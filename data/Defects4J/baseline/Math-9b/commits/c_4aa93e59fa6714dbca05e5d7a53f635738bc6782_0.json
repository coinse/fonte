{"sha": "4aa93e59fa6714dbca05e5d7a53f635738bc6782", "log": "added support for secondary state in ODE step interpolators  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     UNABLE_TO_SOLVE_SINGULAR_PROBLEM(\"unable to solve: singular problem\"),\n     UNBOUNDED_SOLUTION(\"unbounded solution\"),\n     UNKNOWN_MODE(\"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\"),\n-    UNKNOWN_ADDITIONAL_EQUATION(\"unknown additional equation\"),\n     UNKNOWN_PARAMETER(\"unknown parameter {0}\"),\n-    UNMATCHED_ODE_IN_EXTENDED_SET(\"ode does not match the main ode set in the extended set\"),\n+    UNMATCHED_ODE_IN_EXPANDED_SET(\"ode does not match the main ode set in the extended set\"),\n     CANNOT_PARSE_AS_TYPE(\"string {0} unparseable (from position {1}) as an object of type {2}\"), /* keep */\n     CANNOT_PARSE(\"string {0} unparseable (from position {1})\"), /* keep */\n     UNPARSEABLE_3D_VECTOR(\"unparseable 3D vector: \\\"{0}\\\"\"),\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n  * @version $Id$\n  * @since 2.0\n  */\n-public abstract class AbstractIntegrator implements ExpandableFirstOrderIntegrator {\n+public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n \n     /** Step handler. */\n     protected Collection<StepHandler> stepHandlers;\n     private Incrementor evaluations;\n \n     /** Differential equations to integrate. */\n-    private transient ExpandableFirstOrderDifferentialEquations equations;\n+    private transient ExpandableStatefulODE equations;\n \n     /** Build an instance.\n      * @param name name of the method\n         evaluations.resetCount();\n     }\n \n-    /** Set the differential equations.\n-     * @param equations differential equations to integrate\n-     * @see #computeDerivatives(double, double[], double[])\n-     */\n-    protected void setEquations(final ExpandableFirstOrderDifferentialEquations equations) {\n+    /** Set the equations.\n+     * @param equations equations to set\n+     */\n+    protected void setEquations(final ExpandableStatefulODE equations) {\n         this.equations = equations;\n     }\n \n     /** {@inheritDoc} */\n-    public double integrate(FirstOrderDifferentialEquations equations,\n-                            double t0, double[] y0, double t, double[] y)\n+    public double integrate(final FirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] y0, final double t, final double[] y)\n         throws MathIllegalStateException, MathIllegalArgumentException {\n-        return integrate(new ExpandableFirstOrderDifferentialEquations(equations), t0, y0, t, y);\n-    }\n+\n+        if (y0.length != equations.getDimension()) {\n+            throw new DimensionMismatchException(y0.length, equations.getDimension());\n+        }\n+        if (y.length != equations.getDimension()) {\n+            throw new DimensionMismatchException(y.length, equations.getDimension());\n+        }\n+\n+        // prepare expandable stateful equations\n+        final ExpandableStatefulODE expandable = new ExpandableStatefulODE(equations);\n+        expandable.setTime(t0);\n+        expandable.setPrimaryState(y0);\n+\n+        // perform integration\n+        integrate(expandable, t);\n+\n+        // extract results back from the stateful equations\n+        System.arraycopy(expandable.getPrimaryState(), 0, y, 0, y.length);\n+        return expandable.getTime();\n+\n+    }\n+\n+    /** Integrate a set of differential equations up to the given time.\n+     * <p>This method solves an Initial Value Problem (IVP).</p>\n+     * <p>The set of differential equations is composed of a main set, which\n+     * can be extended by some sets of secondary equations. The set of\n+     * equations must be already set up with initial time and partial states.\n+     * At integration completion, the final time and partial states will be\n+     * available in the same object.</p>\n+     * <p>Since this method stores some internal state variables made\n+     * available in its public interface during integration ({@link\n+     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n+     * @param equations complete set of differential equations to integrate\n+     * @param t target time for the integration\n+     * (can be set to a value smaller than <code>t0</code> for backward integration)\n+     * @throws MathIllegalStateException if the integrator cannot perform integration\n+     * @throws MathIllegalArgumentException if integration parameters are wrong (typically\n+     * too small integration span)\n+     */\n+    public abstract void integrate(ExpandableStatefulODE equations, double t)\n+        throws MathIllegalStateException, MathIllegalArgumentException;\n \n     /** Compute the derivatives and check the number of evaluations.\n      * @param t current value of the independent <I>time</I> variable\n \n     }\n \n-    /** Perform some sanity checks on the integration parameters.\n-     * @param ode differential equations set\n-     * @param t0 start time\n-     * @param y0 state vector at t0\n+    /** Check the integration span.\n      * @param t target time for the integration\n-     * @param y placeholder where to put the state vector\n-     * @exception DimensionMismatchException if some inconsistency is detected\n      * @exception NumberIsTooSmallException if integration span is too small\n      */\n-    protected void sanityChecks(final ExpandableFirstOrderDifferentialEquations ode,\n-                                final double t0, final double[] y0,\n-                                final double t, final double[] y)\n-        throws DimensionMismatchException, NumberIsTooSmallException {\n-\n-        if (ode.getMainSetDimension() != y0.length) {\n-            throw new DimensionMismatchException(ode.getDimension(), y0.length);\n+    protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n+        throws NumberIsTooSmallException {\n+\n+        final double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\n+                                                                  FastMath.abs(t)));\n+        final double dt = FastMath.abs(equations.getTime() - t);\n+        if (dt <= threshold) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n+                                                dt, threshold, false);\n         }\n \n-        if (ode.getMainSetDimension() != y.length) {\n-            throw new DimensionMismatchException(ode.getDimension(), y.length);\n-        }\n-\n-        if (FastMath.abs(t - t0) <= 1.0e-12 * FastMath.max(FastMath.abs(t0), FastMath.abs(t))) {\n-            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n-                                                FastMath.abs(t - t0),\n-                                                1.0e-12 * FastMath.max(FastMath.abs(t0), FastMath.abs(t)),\n-                                                false);\n-        }\n-\n     }\n \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/EquationsMapper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+\n+/**\n+ * Class mapping the part of a complete state or derivative that pertains\n+ * to a specific differential equation.\n+ * <p>\n+ * Instances of this class are guaranteed to be immutable.\n+ * </p>\n+ * @see SecondaryEquations\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class EquationsMapper implements Serializable {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20110925L;\n+\n+    /** Index of the first equation element in complete state arrays. */\n+    final int firstIndex;\n+\n+    /** Dimension of the secondary state parameters. */\n+    final int dimension;\n+\n+    /** simple constructor.\n+     * @param firstIndex index of the first equation element in complete state arrays\n+     * @param dimension dimension of the secondary state parameters\n+     */\n+    public EquationsMapper(final int firstIndex, final int dimension) {\n+        this.firstIndex = firstIndex;\n+        this.dimension  = dimension;\n+    }\n+\n+    /** Get the index of the first equation element in complete state arrays.\n+     * @return index of the first equation element in complete state arrays\n+     */\n+    public int getFirstIndex() {\n+        return firstIndex;\n+    }\n+\n+    /** Get the dimension of the secondary state parameters.\n+     * @return dimension of the secondary state parameters\n+     */\n+    public int getDimension() {\n+        return dimension;\n+    }\n+\n+    /** Extract equation data from a complete state or derivative array.\n+     * @param complete complete state or derivative array from which\n+     * equation data should be retrieved\n+     * @param equationData placeholder where to put equation data\n+     * @throws DimensionMismatchException if the dimension of the equation data does not\n+     * match the mapper dimension\n+     */\n+    public void extractEquationData(double[] complete, double[] equationData)\n+        throws DimensionMismatchException {\n+        if (equationData.length != dimension) {\n+            throw new DimensionMismatchException(equationData.length, dimension);\n+        }\n+        System.arraycopy(complete, firstIndex, equationData, 0, dimension);\n+    }\n+\n+    /** Insert equation data into a complete state or derivative array.\n+     * @param equationData equation data to be inserted into the complete array\n+     * @param complete placeholder where to put equation data (only the\n+     * part corresponding to the equation will be overwritten)\n+     * @throws DimensionMismatchException if the dimension of the equation data does not\n+     * match the mapper dimension\n+     */\n+    public void insertEquationData(double[] equationData, double[] complete)\n+        throws DimensionMismatchException {\n+        if (equationData.length != dimension) {\n+            throw new DimensionMismatchException(equationData.length, dimension);\n+        }\n+        System.arraycopy(equationData, 0, complete, firstIndex, dimension);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ExpandableStatefulODE.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+\n+\n+/**\n+ * This class represents a combined set of first order differential equations,\n+ * with at least a primary set of equations expandable by some sets of secondary\n+ * equations.\n+ * <p>\n+ * One typical use case is the computation of the Jacobian matrix for some ODE.\n+ * In this case, the primary set of equations corresponds to the raw ODE, and we\n+ * add to this set another bunch of secondary equations which represent the Jacobian\n+ * matrix of the primary set.\n+ * </p>\n+ * <p>\n+ * We want the integrator to use <em>only</em> the primary set to estimate the\n+ * errors and hence the step sizes. It should <em>not</em> use the secondary\n+ * equations in this computation. The {@link AbstractIntegrator integrator} will\n+ * be able to know where the primary set ends and so where the secondary sets begin.\n+ * </p>\n+ *\n+ * @see FirstOrderDifferentialEquations\n+ * @see JacobianMatrices\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public class ExpandableStatefulODE {\n+\n+    /** Primary differential equation. */\n+    private final FirstOrderDifferentialEquations primary;\n+\n+    /** Mapper for primary equation. */\n+    private final EquationsMapper primaryMapper;\n+\n+    /** Time. */\n+    private double time;\n+\n+    /** State. */\n+    private final double[] primaryState;\n+\n+    /** State derivative. */\n+    private final double[] primaryStateDot;\n+\n+    /** Components of the expandable ODE. */\n+    private List<SecondaryComponent> components;\n+\n+    /** Build an expandable set from its primary ODE set.\n+     * @param ode the primary set of differential equations to be integrated.\n+     */\n+    public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {\n+        final int n          = primary.getDimension();\n+        this.primary         = primary;\n+        this.primaryMapper   = new EquationsMapper(0, n);\n+        this.time            = Double.NaN;\n+        this.primaryState    = new double[n];\n+        this.primaryStateDot = new double[n];\n+        this.components      = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();\n+    }\n+\n+    /** Get the primary set of differential equations.\n+     * @return primary set of differential equations\n+     */\n+    public FirstOrderDifferentialEquations getPrimary() {\n+        return primary;\n+    }\n+\n+    /** Return the dimension of the complete set of equations.\n+     * <p>\n+     * The complete set of equations correspond to the primary set plus all secondary sets.\n+     * </p>\n+     * @return dimension of the complete set of equations\n+     */\n+    public int getTotalDimension() {\n+        if (components.isEmpty()) {\n+            // there are no secondary equations, the complete set is limited to the primary set\n+            return primaryMapper.getDimension();\n+        } else {\n+            // there are secondary equations, the complete set ends after the last set\n+            final EquationsMapper lastMapper = components.get(components.size() - 1).mapper;\n+            return lastMapper.getFirstIndex() + lastMapper.getDimension();\n+        }\n+    }\n+\n+    /** Get the current time derivative of the complete state vector.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the complete state vector\n+     * @param yDot placeholder array where to put the time derivative of the complete state vector\n+     */\n+    public void computeDerivatives(final double t, final double[] y, final double[] yDot) {\n+\n+        // compute derivatives of the primary equations\n+        primaryMapper.extractEquationData(y, primaryState);\n+        primary.computeDerivatives(t, primaryState, primaryStateDot);\n+        primaryMapper.insertEquationData(primaryStateDot, yDot);\n+\n+        // Add contribution for secondary equations\n+        for (final SecondaryComponent component : components) {\n+            component.mapper.extractEquationData(y, component.state);\n+            component.equation.computeDerivatives(t, primaryState, primaryStateDot,\n+                                                  component.state, component.stateDot);\n+            component.mapper.insertEquationData(component.stateDot, yDot);\n+        }\n+\n+    }\n+\n+    /** Add a set of secondary equations to be integrated along with the primary set.\n+     * @param secondary secondary equations set\n+     * @return index of the secondary equation in the expanded state\n+     */\n+    public int addSecondaryEquations(final SecondaryEquations secondary) {\n+\n+        final int firstIndex;\n+        if (components.isEmpty()) {\n+            // lazy creation of the components list\n+            components = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();\n+            firstIndex = primary.getDimension();\n+        } else {\n+            final SecondaryComponent last = components.get(components.size() - 1);\n+            firstIndex = last.mapper.getFirstIndex() + last.mapper.getDimension();\n+        }\n+\n+        components.add(new SecondaryComponent(secondary, firstIndex));\n+\n+        return components.size() - 1;\n+\n+    }\n+\n+    /** Get an equations mapper for the primary equations set.\n+     * @return mapper for the primary set\n+     * @see #getSecondaryMappers()\n+     */\n+    public EquationsMapper getPrimaryMapper() {\n+        return primaryMapper;\n+    }\n+\n+    /** Get the equations mappers for the secondary equations sets.\n+     * @return equations mappers for the secondary equations sets\n+     * @see #getPrimaryMapper()\n+     */\n+    public EquationsMapper[] getSecondaryMappers() {\n+        final EquationsMapper[] mappers = new EquationsMapper[components.size()];\n+        for (int i = 0; i < mappers.length; ++i) {\n+            mappers[i] = components.get(i).mapper;\n+        }\n+        return mappers;\n+    }\n+\n+    /** Set current time.\n+     * @param time current time\n+     */\n+    public void setTime(final double time) {\n+        this.time = time;\n+    }\n+\n+    /** Get current time.\n+     * @return current time\n+     */\n+    public double getTime() {\n+        return time;\n+    }\n+\n+    /** Set primary part of the current state.\n+     * @param primaryState primary part of the current state\n+     * @throws DimensionMismatchException if the dimension of the array does not\n+     * match the primary set\n+     */\n+    public void setPrimaryState(final double[] primaryState) throws DimensionMismatchException {\n+\n+        // safety checks\n+        if (primaryState.length != this.primaryState.length) {\n+            throw new DimensionMismatchException(primaryState.length, this.primaryState.length);\n+        }\n+\n+        // set the data\n+        System.arraycopy(primaryState, 0, this.primaryState, 0, primaryState.length);\n+\n+    }\n+\n+    /** Get primary part of the current state.\n+     * @return primary part of the current state\n+     */\n+    public double[] getPrimaryState() {\n+        return primaryState.clone();\n+    }\n+\n+    /** Get primary part of the current state derivative.\n+     * @return primary part of the current state derivative\n+     */\n+    public double[] getPrimaryStateDot() {\n+        return primaryStateDot.clone();\n+    }\n+\n+    /** Set secondary part of the current state.\n+     * @param index index of the part to set as returned by {@link\n+     * #addSecondaryEquations(SecondaryEquations)}\n+     * @param secondaryState secondary part of the current state\n+     * @throws DimensionMismatchException if the dimension of the partial state does not\n+     * match the selected equations set dimension\n+     */\n+    public void setSecondaryState(final int index, final double[] secondaryState)\n+        throws DimensionMismatchException {\n+\n+        // get either the secondary state\n+        double[] localArray = components.get(index).state;\n+\n+        // safety checks\n+        if (secondaryState.length != localArray.length) {\n+            throw new DimensionMismatchException(secondaryState.length, localArray.length);\n+        }\n+\n+        // set the data\n+        System.arraycopy(secondaryState, 0, localArray, 0, secondaryState.length);\n+\n+    }\n+\n+    /** Get secondary part of the current state.\n+     * @param index index of the part to set as returned by {@link\n+     * #addSecondaryEquations(SecondaryEquations)}\n+     * @return secondary part of the current state\n+     */\n+    public double[] getSecondaryState(final int index) {\n+        return components.get(index).state.clone();\n+    }\n+\n+    /** Get secondary part of the current state derivative.\n+     * @param index index of the part to set as returned by {@link\n+     * #addSecondaryEquations(SecondaryEquations)}\n+     * @return secondary part of the current state derivative\n+     */\n+    public double[] getSecondaryStateDot(final int index) {\n+        return components.get(index).stateDot.clone();\n+    }\n+\n+    /** Set the complete current state.\n+     * @param completeState complete current state to copy data from\n+     * @throws DimensionMismatchException if the dimension of the complete state does not\n+     * match the complete equations sets dimension\n+     */\n+    public void setCompleteState(final double[] completeState)\n+        throws DimensionMismatchException {\n+\n+        // safety checks\n+        if (completeState.length != getTotalDimension()) {\n+            throw new DimensionMismatchException(completeState.length, getTotalDimension());\n+        }\n+\n+        // set the data\n+        primaryMapper.extractEquationData(completeState, primaryState);\n+        for (final SecondaryComponent component : components) {\n+            component.mapper.extractEquationData(completeState, component.state);\n+        }\n+\n+    }\n+\n+    /** Get the complete current state.\n+     * @return complete current state\n+     * @throws DimensionMismatchException if the dimension of the complete state does not\n+     * match the complete equations sets dimension\n+     */\n+    public double[] getCompleteState() {\n+\n+        // allocate complete array\n+        double[] completeState = new double[getTotalDimension()];\n+\n+        // set the data\n+        primaryMapper.insertEquationData(primaryState, completeState);\n+        for (final SecondaryComponent component : components) {\n+            component.mapper.insertEquationData(component.state, completeState);\n+        }\n+\n+        return completeState;\n+\n+    }\n+\n+    /** Components of the compound stateful ODE. */\n+    private static class SecondaryComponent {\n+\n+        \n+        /** Secondary differential equation. */\n+        private final SecondaryEquations equation;\n+\n+        /** Mapper between local and complete arrays. */\n+        private final EquationsMapper mapper;\n+\n+        /** State. */\n+        private final double[] state;\n+\n+        /** State derivative. */\n+        private final double[] stateDot;\n+\n+        /** Simple constructor.\n+         * @param equation secondary differential equation\n+         * @param first index index to use for the first element in the complete arrays\n+         */\n+        public SecondaryComponent(final SecondaryEquations equation, final int firstIndex) {\n+            final int n   = equation.getDimension();\n+            this.equation = equation;\n+            mapper        = new EquationsMapper(firstIndex, n);\n+            state         = new double[n];\n+            stateDot      = new double[n];\n+        }\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/ode/JacobianMatrices.java\n+++ b/src/main/java/org/apache/commons/math/ode/JacobianMatrices.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n- * This class defines a set of {@link AdditionalEquations additional equations} to\n- * compute the jacobian matrices with respect to the initial state vector and, if\n- * any, to some parameters of the main ODE set.\n+ * This class defines a set of {@link SecondaryEquations secondary equations} to\n+ * compute the Jacobian matrices with respect to the initial state vector and, if\n+ * any, to some parameters of the primary ODE set.\n  * <p>\n- * It is intended to be packed into an {@link ExpandableFirstOrderDifferentialEquations}\n- * in conjunction with a main set of ODE, which may be:\n+ * It is intended to be packed into an {@link ExpandableStatefulODE}\n+ * in conjunction with a primary set of ODE, which may be:\n  * <ul>\n  * <li>a {@link FirstOrderDifferentialEquations}</li>\n  * <li>a {@link MainStateJacobianProvider}</li>\n  * </ul>\n- * In order to compute jacobian matrices with respect to some parameters of the\n- * main ODE set, the following parameter jacobian providers may be set:\n+ * In order to compute Jacobian matrices with respect to some parameters of the\n+ * primary ODE set, the following parameter Jacobian providers may be set:\n  * <ul>\n  * <li>a {@link ParameterJacobianProvider}</li>\n  * <li>a {@link ParameterizedODE}</li>\n  * </ul>\n  * </p>\n  *\n- * @see ExpandableFirstOrderDifferentialEquations\n+ * @see ExpandableStatefulODE\n  * @see FirstOrderDifferentialEquations\n  * @see MainStateJacobianProvider\n  * @see ParameterJacobianProvider\n  * @version $Id$\n  * @since 3.0\n  */\n-public class JacobianMatrices implements AdditionalEquations {\n+public class JacobianMatrices {\n \n     /** Expandable first order differential equation. */\n-    private ExpandableFirstOrderDifferentialEquations efode;\n-\n-    /** FODE without exact main jacobian computation skill. */\n-    private FirstOrderDifferentialEquations fode = null;\n-\n-    /** FODE with exact main jacobian computation skill. */\n-    private MainStateJacobianProvider jode = null;\n-\n-    /** FODE without exact parameter jacobian computation skill. */\n-    private ParameterizedODE pode = null;\n-\n-    /** FODE with exact parameter jacobian computation skill. */\n-    private List<ParameterJacobianProvider> pjp = new ArrayList<ParameterJacobianProvider>();;\n-\n-    /** List of parameters selected for parameter jacobian computation. */\n-    private List<ParameterConfiguration> selectedParameters = null;\n+    private ExpandableStatefulODE efode;\n+\n+    /** Index of the instance in the expandable set. */\n+    private int index;\n+\n+    /** FODE with exact primary Jacobian computation skill. */\n+    private MainStateJacobianProvider jode;\n+\n+    /** FODE without exact parameter Jacobian computation skill. */\n+    private ParameterizedODE pode;\n \n     /** Main state vector dimension. */\n     private int stateDim;\n \n+    /** Selected parameters for parameter Jacobian computation. */\n+    private ParameterConfiguration[] selectedParameters;\n+\n+    /** FODE with exact parameter Jacobian computation skill. */\n+    private List<ParameterJacobianProvider> jacobianProviders;\n+\n     /** Parameters dimension. */\n-    private int paramDim = 0;\n-\n-    /** Current main state jacobian matrix in a row. */\n-    private double[] mainJacobianInARow;\n-\n-    /** Current parameters jacobian matrices in a row. */\n-    private double[] parameterJacobiansInARow = null;\n-\n-    /** Step used for finite difference computation of jacobian matrix\n-     *  w.r.t. main state vector. */\n-    private double[] hY = null;\n-\n-    /** Boolean for fode consistency. */\n-    private boolean dirtyMainState = false;\n+    private int paramDim;\n \n     /** Boolean for selected parameters consistency. */\n-    private boolean dirtyParameter = false;\n-\n-    /** Simple constructor for an additional equations set computing jacobian matrices.\n-     * <p>This additional equations set is added internally to the expandable\n-     * first order differential equations set thanks to the\n-     * {@link ExpandableFirstOrderDifferentialEquations#addAdditionalEquations(AdditionalEquations)}\n-     * method.\n-     * @param extended the expandable first order differential equations set\n-     * @param jode the main first order differential equations set to extend\n-     * @exception IllegalArgumentException if jode does not match the main set to be extended given by\n-     *            {@link ExpandableFirstOrderDifferentialEquations#getMainSet() extended.getMainSet()}\n-     */\n-    public JacobianMatrices(final ExpandableFirstOrderDifferentialEquations extended,\n-                            final MainStateJacobianProvider jode)\n-        throws IllegalArgumentException {\n-\n-        checkCompatibility(extended, jode);\n-\n-        efode = extended;\n-        stateDim = efode.getMainSetDimension();\n-        mainJacobianInARow = new double[stateDim * stateDim];\n+    private boolean dirtyParameter;\n+\n+    /** State and parameters Jacobian matrices in a row. */\n+    private double[] matricesData;\n+\n+    /** Simple constructor for a secondary equations set computing Jacobian matrices.\n+     * <p>\n+     * Parameters must belong to the supported ones given by {@link\n+     * Parameterizable#getParametersNames()}, so the primary set of differential\n+     * equations must be {@link Parameterizable}.\n+     * </p>\n+     * <p>Note that each selection clears the previous selected parameters.</p>\n+     *\n+     * @param fode the primary first order differential equations set to extend\n+     * @param hY step used for finite difference computation with respect to state vector\n+     * @param parameters parameters to consider for Jacobian matrices processing\n+     * (may be null if parameters Jacobians is not desired)\n+     * @exception MathIllegalArgumentException if one parameter is not supported\n+     * or there is a dimension mismatch with {@code hY}\n+     */\n+    public JacobianMatrices(final FirstOrderDifferentialEquations fode, final double[] hY,\n+                            final String... parameters)\n+        throws MathIllegalArgumentException {\n+        this(new MainStateJacobianWrapper(fode, hY), parameters);\n+    }\n+\n+    /** Simple constructor for a secondary equations set computing Jacobian matrices.\n+     * <p>\n+     * Parameters must belong to the supported ones given by {@link\n+     * Parameterizable#getParametersNames()}, so the primary set of differential\n+     * equations must be {@link Parameterizable}.\n+     * </p>\n+     * <p>Note that each selection clears the previous selected parameters.</p>\n+     *\n+     * @param jode the primary first order differential equations set to extend\n+     * @param parameters parameters to consider for Jacobian matrices processing\n+     * (may be null if parameters Jacobians is not desired)\n+     * @exception MathIllegalArgumentException if one parameter is not supported\n+     */\n+    public JacobianMatrices(final MainStateJacobianProvider jode,\n+                            final String... parameters)\n+        throws MathIllegalArgumentException {\n+\n+        this.efode = null;\n+        this.index = -1;\n+\n         this.jode = jode;\n-        efode.addAdditionalEquations(this);\n-        setInitialMainStateJacobian();\n-    }\n-\n-    /** Simple constructor for an additional equations set computing jacobian matrices.\n-     * <p>This additional equations set is added internally to the expandable\n-     * first order differential equations set thanks to the\n-     * {@link ExpandableFirstOrderDifferentialEquations#addAdditionalEquations(AdditionalEquations)}\n-     * method.\n-     * @param extended the expandable first order differential equations set\n-     * @param fode the main first order differential equations set to extend\n-     * @exception IllegalArgumentException if fode does not match the main set to be extended given by\n-     *            {@link ExpandableFirstOrderDifferentialEquations#getMainSet() extended.getMainSet()}\n-     */\n-    public JacobianMatrices(final ExpandableFirstOrderDifferentialEquations extended,\n-                            final FirstOrderDifferentialEquations fode)\n-        throws IllegalArgumentException {\n-\n-        checkCompatibility(extended, fode);\n-\n-        efode = extended;\n-        stateDim = efode.getMainSetDimension();\n-        mainJacobianInARow = new double[stateDim * stateDim];\n-        this.fode = fode;\n-        dirtyMainState = true;\n-        efode.addAdditionalEquations(this);\n-        setInitialMainStateJacobian();\n-    }\n-\n-    /** Add a parameter jacobian provider.\n-     * @param pjp the parameter jacobian provider to compute exactly the parameter jacobian matrix\n-     */\n-    public void setParameterJacobianProvider(final ParameterJacobianProvider pjp) {\n-        this.pjp.add(pjp);\n-    }\n-\n-    /** Add a parameter jacobian provider.\n-     * @param pjp the parameterized ODE to compute by finite difference the parameter jacobian matrix\n+        this.pode = null;\n+\n+        this.stateDim = jode.getDimension();\n+\n+        if (parameters == null) {\n+            selectedParameters = null;\n+            paramDim = 0;\n+        } else {\n+            this.selectedParameters = new ParameterConfiguration[parameters.length];\n+            for (int i = 0; i < parameters.length; ++i) {\n+                selectedParameters[i] = new ParameterConfiguration(parameters[i], Double.NaN);\n+            }\n+            paramDim = parameters.length;\n+        }\n+        this.dirtyParameter = false;\n+\n+        this.jacobianProviders = new ArrayList<ParameterJacobianProvider>();\n+\n+        // set the default initial state Jacobian to the identity\n+        // and the default initial parameters Jacobian to the null matrix\n+        matricesData = new double[(stateDim + paramDim) * stateDim];\n+        for (int i = 0; i < stateDim; ++i) {\n+            matricesData[i * (stateDim + 1)] = 1.0;\n+        }\n+\n+    }\n+\n+    /** Register the variational equations for the Jacobians matrices to the expandable set.\n+     * @exception MathIllegalArgumentException if the primary set of the expandable set does\n+     * not match the one used to build the instance\n+     * @see ExpandableStatefulODE#addSecondaryEquations(SecondaryEquations)\n+     */\n+    public void registerVariationalEquations(final ExpandableStatefulODE expandable)\n+        throws MathIllegalArgumentException {\n+\n+        // safety checks\n+        final FirstOrderDifferentialEquations ode = (jode instanceof MainStateJacobianWrapper) ?\n+                                                    ((MainStateJacobianWrapper) jode).ode :\n+                                                    jode;\n+        if (expandable.getPrimary() != ode) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.UNMATCHED_ODE_IN_EXPANDED_SET);\n+        }\n+\n+        efode = expandable;\n+        index = efode.addSecondaryEquations(new JacobiansSecondaryEquations());\n+        efode.setSecondaryState(index, matricesData);\n+\n+    }\n+\n+    /** Add a parameter Jacobian provider.\n+     * @param provider the parameter Jacobian provider to compute exactly the parameter Jacobian matrix\n+     */\n+    public void addParameterJacobianProvider(final ParameterJacobianProvider provider) {\n+        jacobianProviders.add(provider);\n+    }\n+\n+    /** Add a parameter Jacobian provider.\n+     * @param pode the parameterized ODE to compute the parameter Jacobian matrix using finite differences \n      */\n     public void setParameterizedODE(final ParameterizedODE pode) {\n         this.pode = pode;\n         dirtyParameter = true;\n     }\n \n-    /** Select the parameters to consider for jacobian matrices processing.\n-     * <p>\n-     * Parameters must belong to the supported ones given by {@link\n-     * Parameterizable#getParametersNames()}, so the main set of differential\n-     * equations must be {@link Parameterizable}.\n-     * </p>\n-     * <p>Note that each selection clears the previous selected parameters.</p>\n-     *\n-     * @param parameters parameters to consider for jacobian matrices processing\n-     * @exception IllegalArgumentException if one parameter is not supported\n-     */\n-    public void selectParameters(final String... parameters) throws IllegalArgumentException {\n-        \n-        selectedParameters = new ArrayList<ParameterConfiguration>();\n-        for (String param : parameters) {\n-            selectedParameters.add(new ParameterConfiguration(param, Double.NaN));\n-        }\n-        paramDim = parameters.length;\n-        parameterJacobiansInARow = new double[paramDim * stateDim];\n-        setInitialParameterJacobians();\n-    }\n-\n     /** Set the step associated to a parameter in order to compute by finite\n-     *  difference the jacobian matrix.\n-     * <p>\n-     * Needed if and only if the main ODE set is a {@link ParameterizedODE}\n-     * and the parameter has been {@link #selectParameters(String ...) selected}\n-     * </p>\n-     * <p>\n-     * For pval, a non zero value of the parameter, pval * Math.sqrt(MathUtils.EPSILON)\n-     * is a reasonable value for such a step.\n-     * </p>\n-     * <p>\n-     * A zero value for such a step doesn't enable to compute the parameter jacobian matrix.\n-     * </p>\n-     * @param parameter parameter to consider for jacobian processing\n-     * @param hP step for jacobian finite difference computation w.r.t. the specified parameter\n+     *  difference the Jacobian matrix.\n+     * <p>\n+     * Needed if and only if the primary ODE set is a {@link ParameterizedODE}.\n+     * </p>\n+     * <p>\n+     * Given a non zero parameter value pval for the parameter, a reasonable value\n+     * for such a step is {@code pval * FastMath.sqrt(MathUtils.EPSILON)}.\n+     * </p>\n+     * <p>\n+     * A zero value for such a step doesn't enable to compute the parameter Jacobian matrix.\n+     * </p>\n+     * @param parameter parameter to consider for Jacobian processing\n+     * @param hP step for Jacobian finite difference computation w.r.t. the specified parameter\n      * @see ParameterizedODE\n      * @exception IllegalArgumentException if the parameter is not supported\n      */\n     public void setParameterStep(final String parameter, final double hP) {\n \n-        boolean found = false;\n         for (ParameterConfiguration param: selectedParameters) {\n             if (parameter.equals(param.getParameterName())) {\n                 param.setHP(hP);\n-                found = true;\n                 dirtyParameter = true;\n-                break;\n-            }\n-        }\n-        if (!found) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n-                                                   parameter);\n-        }\n-    }\n-\n-    /** Set the steps in order to compute by finite difference the jacobian\n-     *  matrix with respect to main state.\n-     * <p>\n-     * Needed if and only if the main set is a {@link FirstOrderDifferentialEquations}.\n-     * </p>\n-     * <p>\n-     * Zero values for those steps don't enable to compute the main state jacobian matrix.\n-     * </p>\n-     * @param hY step used for finite difference computation with respect to state vector\n-     * @exception IllegalArgumentException if the hY has not the dimension of the main state\n-     * given by {@link ExpandableFirstOrderDifferentialEquations#getMainSetDimension()}\n-     */\n-    public void setMainStateSteps(final double[] hY) {\n-\n-        if (fode != null) {\n-            // Check dimension\n-            checkDimension(stateDim, hY);\n-            this.hY = hY.clone();\n-            dirtyMainState = true;           \n-        }\n-    }\n-\n-    /** Set the initial value of the jacobian matrix with respect to state.\n-     * @param dYdY0 initial jacobian matrix w.r.t. state\n+                return;\n+            }\n+        }\n+\n+        throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, parameter);\n+\n+    }\n+\n+    /** Set the initial value of the Jacobian matrix with respect to state.\n+     * <p>\n+     * If this method is not called, the initial value of the Jacobian\n+     * matrix with respect to state is set to identity.\n+     * </p>\n+     * @param dYdY0 initial Jacobian matrix w.r.t. state\n      * @exception IllegalArgumentException if matrix dimensions are incorrect\n      */\n-    public void setInitialMainStateJacobian(final double[][] dYdY0) {\n+    public void setInitialMainStateJacobian(final double[][] dYdY0)\n+        throws MathIllegalArgumentException {\n \n         // Check dimensions\n         checkDimension(stateDim, dYdY0);\n         checkDimension(stateDim, dYdY0[0]);\n \n         // store the matrix in row major order as a single dimension array\n-        int index = 0;\n+        int i = 0;\n         for (final double[] row : dYdY0) {\n-            System.arraycopy(row, 0, mainJacobianInARow, index, stateDim);\n-            index += stateDim;\n-        }\n-        // set initial additional state value in expandable fode\n-        efode.setInitialAdditionalState(mainJacobianInARow, this);\n-    }\n-\n-    /** Set the initial value of the jacobian matrix with respect to one parameter.\n-     * <p>The parameter must be {@link #selectParameters(String...) selected}.</p>\n+            System.arraycopy(row, 0, matricesData, i, stateDim);\n+            i += stateDim;\n+        }\n+\n+        if (efode != null) {\n+            efode.setSecondaryState(index, matricesData);\n+        }\n+\n+    }\n+\n+    /** Set the initial value of a column of the Jacobian matrix with respect to one parameter.\n+     * <p>\n+     * If this method is not called for some parameter, the initial value of\n+     * the column of the Jacobian matrix with respect to this parameter is set to zero.\n+     * </p>\n      * @param pName parameter name\n-     * @param dYdP initial jacobian matrix w.r.t. the parameter\n-     * @exception IllegalArgumentException if matrix dimensions are incorrect\n-     */\n-    public void setInitialParameterJacobian(final String pName, final double[] dYdP) {\n+     * @param dYdP initial Jacobian column vector with respect to the parameter\n+     * @exception MathIllegalArgumentException if a parameter is not supported\n+     */\n+    public void setInitialParameterJacobian(final String pName, final double[] dYdP)\n+        throws MathIllegalArgumentException {\n \n         // Check dimensions\n         checkDimension(stateDim, dYdP);\n \n-        // store the matrix in a global single dimension array\n-        boolean found = false;\n-        int index = 0;\n+        // store the column in a global single dimension array\n+        int i = stateDim * stateDim;\n         for (ParameterConfiguration param: selectedParameters) {\n             if (pName.equals(param.getParameterName())) {\n-                System.arraycopy(dYdP, 0, parameterJacobiansInARow, index, stateDim);\n-                double[] p = new double[this.getDimension()];\n-                index = stateDim * stateDim;\n-                System.arraycopy(mainJacobianInARow, 0, p, 0, index);\n-                System.arraycopy(parameterJacobiansInARow, 0, p, index, stateDim * paramDim);\n-                // set initial additional state value in expandable fode\n-                efode.setInitialAdditionalState(p, this);\n-                found = true;\n-                break;\n-            }\n-            index += stateDim;\n-        }\n-        if (! found) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n-                                                   pName);\n-        }\n-    }\n-\n-    /** Set the default initial value of the jacobian matrix with respect to state.\n-     * <p>dYdY0 is set to the identity matrix.</p>\n-     */\n-    public void setInitialMainStateJacobian() {\n-        final double[][] dYdY0 = new double[stateDim][stateDim];\n-        for (int i = 0; i < stateDim; ++i) {\n-            dYdY0[i][i] = 1.0;\n-        }\n-        setInitialMainStateJacobian(dYdY0);\n-    }\n-\n-    /** Set the default initial value of the jacobian matrix with respect to one parameter.\n-     * <p>The parameter must be {@link #selectParameters(String...) selected}.</p>\n-     * <p>dYdP is set to the null matrix.</p>\n-     * @param pName parameter name\n-     */\n-    public void setInitialParameterJacobian(final String pName) {\n-        setInitialParameterJacobian(pName, new double[stateDim]);\n-    }\n-\n-    /** Set the default initial values of jacobian matrices with respect to all parameters.\n-     */\n-    public void setInitialParameterJacobians() {\n-        for (ParameterConfiguration param: selectedParameters) {\n-            setInitialParameterJacobian(param.getParameterName());\n-        }\n-    }\n-\n-    /** Set default initial values for jacobian matrices.\n-     * <p>dYdY0 is set to the identity matrix and all dYdP are set to zero.</p>\n-     */\n-    public void setInitialJacobians() {\n-        setInitialMainStateJacobian();\n-        setInitialParameterJacobians();\n-    }\n-\n-    /** Get the current value of the jacobian matrix with respect to state.\n-     * @param dYdY0 current jacobian matrix with respect to state.\n+                System.arraycopy(dYdP, 0, matricesData, i, stateDim);\n+                if (efode != null) {\n+                    efode.setSecondaryState(index, matricesData);\n+                }\n+                return;\n+            }\n+            i += stateDim;\n+        }\n+\n+        throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER, pName);\n+\n+    }\n+\n+    /** Get the current value of the Jacobian matrix with respect to state.\n+     * @param dYdY0 current Jacobian matrix with respect to state.\n      */\n     public void getCurrentMainSetJacobian(final double[][] dYdY0) {\n \n         // get current state for this set of equations from the expandable fode\n-        double[] p = efode.getCurrentAdditionalState(this);\n+        double[] p = efode.getSecondaryState(index);\n \n         int index = 0;\n         for (int i = 0; i < stateDim; i++) {\n \n     }\n \n-    /** Get the current value of the jacobian matrix with respect to one parameter.\n-     * @param pName name of the parameter for the computed jacobian matrix \n-     * @param dYdP current jacobian matrix with respect to the named parameter\n+    /** Get the current value of the Jacobian matrix with respect to one parameter.\n+     * @param pName name of the parameter for the computed Jacobian matrix \n+     * @param dYdP current Jacobian matrix with respect to the named parameter\n      */\n     public void getCurrentParameterJacobian(String pName, final double[] dYdP) {\n \n         // get current state for this set of equations from the expandable fode\n-        double[] p = efode.getCurrentAdditionalState(this);\n+        double[] p = efode.getSecondaryState(index);\n \n         int index = stateDim * stateDim;\n         for (ParameterConfiguration param: selectedParameters) {\n \n     }\n \n-    /** {@inheritDoc} */\n-    public int getDimension() {\n-        return stateDim * (stateDim + paramDim);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void computeDerivatives(final double t, final double[] y, final double[] yDot,\n-                                   final double[] z, final double[] zDot) {\n-\n-        // Lazy initialization\n-        if (dirtyMainState) {\n-            jode = new MainStateJacobianWrapper(fode, hY);\n-            dirtyMainState = false;\n-        }\n-        if (dirtyParameter && (paramDim != 0)) {\n-            pjp.add(new ParameterJacobianWrapper(jode, pode, selectedParameters));\n-            dirtyParameter = false;\n-        }\n-\n-        // variational equations:\n-        // from d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dy0]/dt and d[dy/dp]/dt\n-\n-        // compute jacobian matrix with respect to main state\n-        double[][] dFdY = new double[stateDim][stateDim];\n-        jode.computeMainStateJacobian(t, y, yDot, dFdY);\n-\n-        // Dispatch jacobian matrix in the compound additional state vector\n-        for (int i = 0; i < stateDim; ++i) {\n-            final double[] dFdYi = dFdY[i];\n-            for (int j = 0; j < stateDim; ++j) {\n-                double s = 0;\n-                final int startIndex = j;\n-                int zIndex = startIndex;\n-                for (int l = 0; l < stateDim; ++l) {\n-                    s += dFdYi[l] * z[zIndex];\n-                    zIndex += stateDim;\n-                }\n-                zDot[startIndex + i * stateDim] = s;\n-            }\n-        }\n-\n-        if (paramDim != 0) {\n-            // compute jacobian matrices with respect to parameters\n-            double[] dFdP = new double[stateDim];\n-            int startIndex = stateDim * stateDim;\n-            for (ParameterConfiguration param: selectedParameters) {\n-                boolean found = false;\n-                for (ParameterJacobianProvider provider: pjp) {\n-                    if (provider.isSupported(param.getParameterName())) {\n-                        try {\n-                            provider.computeParameterJacobian(t, y, yDot, param.getParameterName(), dFdP);\n-                            for (int i = 0; i < stateDim; ++i) {\n-                                final double[] dFdYi = dFdY[i];\n-                                int zIndex = startIndex;\n-                                double s = dFdP[i];\n-                                for (int l = 0; l < stateDim; ++l) {\n-                                    s += dFdYi[l] * z[zIndex];\n-                                    zIndex++;\n-                                }\n-                                zDot[startIndex + i] = s;\n-                            }\n-                            startIndex += stateDim;\n-                            found = true;\n-                            break;\n-                        } catch (IllegalArgumentException iae) {\n-                        }\n-                    }\n-                }\n-                if (! found) {\n-                    throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n-                                                           param);\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    /** Check compatibility between the main set in the expandable ode and an ordinary ode.\n-     * @param expended expandable ode containing a main set\n-     * @param ode single ode to check \n-     * @throws MathIllegalArgumentException if single ode doesn't match the main ode set in the extended ode\n-     */\n-    private void checkCompatibility(final ExpandableFirstOrderDifferentialEquations extended,\n-                                    final FirstOrderDifferentialEquations ode)\n-        throws MathIllegalArgumentException {\n-\n-        if (!(ode == extended.getMainSet())) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNMATCHED_ODE_IN_EXTENDED_SET);\n-        }\n-    }\n-\n     /** Check array dimensions.\n      * @param expected expected dimension\n      * @param array (may be null if expected is 0)\n         }\n     }\n \n+    /** Local implementation of secondary equations.\n+     * <p>\n+     * This class is an inner class to ensure proper scheduling of calls\n+     * by forcing the use of {@link JacobianMatrices#registerVariationalEquations(ExpandableStatefulODE)}.\n+     * </p>\n+     */\n+    private class JacobiansSecondaryEquations implements SecondaryEquations {\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            return stateDim * (stateDim + paramDim);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeDerivatives(final double t, final double[] y, final double[] yDot,\n+                                       final double[] z, final double[] zDot) {\n+\n+            // Lazy initialization\n+            if (dirtyParameter && (paramDim != 0)) {\n+                jacobianProviders.add(new ParameterJacobianWrapper(jode, pode, selectedParameters));\n+                dirtyParameter = false;\n+            }\n+\n+            // variational equations:\n+            // from d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dy0]/dt and d[dy/dp]/dt\n+\n+            // compute Jacobian matrix with respect to primary state\n+            double[][] dFdY = new double[stateDim][stateDim];\n+            jode.computeMainStateJacobian(t, y, yDot, dFdY);\n+\n+            // Dispatch Jacobian matrix in the compound secondary state vector\n+            for (int i = 0; i < stateDim; ++i) {\n+                final double[] dFdYi = dFdY[i];\n+                for (int j = 0; j < stateDim; ++j) {\n+                    double s = 0;\n+                    final int startIndex = j;\n+                    int zIndex = startIndex;\n+                    for (int l = 0; l < stateDim; ++l) {\n+                        s += dFdYi[l] * z[zIndex];\n+                        zIndex += stateDim;\n+                    }\n+                    zDot[startIndex + i * stateDim] = s;\n+                }\n+            }\n+\n+            if (paramDim != 0) {\n+                // compute Jacobian matrices with respect to parameters\n+                double[] dFdP = new double[stateDim];\n+                int startIndex = stateDim * stateDim;\n+                for (ParameterConfiguration param: selectedParameters) {\n+                    boolean found = false;\n+                    for (ParameterJacobianProvider provider: jacobianProviders) {\n+                        if (provider.isSupported(param.getParameterName())) {\n+                            try {\n+                                provider.computeParameterJacobian(t, y, yDot, param.getParameterName(), dFdP);\n+                                for (int i = 0; i < stateDim; ++i) {\n+                                    final double[] dFdYi = dFdY[i];\n+                                    int zIndex = startIndex;\n+                                    double s = dFdP[i];\n+                                    for (int l = 0; l < stateDim; ++l) {\n+                                        s += dFdYi[l] * z[zIndex];\n+                                        zIndex++;\n+                                    }\n+                                    zDot[startIndex + i] = s;\n+                                }\n+                                startIndex += stateDim;\n+                                found = true;\n+                                break;\n+                            } catch (IllegalArgumentException iae) {\n+                            }\n+                        }\n+                    }\n+                    if (! found) {\n+                        throw new MathIllegalArgumentException(LocalizedFormats.UNKNOWN_PARAMETER,\n+                                                               param);\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    /** Wrapper class to compute jacobian matrices by finite differences for ODE\n+     *  which do not compute them by themselves.\n+     */\n+    private static class MainStateJacobianWrapper implements MainStateJacobianProvider {\n+\n+        /** Raw ODE without jacobians computation skill to be wrapped into a MainStateJacobianProvider. */\n+        private final FirstOrderDifferentialEquations ode;\n+\n+        /** Steps for finite difference computation of the jacobian df/dy w.r.t. state. */\n+        private final double[] hY;\n+\n+        /** Wrap a {@link FirstOrderDifferentialEquations} into a {@link MainStateJacobianProvider}.\n+         * @param ode original ODE problem, without jacobians computation skill\n+         * @param hY step sizes to compute the jacobian df/dy\n+         * @see JacobianMatrices#setMainStateSteps(double[])\n+         */\n+        public MainStateJacobianWrapper(final FirstOrderDifferentialEquations ode,\n+                                        final double[] hY) {\n+            this.ode = ode;\n+            this.hY = hY.clone();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            return ode.getDimension();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            ode.computeDerivatives(t, y, yDot);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeMainStateJacobian(double t, double[] y, double[] yDot,\n+                                             double[][] dFdY) {\n+\n+            final int n = ode.getDimension();\n+            final double[] tmpDot = new double[n];\n+\n+            for (int j = 0; j < n; ++j) {\n+                final double savedYj = y[j];\n+                y[j] += hY[j];\n+                ode.computeDerivatives(t, y, tmpDot);\n+                for (int i = 0; i < n; ++i) {\n+                    dFdY[i][j] = (tmpDot[i] - yDot[i]) / hY[j];\n+                }\n+                y[j] = savedYj;\n+            }\n+        }\n+\n+    }\n+\n }\n \n--- a/src/main/java/org/apache/commons/math/ode/ParameterJacobianProvider.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterJacobianProvider.java\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n-/** Interface to compute exactly jacobian matrix for some parameter\n+/** Interface to compute exactly Jacobian matrix for some parameter\n  *  when computing {@link JacobianMatrices partial derivatives equations}.\n  * \n  * @version $Id$\n  */\n public interface ParameterJacobianProvider extends Parameterizable {\n \n-    /** Compute the jacobian matrix of ODE with respect to one parameter.\n+    /** Compute the Jacobian matrix of ODE with respect to one parameter.\n      * <p>The parameter must be one given by {@link #getParametersNames()}.</p>\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the main state vector\n      * @param yDot array containing the current value of the time derivative\n      * of the main state vector\n      * @param paramName name of the parameter to consider\n-     * @param dFdP placeholder array where to put the jacobian matrix of the\n+     * @param dFdP placeholder array where to put the Jacobian matrix of the\n      * ODE with respect to the parameter\n      * @throws MathIllegalArgumentException if the parameter is not supported\n      */\n     void computeParameterJacobian(double t, double[] y, double[] yDot,\n                                   String paramName, double[] dFdP)\n         throws MathIllegalArgumentException;\n+\n }\n--- a/src/main/java/org/apache/commons/math/ode/ParameterJacobianWrapper.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterJacobianWrapper.java\n import java.util.HashMap;\n import java.util.Map;\n \n-/** Wrapper class to compute jacobian matrices by finite differences for ODE\n+/** Wrapper class to compute Jacobian matrices by finite differences for ODE\n  *  which do not compute them by themselves.\n  *  \n  * @version $Id$\n     /** Main ODE set. */\n     private final FirstOrderDifferentialEquations fode;\n \n-    /** Raw ODE without jacobian computation skill to be wrapped into a ParameterJacobianProvider. */\n+    /** Raw ODE without Jacobian computation skill to be wrapped into a ParameterJacobianProvider. */\n     private final ParameterizedODE pode;\n \n-    /** Steps for finite difference computation of the jacobian df/dp w.r.t. parameters. */\n+    /** Steps for finite difference computation of the Jacobian df/dp w.r.t. parameters. */\n     private final Map<String, Double> hParam;\n \n     /** Wrap a {@link ParameterizedODE} into a {@link ParameterJacobianProvider}.\n      * @param fode main first order differential equations set\n-     * @param pode additional problem, without parametre jacobian computation skill\n-     * @param paramsAndSteps parameters and steps to compute the jacobians df/dp\n+     * @param pode secondary problem, without parameter Jacobian computation skill\n+     * @param paramsAndSteps parameters and steps to compute the Jacobians df/dp\n      * @see JacobianMatrices#setParameterStep(String, double)\n      */\n     public ParameterJacobianWrapper(final FirstOrderDifferentialEquations fode,\n                                     final ParameterizedODE pode,\n-                                    final Collection<ParameterConfiguration> paramsAndSteps) {\n+                                    final ParameterConfiguration[] paramsAndSteps) {\n         this.fode = fode;\n         this.pode = pode;\n         this.hParam = new HashMap<String, Double>();\n--- a/src/main/java/org/apache/commons/math/ode/ParameterizedODE.java\n+++ b/src/main/java/org/apache/commons/math/ode/ParameterizedODE.java\n  */\n package org.apache.commons.math.ode;\n \n-/** Interface to compute by finite difference jacobian matrix for some parameter\n+/** Interface to compute by finite difference Jacobian matrix for some parameter\n  *  when computing {@link JacobianMatrices partial derivatives equations}.\n  * \n  * @version $Id$\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/SecondaryEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This interface allows users to add secondary differential equations to a primary\n+ * set of differential equations.\n+ * <p>\n+ * In some cases users may need to integrate some problem-specific equations along\n+ * with a primary set of differential equations. One example is optimal control where\n+ * adjoined parameters linked to the minimized hamiltonian must be integrated.\n+ * </p>\n+ * <p>\n+ * This interface allows users to add such equations to a primary set of {@link\n+ * FirstOrderDifferentialEquations first order differential equations}\n+ * thanks to the {@link\n+ * ExpandableStatefulODE#addSecondaryEquations(SecondaryEquations)}\n+ * method.\n+ * </p>\n+ * @see ExpandableStatefulODE\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface SecondaryEquations {\n+\n+    /** Get the dimension of the secondary state parameters.\n+     * @return dimension of the secondary state parameters\n+     */\n+    int getDimension();\n+\n+    /** Compute the derivatives related to the secondary state parameters.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param primary array containing the current value of the primary state vector\n+     * @param primaryDot array containing the derivative of the primary state vector\n+     * @param secondary array containing the current value of the secondary state vector\n+     * @param secondaryDot placeholder array where to put the derivative of the secondary state vector\n+     */\n+    void computeDerivatives(double t, double[] primary, double[] primaryDot,\n+                            double[] secondary, double[] secondaryDot);\n+\n+}\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableStatefulODE;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n-                            final double t0, final double[] z0,\n-                            final double t, final double[] z)\n+    public void integrate(final ExpandableStatefulODE equations, final double t)\n         throws MathIllegalStateException, MathIllegalArgumentException {\n \n-        sanityChecks(equations, t0, z0, t, z);\n+        sanityChecks(equations, t);\n         setEquations(equations);\n         resetEvaluations();\n-        final boolean forward = t > t0;\n+        final boolean forward = t > equations.getTime();\n \n         // initialize working arrays\n-        final int totalDim = equations.getDimension();\n-        final int mainDim  = equations.getMainSetDimension();\n-        final double[] y0  = new double[totalDim];\n-        final double[] y   = new double[totalDim];\n-        System.arraycopy(z0, 0, y0, 0, mainDim);\n-        System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n-        if (y != y0) {\n-            System.arraycopy(y0, 0, y, 0, totalDim);\n-        }\n-        final double[] yDot = new double[totalDim];\n+        final double[] y0   = equations.getCompleteState();\n+        final double[] y    = y0.clone();\n+        final double[] yDot = new double[y.length];\n \n         // set up an interpolator sharing the integrator arrays\n         final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n-        interpolator.reinitialize(y, forward);\n+        interpolator.reinitialize(y, forward,\n+                                  equations.getPrimaryMapper(), equations.getSecondaryMappers());\n \n         // set up integration control objects\n         for (StepHandler handler : stepHandlers) {\n         setStateInitialized(false);\n \n         // compute the initial Nordsieck vector using the configured starter integrator\n-        start(t0, y, t);\n+        start(equations.getTime(), y, t);\n         interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n         interpolator.storeTime(stepStart);\n         final int lastRow = nordsieck.getRowDimension() - 1;\n \n         } while (!isLastStep);\n \n-        // dispatch result between main and additional states\n-        System.arraycopy(y, 0, z, 0, z.length);\n-        equations.setCurrentAdditionalState(y);\n-\n-        final double stopTime = stepStart;\n+        // dispatch results\n+        equations.setTime(stepStart);\n+        equations.setCompleteState(y);\n+\n         resetInternalState();\n-        return stopTime;\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableStatefulODE;\n import org.apache.commons.math.ode.MultistepIntegrator;\n \n \n \n     /** {@inheritDoc} */\n     @Override\n-    public abstract double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n-                                     final double t0, final double[] y0,\n-                                     final double t, final double[] y)\n+    public abstract void integrate(final ExpandableStatefulODE equations, final double t)\n         throws MathIllegalStateException, MathIllegalArgumentException;\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n-import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableStatefulODE;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n-                            final double t0, final double[] z0,\n-                            final double t, final double[] z)\n+    public void integrate(final ExpandableStatefulODE equations,final double t)\n         throws MathIllegalStateException, MathIllegalArgumentException {\n \n-        sanityChecks(equations, t0, z0, t, z);\n+        sanityChecks(equations, t);\n         setEquations(equations);\n         resetEvaluations();\n-        final boolean forward = t > t0;\n+        final boolean forward = t > equations.getTime();\n \n         // initialize working arrays\n-        final int totalDim = equations.getDimension();\n-        final int mainDim  = equations.getMainSetDimension();\n-        final double[] y0  = new double[totalDim];\n-        final double[] y   = new double[totalDim];\n-        System.arraycopy(z0, 0, y0, 0, mainDim);\n-        System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n-        if (y != y0) {\n-            System.arraycopy(y0, 0, y, 0, totalDim);\n-        }\n-        final double[] yDot = new double[totalDim];\n-        final double[] yTmp = new double[totalDim];\n-        final double[] predictedScaled = new double[totalDim];\n+        final double[] y0   = equations.getCompleteState();\n+        final double[] y    = y0.clone();\n+        final double[] yDot = new double[y.length];\n+        final double[] yTmp = new double[y.length];\n+        final double[] predictedScaled = new double[y.length];\n         Array2DRowRealMatrix nordsieckTmp = null;\n \n         // set up two interpolators sharing the integrator arrays\n         final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n-        interpolator.reinitialize(y, forward);\n+        interpolator.reinitialize(y, forward,\n+                                  equations.getPrimaryMapper(), equations.getSecondaryMappers());\n \n         // set up integration control objects\n         for (StepHandler handler : stepHandlers) {\n         setStateInitialized(false);\n \n         // compute the initial Nordsieck vector using the configured starter integrator\n-        start(t0, y, t);\n+        start(equations.getTime(), y, t);\n         interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n         interpolator.storeTime(stepStart);\n \n             updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n \n             // discrete events handling\n-            System.arraycopy(yTmp, 0, y, 0, totalDim);\n+            System.arraycopy(yTmp, 0, y, 0, y.length);\n             interpolator.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n             interpolator.storeTime(stepStart);\n             interpolator.shift();\n \n         } while (!isLastStep);\n \n-        // dispatch result between main and additional states\n-        System.arraycopy(y, 0, z, 0, z.length);\n-        equations.setCurrentAdditionalState(y);\n-\n-        final double stopTime  = stepStart;\n-        stepStart = Double.NaN;\n-        stepSize  = Double.NaN;\n-        return stopTime;\n+        // dispatch results\n+        equations.setTime(stepStart);\n+        equations.setCompleteState(y);\n+\n+        resetInternalState();\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableStatefulODE;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.util.FastMath;\n \n  * relTol which will be used for all components.\n  * </p>\n  * <p>\n- * If the Ordinary Differential Equations is an {@link ExpandableFirstOrderDifferentialEquations\n+ * If the Ordinary Differential Equations is an {@link ExpandableStatefulODE\n  * extended ODE} rather than a {@link FirstOrderDifferentialEquations basic ODE}, then\n- * <em>only</em> the {@link ExpandableFirstOrderDifferentialEquations#getMainSet() main part}\n+ * <em>only</em> the {@link ExpandableStatefulODE#getMainSet() main part}\n  * of the state vector is used for stepsize control, not the complete state vector.\n  * </p>\n  *\n     }\n   }\n \n-  /** Perform some sanity checks on the integration parameters.\n-   * @param equations differential equations set\n-   * @param t0 start time\n-   * @param y0 state vector at t0\n-   * @param t target time for the integration\n-   * @param y placeholder where to put the state vector\n-   * @exception DimensionMismatchException if some inconsistency is detected\n-   * @exception NumberIsTooSmallException if integration span is too small\n-   */\n+  /** {@inheritDoc} */\n   @Override\n-  protected void sanityChecks(final ExpandableFirstOrderDifferentialEquations equations,\n-                              final double t0, final double[] y0,\n-                              final double t, final double[] y)\n+  protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\n       throws DimensionMismatchException, NumberIsTooSmallException {\n \n-      super.sanityChecks(equations, t0, y0, t, y);\n-\n-      mainSetDimension = equations.getMainSetDimension();\n+      super.sanityChecks(equations, t);\n+\n+      mainSetDimension = equations.getPrimaryMapper().getDimension();\n \n       if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != mainSetDimension)) {\n           throw new DimensionMismatchException(mainSetDimension, vecAbsoluteTolerance.length);\n   }\n \n   /** {@inheritDoc} */\n-  public abstract double integrate (ExpandableFirstOrderDifferentialEquations equations,\n-                                    double t0, double[] y0,\n-                                    double t, double[] y)\n+  public abstract void integrate (ExpandableStatefulODE equations, double t)\n     throws MathIllegalStateException, MathIllegalArgumentException;\n \n   /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n package org.apache.commons.math.ode.nonstiff;\n \n import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.EquationsMapper;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   /** {@inheritDoc} */\n   @Override\n   public void reinitialize(final AbstractIntegrator integrator,\n-                           final double[] y, final double[][] yDotK, final boolean forward) {\n-    super.reinitialize(integrator, y, yDotK, forward);\n+                           final double[] y, final double[][] yDotK, final boolean forward,\n+                           final EquationsMapper primaryMapper,\n+                           final EquationsMapper[] secondaryMappers) {\n+    super.reinitialize(integrator, y, yDotK, forward, primaryMapper, secondaryMappers);\n     v1 = null;\n     v2 = null;\n     v3 = null;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n import java.io.ObjectOutput;\n \n import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.EquationsMapper;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n   /** {@inheritDoc} */\n   @Override\n   public void reinitialize(final AbstractIntegrator integrator,\n-                           final double[] y, final double[][] yDotK, final boolean forward) {\n-\n-    super.reinitialize(integrator, y, yDotK, forward);\n+                           final double[] y, final double[][] yDotK, final boolean forward,\n+                           final EquationsMapper primaryMapper,\n+                           final EquationsMapper[] secondaryMappers) {\n+\n+    super.reinitialize(integrator, y, yDotK, forward, primaryMapper, secondaryMappers);\n \n     final int dimension = currentState.length;\n \n   /** {@inheritDoc} */\n   @Override\n   public void readExternal(final ObjectInput in)\n-    throws IOException {\n+    throws IOException, ClassNotFoundException {\n \n     // read the local attributes\n     yDotKLast = new double[3][];\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableStatefulODE;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n \n   /** {@inheritDoc} */\n   @Override\n-  public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n-                          final double t0, final double[] z0,\n-                          final double t, final double[] z)\n+  public void integrate(final ExpandableStatefulODE equations, final double t)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n \n-    sanityChecks(equations, t0, z0, t, z);\n+    sanityChecks(equations, t);\n     setEquations(equations);\n     resetEvaluations();\n-    final boolean forward = t > t0;\n+    final boolean forward = t > equations.getTime();\n \n     // create some internal working arrays\n-    final int totalDim = equations.getDimension();\n-    final int mainDim  = equations.getMainSetDimension();\n-    final double[] y0  = new double[totalDim];\n-    final double[] y   = new double[totalDim];\n-    System.arraycopy(z0, 0, y0, 0, mainDim);\n-    System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n+    final double[] y0  = equations.getCompleteState();\n+    final double[] y = y0.clone();\n     final int stages = c.length + 1;\n-    if (y != y0) {\n-      System.arraycopy(y0, 0, y, 0, totalDim);\n-    }\n-    final double[][] yDotK = new double[stages][totalDim];\n-    final double[] yTmp    = new double[totalDim];\n-    final double[] yDotTmp = new double[totalDim];\n+    final double[][] yDotK = new double[stages][y.length];\n+    final double[] yTmp    = new double[y.length];\n+    final double[] yDotTmp = new double[y.length];\n \n     // set up an interpolator sharing the integrator arrays\n     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n-    interpolator.reinitialize(this, yTmp, yDotK, forward);\n-    interpolator.storeTime(t0);\n+    interpolator.reinitialize(this, yTmp, yDotK, forward,\n+                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n+    interpolator.storeTime(equations.getTime());\n \n     // set up integration control objects\n-    stepStart         = t0;\n+    stepStart         = equations.getTime();\n     double  hNew      = 0;\n     boolean firstTime = true;\n     for (StepHandler handler : stepHandlers) {\n \n     } while (!isLastStep);\n \n-    // dispatch result between main and additional states\n-    System.arraycopy(y, 0, z, 0, z.length);\n-    equations.setCurrentAdditionalState(y);\n-\n-    final double stopTime = stepStart;\n+    // dispatch results\n+    equations.setTime(stepStart);\n+    equations.setCompleteState(y);\n+\n     resetInternalState();\n-    return stopTime;\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableStatefulODE;\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n   /** {@inheritDoc} */\n   @Override\n-  public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n-                          final double t0, final double[] z0, final double t, final double[] z)\n+  public void integrate(final ExpandableStatefulODE equations, final double t)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n \n-    sanityChecks(equations, t0, z0, t, z);\n+    sanityChecks(equations, t);\n     setEquations(equations);\n     resetEvaluations();\n-    final boolean forward = t > t0;\n+    final boolean forward = t > equations.getTime();\n \n     // create some internal working arrays\n-    final int totalDim = equations.getDimension();\n-    final int mainDim  = equations.getMainSetDimension();\n-    final double[] y0 = new double[totalDim];\n-    final double[] y  = new double[totalDim];\n-    System.arraycopy(z0, 0, y0, 0, mainDim);\n-    System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n-    final double[] yDot0   = new double[totalDim];\n-    final double[] y1      = new double[totalDim];\n-    final double[] yTmp    = new double[totalDim];\n-    final double[] yTmpDot = new double[totalDim];\n+    final double[] y0      = equations.getCompleteState();\n+    final double[] y       = y0.clone();\n+    final double[] yDot0   = new double[y.length];\n+    final double[] y1      = new double[y.length];\n+    final double[] yTmp    = new double[y.length];\n+    final double[] yTmpDot = new double[y.length];\n \n     final double[][] diagonal = new double[sequence.length-1][];\n     final double[][] y1Diag = new double[sequence.length-1][];\n     for (int k = 0; k < sequence.length-1; ++k) {\n-      diagonal[k] = new double[totalDim];\n-      y1Diag[k] = new double[totalDim];\n+      diagonal[k] = new double[y.length];\n+      y1Diag[k] = new double[y.length];\n     }\n \n     final double[][][] fk  = new double[sequence.length][][];\n     final AbstractStepInterpolator interpolator =\n             new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                    y1, yDot1,\n-                                                   yMidDots, forward);\n-    interpolator.storeTime(t0);\n-\n-    stepStart = t0;\n+                                                   yMidDots, forward,\n+                                                   equations.getPrimaryMapper(),\n+                                                   equations.getSecondaryMappers());\n+    interpolator.storeTime(equations.getTime());\n+\n+    stepStart = equations.getTime();\n     double  hNew             = 0;\n     double  maxError         = Double.MAX_VALUE;\n     boolean previousRejected = false;\n \n     } while (!isLastStep);\n \n-    // dispatch result between main and additional states\n-    System.arraycopy(y, 0, z, 0, z.length);\n-    equations.setCurrentAdditionalState(y);\n-\n-    final double stopTime = stepStart;\n+    // dispatch results\n+    equations.setTime(stepStart);\n+    equations.setCompleteState(y);\n+\n     resetInternalState();\n-    return stopTime;\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n+import org.apache.commons.math.ode.EquationsMapper;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n      */\n     private double[][] yMidDots;\n \n-    /** Interpolation polynoms. */\n-    private double[][] polynoms;\n+    /** Interpolation polynomials. */\n+    private double[][] polynomials;\n \n     /** Error coefficients for the interpolation. */\n     private double[] errfac;\n \n-    /** Degree of the interpolation polynoms. */\n+    /** Degree of the interpolation polynomials. */\n     private int currentDegree;\n \n   /** Simple constructor.\n    * @param yMidDots reference to the integrator array holding the\n    * derivatives at the middle point of the step\n    * @param forward integration direction indicator\n+   * @param primaryMapper equations mapper for the primary equations set\n+   * @param secondaryMappers equations mappers for the secondary equations sets\n    */\n   public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,\n                                             final double[] y1, final double[] y1Dot,\n                                             final double[][] yMidDots,\n-                                            final boolean forward) {\n-\n-    super(y, forward);\n+                                            final boolean forward,\n+                                            final EquationsMapper primaryMapper,\n+                                            final EquationsMapper[] secondaryMappers) {\n+\n+    super(y, forward, primaryMapper, secondaryMappers);\n     this.y0Dot    = y0Dot;\n     this.y1       = y1;\n     this.y1Dot    = y1Dot;\n     y1Dot    = null;\n     yMidDots = null;\n \n-    // copy the interpolation polynoms (up to the current degree only)\n-    if (interpolator.polynoms == null) {\n-      polynoms = null;\n+    // copy the interpolation polynomials (up to the current degree only)\n+    if (interpolator.polynomials == null) {\n+      polynomials = null;\n       currentDegree = -1;\n     } else {\n       resetTables(interpolator.currentDegree);\n-      for (int i = 0; i < polynoms.length; ++i) {\n-        polynoms[i] = new double[dimension];\n-        System.arraycopy(interpolator.polynoms[i], 0,\n-                         polynoms[i], 0, dimension);\n+      for (int i = 0; i < polynomials.length; ++i) {\n+        polynomials[i] = new double[dimension];\n+        System.arraycopy(interpolator.polynomials[i], 0,\n+                         polynomials[i], 0, dimension);\n       }\n       currentDegree = interpolator.currentDegree;\n     }\n \n   /** Reallocate the internal tables.\n    * Reallocate the internal tables in order to be able to handle\n-   * interpolation polynoms up to the given degree\n+   * interpolation polynomials up to the given degree\n    * @param maxDegree maximal degree to handle\n    */\n   private void resetTables(final int maxDegree) {\n \n     if (maxDegree < 0) {\n-      polynoms      = null;\n+      polynomials   = null;\n       errfac        = null;\n       currentDegree = -1;\n     } else {\n \n       final double[][] newPols = new double[maxDegree + 1][];\n-      if (polynoms != null) {\n-        System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);\n-        for (int i = polynoms.length; i < newPols.length; ++i) {\n+      if (polynomials != null) {\n+        System.arraycopy(polynomials, 0, newPols, 0, polynomials.length);\n+        for (int i = polynomials.length; i < newPols.length; ++i) {\n           newPols[i] = new double[currentState.length];\n         }\n       } else {\n           newPols[i] = new double[currentState.length];\n         }\n       }\n-      polynoms = newPols;\n+      polynomials = newPols;\n \n       // initialize the error factors array for interpolation\n       if (maxDegree <= 4) {\n    */\n   public void computeCoefficients(final int mu, final double h) {\n \n-    if ((polynoms == null) || (polynoms.length <= (mu + 4))) {\n+    if ((polynomials == null) || (polynomials.length <= (mu + 4))) {\n       resetTables(mu + 4);\n     }\n \n       final double aspl  = ydiff - yp1;\n       final double bspl  = yp0 - ydiff;\n \n-      polynoms[0][i] = currentState[i];\n-      polynoms[1][i] = ydiff;\n-      polynoms[2][i] = aspl;\n-      polynoms[3][i] = bspl;\n+      polynomials[0][i] = currentState[i];\n+      polynomials[1][i] = ydiff;\n+      polynomials[2][i] = aspl;\n+      polynomials[3][i] = bspl;\n \n       if (mu < 0) {\n         return;\n \n       // compute the remaining coefficients\n       final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);\n-      polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);\n+      polynomials[4][i] = 16 * (yMidDots[0][i] - ph0);\n \n       if (mu > 0) {\n         final double ph1 = ydiff + 0.25 * (aspl - bspl);\n-        polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);\n+        polynomials[5][i] = 16 * (yMidDots[1][i] - ph1);\n \n         if (mu > 1) {\n           final double ph2 = yp1 - yp0;\n-          polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);\n+          polynomials[6][i] = 16 * (yMidDots[2][i] - ph2 + polynomials[4][i]);\n \n           if (mu > 2) {\n             final double ph3 = 6 * (bspl - aspl);\n-            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);\n+            polynomials[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynomials[5][i]);\n \n             for (int j = 4; j <= mu; ++j) {\n               final double fac1 = 0.5 * j * (j - 1);\n               final double fac2 = 2 * fac1 * (j - 2) * (j - 3);\n-              polynoms[j+4][i] =\n-                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);\n+              polynomials[j+4][i] =\n+                  16 * (yMidDots[j][i] + fac1 * polynomials[j+2][i] - fac2 * polynomials[j][i]);\n             }\n \n           }\n     double error = 0;\n     if (currentDegree >= 5) {\n       for (int i = 0; i < scale.length; ++i) {\n-        final double e = polynoms[currentDegree][i] / scale[i];\n+        final double e = polynomials[currentDegree][i] / scale[i];\n         error += e * e;\n       }\n       error = FastMath.sqrt(error / scale.length) * errfac[currentDegree - 5];\n   /** {@inheritDoc} */\n   @Override\n   protected void computeInterpolatedStateAndDerivatives(final double theta,\n-                                          final double oneMinusThetaH) {\n+                                                        final double oneMinusThetaH) {\n \n     final int dimension = currentState.length;\n \n \n     for (int i = 0; i < dimension; ++i) {\n \n-        final double p0 = polynoms[0][i];\n-        final double p1 = polynoms[1][i];\n-        final double p2 = polynoms[2][i];\n-        final double p3 = polynoms[3][i];\n+        final double p0 = polynomials[0][i];\n+        final double p1 = polynomials[1][i];\n+        final double p2 = polynomials[2][i];\n+        final double p3 = polynomials[3][i];\n         interpolatedState[i] = p0 + theta * (p1 + oneMinusTheta * (p2 * theta + p3 * oneMinusTheta));\n         interpolatedDerivatives[i] = dot1 * p1 + dot2 * p2 + dot3 * p3;\n \n         if (currentDegree > 3) {\n             double cDot = 0;\n-            double c = polynoms[currentDegree][i];\n+            double c = polynomials[currentDegree][i];\n             for (int j = currentDegree - 1; j > 3; --j) {\n                 final double d = 1.0 / (j - 3);\n                 cDot = d * (theta05 * cDot + c);\n-                c = polynoms[j][i] + c * d * theta05;\n+                c = polynomials[j][i] + c * d * theta05;\n             }\n             interpolatedState[i]       += t4 * c;\n             interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;\n     out.writeInt(currentDegree);\n     for (int k = 0; k <= currentDegree; ++k) {\n       for (int l = 0; l < dimension; ++l) {\n-        out.writeDouble(polynoms[k][l]);\n+        out.writeDouble(polynomials[k][l]);\n       }\n     }\n \n   /** {@inheritDoc} */\n   @Override\n   public void readExternal(final ObjectInput in)\n-    throws IOException {\n+    throws IOException, ClassNotFoundException {\n \n     // read the base class\n     final double t = readBaseExternal(in);\n \n     for (int k = 0; k <= currentDegree; ++k) {\n       for (int l = 0; l < dimension; ++l) {\n-        polynoms[k][l] = in.readDouble();\n+        polynomials[k][l] = in.readDouble();\n       }\n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.ode.AbstractIntegrator;\n-import org.apache.commons.math.ode.ExpandableFirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.ExpandableStatefulODE;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n \n   }\n \n   /** {@inheritDoc} */\n-  public double integrate(final ExpandableFirstOrderDifferentialEquations equations,\n-                          final double t0, final double[] z0,\n-                          final double t, final double[] z)\n+  public void integrate(final ExpandableStatefulODE equations, final double t)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n \n-    sanityChecks(equations, t0, z0, t, z);\n+    sanityChecks(equations, t);\n     setEquations(equations);\n     resetEvaluations();\n-    final boolean forward = t > t0;\n+    final boolean forward = t > equations.getTime();\n \n     // create some internal working arrays\n-    final int totalDim = equations.getDimension();\n-    final int mainDim  = equations.getMainSetDimension();\n-    final double[] y0  = new double[totalDim];\n-    final double[] y   = new double[totalDim];\n-    System.arraycopy(z0, 0, y0, 0, mainDim);\n-    System.arraycopy(equations.getCurrentAdditionalStates(), 0, y0, mainDim, totalDim - mainDim);\n-    final int stages = c.length + 1;\n-    if (y != y0) {\n-      System.arraycopy(y0, 0, y, 0, y0.length);\n-    }\n+    final double[] y0      = equations.getCompleteState();\n+    final double[] y       = y0.clone();\n+    final int stages       = c.length + 1;\n     final double[][] yDotK = new double[stages][];\n     for (int i = 0; i < stages; ++i) {\n       yDotK [i] = new double[y0.length];\n \n     // set up an interpolator sharing the integrator arrays\n     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n-    interpolator.reinitialize(this, yTmp, yDotK, forward);\n-    interpolator.storeTime(t0);\n+    interpolator.reinitialize(this, yTmp, yDotK, forward,\n+                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n+    interpolator.storeTime(equations.getTime());\n \n     // set up integration control objects\n-    stepStart = t0;\n+    stepStart = equations.getTime();\n     stepSize  = forward ? step : -step;\n     for (StepHandler handler : stepHandlers) {\n         handler.reset();\n \n     } while (!isLastStep);\n \n-    // dispatch result between main and additional states\n-    System.arraycopy(y, 0, z, 0, z.length);\n-    equations.setCurrentAdditionalState(y);\n+    // dispatch results\n+    equations.setTime(stepStart);\n+    equations.setCompleteState(y);\n \n-    final double stopTime = stepStart;\n     stepStart = Double.NaN;\n     stepSize  = Double.NaN;\n-    return stopTime;\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n import java.io.ObjectOutput;\n \n import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.EquationsMapper;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n \n /** This class represents an interpolator over the last step during an\n    * @param yDotArray reference to the integrator array holding all the\n    * intermediate slopes\n    * @param forward integration direction indicator\n+   * @param primaryMapper equations mapper for the primary equations set\n+   * @param secondaryMappers equations mappers for the secondary equations sets\n    */\n   public void reinitialize(final AbstractIntegrator rkIntegrator,\n-                           final double[] y, final double[][] yDotArray, final boolean forward) {\n-    reinitialize(y, forward);\n+                           final double[] y, final double[][] yDotArray, final boolean forward,\n+                           final EquationsMapper primaryMapper,\n+                           final EquationsMapper[] secondaryMappers) {\n+    reinitialize(y, forward, primaryMapper, secondaryMappers);\n     this.yDotK = yDotArray;\n     this.integrator = rkIntegrator;\n   }\n   /** {@inheritDoc} */\n   @Override\n   public void readExternal(final ObjectInput in)\n-    throws IOException {\n+    throws IOException, ClassNotFoundException {\n \n     // read the base class\n     final double t = readBaseExternal(in);\n--- a/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n \n+import org.apache.commons.math.ode.EquationsMapper;\n+\n /** This abstract class represents an interpolator over the last step\n  * during an ODE integration.\n  *\n   /** interpolated derivatives */\n   protected double[] interpolatedDerivatives;\n \n+  /** interpolated primary state */\n+  protected double[] interpolatedPrimaryState;\n+\n+  /** interpolated primary derivatives */\n+  protected double[] interpolatedPrimaryDerivatives;\n+\n+  /** interpolated secondary state */\n+  protected double[][] interpolatedSecondaryState;\n+\n+  /** interpolated secondary derivatives */\n+  protected double[][] interpolatedSecondaryDerivatives;\n+\n   /** global previous time */\n   private double globalPreviousTime;\n \n   /** indicator for dirty state. */\n   private boolean dirtyState;\n \n+  /** Equations mapper for the primary equations set. */\n+  private EquationsMapper primaryMapper;\n+\n+  /** Equations mappers for the secondary equations sets. */\n+  private EquationsMapper[] secondaryMappers;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n    * initializing the copy.\n    */\n   protected AbstractStepInterpolator() {\n-    globalPreviousTime      = Double.NaN;\n-    globalCurrentTime       = Double.NaN;\n-    softPreviousTime        = Double.NaN;\n-    softCurrentTime         = Double.NaN;\n-    h                       = Double.NaN;\n-    interpolatedTime        = Double.NaN;\n-    currentState            = null;\n-    interpolatedState       = null;\n-    interpolatedDerivatives = null;\n-    finalized               = false;\n-    this.forward            = true;\n-    this.dirtyState         = true;\n-  }\n-\n-  /** Simple constructor.\n-   * @param y reference to the integrator array holding the state at\n-   * the end of the step\n-   * @param forward integration direction indicator\n-   */\n-  protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n-\n     globalPreviousTime = Double.NaN;\n     globalCurrentTime  = Double.NaN;\n     softPreviousTime   = Double.NaN;\n     softCurrentTime    = Double.NaN;\n     h                  = Double.NaN;\n     interpolatedTime   = Double.NaN;\n-\n-    currentState            = y;\n-    interpolatedState       = new double[y.length];\n-    interpolatedDerivatives = new double[y.length];\n-\n-    finalized         = false;\n-    this.forward      = forward;\n-    this.dirtyState   = true;\n+    currentState       = null;\n+    finalized          = false;\n+    this.forward       = true;\n+    this.dirtyState    = true;\n+    primaryMapper      = null;\n+    secondaryMappers   = null;\n+    allocateInterpolatedArrays(-1, null, null);\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   * @param primaryMapper equations mapper for the primary equations set\n+   * @param secondaryMappers equations mappers for the secondary equations sets\n+   */\n+  protected AbstractStepInterpolator(final double[] y, final boolean forward,\n+                                     final EquationsMapper primaryMapper,\n+                                     final EquationsMapper[] secondaryMappers) {\n+\n+    globalPreviousTime    = Double.NaN;\n+    globalCurrentTime     = Double.NaN;\n+    softPreviousTime      = Double.NaN;\n+    softCurrentTime       = Double.NaN;\n+    h                     = Double.NaN;\n+    interpolatedTime      = Double.NaN;\n+    currentState          = y;\n+    finalized             = false;\n+    this.forward          = forward;\n+    this.dirtyState       = true;\n+    this.primaryMapper    = primaryMapper;\n+    this.secondaryMappers = (secondaryMappers == null) ? null : secondaryMappers.clone();\n+    allocateInterpolatedArrays(y.length, primaryMapper, secondaryMappers);\n \n   }\n \n     h                  = interpolator.h;\n     interpolatedTime   = interpolator.interpolatedTime;\n \n-    if (interpolator.currentState != null) {\n-      currentState            = interpolator.currentState.clone();\n-      interpolatedState       = interpolator.interpolatedState.clone();\n-      interpolatedDerivatives = interpolator.interpolatedDerivatives.clone();\n+    if (interpolator.currentState == null) {\n+        currentState = null;\n+        allocateInterpolatedArrays(-1, null, null);\n     } else {\n-      currentState            = null;\n-      interpolatedState       = null;\n-      interpolatedDerivatives = null;\n-    }\n-\n-    finalized  = interpolator.finalized;\n-    forward    = interpolator.forward;\n-    dirtyState = interpolator.dirtyState;\n-\n+      currentState                     = interpolator.currentState.clone();\n+      interpolatedState                = interpolator.interpolatedState.clone();\n+      interpolatedDerivatives          = interpolator.interpolatedDerivatives.clone();\n+      interpolatedPrimaryState         = interpolator.interpolatedPrimaryState.clone();\n+      interpolatedPrimaryDerivatives   = interpolator.interpolatedPrimaryDerivatives.clone();\n+      interpolatedSecondaryState       = new double[interpolator.interpolatedSecondaryState.length][];\n+      interpolatedSecondaryDerivatives = new double[interpolator.interpolatedSecondaryDerivatives.length][];\n+      for (int i = 0; i < interpolatedSecondaryState.length; ++i) {\n+          interpolatedSecondaryState[i]       = interpolator.interpolatedSecondaryState[i].clone();\n+          interpolatedSecondaryDerivatives[i] = interpolator.interpolatedSecondaryDerivatives[i].clone();\n+      }\n+    }\n+\n+    finalized        = interpolator.finalized;\n+    forward          = interpolator.forward;\n+    dirtyState       = interpolator.dirtyState;\n+    primaryMapper    = interpolator.primaryMapper;\n+    secondaryMappers = (interpolator.secondaryMappers == null) ?\n+                       null : interpolator.secondaryMappers.clone();\n+\n+  }\n+\n+  /** Allocate the various interpolated states arrays.\n+   * @param dimension total dimension (negative if arrays should be set to null)\n+   * @param primaryMapper equations mapper for the primary equations set\n+   * @param secondaryMappers equations mappers for the secondary equations sets\n+   */\n+  private void allocateInterpolatedArrays(final int dimension,\n+                                          final EquationsMapper primaryMapper,\n+                                          final EquationsMapper[] secondaryMappers) {\n+      if (dimension < 0) {\n+          interpolatedState                = null;\n+          interpolatedDerivatives          = null;\n+          interpolatedPrimaryState         = null;\n+          interpolatedPrimaryDerivatives   = null;\n+          interpolatedSecondaryState       = null;\n+          interpolatedSecondaryDerivatives = null;\n+      } else {\n+          interpolatedState                = new double[dimension];\n+          interpolatedDerivatives          = new double[dimension];\n+          interpolatedPrimaryState         = new double[primaryMapper.getDimension()];\n+          interpolatedPrimaryDerivatives   = new double[primaryMapper.getDimension()];\n+          if (secondaryMappers == null) {\n+              interpolatedSecondaryState       = null;\n+              interpolatedSecondaryDerivatives = null;\n+          } else {\n+              interpolatedSecondaryState       = new double[secondaryMappers.length][];\n+              interpolatedSecondaryDerivatives = new double[secondaryMappers.length][];\n+              for (int i = 0; i < secondaryMappers.length; ++i) {\n+                  interpolatedSecondaryState[i]       = new double[secondaryMappers[i].getDimension()];\n+                  interpolatedSecondaryDerivatives[i] = new double[secondaryMappers[i].getDimension()];\n+              }\n+          }\n+      }\n   }\n \n   /** Reinitialize the instance\n-   * @param y reference to the integrator array holding the state at\n-   * the end of the step\n+   * @param y reference to the integrator array holding the state at the end of the step\n    * @param isForward integration direction indicator\n-   */\n-  protected void reinitialize(final double[] y, final boolean isForward) {\n-\n-    globalPreviousTime = Double.NaN;\n-    globalCurrentTime  = Double.NaN;\n-    softPreviousTime   = Double.NaN;\n-    softCurrentTime    = Double.NaN;\n-    h                  = Double.NaN;\n-    interpolatedTime   = Double.NaN;\n-\n-    currentState            = y;\n-    interpolatedState       = new double[y.length];\n-    interpolatedDerivatives = new double[y.length];\n-\n-    finalized         = false;\n-    this.forward      = isForward;\n-    this.dirtyState   = true;\n+   * @param primaryMapper equations mapper for the primary equations set\n+   * @param secondaryMappers equations mappers for the secondary equations sets\n+   */\n+  protected void reinitialize(final double[] y, final boolean isForward,\n+                              final EquationsMapper primaryMapper,\n+                              final EquationsMapper[] secondaryMappers) {\n+\n+    globalPreviousTime    = Double.NaN;\n+    globalCurrentTime     = Double.NaN;\n+    softPreviousTime      = Double.NaN;\n+    softCurrentTime       = Double.NaN;\n+    h                     = Double.NaN;\n+    interpolatedTime      = Double.NaN;\n+    currentState          = y;\n+    finalized             = false;\n+    this.forward          = isForward;\n+    this.dirtyState       = true;\n+    this.primaryMapper    = primaryMapper;\n+    this.secondaryMappers = secondaryMappers.clone();\n+    allocateInterpolatedArrays(y.length, primaryMapper, secondaryMappers);\n \n   }\n \n   protected abstract void computeInterpolatedStateAndDerivatives(double theta,\n                                                                  double oneMinusThetaH);\n \n-  /** {@inheritDoc} */\n-  public double[] getInterpolatedState() {\n-\n+  /** Lazy evaluation of complete interpolated state.\n+   */\n+  private void evaluateCompleteInterpolatedState() {\n       // lazy evaluation of the state\n       if (dirtyState) {\n           final double oneMinusThetaH = globalCurrentTime - interpolatedTime;\n           computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n           dirtyState = false;\n       }\n-\n-      return interpolatedState;\n-\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedState() {\n+      evaluateCompleteInterpolatedState();\n+      primaryMapper.extractEquationData(interpolatedState,\n+                                        interpolatedPrimaryState);\n+      return interpolatedPrimaryState;\n   }\n \n   /** {@inheritDoc} */\n   public double[] getInterpolatedDerivatives() {\n-\n-      // lazy evaluation of the state\n-      if (dirtyState) {\n-          final double oneMinusThetaH = globalCurrentTime - interpolatedTime;\n-          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n-          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n-          dirtyState = false;\n-      }\n-\n-      return interpolatedDerivatives;\n-\n+      evaluateCompleteInterpolatedState();\n+      primaryMapper.extractEquationData(interpolatedDerivatives,\n+                                        interpolatedPrimaryDerivatives);\n+      return interpolatedPrimaryDerivatives;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedSecondaryState(final int index) {\n+      evaluateCompleteInterpolatedState();\n+      secondaryMappers[index].extractEquationData(interpolatedState,\n+                                                  interpolatedSecondaryState[index]);\n+      return interpolatedSecondaryState[index];\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedSecondaryDerivatives(final int index) {\n+      evaluateCompleteInterpolatedState();\n+      secondaryMappers[index].extractEquationData(interpolatedDerivatives,\n+                                                  interpolatedSecondaryDerivatives[index]);\n+      return interpolatedSecondaryDerivatives[index];\n   }\n \n   /**\n     out.writeDouble(softCurrentTime);\n     out.writeDouble(h);\n     out.writeBoolean(forward);\n+    out.writeObject(primaryMapper);\n+    out.write(secondaryMappers.length);\n+    for (final EquationsMapper  mapper : secondaryMappers) {\n+        out.writeObject(mapper);\n+    }\n \n     if (currentState != null) {\n         for (int i = 0; i < currentState.length; ++i) {\n    * properly calling the {@link #setInterpolatedTime} method later,\n    * once all rest of the object state has been set up properly.\n    * @param in stream where to read the state from\n-   * @return interpolated time be set later by the caller\n+   * @return interpolated time to be set later by the caller\n    * @exception IOException in case of read error\n    */\n   protected double readBaseExternal(final ObjectInput in)\n-    throws IOException {\n+    throws IOException, ClassNotFoundException {\n \n     final int dimension = in.readInt();\n     globalPreviousTime  = in.readDouble();\n     softCurrentTime     = in.readDouble();\n     h                   = in.readDouble();\n     forward             = in.readBoolean();\n+    primaryMapper       = (EquationsMapper) in.readObject();\n+    secondaryMappers    = new EquationsMapper[in.read()];\n+    for (int i = 0; i < secondaryMappers.length; ++i) {\n+        secondaryMappers[i] = (EquationsMapper) in.readObject();\n+    }\n     dirtyState          = true;\n \n     if (dimension < 0) {\n     }\n \n     // we do NOT handle the interpolated time and state here\n-    interpolatedTime        = Double.NaN;\n-    interpolatedState       = (dimension < 0) ? null : new double[dimension];\n-    interpolatedDerivatives = (dimension < 0) ? null : new double[dimension];\n+    interpolatedTime = Double.NaN;\n+    allocateInterpolatedArrays(dimension, primaryMapper, secondaryMappers);\n \n     finalized = true;\n \n--- a/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n import java.util.Arrays;\n \n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.ode.EquationsMapper;\n import org.apache.commons.math.util.FastMath;\n \n /**\n      * @param y reference to the integrator array holding the state at\n      * the end of the step\n      * @param forward integration direction indicator\n-     */\n-    @Override\n-    public void reinitialize(final double[] y, final boolean forward) {\n-        super.reinitialize(y, forward);\n+     * @param primaryMapper equations mapper for the primary equations set\n+     * @param secondaryMappers equations mappers for the secondary equations sets\n+     */\n+    @Override\n+    public void reinitialize(final double[] y, final boolean forward,\n+                             final EquationsMapper primaryMapper,\n+                             final EquationsMapper[] secondaryMappers) {\n+        super.reinitialize(y, forward, primaryMapper, secondaryMappers);\n         stateVariation = new double[y.length];\n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n    */\n   double[] getInterpolatedDerivatives();\n \n+  /** Get the interpolated secondary state corresponding to the secondary equations.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @param index index of the secondary set, as returned by {@link\n+   * org.apache.commons.math.ode.ExpandableStatefulODE#addSecondaryEquations(\n+   * org.apache.commons.math.ode.SecondaryEquations)\n+   * ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}\n+   * @return interpolated secondary state at the current interpolation date\n+   * @see #getInterpolatedState()\n+   * @see #getInterpolatedDerivatives()\n+   * @see #getInterpolatedSecondaryDerivatives(String)\n+   * @see #setInterpolatedTime(double)\n+   * @since 3.0\n+   */\n+  double[] getInterpolatedSecondaryState(int index);\n+\n+  /** Get the interpolated secondary derivatives corresponding to the secondary equations.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @param index index of the secondary set, as returned by {@link\n+   * org.apache.commons.math.ode.ExpandableStatefulODE#addSecondaryEquations(\n+   * org.apache.commons.math.ode.SecondaryEquations)\n+   * ExpandableStatefulODE.addSecondaryEquations(SecondaryEquations)}\n+   * @return interpolated secondary derivatives at the current interpolation date\n+   * @see #getInterpolatedState()\n+   * @see #getInterpolatedDerivatives()\n+   * @see #getInterpolatedSecondaryState(String)\n+   * @see #setInterpolatedTime(double)\n+   * @since 3.0\n+   */\n+  double[] getInterpolatedSecondaryDerivatives(int index);\n+\n   /** Check if the natural integration direction is forward.\n    * <p>This method provides the integration direction as specified by\n    * the integrator itself, it avoid some nasty problems in\n--- a/src/test/java/org/apache/commons/math/ode/JacobianMatricesTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/JacobianMatricesTest.java\n \n     @Test\n     public void testInternalDifferentiation() {\n-        ExpandableFirstOrderIntegrator integ =\n+        AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         double hP = 1.0e-12;\n         double hY = 1.0e-12;\n             double[] z = { 1.3, b };\n             double[][] dZdZ0 = new double[2][2];\n             double[]   dZdP  = new double[2];\n-            ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(brusselator);\n-            JacobianMatrices jacob = new JacobianMatrices(efode, brusselator);\n+\n+            JacobianMatrices jacob = new JacobianMatrices(brusselator, new double[] { hY, hY }, ParamBrusselator.B);\n             jacob.setParameterizedODE(brusselator);\n-            jacob.selectParameters(ParamBrusselator.B);\n-            jacob.setMainStateSteps(new double[] { hY, hY });\n             jacob.setParameterStep(ParamBrusselator.B, hP);\n             jacob.setInitialParameterJacobian(ParamBrusselator.B, new double[] { 0.0, 1.0 });\n+\n+            ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator);\n+            efode.setTime(0);\n+            efode.setPrimaryState(z);\n+            jacob.registerVariationalEquations(efode);\n+\n             integ.setMaxEvaluations(5000);\n-            integ.integrate(efode, 0, z, 20.0, z);\n+            integ.integrate(efode, 20.0);\n             jacob.getCurrentMainSetJacobian(dZdZ0);\n             jacob.getCurrentParameterJacobian(ParamBrusselator.B, dZdP);\n //            Assert.assertEquals(5000, integ.getMaxEvaluations());\n \n     @Test\n     public void testAnalyticalDifferentiation() {\n-        ExpandableFirstOrderIntegrator integ =\n+        AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 });\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n         SummaryStatistics residualsP1 = new SummaryStatistics();\n             double[] z = { 1.3, b };\n             double[][] dZdZ0 = new double[2][2];\n             double[]   dZdP  = new double[2];\n-            ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(brusselator);\n-            JacobianMatrices jacob = new JacobianMatrices(efode, brusselator);\n-            jacob.setParameterJacobianProvider(brusselator);\n-            jacob.selectParameters(Brusselator.B);\n+\n+            JacobianMatrices jacob = new JacobianMatrices(brusselator, Brusselator.B);\n+            jacob.addParameterJacobianProvider(brusselator);\n             jacob.setInitialParameterJacobian(Brusselator.B, new double[] { 0.0, 1.0 });\n+\n+            ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator);\n+            efode.setTime(0);\n+            efode.setPrimaryState(z);\n+            jacob.registerVariationalEquations(efode);\n+\n             integ.setMaxEvaluations(5000);\n-            integ.integrate(efode, 0, z, 20.0, z);\n+            integ.integrate(efode, 20.0);\n             jacob.getCurrentMainSetJacobian(dZdZ0);\n             jacob.getCurrentParameterJacobian(Brusselator.B, dZdP);\n //            Assert.assertEquals(5000, integ.getMaxEvaluations());\n     @Test\n     public void testFinalResult() {\n \n-        ExpandableFirstOrderIntegrator integ =\n+        AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n         Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n \n-        ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(circle);\n-        JacobianMatrices jacob = new JacobianMatrices(efode, circle);\n-        jacob.setParameterJacobianProvider(circle);\n-        jacob.selectParameters(Circle.CX, Circle.CY, Circle.OMEGA);\n+        JacobianMatrices jacob = new JacobianMatrices(circle, Circle.CX, Circle.CY, Circle.OMEGA);\n+        jacob.addParameterJacobianProvider(circle);\n         jacob.setInitialMainStateJacobian(circle.exactDyDy0(0));\n         jacob.setInitialParameterJacobian(Circle.CX, circle.exactDyDcx(0));\n         jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0));\n         jacob.setInitialParameterJacobian(Circle.OMEGA, circle.exactDyDom(0));\n+\n+        ExpandableStatefulODE efode = new ExpandableStatefulODE(circle);\n+        efode.setTime(0);\n+        efode.setPrimaryState(y);\n+        jacob.registerVariationalEquations(efode);\n+\n         integ.setMaxEvaluations(5000);\n \n         double t = 18 * FastMath.PI;\n-        integ.integrate(efode, 0, y, t, y);\n+        integ.integrate(efode, t);\n+        y = efode.getPrimaryState();\n         for (int i = 0; i < y.length; ++i) {\n             Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9);\n         }\n     @Test\n     public void testParameterizable() {\n \n-        ExpandableFirstOrderIntegrator integ =\n+        AbstractIntegrator integ =\n             new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 });\n         double[] y = new double[] { 0.0, 1.0 };\n         ParameterizedCircle pcircle = new ParameterizedCircle(y, 1.0, 1.0, 0.1);\n //        pcircle.setParameter(ParameterizedCircle.CY, 1.0);\n //        pcircle.setParameter(ParameterizedCircle.OMEGA, 0.1);\n \n-        ExpandableFirstOrderDifferentialEquations efode = new ExpandableFirstOrderDifferentialEquations(pcircle);\n-\n         double hP = 1.0e-12;\n         double hY = 1.0e-12;\n \n-        JacobianMatrices jacob = new JacobianMatrices(efode, pcircle);\n-        jacob.setParameterJacobianProvider(pcircle);\n+        JacobianMatrices jacob = new JacobianMatrices(pcircle, new double[] { hY, hY },\n+                                                      Circle.CX, Circle.OMEGA);\n+        jacob.addParameterJacobianProvider(pcircle);\n         jacob.setParameterizedODE(pcircle);\n-        jacob.selectParameters(Circle.CX, Circle.OMEGA);\n-        jacob.setMainStateSteps(new double[] { hY, hY });\n         jacob.setParameterStep(Circle.OMEGA, hP);\n         jacob.setInitialMainStateJacobian(pcircle.exactDyDy0(0));\n         jacob.setInitialParameterJacobian(Circle.CX, pcircle.exactDyDcx(0));\n //        jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0));\n         jacob.setInitialParameterJacobian(Circle.OMEGA, pcircle.exactDyDom(0));\n+\n+        ExpandableStatefulODE efode = new ExpandableStatefulODE(pcircle);\n+        efode.setTime(0);\n+        efode.setPrimaryState(y);\n+        jacob.registerVariationalEquations(efode);\n+\n         integ.setMaxEvaluations(50000);\n \n         double t = 18 * FastMath.PI;\n-        integ.integrate(efode, 0, y, t, y);\n+        integ.integrate(efode, t);\n+        y = efode.getPrimaryState();\n         for (int i = 0; i < y.length; ++i) {\n             Assert.assertEquals(pcircle.exactY(t)[i], y[i], 1.0e-9);\n         }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n import java.util.Random;\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.EquationsMapper;\n import org.apache.commons.math.ode.TestProblem1;\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n     double[]   y    =   { 0.0, 1.0, -2.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n-    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true,\n+                              new EquationsMapper(0, y.length),\n+                              new EquationsMapper[0]);\n     interpolator.storeTime(0);\n     interpolator.shift();\n     interpolator.storeTime(1);\n     double[] y = y0.clone();\n     double[][] yDot = { new double[y0.length] };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n-    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true,\n+                              new EquationsMapper(0, y.length),\n+                              new EquationsMapper[0]);\n     interpolator.storeTime(t0);\n \n     double dt = 1.0;\n     double[]   y    =   { 1.0, 3.0, -4.0 };\n     double[][] yDot = { { 1.0, 2.0, -2.0 } };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n-    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true);\n+    interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true,\n+                              new EquationsMapper(0, y.length),\n+                              new EquationsMapper[0]);\n     interpolator.storeTime(0);\n     interpolator.shift();\n     interpolator.storeTime(1);\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.ode.EquationsMapper;\n+\n+/** This class is a step interpolator that does nothing.\n+ *\n+ * <p>This class is used when the {@link StepHandler \"step handler\"}\n+ * set up by the user does not need step interpolation. It does not\n+ * recompute the state when {@link AbstractStepInterpolator#setInterpolatedTime\n+ * setInterpolatedTime} is called. This implies the interpolated state\n+ * is always the state at the end of the current step.</p>\n+ *\n+ * @see StepHandler\n+ *\n+ * @version $Id$\n+ * @since 1.2\n+ */\n+\n+public class DummyStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 1708010296707839488L;\n+\n+  /** Current derivative. */\n+  private double[] currentDerivative;\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * <code>AbstractStepInterpolator.reinitialize</code> protected method\n+   * should be called before using the instance in order to initialize\n+   * the internal arrays. This constructor is used only in order to delay\n+   * the initialization in some cases. As an example, the {@link\n+   * org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator} uses\n+   * the prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DummyStepInterpolator() {\n+    super();\n+    currentDerivative = null;\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDot reference to the integrator array holding the state\n+   * derivative at some arbitrary point within the step\n+   * @param forward integration direction indicator\n+   * @param primaryMapper equations mapper for the primary equations set\n+   * @param secondaryMappers equations mappers for the secondary equations sets\n+   */\n+  public DummyStepInterpolator(final double[] y, final double[] yDot, final boolean forward) {\n+    super(y, forward, new EquationsMapper(0, y.length), new EquationsMapper[0]);\n+    currentDerivative = yDot;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DummyStepInterpolator(final DummyStepInterpolator interpolator) {\n+    super(interpolator);\n+    currentDerivative = interpolator.currentDerivative.clone();\n+  }\n+\n+  /** Really copy the finalized instance.\n+   * @return a copy of the finalized instance\n+   */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new DummyStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * In this class, this method does nothing: the interpolated state\n+   * is always the state at the end of the current step.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n+      System.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\n+      System.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n+  }\n+\n+  /** Write the instance to an output channel.\n+   * @param out output channel\n+   * @exception IOException if the instance cannot be written\n+   */\n+  @Override\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+      // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    if (currentDerivative != null) {\n+        for (int i = 0; i < currentDerivative.length; ++i) {\n+            out.writeDouble(currentDerivative[i]);\n+        }\n+    }\n+\n+  }\n+\n+  /** Read the instance from an input channel.\n+   * @param in input channel\n+   * @exception IOException if the instance cannot be read\n+   */\n+  @Override\n+  public void readExternal(final ObjectInput in)\n+    throws IOException, ClassNotFoundException {\n+\n+    // read the base class\n+    final double t = readBaseExternal(in);\n+\n+    if (currentState == null) {\n+        currentDerivative = null;\n+    } else {\n+        currentDerivative  = new double[currentState.length];\n+        for (int i = 0; i < currentDerivative.length; ++i) {\n+            currentDerivative[i] = in.readDouble();\n+        }\n+    }\n+\n+    // we can now set the interpolated time and state\n+    setInterpolatedTime(t);\n+\n+  }\n+\n+}", "timestamp": 1317189402, "metainfo": ""}