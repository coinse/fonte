{"sha": "947d3420b62e8f7aadc5f3fbd1ceac0463c33937", "log": "Added localized messages for exceptions thrown in the genetics package, improved javadoc, added final for parameters. JIRA: MATH-575  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     CROSSING_BOUNDARY_LOOPS(\"some outline boundary loops cross each other\"),\n     CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Cumulative probability function returned NaN for argument {0} p = {1}\"),\n     DIFFERENT_ROWS_LENGTHS(\"some rows have length {0} while others have length {1}\"),\n+    DIFFERENT_ORIG_AND_PERMUTED_DATA(\"original and permuted data must contain the same elements\"),\n     DIGEST_NOT_INITIALIZED(\"digest not initialized\"),\n     DIMENSIONS_MISMATCH_2x2(\"got {0}x{1} but expected {2}x{3}\"), /* keep */\n     DIMENSIONS_MISMATCH_SIMPLE(\"{0} != {1}\"), /* keep */\n     INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS(\"{0} method needs at least two previous points\"),\n     INTERNAL_ERROR(\"internal error, please fill a bug report at {0}\"),\n     INVALID_BINARY_DIGIT(\"invalid binary digit: {0}\"),\n+    INVALID_BINARY_CHROMOSOME(\"binary mutation works on BinaryChromosome only\"),\n     INVALID_BRACKETING_PARAMETERS(\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\"),\n+    INVALID_CROSSOVER_CHROMOSOME_LENGTH(\"both chromosomes must have same lengths: ({0}) ({1})\"),\n+    INVALID_FIXED_LENGTH_CHROMOSOME(\"one-point crossover works only on instances of AbstractListChromosome\"),\n     INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS(\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\"),\n     INVALID_ITERATIONS_LIMITS(\"invalid iteration limits: min={0}, max={1}\"),\n     INVALID_MAX_ITERATIONS(\"bad value for maximum iterations number: {0}\"),\n     OUT_OF_BOUND_SIGNIFICANCE_LEVEL(\"out of bounds significance level {0}, must be between {1} and {2}\"),\n     SIGNIFICANCE_LEVEL(\"significance level ({0})\"), /* keep */\n     OUT_OF_ORDER_ABSCISSA_ARRAY(\"the abscissae array must be sorted in a strictly increasing order, but the {0}-th element is {1} whereas {2}-th is {3}\"),\n+    OUT_OF_RANGE_CROSSOVER_RATE(\"crossover rate ({0}) out of [{1}, {2}] range\"),\n+    OUT_OF_RANGE_ELITISM_RATE(\"elitism rate ({0}) out of [{1}, {2}] range\"),\n+    OUT_OF_RANGE_MUTATION_RATE(\"mutation rate ({0}) out of [{1}, {2}] range\"),\n     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n     OUT_OF_RANGE(\"out of range\"), /* keep */\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n     SINGULAR_OPERATOR(\"operator is singular\"),\n     SUBARRAY_ENDS_AFTER_ARRAY_END(\"subarray ends after array end\"),\n     TOO_LARGE_CUTOFF_SINGULAR_VALUE(\"cutoff singular value is {0}, should be at most {1}\"),\n+    TOO_LARGE_TOURNAMENT_ARITY(\"tournament arity ({0}) cannot be bigger than population size ({1})\"),\n     TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY(\"cannot discard {0} elements from a {1} elements array\"),\n     TOO_MUCH_CANCELLATION(\"too much cancellation in a denominator\"),\n     TOO_MANY_REGRESSORS(\"too many regressors ({0}) specified, only {1} in the model\"),\n     TOO_SMALL_COST_RELATIVE_TOLERANCE(\"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\"),\n+    TOO_SMALL_GENERATION_COUNT(\"number of generations ({0}) must be >= {1}\"),\n     TOO_SMALL_INTEGRATION_INTERVAL(\"too small integration interval: length = {0}\"),\n     TOO_SMALL_ORTHOGONALITY_TOLERANCE(\"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\"),\n     TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE(\"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\"),\n     WEIGHT_AT_LEAST_ONE_NON_ZERO(\"weigth array must contain at least one non-zero value\"),\n     WRONG_BLOCK_LENGTH(\"wrong array shape (block length = {0}, expected {1})\"),\n     WRONG_NUMBER_OF_POINTS(\"{0} points are required, got only {1}\"),\n+    WRONG_SEQUENCE_LENGTH_RANDOMKEY(\"length of sequence for decoding ({0}) has to be equal to the RandomKey length ({1})\"),\n+    WRONG_REPR_AND_SREPR_SIZE(\"size of representation and sorted representation must be equals: {0} != {1}\"),\n+    WRONG_ORIG_AND_PERMUTED_SIZE(\"original and permuted data must have same length: {0} != {1}\"),\n     NUMBER_OF_POINTS(\"number of points ({0})\"), /* keep */\n     ZERO_DENOMINATOR(\"denominator must be different from 0\"),\n     ZERO_DENOMINATOR_IN_FRACTION(\"zero denominator in fraction {0}/{1}\"),\n--- a/src/main/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n     /**\n      * Constructor.\n      * @param representation inner representation of the chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n+     *         a valid chromosome\n      */\n     public AbstractListChromosome(final List<T> representation) {\n         checkValidity(representation);\n--- a/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n     /**\n      * Constructor.\n      * @param representation list of {0,1} values representing the chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n+     *         a valid chromosome\n      */\n     public BinaryChromosome(List<Integer> representation) {\n         super(representation);\n     /**\n      * Constructor.\n      * @param representation array of {0,1} values representing the chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n+     *         a valid chromosome\n      */\n     public BinaryChromosome(Integer[] representation) {\n         super(representation);\n--- a/src/main/java/org/apache/commons/math/genetics/BinaryMutation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryMutation.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n /**\n  * Mutation for {@link BinaryChromosome}s. Randomly changes one gene.\n  *\n      * Mutate the given chromosome. Randomly changes one gene.\n      * @param original the original chromosome.\n      * @return the mutated chromomsome.\n+     * @throws MathIllegalArgumentException if the <code>chromosome</code> is not an instance\n+     *         of {@link BinaryChromosome}.\n      */\n     public Chromosome mutate(Chromosome original) {\n         if (!(original instanceof BinaryChromosome)) {\n-            throw new IllegalArgumentException(\"Binary mutation works on BinaryChromosome only.\");\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_BINARY_CHROMOSOME);\n         }\n \n         BinaryChromosome origChrom = (BinaryChromosome) original;\n--- a/src/main/java/org/apache/commons/math/genetics/Chromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/Chromosome.java\n  */\n public abstract class Chromosome implements Comparable<Chromosome>,Fitness {\n \n-    /**\n-     * Cached value of the fitness of this chromosome.\n-     */\n+    /** Cached value of the fitness of this chromosome. */\n     private double fitness = Double.MIN_VALUE;\n \n     /**\n      *     <li>0 if the two chromosomes have the same fitness</li>\n      * </ul>\n      */\n-    public int compareTo(Chromosome another) {\n+    public int compareTo(final Chromosome another) {\n         return ((Double)this.getFitness()).compareTo(another.getFitness());\n     }\n \n      * @param another chromosome to compare\n      * @return true if <code>another</code> is equivalent to this chromosome\n      */\n-    protected boolean isSame(Chromosome another) {\n+    protected boolean isSame(final Chromosome another) {\n         return false;\n     }\n \n      * representation. If such chromosome is found, it is returned, if no such\n      * chromosome exists, returns <code>null</code>.\n      *\n-     * @param population\n-     *            Population to search\n+     * @param population Population to search\n      * @return Chromosome with the same representation, or <code>null</code> if\n      *         no such chromosome exists.\n      */\n-    protected Chromosome findSameChromosome(Population population) {\n+    protected Chromosome findSameChromosome(final Population population) {\n         for (Chromosome anotherChr : population) {\n             if (this.isSame(anotherChr)) {\n                 return anotherChr;\n      * Searches the population for a chromosome representing the same solution,\n      * and if it finds one, updates the fitness to its value.\n      *\n-     * @param population\n-     *            Population to search\n+     * @param population Population to search\n      */\n-    public void searchForFitnessUpdate(Population population) {\n+    public void searchForFitnessUpdate(final Population population) {\n         Chromosome sameChromosome = findSameChromosome(population);\n         if (sameChromosome != null) {\n             fitness = sameChromosome.getFitness();\n--- a/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n import java.util.Collections;\n import java.util.List;\n \n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n /**\n     /**\n      * Creates a new ElitisticListPopulation instance.\n      *\n-     * @param chromosomes\n-     *            list of chromosomes in the population\n-     * @param populationLimit\n-     *            maximal size of the population\n-     * @param elitismRate\n-     *            how many best chromosomes will be directly transferred to the\n-     *            next generation [in %]\n+     * @param chromosomes list of chromosomes in the population\n+     * @param populationLimit maximal size of the population\n+     * @param elitismRate how many best chromosomes will be directly transferred to the\n+     *                    next generation [in %]\n      */\n-    public ElitisticListPopulation(List<Chromosome> chromosomes, int populationLimit, double elitismRate) {\n+    public ElitisticListPopulation(final List<Chromosome> chromosomes,\n+                                   final int populationLimit,\n+                                   final double elitismRate) {\n         super(chromosomes, populationLimit);\n         this.elitismRate = elitismRate;\n     }\n      * chromosome list.\n      *\n      * @param populationLimit maximal size of the population\n-     * @param elitismRate\n-     *            how many best chromosomes will be directly transferred to the\n-     *            next generation [in %]\n+     * @param elitismRate how many best chromosomes will be directly transferred to the\n+     *                    next generation [in %]\n      */\n-    public ElitisticListPopulation(int populationLimit, double elitismRate) {\n+    public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n         this.elitismRate = elitismRate;\n     }\n \n     /**\n-     * Start the population for the next generation. The\n-     * <code>{@link #elitismRate}<code> percents of the best\n-     * chromosomes are directly copied to the next generation.\n+     * Start the population for the next generation. The <code>{@link #elitismRate}<code>\n+     * percents of the best chromosomes are directly copied to the next generation.\n      *\n      * @return the beginnings of the next generation.\n      */\n      * Sets the elitism rate, i.e. how many best chromosomes will be directly\n      * transferred to the next generation [in %].\n      *\n-     * @param elitismRate\n-     *            how many best chromosomes will be directly transferred to the\n-     *            next generation [in %]\n+     * @param elitismRate how many best chromosomes will be directly transferred to the\n+     *                    next generation [in %]\n+     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n-    public void setElitismRate(double elitismRate) {\n+    public void setElitismRate(final double elitismRate) {\n         if (elitismRate < 0 || elitismRate > 1) {\n-            throw new IllegalArgumentException(\"Elitism rate has to be in [0,1]\");\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_ELITISM_RATE, elitismRate, 0, 1);\n         }\n         this.elitismRate = elitismRate;\n     }\n--- a/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n+++ b/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.genetics;\n+\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * Stops after a fixed number of generations.  Each time\n      * Create a new FixedGenerationCount instance.\n      *\n      * @param maxGenerations number of generations to evolve\n+     * @throws NumberIsTooSmallException if the number of generations is &lt; 1\n      */\n-    public FixedGenerationCount(int maxGenerations) {\n+    public FixedGenerationCount(final int maxGenerations) {\n         if (maxGenerations <= 0) {\n-            throw new IllegalArgumentException(\"The number of generations has to be >= 0\");\n+            throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_GENERATION_COUNT,\n+                                                maxGenerations, 1, true);\n         }\n         this.maxGenerations = maxGenerations;\n     }\n      * @param population ignored (no impact on result)\n      * @return <code>true</code> IFF the maximum number of generations has been exceeded\n      */\n-    public boolean isSatisfied(Population population) {\n+    public boolean isSatisfied(final Population population) {\n         if (this.numGenerations < this.maxGenerations) {\n             numGenerations++;\n             return false;\n--- a/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n  */\n package org.apache.commons.math.genetics;\n \n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomGenerator;\n import org.apache.commons.math.random.JDKRandomGenerator;\n \n      * @param mutationPolicy The {@link MutationPolicy}\n      * @param mutationRate The mutation rate as a percentage (0-1 inclusive)\n      * @param selectionPolicy The {@link SelectionPolicy}\n-     */\n-    public GeneticAlgorithm(\n-            CrossoverPolicy crossoverPolicy, double crossoverRate,\n-            MutationPolicy mutationPolicy, double mutationRate,\n-            SelectionPolicy selectionPolicy) {\n+     * @throws OutOfRangeException if the crossover or mutation rate is outside the [0, 1] range\n+     */\n+    public GeneticAlgorithm(final CrossoverPolicy crossoverPolicy,\n+                            final double crossoverRate,\n+                            final MutationPolicy mutationPolicy,\n+                            final double mutationRate,\n+                            final SelectionPolicy selectionPolicy) {\n+\n         if (crossoverRate < 0 || crossoverRate > 1) {\n-            throw new IllegalArgumentException(\"crossoverRate must be between 0 and 1\");\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_CROSSOVER_RATE,\n+                                          crossoverRate, 0, 1);\n         }\n         if (mutationRate < 0 || mutationRate > 1) {\n-            throw new IllegalArgumentException(\"mutationRate must be between 0 and 1\");\n+            throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_MUTATION_RATE,\n+                                          mutationRate, 0, 1);\n         }\n         this.crossoverPolicy = crossoverPolicy;\n         this.crossoverRate = crossoverRate;\n      *\n      * @param random random generator\n      */\n-    public static synchronized void setRandomGenerator(RandomGenerator random) {\n+    public static synchronized void setRandomGenerator(final RandomGenerator random) {\n         randomGenerator = random;\n     }\n \n      * @param condition the stopping condition used to stop evolution.\n      * @return the population that satisfies the stopping condition.\n      */\n-    public Population evolve(Population initial, StoppingCondition condition) {\n+    public Population evolve(final Population initial, final StoppingCondition condition) {\n         Population current = initial;\n         generationsEvolved = 0;\n         while (!condition.isSatisfied(current)) {\n      * @param current the current population.\n      * @return the population for the next generation.\n      */\n-    public Population nextGeneration(Population current) {\n+    public Population nextGeneration(final Population current) {\n         Population nextGeneration = current.nextGeneration();\n \n         RandomGenerator randGen = getRandomGenerator();\n--- a/src/main/java/org/apache/commons/math/genetics/InvalidRepresentationException.java\n+++ b/src/main/java/org/apache/commons/math/genetics/InvalidRepresentationException.java\n      * @param pattern Message pattern.\n      * @param args Arguments.\n      */\n-    public InvalidRepresentationException(Localizable pattern,\n-            Object ... args) {\n+    public InvalidRepresentationException(Localizable pattern, Object ... args) {\n        super(pattern, args);\n     }\n \n--- a/src/main/java/org/apache/commons/math/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ListPopulation.java\n      *\n      * @param chromosomes list of chromosomes in the population\n      * @param populationLimit maximal size of the population\n+     * @throws NumberIsTooLargeException if the list of chromosomes exceeds the population limit\n+     * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n      */\n-    public ListPopulation (List<Chromosome> chromosomes, int populationLimit) {\n+    public ListPopulation(final List<Chromosome> chromosomes, final int populationLimit) {\n         if (chromosomes.size() > populationLimit) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE,\n                                                 chromosomes.size(), populationLimit, false);\n         }\n-        if (populationLimit < 0) {\n+        if (populationLimit <= 0) {\n             throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n         }\n \n     }\n \n     /**\n-     * Creates a new ListPopulation instance and initializes its inner\n-     * chromosome list.\n+     * Creates a new ListPopulation instance and initializes its inner chromosome list.\n      *\n      * @param populationLimit maximal size of the population\n+     * @throws NotPositiveException if the population limit is not a positive number (&lt; 1)\n      */\n-    public ListPopulation (int populationLimit) {\n-        if (populationLimit < 0) {\n+    public ListPopulation(final int populationLimit) {\n+        if (populationLimit <= 0) {\n             throw new NotPositiveException(LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE, populationLimit);\n         }\n         this.populationLimit = populationLimit;\n      * Sets the list of chromosomes.\n      * @param chromosomes the list of chromosomes\n      */\n-    public void setChromosomes(List<Chromosome> chromosomes) {\n+    public void setChromosomes(final List<Chromosome> chromosomes) {\n         this.chromosomes = chromosomes;\n     }\n \n      * Add the given chromosome to the population.\n      * @param chromosome the chromosome to add.\n      */\n-    public void addChromosome(Chromosome chromosome) {\n+    public void addChromosome(final Chromosome chromosome) {\n         this.chromosomes.add(chromosome);\n     }\n \n      * Sets the maximal population size.\n      * @param populationLimit maximal population size.\n      */\n-    public void setPopulationLimit(int populationLimit) {\n+    public void setPopulationLimit(final int populationLimit) {\n         this.populationLimit = populationLimit;\n     }\n \n--- a/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n+++ b/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n \n import java.util.ArrayList;\n import java.util.List;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n \n \n /**\n      * @param first first parent (p1)\n      * @param second second parent (p2)\n      * @return pair of two children (c1,c2)\n+     * @throws MathIllegalArgumentException iff one of the chromosomes is\n+     *         not an instance of {@link AbstractListChromosome} or the length\n+     *         of the two chromosomes is not equal\n      */\n     @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n-    public ChromosomePair crossover(Chromosome first, Chromosome second) {\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n         if (! (first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n-            throw new IllegalArgumentException(\"One point crossover works on FixedLengthChromosomes only.\");\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n         }\n         return crossover((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n     }\n      * @param first the first chromosome.\n      * @param second the second chromosome.\n      * @return the pair of new chromosomes that resulted from the crossover.\n+     * @throws MathIllegalArgumentException if the length of the two chromosomes is different\n      */\n-    private ChromosomePair crossover(AbstractListChromosome<T> first, AbstractListChromosome<T> second) {\n+    private ChromosomePair crossover(final AbstractListChromosome<T> first,\n+                                     final AbstractListChromosome<T> second) {\n         int length = first.getLength();\n         if (length != second.getLength()) {\n-            throw new IllegalArgumentException(\"Both chromosomes must have same lengths.\");\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_CROSSOVER_CHROMOSOME_LENGTH,\n+                                                   length, second.getLength());\n         }\n \n         // array representations of the parents\n             child2Rep.add(parent1Rep.get(i));\n         }\n \n-        return new ChromosomePair(\n-                first.newFixedLengthChromosome(child1Rep),\n-                second.newFixedLengthChromosome(child2Rep)\n-                );\n+        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n+                                  second.newFixedLengthChromosome(child2Rep));\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/genetics/PermutationChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/PermutationChromosome.java\n      * represents a permutation (3,0,1,2), and the unpermuted sequence is\n      * (a,b,c,d), this yields (d,a,b,c).\n      *\n-     * @param sequence\n-     *            the unpermuted (original) sequence of objects\n-     * @return permutation of <code>sequence</code> represented by this\n-     *         permutation\n+     * @param sequence the unpermuted (original) sequence of objects\n+     * @return permutation of <code>sequence</code> represented by this permutation\n      */\n     List<T> decode(List<T> sequence);\n \n--- a/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  */\n public abstract class RandomKey<T> extends AbstractListChromosome<Double> implements PermutationChromosome<T> {\n \n-    /**\n-     * Cache of sorted representation (unmodifiable).\n-     */\n+    /** Cache of sorted representation (unmodifiable). */\n     private final List<Double> sortedRepresentation;\n \n     /**\n      * Constructor.\n      *\n      * @param representation list of [0,1] values representing the permutation\n-     */\n-    public RandomKey(List<Double> representation) {\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n+     *         a valid chromosome\n+     */\n+    public RandomKey(final List<Double> representation) {\n         super(representation);\n         // store the sorted representation\n         List<Double> sortedRepr = new ArrayList<Double> (getRepresentation());\n      *\n      * @param representation array of [0,1] values representing the permutation\n      */\n-    public RandomKey(Double[] representation) {\n+    public RandomKey(final Double[] representation) {\n         this(Arrays.asList(representation));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public List<T> decode(List<T> sequence) {\n+    public List<T> decode(final List<T> sequence) {\n         return decodeGeneric(sequence, getRepresentation(), sortedRepresentation);\n     }\n \n      * @param sortedRepr sorted <code>representation</code>\n      * @return list with the sequence values permuted according to the representation\n      */\n-    private static <S> List<S> decodeGeneric(List<S> sequence, List<Double> representation, List<Double> sortedRepr) {\n+    private static <S> List<S> decodeGeneric(final List<S> sequence, List<Double> representation,\n+                                             final List<Double> sortedRepr) {\n         int l = sequence.size();\n \n         if (representation.size() != l) {\n-            throw new IllegalArgumentException(String.format(\"Length of sequence for decoding (%s) has to be equal to the length of the RandomKey (%s)\", l, representation.size()));\n+            throw new MathIllegalArgumentException(LocalizedFormats.WRONG_SEQUENCE_LENGTH_RANDOMKEY,\n+                                                   l, representation.size());\n         }\n         if (representation.size() != sortedRepr.size()) {\n-            throw new IllegalArgumentException(String.format(\"Representation and sortedRepr must have same sizes, %d != %d\", representation.size(), sortedRepr.size()));\n+            throw new MathIllegalArgumentException(LocalizedFormats.WRONG_REPR_AND_SREPR_SIZE,\n+                                                   representation.size(), sortedRepr.size());\n         }\n \n         List<Double> reprCopy = new ArrayList<Double> (representation);// do not modify the orig. representation\n      * @return true iff chromosomes encode the same permutation\n      */\n     @Override\n-    protected boolean isSame(Chromosome another) {\n+    protected boolean isSame(final Chromosome another) {\n         // type check\n         if (! (another instanceof RandomKey<?>)) {\n             return false;\n      * {@inheritDoc}\n      */\n     @Override\n-    protected void checkValidity(java.util.List<Double> chromosomeRepresentation) throws InvalidRepresentationException {\n+    protected void checkValidity(final List<Double> chromosomeRepresentation)\n+        throws InvalidRepresentationException {\n+\n         for (double val : chromosomeRepresentation) {\n             if (val < 0 || val > 1) {\n-                throw new InvalidRepresentationException(\n-                        LocalizedFormats.OUT_OF_RANGE_SIMPLE, val, 0, 1);\n+                throw new InvalidRepresentationException(LocalizedFormats.OUT_OF_RANGE_SIMPLE, val, 0, 1);\n             }\n         }\n     }\n      * Generates a representation corresponding to a random permutation of\n      * length l which can be passed to the RandomKey constructor.\n      *\n-     * @param l\n-     *            length of the permutation\n+     * @param l length of the permutation\n      * @return representation of a random permutation\n      */\n-    public static final List<Double> randomPermutation(int l) {\n+    public static final List<Double> randomPermutation(final int l) {\n         List<Double> repr = new ArrayList<Double>(l);\n         for (int i=0; i<l; i++) {\n             repr.add(GeneticAlgorithm.getRandomGenerator().nextDouble());\n      * Generates a representation corresponding to an identity permutation of\n      * length l which can be passed to the RandomKey constructor.\n      *\n-     * @param l\n-     *            length of the permutation\n+     * @param l length of the permutation\n      * @return representation of an identity permutation\n      */\n-    public static final List<Double> identityPermutation(int l) {\n+    public static final List<Double> identityPermutation(final int l) {\n         List<Double> repr = new ArrayList<Double>(l);\n         for (int i=0; i<l; i++) {\n             repr.add((double)i/l);\n      * @param comparator how the data will be compared\n      * @return list representation of the permutation corresponding to the parameters\n      */\n-    public static <S> List<Double> comparatorPermutation(List<S> data, Comparator<S> comparator) {\n+    public static <S> List<Double> comparatorPermutation(final List<S> data,\n+                                                         final Comparator<S> comparator) {\n         List<S> sortedData = new ArrayList<S> (data);\n         Collections.sort(sortedData, comparator);\n \n      * @param <S> type of the data\n      * @param originalData the original, unpermuted data\n      * @param permutedData the data, somehow permuted\n-     * @return representation of a permutation corresponding to the permutation <code>originalData -> permutedData</code>\n-     * @throws IllegalArgumentException iff the <code>permutedData</code> and <code>originalData</code> contains different data\n-     */\n-    public static <S> List<Double> inducedPermutation(List<S> originalData, List<S> permutedData) throws IllegalArgumentException {\n+     * @return representation of a permutation corresponding to the permutation\n+     * <code>originalData -> permutedData</code>\n+     * @throws IllegalArgumentException iff the <code>permutedData</code> and\n+     * <code>originalData</code> contains different data\n+     */\n+    public static <S> List<Double> inducedPermutation(final List<S> originalData,\n+                                                      final List<S> permutedData)\n+        throws IllegalArgumentException {\n+\n         if (originalData.size() != permutedData.size()) {\n-            throw new IllegalArgumentException(\"originalData and permutedData must have same length\");\n+            throw new MathIllegalArgumentException(LocalizedFormats.WRONG_ORIG_AND_PERMUTED_SIZE,\n+                                                   originalData.size(), permutedData.size());\n         }\n         int l = originalData.size();\n \n         for (int i=0; i<l; i++) {\n             int index = origDataCopy.indexOf(permutedData.get(i));\n             if (index == -1) {\n-                throw new IllegalArgumentException(\"originalData and permutedData must contain the same objects.\");\n+                throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_ORIG_AND_PERMUTED_DATA);\n             }\n             res[index] = (double) i / l;\n             origDataCopy.set(index, null);\n      * @param l length of list to generate\n      * @return list of integers from 0 to l-1\n      */\n-    private static List<Integer> baseSequence(int l) {\n+    private static List<Integer> baseSequence(final int l) {\n         List<Integer> baseSequence = new ArrayList<Integer> (l);\n         for (int i=0; i<l; i++) {\n             baseSequence.add(i);\n--- a/src/main/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n      * @throws MathIllegalArgumentException if <code>original</code> is not a\n      * {@link RandomKey} instance\n      */\n-    public Chromosome mutate(Chromosome original) {\n+    public Chromosome mutate(final Chromosome original) {\n         if (!(original instanceof RandomKey<?>)) {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.RANDOMKEY_MUTATION_WRONG_CLASS,\n-                    original.getClass().getSimpleName());\n+            throw new MathIllegalArgumentException(LocalizedFormats.RANDOMKEY_MUTATION_WRONG_CLASS,\n+                                                   original.getClass().getSimpleName());\n         }\n \n         RandomKey<?> originalRk = (RandomKey<?>) original;\n--- a/src/main/java/org/apache/commons/math/genetics/TournamentSelection.java\n+++ b/src/main/java/org/apache/commons/math/genetics/TournamentSelection.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n /**\n  * Tournament selection scheme. Each of the two selected chromosomes is selected\n  * based on n-ary tournament -- this is done by drawing {@link #arity} random\n     /**\n      * Creates a new TournamentSelection instance.\n      *\n-     * @param arity\n-     *            how many chromosomes will be drawn to the tournament\n+     * @param arity how many chromosomes will be drawn to the tournament\n      */\n-    public TournamentSelection(int arity) {\n+    public TournamentSelection(final int arity) {\n         this.arity = arity;\n     }\n \n      * drawing {@link #arity} random chromosomes without replacement from the\n      * population, and then selecting the fittest chromosome among them.\n      *\n-     * @param population\n-     *            the population from which the chromosomes are choosen.\n+     * @param population the population from which the chromosomes are choosen.\n      * @return the selected chromosomes.\n      */\n-    public ChromosomePair select(Population population) {\n-        return new ChromosomePair(\n-                tournament((ListPopulation) population),\n-                tournament((ListPopulation)population)\n-                );\n+    public ChromosomePair select(final Population population) {\n+        return new ChromosomePair(tournament((ListPopulation) population),\n+                                  tournament((ListPopulation)population));\n     }\n \n     /**\n      * chromosomes without replacement from the population, and then select the\n      * fittest chromosome among them.\n      *\n-     * @param population\n-     *            the population from which the chromosomes are choosen.\n+     * @param population the population from which the chromosomes are choosen.\n      * @return the selected chromosome.\n+     * @throws MathIllegalArgumentException if the tournament arity is bigger than the\n+     * population size\n      */\n-    private Chromosome tournament(ListPopulation population) {\n+    private Chromosome tournament(final ListPopulation population) {\n         if (population.getPopulationSize() < this.arity) {\n-            throw new IllegalArgumentException(\"Tournament arity cannot be bigger than population size.\");\n+            throw new MathIllegalArgumentException(LocalizedFormats.TOO_LARGE_TOURNAMENT_ARITY,\n+                                                   arity, population.getPopulationSize());\n         }\n         // auxiliary population\n         ListPopulation tournamentPopulation = new ListPopulation(this.arity) {\n      *\n      * @param arity arity of the tournament\n      */\n-    public void setArity(int arity) {\n+    public void setArity(final int arity) {\n         this.arity = arity;\n     }\n ", "timestamp": 1327357597, "metainfo": ""}