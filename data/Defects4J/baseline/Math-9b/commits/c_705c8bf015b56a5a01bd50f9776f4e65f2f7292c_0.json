{"sha": "705c8bf015b56a5a01bd50f9776f4e65f2f7292c", "log": "Implementation of continuous triangular distributions (MATH-731). Patch contributed by Dennis Hendriks.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/TriangularDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Implementation of the triangular real distribution.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Triangular_distribution\">\n+ * Triangular distribution (Wikipedia)</a>\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class TriangularDistribution extends AbstractRealDistribution {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 20120112L;\n+\n+    /** Lower limit of this distribution (inclusive). */\n+    private final double a;\n+\n+    /** Upper limit of this distribution (inclusive). */\n+    private final double b;\n+\n+    /** Mode of this distribution. */\n+    private final double c;\n+\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a triangular real distribution using the given lower limit,\n+     * upper limit, and mode.\n+     *\n+     * @param a Lower limit of this distribution (inclusive).\n+     * @param b Upper limit of this distribution (inclusive).\n+     * @param c Mode of this distribution.\n+     * @throws NumberIsTooLargeException if {@code a >= b} or if {@code c > b}\n+     * @throws NumberIsTooSmallException if {@code c < a}\n+     */\n+    public TriangularDistribution(double a, double c, double b)\n+        throws NumberIsTooLargeException, NumberIsTooSmallException {\n+        if (a >= b) {\n+            throw new NumberIsTooLargeException(\n+                            LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                            a, b, false);\n+        }\n+        if (c < a) {\n+            throw new NumberIsTooSmallException(\n+                    LocalizedFormats.NUMBER_TOO_SMALL, c, a, true);\n+        }\n+        if (c > b) {\n+            throw new NumberIsTooLargeException(\n+                    LocalizedFormats.NUMBER_TOO_LARGE, c, b, true);\n+        }\n+\n+        this.a = a;\n+        this.c = c;\n+        this.b = b;\n+        solverAbsoluteAccuracy = FastMath.ulp(c);\n+    }\n+\n+    /**\n+     * Returns the mode {@code c} of this distribution.\n+     *\n+     * @return the mode {@code c} of this distribution\n+     */\n+    public double getMode() {\n+        return c;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For lower limit {@code a}, upper limit {@code b} and mode {@code c}, the\n+     * PDF is given by\n+     * <ul>\n+     * <li>{@code 2 * (x - a) / [(b - a) * (c - a)]} if {@code a <= x < c},</li>\n+     * <li>{@code 2 / (b - a)} if {@code x = c},</li>\n+     * <li>{@code 2 * (b - x) / [(b - a) * (b - c)]} if {@code c < x <= b},</li>\n+     * <li>{@code 0} otherwise.\n+     * </ul>\n+     */\n+    public double density(double x) {\n+        if (x < a) {\n+            return 0;\n+        }\n+        if (a <= x && x < c) {\n+            double divident = 2 * (x - a);\n+            double divisor = (b - a) * (c - a);\n+            return divident / divisor;\n+        }\n+        if (x == c) {\n+            return 2 / (b - a);\n+        }\n+        if (c < x && x <= b) {\n+            double divident = 2 * (b - x);\n+            double divisor = (b - a) * (b - c);\n+            return divident / divisor;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For lower limit {@code a}, upper limit {@code b} and mode {@code c}, the\n+     * CDF is given by\n+     * <ul>\n+     * <li>{@code 0} if {@code x < a},</li>\n+     * <li>{@code (x - a)^2 / [(b - a) * (c - a)]} if {@code a <= x < c},</li>\n+     * <li>{@code (c - a) / (b - a)} if {@code x = c},</li>\n+     * <li>{@code 1 - (b - x)^2 / [(b - a) * (b - c)]} if {@code c < x <= b},</li>\n+     * <li>{@code 1} if {@code x > b}.</li>\n+     * </ul>\n+     */\n+    public double cumulativeProbability(double x)  {\n+        if (x < a) {\n+            return 0;\n+        }\n+        if (a <= x && x < c) {\n+            double divident = (x - a) * (x - a);\n+            double divisor = (b - a) * (c - a);\n+            return divident / divisor;\n+        }\n+        if (x == c) {\n+            return (c - a) / (b - a);\n+        }\n+        if (c < x && x <= b) {\n+            double divident = (b - x) * (b - x);\n+            double divisor = (b - a) * (b - c);\n+            return 1 - (divident / divisor);\n+        }\n+        return 1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For lower limit {@code a}, upper limit {@code b}, and mode {@code c},\n+     * the mean is {@code (a + b + c) / 3}.\n+     */\n+    public double getNumericalMean() {\n+        return (a + b + c) / 3;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For lower limit {@code a}, upper limit {@code b}, and mode {@code c},\n+     * the variance is {@code (a^2 + b^2 + c^2 - a * b - a * c - b * c) / 18}.\n+     */\n+    public double getNumericalVariance() {\n+        return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is equal to the lower limit parameter\n+     * {@code a} of the distribution.\n+     *\n+     * @return lower bound of the support\n+     */\n+    public double getSupportLowerBound() {\n+        return a;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is equal to the upper limit parameter\n+     * {@code b} of the distribution.\n+     *\n+     * @return upper bound of the support\n+     */\n+    public double getSupportUpperBound() {\n+        return b;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    @Override\n+    public double inverseCumulativeProbability(double p)\n+        throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+        if (p == 0.0) {\n+            return a;\n+        }\n+        if (p == 1.0) {\n+            return b;\n+        }\n+        final double pc = (c - a) / (b - a);\n+        if (p == pc) {\n+            return c;\n+        }\n+        if (p < pc) {\n+            return a + FastMath.sqrt(p * (b - a) * (c - a));\n+        }\n+        return b - FastMath.sqrt((1 - p) * (b - a) * (b - c));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/TriangularDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for {@link TriangularDistribution}. See class javadoc for\n+ * {@link RealDistributionAbstractTest} for further details.\n+ */\n+public class TriangularDistributionTest extends RealDistributionAbstractTest {\n+\n+    // --- Override tolerance -------------------------------------------------\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(1e-4);\n+    }\n+\n+    //--- Implementations for abstract methods --------------------------------\n+\n+    /**\n+     * Creates the default triangular distribution instance to use in tests.\n+     */\n+    @Override\n+    public TriangularDistribution makeDistribution() {\n+        // Left side 5 wide, right side 10 wide.\n+        return new TriangularDistribution(-3, 2, 12);\n+    }\n+\n+    /**\n+     * Creates the default cumulative probability distribution test input\n+     * values.\n+     */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        return new double[] { -3.0001,                 // below lower limit\n+                              -3.0,                    // at lower limit\n+                              -2.0, -1.0, 0.0, 1.0,    // on lower side\n+                              2.0,                     // at mode\n+                              3.0, 4.0, 10.0, 11.0,    // on upper side\n+                              12.0,                    // at upper limit\n+                              12.0001                  // above upper limit\n+                            };\n+    }\n+\n+    /**\n+     * Creates the default cumulative probability density test expected values.\n+     */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        // Top at 2 / (b - a) = 2 / (12 - -3) = 2 / 15 = 7.5\n+        // Area left  = 7.5 * 5  * 0.5 = 18.75 (1/3 of the total area)\n+        // Area right = 7.5 * 10 * 0.5 = 37.5  (2/3 of the total area)\n+        // Area total = 18.75 + 37.5 = 56.25\n+        // Derivative left side = 7.5 / 5 = 1.5\n+        // Derivative right side = -7.5 / 10 = -0.75\n+        double third = 1 / 3.0;\n+        double left = 18.75;\n+        double area = 56.25;\n+        return new double[] { 0.0,\n+                              0.0,\n+                              0.75 / area, 3 / area, 6.75 / area, 12 / area,\n+                              third,\n+                              (left + 7.125) / area, (left + 13.5) / area,\n+                              (left + 36) / area, (left + 37.125) / area,\n+                              1.0,\n+                              1.0\n+                            };\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability distribution test\n+     * input values.\n+     */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        // Exclude the points outside the limits, as they have cumulative\n+        // probability of zero and one, meaning the inverse returns the\n+        // limits and not the points outside the limits.\n+        double[] points = makeCumulativeTestValues();\n+        return Arrays.copyOfRange(points, 1, points.length - 1);\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability density test expected\n+     * values.\n+     */\n+    @Override\n+    public double[] makeInverseCumulativeTestValues() {\n+        // Exclude the points outside the limits, as they have cumulative\n+        // probability of zero and one, meaning the inverse returns the\n+        // limits and not the points outside the limits.\n+        double[] points = makeCumulativeTestPoints();\n+        return Arrays.copyOfRange(points, 1, points.length - 1);\n+    }\n+\n+    /** Creates the default probability density test expected values. */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] { 0,\n+                              0,\n+                              2 / 75.0, 4 / 75.0, 6 / 75.0, 8 / 75.0,\n+                              10 / 75.0,\n+                              9 / 75.0, 8 / 75.0, 2 / 75.0, 1 / 75.0,\n+                              0,\n+                              0\n+                            };\n+    }\n+\n+    //--- Additional test cases -----------------------------------------------\n+\n+    /** Test lower bound getter. */\n+    @Test\n+    public void testGetLowerBound() {\n+        TriangularDistribution distribution = makeDistribution();\n+        Assert.assertEquals(-3.0, distribution.getSupportLowerBound(), 0);\n+    }\n+\n+    /** Test upper bound getter. */\n+    @Test\n+    public void testGetUpperBound() {\n+        TriangularDistribution distribution = makeDistribution();\n+        Assert.assertEquals(12.0, distribution.getSupportUpperBound(), 0);\n+    }\n+\n+    /** Test pre-condition for equal lower/upper limit. */\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testPreconditions1() {\n+        new TriangularDistribution(0, 0, 0);\n+    }\n+\n+    /** Test pre-condition for lower limit larger than upper limit. */\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testPreconditions2() {\n+        new TriangularDistribution(1, 1, 0);\n+    }\n+\n+    /** Test pre-condition for mode larger than upper limit. */\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testPreconditions3() {\n+        new TriangularDistribution(0, 2, 1);\n+    }\n+\n+    /** Test pre-condition for mode smaller than lower limit. */\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testPreconditions4() {\n+        new TriangularDistribution(2, 1, 3);\n+    }\n+\n+    /** Test mean/variance. */\n+    @Test\n+    public void testMeanVariance() {\n+        TriangularDistribution dist;\n+\n+        dist = new TriangularDistribution(0, 0.5, 1.0);\n+        Assert.assertEquals(dist.getNumericalMean(), 0.5, 0);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1 / 24.0, 0);\n+\n+        dist = new TriangularDistribution(0, 1, 1);\n+        Assert.assertEquals(dist.getNumericalMean(), 2 / 3.0, 0);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1 / 18.0, 0);\n+\n+        dist = new TriangularDistribution(-3, 2, 12);\n+        Assert.assertEquals(dist.getNumericalMean(), 3 + (2 / 3.0), 0);\n+        Assert.assertEquals(dist.getNumericalVariance(), 175 / 18.0, 0);\n+    }\n+}", "timestamp": 1326351703, "metainfo": ""}