{"sha": "79d55e7f436d22beb94801fa79bc80ffce60cf9a", "log": "MATH-854: populate the throws clause in package o.a.c.m.linear.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n      */\n     protected AbstractFieldMatrix(final Field<T> field,\n                                   final int rowDimension,\n-                                  final int columnDimension) {\n+                                  final int columnDimension)\n+        throws NotStrictlyPositiveException {\n         if (rowDimension <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n                                                    rowDimension);\n      * @throws NullArgumentException if the array is {@code null}.\n      * @throws NoDataException if the array is empty.\n      */\n-    protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) {\n+    protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d)\n+        throws NoDataException, NullArgumentException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @return the field to which the array elements belong.\n      * @throws NoDataException if array is empty.\n      */\n-    protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) {\n+    protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d)\n+        throws NoDataException {\n         if (d.length == 0) {\n             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n     public abstract FieldMatrix<T> copy();\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> add(FieldMatrix<T> m) {\n+    public FieldMatrix<T> add(FieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         // safety check\n         checkAdditionCompatible(m);\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> subtract(final FieldMatrix<T> m) {\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         // safety check\n         checkSubtractionCompatible(m);\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> multiply(final FieldMatrix<T> m) {\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws DimensionMismatchException {\n         // safety check\n         checkMultiplicationCompatible(m);\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> preMultiply(final FieldMatrix<T> m) {\n+    public FieldMatrix<T> preMultiply(final FieldMatrix<T> m)\n+        throws DimensionMismatchException {\n         return m.multiply(this);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> power(final int p) {\n+    public FieldMatrix<T> power(final int p) throws NonSquareMatrixException,\n+    NotPositiveException {\n         if (p < 0) {\n-            throw new IllegalArgumentException(\"p must be >= 0\");\n+            throw new NotPositiveException(p);\n         }\n \n         if (!isSquare()) {\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                       final int startColumn, final int endColumn)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n \n         final FieldMatrix<T> subMatrix =\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> getSubMatrix(final int[] selectedRows,\n-                                       final int[] selectedColumns) {\n+                                       final int[] selectedColumns)\n+    throws NoDataException, NullArgumentException, OutOfRangeException {\n \n         // safety checks\n         checkSubMatrixIndex(selectedRows, selectedColumns);\n     /** {@inheritDoc} */\n     public void copySubMatrix(final int startRow, final int endRow,\n                               final int startColumn, final int endColumn,\n-                              final T[][] destination) {\n+                              final T[][] destination)\n+    throws MatrixDimensionMismatchException, NumberIsTooSmallException,\n+    OutOfRangeException{\n         // safety checks\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         final int rowsCount    = endRow + 1 - startRow;\n     }\n \n     /** {@inheritDoc} */\n-    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination) {\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n+        throws MatrixDimensionMismatchException, NoDataException,\n+        NullArgumentException, OutOfRangeException {\n         // safety checks\n         checkSubMatrixIndex(selectedRows, selectedColumns);\n         if ((destination.length < selectedRows.length) ||\n \n     }\n \n-    /** {@inheritDoc} */\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n+    /**\n+     * {@inheritDoc}\n+     *\n+     */\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n+        throws DimensionMismatchException, NoDataException, NullArgumentException,\n+        OutOfRangeException {\n         if (subMatrix == null) {\n             throw new NullArgumentException();\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> getRowMatrix(final int row) {\n+    public FieldMatrix<T> getRowMatrix(final int row) throws OutOfRangeException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         final FieldMatrix<T> out = createMatrix(1, nCols);\n     }\n \n     /** {@inheritDoc} */\n-    public void setRowMatrix(final int row, final FieldMatrix<T> matrix) {\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> getColumnMatrix(final int column) {\n+    public FieldMatrix<T> getColumnMatrix(final int column)\n+    throws OutOfRangeException {\n \n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix) {\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n+        throws OutOfRangeException {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n     }\n \n     /** {@inheritDoc} */\n-    public void setRowVector(final int row, final FieldVector<T> vector) {\n+    public void setRowVector(final int row, final FieldVector<T> vector)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumnVector(final int column, final FieldVector<T> vector) {\n+    public void setColumnVector(final int column, final FieldVector<T> vector)\n+        throws OutOfRangeException {\n+\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n     }\n \n     /** {@inheritDoc} */\n-    public T[] getRow(final int row) {\n+    public T[] getRow(final int row) throws OutOfRangeException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         final T[] out = buildArray(field, nCols);\n     }\n \n     /** {@inheritDoc} */\n-    public void setRow(final int row, final T[] array) {\n+    public void setRow(final int row, final T[] array) throws OutOfRangeException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public T[] getColumn(final int column) {\n+    public T[] getColumn(final int column) throws OutOfRangeException {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         final T[] out = buildArray(field, nRows);\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumn(final int column, final T[] array) {\n+    public void setColumn(final int column, final T[] array)\n+        throws OutOfRangeException {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n     public abstract int getColumnDimension();\n \n     /** {@inheritDoc} */\n-    public T getTrace() {\n+    public T getTrace() throws NonSquareMatrixException {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (nRows != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public T[] operate(final T[] v) {\n+    public T[] operate(final T[] v) throws DimensionMismatchException {\n \n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> operate(final FieldVector<T> v) {\n+    public FieldVector<T> operate(final FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return new ArrayFieldVector<T>(field, operate(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public T[] preMultiply(final T[] v) {\n+    public T[] preMultiply(final T[] v) throws DimensionMismatchException {\n \n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> preMultiply(final FieldVector<T> v) {\n+    public FieldVector<T> preMultiply(final FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return new ArrayFieldVector<T>(field, preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n     /** {@inheritDoc} */\n     public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn) {\n+                               final int startColumn, final int endColumn)\n+    throws NumberIsTooSmallException, OutOfRangeException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     /** {@inheritDoc} */\n     public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn) {\n+                               final int startColumn, final int endColumn)\n+    throws NumberIsTooSmallException, OutOfRangeException{\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n      * @param row Row index to check.\n      * @throws OutOfRangeException if {@code index} is not valid.\n      */\n-    protected void checkRowIndex(final int row) {\n+    protected void checkRowIndex(final int row) throws OutOfRangeException {\n         if (row < 0 || row >= getRowDimension()) {\n             throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                           row, 0, getRowDimension() - 1);\n      * @param column Column index to check.\n      * @throws OutOfRangeException if {@code index} is not valid.\n      */\n-    protected void checkColumnIndex(final int column) {\n+    protected void checkColumnIndex(final int column)\n+        throws OutOfRangeException {\n         if (column < 0 || column >= getColumnDimension()) {\n             throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, getColumnDimension() - 1);\n      * {@code endColumn < startColumn}.\n      */\n     protected void checkSubMatrixIndex(final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                       final int startColumn, final int endColumn)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         checkRowIndex(startRow);\n         checkRowIndex(endRow);\n         if (endRow < startRow) {\n      * @throws NoDataException if the arrays have zero length.\n      * @throws OutOfRangeException if row or column selections are not valid.\n      */\n-    protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n+    protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns)\n+        throws NoDataException, NullArgumentException, OutOfRangeException {\n         if (selectedRows == null ||\n             selectedColumns == null) {\n             throw new NullArgumentException();\n      * @throws MatrixDimensionMismatchException if the matrix is not\n      * addition-compatible with instance.\n      */\n-    protected void checkAdditionCompatible(final FieldMatrix<T> m) {\n+    protected void checkAdditionCompatible(final FieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         if ((getRowDimension() != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n             throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(),\n      * @throws MatrixDimensionMismatchException if the matrix is not\n      * subtraction-compatible with instance.\n      */\n-    protected void checkSubtractionCompatible(final FieldMatrix<T> m) {\n+    protected void checkSubtractionCompatible(final FieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         if ((getRowDimension() != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n             throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(),\n      * @throws DimensionMismatchException if the matrix is not\n      * multiplication-compatible with instance.\n      */\n-    protected void checkMultiplicationCompatible(final FieldMatrix<T> m) {\n+    protected void checkMultiplicationCompatible(final FieldMatrix<T> m)\n+        throws DimensionMismatchException {\n         if (getColumnDimension() != m.getRowDimension()) {\n             throw new DimensionMismatchException(m.getRowDimension(), getColumnDimension());\n         }\n--- a/src/main/java/org/apache/commons/math3/linear/ConjugateGradient.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ConjugateGradient.java\n      * @param delta the &delta; parameter for the default stopping criterion\n      * @param check {@code true} if positive definiteness of both matrix and\n      * preconditioner should be checked\n+     * @throws NullArgumentException if {@code manager} is {@code null}\n      */\n     public ConjugateGradient(final IterationManager manager,\n-                             final double delta, final boolean check) {\n+                             final double delta, final boolean check)\n+        throws NullArgumentException {\n         super(manager);\n         this.delta = delta;\n         this.check = check;\n         return check;\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws NonPositiveDefiniteOperatorException if {@code a} or {@code m} is\n+     * not positive definite\n+     */\n     @Override\n     public RealVector solveInPlace(final RealLinearOperator a,\n-        final RealLinearOperator m, final RealVector b, final RealVector x0)\n-        throws NullArgumentException, NonSquareOperatorException,\n-        DimensionMismatchException, MaxCountExceededException {\n+                                   final RealLinearOperator m,\n+                                   final RealVector b,\n+                                   final RealVector x0)\n+        throws NullArgumentException, NonPositiveDefiniteOperatorException,\n+        NonSquareOperatorException, DimensionMismatchException,\n+        MaxCountExceededException, NonPositiveDefiniteOperatorException {\n         checkParameters(a, m, b, x0);\n         final IterationManager manager = getIterationManager();\n         // Initialization of default stopping criterion\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n      * @throws MathArithmeticException if the decomposition of a general matrix\n      * results in a matrix with zero norm\n      */\n-    public EigenDecomposition(final RealMatrix matrix)  {\n+    public EigenDecomposition(final RealMatrix matrix)\n+        throws MathArithmeticException {\n         if (isSymmetric(matrix, false)) {\n             transformToTridiagonal(matrix);\n             findEigenVectors(transformer.getQ().getData());\n      * @param matrix Matrix to decompose.\n      * @param splitTolerance Dummy parameter (present for backward\n      * compatibility only).\n+     * @throws MathArithmeticException  if the decomposition of a general matrix\n+     * results in a matrix with zero norm\n      * @throws MaxCountExceededException if the algorithm fails to converge.\n      * @deprecated in 3.1 (to be removed in 4.0) due to unused parameter\n      */\n     @Deprecated\n     public EigenDecomposition(final RealMatrix matrix,\n-                              final double splitTolerance)  {\n+                              final double splitTolerance)\n+        throws MathArithmeticException {\n         this(matrix);\n     }\n \n      * @param schur the schur transformation of the matrix\n      * @throws MathArithmeticException if the Schur form has a norm of zero\n      */\n-    private void findEigenVectorsFromSchur(final SchurTransformer schur) {\n+    private void findEigenVectorsFromSchur(final SchurTransformer schur)\n+        throws MathArithmeticException {\n         final double[][] matrixT = schur.getT().getData();\n         final double[][] matrixP = schur.getP().getData();\n \n--- a/src/main/java/org/apache/commons/math3/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/FieldMatrix.java\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.exception.ZeroException;\n \n /**\n  * Interface defining field-valued matrix with basic algebraic operations.\n      * @param rowDimension  the number of rows in the new matrix\n      * @param columnDimension  the number of columns in the new matrix\n      * @return a new matrix of the same type as the instance\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if row or column dimension is not positive.\n+     * @throws NotStrictlyPositiveException if row or column dimension is not\n+     * positive.\n      * @since 2.0\n      */\n-    FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension);\n+    FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+    throws NotStrictlyPositiveException;\n \n     /**\n      * Make a (deep) copy of this.\n      *\n      * @param m Matrix to be added.\n      * @return {@code this} + {@code m}.\n-     * @throws MatrixDimensionMismatchException\n-     * if {@code m} is not the same size as this matrix.\n-     */\n-    FieldMatrix<T> add(FieldMatrix<T> m);\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as {@code this} matrix.\n+     */\n+    FieldMatrix<T> add(FieldMatrix<T> m) throws MatrixDimensionMismatchException;\n \n     /**\n      * Subtract {@code m} from this matrix.\n      *\n      * @param m Matrix to be subtracted.\n      * @return {@code this} - {@code m}.\n-     * @throws MatrixDimensionMismatchException\n-     * if {@code m} is not the same size as this matrix.\n-     */\n-    FieldMatrix<T> subtract(FieldMatrix<T> m);\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as {@code this} matrix.\n+     */\n+    FieldMatrix<T> subtract(FieldMatrix<T> m) throws MatrixDimensionMismatchException;\n \n      /**\n      * Increment each entry of this matrix.\n      *\n      * @param m  Matrix to postmultiply by.\n      * @return {@code this} * {@code m}.\n-     * @throws IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n-     */\n-    FieldMatrix<T> multiply(FieldMatrix<T> m);\n+     * @throws DimensionMismatchException if the number of columns of\n+     * {@code this} matrix is not equal to the number of rows of matrix\n+     * {@code m}.\n+     */\n+    FieldMatrix<T> multiply(FieldMatrix<T> m) throws DimensionMismatchException;\n \n     /**\n      * Premultiply this matrix by {@code m}.\n      *\n      * @param m Matrix to premultiply by.\n      * @return {@code m} * {@code this}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if the number of columns of {@code m} differ from the number of rows\n-     * of this matrix.\n-     */\n-    FieldMatrix<T> preMultiply(FieldMatrix<T> m);\n+     * @throws DimensionMismatchException if the number of columns of {@code m}\n+     * differs from the number of rows of {@code this} matrix.\n+     */\n+    FieldMatrix<T> preMultiply(FieldMatrix<T> m) throws DimensionMismatchException;\n \n     /**\n      * Returns the result multiplying this with itself <code>p</code> times.\n-     * Depending on the type of the field elements, T,\n-     * instability for high powers might occur.\n-     * @param      p raise this to power p\n-     * @return     this^p\n-     * @throws     IllegalArgumentException if p < 0\n-     *             NonSquareMatrixException if the matrix is not square\n-     */\n-    FieldMatrix<T> power(final int p);\n+     * Depending on the type of the field elements, T, instability for high\n+     * powers might occur.\n+     *\n+     * @param p raise this to power p\n+     * @return this^p\n+     * @throws NotPositiveException if {@code p < 0}\n+     * @throws NonSquareMatrixException if {@code this matrix} is not square\n+     */\n+    FieldMatrix<T> power(final int p) throws NonSquareMatrixException,\n+    NotPositiveException;\n \n     /**\n      * Returns matrix entries as a two-dimensional array.\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n-     * @return the matrix containing the data of the\n-     * specified rows and columns.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the indices are not valid.\n-     */\n-   FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn);\n+     * @return the matrix containing the data of the specified rows and columns.\n+     * @throws NumberIsTooSmallException is {@code endRow < startRow} of\n+     * {@code endColumn < startColumn}.\n+     * @throws OutOfRangeException if the indices are not valid.\n+     */\n+   FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n+   throws NumberIsTooSmallException, OutOfRangeException;\n \n    /**\n     * Get a submatrix. Rows and columns are indicated\n     * @param selectedColumns Array of column indices.\n     * @return the matrix containing the data in the\n     * specified rows and columns.\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if row or column selections are not valid.\n-    */\n-   FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns);\n+    * @throws NoDataException if {@code selectedRows} or\n+    * {@code selectedColumns} is empty\n+    * @throws NullArgumentException if {@code selectedRows} or\n+    * {@code selectedColumns} is {@code null}.\n+    * @throws OutOfRangeException if row or column selections are not valid.\n+    */\n+   FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+   throws NoDataException, NullArgumentException, OutOfRangeException;\n \n    /**\n     * Copy a submatrix. Rows and columns are indicated\n     * @param endColumn Final column index (inclusive).\n     * @param destination The arrays where the submatrix data should be copied\n     * (if larger than rows/columns counts, only the upper-left part will be used).\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the indices are not valid.\n+    * @throws MatrixDimensionMismatchException if the dimensions of\n+    * {@code destination} do not match those of {@code this}.\n+    * @throws NumberIsTooSmallException is {@code endRow < startRow} of\n+    * {@code endColumn < startColumn}.\n+    * @throws OutOfRangeException if the indices are not valid.\n     * @exception IllegalArgumentException if the destination array is too small.\n     */\n-  void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n-                     T[][] destination);\n+    void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n+                       T[][] destination)\n+    throws MatrixDimensionMismatchException, NumberIsTooSmallException,\n+    OutOfRangeException;\n \n   /**\n    * Copy a submatrix. Rows and columns are indicated\n    * @param selectedColumns Array of column indices.\n    * @param destination Arrays where the submatrix data should be copied\n    * (if larger than rows/columns counts, only the upper-left part will be used)\n-   * @throws org.apache.commons.math3.exception.OutOfRangeException\n-   * if the indices are not valid.\n-   * @exception IllegalArgumentException if the destination array is too small\n+   * @throws MatrixDimensionMismatchException if the dimensions of\n+   * {@code destination} do not match those of {@code this}.\n+   * @throws NoDataException if {@code selectedRows} or\n+   * {@code selectedColumns} is empty\n+   * @throws NullArgumentException if {@code selectedRows} or\n+   * {@code selectedColumns} is {@code null}.\n+   * @throws OutOfRangeException if the indices are not valid.\n    */\n-  void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination);\n+  void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n+  throws MatrixDimensionMismatchException, NoDataException, NullArgumentException,\n+  OutOfRangeException;\n \n    /**\n     * Replace the submatrix starting at {@code (row, column)} using data in\n     * if {@code subMatrix} is {@code null}.\n     * @since 2.0\n     */\n-  void setSubMatrix(T[][] subMatrix, int row, int column);\n+    void setSubMatrix(T[][] subMatrix, int row, int column)\n+    throws DimensionMismatchException, MatrixDimensionMismatchException,\n+           NullArgumentException, ZeroException;\n \n    /**\n     * Get the entries in row number {@code row}\n     *\n     * @param row Row to be fetched.\n     * @return a row matrix.\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified row index is invalid.\n-    */\n-   FieldMatrix<T> getRowMatrix(int row);\n+    * @throws OutOfRangeException if the specified row index is invalid.\n+    */\n+   FieldMatrix<T> getRowMatrix(int row) throws OutOfRangeException;\n \n    /**\n     * Set the entries in row number {@code row}\n     * @param row Row to be set.\n     * @param matrix Row matrix (must have one row and the same number\n     * of columns as the instance).\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified row index is invalid.\n+    * @throws OutOfRangeException if the specified row index is invalid.\n     * @throws MatrixDimensionMismatchException\n     * if the matrix dimensions do not match one instance row.\n     */\n-   void setRowMatrix(int row, FieldMatrix<T> matrix);\n+   void setRowMatrix(int row, FieldMatrix<T> matrix)\n+   throws MatrixDimensionMismatchException, OutOfRangeException;\n \n    /**\n     * Get the entries in column number {@code column}\n     *\n     * @param column Column to be fetched.\n     * @return a column matrix.\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified column index is invalid.\n-    */\n-   FieldMatrix<T> getColumnMatrix(int column);\n+    * @throws OutOfRangeException if the specified column index is invalid.\n+    */\n+   FieldMatrix<T> getColumnMatrix(int column) throws OutOfRangeException;\n \n    /**\n     * Set the entries in column number {@code column}\n     * @param column Column to be set.\n     * @param matrix column matrix (must have one column and the same\n     * number of rows as the instance).\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified column index is invalid.\n-    * @throws MatrixDimensionMismatchException\n-    * if the matrix dimensions do not match one instance column.\n-    */\n-   void setColumnMatrix(int column, FieldMatrix<T> matrix);\n+    * @throws OutOfRangeException if the specified column index is invalid.\n+    * @throws MatrixDimensionMismatchException if the matrix dimensions do\n+    * not match one instance column.\n+    */\n+   void setColumnMatrix(int column, FieldMatrix<T> matrix)\n+   throws MatrixDimensionMismatchException, OutOfRangeException;\n \n    /**\n     * Get the entries in row number {@code row}\n     *\n     * @param row Row to be fetched\n     * @return a row vector.\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified row index is invalid.\n-    */\n-   FieldVector<T> getRowVector(int row);\n+    * @throws OutOfRangeException if the specified row index is invalid.\n+    */\n+   FieldVector<T> getRowVector(int row) throws OutOfRangeException;\n \n    /**\n     * Set the entries in row number {@code row}\n     * @param row Row to be set.\n     * @param vector row vector (must have the same number of columns\n     * as the instance).\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified row index is invalid.\n-    * @throws MatrixDimensionMismatchException\n-    * if the vector dimension does not match one instance row.\n-    */\n-   void setRowVector(int row, FieldVector<T> vector);\n+    * @throws OutOfRangeException if the specified row index is invalid.\n+    * @throws MatrixDimensionMismatchException if the vector dimension does not\n+    * match one instance row.\n+    */\n+   void setRowVector(int row, FieldVector<T> vector)\n+   throws MatrixDimensionMismatchException, OutOfRangeException;\n \n    /**\n     * Returns the entries in column number {@code column}\n     *\n     * @param column Column to be fetched.\n     * @return a column vector.\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified column index is invalid.\n-    */\n-   FieldVector<T> getColumnVector(int column);\n+    * @throws OutOfRangeException if the specified column index is invalid.\n+    */\n+   FieldVector<T> getColumnVector(int column) throws OutOfRangeException;\n \n    /**\n     * Set the entries in column number {@code column}\n     * @param column Column to be set.\n     * @param vector Column vector (must have the same number of rows\n     * as the instance).\n-    * @throws org.apache.commons.math3.exception.OutOfRangeException\n-    * if the specified column index is invalid.\n-    * @throws MatrixDimensionMismatchException\n-    * if the vector dimension does not match one instance column.\n-    */\n-   void setColumnVector(int column, FieldVector<T> vector);\n+    * @throws OutOfRangeException if the specified column index is invalid.\n+    * @throws MatrixDimensionMismatchException if the vector dimension does not\n+    * match one instance column.\n+    */\n+   void setColumnVector(int column, FieldVector<T> vector)\n+   throws MatrixDimensionMismatchException, OutOfRangeException;\n \n     /**\n      * Get the entries in row number {@code row} as an array.\n      *\n      * @param row Row to be fetched.\n      * @return array of entries in the row.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the specified row index is not valid.\n-     */\n-    T[] getRow(int row);\n+     * @throws OutOfRangeException if the specified row index is not valid.\n+     */\n+    T[] getRow(int row) throws OutOfRangeException;\n \n     /**\n      * Set the entries in row number {@code row}\n      * @param row Row to be set.\n      * @param array Row matrix (must have the same number of columns as\n      * the instance).\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the specified row index is invalid.\n-     * @throws MatrixDimensionMismatchException\n-     * if the array size does not match one instance row.\n-     */\n-    void setRow(int row, T[] array);\n+     * @throws OutOfRangeException if the specified row index is invalid.\n+     * @throws MatrixDimensionMismatchException if the array size does not match\n+     * one instance row.\n+     */\n+    void setRow(int row, T[] array) throws MatrixDimensionMismatchException,\n+    OutOfRangeException;\n \n     /**\n      * Get the entries in column number {@code col} as an array.\n      *\n      * @param column the column to be fetched\n      * @return array of entries in the column\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the specified column index is not valid.\n-     */\n-    T[] getColumn(int column);\n+     * @throws OutOfRangeException if the specified column index is not valid.\n+     */\n+    T[] getColumn(int column) throws OutOfRangeException;\n \n     /**\n      * Set the entries in column number {@code column}\n      *\n      * @param column the column to be set\n      * @param array column array (must have the same number of rows as the instance)\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the specified column index is invalid.\n-     * @throws MatrixDimensionMismatchException\n-     * if the array size does not match one instance column.\n-     */\n-    void setColumn(int column, T[] array);\n+     * @throws OutOfRangeException if the specified column index is invalid.\n+     * @throws MatrixDimensionMismatchException if the array size does not match\n+     * one instance column.\n+     */\n+    void setColumn(int column, T[] array) throws MatrixDimensionMismatchException,\n+    OutOfRangeException;\n \n     /**\n      * Returns the entry in the specified row and column.\n      * @param row  row location of entry to be fetched\n      * @param column  column location of entry to be fetched\n      * @return matrix entry in row,column\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the row or column index is not valid.\n-     */\n-    T getEntry(int row, int column);\n+     * @throws OutOfRangeException if the row or column index is not valid.\n+     */\n+    T getEntry(int row, int column) throws OutOfRangeException;\n \n     /**\n      * Set the entry in the specified row and column.\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param value matrix entry to be set in row,column\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the row or column index is not valid.\n+     * @throws OutOfRangeException if the row or column index is not valid.\n      * @since 2.0\n      */\n-    void setEntry(int row, int column, T value);\n+    void setEntry(int row, int column, T value) throws OutOfRangeException;\n \n     /**\n      * Change an entry in the specified row and column.\n      * @param column Column location of entry to be set.\n      * @param increment Value to add to the current matrix entry in\n      * {@code (row, column)}.\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the row or column index is not valid.\n+     * @throws OutOfRangeException if the row or column index is not valid.\n      * @since 2.0\n      */\n-    void addToEntry(int row, int column, T increment);\n+    void addToEntry(int row, int column, T increment) throws OutOfRangeException;\n \n     /**\n      * Change an entry in the specified row and column.\n      * @param column Column location of entry to be set.\n      * @param factor Multiplication factor for the current matrix entry\n      * in {@code (row,column)}\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the row or column index is not valid.\n+     * @throws OutOfRangeException if the row or column index is not valid.\n      * @since 2.0\n      */\n-    void multiplyEntry(int row, int column, T factor);\n+    void multiplyEntry(int row, int column, T factor) throws OutOfRangeException;\n \n     /**\n      * Returns the transpose of this matrix.\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n      * @return trace\n-     * @throws NonSquareMatrixException\n-     * if the matrix is not square.\n-     */\n-    T getTrace();\n-\n-    /**\n-     * Returns the result of multiplying this by the vector <code>v</code>.\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     */\n+    T getTrace() throws NonSquareMatrixException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector {@code v}.\n      *\n      * @param v the vector to operate on\n-     * @return this*v\n-     * @throws IllegalArgumentException if columnDimension != v.size()\n-     */\n-    T[] operate(T[] v);\n-\n-    /**\n-     * Returns the result of multiplying this by the vector <code>v</code>.\n+     * @return {@code this * v}\n+     * @throws DimensionMismatchException if the number of columns of\n+     * {@code this} matrix is not equal to the size of the vector {@code v}.\n+     */\n+    T[] operate(T[] v) throws DimensionMismatchException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector {@code v}.\n      *\n      * @param v the vector to operate on\n-     * @return this*v\n-     * @throws IllegalArgumentException if columnDimension != v.size()\n-     */\n-    FieldVector<T> operate(FieldVector<T> v);\n-\n-    /**\n-     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     * @return {@code this * v}\n+     * @throws DimensionMismatchException if the number of columns of\n+     * {@code this} matrix is not equal to the size of the vector {@code v}.\n+     */\n+    FieldVector<T> operate(FieldVector<T> v) throws DimensionMismatchException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector\n+     * {@code v}.\n      *\n      * @param v the row vector to premultiply by\n-     * @return v*this\n-     * @throws IllegalArgumentException if rowDimension != v.size()\n-     */\n-    T[] preMultiply(T[] v);\n-\n-    /**\n-     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     * @return {@code v * this}\n+     * @throws DimensionMismatchException if the number of rows of {@code this}\n+     * matrix is not equal to the size of the vector {@code v}\n+     */\n+    T[] preMultiply(T[] v) throws DimensionMismatchException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector\n+     * {@code v}.\n      *\n      * @param v the row vector to premultiply by\n-     * @return v*this\n-     * @throws IllegalArgumentException if rowDimension != v.size()\n-     */\n-    FieldVector<T> preMultiply(FieldVector<T> v);\n+     * @return {@code v * this}\n+     * @throws DimensionMismatchException if the number of rows of {@code this}\n+     * matrix is not equal to the size of the vector {@code v}\n+     */\n+    FieldVector<T> preMultiply(FieldVector<T> v) throws DimensionMismatchException;\n \n     /**\n      * Visit (and possibly change) all matrix entries in row order.\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the indices are not valid.\n+     * @throws OutOfRangeException if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n      * of the walk\n      */\n     T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor,\n-                     int startRow, int endRow, int startColumn, int endColumn);\n+                     int startRow, int endRow, int startColumn, int endColumn)\n+    throws OutOfRangeException;\n \n     /**\n      * Visit (but don't change) some matrix entries in row order.\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the indices are not valid.\n+     * @throws OutOfRangeException if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * of the walk\n      */\n     T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor,\n-                     int startRow, int endRow, int startColumn, int endColumn);\n+                     int startRow, int endRow, int startColumn, int endColumn)\n+    throws OutOfRangeException;\n \n     /**\n      * Visit (and possibly change) all matrix entries in column order.\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * of the walk\n      */\n     T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor,\n-                        int startRow, int endRow, int startColumn, int endColumn);\n+                        int startRow, int endRow, int startColumn, int endColumn)\n+    throws NumberIsTooSmallException, OutOfRangeException;\n \n     /**\n      * Visit (but don't change) some matrix entries in column order.\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * of the walk\n      */\n     T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor,\n-                        int startRow, int endRow, int startColumn, int endColumn);\n+                        int startRow, int endRow, int startColumn, int endColumn)\n+    throws NumberIsTooSmallException, OutOfRangeException;\n \n     /**\n      * Visit (and possibly change) all matrix entries using the fastest possible order.\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * of the walk\n      */\n     T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor,\n-                           int startRow, int endRow, int startColumn, int endColumn);\n+                           int startRow, int endRow, int startColumn, int endColumn)\n+    throws NumberIsTooSmallException, OutOfRangeException;\n \n     /**\n      * Visit (but don't change) some matrix entries using the fastest possible order.\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n+     * @throws OutOfRangeException if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * of the walk\n      */\n     T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor,\n-                           int startRow, int endRow, int startColumn, int endColumn);\n+                           int startRow, int endRow, int startColumn, int endColumn)\n+    throws NumberIsTooSmallException, OutOfRangeException;\n }\n--- a/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.MathArithmeticException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n      * @throws NoDataException if a row or column is empty.\n      * @throws NullArgumentException if either {@code data} or {@code data[0]}\n      * is {@code null}.\n+     * @throws DimensionMismatchException if {@code data} is not rectangular.\n      * @see #createRealMatrix(int, int)\n      */\n-    public static RealMatrix createRealMatrix(double[][] data) {\n+    public static RealMatrix createRealMatrix(double[][] data)\n+        throws NullArgumentException, DimensionMismatchException,\n+        NoDataException {\n         if (data == null ||\n             data[0] == null) {\n             throw new NullArgumentException();\n      * @see #createFieldMatrix(Field, int, int)\n      * @since 2.0\n      */\n-    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) {\n+    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data)\n+        throws DimensionMismatchException, NoDataException, NullArgumentException {\n         if (data == null ||\n             data[0] == null) {\n             throw new NullArgumentException();\n      * @throws NoDataException if {@code data} is empty.\n      * @throws NullArgumentException if {@code data} is {@code null}.\n      */\n-    public static RealVector createRealVector(double[] data) {\n+    public static RealVector createRealVector(double[] data)\n+        throws NoDataException, NullArgumentException {\n         if (data == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code data} is {@code null}.\n      * @throws ZeroException if {@code data} has 0 elements\n      */\n-    public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n+    public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data)\n+        throws NoDataException, NullArgumentException, ZeroException {\n         if (data == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NoDataException if {@code rowData} is empty.\n      * @throws NullArgumentException if {@code rowData} is {@code null}.\n      */\n-    public static RealMatrix createRowRealMatrix(double[] rowData) {\n+    public static RealMatrix createRowRealMatrix(double[] rowData)\n+        throws NoDataException, NullArgumentException {\n         if (rowData == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code rowData} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T>\n-        createRowFieldMatrix(final T[] rowData) {\n+        createRowFieldMatrix(final T[] rowData)\n+        throws NoDataException, NullArgumentException {\n         if (rowData == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NoDataException if {@code columnData} is empty.\n      * @throws NullArgumentException if {@code columnData} is {@code null}.\n      */\n-    public static RealMatrix createColumnRealMatrix(double[] columnData) {\n+    public static RealMatrix createColumnRealMatrix(double[] columnData)\n+        throws NoDataException, NullArgumentException {\n         if (columnData == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code columnData} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T>\n-        createColumnFieldMatrix(final T[] columnData) {\n+        createColumnFieldMatrix(final T[] columnData)\n+        throws NoDataException, NullArgumentException {\n         if (columnData == null) {\n             throw new NullArgumentException();\n         }\n      * a valid index.\n      */\n     public static void checkMatrixIndex(final AnyMatrix m,\n-                                        final int row, final int column) {\n+                                        final int row, final int column)\n+        throws OutOfRangeException {\n         checkRowIndex(m, row);\n         checkColumnIndex(m, column);\n     }\n      * @param row Row index to check.\n      * @throws OutOfRangeException if {@code row} is not a valid index.\n      */\n-    public static void checkRowIndex(final AnyMatrix m, final int row) {\n+    public static void checkRowIndex(final AnyMatrix m, final int row)\n+        throws OutOfRangeException {\n         if (row < 0 ||\n             row >= m.getRowDimension()) {\n             throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n      * @param column Column index to check.\n      * @throws OutOfRangeException if {@code column} is not a valid index.\n      */\n-    public static void checkColumnIndex(final AnyMatrix m, final int column) {\n+    public static void checkColumnIndex(final AnyMatrix m, final int column)\n+        throws OutOfRangeException {\n         if (column < 0 || column >= m.getColumnDimension()) {\n             throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                            column, 0, m.getColumnDimension() - 1);\n      */\n     public static void checkSubMatrixIndex(final AnyMatrix m,\n                                            final int startRow, final int endRow,\n-                                           final int startColumn, final int endColumn) {\n+                                           final int startColumn, final int endColumn)\n+        throws NumberIsTooSmallException, OutOfRangeException {\n         checkRowIndex(m, startRow);\n         checkRowIndex(m, endRow);\n         if (endRow < startRow) {\n      */\n     public static void checkSubMatrixIndex(final AnyMatrix m,\n                                            final int[] selectedRows,\n-                                           final int[] selectedColumns) {\n+                                           final int[] selectedColumns)\n+        throws NoDataException, NullArgumentException, OutOfRangeException {\n         if (selectedRows == null) {\n             throw new NullArgumentException();\n         }\n      *\n      * @param left Left hand side matrix.\n      * @param right Right hand side matrix.\n-     * @throws MatrixDimensionMismatchException if the matrices are not addition compatible.\n-     */\n-    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right) {\n+     * @throws MatrixDimensionMismatchException if the matrices are not addition\n+     * compatible.\n+     */\n+    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws MatrixDimensionMismatchException {\n         if ((left.getRowDimension()    != right.getRowDimension()) ||\n             (left.getColumnDimension() != right.getColumnDimension())) {\n             throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n      *\n      * @param left Left hand side matrix.\n      * @param right Right hand side matrix.\n-     * @throws MatrixDimensionMismatchException if the matrices are not addition compatible.\n-     */\n-    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right) {\n+     * @throws MatrixDimensionMismatchException if the matrices are not addition\n+     * compatible.\n+     */\n+    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws MatrixDimensionMismatchException {\n         if ((left.getRowDimension()    != right.getRowDimension()) ||\n             (left.getColumnDimension() != right.getColumnDimension())) {\n             throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n      *\n      * @param left Left hand side matrix.\n      * @param right Right hand side matrix.\n-     * @throws DimensionMismatchException if matrices are not multiplication compatible.\n-     */\n-    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right) {\n+     * @throws DimensionMismatchException if matrices are not multiplication\n+     * compatible.\n+     */\n+    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws DimensionMismatchException {\n+\n         if (left.getColumnDimension() != right.getRowDimension()) {\n             throw new DimensionMismatchException(left.getColumnDimension(),\n                                                  right.getRowDimension());\n      * </p>\n      * @param rm RealMatrix which is lower triangular\n      * @param b  RealVector this is overwritten\n-     * @exception IllegalArgumentException if the matrix and vector are not conformable\n-     * @exception ArithmeticException there is a zero or near zero on the diagonal of rm\n-     */\n-    public static void solveLowerTriangularSystem( RealMatrix rm, RealVector b){\n+     * @throws DimensionMismatchException if the matrix and vector are not\n+     * conformable\n+     * @throws NonSquareMatrixException if the matrix {@code rm} is not square\n+     * @throws MathArithmeticException if the absolute value of one of the diagonal\n+     * coefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}\n+     */\n+    public static void solveLowerTriangularSystem(RealMatrix rm, RealVector b)\n+        throws DimensionMismatchException, MathArithmeticException,\n+        NonSquareMatrixException {\n         if ((rm == null) || (b == null) || ( rm.getRowDimension() != b.getDimension())) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n+            throw new DimensionMismatchException(\n                     (rm == null) ? 0 : rm.getRowDimension(),\n                     (b == null) ? 0 : b.getDimension());\n         }\n         if( rm.getColumnDimension() != rm.getRowDimension() ){\n-            throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    rm.getRowDimension(),rm.getRowDimension(),\n-                    rm.getRowDimension(),rm.getColumnDimension());\n+            throw new NonSquareMatrixException(rm.getRowDimension(),\n+                                               rm.getColumnDimension());\n         }\n         int rows = rm.getRowDimension();\n         for( int i = 0 ; i < rows ; i++ ){\n      * </p>\n      * @param rm RealMatrix which is upper triangular\n      * @param b  RealVector this is overwritten\n-     * @exception IllegalArgumentException if the matrix and vector are not conformable\n-     * @exception ArithmeticException there is a zero or near zero on the diagonal of rm\n-     */\n-    public static void solveUpperTriangularSystem( RealMatrix rm, RealVector b){\n+     * @throws DimensionMismatchException if the matrix and vector are not\n+     * conformable\n+     * @throws NonSquareMatrixException if the matrix {@code rm} is not\n+     * square\n+     * @throws MathArithmeticException if the absolute value of one of the diagonal\n+     * coefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}\n+     */\n+    public static void solveUpperTriangularSystem(RealMatrix rm, RealVector b)\n+        throws DimensionMismatchException, MathArithmeticException,\n+        NonSquareMatrixException {\n         if ((rm == null) || (b == null) || ( rm.getRowDimension() != b.getDimension())) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n+            throw new DimensionMismatchException(\n                     (rm == null) ? 0 : rm.getRowDimension(),\n                     (b == null) ? 0 : b.getDimension());\n         }\n         if( rm.getColumnDimension() != rm.getRowDimension() ){\n-            throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    rm.getRowDimension(),rm.getRowDimension(),\n-                    rm.getRowDimension(),rm.getColumnDimension());\n+            throw new NonSquareMatrixException(rm.getRowDimension(),\n+                                               rm.getColumnDimension());\n         }\n         int rows = rm.getRowDimension();\n         for( int i = rows-1 ; i >-1 ; i-- ){\n--- a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealVector unitVector() {\n+    public OpenMapRealVector unitVector() throws MathArithmeticException {\n         OpenMapRealVector res = copy();\n         res.unitize();\n         return res;\n \n     /** {@inheritDoc} */\n     @Override\n-    public void unitize() {\n+    public void unitize() throws MathArithmeticException {\n         double norm = getNorm();\n         if (isDefaultValue(norm)) {\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n      * @throws DimensionMismatchException if the dimensions of {@code this} and\n      * {@code v} do not match\n      */\n-    public double cosine(RealVector v) {\n+    public double cosine(RealVector v) throws MathArithmeticException {\n         final double norm = getNorm();\n         final double vNorm = v.getNorm();\n \n      * @param v vector onto which instance must be projected.\n      * @return projection of the instance onto {@code v}.\n      * @throws MathArithmeticException if {@code this} or {@code v} is the null\n-     * vector\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public RealVector projection(final RealVector v) {\n+     *         vector\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     *         this vector.\n+     */\n+    public RealVector projection(final RealVector v) throws MathArithmeticException {\n         final double norm2 = v.dotProduct(v);\n         if (norm2 == 0.0) {\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n      * The instance is not changed by this method.\n      *\n      * @return a unit vector pointing in direction of this vector.\n-     * @throws ArithmeticException if the norm is {@code null}.\n-     */\n-    public RealVector unitVector() {\n+     * @throws MathArithmeticException if the norm is zero.\n+     */\n+    public RealVector unitVector() throws MathArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n      * Converts this vector into a unit vector.\n      * The instance itself is changed by this method.\n      *\n-     * @throws org.apache.commons.math3.exception.MathArithmeticException\n-     * if the norm is zero.\n-     */\n-    public void unitize() {\n+     * @throws MathArithmeticException if the norm is zero.\n+     */\n+    public void unitize() throws MathArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n \n             /** {@inheritDoc} */\n             @Override\n-            public double cosine(RealVector w) {\n+            public double cosine(RealVector w) throws MathArithmeticException {\n                 return v.cosine(w);\n             }\n \n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector unitVector() {\n+            public RealVector unitVector() throws MathArithmeticException {\n                 return v.unitVector();\n             }\n ", "timestamp": 1346644463, "metainfo": ""}