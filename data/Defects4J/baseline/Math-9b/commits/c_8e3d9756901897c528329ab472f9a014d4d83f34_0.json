{"sha": "8e3d9756901897c528329ab472f9a014d4d83f34", "log": "fixed yet another eigen decomposition bug identified, debugged and fixed by Dimitri! Many thanks to him.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n         }\n \n         // initial checks for splits (see Parlett & Marques section 3.3)\n-        flipIfWarranted(n, 2);\n+        flipEveryOtherIfWarranted(n);\n \n         // two iterations with Li's test for initial splits\n         initialSplits(n);\n \n         // step 2: flip array if needed\n         if ((dMin <= 0) || (deflatedEnd < end)) {\n-            if (flipIfWarranted(deflatedEnd, 1)) {\n+            if (flipAllIfWarranted(deflatedEnd)) {\n                 dMin2 = Math.min(dMin2, work[l - 1]);\n                 work[l - 1] =\n                     Math.min(work[l - 1],\n     }\n \n     /**\n-     * Flip qd array if warranted.\n+     * Flip all elements of qd array if warranted.\n      * @param n number of rows in the block\n-     * @param step within the array (1 for flipping all elements, 2 for flipping\n-     * only every other element)\n      * @return true if qd array was flipped\n      */\n-    private boolean flipIfWarranted(final int n, final int step) {\n-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n-            // flip array\n-            int j = 4 * (n - 1);\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n-                j -= 4;\n-            }\n-            return true;\n-        }\n-        return false;\n+    private boolean flipAllIfWarranted(final int n) {\n+        if (1.5 * work[pingPong] >= work[4 * (n - 1) + pingPong]) {\n+            return false;\n+        }\n+\n+        int j = 4 * (n - 1);\n+        for (int i = 0; i < j; i += 4) {\n+            final double tmp1 = work[i];\n+            work[i] = work[j];\n+            work[j] = tmp1;\n+            final double tmp2 = work[i+1];\n+            work[i+1] = work[j+1];\n+            work[j+1] = tmp2;\n+            final double tmp3 = work[i+2];\n+            work[i+2] = work[j-2];\n+            work[j-2] = tmp3;\n+            final double tmp4 = work[i+3];\n+            work[i+3] = work[j-1];\n+            work[j-1] = tmp4;\n+            j -= 4;\n+        }\n+\n+        return true;\n+\n+    }\n+\n+    /**\n+     * Flip every other elements of qd array if warranted.\n+     * @param n number of rows in the block\n+     * @return true if qd array was flipped\n+     */\n+    private boolean flipEveryOtherIfWarranted(final int n) {\n+        if (1.5 * work[pingPong] >= work[4 * (n - 1) + pingPong]) {\n+            return false;\n+        }\n+\n+        // flip array\n+        int j = 4 * (n - 1);\n+        for (int i = 0; i < j; i += 4) {\n+            for (int k = 0; k < 4; k += 2) {\n+                final double tmp = work[i + k];\n+                work[i + k] = work[j - k];\n+                work[j - k] = tmp;\n+            }\n+            j -= 4;\n+        }\n+\n+        return true;\n+\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n             assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n+            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n+                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+            } else {\n+                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+            }\n+        }\n+\n+    }\n+\n+    public void testMathpbx03() {\n+\n+        double[] mainTridiagonal = {\n+            1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377,\n+            806.0482458637571,2403.656427234185,28.48691431556015\n+        };\n+        double[] secondaryTridiagonal = {\n+            -656.8932064545833,-469.30804108920734,-1021.7714889369421,\n+            -1152.540497328983,-939.9765163817368,-12.885877015422391\n+        };\n+\n+        // the reference values have been computed using routine DSTEMR\n+        // from the fortran library LAPACK version 3.2.1\n+        double[] refEigenValues = {\n+            4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764,\n+            1336.797819095331306,30.129865209677519,17.035352085224986\n+        };\n+\n+        RealVector[] refEigenVectors = {\n+            new ArrayRealVector(new double[] {-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}),\n+            new ArrayRealVector(new double[] {-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}),\n+            new ArrayRealVector(new double[] {-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}),\n+            new ArrayRealVector(new double[] {0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}),\n+            new ArrayRealVector(new double[] {0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}),\n+            new ArrayRealVector(new double[] {-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}),\n+            new ArrayRealVector(new double[] {0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266}),\n+        };\n+\n+        // the following line triggers the exception\n+        EigenDecomposition decomposition =\n+            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n+\n+        double[] eigenValues = decomposition.getRealEigenvalues();\n+        for (int i = 0; i < refEigenValues.length; ++i) {\n+            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);\n             if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n                 assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n             } else {", "timestamp": 1257623822, "metainfo": ""}