{"sha": "6a5ef0149e123d9de19910d59e45d0e66bfd665c", "log": "Unit tests for GammaDistribution, based on reference data generated with Maxima. Solves MATH-753.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math3/distribution/GammaDistributionTest.java\n \n package org.apache.commons.math3.distribution;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n         Assert.assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol);\n     }\n+\n+    public static double density(final double x, final double shape,\n+                                 final double scale) {\n+        /*\n+         * This is a copy of\n+         * double GammaDistribution.density(double)\n+         * prior to r1338548.\n+         */\n+        if (x < 0) {\n+            return 0;\n+        }\n+        return FastMath.pow(x / scale, shape - 1) / scale *\n+               FastMath.exp(-x / scale) / FastMath.exp(Gamma.logGamma(shape));\n+    }\n+\n+    /*\n+     * MATH-753: large values of x or shape parameter cause density(double) to\n+     * overflow. Reference data is generated with the Maxima script\n+     * gamma-distribution.mac, which can be found in\n+     * src/test/resources/org/apache/commons/math3/distribution.\n+     */\n+\n+    private void doTestMath753(final double shape,\n+        final double meanNoOF, final double sdNoOF,\n+        final double meanOF, final double sdOF,\n+        final String resourceName) throws IOException {\n+        final GammaDistribution distribution = new GammaDistribution(shape, 1.0);\n+        final SummaryStatistics statOld = new SummaryStatistics();\n+        final SummaryStatistics statNewNoOF = new SummaryStatistics();\n+        final SummaryStatistics statNewOF = new SummaryStatistics();\n+\n+        final InputStream resourceAsStream;\n+        resourceAsStream = this.getClass().getResourceAsStream(resourceName);\n+        Assert.assertNotNull(\"Could not find resource \" + resourceName,\n+                             resourceAsStream);\n+        final BufferedReader in;\n+        in = new BufferedReader(new InputStreamReader(resourceAsStream));\n+\n+        try {\n+            for (String line = in.readLine(); line != null; line = in\n+                .readLine()) {\n+                final String[] tokens = line.split(\", \");\n+                Assert.assertTrue(\"expected two floating-point values\",\n+                                  tokens.length == 2);\n+                final double x = Double.parseDouble(tokens[0]);\n+                final String msg = \"x = \" + x + \", shape = \" + shape +\n+                                   \", scale = 1.0\";\n+                final double expected = Double.parseDouble(tokens[1]);\n+                final double ulp = FastMath.ulp(expected);\n+                final double actualOld = density(x, shape, 1.0);\n+                final double actualNew = distribution.density(x);\n+                final double errOld, errNew;\n+                errOld = FastMath.abs((actualOld - expected) / ulp);\n+                errNew = FastMath.abs((actualNew - expected) / ulp);\n+\n+                if (Double.isNaN(actualOld) || Double.isInfinite(actualOld)) {\n+                    Assert.assertFalse(msg, Double.isNaN(actualNew));\n+                    Assert.assertFalse(msg, Double.isInfinite(actualNew));\n+                    statNewOF.addValue(errNew);\n+                } else {\n+                    statOld.addValue(errOld);\n+                    statNewNoOF.addValue(errNew);\n+                }\n+            }\n+            if (statOld.getN() != 0) {\n+                /*\n+                 * If no overflow occurs, check that new implementation is\n+                 * better than old one.\n+                 */\n+                final StringBuilder sb = new StringBuilder(\"shape = \");\n+                sb.append(shape);\n+                sb.append(\", scale = 1.0\\n\");\n+                sb.append(\"Old implementation\\n\");\n+                sb.append(\"------------------\\n\");\n+                sb.append(statOld.toString());\n+                sb.append(\"New implementation\\n\");\n+                sb.append(\"------------------\\n\");\n+                sb.append(statNewNoOF.toString());\n+                final String msg = sb.toString();\n+\n+                final double oldMin = statOld.getMin();\n+                final double newMin = statNewNoOF.getMin();\n+                Assert.assertTrue(msg, newMin <= oldMin);\n+\n+                final double oldMax = statOld.getMax();\n+                final double newMax = statNewNoOF.getMax();\n+                Assert.assertTrue(msg, newMax <= oldMax);\n+\n+                final double oldMean = statOld.getMean();\n+                final double newMean = statNewNoOF.getMean();\n+                Assert.assertTrue(msg, newMean <= oldMean);\n+\n+                final double oldSd = statOld.getStandardDeviation();\n+                final double newSd = statNewNoOF.getStandardDeviation();\n+                Assert.assertTrue(msg, newSd <= oldSd);\n+\n+                Assert.assertTrue(msg, newMean <= meanNoOF);\n+                Assert.assertTrue(msg, newSd <= sdNoOF);\n+            }\n+            if (statNewOF.getN() != 0) {\n+                final double newMean = statNewOF.getMean();\n+                final double newSd = statNewOF.getStandardDeviation();\n+\n+                final StringBuilder sb = new StringBuilder(\"shape = \");\n+                sb.append(shape);\n+                sb.append(\", scale = 1.0\");\n+                sb.append(\", max. mean error (ulps) = \");\n+                sb.append(meanOF);\n+                sb.append(\", actual mean error (ulps) = \");\n+                sb.append(newMean);\n+                sb.append(\", max. sd of error (ulps) = \");\n+                sb.append(sdOF);\n+                sb.append(\", actual sd of error (ulps) = \");\n+                sb.append(newSd);\n+                final String msg = sb.toString();\n+\n+                Assert.assertTrue(msg, newMean <= meanOF);\n+                Assert.assertTrue(msg, newSd <= sdOF);\n+            }\n+        } catch (IOException e) {\n+            Assert.fail(e.getMessage());\n+        } finally {\n+            in.close();\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMath753Shape1() throws IOException {\n+        doTestMath753(1.0, 1.5, 0.5, 0.0, 0.0, \"gamma-distribution-shape-1.csv\");\n+    }\n+\n+    @Test\n+    public void testMath753Shape10() throws IOException {\n+        doTestMath753(10.0, 1.0, 1.0, 0.0, 0.0, \"gamma-distribution-shape-10.csv\");\n+    }\n+\n+    @Test\n+    public void testMath753Shape100() throws IOException {\n+        doTestMath753(100.0, 1.5, 1.0, 0.0, 0.0, \"gamma-distribution-shape-100.csv\");\n+    }\n+\n+    @Test\n+    public void testMath753Shape142() throws IOException {\n+        doTestMath753(142.0, 0.5, 1.5, 40.0, 40.0, \"gamma-distribution-shape-142.csv\");\n+    }\n+\n+    @Test\n+    public void testMath753Shape1000() throws IOException {\n+        doTestMath753(1000.0, 1.0, 1.0, 160.0, 220.0, \"gamma-distribution-shape-1000.csv\");\n+    }\n }", "timestamp": 1337146600, "metainfo": ""}