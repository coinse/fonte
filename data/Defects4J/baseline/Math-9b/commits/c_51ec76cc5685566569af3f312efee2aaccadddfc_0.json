{"sha": "51ec76cc5685566569af3f312efee2aaccadddfc", "log": "MATH-195 Created an unchecked \"FunctionEvaluationException\" in package \"exception\". Removed \"throws\" clause from interface \"UnivariateRealFunction\". \"PolynomialFunctionLagrangeForm\": Added early check on the interpolating array having distinct points; removed redundant test in methods \"evaluate\" and \"computeCoefficients\". \"DividedDifferenceInerpolator\": Removed redundant check. \"Mathutils\": Added method \"sortInPlace\". Removed (most) references to the deprecated \"MathRuntimeException\" class. \"optimization.direct\": Removed deprecated classes. Javadoc clean up.    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n+++ b/src/main/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n  *\n  * @since 1.2\n  * @version $Revision$ $Date$\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link org.apache.commons.math.exception.OutOfRangeException} instead.\n  */\n public class ArgumentOutsideDomainException extends FunctionEvaluationException {\n \n--- a/src/main/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+++ b/src/main/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n  *\n  * @since 1.2\n  * @version $Revision$ $Date$\n+ * @deprecated in 2.2 (to be removed in 3.0).\n  */\n public class DuplicateSampleAbscissaException extends MathException  {\n \n--- a/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n  * caused the function evaluation to fail.\n  *\n  * @version $Revision$ $Date$\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link org.apache.commons.math.exception.FunctionEvaluationException} instead.\n  */\n public class FunctionEvaluationException extends MathException  {\n \n--- a/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n \n \n--- a/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a bivariate real function.\n--- a/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n \n \n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n package org.apache.commons.math.analysis;\n \n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a multivariate matrix function.\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a multivariate real function.\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a multivariate vectorial function.\n--- a/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a trivariate real function.\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a univariate matrix function.\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n-\n /**\n  * An interface representing a univariate real function.\n  *\n  * @version $Revision$ $Date$\n  */\n public interface UnivariateRealFunction {\n-\n     /**\n-     * Compute the value for the function.\n-     * @param x the point for which the function value should be computed\n-     * @return the value\n-     * @throws FunctionEvaluationException if the function evaluation fails\n+     * Compute the value of the function.\n+     *\n+     * @param x Point at which the function value should be computed.\n+     * @return the value.\n      */\n-    double value(double x) throws FunctionEvaluationException;\n-\n+    double value(double x);\n }\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a univariate vectorial function.\n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.ConvergingAlgorithm;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.DimensionMismatchException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n package org.apache.commons.math.analysis.interpolation;\n \n import java.io.Serializable;\n-\n-import org.apache.commons.math.DuplicateSampleAbscissaException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm;\n \n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,\n-    Serializable {\n-\n+public class DividedDifferenceInterpolator\n+    implements UnivariateRealInterpolator, Serializable {\n     /** serializable version identifier */\n     private static final long serialVersionUID = 107049519551235069L;\n \n     /**\n-     * Computes an interpolating function for the data set.\n+     * Compute an interpolating function for the dataset.\n      *\n-     * @param x the interpolating points array\n-     * @param y the interpolating values array\n-     * @return a function which interpolates the data set\n-     * @throws DuplicateSampleAbscissaException if arguments are invalid\n+     * @param x Interpolating points array.\n+     * @param y Interpolating values array.\n+     * @return a function which interpolates the dataset.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array lengths are different.\n+     * @throws org.apache.commons.math.exception.NumberIsTooSmallException\n+     * if the number of points is less than 2.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strictly increasing order.\n      */\n-    public PolynomialFunctionNewtonForm interpolate(double x[], double y[]) throws\n-        DuplicateSampleAbscissaException {\n-\n+    public PolynomialFunctionNewtonForm interpolate(double x[], double y[]) {\n         /**\n          * a[] and c[] are defined in the general formula of Newton form:\n          * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n          *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\n          */\n-        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y, true);\n \n         /**\n          * When used for interpolation, the Newton form formula becomes\n \n         final double[] a = computeDividedDifference(x, y);\n         return new PolynomialFunctionNewtonForm(a, c);\n-\n     }\n \n     /**\n-     * Returns a copy of the divided difference array.\n+     * Return a copy of the divided difference array.\n      * <p>\n      * The divided difference array is defined recursively by <pre>\n      * f[x0] = f(x0)\n      * <p>\n      * The computational complexity is O(N^2).</p>\n      *\n-     * @param x the interpolating points array\n-     * @param y the interpolating values array\n-     * @return a fresh copy of the divided difference array\n-     * @throws DuplicateSampleAbscissaException if any abscissas coincide\n+     * @param x Interpolating points array.\n+     * @param y Interpolating values array.\n+     * @return a fresh copy of the divided difference array.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array lengths are different.\n+     * @throws org.apache.commons.math.exception.NumberIsTooSmallException\n+     * if the number of points is less than 2.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strictly increasing order.\n      */\n-    protected static double[] computeDividedDifference(final double x[], final double y[])\n-        throws DuplicateSampleAbscissaException {\n-\n-        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+    protected static double[] computeDividedDifference(final double x[], final double y[]) {\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y, true);\n \n         final double[] divdiff = y.clone(); // initialization\n \n         for (int i = 1; i < n; i++) {\n             for (int j = 0; j < n-i; j++) {\n                 final double denominator = x[j+i] - x[j];\n-                if (denominator == 0.0) {\n-                    // This happens only when two abscissas are identical.\n-                    throw new DuplicateSampleAbscissaException(x[j], j, j+i);\n-                }\n                 divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;\n             }\n             a[i] = divdiff[0];\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n  */\n package org.apache.commons.math.analysis.polynomials;\n \n-import org.apache.commons.math.DuplicateSampleAbscissaException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the representation of a real polynomial function in\n  * @since 1.2\n  */\n public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction {\n-\n     /**\n      * The coefficients of the polynomial, ordered by degree -- i.e.\n      * coefficients[0] is the constant term and coefficients[n] is the\n      * coefficient of x^n where n is the degree of the polynomial.\n      */\n     private double coefficients[];\n-\n     /**\n      * Interpolating points (abscissas).\n      */\n     private final double x[];\n-\n     /**\n      * Function values at interpolating points.\n      */\n     private final double y[];\n-\n     /**\n      * Whether the polynomial coefficients are available.\n      */\n      * @param y function values at interpolating points\n      * @throws IllegalArgumentException if input arrays are not valid\n      */\n-    public PolynomialFunctionLagrangeForm(double x[], double y[])\n-        throws IllegalArgumentException {\n-\n-        verifyInterpolationArray(x, y);\n+    public PolynomialFunctionLagrangeForm(double x[], double y[]) {\n         this.x = new double[x.length];\n         this.y = new double[y.length];\n         System.arraycopy(x, 0, this.x, 0, x.length);\n         System.arraycopy(y, 0, this.y, 0, y.length);\n         coefficientsComputed = false;\n+\n+        if (!verifyInterpolationArray(x, y, false)) {\n+            MathUtils.sortInPlace(this.x, this.y);\n+            // Second check in case some abscissa is duplicated.\n+            verifyInterpolationArray(this.x, this.y, true);\n+        }\n     }\n \n     /**\n      * Calculate the function value at the given point.\n      *\n-     * @param z the point at which the function value is to be computed\n-     * @return the function value\n-     * @throws FunctionEvaluationException if a runtime error occurs\n-     * @see UnivariateRealFunction#value(double)\n-     */\n-    public double value(double z) throws FunctionEvaluationException {\n-        try {\n-            return evaluate(x, y, z);\n-        } catch (DuplicateSampleAbscissaException e) {\n-            throw new FunctionEvaluationException(e, z, e.getLocalizablePattern(), e.getArguments());\n-        }\n+     * @param z Point at which the function value is to be computed.\n+     * @return the function value.\n+     * @throws DimensionMismatchException if {@code x} and {@code y} have\n+     * different lengths.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strictly increasing order.\n+     * @throws NumberIsTooSmallException if the size of {@code x} is less\n+     * than 2.\n+     */\n+    public double value(double z) {\n+        return evaluateInternal(x, y, z);\n     }\n \n     /**\n     /**\n      * Evaluate the Lagrange polynomial using\n      * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n-     * Neville's Algorithm</a>. It takes O(N^2) time.\n-     * <p>\n-     * This function is made public static so that users can call it directly\n-     * without instantiating PolynomialFunctionLagrangeForm object.</p>\n-     *\n-     * @param x the interpolating points array\n-     * @param y the interpolating values array\n-     * @param z the point at which the function value is to be computed\n-     * @return the function value\n-     * @throws DuplicateSampleAbscissaException if the sample has duplicate abscissas\n-     * @throws IllegalArgumentException if inputs are not valid\n-     */\n-    public static double evaluate(double x[], double y[], double z) throws\n-        DuplicateSampleAbscissaException, IllegalArgumentException {\n-\n-        verifyInterpolationArray(x, y);\n-\n+     * Neville's Algorithm</a>. It takes O(n^2) time.\n+     *\n+     * @param x Interpolating points array.\n+     * @param y Interpolating values array.\n+     * @param z Point at which the function value is to be computed.\n+     * @return the function value.\n+     * @throws DimensionMismatchException if {@code x} and {@code y} have\n+     * different lengths.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strictly increasing order.\n+     * @throws NumberIsTooSmallException if the size of {@code x} is less\n+     * than 2.\n+     */\n+    public static double evaluate(double x[], double y[], double z) {\n+        if (verifyInterpolationArray(x, y, false)) {\n+            return evaluateInternal(x, y, z);\n+        }\n+\n+        // Array is not sorted.\n+        final double[] xNew = new double[x.length];\n+        final double[] yNew = new double[y.length];\n+        System.arraycopy(x, 0, xNew, 0, x.length);\n+        System.arraycopy(y, 0, yNew, 0, y.length);\n+\n+        MathUtils.sortInPlace(xNew, yNew);\n+        // Second check in case some abscissa is duplicated.\n+        verifyInterpolationArray(xNew, yNew, true);\n+        return evaluateInternal(xNew, yNew, z);\n+    }\n+\n+    /**\n+     * Evaluate the Lagrange polynomial using\n+     * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+     * Neville's Algorithm</a>. It takes O(n^2) time.\n+     *\n+     * @param x Interpolating points array.\n+     * @param y Interpolating values array.\n+     * @param z Point at which the function value is to be computed.\n+     * @return the function value.\n+     * @throws DimensionMismatchException if {@code x} and {@code y} have\n+     * different lengths.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strictly increasing order.\n+     * @throws NumberIsTooSmallException if the size of {@code x} is less\n+     * than 2.\n+     */\n+    private static double evaluateInternal(double x[], double y[], double z) {\n         int nearest = 0;\n         final int n = x.length;\n         final double[] c = new double[n];\n                 final double tc = x[j] - z;\n                 final double td = x[i+j] - z;\n                 final double divider = x[j] - x[i+j];\n-                if (divider == 0.0) {\n-                    // This happens only when two abscissas are identical.\n-                    throw new DuplicateSampleAbscissaException(x[i], i, i+j);\n-                }\n                 // update the difference arrays\n                 final double w = (c[j+1] - d[j]) / divider;\n                 c[j] = tc * w;\n \n     /**\n      * Calculate the coefficients of Lagrange polynomial from the\n-     * interpolation data. It takes O(N^2) time.\n-     * <p>\n-     * Note this computation can be ill-conditioned. Use with caution\n-     * and only when it is necessary.</p>\n-     *\n-     * @throws ArithmeticException if any abscissas coincide\n-     */\n-    protected void computeCoefficients() throws ArithmeticException {\n-\n+     * interpolation data. It takes O(n^2) time.\n+     * Note that this computation can be ill-conditioned: Use with caution\n+     * and only when it is necessary.\n+     */\n+    protected void computeCoefficients() {\n         final int n = degree() + 1;\n         coefficients = new double[n];\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 if (i != j) {\n                     d *= x[i] - x[j];\n-                }\n-            }\n-            if (d == 0.0) {\n-                // This happens only when two abscissas are identical.\n-                for (int k = 0; k < n; ++k) {\n-                    if ((i != k) && (x[i] == x[k])) {\n-                        throw MathRuntimeException.createArithmeticException(\n-                              LocalizedFormats.IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO,\n-                              i, k, x[i]);\n-                    }\n                 }\n             }\n             final double t = y[i] / d;\n     }\n \n     /**\n-     * Verifies that the interpolation arrays are valid.\n-     * <p>\n+     * Check that the interpolation arrays are valid.\n      * The arrays features checked by this method are that both arrays have the\n      * same length and this length is at least 2.\n-     * </p>\n-     * <p>\n-     * The interpolating points must be distinct. However it is not\n-     * verified here, it is checked in evaluate() and computeCoefficients().\n-     * </p>\n-     *\n-     * @param x the interpolating points array\n-     * @param y the interpolating values array\n-     * @throws IllegalArgumentException if not valid\n+     *\n+     * @param x Interpolating points array.\n+     * @param y Interpolating values array.\n+     * @param abort Whether to throw an exception if {@code x} is not sorted.\n+     * @throws DimensionMismatchException if the array lengths are different.\n+     * @throws NumberIsTooSmallException if the number of points is less than 2.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException\n+     * if {@code x} is not sorted in strictly increasing order and {@code abort}\n+     * is {@code true}.\n+     * @return {@code false} if the {@code x} is not sorted in increasing order,\n+     * {@code true} otherwise.\n      * @see #evaluate(double[], double[], double)\n      * @see #computeCoefficients()\n      */\n-    public static void verifyInterpolationArray(double x[], double y[])\n-        throws IllegalArgumentException {\n-\n+    public static boolean verifyInterpolationArray(double x[], double y[], boolean abort) {\n         if (x.length != y.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, y.length);\n-        }\n-\n+            throw new DimensionMismatchException(x.length, y.length);\n+        }\n         if (x.length < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length);\n-        }\n-\n+            throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length, true);\n+        }\n+\n+        return MathUtils.checkOrder(x, MathUtils.OrderDirection.INCREASING, true, abort);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n  */\n package org.apache.commons.math.analysis.polynomials;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.ArgumentOutsideDomainException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  *\n  * @version $Revision$ $Date$\n  */\n-public class PolynomialSplineFunction\n-    implements DifferentiableUnivariateRealFunction {\n-\n-    /** Spline segment interval delimiters (knots).   Size is n+1 for n segments. */\n+public class PolynomialSplineFunction implements DifferentiableUnivariateRealFunction {\n+    /**\n+     * Spline segment interval delimiters (knots).\n+     * Size is n + 1 for n segments.\n+     */\n     private final double knots[];\n-\n     /**\n      * The polynomial functions that make up the spline.  The first element\n      * determines the value of the spline over the first subinterval, the\n      * second over the second, etc.   Spline function values are determined by\n-     * evaluating these functions at <code>(x - knot[i])</code> where i is the\n+     * evaluating these functions at {@code (x - knot[i])} where i is the\n      * knot segment to which x belongs.\n      */\n     private final PolynomialFunction polynomials[];\n-\n-    /**\n-     * Number of spline segments = number of polynomials\n-     *  = number of partition points - 1\n+    /**\n+     * Number of spline segments. It is equal to the number of polynomials and\n+     * to the number of partition points - 1.\n      */\n     private final int n;\n \n     /**\n      * Construct a polynomial spline function with the given segment delimiters\n      * and interpolating polynomials.\n-     * <p>\n      * The constructor copies both arrays and assigns the copies to the knots\n-     * and polynomials properties, respectively.</p>\n-     *\n-     * @param knots spline segment interval delimiters\n-     * @param polynomials polynomial functions that make up the spline\n-     * @throws NullPointerException if either of the input arrays is null\n-     * @throws IllegalArgumentException if knots has length less than 2,\n-     * <code>polynomials.length != knots.length - 1 </code>, or the knots array\n-     * is not strictly increasing.\n+     * and polynomials properties, respectively.\n+     *\n+     * @param knots Spline segment interval delimiters.\n+     * @param polynomials Polynomial functions that make up the spline.\n+     * @throws NullArgumentException if either of the input arrays is {@code null}.\n+     * @throws NumberIsTooSmallException if knots has length less than 2.\n+     * @throws DimensionMismatchException if {@code polynomials.length != knots.length - 1}.\n+     * @throws org.apache.commons.math.exception.NonMonotonousSequenceException if\n+     * the {@code knots} array is not strictly increasing.\n      *\n      */\n     public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n+        if (knots == null ||\n+            polynomials == null) {\n+            throw new NullArgumentException();\n+        }\n         if (knots.length < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION,\n-                  2, knots.length);\n+            throw new NumberIsTooSmallException(LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION,\n+                                                2, knots.length, false);\n         }\n         if (knots.length - 1 != polynomials.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS,\n-                  polynomials.length, knots.length);\n-        }\n-        if (!isStrictlyIncreasing(knots)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_STRICTLY_INCREASING_KNOT_VALUES);\n-        }\n+            throw new DimensionMismatchException(polynomials.length, knots.length);\n+        }\n+        MathUtils.checkOrder(knots);\n \n         this.n = knots.length -1;\n         this.knots = new double[n + 1];\n \n     /**\n      * Compute the value for the function.\n-     * <p>\n-     * Throws FunctionEvaluationException if v is outside of the domain of the\n-     * function.  The domain is [smallest knot, largest knot].</p>\n-     * <p>\n      * See {@link PolynomialSplineFunction} for details on the algorithm for\n-     * computing the value of the function.</p>\n-     *\n-     * @param v the point for which the function value should be computed\n-     * @return the value\n-     * @throws ArgumentOutsideDomainException if v is outside of the domain of\n-     * of the spline function (less than the smallest knot point or greater\n-     * than the largest knot point)\n-     */\n-    public double value(double v) throws ArgumentOutsideDomainException {\n+     * computing the value of the function.\n+     *\n+     * @param v Point for which the function value should be computed.\n+     * @return the value.\n+     * @throws OutOfRangeException if {@code v} is outside of the domain of the\n+     * spline function (smaller than the smallest knot point or larger than the\n+     * largest knot point).\n+     */\n+    public double value(double v) {\n         if (v < knots[0] || v > knots[n]) {\n-            throw new ArgumentOutsideDomainException(v, knots[0], knots[n]);\n+            throw new OutOfRangeException(v, knots[0], knots[n]);\n         }\n         int i = Arrays.binarySearch(knots, v);\n         if (i < 0) {\n             i = -i - 2;\n         }\n-        //This will handle the case where v is the last knot value\n-        //There are only n-1 polynomials, so if v is the last knot\n-        //then we will use the last polynomial to calculate the value.\n+        // This will handle the case where v is the last knot value\n+        // There are only n-1 polynomials, so if v is the last knot\n+        // then we will use the last polynomial to calculate the value.\n         if ( i >= polynomials.length ) {\n             i--;\n         }\n     }\n \n     /**\n-     * Returns the derivative of the polynomial spline function as a UnivariateRealFunction\n-     * @return  the derivative function\n+     * Get the derivative of the polynomial spline function.\n+     *\n+     * @return the derivative function.\n      */\n     public UnivariateRealFunction derivative() {\n         return polynomialSplineDerivative();\n     }\n \n     /**\n-     * Returns the derivative of the polynomial spline function as a PolynomialSplineFunction\n-     *\n-     * @return  the derivative function\n+     * Get the derivative of the polynomial spline function.\n+     *\n+     * @return the derivative function.\n      */\n     public PolynomialSplineFunction polynomialSplineDerivative() {\n         PolynomialFunction derivativePolynomials[] = new PolynomialFunction[n];\n     }\n \n     /**\n-     * Returns the number of spline segments = the number of polynomials\n-     * = the number of knot points - 1.\n-     *\n-     * @return the number of spline segments\n+     * Get the number of spline segments.\n+     * It is also the number of polynomials and the number of knot points - 1.\n+     *\n+     * @return the number of spline segments.\n      */\n     public int getN() {\n         return n;\n     }\n \n     /**\n-     * Returns a copy of the interpolating polynomials array.\n-     * <p>\n-     * Returns a fresh copy of the array. Changes made to the copy will\n-     * not affect the polynomials property.</p>\n-     *\n-     * @return the interpolating polynomials\n+     * Get a copy of the interpolating polynomials array.\n+     * It returns a fresh copy of the array. Changes made to the copy will\n+     * not affect the polynomials property.\n+     *\n+     * @return the interpolating polynomials.\n      */\n     public PolynomialFunction[] getPolynomials() {\n         PolynomialFunction p[] = new PolynomialFunction[n];\n     }\n \n     /**\n-     * Returns an array copy of the knot points.\n-     * <p>\n-     * Returns a fresh copy of the array. Changes made to the copy\n-     * will not affect the knots property.</p>\n-     *\n-     * @return the knot points\n+     * Get an array copy of the knot points.\n+     * It returns a fresh copy of the array. Changes made to the copy\n+     * will not affect the knots property.\n+     *\n+     * @return the knot points.\n      */\n     public double[] getKnots() {\n         double out[] = new double[n + 1];\n         System.arraycopy(knots, 0, out, 0, n + 1);\n         return out;\n     }\n-\n-    /**\n-     * Determines if the given array is ordered in a strictly increasing\n-     * fashion.\n-     *\n-     * @param x the array to examine.\n-     * @return <code>true</code> if the elements in <code>x</code> are ordered\n-     * in a stricly increasing manner.  <code>false</code>, otherwise.\n-     */\n-    private static boolean isStrictlyIncreasing(double[] x) {\n-        for (int i = 1; i < x.length; ++i) {\n-            if (x[i - 1] >= x[i]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.ConvergingAlgorithm;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n \n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergingAlgorithmImpl;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import java.io.Serializable;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/FunctionEvaluationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.math.exception.util.ArgUtils;\n+import org.apache.commons.math.exception.util.MessageFactory;\n+import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception for signalling that a function object could not return\n+ * a valid result.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class FunctionEvaluationException extends RuntimeException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -6024911025449780478L;\n+    /**\n+     * Pattern used to build the message.\n+     */\n+    private final Localizable specific;\n+    /**\n+     * Arguments used to build the message.\n+     */\n+    private final Object[] arguments;\n+\n+    /**\n+     * @param specific Message pattern providing the specific context of\n+     * the error.\n+     * @param args Arguments.\n+     */\n+    public FunctionEvaluationException(Localizable specific,\n+                                       Object ... args) {\n+        this.specific = specific;\n+        arguments = ArgUtils.flatten(args);\n+    }\n+    /**\n+     * @param args Arguments.\n+     */\n+    public FunctionEvaluationException(Object ... args) {\n+        this(null, args);\n+    }\n+\n+    /**\n+     * Get the arguments.\n+     *\n+     * @return a (shallow) copy of the arguments.\n+     */\n+    public Object[] getArguments() {\n+        return arguments.clone();\n+    }\n+\n+    /**\n+     * Get the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated.\n+     *\n+     * @return the localized message.\n+     */\n+    public String getMessage(final Locale locale) {\n+        return MessageFactory.buildMessage(locale,\n+                                           specific,\n+                                           LocalizedFormats.EVALUATION,\n+                                           arguments);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String getMessage() {\n+        return getMessage(Locale.US);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     AT_LEAST_ONE_COLUMN(\"matrix must have at least one column\"),\n     AT_LEAST_ONE_ROW(\"matrix must have at least one row\"),\n     BANDWIDTH_OUT_OF_INTERVAL(\"bandwidth must be in the interval [0,1], but got {0}\"),\n-    BINOMIAL_INVALID_PARAMETERS_ORDER(\"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\"),\n-    BINOMIAL_NEGATIVE_PARAMETER(\"must have n >= 0 for binomial coefficient (n,k), got n = {0}\"),\n+    BINOMIAL_INVALID_PARAMETERS_ORDER(\"must have n >= k for binomial coefficient (n, k), got k = {0}, n = {1}\"),\n+    BINOMIAL_NEGATIVE_PARAMETER(\"must have n >= 0 for binomial coefficient (n, k), got n = {0}\"),\n     CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS(\"statistics constructed from external moments cannot be cleared\"),\n     CANNOT_COMPUTE_0TH_ROOT_OF_UNITY(\"cannot compute 0-th root of unity, indefinite result\"),\n     CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA(\"cannot compute beta density at 0 when alpha = {0,number}\"),\n     EQUAL_VERTICES_IN_SIMPLEX(\"equal vertices {0} and {1} in simplex configuration\"),\n     EULER_ANGLES_SINGULARITY(\"Euler angles singularity\"),\n     EVALUATION_FAILED(\"evaluation failed for argument = {0}\"),\n+    EVALUATION(\"evaluation\"), /* keep */\n     EXPANSION_FACTOR_SMALLER_THAN_ONE(\"expansion factor smaller than one ({0})\"),\n     FACTORIAL_NEGATIVE_PARAMETER(\"must have n >= 0 for n!, got n = {0}\"),\n     FAILED_BRACKETING(\"number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\"),\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathUnsupportedOperationException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n \n import java.util.Iterator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n \n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n package org.apache.commons.math.ode.events;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n /**\n      * @param startPoint Start point for optimization.\n      * @return the point/value pair giving the optimal value for objective\n      * function.\n-     * @throws org.apache.commons.math.FunctionEvaluationException if the\n+     * @throws org.apache.commons.math.exception.FunctionEvaluationException if the\n      * objective function throws one during the search.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n \n /**\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n \n /**\n  * This class implements simplex-based direct search optimization.\n  * @since 3.0\n  */\n public class SimplexOptimizer\n-    extends BaseAbstractScalarOptimizer<MultivariateRealFunction> {\n+    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    implements MultivariateRealOptimizer {\n     /** Simplex. */\n     private AbstractSimplex simplex;\n \n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianDerivativeFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianDerivativeFunction.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFunction.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunction.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.ZeroException;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * An interface representing a real function that depends on one independent\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.DecompositionSolver;\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n--- a/src/main/java/org/apache/commons/math/optimization/general/Preconditioner.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/Preconditioner.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * This interface represents a preconditioner for differentiable scalar\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.BaseOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n  */\n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import java.io.Serializable;\n import java.lang.reflect.Array;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n--- a/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Arrays;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.AbstractMap;\n+import java.util.Collections;\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NonMonotonousSequenceException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n \n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n      * @param x an addend\n      * @param y an addend\n      * @return the sum <code>x+y</code>\n-     * @throws ArithmeticException if the result can not be represented as an\n-     *         int\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as an {@code int}.\n      * @since 1.1\n      */\n     public static int addAndCheck(int x, int y) {\n         long s = (long)x + (long)y;\n         if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n         }\n         return (int)s;\n     }\n     /**\n      * Add two long integers, checking for overflow.\n      *\n-     * @param a an addend\n-     * @param b an addend\n-     * @param pattern the pattern to use for any thrown exception.\n-     * @return the sum <code>a+b</code>\n-     * @throws ArithmeticException if the result can not be represented as an\n-     *         long\n+     * @param a Addend.\n+     * @param b Addend.\n+     * @param pattern Pattern to use for any thrown exception.\n+     * @return the sum {@code a + b}.\n+     * @throws MathArithmeticException if the result cannot be represented\n+     * as a {@code long}.\n      * @since 1.2\n      */\n     private static long addAndCheck(long a, long b, Localizable pattern) {\n                     if (Long.MIN_VALUE - b <= a) {\n                         ret = a + b;\n                     } else {\n-                        throw MathRuntimeException.createArithmeticException(pattern, a, b);\n+                        throw new MathArithmeticException(pattern, a, b);\n                     }\n                 } else {\n                     // opposite sign addition is always safe\n                 if (a <= Long.MAX_VALUE - b) {\n                     ret = a + b;\n                 } else {\n-                    throw MathRuntimeException.createArithmeticException(pattern, a, b);\n+                    throw new MathArithmeticException(pattern, a, b);\n                 }\n             }\n         }\n \n     /**\n      * Check binomial preconditions.\n-     * @param n the size of the set\n-     * @param k the size of the subsets to be counted\n-     * @exception IllegalArgumentException if preconditions are not met.\n-     */\n-    private static void checkBinomial(final int n, final int k)\n-        throws IllegalArgumentException {\n+     *\n+     * @param n Size of the set.\n+     * @param k Size of the subsets to be counted.\n+     * @throws NotPositiveException if {@code n < 0}.\n+     * @throws NumberIsTooLargeException if {@code k > n}.\n+     */\n+    private static void checkBinomial(final int n, final int k) {\n         if (n < k) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n-                n, k);\n+            throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n+                                                k, n, true);\n         }\n         if (n < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER,\n-                  n);\n+            throw new NotPositiveException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n);\n         }\n     }\n \n      *\n      * @param n argument\n      * @return <code>n!</code>\n-     * @throws ArithmeticException if the result is too large to be represented\n-     *         by a long integer.\n-     * @throws IllegalArgumentException if n < 0\n+     * @throws MathArithmeticException if the result is too large to be represented\n+     * by a {@code long}.\n+     * @throws NotPositiveException if {@code n < 0}.\n+     * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n+     * large to fit in a {@code long}.\n      */\n     public static long factorial(final int n) {\n         if (n < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                  n);\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n         }\n         if (n > 20) {\n-            throw new ArithmeticException(\n-                    \"factorial value is too large to fit in a long\");\n+            throw new MathArithmeticException();\n         }\n         return FACTORIALS[n];\n     }\n \n     /**\n-     * Returns n!. Shorthand for <code>n</code> <a\n-     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n-     * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n-     * <p>\n-     * <Strong>Preconditions</strong>:\n-     * <ul>\n-     * <li> <code>n >= 0</code> (otherwise\n-     * <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>double</code>. The\n-     * largest value of <code>n</code> for which <code>n!</code> <\n-     * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n-     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n-     * </ul>\n-     * </p>\n-     *\n-     * @param n argument\n-     * @return <code>n!</code>\n-     * @throws IllegalArgumentException if n < 0\n+     * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n+     * {@code double}.\n+     * The result should be small enough to fit into a {@code double}: The\n+     * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n+     * If the computed value exceeds {@code Double.MAX_VALUE},\n+     * {@code Double.POSITIVE_INFINITY} is returned.\n+     *\n+     * @param n Argument.\n+     * @return {@code n!}\n+     * @throws NotPositiveException if {@code n < 0}.\n      */\n     public static double factorialDouble(final int n) {\n         if (n < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                  n);\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n         }\n         if (n < 21) {\n             return factorial(n);\n     }\n \n     /**\n-     * Returns the natural logarithm of n!.\n-     * <p>\n-     * <Strong>Preconditions</strong>:\n-     * <ul>\n-     * <li> <code>n >= 0</code> (otherwise\n-     * <code>IllegalArgumentException</code> is thrown)</li>\n-     * </ul></p>\n-     *\n-     * @param n argument\n-     * @return <code>n!</code>\n-     * @throws IllegalArgumentException if preconditions are not met.\n+     * Compute the natural logarithm of the factorial of {@code n}.\n+     *\n+     * @param n Argument.\n+     * @return {@code n!}\n+     * @throws NotPositiveException if {@code n < 0}.\n      */\n     public static double factorialLog(final int n) {\n         if (n < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                  n);\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n         }\n         if (n < 21) {\n             return FastMath.log(factorial(n));\n      * <code>0</code>.</li>\n      * </ul>\n      *\n-     * @param p any number\n-     * @param q any number\n-     * @return the greatest common divisor, never negative\n-     * @throws ArithmeticException if the result cannot be represented as a\n-     * nonnegative int value\n+     * @param p Number.\n+     * @param q Number.\n+     * @return the greatest common divisor, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code int} value.\n      * @since 1.1\n      */\n     public static int gcd(final int p, final int q) {\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n             if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n-                throw MathRuntimeException.createArithmeticException(\n-                        LocalizedFormats.GCD_OVERFLOW_32_BITS,\n-                        p, q);\n+                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                                  p, q);\n             }\n             return FastMath.abs(u) + FastMath.abs(v);\n         }\n             k++; // cast out twos.\n         }\n         if (k == 31) {\n-            throw MathRuntimeException.createArithmeticException(\n-                    LocalizedFormats.GCD_OVERFLOW_32_BITS,\n-                    p, q);\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                              p, q);\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         // one is odd.\n      * <code>0L</code>.</li>\n      * </ul>\n      *\n-     * @param p any number\n-     * @param q any number\n-     * @return the greatest common divisor, never negative\n-     * @throws ArithmeticException if the result cannot be represented as a nonnegative long\n-     * value\n+     * @param p Number.\n+     * @param q Number.\n+     * @return the greatest common divisor, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code long} value.\n      * @since 2.1\n      */\n     public static long gcd(final long p, final long q) {\n         long v = q;\n         if ((u == 0) || (v == 0)) {\n             if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n-                throw MathRuntimeException.createArithmeticException(\n-                        LocalizedFormats.GCD_OVERFLOW_64_BITS,\n-                        p, q);\n+                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n+                                                  p, q);\n             }\n             return FastMath.abs(u) + FastMath.abs(v);\n         }\n             k++; // cast out twos.\n         }\n         if (k == 63) {\n-            throw MathRuntimeException.createArithmeticException(\n-                    LocalizedFormats.GCD_OVERFLOW_64_BITS,\n-                    p, q);\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n+                                              p, q);\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         // one is odd.\n      * <code>0</code> for any <code>x</code>.\n      * </ul>\n      *\n-     * @param a any number\n-     * @param b any number\n-     * @return the least common multiple, never negative\n-     * @throws ArithmeticException\n-     *             if the result cannot be represented as a nonnegative int\n-     *             value\n+     * @param a Number.\n+     * @param b Number.\n+     * @return the least common multiple, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code int} value.\n      * @since 1.1\n      */\n     public static int lcm(int a, int b) {\n-        if (a==0 || b==0){\n+        if (a == 0 || b == 0){\n             return 0;\n         }\n         int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n         if (lcm == Integer.MIN_VALUE) {\n-            throw MathRuntimeException.createArithmeticException(\n-                LocalizedFormats.LCM_OVERFLOW_32_BITS,\n-                a, b);\n+            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS,\n+                                              a, b);\n         }\n         return lcm;\n     }\n      * <code>0L</code> for any <code>x</code>.\n      * </ul>\n      *\n-     * @param a any number\n-     * @param b any number\n-     * @return the least common multiple, never negative\n-     * @throws ArithmeticException if the result cannot be represented as a nonnegative long\n-     * value\n+     * @param a Number.\n+     * @param b Number.\n+     * @return the least common multiple, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented\n+     * as a non-negative {@code long} value.\n      * @since 2.1\n      */\n     public static long lcm(long a, long b) {\n-        if (a==0 || b==0){\n+        if (a == 0 || b == 0){\n             return 0;\n         }\n         long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n         if (lcm == Long.MIN_VALUE){\n-            throw MathRuntimeException.createArithmeticException(\n-                LocalizedFormats.LCM_OVERFLOW_64_BITS,\n-                a, b);\n+            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS,\n+                                              a, b);\n         }\n         return lcm;\n     }\n     /**\n      * Multiply two integers, checking for overflow.\n      *\n-     * @param x a factor\n-     * @param y a factor\n-     * @return the product <code>x*y</code>\n-     * @throws ArithmeticException if the result can not be represented as an\n-     *         int\n+     * @param x Factor.\n+     * @param y Factor.\n+     * @return the product {@code x * y}.\n+     * @throws MathArithmeticException if the result can not be\n+     * represented as an {@code int}.\n      * @since 1.1\n      */\n     public static int mulAndCheck(int x, int y) {\n         long m = ((long)x) * ((long)y);\n         if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n-            throw new ArithmeticException(\"overflow: mul\");\n+            throw new MathArithmeticException();\n         }\n         return (int)m;\n     }\n     /**\n      * Multiply two long integers, checking for overflow.\n      *\n-     * @param a first value\n-     * @param b second value\n-     * @return the product <code>a * b</code>\n-     * @throws ArithmeticException if the result can not be represented as an\n-     *         long\n+     * @param a Factor.\n+     * @param b Factor.\n+     * @return the product {@code a * b}.\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as a {@code long}.\n      * @since 1.2\n      */\n     public static long mulAndCheck(long a, long b) {\n         long ret;\n-        String msg = \"overflow: multiply\";\n         if (a > b) {\n             // use symmetry to reduce boundary cases\n             ret = mulAndCheck(b, a);\n                     if (a >= Long.MAX_VALUE / b) {\n                         ret = a * b;\n                     } else {\n-                        throw new ArithmeticException(msg);\n+                        throw new MathArithmeticException();\n                     }\n                 } else if (b > 0) {\n                     // check for negative overflow with negative a, positive b\n                     if (Long.MIN_VALUE / b <= a) {\n                         ret = a * b;\n                     } else {\n-                        throw new ArithmeticException(msg);\n+                        throw new MathArithmeticException();\n \n                     }\n                 } else {\n                 if (a <= Long.MAX_VALUE / b) {\n                     ret = a * b;\n                 } else {\n-                    throw new ArithmeticException(msg);\n+                    throw new MathArithmeticException();\n                 }\n             } else {\n                 // assert a == 0\n       * @throws IllegalArgumentException if the target sum is infinite or NaN\n       * @since 2.1\n       */\n-     public static double[] normalizeArray(double[] values, double normalizedSum)\n-       throws ArithmeticException, IllegalArgumentException {\n+     public static double[] normalizeArray(double[] values, double normalizedSum) {\n          if (Double.isInfinite(normalizedSum)) {\n              throw MathRuntimeException.createIllegalArgumentException(\n                      LocalizedFormats.NORMALIZE_INFINITE);\n      * determined by the rounding method specified. Rounding methods are defined\n      * in {@link BigDecimal}.\n      *\n-     * @param unscaled the value to round.\n-     * @param sign the sign of the original, scaled value.\n-     * @param roundingMethod the rounding method as defined in\n-     *        {@link BigDecimal}.\n+     * @param unscaled Value to round.\n+     * @param sign Sign of the original, scaled value.\n+     * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\n      * @return the rounded value.\n      * @since 1.1\n      */\n-    private static double roundUnscaled(double unscaled, double sign,\n-        int roundingMethod) {\n+    private static double roundUnscaled(double unscaled,\n+                                        double sign,\n+                                        int roundingMethod) {\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n         }\n         case BigDecimal.ROUND_UNNECESSARY :\n             if (unscaled != FastMath.floor(unscaled)) {\n-                throw new ArithmeticException(\"Inexact result from rounding\");\n+                throw new MathArithmeticException();\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n             unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INVALID_ROUNDING_METHOD,\n-                  roundingMethod,\n-                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n-                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n-                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n-                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n-                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n-                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n-                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n-                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,\n+                                                   roundingMethod,\n+                                                   \"ROUND_CEILING\", BigDecimal.ROUND_CEILING,\n+                                                   \"ROUND_DOWN\", BigDecimal.ROUND_DOWN,\n+                                                   \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR,\n+                                                   \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN,\n+                                                   \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN,\n+                                                   \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP,\n+                                                   \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n+                                                   \"ROUND_UP\", BigDecimal.ROUND_UP);\n         }\n         return unscaled;\n     }\n     }\n \n     /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n-     * for short value <code>x</code>.\n-     * <p>\n-     * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n-     * if x = 0, and (short)(-1) if x < 0.</p>\n+     * Compute the <a href=\"http://mathworld.wolfram.com/Sign.html\">sign</a>\n+     * of the argument.\n      *\n      * @param x the value, a short\n-     * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of\n-     *         x\n+     * @return 1 if {@code x > 0}, 0 if {@code x == 0}, and -1 if {@code x < 0}.\n      */\n     public static short sign(final short x) {\n         return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n     }\n \n     /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n-     * hyperbolic sine</a> of x.\n-     *\n-     * @param x double value for which to find the hyperbolic sine\n-     * @return hyperbolic sine of x\n+     * Compute the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n+     * hyperbolic sine</a> of the argument.\n+     *\n+     * @param x Value for which to find the hyperbolic sine.\n+     * @return hyperbolic sine of {@code x}.\n      */\n     public static double sinh(double x) {\n         return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;\n     /**\n      * Subtract two integers, checking for overflow.\n      *\n-     * @param x the minuend\n-     * @param y the subtrahend\n-     * @return the difference <code>x-y</code>\n-     * @throws ArithmeticException if the result can not be represented as an\n-     *         int\n+     * @param x Minuend.\n+     * @param y Subtrahend.\n+     * @return the difference {@code x - y}.\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as an {@code int}.\n      * @since 1.1\n      */\n     public static int subAndCheck(int x, int y) {\n         long s = (long)x - (long)y;\n         if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n         }\n         return (int)s;\n     }\n     /**\n      * Subtract two long integers, checking for overflow.\n      *\n-     * @param a first value\n-     * @param b second value\n-     * @return the difference <code>a-b</code>\n-     * @throws ArithmeticException if the result can not be represented as an\n-     *         long\n+     * @param a Value.\n+     * @param b Value.\n+     * @return the difference {@code a - b}.\n+     * @throws MathArithmeticException if the result can not be represented as a\n+     * {@code long}.\n      * @since 1.2\n      */\n     public static long subAndCheck(long a, long b) {\n \n     /**\n      * Raise an int to an int power.\n-     * @param k number to raise\n-     * @param e exponent (must be positive or null)\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n      * @return k<sup>e</sup>\n-     * @exception IllegalArgumentException if e is negative\n-     */\n-    public static int pow(final int k, int e)\n-        throws IllegalArgumentException {\n-\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static int pow(final int k, int e) {\n         if (e < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n-                k, e);\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n \n         int result = 1;\n         }\n \n         return result;\n-\n     }\n \n     /**\n      * Raise an int to a long power.\n-     * @param k number to raise\n-     * @param e exponent (must be positive or null)\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n      * @return k<sup>e</sup>\n-     * @exception IllegalArgumentException if e is negative\n-     */\n-    public static int pow(final int k, long e)\n-        throws IllegalArgumentException {\n-\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static int pow(final int k, long e) {\n         if (e < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n-                k, e);\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n \n         int result = 1;\n         }\n \n         return result;\n-\n     }\n \n     /**\n      * Raise a long to an int power.\n-     * @param k number to raise\n-     * @param e exponent (must be positive or null)\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n      * @return k<sup>e</sup>\n-     * @exception IllegalArgumentException if e is negative\n-     */\n-    public static long pow(final long k, int e)\n-        throws IllegalArgumentException {\n-\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static long pow(final long k, int e) {\n         if (e < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n-                k, e);\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n \n         long result = 1l;\n         }\n \n         return result;\n-\n     }\n \n     /**\n      * Raise a long to a long power.\n-     * @param k number to raise\n-     * @param e exponent (must be positive or null)\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n      * @return k<sup>e</sup>\n-     * @exception IllegalArgumentException if e is negative\n-     */\n-    public static long pow(final long k, long e)\n-        throws IllegalArgumentException {\n-\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static long pow(final long k, long e) {\n         if (e < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n-                k, e);\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n \n         long result = 1l;\n         }\n \n         return result;\n-\n     }\n \n     /**\n      * Raise a BigInteger to an int power.\n-     * @param k number to raise\n-     * @param e exponent (must be positive or null)\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n      * @return k<sup>e</sup>\n-     * @exception IllegalArgumentException if e is negative\n-     */\n-    public static BigInteger pow(final BigInteger k, int e)\n-        throws IllegalArgumentException {\n-\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static BigInteger pow(final BigInteger k, int e) {\n         if (e < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n-                k, e);\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n \n         return k.pow(e);\n-\n     }\n \n     /**\n      * Raise a BigInteger to a long power.\n-     * @param k number to raise\n-     * @param e exponent (must be positive or null)\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n      * @return k<sup>e</sup>\n-     * @exception IllegalArgumentException if e is negative\n-     */\n-    public static BigInteger pow(final BigInteger k, long e)\n-        throws IllegalArgumentException {\n-\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static BigInteger pow(final BigInteger k, long e) {\n         if (e < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n-                k, e);\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n \n         BigInteger result = BigInteger.ONE;\n \n     /**\n      * Raise a BigInteger to a BigInteger power.\n-     * @param k number to raise\n-     * @param e exponent (must be positive or null)\n+     *\n+     * @param k Number to raise.\n+     * @param e Exponent (must be positive or zero).\n      * @return k<sup>e</sup>\n-     * @exception IllegalArgumentException if e is negative\n-     */\n-    public static BigInteger pow(final BigInteger k, BigInteger e)\n-        throws IllegalArgumentException {\n-\n+     * @throws NotPositiveException if {@code e < 0}.\n+     */\n+    public static BigInteger pow(final BigInteger k, BigInteger e) {\n         if (e.compareTo(BigInteger.ZERO) < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n-                k, e);\n+            throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n         }\n \n         BigInteger result = BigInteger.ONE;\n         }\n \n         return result;\n-\n     }\n \n     /**\n      * @param val Values.\n      * @param dir Ordering direction.\n      * @param strict Whether the order should be strict.\n-     * @throws NonMonotonousSequenceException if the array is not sorted.\n-     */\n-    public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {\n+     * @param abort Whether to throw an exception if the check fails.\n+     * @return {@code true} if the array is sorted.\n+     * @throws NonMonotonousSequenceException if the array is not sorted\n+     * and {@code abort} is {@code true}.\n+     */\n+    public static boolean checkOrder(double[] val, OrderDirection dir,\n+                                     boolean strict, boolean abort) {\n         double previous = val[0];\n         boolean ok = true;\n \n                 throw new IllegalArgumentException();\n             }\n \n-            if (!ok) {\n+            if (!ok &&\n+                abort) {\n                 throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);\n             }\n             previous = val[i];\n         }\n+\n+        return ok;\n+    }\n+\n+    /**\n+     * Checks that the given array is sorted.\n+     *\n+     * @param val Values.\n+     * @param dir Ordering direction.\n+     * @param strict Whether the order should be strict.\n+     * @return {@code true} if the array is sorted.\n+     * @throws NonMonotonousSequenceException if the array is not sorted\n+     * and {@code abort} is {@code true}.\n+     */\n+    public static boolean checkOrder(double[] val, OrderDirection dir,\n+                                     boolean strict) {\n+        return checkOrder(val, dir, strict, true);\n     }\n \n     /**\n      * Checks that the given array is sorted in strictly increasing order.\n      *\n      * @param val Values.\n+     * @return {@code true} if the array is sorted.\n      * @throws NonMonotonousSequenceException if the array is not sorted.\n      */\n-    public static void checkOrder(double[] val) {\n-        checkOrder(val, OrderDirection.INCREASING, true);\n+    public static boolean checkOrder(double[] val) {\n+        return checkOrder(val, OrderDirection.INCREASING, true);\n     }\n \n     /**\n      * @return the 2-norm of the vector\n      */\n     public static double safeNorm(double[] v) {\n-    double rdwarf = 3.834e-20;\n-    double rgiant = 1.304e+19;\n-    double s1=0.0;\n-    double s2=0.0;\n-    double s3=0.0;\n-    double x1max = 0.0;\n-    double x3max = 0.0;\n-    double floatn = (double)v.length;\n-    double agiant = rgiant/floatn;\n-    for (int i=0;i<v.length;i++) {\n-        double xabs = Math.abs(v[i]);\n-        if (xabs<rdwarf || xabs>agiant) {\n-            if (xabs>rdwarf) {\n-                if (xabs>x1max) {\n-                    double r=x1max/xabs;\n-                    s1=1.0+s1*r*r;\n-                    x1max=xabs;\n+        double rdwarf = 3.834e-20;\n+        double rgiant = 1.304e+19;\n+        double s1 = 0;\n+        double s2 = 0;\n+        double s3 = 0;\n+        double x1max = 0;\n+        double x3max = 0;\n+        double floatn = (double) v.length;\n+        double agiant = rgiant / floatn;\n+        for (int i = 0; i < v.length; i++) {\n+            double xabs = Math.abs(v[i]);\n+            if (xabs < rdwarf || xabs > agiant) {\n+                if (xabs > rdwarf) {\n+                    if (xabs > x1max) {\n+                        double r = x1max / xabs;\n+                        s1= 1 + s1 * r * r;\n+                        x1max = xabs;\n+                    } else {\n+                        double r = xabs / x1max;\n+                        s1 += r * r;\n+                    }\n                 } else {\n-                    double r=xabs/x1max;\n-                    s1+=r*r;\n+                    if (xabs > x3max) {\n+                        double r = x3max / xabs;\n+                        s3= 1 + s3 * r * r;\n+                        x3max = xabs;\n+                    } else {\n+                        if (xabs != 0) {\n+                            double r = xabs / x3max;\n+                            s3 += r * r;\n+                        }\n+                    }\n                 }\n             } else {\n-                if (xabs>x3max) {\n-                 double r=x3max/xabs;\n-                 s3=1.0+s3*r*r;\n-                 x3max=xabs;\n+                s2 += xabs * xabs;\n+            }\n+        }\n+        double norm;\n+        if (s1 != 0) {\n+            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n+        } else {\n+            if (s2 == 0) {\n+                norm = x3max * Math.sqrt(s3);\n+            } else {\n+                if (s2 >= x3max) {\n+                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                 } else {\n-                    if (xabs!=0.0) {\n-                        double r=xabs/x3max;\n-                        s3+=r*r;\n-                    }\n+                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                 }\n             }\n-        } else {\n-         s2+=xabs*xabs;\n-        }\n-    }\n-    double norm;\n-    if (s1!=0.0) {\n-        norm = x1max*Math.sqrt(s1+(s2/x1max)/x1max);\n-    } else {\n-        if (s2==0.0) {\n-            norm = x3max*Math.sqrt(s3);\n-        } else {\n-            if (s2>=x3max) {\n-                norm = Math.sqrt(s2*(1.0+(x3max/s2)*(x3max*s3)));\n-            } else {\n-                norm = Math.sqrt(x3max*((s2/x3max)+(x3max*s3)));\n-            }\n-        }\n-    }\n-    return norm;\n+        }\n+        return norm;\n+    }\n+\n+    /**\n+     * Sort an array in increasing order, performing the same reordering of\n+     * entries on other arrays.\n+     *\n+     * @param x Array to be sorted.\n+     * @param yList Set of arrays whose permutations of entries must follow\n+     * those performed on {@code x}.\n+     * @throws DimensionMismatchException if any {@code y} has not the same\n+     * size as {@code x}.\n+     */\n+    public static void sortInPlace(double[] x,\n+                                   double[] ... yList) {\n+        sortInPlace(x, OrderDirection.INCREASING, yList);\n+    }\n+\n+    /**\n+     * Sort an array, performing the same reordering of entries on other arrays.\n+     *\n+     * @param x Array to be sorted.\n+     * @param dir Order direction.\n+     * @param yList Set of arrays whose permutations of entries must follow\n+     * those performed on {@code x}.\n+     * @throws DimensionMismatchException if any {@code y} has not the same\n+     * size as {@code x}.\n+     */\n+    public static void sortInPlace(double[] x,\n+                                   final OrderDirection dir,\n+                                   double[] ... yList) {\n+        if (x == null ||\n+            yList == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        final int len = x.length;\n+        final List<Map.Entry<Double, double[]>> list\n+            = new ArrayList<Map.Entry<Double, double[]>>(len);\n+\n+        final int yListLen = yList.length;\n+        for (int i = 0; i < len; i++) {\n+            final double[] yValues = new double[yListLen];\n+            for (int j = 0; j < yListLen; j++) {\n+                double[] y = yList[j];\n+                if (y.length != len) {\n+                    throw new DimensionMismatchException(y.length, len);\n+                }\n+                yValues[j] = y[i];\n+            }\n+            list.add(new AbstractMap.SimpleEntry<Double, double[]>(x[i], yValues));\n+        }\n+\n+        final Comparator<Map.Entry<Double, double[]>> comp\n+            = new Comparator<Map.Entry<Double, double[]>>() {\n+            public int compare(Map.Entry<Double, double[]> o1,\n+                               Map.Entry<Double, double[]> o2) {\n+                int val;\n+                switch (dir) {\n+                case INCREASING:\n+                    val = o1.getKey().compareTo(o2.getKey());\n+                break;\n+                case DECREASING:\n+                    val = o2.getKey().compareTo(o1.getKey());\n+                break;\n+                default:\n+                    // Should never happen.\n+                    throw new IllegalArgumentException();\n+                }\n+                return val;\n+            }\n+        };\n+\n+        Collections.sort(list, comp);\n+\n+        for (int i = 0; i < len; i++) {\n+            final Map.Entry<Double, double[]> e = list.get(i);\n+            x[i] = e.getKey();\n+            final double[] yValues = e.getValue();\n+            for (int j = 0; j < yListLen; j++) {\n+                yList[j][i] = yValues[j];\n+            }\n+        }\n+    }\n }\n-\n-}\n--- a/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n--- a/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n--- a/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n+++ b/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n--- a/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * Wrapper class for counting functions calls.\n--- a/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * Auxiliary class for testing solvers.\n--- a/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n--- a/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n \n /**\n  * Auxiliary class for testing optimizers.\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n import java.util.Random;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n             double y[] = { 0.0, 4.0, 4.0, 2.5 };\n             UnivariateRealFunction p = interpolator.interpolate(x, y);\n             p.value(0.0);\n-            fail(\"Expecting MathException - bad abscissas array\");\n-        } catch (MathException ex) {\n+            fail(\"Expecting NonMonotonousSequenceException - bad abscissas array\");\n+        } catch (NonMonotonousSequenceException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n             double y[] = { 0.0, 4.0, 4.0, 2.5 };\n             UnivariateRealFunction p = interpolator.interpolate(x, y);\n             p.value(0.0);\n-            fail(\"Expecting MathException - bad abscissas array\");\n-        } catch (MathException ex) {\n+            fail(\"Expecting NonMonotonousSequenceException - bad abscissas array\");\n+        } catch (NonMonotonousSequenceException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n import java.util.Arrays;\n import junit.framework.TestCase;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n /**\n \n         try { //outside of domain -- under min\n             x = spline.value(-1.5);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (FunctionEvaluationException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n \n         try { //outside of domain -- over max\n             x = spline.value(2.5);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (FunctionEvaluationException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n import java.awt.geom.Point2D;\n import java.util.ArrayList;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.optimization.direct.NelderMead;\n+import org.apache.commons.math.optimization.direct.SimplexOptimizer;\n+import org.apache.commons.math.optimization.direct.NelderMeadSimplex;\n import org.apache.commons.math.random.GaussianRandomGenerator;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.RandomVectorGenerator;\n import org.junit.Test;\n \n public class MultiStartMultivariateRealOptimizerTest {\n+    @Test\n+    public void testRosenbrock() {\n+        Rosenbrock rosenbrock = new Rosenbrock();\n+        SimplexOptimizer underlying = new SimplexOptimizer();\n+        NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {\n+                { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+            });\n+        underlying.setSimplex(simplex);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(16069223052l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));\n+        MultiStartMultivariateRealOptimizer optimizer =\n+            new MultiStartMultivariateRealOptimizer(underlying, 10, generator);\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n+        optimizer.setMaxEvaluations(1100);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n-  @Test\n-  public void testRosenbrock()\n-    throws FunctionEvaluationException {\n+        assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+        assertTrue(optimizer.getEvaluations() > 900);\n+        assertTrue(optimizer.getEvaluations() < 1200);\n+        assertTrue(optimum.getValue() < 8.0e-4);\n+    }\n \n-    Rosenbrock rosenbrock = new Rosenbrock();\n-    NelderMead underlying = new NelderMead();\n-    underlying.setStartConfiguration(new double[][] {\n-                                         { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n-                                     });\n-    JDKRandomGenerator g = new JDKRandomGenerator();\n-    g.setSeed(16069223052l);\n-    RandomVectorGenerator generator =\n-        new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));\n-    MultiStartMultivariateRealOptimizer optimizer =\n-        new MultiStartMultivariateRealOptimizer(underlying, 10, generator);\n-    optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n-    optimizer.setMaxEvaluations(1100);\n-    RealPointValuePair optimum =\n-        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+    private static class Rosenbrock implements MultivariateRealFunction {\n+        private int count;\n \n-    assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n-    assertTrue(optimizer.getEvaluations() > 900);\n-    assertTrue(optimizer.getEvaluations() < 1200);\n-    assertTrue(optimum.getValue() < 8.0e-4);\n+        public Rosenbrock() {\n+            count = 0;\n+        }\n \n-  }\n+        public double value(double[] x) {\n+            ++count;\n+            double a = x[1] - x[0] * x[0];\n+            double b = 1.0 - x[0];\n+            return 100 * a * a + b * b;\n+        }\n \n-  private static class Rosenbrock implements MultivariateRealFunction {\n-\n-      private int count;\n-\n-      public Rosenbrock() {\n-          count = 0;\n-      }\n-\n-      public double value(double[] x) throws FunctionEvaluationException {\n-          ++count;\n-          double a = x[1] - x[0] * x[0];\n-          double b = 1.0 - x[0];\n-          return 100 * a * a + b * b;\n-      }\n-\n-      public int getCount() {\n-          return count;\n-      }\n-\n-  }\n-\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n  */\n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.SumSincFunction;\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n \n import static org.junit.Assert.assertEquals;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.\n        LevenbergMarquardtOptimizer;\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunctionTest.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n \n import junit.framework.TestCase;\n \n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BracketFinderTest.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Arrays;\n \n import junit.framework.TestCase;\n \n             // Expected\n         }\n     }\n+\n+    public void testSortInPlace() {\n+        final double[] x1 = {2,   5,  -3, 1,  4};\n+        final double[] x2 = {4,  25,   9, 1, 16};\n+        final double[] x3 = {8, 125, -27, 1, 64};\n+        \n+        MathUtils.sortInPlace(x1, x2, x3);\n+\n+        assertEquals(-3,  x1[0], Math.ulp(1d));\n+        assertEquals(9,   x2[0], Math.ulp(1d));\n+        assertEquals(-27, x3[0], Math.ulp(1d));\n+\n+        assertEquals(1, x1[1], Math.ulp(1d));\n+        assertEquals(1, x2[1], Math.ulp(1d));\n+        assertEquals(1, x3[1], Math.ulp(1d));\n+\n+        assertEquals(2, x1[2], Math.ulp(1d));\n+        assertEquals(4, x2[2], Math.ulp(1d));\n+        assertEquals(8, x3[2], Math.ulp(1d));\n+\n+        assertEquals(4,  x1[3], Math.ulp(1d));\n+        assertEquals(16, x2[3], Math.ulp(1d));\n+        assertEquals(64, x3[3], Math.ulp(1d));\n+\n+        assertEquals(5,   x1[4], Math.ulp(1d));\n+        assertEquals(25,  x2[4], Math.ulp(1d));\n+        assertEquals(125, x3[4], Math.ulp(1d));\n+    }\n }", "timestamp": 1288791964, "metainfo": ""}