{"sha": "c3603b91a40d205be58b3f2716965d5f65da90e4", "log": "Adding unit test for OpenIntToFieldHashMap  ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/OpenIntToFieldTest.java\n+package org.apache.commons.math.util;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.Map.Entry;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+import junit.framework.TestCase;\n+\n+public class OpenIntToFieldTest extends TestCase {\n+\n+    private Map<Integer, Fraction> javaMap = new HashMap<Integer, Fraction>();\n+    private FractionField field = FractionField.getInstance();\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        javaMap.put(50, new Fraction(100.0));\n+        javaMap.put(75, new Fraction(75.0));\n+        javaMap.put(25, new Fraction(500.0));\n+        javaMap.put(Integer.MAX_VALUE, new Fraction(Integer.MAX_VALUE));\n+        javaMap.put(0, new Fraction(-1.0));\n+        javaMap.put(1, new Fraction(0.0));\n+        javaMap.put(33, new Fraction(-0.1));\n+        javaMap.put(23234234, new Fraction(-242343.0));\n+        javaMap.put(23321, new Fraction (Integer.MIN_VALUE));\n+        javaMap.put(-4444, new Fraction(332.0));\n+        javaMap.put(-1, new Fraction(-2323.0));\n+        javaMap.put(Integer.MIN_VALUE, new Fraction(44.0));\n+\n+        /* Add a few more to cause the table to rehash */\n+        javaMap.putAll(generate());\n+\n+    }\n+\n+    private Map<Integer, Fraction> generate() {\n+        Map<Integer, Fraction> map = new HashMap<Integer, Fraction>();\n+        Random r = new Random();\n+        double dd=0;\n+        for (int i = 0; i < 2000; ++i)\n+            dd = r.nextDouble(); \n+            try {\n+                map.put(r.nextInt(), new Fraction(dd));\n+            } catch (FractionConversionException e) {\n+                throw new IllegalStateException(\"Invalid :\"+dd, e);\n+            }\n+        return map;\n+    }\n+\n+    private OpenIntToFieldHashMap<Fraction> createFromJavaMap(Field<Fraction> field) {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+        }\n+        return map;\n+    }\n+    \n+    public void testPutAndGetWith0ExpectedSize() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0);\n+        assertPutAndGet(map);\n+    }\n+    \n+    public void testPutAndGetWithExpectedSize() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500);\n+        assertPutAndGet(map);\n+    }\n+\n+    public void testPutAndGet() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        assertPutAndGet(map);\n+    }\n+\n+    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map) {\n+        assertPutAndGet(map, 0, new HashSet<Integer>());\n+    }\n+\n+    private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map, int mapSize,\n+            Set<Integer> keysInMap) {\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            if (!keysInMap.contains(mapEntry.getKey()))\n+                ++mapSize;\n+            assertEquals(mapSize, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutAbsentOnExisting() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int size = javaMap.size();\n+        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(++size, map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testPutOnExisting() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.put(mapEntry.getKey(), mapEntry.getValue());\n+            assertEquals(javaMap.size(), map.size());\n+            assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey()));\n+        }\n+    }\n+\n+    public void testGetAbsent() {\n+        Map<Integer, Fraction> generated = generateAbsent();\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        \n+        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet())\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+    }\n+\n+    public void testGetFromEmpty() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        assertTrue(field.getZero().equals(map.get(5)));\n+        assertTrue(field.getZero().equals(map.get(0)));\n+        assertTrue(field.getZero().equals(map.get(50)));\n+    }\n+\n+    public void testRemove() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int mapSize = javaMap.size();\n+        assertEquals(mapSize, map.size());\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map);\n+    }\n+\n+    /* This time only remove some entries */\n+    public void testRemove2() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int mapSize = javaMap.size();\n+        int count = 0;\n+        Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet());\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            keysInMap.remove(mapEntry.getKey());\n+            map.remove(mapEntry.getKey());\n+            assertEquals(--mapSize, map.size());\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+            if (count++ > 5)\n+                break;\n+        }\n+\n+        /* Ensure that put and get still work correctly after removals */\n+        assertPutAndGet(map, mapSize, keysInMap);\n+    }\n+\n+    public void testRemoveFromEmpty() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        assertTrue(field.getZero().equals(map.remove(50)));\n+    }\n+\n+    public void testRemoveAbsent() {\n+        Map<Integer, Fraction> generated = generateAbsent();\n+\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        int mapSize = map.size();\n+        \n+        for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) {\n+            map.remove(mapEntry.getKey());\n+            assertEquals(mapSize, map.size());\n+            assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n+        }\n+    }\n+\n+    /**\n+     * Returns a map with at least 100 elements where each element is absent from javaMap.\n+     */\n+    private Map<Integer, Fraction> generateAbsent() {\n+        Map<Integer, Fraction> generated = new HashMap<Integer, Fraction>();\n+        do {\n+            generated.putAll(generate());\n+            for (Integer key : javaMap.keySet())\n+                generated.remove(key);\n+        } while (generated.size() < 100);\n+        return generated;\n+    }\n+\n+    public void testCopy() {\n+        OpenIntToFieldHashMap<Fraction> copy =\n+            new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field));\n+        assertEquals(javaMap.size(), copy.size());\n+\n+        for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet())\n+            assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey()));\n+    }\n+\n+    public void testContainsKey() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            assertTrue(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) {\n+            assertFalse(map.containsKey(mapEntry.getKey()));\n+        }\n+        for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) {\n+            int key = mapEntry.getKey();\n+            assertTrue(map.containsKey(key));\n+            map.remove(key);\n+            assertFalse(map.containsKey(key));\n+        }\n+    }\n+\n+    public void testIterator() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();\n+        for (int i = 0; i < map.size(); ++i) {\n+            assertTrue(iterator.hasNext());\n+            iterator.advance();\n+            int key = iterator.key();\n+            assertTrue(map.containsKey(key));\n+            assertEquals(javaMap.get(key), map.get(key));\n+            assertEquals(javaMap.get(key), iterator.value());\n+            assertTrue(javaMap.containsKey(key));\n+        }\n+        assertFalse(iterator.hasNext());\n+        try {\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n+        } catch (NoSuchElementException nsee) {\n+            // expected\n+        }\n+    }\n+\n+    public void testConcurrentModification() {\n+        OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n+        OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator();\n+        map.put(3, new Fraction(3));\n+        try {\n+            iterator.advance();\n+            fail(\"an exception should have been thrown\");\n+        } catch (ConcurrentModificationException cme) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Regression test for a bug in findInsertionIndex where the hashing in the second probing\n+     * loop was inconsistent with the first causing duplicate keys after the right sequence\n+     * of puts and removes.\n+     */\n+    public void testPutKeysWithCollisions() {\n+        OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field);\n+        int key1 = -1996012590;\n+        Fraction value1 = new Fraction(1);\n+        map.put(key1, value1);\n+        int key2 = 835099822;\n+        map.put(key2, value1);\n+        int key3 = 1008859686;\n+        map.put(key3, value1);\n+        assertEquals(value1, map.get(key3));\n+        assertEquals(3, map.size());\n+        \n+        map.remove(key2);\n+        Fraction value2 = new Fraction(2);\n+        map.put(key3, value2);\n+        assertEquals(value2, map.get(key3));\n+        assertEquals(2, map.size());\n+    }\n+    \n+    /**\n+     * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n+     * different manner.\n+     */\n+    public void testPutKeysWithCollision2() {\n+        OpenIntToFieldHashMap<Fraction>map = new OpenIntToFieldHashMap<Fraction>(field);\n+        int key1 = 837989881;\n+        Fraction value1 = new Fraction(1);\n+        map.put(key1, value1);\n+        int key2 = 476463321;\n+        map.put(key2, value1);\n+        assertEquals(2, map.size());\n+        assertEquals(value1, map.get(key2));\n+        \n+        map.remove(key1);\n+        Fraction value2 = new Fraction(2);\n+        map.put(key2, value2);\n+        assertEquals(1, map.size());\n+        assertEquals(value2, map.get(key2));\n+    }\n+\n+\n+}", "timestamp": 1240886577, "metainfo": ""}