{"sha": "96dfe1afa1c06fb243e312d3366daf99b88ca7b5", "log": "Added a new package dealing with differentials.  The package is intended to deals with one or more free parameters and derivation order 1 or higher.  The core elements are based on Dan Kalman paper \"Recursive Multivariate Automatic Differentiation\", Mathematics Magazine, vol. 75, no. 3, June 2002. For efficiency, the recursive structure is compiled as simple loops once for each pair (number of free parameters, derivation order).  This is work in progress, there are still some features missing even in the most basic blocks (typically the asin, acos, atan, atant2 and taylor methods in DSCompiler). There are also still no high level differentiator implementation.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.util.ArithmeticUtils;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/** Class holding \"compiled\" computation rules for derivative structures.\n+ * <p>This class implements the computation rules described in Dan Kalman's paper <a\n+ * href=\"http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf\">Doubly\n+ * Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75,\n+ * no. 3, June 2002. However, in order to avoid performances bottlenecks, the recursive\n+ * rules are \"compiled\" once in an unfold form. This class does this recursion unrolling\n+ * and stores the computation rules as simple loops with pre-computed indirection arrays.</p>\n+ * <p>\n+ * This class maps all derivative computation into single dimension arrays that hold the\n+ * value and partial derivatives. The class does not hold these arrays, which remains under\n+ * the responsibility of the caller. For each combination of number of free parameters and\n+ * derivation order, only one compiler is necessary, and this compiler will be used to\n+ * perform computations on all arrays provided to it, which can represent hundreds or\n+ * thousands of different parameters kept together with all theur partial derivatives.\n+ * </p>\n+ * <p>\n+ * The arrays on which compilers operate contain only the partial derivatives together\n+ * with the 0<sup>th</sup> derivative, i.e. the value. The partial derivatives are stored in\n+ * a compiler-specific order, which can be retrieved using methods {@link\n+ * #getPartialDerivativeIndex(int...) getPartialDerivativeIndex} and {@link\n+ * #getPartialDerivativeOrders(int)}. The value is guaranteed to be stored as the first element\n+ * (i.e. the {@link #getPartialDerivativeIndex(int...) getPartialDerivativeIndex} method returns\n+ * 0 when called with 0 for all derivation orders and {@link #getPartialDerivativeOrders(int)\n+ * getPartialDerivativeOrders} returns an array filled with 0 when called with 0 as the index).\n+ * </p>\n+ * <p>\n+ * Note that the ordering changes with number of parameters and derivation order. For example\n+ * given 2 parameters x and y, df/dy is stored at index 2 when derivation order is set to 1 (in\n+ * this case the array has three elements: f, df/dx and df/dy). If derivation order is set to\n+ * 2, then df/dy will be stored at index 3 (in this case the array has six elements: f, df/dx,\n+ * df/dxdx, df/dy, df/dxdy and df/dydy).\n+ * </p>\n+ * <p>\n+ * Given this structure, users can perform some simple operations like adding, subtracting\n+ * or multiplying constants and negating the elements by themselves, knowing if they want to\n+ * mutate their array or create a new array. These simple operations are not provided by\n+ * the compiler. The compiler provides only the more complex operations between several arrays.\n+ * </p>\n+ * <p>This class is mainly used as the engine for scalar variable {@link DerivativeStructure}.\n+ * It can also be used directly to hold several variables in arrays for more complex data\n+ * structures. User can for example store a vector of n variables depending on three x, y\n+ * and z free parameters in one array as follows:\n+ * <pre>\n+ *   // parameter 0 is x, parameter 1 is y, parameter 3 is z\n+ *   int parameters = 3;\n+ *   DSCompiler compiler = DSCompiler.getCompiler(parameters, order);\n+ *   int size = compiler.getSize();\n+ *\n+ *   // pack all elements in a single array\n+ *   double[] array = new double[n * size];\n+ *   for (int i = 0; i < n; ++i) {\n+ *\n+ *     // we know value is guaranteed to be the first element\n+ *     array[i * size] = v[i];\n+ *\n+ *     // we don't know where first derivatives are stored, so we ask the compiler\n+ *     array[i * size + compiler.getPartialDerivativeIndex(1, 0, 0) = dvOnDx[i][0];\n+ *     array[i * size + compiler.getPartialDerivativeIndex(0, 1, 0) = dvOnDy[i][0];\n+ *     array[i * size + compiler.getPartialDerivativeIndex(0, 0, 1) = dvOnDz[i][0];\n+ *\n+ *     // we let all higher order derivatives set to 0\n+ *\n+ *   }\n+ * </pre>\n+ * Then in another function, user can perform some operations on all elements stored\n+ * in the single array, such as a simple product of all variables:\n+ * <pre>\n+ *   // compute the product of all elements\n+ *   double[] product = new double[size];\n+ *   prod[0] = 1.0;\n+ *   for (int i = 0; i < n; ++i) {\n+ *     double[] tmp = product.clone();\n+ *     compiler.multiply(tmp, 0, array, i * size, product, 0);\n+ *   }\n+ *\n+ *   // value\n+ *   double p = product[0];\n+ *\n+ *   // first derivatives\n+ *   double dPdX = product[compiler.getPartialDerivativeIndex(1, 0, 0)];\n+ *   double dPdY = product[compiler.getPartialDerivativeIndex(0, 1, 0)];\n+ *   double dPdZ = product[compiler.getPartialDerivativeIndex(0, 0, 1)];\n+ *\n+ *   // cross derivatives (assuming order was at least 2)\n+ *   double dPdXdX = product[compiler.getPartialDerivativeIndex(2, 0, 0)];\n+ *   double dPdXdY = product[compiler.getPartialDerivativeIndex(1, 1, 0)];\n+ *   double dPdXdZ = product[compiler.getPartialDerivativeIndex(1, 0, 1)];\n+ *   double dPdYdY = product[compiler.getPartialDerivativeIndex(0, 2, 0)];\n+ *   double dPdYdZ = product[compiler.getPartialDerivativeIndex(0, 1, 1)];\n+ *   double dPdZdZ = product[compiler.getPartialDerivativeIndex(0, 0, 2)];\n+ * </p>\n+ * @see DerivativeStructure\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class DSCompiler {\n+\n+    /** Array of all compilers created so far. */\n+    private static AtomicReference<DSCompiler[][]> compilers =\n+            new AtomicReference<DSCompiler[][]>(null);\n+\n+    /** Number of free parameters. */\n+    private final int parameters;\n+\n+    /** Derivation order. */\n+    private final int order;\n+\n+    /** Number of partial derivatives (including the single 0 order derivative element). */\n+    private final int[][] sizes;\n+\n+    /** Indirection array for partial derivatives. */\n+    private final int[][] derivativesIndirection;\n+\n+    /** Indirection array of the lower derivative elements. */\n+    private final int[] lowerIndirection;\n+\n+    /** Indirection arrays for multiplication. */\n+    private final int[][][] multIndirection;\n+\n+    /** Indirection arrays for function composition. */\n+    private final int[][][] compIndirection;\n+\n+    /** Get the compiler for number of free parameters and order.\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @return cached rules set\n+     */\n+    public static DSCompiler getCompiler(int parameters, int order) {\n+\n+        // get the cached compilers\n+        final DSCompiler[][] cache = compilers.get();\n+        if (cache != null && cache.length > parameters && cache[parameters].length > order) {\n+            // the compiler has already been created\n+            return cache[parameters][order];\n+        }\n+\n+        // we need to create more compilers\n+        final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n+        final int maxOrder      = FastMath.max(order,     cache == null ? 0 : cache[0].length);\n+        final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n+\n+        if (cache != null) {\n+            // preserve the already created compilers\n+            for (int i = 0; i < cache.length; ++i) {\n+                System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n+            }\n+        }\n+\n+        // create the array in increasing diagonal order\n+        for (int diag = 0; diag <= maxParameters + maxOrder; ++diag) {\n+            for (int o = FastMath.max(0, diag - maxParameters); o <= FastMath.min(maxOrder, diag); ++o) {\n+                final int p = diag - o;\n+                if (newCache[p][o] == null) {\n+                    final DSCompiler valueCompiler      = (p == 0) ? null : newCache[p - 1][o];\n+                    final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n+                    newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n+                }\n+            }\n+        }\n+\n+        // atomically reset the cached compilers array\n+        compilers.compareAndSet(cache, newCache);\n+\n+        return newCache[parameters][order];\n+\n+    }\n+\n+    /** Private constructor, reserved for the factory method {@link #getCompiler(int, int)}.\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @param valueCompiler compiler for the value part\n+     * @param derivativeCompiler compiler for the derivative part\n+     */\n+    private DSCompiler(final int parameters, final int order,\n+                       final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n+\n+        this.parameters = parameters;\n+        this.order      = order;\n+        this.sizes      = compileSizes(parameters, order, valueCompiler, derivativeCompiler);\n+        this.derivativesIndirection =\n+                compileDerivativesIndirection(parameters, order,\n+                                              valueCompiler, derivativeCompiler);\n+        this.lowerIndirection =\n+                compileLowerIndirection(parameters, order,\n+                                        valueCompiler, derivativeCompiler);\n+        this.multIndirection =\n+                compileMultiplicationIndirection(parameters, order,\n+                                                 valueCompiler, derivativeCompiler, lowerIndirection);\n+        this.compIndirection =\n+                compileCompositionIndirection(parameters, order,\n+                                              valueCompiler, derivativeCompiler,\n+                                              sizes, derivativesIndirection, lowerIndirection);\n+\n+\n+    }\n+\n+    /** Compile the sizes array.\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @param valueCompiler compiler for the value part\n+     * @param derivativeCompiler compiler for the derivative part\n+     * @return sizes array\n+     */\n+    private static int[][] compileSizes(final int parameters, final int order,\n+                                        final DSCompiler valueCompiler,\n+                                        final DSCompiler derivativeCompiler) {\n+\n+        final int[][] sizes = new int[parameters + 1][order + 1];\n+        if (parameters == 0) {\n+            Arrays.fill(sizes[0], 1);\n+        } else {\n+            System.arraycopy(valueCompiler.sizes, 0, sizes, 0, parameters);\n+            sizes[parameters][0] = 1;\n+            for (int i = 0; i < order; ++i) {\n+                sizes[parameters][i + 1] = sizes[parameters][i] + sizes[parameters - 1][i + 1];\n+            }\n+        }\n+\n+        return sizes;\n+\n+    }\n+\n+    /** Compile the derivatives indirection array.\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @param valueCompiler compiler for the value part\n+     * @param derivativeCompiler compiler for the derivative part\n+     * @return derivatives indirection array\n+     */\n+    private static int[][] compileDerivativesIndirection(final int parameters, final int order,\n+                                                      final DSCompiler valueCompiler,\n+                                                      final DSCompiler derivativeCompiler) {\n+\n+        if (parameters == 0 || order == 0) {\n+            return new int[1][parameters];\n+        }\n+\n+        final int vSize = valueCompiler.derivativesIndirection.length;\n+        final int dSize = derivativeCompiler.derivativesIndirection.length;\n+        final int[][] derivativesIndirection = new int[vSize + dSize][parameters];\n+\n+        // set up the indices for the value part\n+        for (int i = 0; i < vSize; ++i) {\n+            // copy the first indices, the last one remaining set to 0\n+            System.arraycopy(valueCompiler.derivativesIndirection[i], 0,\n+                             derivativesIndirection[i], 0,\n+                             parameters - 1);\n+        }\n+\n+        // set up the indices for the derivative part\n+        for (int i = 0; i < dSize; ++i) {\n+\n+            // copy the indices\n+            System.arraycopy(derivativeCompiler.derivativesIndirection[i], 0,\n+                             derivativesIndirection[vSize + i], 0,\n+                             parameters);\n+\n+            // increment the derivation order for the last parameter\n+            derivativesIndirection[vSize + i][parameters - 1]++;\n+\n+        }\n+\n+        return derivativesIndirection;\n+\n+    }\n+\n+    /** Compile the lower derivatives indirection array.\n+     * <p>\n+     * This indirection array contains the indices of all elements\n+     * except derivatives for last derivation order.\n+     * </p>\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @param valueCompiler compiler for the value part\n+     * @param derivativeCompiler compiler for the derivative part\n+     * @return lower derivatives indirection array\n+     */\n+    private static int[] compileLowerIndirection(final int parameters, final int order,\n+                                              final DSCompiler valueCompiler,\n+                                              final DSCompiler derivativeCompiler) {\n+\n+        if (parameters == 0 || order <= 1) {\n+            return new int[] { 0 };\n+        }\n+\n+        // this is an implementation of definition 6 in Dan Kalman's paper.\n+        final int vSize = valueCompiler.lowerIndirection.length;\n+        final int dSize = derivativeCompiler.lowerIndirection.length;\n+        final int[] lowerIndirection = new int[vSize + dSize];\n+        System.arraycopy(valueCompiler.lowerIndirection, 0, lowerIndirection, 0, vSize);\n+        for (int i = 0; i < dSize; ++i) {\n+            lowerIndirection[vSize + i] = valueCompiler.getSize() + derivativeCompiler.lowerIndirection[i];\n+        }\n+\n+        return lowerIndirection;\n+\n+    }\n+\n+    /** Compile the multiplication indirection array.\n+     * <p>\n+     * This indirection array contains the indices of all pairs of elements\n+     * involved when computing a multiplication. This allows a straightforward\n+     * loop-based multiplication (see {@link #multiply(double[], int, double[], int, double[], int)}).\n+     * </p>\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @param valueCompiler compiler for the value part\n+     * @param derivativeCompiler compiler for the derivative part\n+     * @param lowerIndirection lower derivatives indirection array\n+     * @return multiplication indirection array\n+     */\n+    private static int[][][] compileMultiplicationIndirection(final int parameters, final int order,\n+                                                           final DSCompiler valueCompiler,\n+                                                           final DSCompiler derivativeCompiler,\n+                                                           final int[] lowerIndirection) {\n+\n+        if ((parameters == 0) || (order == 0)) {\n+            return new int[][][] { { { 1, 0, 0 } } };\n+        }\n+\n+        // this is an implementation of definition 3 in Dan Kalman's paper.\n+        final int vSize = valueCompiler.multIndirection.length;\n+        final int dSize = derivativeCompiler.multIndirection.length;\n+        final int[][][] multIndirection = new int[vSize + dSize][][];\n+\n+        System.arraycopy(valueCompiler.multIndirection, 0, multIndirection, 0, vSize);\n+\n+        for (int i = 0; i < dSize; ++i) {\n+            final int[][] dRow = derivativeCompiler.multIndirection[i];\n+            List<int[]> row = new ArrayList<int[]>();\n+            for (int j = 0; j < dRow.length; ++j) {\n+                row.add(new int[] { dRow[j][0], lowerIndirection[dRow[j][1]], vSize + dRow[j][2] });\n+                row.add(new int[] { dRow[j][0], vSize + dRow[j][1], lowerIndirection[dRow[j][2]] });\n+            }\n+\n+            // combine terms with similar derivation orders\n+            final List<int[]> combined = new ArrayList<int[]>(row.size());\n+            for (int j = 0; j < row.size(); ++j) {\n+                final int[] termJ = row.get(j);\n+                if (termJ[0] > 0) {\n+                    for (int k = j + 1; k < row.size(); ++k) {\n+                        final int[] termK = row.get(k);\n+                        if (termJ[1] == termK[1] && termJ[2] == termK[2]) {\n+                            // combine termJ and termK\n+                            termJ[0] += termK[0];\n+                            // make sure we will skip termK later on in the outer loop\n+                            termK[0] = 0;\n+                        }\n+                    }\n+                    combined.add(termJ);\n+                }\n+            }\n+\n+            multIndirection[vSize + i] = combined.toArray(new int[combined.size()][]);\n+\n+        }\n+\n+        return multIndirection;\n+\n+    }\n+\n+    /** Compile the function composition indirection array.\n+     * <p>\n+     * This indirection array contains the indices of all sets of elements\n+     * involved when computing a composition. This allows a straightforward\n+     * loop-based composition (see {@link #compose(double[], int, double[], double[], int)}).\n+     * </p>\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @param valueCompiler compiler for the value part\n+     * @param derivativeCompiler compiler for the derivative part\n+     * @param sizes sizes array\n+     * @param derivativesIndirection derivatives indirection array\n+     * @param lowerIndirection lower derivatives indirection array\n+     * @return multiplication indirection array\n+     */\n+    private static int[][][] compileCompositionIndirection(final int parameters, final int order,\n+                                                        final DSCompiler valueCompiler,\n+                                                        final DSCompiler derivativeCompiler,\n+                                                        final int[][] sizes,\n+                                                        final int[][] derivativesIndirection,\n+                                                        final int[] lowerIndirection) {\n+\n+        if ((parameters == 0) || (order == 0)) {\n+            return new int[][][] { { { 1, 0 } } };\n+        }\n+\n+        final int vSize = valueCompiler.compIndirection.length;\n+        final int dSize = derivativeCompiler.compIndirection.length;\n+        final int[][][] compIndirection = new int[vSize + dSize][][];\n+\n+        // the composition rules from the value part can be reused as is\n+        System.arraycopy(valueCompiler.compIndirection, 0, compIndirection, 0, vSize);\n+\n+        // the composition rules for the derivative part are deduced by\n+        // differentiation the rules from the underlying compiler once\n+        // with respect to the parameter this compiler handles and the\n+        // underlying one did not handle\n+        for (int i = 0; i < dSize; ++i) {\n+            List<int[]> row = new ArrayList<int[]>();\n+            for (int[] term : derivativeCompiler.compIndirection[i]) {\n+\n+                // handle term p * f_k(g(x)) * g_l1(x) * g_l2(x) * ... * g_lp(x)\n+\n+                // derive the first factor in the term: f_k with respect to new parameter\n+                int[] derivedTermF = new int[term.length + 1];\n+                derivedTermF[0] = term[0];     // p\n+                derivedTermF[1] = term[1] + 1; // f_(k+1)\n+                int[] orders = new int[parameters];\n+                orders[parameters - 1] = 1;\n+                derivedTermF[term.length] = getPartialDerivativeIndex(parameters, order, sizes, orders);  // g_1\n+                for (int j = 2; j < term.length; ++j) {\n+                    // convert the indices as the mapping for the current order\n+                    // is different from the mapping with one less order\n+                    derivedTermF[j] = convertIndex(term[j], parameters,\n+                                                   derivativeCompiler.derivativesIndirection,\n+                                                   parameters, order, sizes);\n+                }\n+                Arrays.sort(derivedTermF, 2, derivedTermF.length);\n+                row.add(derivedTermF);\n+\n+                // derive the various g_l\n+                for (int l = 2; l < term.length; ++l) {\n+                    int[] derivedTermG = new int[term.length];\n+                    derivedTermG[0] = term[0];\n+                    derivedTermG[1] = term[1];\n+                    for (int j = 2; j < term.length; ++j) {\n+                        // convert the indices as the mapping for the current order\n+                        // is different from the mapping with one less order\n+                        derivedTermG[j] = convertIndex(term[j], parameters,\n+                                                       derivativeCompiler.derivativesIndirection,\n+                                                       parameters, order, sizes);\n+                        if (j == l) {\n+                            // derive this term\n+                            System.arraycopy(derivativesIndirection[derivedTermG[j]], 0, orders, 0, parameters);\n+                            orders[parameters - 1]++;\n+                            derivedTermG[j] = getPartialDerivativeIndex(parameters, order, sizes, orders);\n+                        }\n+                    }\n+                    Arrays.sort(derivedTermG, 2, derivedTermG.length);\n+                    row.add(derivedTermG);\n+                }\n+\n+            }\n+\n+            // combine terms with similar derivation orders\n+            final List<int[]> combined = new ArrayList<int[]>(row.size());\n+            for (int j = 0; j < row.size(); ++j) {\n+                final int[] termJ = row.get(j);\n+                if (termJ[0] > 0) {\n+                    for (int k = j + 1; k < row.size(); ++k) {\n+                        final int[] termK = row.get(k);\n+                        boolean equals = termJ.length == termK.length;\n+                        for (int l = 1; equals && l < termJ.length; ++l) {\n+                            equals &= termJ[l] == termK[l];\n+                        }\n+                        if (equals) {\n+                            // combine termJ and termK\n+                            termJ[0] += termK[0];\n+                            // make sure we will skip termK later on in the outer loop\n+                            termK[0] = 0;\n+                        }\n+                    }\n+                    combined.add(termJ);\n+                }\n+            }\n+\n+            compIndirection[vSize + i] = combined.toArray(new int[combined.size()][]);\n+\n+        }\n+\n+        return compIndirection;\n+\n+    }\n+\n+    /** Get the index of a partial derivative in the array.\n+     * <p>\n+     * If all orders are set to 0, then the 0<sup>th</sup> order derivative\n+     * is returned, which is the value of the function. The index for this\n+     * 0<sup>th</sup> order derivative is always 0. the indices of higher\n+     * order derivatives is between 1 and {@link #getSize() - 1)}.\n+     * </p>\n+     * <p>\n+     * This method is the inverse of method {@link #getPartialDerivativeOrders(int)}\n+     * </p>\n+     * @param orders derivation orders with respect to each parameter\n+     * @return index of the partial derivative\n+     * @exception DimensionMismatchException if the numbers of parameters does not\n+     * match the instance\n+     * @exception NumberIsTooLargeException if sum of derivation orders is larger\n+     * than the instance limits\n+     * @see #getPartialDerivativeOrders(int)\n+     */\n+    public int getPartialDerivativeIndex(final int ... orders)\n+            throws DimensionMismatchException, NumberIsTooLargeException {\n+\n+        // safety check\n+        if (orders.length != getFreeParameters()) {\n+            throw new DimensionMismatchException(orders.length, getFreeParameters());\n+        }\n+\n+        return getPartialDerivativeIndex(parameters, order, sizes, orders);\n+\n+    }\n+\n+    /** Get the index of a partial derivative in an array.\n+     * @param parameters number of free parameters\n+     * @param order derivation order\n+     * @param sizes sizes array\n+     * @param orders derivation orders with respect to each parameter\n+     * (the lenght of this array must match the number of parameters)\n+     * @return index of the partial derivative\n+     * @exception NumberIsTooLargeException if sum of derivation orders is larger\n+     * than the instance limits\n+     */\n+    private static int getPartialDerivativeIndex(final int parameters, final int order,\n+                                                 final int[][] sizes, final int ... orders)\n+        throws NumberIsTooLargeException {\n+\n+        // the value is obtained by diving into the recursive Dan Kalman's structure\n+        // this is theorem 2 of his paper, with recursion replaced by iteration\n+        int index     = 0;\n+        int m         = order;\n+        int ordersSum = 0;\n+        for (int i = parameters - 1; i >= 0; --i) {\n+\n+            // derivative order for current free parameter\n+            int derivativeOrder = orders[i];\n+\n+            // safety check\n+            ordersSum += derivativeOrder;\n+            if (ordersSum > order) {\n+                throw new NumberIsTooLargeException(ordersSum, order, true);\n+            }\n+\n+            while (derivativeOrder-- > 0) {\n+                // as long as we differentiate according to current free parameter,\n+                // we have to skip the value part and dive into the derivative part\n+                // so we add the size of the value part to the base index\n+                index += sizes[i][m--];\n+            }\n+\n+        }\n+\n+        return index;\n+\n+    }\n+\n+    /** Convert an index from one (parameters, order) structure to another.\n+     * @param index index of a partial derivative in source derivative structure\n+     * @param srcP number of free parameters in source derivative structure\n+     * @param srcDerivativesIndirection derivatives indirection array for the source\n+     * derivative structure\n+     * @param destP number of free parameters in destination derivative structure\n+     * @param destO derivation order in destination derivative structure\n+     * @param destSizes sizes array for the destination derivative structure\n+     * @return index of the partial derivative with the <em>same</em> characteristics\n+     * in destination derivative structure\n+     */\n+    private static int convertIndex(final int index,\n+                                    final int srcP, final int[][] srcDerivativesIndirection,\n+                                    final int destP, final int destO, final int[][] destSizes) {\n+        int[] orders = new int[destP];\n+        System.arraycopy(srcDerivativesIndirection[index], 0, orders, 0, FastMath.min(srcP, destP));\n+        return getPartialDerivativeIndex(destP, destO, destSizes, orders);\n+    }\n+\n+    /** Get the derivation orders for a specific index in the array.\n+     * <p>\n+     * This method is the inverse of {@link #getPartialDerivativeIndex(int...)}.\n+     * </p>\n+     * @param index of the partial derivative\n+     * @return orders derivation orders with respect to each parameter\n+     * @see #getPartialDerivativeIndex(int...)\n+     */\n+    public int[] getPartialDerivativeOrders(final int index) {\n+        return derivativesIndirection[index];\n+    }\n+\n+    /** Get the number of free parameters.\n+     * @return number of free parameters\n+     */\n+    public int getFreeParameters() {\n+        return parameters;\n+    }\n+\n+    /** Get the derivation order.\n+     * @return derivation order\n+     */\n+    public int getOrder() {\n+        return order;\n+    }\n+\n+    /** Get the array size required for holding partial derivatives data.\n+     * <p>\n+     * This number includes the single 0 order derivative element, which is\n+     * guaranteed to be stored in the first element of the array.\n+     * </p>\n+     * @return array size required for holding partial derivatives data\n+     */\n+    public int getSize() {\n+        return sizes[parameters][order];\n+    }\n+\n+    /** Compute linear combination.\n+     * The derivative structure built will be a1 * ds1 + a2 * ds2\n+     * @param a1 first scale factor\n+     * @param c1 first base (unscaled) component\n+     * @param offset1 offset of first operand in its array\n+     * @param a2 second scale factor\n+     * @param c2 second base (unscaled) component\n+     * @param offset2 offset of second operand in its array\n+     * @param result array where result must be stored (it may be\n+     * one of the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void linearCombination(final double a1, final double[] c1, final int offset1,\n+                                  final double a2, final double[] c2, final int offset2,\n+                                  final double[] result, final int resultOffset) {\n+        for (int i = 0; i < getSize(); ++i) {\n+            result[resultOffset + i] =\n+                    MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i]);\n+        }\n+    }\n+\n+    /** Compute linear combination.\n+     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4\n+     * @param a1 first scale factor\n+     * @param c1 first base (unscaled) component\n+     * @param offset1 offset of first operand in its array\n+     * @param a2 second scale factor\n+     * @param c2 second base (unscaled) component\n+     * @param offset2 offset of second operand in its array\n+     * @param a3 third scale factor\n+     * @param c3 third base (unscaled) component\n+     * @param offset3 offset of third operand in its array\n+     * @param result array where result must be stored (it may be\n+     * one of the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void linearCombination(final double a1, final double[] c1, final int offset1,\n+                                  final double a2, final double[] c2, final int offset2,\n+                                  final double a3, final double[] c3, final int offset3,\n+                                  final double[] result, final int resultOffset) {\n+        for (int i = 0; i < getSize(); ++i) {\n+            result[resultOffset + i] =\n+                    MathArrays.linearCombination(a1, c1[offset1 + i],\n+                                                 a2, c2[offset2 + i],\n+                                                 a3, c3[offset3 + i]);\n+        }\n+    }\n+\n+    /** Compute linear combination.\n+     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4\n+     * @param a1 first scale factor\n+     * @param c1 first base (unscaled) component\n+     * @param offset1 offset of first operand in its array\n+     * @param a2 second scale factor\n+     * @param c2 second base (unscaled) component\n+     * @param offset2 offset of second operand in its array\n+     * @param a3 third scale factor\n+     * @param c3 third base (unscaled) component\n+     * @param offset3 offset of third operand in its array\n+     * @param a4 fourth scale factor\n+     * @param c4 fourth base (unscaled) component\n+     * @param offset4 offset of fourth operand in its array\n+     * @param result array where result must be stored (it may be\n+     * one of the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void linearCombination(final double a1, final double[] c1, final int offset1,\n+                                  final double a2, final double[] c2, final int offset2,\n+                                  final double a3, final double[] c3, final int offset3,\n+                                  final double a4, final double[] c4, final int offset4,\n+                                  final double[] result, final int resultOffset) {\n+        for (int i = 0; i < getSize(); ++i) {\n+            result[resultOffset + i] =\n+                    MathArrays.linearCombination(a1, c1[offset1 + i],\n+                                                 a2, c2[offset2 + i],\n+                                                 a3, c3[offset3 + i],\n+                                                 a4, c4[offset4 + i]);\n+        }\n+    }\n+\n+    /** Perform addition of two derivative structures.\n+     * @param lhs array holding left hand side of addition\n+     * @param lhsOffset offset of the left hand side in its array\n+     * @param rhs array right hand side of addition\n+     * @param rhsOffset offset of the right hand side in its array\n+     * @param result array where result must be stored (it may be\n+     * one of the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void add(final double[] lhs, final int lhsOffset,\n+                    final double[] rhs, final int rhsOffset,\n+                    final double[] result, final int resultOffset) {\n+        for (int i = 0; i < getSize(); ++i) {\n+            result[resultOffset + i] = lhs[lhsOffset + i] + rhs[rhsOffset + i];\n+        }\n+    }\n+    /** Perform subtraction of two derivative structures.\n+     * @param lhs array holding left hand side of subtraction\n+     * @param lhsOffset offset of the left hand side in its array\n+     * @param rhs array right hand side of subtraction\n+     * @param rhsOffset offset of the right hand side in its array\n+     * @param result array where result must be stored (it may be\n+     * one of the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void subtract(final double[] lhs, final int lhsOffset,\n+                         final double[] rhs, final int rhsOffset,\n+                         final double[] result, final int resultOffset) {\n+        for (int i = 0; i < getSize(); ++i) {\n+            result[resultOffset + i] = lhs[lhsOffset + i] - rhs[rhsOffset + i];\n+        }\n+    }\n+\n+    /** Perform multiplication of two derivative structures.\n+     * @param lhs array holding left hand side of multiplication\n+     * @param lhsOffset offset of the left hand side in its array\n+     * @param rhs array right hand side of multiplication\n+     * @param rhsOffset offset of the right hand side in its array\n+     * @param result array where result must be stored (for\n+     * multiplication the result array <em>cannot</em> be one of\n+     * the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void multiply(final double[] lhs, final int lhsOffset,\n+                         final double[] rhs, final int rhsOffset,\n+                         final double[] result, final int resultOffset) {\n+        for (int i = 0; i < multIndirection.length; ++i) {\n+            final int[][] mappingI = multIndirection[i];\n+            double r = 0;\n+            for (int j = 0; j < mappingI.length; ++j) {\n+                r += mappingI[j][0] *\n+                     lhs[lhsOffset + mappingI[j][1]] *\n+                     rhs[rhsOffset + mappingI[j][2]];\n+            }\n+            result[resultOffset + i] = r;\n+        }\n+    }\n+\n+    /** Perform division of two derivative structures.\n+     * @param lhs array holding left hand side of division\n+     * @param lhsOffset offset of the left hand side in its array\n+     * @param rhs array right hand side of division\n+     * @param rhsOffset offset of the right hand side in its array\n+     * @param result array where result must be stored (for\n+     * division the result array <em>cannot</em> be one of\n+     * the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void divide(final double[] lhs, final int lhsOffset,\n+                       final double[] rhs, final int rhsOffset,\n+                       final double[] result, final int resultOffset) {\n+        final double[] reciprocal = new double[getSize()];\n+        pow(rhs, lhsOffset, -1, reciprocal, 0);\n+        multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);\n+    }\n+\n+    /** Perform remainder of two derivative structures.\n+     * @param lhs array holding left hand side of remainder\n+     * @param lhsOffset offset of the left hand side in its array\n+     * @param rhs array right hand side of remainder\n+     * @param rhsOffset offset of the right hand side in its array\n+     * @param result array where result must be stored (it may be\n+     * one of the input arrays)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void remainder(final double[] lhs, final int lhsOffset,\n+                          final double[] rhs, final int rhsOffset,\n+                          final double[] result, final int resultOffset) {\n+\n+        // compute k such that lhs % rhs = lhs - k rhs\n+        final double rem = lhs[lhsOffset] % rhs[rhsOffset];\n+        final double k   = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);\n+\n+        // set up value\n+        result[resultOffset] = rem;\n+\n+        // set up partial derivatives\n+        for (int i = 1; i < getSize(); ++i) {\n+            result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i];\n+        }\n+\n+    }\n+\n+    /** Compute power of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param p power to apply\n+     * @param result array where result must be stored (for\n+     * power the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void pow(final double[] operand, final int operandOffset, final double p,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]\n+        double[] function = new double[1 + order];\n+        double xk = FastMath.pow(operand[operandOffset], p - order);\n+        for (int i = order; i > 0; --i) {\n+            function[i] = xk;\n+            xk *= operand[operandOffset];\n+        }\n+        function[0] = xk;\n+        double coefficient = p;\n+        for (int i = 1; i <= order; ++i) {\n+            function[i] *= coefficient;\n+            coefficient *= p - i;\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute integer power of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param n power to apply\n+     * @param result array where result must be stored (for\n+     * power the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void pow(final double[] operand, final int operandOffset, final int n,\n+                    final double[] result, final int resultOffset) {\n+\n+        if (n == 0) {\n+            // special case, x^0 = 1 for all x\n+            result[resultOffset] = 1.0;\n+            Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);\n+            return;\n+        }\n+\n+        // create the power function value and derivatives\n+        // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]\n+        double[] function = new double[1 + order];\n+\n+        if (n > 0) {\n+            // strictly positive power\n+            final int maxOrder = FastMath.min(order, n);\n+            double xk = FastMath.pow(operand[operandOffset], n - maxOrder);\n+            for (int i = maxOrder; i > 0; --i) {\n+                function[i] = xk;\n+                xk *= operand[operandOffset];\n+            }\n+            function[0] = xk;\n+        } else {\n+            // strictly negative power\n+            final double inv = 1.0 / operand[operandOffset];\n+            double xk = FastMath.pow(inv, -n);\n+            for (int i = 0; i <= order; ++i) {\n+                function[i] = xk;\n+                xk *= inv;\n+            }\n+        }\n+\n+        double coefficient = n;\n+        for (int i = 1; i <= order; ++i) {\n+            function[i] *= coefficient;\n+            coefficient *= n - i;\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute n<sup>th</sup> root of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param n order of the root\n+     * @param result array where result must be stored (for\n+     * n<sup>th</sup> root the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void rootN(final double[] operand, final int operandOffset, final int n,\n+                      final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        // [x^(1/n), (1/n)x^((1/n)-1), (1-n)/n^2x^((1/n)-2), ... ]\n+        double[] function = new double[1 + order];\n+        double xk;\n+        if (n == 2) {\n+            xk = FastMath.sqrt(operand[operandOffset]);\n+        } else if (n == 3) {\n+            xk = FastMath.cbrt(operand[operandOffset]);\n+        } else {\n+            xk = FastMath.pow(operand[operandOffset], 1.0 / n);\n+        }\n+        final double nReciprocal = 1.0 / n;\n+        final double xReciprocal = 1.0 / operand[operandOffset];\n+        for (int i = 0; i <= order; ++i) {\n+            function[i] = xk;\n+            xk *= xReciprocal * (nReciprocal - i);\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute exponential of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * exponential the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void exp(final double[] operand, final int operandOffset,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        Arrays.fill(function, FastMath.exp(operand[operandOffset]));\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute natural logarithm of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * logarithm the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void log(final double[] operand, final int operandOffset,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        function[0] = FastMath.log(operand[operandOffset]);\n+        if (order > 0) {\n+            double inv = 1.0 / operand[operandOffset];\n+            double xk  = inv;\n+            for (int i = 1; i <= order; ++i) {\n+                function[i] = xk;\n+                xk *= -i * inv;\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute cosine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * cosine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void cos(final double[] operand, final int operandOffset,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        function[0] = FastMath.cos(operand[operandOffset]);\n+        if (order > 0) {\n+            function[1] = -FastMath.sin(operand[operandOffset]);\n+            for (int i = 2; i <= order; ++i) {\n+                function[i] = -function[i - 2];\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute sine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * sine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void sin(final double[] operand, final int operandOffset,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        function[0] = FastMath.sin(operand[operandOffset]);\n+        if (order > 0) {\n+            function[1] = FastMath.cos(operand[operandOffset]);\n+            for (int i = 2; i <= order; ++i) {\n+                function[i] = -function[i - 2];\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute tangent of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * tangent the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void tan(final double[] operand, final int operandOffset,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        final double z = operand[operandOffset];\n+        final double t = FastMath.tan(z);\n+        function[0] = t;\n+        if (order > 0) {\n+            final double secant2 = 1 + t * t;\n+            function[1] = secant2;\n+            for (int n = 2; n <= order; ++n) {\n+                final int signN4 = ((n & 0x02) == 0) ? 1 : -1;\n+                double outerSum = 0;\n+                int sign = 1;\n+                double secant2Kp2 = secant2;\n+                for (int k = 0; k < n; ++k) {\n+                    double innerSum = 0;\n+                    for (int j = 0; j < k; ++j) {\n+                        final double alpha = 2 * (k - j) * z;\n+                        final double sc  = ((n & 0x01) == 0) ? FastMath.sin(alpha) : FastMath.cos(alpha);\n+                         innerSum += sc * signN4 * ArithmeticUtils.pow(k - j, n - 1) *\n+                                    ArithmeticUtils.binomialCoefficient(2 * k, j);\n+                    }\n+                    double twoNm2K = (n >= 2 * k) ? (1 << (n - 2 * k)) : (1.0 / (1 << (2 * k - n)));\n+                    outerSum  += sign * innerSum * ArithmeticUtils.binomialCoefficient(n - 1, k) *\n+                                 twoNm2K * secant2Kp2 / (k + 1);\n+                    sign       = -sign;\n+                    secant2Kp2 *= secant2;\n+                }\n+                function[n] = n * outerSum;\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute arc cosine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * arc cosine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void acos(final double[] operand, final int operandOffset,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        final double x = operand[operandOffset];\n+        function[0] = FastMath.acos(x);\n+        if (order > 0) {\n+            function[1] = -1.0 / FastMath.sqrt(1 - x * x);\n+            for (int i = 2; i <= order; ++i) {\n+                // TODO compute higher order derivatives\n+                function[i] = Double.NaN;\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute arc sine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * arc sine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void asin(final double[] operand, final int operandOffset,\n+                    final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        final double x = operand[operandOffset];\n+        function[0] = FastMath.asin(x);\n+        if (order > 0) {\n+            function[1] = 1.0 / FastMath.sqrt(1 - x * x);\n+            for (int i = 2; i <= order; ++i) {\n+                // TODO compute higher order derivatives\n+                function[i] = Double.NaN;\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute arc tangent of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * arc tangent the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void atan(final double[] operand, final int operandOffset,\n+                     final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        final double x = operand[operandOffset];\n+        function[0] = FastMath.atan(x);\n+        if (order > 0) {\n+            function[1] = 1.0 / (1 + x * x);\n+            for (int i = 2; i <= order; ++i) {\n+                // TODO compute higher order derivatives\n+                function[i] = Double.NaN;\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute two arguments arc tangent of a derivative structure.\n+     * @param y array holding the first operand\n+     * @param yOffset offset of the first operand in its array\n+     * @param x array holding the second operand\n+     * @param xOffset offset of the second operand in its array\n+     * @param result array where result must be stored (for\n+     * two arguments arc tangent the result array <em>cannot</em>\n+     * be the input array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void atan2(final double[] y, final int yOffset,\n+                      final double[] x, final int xOffset,\n+                      final double[] result, final int resultOffset) {\n+\n+        final double y0 = y[yOffset];\n+        final double x0 = x[xOffset];\n+        result[resultOffset] = FastMath.atan2(y0, x0);\n+        if (order > 0) {\n+            for (int i = 1; i <= order; ++i) {\n+                // TODO compute higher order derivatives\n+                result[resultOffset + i] = Double.NaN;\n+            }\n+        }\n+\n+    }\n+\n+    /** Compute composition of a derivative structure by a function.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param f array of value and derivatives of the function at\n+     * the current point (i.e. at {@code operand[operandOffset]}).\n+     * @param result array where result must be stored (for\n+     * composition the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void compose(final double[] operand, final int operandOffset, final double[] f,\n+                        final double[] result, final int resultOffset) {\n+        for (int i = 0; i < compIndirection.length; ++i) {\n+            final int[][] mappingI = compIndirection[i];\n+            double r = 0;\n+            for (int j = 0; j < mappingI.length; ++j) {\n+                final int[] mappingIJ = mappingI[j];\n+                double product = mappingIJ[0] * f[mappingIJ[1]];\n+                for (int k = 2; k < mappingIJ.length; ++k) {\n+                    product *= operand[operandOffset + mappingIJ[k]];\n+                }\n+                r += product;\n+            }\n+            result[resultOffset + i] = r;\n+        }\n+    }\n+\n+    /** Evaluate Taylor expansion a derivative structure.\n+     * @param ds array holding the derivative structure \n+     * @param dsOffset offset of the derivative structure in its array\n+     * @param offsets parameters offsets (dx, dy, ...)\n+     * @return value of the Taylor expansion at x+dx, y.dy, ...\n+     */\n+    public double taylor(final double[] ds, final int dsOffset, final double ... offsets) {\n+        // TODO\n+        return Double.NaN;\n+    }\n+\n+    /** Check rules set compatibility.\n+     * @param compiler other compiler to check against instance\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public void checkCompatibility(final DSCompiler compiler)\n+            throws DimensionMismatchException {\n+        if (parameters != compiler.parameters) {\n+            throw new DimensionMismatchException(parameters, compiler.parameters);\n+        }\n+        if (order != compiler.order) {\n+            throw new DimensionMismatchException(order, compiler.order);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math3.Field;\n+import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+\n+/** Class representing both the value and the differentials of a function.\n+ * <p>This class is the workhorse of the differentiation package.</p>\n+ * <p>This class is an implementation of the extension to Rall's\n+ * numbers described in Dan Kalman's paper <a\n+ * href=\"http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf\">Doubly\n+ * Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75,\n+ * no. 3, June 2002.</p>. Rall's numbers are an extension to the real numbers used\n+ * throughout mathematical expressions; they hold the derivative together with the\n+ * value of a function. Dan Kalman's derivative structures holds all partial derivatives\n+ * up to any specified order, with respect to any number of free variables. Rall's\n+ * number therefore can be seen as derivative structures for order one derivative and\n+ * one free variable, and real numbers can be seen as derivative structures with zero\n+ * order derivative and no free variables.</p>\n+ * <p>{@link DerivativeStructure} instances can be used directly thanks to\n+ * the arithmetic operators to the mathematical functions provided as static\n+ * methods by this class (+, -, *, /, %, sin, cos ...).</p>\n+ * <p>Implementing complex expressions by hand using these classes is\n+ * however a complex and error-prone task, so the classical use is\n+ * simply to develop computation code using standard primitive double\n+ * values and to use {@link UnivariateDifferentiator differentiators} to create\n+ * the {@link DerivativeStructure}-based instances.</p>\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @see DSCompiler\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class DerivativeStructure implements FieldElement<DerivativeStructure>, Serializable {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20120730L;\n+\n+    /** Compiler for the current dimensions. */\n+    private transient DSCompiler compiler;\n+\n+    /** Combined array holding all values. */\n+    private final double[] data;\n+\n+    /** Build an instance with all values and derivatives set to 0.\n+     * @param compiler compiler to use for computation\n+     */\n+    private DerivativeStructure(final DSCompiler compiler) {\n+        this.compiler = compiler;\n+        this.data     = new double[compiler.getSize()];\n+    }\n+\n+    /** Build an instance with all values and derivatives set to 0.\n+     * @param variables number of variables\n+     * @param order derivation order\n+     */\n+    public DerivativeStructure(final int variables, final int order) {\n+        this(DSCompiler.getCompiler(variables, order));\n+    }\n+\n+    /** Build an instance representing a constant value.\n+     * @param variables number of variables\n+     * @param order derivation order\n+     * @param value value of the constant\n+     * @see #DerivativeStructure(int, int, int, double)\n+     */\n+    public DerivativeStructure(final int variables, final int order, final double value) {\n+        this(variables, order);\n+        this.data[0] = value;\n+    }\n+\n+    /** Build an instance representing a variable.\n+     * <p>Instances built using this constructor are considered\n+     * to be the free variables with respect to which differentials\n+     * are computed. As such, their differential with respect to\n+     * themselves is +1.</p>\n+     * @param variables number of variables\n+     * @param order derivation order\n+     * @param index index of the variable (from 0 to {@code variables - 1})\n+     * @param value value of the variable\n+     * @exception NumberIsTooLargeException if index is equal to variables or larger\n+     * @see #DerivativeStructure(int, int, double)\n+     */\n+    public DerivativeStructure(final int variables, final int order,\n+                               final int index, final double value)\n+        throws NumberIsTooLargeException {\n+        this(variables, order, value);\n+\n+        if (index >= variables) {\n+            throw new NumberIsTooLargeException(index, variables, false);\n+        }\n+\n+        if (order > 0) {\n+            // the derivative of the variable with respect to itself is 1.0\n+            data[DSCompiler.getCompiler(index, order).getSize()] = 1.0;\n+        }\n+\n+    }\n+\n+    /** Linear combination constructor.\n+     * The derivative structure built will be a1 * ds1 + a2 * ds2\n+     * @param a1 first scale factor\n+     * @param ds1 first base (unscaled) derivative structure\n+     * @param a2 second scale factor\n+     * @param ds2 second base (unscaled) derivative structure\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure(final double a1, final DerivativeStructure ds1,\n+                               final double a2, final DerivativeStructure ds2)\n+        throws DimensionMismatchException {\n+        this(ds1.compiler);\n+        compiler.checkCompatibility(ds2.compiler);\n+        compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0, data, 0);\n+    }\n+\n+    /** Linear combination constructor.\n+     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3\n+     * @param a1 first scale factor\n+     * @param ds1 first base (unscaled) derivative structure\n+     * @param a2 second scale factor\n+     * @param ds2 second base (unscaled) derivative structure\n+     * @param a3 third scale factor\n+     * @param ds3 third base (unscaled) derivative structure\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure(final double a1, final DerivativeStructure ds1,\n+                               final double a2, final DerivativeStructure ds2,\n+                               final double a3, final DerivativeStructure ds3)\n+        throws DimensionMismatchException {\n+        this(ds1.compiler);\n+        compiler.checkCompatibility(ds2.compiler);\n+        compiler.checkCompatibility(ds3.compiler);\n+        compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0, a3, ds3.data, 0, data, 0);\n+    }\n+\n+    /** Linear combination constructor.\n+     * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4\n+     * @param a1 first scale factor\n+     * @param ds1 first base (unscaled) derivative structure\n+     * @param a2 second scale factor\n+     * @param ds2 second base (unscaled) derivative structure\n+     * @param a3 third scale factor\n+     * @param ds3 third base (unscaled) derivative structure\n+     * @param a4 fourth scale factor\n+     * @param ds4 fourth base (unscaled) derivative structure\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure(final double a1, final DerivativeStructure ds1,\n+                               final double a2, final DerivativeStructure ds2,\n+                               final double a3, final DerivativeStructure ds3,\n+                               final double a4, final DerivativeStructure ds4)\n+        throws DimensionMismatchException {\n+        this(ds1.compiler);\n+        compiler.checkCompatibility(ds2.compiler);\n+        compiler.checkCompatibility(ds3.compiler);\n+        compiler.checkCompatibility(ds4.compiler);\n+        compiler.linearCombination(a1, ds1.data, 0, a2, ds2.data, 0,\n+                                   a3, ds3.data, 0, a4, ds4.data, 0,\n+                                   data, 0);\n+    }\n+\n+    /** Copy constructor.\n+     * @param instance to copy\n+     */\n+    private DerivativeStructure(final DerivativeStructure ds) {\n+        this.compiler = ds.compiler;\n+        this.data     = ds.data.clone();\n+    }\n+\n+    /** Get the number of free parameters.\n+     * @return number of free parameters\n+     */\n+    public int getFreeParameters() {\n+        return compiler.getFreeParameters();\n+    }\n+\n+    /** Get the derivation order.\n+     * @return derivation order\n+     */\n+    public int getOrder() {\n+        return compiler.getOrder();\n+    }\n+\n+    /** Get the value part of the derivative structure.\n+     * @return value part of the derivative structure\n+     * @see #getPartialDerivative(int...)\n+     */\n+    public double getValue() {\n+        return data[0];\n+    }\n+\n+    /** Get a partial derivative.\n+     * @param orders derivation orders with respect to each variable (if all orders are 0,\n+     * the value is returned)\n+     * @return partial derivative\n+     * @see #getValue()\n+     * @exception DimensionMismatchException if the numbers of variables does not\n+     * match the instance\n+     * @exception NumberIsTooLargeException if sum of derivation orders is larger\n+     * than the instance limits\n+     */\n+    public double getPartialDerivative(final int ... orders)\n+        throws DimensionMismatchException, NumberIsTooLargeException {\n+        return data[compiler.getPartialDerivativeIndex(orders)];\n+    }\n+\n+    /** '+' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this+a\n+     */\n+    public DerivativeStructure add(final double a) {\n+        final DerivativeStructure ds = new DerivativeStructure(this);\n+        ds.data[0] += a;\n+        return ds;\n+    }\n+\n+    /** '+' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this+a\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure add(final DerivativeStructure a)\n+        throws DimensionMismatchException {\n+        compiler.checkCompatibility(a.compiler);\n+        final DerivativeStructure ds = new DerivativeStructure(this);\n+        compiler.add(data, 0, a.data, 0, ds.data, 0);\n+        return ds;\n+    }\n+\n+    /** '-' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this-a\n+     */\n+    public DerivativeStructure subtract(final double a) {\n+        return add(-a);\n+    }\n+\n+    /** '-' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this-a\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure subtract(final DerivativeStructure a)\n+        throws DimensionMismatchException {\n+        compiler.checkCompatibility(a.compiler);\n+        final DerivativeStructure ds = new DerivativeStructure(this);\n+        compiler.subtract(data, 0, a.data, 0, ds.data, 0);\n+        return ds;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure multiply(final int n) {\n+        return multiply((double) n);\n+    }\n+\n+    /** '&times;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&times;a\n+     */\n+    public DerivativeStructure multiply(final double a) {\n+        final DerivativeStructure ds = new DerivativeStructure(this);\n+        for (int i = 0; i < ds.data.length; ++i) {\n+            ds.data[i] *= a;\n+        }\n+        return ds;\n+    }\n+\n+    /** '&times;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&times;a\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure multiply(final DerivativeStructure a)\n+        throws DimensionMismatchException {\n+        compiler.checkCompatibility(a.compiler);\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.multiply(data, 0, a.data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** '&divides;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&divides;a\n+     */\n+    public DerivativeStructure divide(final double a) {\n+        final DerivativeStructure ds = new DerivativeStructure(this);\n+        for (int i = 0; i < ds.data.length; ++i) {\n+            ds.data[i] /= a;\n+        }\n+        return ds;\n+    }\n+\n+    /** '&divides;' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this&divides;a\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure divide(final DerivativeStructure a)\n+        throws DimensionMismatchException {\n+        compiler.checkCompatibility(a.compiler);\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.divide(data, 0, a.data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** '%' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this%a\n+     */\n+    public DerivativeStructure remainder(final double a) {\n+        final DerivativeStructure ds = new DerivativeStructure(this);\n+        ds.data[0] = ds.data[0] % a;\n+        return ds;\n+    }\n+\n+    /** '%' operator.\n+     * @param a right hand side parameter of the operator\n+     * @return this%a\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public DerivativeStructure remainder(final DerivativeStructure a)\n+        throws DimensionMismatchException {\n+        compiler.checkCompatibility(a.compiler);\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.remainder(data, 0, a.data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** unary '-' operator.\n+     * @return -this\n+     */\n+    public DerivativeStructure negate() {\n+        final DerivativeStructure ds = new DerivativeStructure(compiler);\n+        for (int i = 0; i < ds.data.length; ++i) {\n+            ds.data[i] = -data[i];\n+        }\n+        return ds;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DerivativeStructure reciprocal() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.pow(data, 0, -1, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Square root.\n+     * @return square root of the instance\n+     */\n+    public DerivativeStructure sqrt() {\n+        return rootN(2);\n+    }\n+\n+    /** Cubic root.\n+     * @return cubic root of the instance\n+     */\n+    public DerivativeStructure cbrt() {\n+        return rootN(3);\n+    }\n+\n+    /** N<sup>th</sup> root.\n+     * @param n order of the root\n+     * @return n<sup>th</sup> root of the instance\n+     */\n+    public DerivativeStructure rootN(final int n) {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.rootN(data, 0, n, result.data, 0);\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Field<DerivativeStructure> getField() {\n+        return new Field<DerivativeStructure>() {\n+\n+            /** {@inheritDoc} */\n+            public DerivativeStructure getZero() {\n+                return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 0.0);\n+            }\n+\n+            /** {@inheritDoc} */\n+            public DerivativeStructure getOne() {\n+                return new DerivativeStructure(compiler.getFreeParameters(), compiler.getOrder(), 1.0);\n+            }\n+\n+            /** {@inheritDoc} */\n+            public Class<? extends FieldElement<DerivativeStructure>> getRuntimeClass() {\n+                return DerivativeStructure.class;\n+            }\n+\n+        };\n+    }\n+\n+    /** Power operation.\n+     * @param p power to apply\n+     * @return this<sup>p</sup>\n+     */\n+    public DerivativeStructure pow(final double p) {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.pow(data, 0, p, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Integer power operation.\n+     * @param n power to apply\n+     * @return this<sup>n</sup>\n+     */\n+    public DerivativeStructure pow(final int n) {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.pow(data, 0, n, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Exponential.\n+     * @return exponential of the instance\n+     */\n+    public DerivativeStructure exp() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.exp(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Natural logarithm.\n+     * @return logarithm of the instance\n+     */\n+    public DerivativeStructure log() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.log(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Cosine operation.\n+     * @return cos(this)\n+     */\n+    public DerivativeStructure cos() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.cos(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Sine operation.\n+     * @return sin(this)\n+     */\n+    public DerivativeStructure sin() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.sin(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Tangent operation.\n+     * @return tan(this)\n+     */\n+    public DerivativeStructure tan() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.tan(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Arc cosine operation.\n+     * @return acos(this)\n+     */\n+    public DerivativeStructure acos() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.acos(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Arc sine operation.\n+     * @return asin(this)\n+     */\n+    public DerivativeStructure asin() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.asin(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Arc tangent operation.\n+     * @return tan(this)\n+     */\n+    public DerivativeStructure atan() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.atan(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Two arguments arc tangent operation.\n+     * @param y first argument of the arc tangent\n+     * @param x second argument of the arc tangent\n+     * @return atan2(y, x)\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x)\n+        throws DimensionMismatchException {\n+        y.compiler.checkCompatibility(x.compiler);\n+        final DerivativeStructure result = new DerivativeStructure(y.compiler);\n+        y.compiler.atan2(y.data, 0, x.data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Evaluate Taylor expansion a derivative structure.\n+     * @param offsets parameters offsets (dx, dy, ...)\n+     * @return value of the Taylor expansion at x+dx, y.dy, ...\n+     */\n+    public double taylor(final double ... offsets) {\n+        return compiler.taylor(data, 0, offsets);\n+    }\n+\n+    /**\n+     * Replace the instance with a data transfer object for serialization.\n+     * @return data transfer object that will be serialized\n+     */\n+    private Object writeReplace() {\n+        return new DataTransferObject(compiler.getFreeParameters(), compiler.getOrder(), data);\n+    }\n+\n+    /** Internal class used only for serialization. */\n+    private static class DataTransferObject implements Serializable {\n+\n+        /** Serializable UID. */\n+        private static final long serialVersionUID = 20120730L;\n+\n+        /** Number of variables.\n+         * @Serial\n+         */\n+        private final int variables;\n+\n+        /** Derivation order.\n+         * @Serial\n+         */\n+        private final int order;\n+\n+        /** Partial derivatives.\n+         * @Serial\n+         */\n+        private final double[] data;\n+\n+        /** Simple constructor.\n+         * @param variables number of variables\n+         * @param order derivation order\n+         * @param data partial derivatives\n+         */\n+        public DataTransferObject(final int variables, final int order, final double[] data) {\n+            this.variables = variables;\n+            this.order     = order;\n+            this.data      = data;\n+        }\n+\n+        /** Replace the deserialized data transfer object with a {@link DerivativeStructure}.\n+         * @return replacement {@link DerivativeStructure}\n+         */\n+        private Object readResolve() {\n+            final DerivativeStructure ds = new DerivativeStructure(variables, order);\n+            System.arraycopy(data, 0, ds.data, 0, ds.data.length);\n+            return ds;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateDifferential.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+\n+/** Interface for univariate functions derivatives.\n+ * <p>This interface represents a simple function which computes\n+ * both the value and the first derivative of a mathematical function.\n+ * The derivative is computed with respect to the input variable.</p>\n+ * @see UnivariateDifferentiable\n+ * @see UnivariateDifferentiator\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public interface UnivariateDifferential {\n+\n+    /** Get the primitive function associated with this differential.\n+     * <p>Each {@link UnivariateDifferential} instance is tightly bound\n+     * to an {@link UnivariateDifferentiable} instance. If the state of\n+     * the primitive instance changes in any way that affects the\n+     * differential computation, this binding allows this change to\n+     * be immediately seen by the derivative instance, there is no need\n+     * to differentiate the primitive again. The existing instance is aware\n+     * of the primitive changes.</p>\n+     * <p>In other words in the following code snippet, the three values\n+     * f1, f2 and f3 should be equal (at least at machine tolerance level)</p>\n+     * <pre>\n+     *    UnivariateDifferential derivative = differentiator.differentiate(derivable);\n+     *    derivable.someFunctionThatMutatesHeavilyTheInstance();\n+     *    double f1 = derivable.f(t);\n+     *    double f2 = derivative.getPrimitive().f(t);\n+     *    double f3 = derivative.f(new DerivativeStructure(variables, order, index, t)).getValue();\n+     * </pre>\n+     * @return primitive function bound to this derivative\n+     */\n+    UnivariateFunction getPrimitive();\n+\n+    /** Simple mathematical function.\n+     * <p>{@link UnivariateDifferential} classes compute both the\n+     * value and the first derivative of the function.</p>\n+     * @param t function input value\n+     * @return function result\n+     */\n+    DerivativeStructure f(DerivativeStructure t);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+\n+/** Interface defining the function differentiation operation.\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public interface UnivariateDifferentiator {\n+\n+    /** Create an implementation of a differential for a\n+     * {@link UnivariateDifferentiable differentiable function}.\n+     * @param function function to differentiate\n+     * @return differential function\n+     */\n+    UnivariateDifferential differentiate(UnivariateFunction function);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ *\n+ * <p>\n+ *   This package holds the main interfaces and basic building block classes\n+ *   dealing with differentiation.\n+ *   The core class is {@link DerivativeStructure} which holds the value and\n+ *   the differentials of a function. This class handles some arbitrary number\n+ *   of free parameters and arbitrary derivation order. It is used both as\n+ *   the input and the output type for the {@link UnivariateDifferential}\n+ *   interface. Any differentiable function should implement this interface.\n+ * </p>\n+ * <p>\n+ *   The {@link UnivariateDifferentiator} interface defines a way to differentation\n+ *   a simple {@link org.apache.commons.math3.analysis.UnivariateFunction\n+ *   univariate function} and get a {@link differential function}.\n+ * </p>\n+ *\n+ */\n+package org.apache.commons.math3.analysis.differentiation;\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n package org.apache.commons.math3.util;\n \n import java.io.PrintStream;\n+\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n  * Faster, more accurate, portable alternative to {@link Math} and\n             /* Normalize the subnormal number. */\n             bits <<= 1;\n             while ( (bits & 0x0010000000000000L) == 0) {\n-                --exp;\n+                exp--;\n                 bits <<= 1;\n             }\n         }\n                 xa = aa;\n                 xb = ab;\n \n-                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n-                double ya = lnCoef_last[0];\n-                double yb = lnCoef_last[1];\n+                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n+                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n \n                 for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                     /* Multiply a = y * x */\n                     yb = aa - ya + ab;\n \n                     /* Add  a = y + lnQuickCoef */\n-                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n-                    aa = ya + lnCoef_i[0];\n-                    ab = yb + lnCoef_i[1];\n+                    aa = ya + LN_QUICK_COEF[i][0];\n+                    ab = yb + LN_QUICK_COEF[i][1];\n                     /* Split y = a */\n                     tmp = aa * HEX_40000000;\n                     ya = aa + tmp - tmp;\n         }\n \n         // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n-        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n+        double lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n \n         /*\n     double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n         // y is the most significant 10 bits of the mantissa\n         //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n         //double epsilon = (x - y) / y;\n-        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n+        double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n \n         double lnza = 0.0;\n         double lnzb = 0.0;\n             double xb = ab;\n \n             /* Need a more accurate epsilon, so adjust the division. */\n-            final double numer = bits & 0x3ffffffffffL;\n-            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n+            double numer = bits & 0x3ffffffffffL;\n+            double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n             aa = numer - xa*denom - xb * denom;\n             xb += aa / denom;\n \n             /* Remez polynomial evaluation */\n-            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n-            double ya = lnCoef_last[0];\n-            double yb = lnCoef_last[1];\n+            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n+            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n \n             for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                 /* Multiply a = y * x */\n                 yb = aa - ya + ab;\n \n                 /* Add  a = y + lnHiPrecCoef */\n-                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n-                aa = ya + lnCoef_i[0];\n-                ab = yb + lnCoef_i[1];\n+                aa = ya + LN_HI_PREC_COEF[i][0];\n+                ab = yb + LN_HI_PREC_COEF[i][1];\n                 /* Split y = a */\n                 tmp = aa * HEX_40000000;\n                 ya = aa + tmp - tmp;\n         return result;\n     }\n \n+\n+    /**\n+     * Raise a double to an int power.\n+     *\n+     * @param d Number to raise.\n+     * @param e Exponent.\n+     * @return d<sup>e</sup>\n+     */\n+    public static double pow(double d, int e) {\n+        if (e == 0) {\n+            return 1.0;\n+        } else if (e < 0) {\n+            e = -e;\n+            d = 1.0 / d;\n+        }\n+\n+        double result = 1;\n+        double d2p    = d;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= d2p;\n+            }\n+            d2p *= d2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+    }\n \n     /**\n      *  Computes sin(x) - x, where |x| < 1/16.\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DSCompilerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.math3.util.ArithmeticUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+/**\n+ * Test for class {@link DSCompiler}.\n+ */\n+public class DSCompilerTest {\n+\n+    @Test\n+    public void testSize() {\n+        for (int i = 0; i < 6; ++i) {\n+            for (int j = 0; j < 6; ++j) {\n+                long expected = ArithmeticUtils.binomialCoefficient(i + j, i);\n+                Assert.assertEquals(expected, DSCompiler.getCompiler(i, j).getSize());\n+                Assert.assertEquals(expected, DSCompiler.getCompiler(j, i).getSize());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testIndices() {\n+\n+        DSCompiler c = DSCompiler.getCompiler(0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(0), new int[0]);\n+\n+        c = DSCompiler.getCompiler(0, 1);\n+        checkIndices(c.getPartialDerivativeOrders(0), new int[0]);\n+\n+        c = DSCompiler.getCompiler(1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0);\n+\n+        c = DSCompiler.getCompiler(1, 1);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1);\n+\n+        c = DSCompiler.getCompiler(1, 2);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1);\n+        checkIndices(c.getPartialDerivativeOrders(2), 2);\n+\n+        c = DSCompiler.getCompiler(2, 1);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(2), 0, 1);\n+\n+        c = DSCompiler.getCompiler(1, 3);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1);\n+        checkIndices(c.getPartialDerivativeOrders(2), 2);\n+        checkIndices(c.getPartialDerivativeOrders(3), 3);\n+\n+        c = DSCompiler.getCompiler(2, 2);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(2), 2, 0);\n+        checkIndices(c.getPartialDerivativeOrders(3), 0, 1);\n+        checkIndices(c.getPartialDerivativeOrders(4), 1, 1);\n+        checkIndices(c.getPartialDerivativeOrders(5), 0, 2);\n+\n+        c = DSCompiler.getCompiler(3, 1);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(2), 0, 1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(3), 0, 0, 1);\n+\n+        c = DSCompiler.getCompiler(1, 4);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1);\n+        checkIndices(c.getPartialDerivativeOrders(2), 2);\n+        checkIndices(c.getPartialDerivativeOrders(3), 3);\n+        checkIndices(c.getPartialDerivativeOrders(4), 4);\n+\n+        c = DSCompiler.getCompiler(2, 3);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(2), 2, 0);\n+        checkIndices(c.getPartialDerivativeOrders(3), 3, 0);\n+        checkIndices(c.getPartialDerivativeOrders(4), 0, 1);\n+        checkIndices(c.getPartialDerivativeOrders(5), 1, 1);\n+        checkIndices(c.getPartialDerivativeOrders(6), 2, 1);\n+        checkIndices(c.getPartialDerivativeOrders(7), 0, 2);\n+        checkIndices(c.getPartialDerivativeOrders(8), 1, 2);\n+        checkIndices(c.getPartialDerivativeOrders(9), 0, 3);\n+\n+        c = DSCompiler.getCompiler(3, 2);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(2), 2, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(3), 0, 1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(4), 1, 1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(5), 0, 2, 0);\n+        checkIndices(c.getPartialDerivativeOrders(6), 0, 0, 1);\n+        checkIndices(c.getPartialDerivativeOrders(7), 1, 0, 1);\n+        checkIndices(c.getPartialDerivativeOrders(8), 0, 1, 1);\n+        checkIndices(c.getPartialDerivativeOrders(9), 0, 0, 2);\n+\n+        c = DSCompiler.getCompiler(4, 1);\n+        checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(2), 0, 1, 0, 0);\n+        checkIndices(c.getPartialDerivativeOrders(3), 0, 0, 1, 0);\n+        checkIndices(c.getPartialDerivativeOrders(4), 0, 0, 0, 1);\n+\n+    }\n+\n+    @Test\n+    public void testSymmetry() {\n+        for (int i = 0; i < 6; ++i) {\n+            for (int j = 0; j < 6; ++j) {\n+                DSCompiler c = DSCompiler.getCompiler(i, j);\n+                for (int k = 0; k < c.getSize(); ++k) {\n+                    Assert.assertEquals(k, c.getPartialDerivativeIndex(c.getPartialDerivativeOrders(k)));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test public void testMultiplicationRules()\n+        throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {\n+\n+        Map<String,String> referenceRules = new HashMap<String, String>();\n+        referenceRules.put(\"(f*g)\",          \"f * g\");\n+        referenceRules.put(\"d(f*g)/dx\",      \"f * dg/dx + df/dx * g\");\n+        referenceRules.put(\"d(f*g)/dy\",      referenceRules.get(\"d(f*g)/dx\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d(f*g)/dz\",      referenceRules.get(\"d(f*g)/dx\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d(f*g)/dt\",      referenceRules.get(\"d(f*g)/dx\").replaceAll(\"x\", \"t\"));\n+        referenceRules.put(\"d2(f*g)/dx2\",    \"f * d2g/dx2 + 2 * df/dx * dg/dx + d2f/dx2 * g\");\n+        referenceRules.put(\"d2(f*g)/dy2\",    referenceRules.get(\"d2(f*g)/dx2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d2(f*g)/dz2\",    referenceRules.get(\"d2(f*g)/dx2\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d2(f*g)/dt2\",    referenceRules.get(\"d2(f*g)/dx2\").replaceAll(\"x\", \"t\"));\n+        referenceRules.put(\"d2(f*g)/dxdy\",   \"f * d2g/dxdy + df/dy * dg/dx + df/dx * dg/dy + d2f/dxdy * g\");\n+        referenceRules.put(\"d2(f*g)/dxdz\",   referenceRules.get(\"d2(f*g)/dxdy\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d2(f*g)/dxdt\",   referenceRules.get(\"d2(f*g)/dxdy\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d2(f*g)/dydz\",   referenceRules.get(\"d2(f*g)/dxdz\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d2(f*g)/dydt\",   referenceRules.get(\"d2(f*g)/dxdt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d2(f*g)/dzdt\",   referenceRules.get(\"d2(f*g)/dxdt\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f*g)/dx3\",    \"f * d3g/dx3 +\" +\n+                                             \" 3 * df/dx * d2g/dx2 +\" +\n+                                             \" 3 * d2f/dx2 * dg/dx +\" +\n+                                             \" d3f/dx3 * g\");\n+        referenceRules.put(\"d3(f*g)/dy3\",   referenceRules.get(\"d3(f*g)/dx3\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f*g)/dz3\",   referenceRules.get(\"d3(f*g)/dx3\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f*g)/dt3\",   referenceRules.get(\"d3(f*g)/dx3\").replaceAll(\"x\", \"t\"));\n+        referenceRules.put(\"d3(f*g)/dx2dy\",  \"f * d3g/dx2dy +\" +\n+                                             \" df/dy * d2g/dx2 +\" +\n+                                             \" 2 * df/dx * d2g/dxdy +\" +\n+                                             \" 2 * d2f/dxdy * dg/dx +\" +\n+                                             \" d2f/dx2 * dg/dy +\" +\n+                                             \" d3f/dx2dy * g\");\n+        referenceRules.put(\"d3(f*g)/dxdy2\",  \"f * d3g/dxdy2 +\" +\n+                                             \" 2 * df/dy * d2g/dxdy +\" +\n+                                             \" d2f/dy2 * dg/dx +\" +\n+                                             \" df/dx * d2g/dy2 +\" +\n+                                             \" 2 * d2f/dxdy * dg/dy +\" +\n+                                             \" d3f/dxdy2 * g\");\n+        referenceRules.put(\"d3(f*g)/dx2dz\",   referenceRules.get(\"d3(f*g)/dx2dy\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d3(f*g)/dy2dz\",   referenceRules.get(\"d3(f*g)/dx2dz\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f*g)/dxdz2\",   referenceRules.get(\"d3(f*g)/dxdy2\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d3(f*g)/dydz2\",   referenceRules.get(\"d3(f*g)/dxdz2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f*g)/dx2dt\",   referenceRules.get(\"d3(f*g)/dx2dz\").replaceAll(\"z\", \"t\"));\n+        referenceRules.put(\"d3(f*g)/dy2dt\",   referenceRules.get(\"d3(f*g)/dx2dt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f*g)/dz2dt\",   referenceRules.get(\"d3(f*g)/dx2dt\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f*g)/dxdt2\",   referenceRules.get(\"d3(f*g)/dxdy2\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d3(f*g)/dydt2\",   referenceRules.get(\"d3(f*g)/dxdt2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f*g)/dzdt2\",   referenceRules.get(\"d3(f*g)/dxdt2\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f*g)/dxdydz\", \"f * d3g/dxdydz +\" +\n+                                             \" df/dz * d2g/dxdy +\" +\n+                                             \" df/dy * d2g/dxdz +\" +\n+                                             \" d2f/dydz * dg/dx +\" +\n+                                             \" df/dx * d2g/dydz +\" +\n+                                             \" d2f/dxdz * dg/dy +\" +\n+                                             \" d2f/dxdy * dg/dz +\" +\n+                                             \" d3f/dxdydz * g\");\n+        referenceRules.put(\"d3(f*g)/dxdydt\", referenceRules.get(\"d3(f*g)/dxdydz\").replaceAll(\"z\", \"t\"));\n+        referenceRules.put(\"d3(f*g)/dxdzdt\", referenceRules.get(\"d3(f*g)/dxdydt\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d3(f*g)/dydzdt\", referenceRules.get(\"d3(f*g)/dxdzdt\").replaceAll(\"x\", \"y\"));\n+\n+        Field multFieldArrayField = DSCompiler.class.getDeclaredField(\"multIndirection\");\n+        multFieldArrayField.setAccessible(true);\n+        for (int i = 0; i < 5; ++i) {\n+            for (int j = 0; j < 4; ++j) {\n+                DSCompiler compiler = DSCompiler.getCompiler(i, j);\n+                int[][][] multIndirection = (int[][][]) multFieldArrayField.get(compiler);\n+                for (int k = 0; k < multIndirection.length; ++k) {\n+                    String product = ordersToString(compiler.getPartialDerivativeOrders(k),\n+                                                    \"(f*g)\", \"x\", \"y\", \"z\", \"t\");\n+                    StringBuilder rule = new StringBuilder();\n+                    for (int[] term : multIndirection[k]) {\n+                        if (rule.length() > 0) {\n+                            rule.append(\" + \");\n+                        }\n+                        if (term[0] > 1) {\n+                            rule.append(term[0]).append(\" * \");\n+                        }\n+                        rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[1]),\n+                                                   \"f\", \"x\", \"y\", \"z\", \"t\"));\n+                        rule.append(\" * \");\n+                        rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[2]),\n+                                                   \"g\", \"x\", \"y\", \"z\", \"t\"));\n+                    }\n+                    Assert.assertEquals(product, referenceRules.get(product), rule.toString());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test public void testCompositionRules()\n+        throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {\n+\n+        // the following reference rules have all been computed independently from the library,\n+        // using only pencil and paper and some search and replace to handle symmetries\n+        Map<String,String> referenceRules = new HashMap<String, String>();\n+        referenceRules.put(\"(f(g))\",              \"(f(g))\");\n+        referenceRules.put(\"d(f(g))/dx\",          \"d(f(g))/dg * dg/dx\");\n+        referenceRules.put(\"d(f(g))/dy\",          referenceRules.get(\"d(f(g))/dx\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d(f(g))/dz\",          referenceRules.get(\"d(f(g))/dx\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d(f(g))/dt\",          referenceRules.get(\"d(f(g))/dx\").replaceAll(\"x\", \"t\"));\n+        referenceRules.put(\"d2(f(g))/dx2\",        \"d2(f(g))/dg2 * dg/dx * dg/dx + d(f(g))/dg * d2g/dx2\");\n+        referenceRules.put(\"d2(f(g))/dy2\",        referenceRules.get(\"d2(f(g))/dx2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d2(f(g))/dz2\",        referenceRules.get(\"d2(f(g))/dx2\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d2(f(g))/dt2\",        referenceRules.get(\"d2(f(g))/dx2\").replaceAll(\"x\", \"t\"));\n+        referenceRules.put(\"d2(f(g))/dxdy\",       \"d2(f(g))/dg2 * dg/dx * dg/dy + d(f(g))/dg * d2g/dxdy\");\n+        referenceRules.put(\"d2(f(g))/dxdz\",       referenceRules.get(\"d2(f(g))/dxdy\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d2(f(g))/dxdt\",       referenceRules.get(\"d2(f(g))/dxdy\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d2(f(g))/dydz\",       referenceRules.get(\"d2(f(g))/dxdz\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d2(f(g))/dydt\",       referenceRules.get(\"d2(f(g))/dxdt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d2(f(g))/dzdt\",       referenceRules.get(\"d2(f(g))/dxdt\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f(g))/dx3\",        \"d3(f(g))/dg3 * dg/dx * dg/dx * dg/dx +\" +\n+                                                  \" 3 * d2(f(g))/dg2 * dg/dx * d2g/dx2 +\" +\n+                                                  \" d(f(g))/dg * d3g/dx3\");\n+        referenceRules.put(\"d3(f(g))/dy3\",        referenceRules.get(\"d3(f(g))/dx3\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f(g))/dz3\",        referenceRules.get(\"d3(f(g))/dx3\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f(g))/dt3\",        referenceRules.get(\"d3(f(g))/dx3\").replaceAll(\"x\", \"t\"));\n+        referenceRules.put(\"d3(f(g))/dxdy2\",      \"d3(f(g))/dg3 * dg/dx * dg/dy * dg/dy +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * dg/dy * d2g/dxdy +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dx * d2g/dy2 +\" +\n+                                                  \" d(f(g))/dg * d3g/dxdy2\");\n+        referenceRules.put(\"d3(f(g))/dxdz2\",      referenceRules.get(\"d3(f(g))/dxdy2\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d3(f(g))/dxdt2\",      referenceRules.get(\"d3(f(g))/dxdy2\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d3(f(g))/dydz2\",      referenceRules.get(\"d3(f(g))/dxdz2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f(g))/dydt2\",      referenceRules.get(\"d3(f(g))/dxdt2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f(g))/dzdt2\",      referenceRules.get(\"d3(f(g))/dxdt2\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f(g))/dx2dy\",      \"d3(f(g))/dg3 * dg/dx * dg/dx * dg/dy +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * dg/dx * d2g/dxdy +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dx2 * dg/dy +\" +\n+                                                  \" d(f(g))/dg * d3g/dx2dy\");\n+        referenceRules.put(\"d3(f(g))/dx2dz\",      referenceRules.get(\"d3(f(g))/dx2dy\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d3(f(g))/dx2dt\",      referenceRules.get(\"d3(f(g))/dx2dy\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d3(f(g))/dy2dz\",      referenceRules.get(\"d3(f(g))/dx2dz\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f(g))/dy2dt\",      referenceRules.get(\"d3(f(g))/dx2dt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d3(f(g))/dz2dt\",      referenceRules.get(\"d3(f(g))/dx2dt\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d3(f(g))/dxdydz\",     \"d3(f(g))/dg3 * dg/dx * dg/dy * dg/dz +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dy * d2g/dxdz +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dx * d2g/dydz +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dxdy * dg/dz +\" +\n+                                                  \" d(f(g))/dg * d3g/dxdydz\");\n+        referenceRules.put(\"d3(f(g))/dxdydt\",     referenceRules.get(\"d3(f(g))/dxdydz\").replaceAll(\"z\", \"t\"));\n+        referenceRules.put(\"d3(f(g))/dxdzdt\",     referenceRules.get(\"d3(f(g))/dxdydt\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d3(f(g))/dydzdt\",     referenceRules.get(\"d3(f(g))/dxdzdt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dx4\",        \"d4(f(g))/dg4 * dg/dx * dg/dx * dg/dx * dg/dx +\" +\n+                                                  \" 6 * d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dx2 +\" +\n+                                                  \" 3 * d2(f(g))/dg2 * d2g/dx2 * d2g/dx2 +\" +\n+                                                  \" 4 * d2(f(g))/dg2 * dg/dx * d3g/dx3 +\" +\n+                                                  \" d(f(g))/dg * d4g/dx4\");\n+        referenceRules.put(\"d4(f(g))/dy4\",        referenceRules.get(\"d4(f(g))/dx4\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dz4\",        referenceRules.get(\"d4(f(g))/dx4\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dt4\",        referenceRules.get(\"d4(f(g))/dx4\").replaceAll(\"x\", \"t\"));\n+        referenceRules.put(\"d4(f(g))/dx3dy\",      \"d4(f(g))/dg4 * dg/dx * dg/dx * dg/dx * dg/dy +\" +\n+                                                  \" 3 * d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dxdy +\" +\n+                                                  \" 3 * d3(f(g))/dg3 * dg/dx * d2g/dx2 * dg/dy +\" +\n+                                                  \" 3 * d2(f(g))/dg2 * d2g/dx2 * d2g/dxdy +\" +\n+                                                  \" 3 * d2(f(g))/dg2 * dg/dx * d3g/dx2dy +\" +\n+                                                  \" d2(f(g))/dg2 * d3g/dx3 * dg/dy +\" +\n+                                                  \" d(f(g))/dg * d4g/dx3dy\");\n+        referenceRules.put(\"d4(f(g))/dx3dz\",      referenceRules.get(\"d4(f(g))/dx3dy\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dx3dt\",      referenceRules.get(\"d4(f(g))/dx3dy\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d4(f(g))/dxdy3\",      \"d4(f(g))/dg4 * dg/dx * dg/dy * dg/dy * dg/dy +\" +\n+                                                  \" 3 * d3(f(g))/dg3 * dg/dy * dg/dy * d2g/dxdy +\" +\n+                                                  \" 3 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dy2 +\" +\n+                                                  \" 3 * d2(f(g))/dg2 * d2g/dxdy * d2g/dy2 +\" +\n+                                                  \" 3 * d2(f(g))/dg2 * dg/dy * d3g/dxdy2 +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dx * d3g/dy3 +\" +\n+                                                  \" d(f(g))/dg * d4g/dxdy3\");\n+        referenceRules.put(\"d4(f(g))/dxdz3\",      referenceRules.get(\"d4(f(g))/dxdy3\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dxdt3\",      referenceRules.get(\"d4(f(g))/dxdy3\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d4(f(g))/dy3dz\",      referenceRules.get(\"d4(f(g))/dx3dz\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dy3dt\",      referenceRules.get(\"d4(f(g))/dx3dt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dydz3\",      referenceRules.get(\"d4(f(g))/dxdz3\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dydt3\",      referenceRules.get(\"d4(f(g))/dxdt3\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dz3dt\",      referenceRules.get(\"d4(f(g))/dx3dt\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dzdt3\",      referenceRules.get(\"d4(f(g))/dxdt3\").replaceAll(\"x\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dx2dy2\",     \"d4(f(g))/dg4 * dg/dx * dg/dx * dg/dy * dg/dy +\" +\n+                                                  \" 4 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dxdy +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dy2 +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dxdy +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * dg/dx * d3g/dxdy2 +\" +\n+                                                  \" d3(f(g))/dg3 * d2g/dx2 * dg/dy * dg/dy +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * dg/dy * d3g/dx2dy +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dx2 * d2g/dy2 +\" +\n+                                                  \" d(f(g))/dg * d4g/dx2dy2\");\n+        referenceRules.put(\"d4(f(g))/dx2dz2\",     referenceRules.get(\"d4(f(g))/dx2dy2\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dx2dt2\",     referenceRules.get(\"d4(f(g))/dx2dy2\").replaceAll(\"y\", \"t\"));\n+        referenceRules.put(\"d4(f(g))/dy2dz2\",     referenceRules.get(\"d4(f(g))/dx2dz2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dy2dt2\",     referenceRules.get(\"d4(f(g))/dx2dt2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dz2dt2\",     referenceRules.get(\"d4(f(g))/dx2dt2\").replaceAll(\"x\", \"z\"));\n+\n+        referenceRules.put(\"d4(f(g))/dx2dydz\",    \"d4(f(g))/dg4 * dg/dx * dg/dx * dg/dy * dg/dz +\" +\n+                                                  \" 2 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dxdz +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dydz +\" +\n+                                                  \" 2 * d3(f(g))/dg3 * dg/dx * d2g/dxdy * dg/dz +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dxdz +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * dg/dx * d3g/dxdydz +\" +\n+                                                  \" d3(f(g))/dg3 * d2g/dx2 * dg/dy * dg/dz +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dy * d3g/dx2dz +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dx2 * d2g/dydz +\" +\n+                                                  \" d2(f(g))/dg2 * d3g/dx2dy * dg/dz +\" +\n+                                                  \" d(f(g))/dg * d4g/dx2dydz\");\n+        referenceRules.put(\"d4(f(g))/dx2dydt\",    referenceRules.get(\"d4(f(g))/dx2dydz\").replaceAll(\"z\", \"t\"));\n+        referenceRules.put(\"d4(f(g))/dx2dzdt\",    referenceRules.get(\"d4(f(g))/dx2dydt\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dxdy2dz\",    \"d4(f(g))/dg4 * dg/dx * dg/dy * dg/dy * dg/dz +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dy * dg/dy * d2g/dxdz +\" +\n+                                                  \" 2 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dydz +\" +\n+                                                  \" 2 * d3(f(g))/dg3 * dg/dy * d2g/dxdy * dg/dz +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dydz +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * dg/dy * d3g/dxdydz +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dx * d2g/dy2 * dg/dz +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dy2 * d2g/dxdz +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dx * d3g/dy2dz +\" +\n+                                                  \" d2(f(g))/dg2 * d3g/dxdy2 * dg/dz +\" +\n+                                                  \" d(f(g))/dg * d4g/dxdy2dz\");\n+        referenceRules.put(\"d4(f(g))/dxdy2dt\",    referenceRules.get(\"d4(f(g))/dxdy2dz\").replaceAll(\"z\", \"t\"));\n+        referenceRules.put(\"d4(f(g))/dy2dzdt\",    referenceRules.get(\"d4(f(g))/dx2dzdt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dxdydz2\",    \"d4(f(g))/dg4 * dg/dx * dg/dy * dg/dz * dg/dz +\" +\n+                                                  \" 2 * d3(f(g))/dg3 * dg/dy * dg/dz * d2g/dxdz +\" +\n+                                                  \" 2 * d3(f(g))/dg3 * dg/dx * dg/dz * d2g/dydz +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dz2 +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * d2g/dxdz * d2g/dydz +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dy * d3g/dxdz2 +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dx * d3g/dydz2 +\" +\n+                                                  \" d3(f(g))/dg3 * d2g/dxdy * dg/dz * dg/dz +\" +\n+                                                  \" 2 * d2(f(g))/dg2 * dg/dz * d3g/dxdydz +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dxdy * d2g/dz2 +\" +\n+                                                  \" d(f(g))/dg * d4g/dxdydz2\");\n+        referenceRules.put(\"d4(f(g))/dxdz2dt\",    referenceRules.get(\"d4(f(g))/dxdy2dt\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dydz2dt\",    referenceRules.get(\"d4(f(g))/dxdz2dt\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dxdydt2\",    referenceRules.get(\"d4(f(g))/dxdydz2\").replaceAll(\"z\", \"t\"));\n+        referenceRules.put(\"d4(f(g))/dxdzdt2\",    referenceRules.get(\"d4(f(g))/dxdydt2\").replaceAll(\"y\", \"z\"));\n+        referenceRules.put(\"d4(f(g))/dydzdt2\",    referenceRules.get(\"d4(f(g))/dxdzdt2\").replaceAll(\"x\", \"y\"));\n+        referenceRules.put(\"d4(f(g))/dxdydzdt\",   \"d4(f(g))/dg4 * dg/dx * dg/dy * dg/dz * dg/dt +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dy * dg/dz * d2g/dxdt +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dx * dg/dz * d2g/dydt +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dzdt +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dy * d2g/dxdz * dg/dt +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dxdz * d2g/dydt +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dy * d3g/dxdzdt +\" +\n+                                                  \" d3(f(g))/dg3 * dg/dx * d2g/dydz * dg/dt +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dydz * d2g/dxdt +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dx * d3g/dydzdt +\" +\n+                                                  \" d3(f(g))/dg3 * d2g/dxdy * dg/dz * dg/dt +\" +\n+                                                  \" d2(f(g))/dg2 * dg/dz * d3g/dxdydt +\" +\n+                                                  \" d2(f(g))/dg2 * d2g/dxdy * d2g/dzdt +\" +\n+                                                  \" d2(f(g))/dg2 * d3g/dxdydz * dg/dt +\" +\n+                                                  \" d(f(g))/dg * d4g/dxdydzdt\");\n+\n+        Field compFieldArrayField = DSCompiler.class.getDeclaredField(\"compIndirection\");\n+        compFieldArrayField.setAccessible(true);\n+        for (int i = 0; i < 5; ++i) {\n+            for (int j = 0; j < 5; ++j) {\n+                DSCompiler compiler = DSCompiler.getCompiler(i, j);\n+                int[][][] compIndirection = (int[][][]) compFieldArrayField.get(compiler);\n+                for (int k = 0; k < compIndirection.length; ++k) {\n+                    String product = ordersToString(compiler.getPartialDerivativeOrders(k),\n+                                                    \"(f(g))\", \"x\", \"y\", \"z\", \"t\");\n+                    StringBuilder rule = new StringBuilder();\n+                    for (int[] term : compIndirection[k]) {\n+                        if (rule.length() > 0) {\n+                            rule.append(\" + \");\n+                        }\n+                        if (term[0] > 1) {\n+                            rule.append(term[0]).append(\" * \");\n+                        }\n+                        rule.append(orderToString(term[1], \"(f(g))\", \"g\"));\n+                        for (int l = 2; l < term.length; ++l) {\n+                            rule.append(\" * \");\n+                            rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[l]),\n+                                                       \"g\", \"x\", \"y\", \"z\", \"t\"));\n+                        }\n+                    }\n+                    Assert.assertEquals(product, referenceRules.get(product), rule.toString());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void checkIndices(int[] indices, int ... expected) {\n+        Assert.assertEquals(expected.length, indices.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            Assert.assertEquals(expected[i], indices[i]);\n+        }\n+    }\n+\n+    private String orderToString(int order, String functionName, String parameterName) {\n+        if (order == 0) {\n+            return functionName;\n+        } else if (order == 1) {\n+            return \"d\" + functionName + \"/d\" + parameterName;\n+        } else {\n+            return \"d\" + order + functionName + \"/d\" + parameterName + order;\n+        }\n+    }\n+\n+    private String ordersToString(int[] orders, String functionName, String ... parametersNames) {\n+\n+        int sumOrders = 0;\n+        for (int order : orders) {\n+            sumOrders += order;\n+        }\n+\n+        if (sumOrders == 0) {\n+            return functionName;\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        builder.append('d');\n+        if (sumOrders > 1) {\n+            builder.append(sumOrders);\n+        }\n+        builder.append(functionName).append('/');\n+        for (int i = 0; i < orders.length; ++i) {\n+            if (orders[i] > 0) {\n+                builder.append('d').append(parametersNames[i]);\n+                if (orders[i] > 1) {\n+                    builder.append(orders[i]);\n+                }\n+            }\n+        }\n+        return builder.toString();\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.util.ArithmeticUtils;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for class {@link DerivativeStructure}.\n+ */\n+public class DerivativeStructureTest {\n+\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testWrongVariableIndex() {\n+        new DerivativeStructure(3, 1, 3, 1.0);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testMissingOrders() {\n+        new DerivativeStructure(3, 1, 0, 1.0).getPartialDerivative(0, 1);\n+    }\n+\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testTooLargeOrder() {\n+        new DerivativeStructure(3, 1, 0, 1.0).getPartialDerivative(1, 1, 2);\n+    }\n+\n+    @Test\n+    public void testVariableWithoutDerivative0() {\n+        DerivativeStructure v = new DerivativeStructure(1, 0, 0, 1.0);\n+        Assert.assertEquals(1.0, v.getValue(), 1.0e-15);\n+    }\n+\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testVariableWithoutDerivative1() {\n+        DerivativeStructure v = new DerivativeStructure(1, 0, 0, 1.0);\n+        Assert.assertEquals(1.0, v.getPartialDerivative(1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testVariable() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0),\n+                      1.0, 1.0, 0.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0),\n+                      2.0, 0.0, 1.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0),\n+                      3.0, 0.0, 0.0, 1.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testConstant() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            checkF0F1(new DerivativeStructure(3, maxOrder, FastMath.PI),\n+                      FastMath.PI, 0.0, 0.0, 0.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrimitiveAdd() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).add(5), 6.0, 1.0, 0.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).add(5), 7.0, 0.0, 1.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).add(5), 8.0, 0.0, 0.0, 1.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testAdd() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);\n+            DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);\n+            DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);\n+            DerivativeStructure xyz = x.add(y.add(z));\n+            checkF0F1(xyz, x.getValue() + y.getValue() + z.getValue(), 1.0, 1.0, 1.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrimitiveSubtract() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).subtract(5), -4.0, 1.0, 0.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).subtract(5), -3.0, 0.0, 1.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).subtract(5), -2.0, 0.0, 0.0, 1.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);\n+            DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);\n+            DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);\n+            DerivativeStructure xyz = x.subtract(y.subtract(z));\n+            checkF0F1(xyz, x.getValue() - (y.getValue() - z.getValue()), 1.0, -1.0, 1.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testPrimitiveMultiply() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).multiply(5),  5.0, 5.0, 0.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).multiply(5), 10.0, 0.0, 5.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).multiply(5), 15.0, 0.0, 0.0, 5.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiply() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);\n+            DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);\n+            DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);\n+            DerivativeStructure xyz = x.multiply(y.multiply(z));\n+            for (int i = 0; i <= maxOrder; ++i) {\n+                for (int j = 0; j <= maxOrder; ++j) {\n+                    for (int k = 0; k <= maxOrder; ++k) {\n+                        if (i + j + k <= maxOrder) {\n+                            Assert.assertEquals((i == 0 ? x.getValue() : (i == 1 ? 1.0 : 0.0)) *\n+                                                (j == 0 ? y.getValue() : (j == 1 ? 1.0 : 0.0)) *\n+                                                (k == 0 ? z.getValue() : (k == 1 ? 1.0 : 0.0)),\n+                                                xyz.getPartialDerivative(i, j, k),\n+                                                1.0e-15);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNegate() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).negate(), -1.0, -1.0, 0.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).negate(), -2.0, 0.0, -1.0, 0.0);\n+            checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).negate(), -3.0, 0.0, 0.0, -1.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testReciprocal() {\n+        for (double x = 0.1; x < 1.2; x += 0.1) {\n+            DerivativeStructure r = new DerivativeStructure(1, 6, 0, x).reciprocal();\n+            Assert.assertEquals(1 / x, r.getValue(), 1.0e-15);\n+            for (int i = 1; i < r.getOrder(); ++i) {\n+                double expected = ArithmeticUtils.pow(-1, i) * ArithmeticUtils.factorial(i) /\n+                                  FastMath.pow(x, i + 1);\n+                Assert.assertEquals(expected, r.getPartialDerivative(i), 1.0e-15 * FastMath.abs(expected));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testPower() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            for (int n = 0; n < 10; ++n) {\n+\n+                DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);\n+                DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0);\n+                DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0);\n+                List<DerivativeStructure> list = Arrays.asList(x, y, z,\n+                                                               x.add(y).add(z),\n+                                                               x.multiply(y).multiply(z));\n+\n+                if (n == 0) {\n+                    for (DerivativeStructure ds : list) {\n+                        checkEquals(ds.getField().getOne(), ds.pow(n), 1.0e-15);\n+                    }\n+                } else if (n == 1) {\n+                    for (DerivativeStructure ds : list) {\n+                        checkEquals(ds, ds.pow(n), 1.0e-15);\n+                    }\n+                } else {\n+                    for (DerivativeStructure ds : list) {\n+                        DerivativeStructure p = ds.getField().getOne();\n+                        for (int i = 0; i < n; ++i) {\n+                            p = p.multiply(ds);\n+                        }\n+                        checkEquals(p, ds.pow(n), 1.0e-15);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExpression() {\n+        double epsilon = 2.5e-13;\n+        for (double x = 0; x < 2; x += 0.2) {\n+            DerivativeStructure dsX = new DerivativeStructure(3, 5, 0, x);\n+            for (double y = 0; y < 2; y += 0.2) {\n+                DerivativeStructure dsY = new DerivativeStructure(3, 5, 1, y);\n+                for (double z = 0; z >- 2; z -= 0.2) {\n+                    DerivativeStructure dsZ = new DerivativeStructure(3, 5, 2, z);\n+\n+                    // f(x, y, z) = x + 5 x y - 2 z + (8 z x - y)^3\n+                    DerivativeStructure ds =\n+                            new DerivativeStructure(1, dsX,\n+                                                    5, dsX.multiply(dsY),\n+                                                    -2, dsZ,\n+                                                    1, new DerivativeStructure(8, dsZ.multiply(dsX),\n+                                                                               -1, dsY).pow(3));\n+                    double f = x + 5 * x * y - 2 * z + FastMath.pow(8 * z * x - y, 3);\n+                    Assert.assertEquals(f, ds.getValue(),\n+                                        FastMath.abs(epsilon * f));\n+\n+                    // df/dx = 1 + 5 y + 24 (8 z x - y)^2 z\n+                    double dfdx = 1 + 5 * y + 24 * z * FastMath.pow(8 * z * x - y, 2);\n+                    Assert.assertEquals(dfdx, ds.getPartialDerivative(1, 0, 0),\n+                                        FastMath.abs(epsilon * dfdx));\n+\n+                    // df/dxdy = 5 + 48 z*(y - 8 z x)\n+                    double dfdxdy = 5 + 48 * z * (y - 8 * z * x);\n+                    Assert.assertEquals(dfdxdy, ds.getPartialDerivative(1, 1, 0),\n+                                        FastMath.abs(epsilon * dfdxdy));\n+\n+                    // df/dxdydz = 48 (y - 16 z x)\n+                    double dfdxdydz = 48 * (y - 16 * z * x);\n+                    Assert.assertEquals(dfdxdydz, ds.getPartialDerivative(1, 1, 1),\n+                                        FastMath.abs(epsilon * dfdxdydz));\n+\n+                }\n+                \n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCompositionOneVariableX() {\n+        double epsilon = 1.0e-13;\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.1) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                for (double y = 0.1; y < 1.2; y += 0.1) {\n+                    DerivativeStructure dsY = new DerivativeStructure(1, maxOrder, y);\n+                    DerivativeStructure f = dsX.divide(dsY).sqrt();\n+                    double f0 = FastMath.sqrt(x / y);\n+                    Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));\n+                    if (f.getOrder() > 0) {\n+                        double f1 = 1 / (2 * FastMath.sqrt(x * y));\n+                        Assert.assertEquals(f1, f.getPartialDerivative(1), FastMath.abs(epsilon * f1));\n+                        if (f.getOrder() > 1) {\n+                            double f2 = -f1 / (2 * x); \n+                            Assert.assertEquals(f2, f.getPartialDerivative(2), FastMath.abs(epsilon * f2));\n+                            if (f.getOrder() > 2) {\n+                                double f3 = (f0 + x / (2 * y * f0)) / (4 * x * x * x); \n+                                Assert.assertEquals(f3, f.getPartialDerivative(3), FastMath.abs(epsilon * f3));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }        \n+    }\n+\n+    @Test\n+    public void testTrigo() {\n+        double epsilon = 2.0e-12;\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.1) {\n+                DerivativeStructure dsX = new DerivativeStructure(3, maxOrder, 0, x);\n+                for (double y = 0.1; y < 1.2; y += 0.1) {\n+                    DerivativeStructure dsY = new DerivativeStructure(3, maxOrder, 1, y);\n+                    for (double z = 0.1; z < 1.2; z += 0.1) {\n+                        DerivativeStructure dsZ = new DerivativeStructure(3, maxOrder, 2, z);\n+                        DerivativeStructure f = dsX.divide(dsY.cos().add(dsZ.tan())).sin();\n+                        double a = FastMath.cos(y) + FastMath.tan(z);\n+                        double f0 = FastMath.sin(x / a);\n+                        Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));\n+                        if (f.getOrder() > 0) {\n+                            double dfdx = FastMath.cos(x / a) / a;\n+                            Assert.assertEquals(dfdx, f.getPartialDerivative(1, 0, 0), FastMath.abs(epsilon * dfdx));\n+                            double dfdy =  x * FastMath.sin(y) * dfdx / a;\n+                            Assert.assertEquals(dfdy, f.getPartialDerivative(0, 1, 0), FastMath.abs(epsilon * dfdy));\n+                            double cz = FastMath.cos(z);\n+                            double cz2 = cz * cz;\n+                            double dfdz = -x * dfdx / (a * cz2);\n+                            Assert.assertEquals(dfdz, f.getPartialDerivative(0, 0, 1), FastMath.abs(epsilon * dfdz));\n+                            if (f.getOrder() > 1) {\n+                                double df2dx2 = -(f0 / (a * a));\n+                                Assert.assertEquals(df2dx2, f.getPartialDerivative(2, 0, 0), FastMath.abs(epsilon * df2dx2));\n+                                double df2dy2 = x * FastMath.cos(y) * dfdx / a -\n+                                                x * x * FastMath.sin(y) * FastMath.sin(y) * f0 / (a * a * a * a) +\n+                                                2 * FastMath.sin(y) * dfdy / a;\n+                                Assert.assertEquals(df2dy2, f.getPartialDerivative(0, 2, 0), FastMath.abs(epsilon * df2dy2));\n+                                double c4 = cz2 * cz2;\n+                                double df2dz2 = x * (2 * a * (1 - a * cz * FastMath.sin(z)) * dfdx - x * f0 / a ) / (a * a * a * c4);\n+                                Assert.assertEquals(df2dz2, f.getPartialDerivative(0, 0, 2), FastMath.abs(epsilon * df2dz2));\n+                                double df2dxdy = dfdy / x  - x * FastMath.sin(y) * f0 / (a * a * a);\n+                                Assert.assertEquals(df2dxdy, f.getPartialDerivative(1, 1, 0), FastMath.abs(epsilon * df2dxdy));\n+                            }\n+                        }\n+                    }\n+                }\n+            }        \n+        }\n+    }\n+\n+    @Test\n+    public void testSqrtDefinition() {\n+        double[] epsilon = new double[] { 5.0e-16, 5.0e-16, 2.0e-15, 5.0e-14, 2.0e-12 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure sqrt1 = dsX.pow(0.5);\n+                DerivativeStructure sqrt2 = dsX.sqrt();\n+                DerivativeStructure zero = sqrt1.subtract(sqrt2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSqrtPow2() {\n+        double[] epsilon = new double[] { 1.0e-16, 3.0e-16, 2.0e-15, 6.0e-14, 6.0e-12 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.multiply(dsX).sqrt();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCbrtDefinition() {\n+        double[] epsilon = new double[] { 4.0e-16, 9.0e-16, 6.0e-15, 2.0e-13, 4.0e-12 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure cbrt1 = dsX.pow(1.0 / 3.0);\n+                DerivativeStructure cbrt2 = dsX.cbrt();\n+                DerivativeStructure zero = cbrt1.subtract(cbrt2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCbrtPow3() {\n+        double[] epsilon = new double[] { 1.0e-16, 5.0e-16, 8.0e-15, 3.0e-13, 4.0e-11 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.multiply(dsX.multiply(dsX)).cbrt();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExp() {\n+        double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                double refExp = FastMath.exp(x);\n+                DerivativeStructure exp = new DerivativeStructure(1, maxOrder, 0, x).exp();\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(refExp, exp.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLog() {\n+        double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 3.0e-14, 7.0e-13, 3.0e-11 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure log = new DerivativeStructure(1, maxOrder, 0, x).log();\n+                Assert.assertEquals(FastMath.log(x), log.getValue(), epsilon[0]);\n+                for (int n = 1; n <= maxOrder; ++n) {\n+                    double refDer = -ArithmeticUtils.factorial(n - 1) / FastMath.pow(-x, n);\n+                    Assert.assertEquals(refDer, log.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLogExp() {\n+        double[] epsilon = new double[] { 2.0e-16, 2.0e-16, 3.0e-16, 2.0e-15, 6.0e-15 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.exp().log();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTangentDefinition() {\n+        double[] epsilon = new double[] { 5.0e-16, 2.0e-15, 3.0e-14, 5.0e-13, 2.0e-11 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure tan1 = dsX.sin().divide(dsX.cos());\n+                DerivativeStructure tan2 = dsX.tan();\n+                DerivativeStructure zero = tan1.subtract(tan2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCompositionOneVariableY() {\n+        double epsilon = 1.0e-13;\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.1) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, x);\n+                for (double y = 0.1; y < 1.2; y += 0.1) {\n+                    DerivativeStructure dsY = new DerivativeStructure(1, maxOrder, 0, y);\n+                    DerivativeStructure f = dsX.divide(dsY).sqrt();\n+                    double f0 = FastMath.sqrt(x / y);\n+                    Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0));\n+                    if (f.getOrder() > 0) {\n+                        double f1 = -x / (2 * y * y * f0);\n+                        Assert.assertEquals(f1, f.getPartialDerivative(1), FastMath.abs(epsilon * f1));\n+                        if (f.getOrder() > 1) {\n+                            double f2 = (f0 - x / (4 * y * f0)) / (y * y); \n+                            Assert.assertEquals(f2, f.getPartialDerivative(2), FastMath.abs(epsilon * f2));\n+                            if (f.getOrder() > 2) {\n+                                double f3 = (x / (8 * y * f0) - 2 * f0) / (y * y * y); \n+                                Assert.assertEquals(f3, f.getPartialDerivative(3), FastMath.abs(epsilon * f3));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }        \n+    }\n+\n+    @Test\n+    public void testField() {\n+        for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {\n+            DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0);\n+            checkF0F1(x.getField().getZero(), 0.0, 0.0, 0.0, 0.0);\n+            checkF0F1(x.getField().getOne(), 1.0, 0.0, 0.0, 0.0);\n+            Assert.assertEquals(maxOrder, x.getField().getZero().getOrder());\n+            Assert.assertEquals(3, x.getField().getZero().getFreeParameters());\n+            Assert.assertEquals(DerivativeStructure.class, x.getField().getRuntimeClass());\n+        }\n+    }\n+\n+    private void checkF0F1(DerivativeStructure ds, double value, double...derivatives) {\n+\n+        // check dimension\n+        Assert.assertEquals(derivatives.length, ds.getFreeParameters());\n+\n+        // check value, directly and also as 0th order derivative\n+        Assert.assertEquals(value, ds.getValue(), 1.0e-15);\n+        Assert.assertEquals(value, ds.getPartialDerivative(new int[ds.getFreeParameters()]), 1.0e-15);\n+\n+        // check first order derivatives\n+        for (int i = 0; i < derivatives.length; ++i) {\n+            int[] orders = new int[derivatives.length];\n+            orders[i] = 1;\n+            Assert.assertEquals(derivatives[i], ds.getPartialDerivative(orders), 1.0e-15);\n+        }\n+\n+    }\n+\n+    private void checkEquals(DerivativeStructure ds1, DerivativeStructure ds2, double epsilon) {\n+\n+        // check dimension\n+        Assert.assertEquals(ds1.getFreeParameters(), ds2.getFreeParameters());\n+        Assert.assertEquals(ds1.getOrder(), ds2.getOrder());\n+\n+        int[] derivatives = new int[ds1.getFreeParameters()];\n+        int sum = 0;\n+        while (true) {\n+\n+            if (sum <= ds1.getOrder()) {\n+                Assert.assertEquals(ds1.getPartialDerivative(derivatives),\n+                                    ds2.getPartialDerivative(derivatives),\n+                                    epsilon);\n+            }\n+\n+            boolean increment = true;\n+            sum = 0;\n+            for (int i = derivatives.length - 1; i >= 0; --i) {\n+                if (increment) {\n+                    if (derivatives[i] == ds1.getOrder()) {\n+                        derivatives[i] = 0;\n+                    } else {\n+                        derivatives[i]++;\n+                        increment = false;\n+                    }\n+                }\n+                sum += derivatives[i];\n+            }\n+            if (increment) {\n+                return;\n+            }\n+\n+        }\n+\n+    }\n+\n+}", "timestamp": 1344458023, "metainfo": ""}