{"sha": "a311dce47eb28360297655aefeac518cfac069a9", "log": "Support for one dimensional vectors has been added to the linear algebra package with a RealVector interface, a RealVectorImpl default implementation using a single double array to store elements and a RealVectorFormat class for input/output.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n     * @throws MatrixIndexException if the specified column index is invalid\n     */\n    RealMatrix getColumnMatrix(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row vector\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   RealVector getRowVector(int row) throws MatrixIndexException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a column vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column vector\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   RealVector getColumnVector(int column) throws MatrixIndexException;\n     \n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n     double[] operate(double[] v) throws IllegalArgumentException;\n \n     /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    RealVector operate(RealVector v) throws IllegalArgumentException;\n+\n+    /**\n      * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n      *\n      * @param v the row vector to premultiply by\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n     double[] preMultiply(double[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    RealVector preMultiply(RealVector v) throws IllegalArgumentException;\n \n     /**\n      * Returns the solution vector for a linear system with coefficient\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Returns the solution vector for a linear system with coefficient\n+     * matrix = this and constant vector = <code>b</code>.\n+     *\n+     * @param b  constant vector\n+     * @return vector of solution values to AX = b, where A is *this\n+     * @throws IllegalArgumentException if this.rowDimension != b.length\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException;\n \n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n+\n }\n-\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n public class RealMatrixImpl implements RealMatrix, Serializable {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -4828886979278117018L;\n+    private static final long serialVersionUID = 4970229902484487012L;\n \n     /** Entries of the matrix */\n     protected double data[][] = null;\n         return new RealMatrixImpl(out, false);\n     }\n \n-     /**\n+    /** {@inheritDoc} */\n+    public RealVector getColumnVector(int column) throws MatrixIndexException {\n+        return new RealVectorImpl(getColumn(column), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getRowVector(int row) throws MatrixIndexException {\n+        return new RealVectorImpl(getRow(row), false);\n+    }\n+\n+    /**\n      * Returns the entries in row number <code>row</code> as an array.\n      * <p>\n      * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n         return out;\n     }\n \n+    /** {@inheritDoc} */\n+    public RealVector operate(RealVector v) throws IllegalArgumentException {\n+        try {\n+            return operate((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            final int nRows = this.getRowDimension();\n+            final int nCols = this.getColumnDimension();\n+            if (v.getDimension() != nCols) {\n+                throw new IllegalArgumentException(\"vector has wrong length\");\n+            }\n+            final double[] out = new double[nRows];\n+            for (int row = 0; row < nRows; row++) {\n+                final double[] dataRow = data[row];\n+                double sum = 0;\n+                for (int i = 0; i < nCols; i++) {\n+                    sum += dataRow[i] * v.getEntry(i);\n+                }\n+                out[row] = sum;\n+            }\n+            return new RealVectorImpl(out, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    public RealVectorImpl operate(RealVectorImpl v) throws IllegalArgumentException {\n+        return new RealVectorImpl(operate(v.getDataRef()), false);\n+    }\n+\n     /**\n      * @param v vector to premultiply by\n      * @throws IllegalArgumentException if rowDimension != v.length\n         return out;\n     }\n \n+    /** {@inheritDoc} */\n+    public RealVector preMultiply(RealVector v) throws IllegalArgumentException {\n+        try {\n+            return preMultiply((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            final int nRows = this.getRowDimension();\n+            if (v.getDimension() != nRows) {\n+                throw new IllegalArgumentException(\"vector has wrong length\");\n+            }\n+            final int nCols = this.getColumnDimension();\n+            final double[] out = new double[nCols];\n+            for (int col = 0; col < nCols; col++) {\n+                double sum = 0;\n+                for (int i = 0; i < nRows; i++) {\n+                    sum += data[i][col] * v.getEntry(i);\n+                }\n+                out[col] = sum;\n+            }\n+            return new RealVectorImpl(out, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    RealVectorImpl preMultiply(RealVectorImpl v) throws IllegalArgumentException {\n+        return new RealVectorImpl(preMultiply(v.getDataRef()), false);\n+    }\n+\n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * coefficient matrix = this and constant vectors = columns of\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n+\n         final int nRows = this.getRowDimension();\n+        final int nCol  = this.getColumnDimension();\n+\n         if (b.length != nRows) {\n             throw new IllegalArgumentException(\"constant vector has wrong length\");\n         }\n-        final RealMatrix bMatrix = new RealMatrixImpl(b);\n-        final double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n-        final double[] out = new double[nRows];\n+        if (!isSquare()) {\n+            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n+        }\n+        if (isSingular()) { // side effect: compute LU decomp\n+            throw new InvalidMatrixException(\"Matrix is singular.\");\n+        }\n+\n+        final double[] bp = new double[nRows];\n+\n+        // Apply permutations to b\n         for (int row = 0; row < nRows; row++) {\n-            out[row] = solution[row][0];\n-        }\n-        return out;\n+            bp[row] = b[permutation[row]];\n+        }\n+\n+        // Solve LY = b\n+        for (int col = 0; col < nCol; col++) {\n+            for (int i = col + 1; i < nCol; i++) {\n+                bp[i] -= bp[col] * lu[i][col];\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        for (int col = nCol - 1; col >= 0; col--) {\n+            bp[col] /= lu[col][col];\n+            for (int i = 0; i < col; i++) {\n+                bp[i] -= bp[col] * lu[i][col];\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+\n+            final int nRows = this.getRowDimension();\n+            final int nCol  = this.getColumnDimension();\n+\n+            if (b.getDimension() != nRows) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+            if (!isSquare()) {\n+                throw new InvalidMatrixException(\"coefficient matrix is not square\");\n+            }\n+            if (isSingular()) { // side effect: compute LU decomp\n+                throw new InvalidMatrixException(\"Matrix is singular.\");\n+            }\n+\n+            final double[] bp = new double[nRows];\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < nRows; row++) {\n+                bp[row] = b.getEntry(permutation[row]);\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < nCol; col++) {\n+                for (int i = col + 1; i < nCol; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = nCol - 1; col >= 0; col--) {\n+                bp[col] /= lu[col][col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            return new RealVectorImpl(bp, false);\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the solution vector for a linear system with coefficient\n+     * matrix = this and constant vector = <code>b</code>.\n+     *\n+     * @param b  constant vector\n+     * @return vector of solution values to AX = b, where A is *this\n+     * @throws IllegalArgumentException if this.rowDimension != b.length\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    RealVectorImpl solve(RealVectorImpl b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n     }\n \n     /**\n         final double[][] bp = new double[nRowB][nColB];\n         for (int row = 0; row < nRowB; row++) {\n             final double[] bpRow = bp[row];\n+            final int pRow = permutation[row];\n             for (int col = 0; col < nColB; col++) {\n-                bpRow[col] = b.getEntry(permutation[row], col);\n+                bpRow[col] = b.getEntry(pRow, col);\n             }\n         }\n \n         // Solve LY = b\n         for (int col = 0; col < nCol; col++) {\n+            final double[] bpCol = bp[col];\n             for (int i = col + 1; i < nCol; i++) {\n                 final double[] bpI = bp[i];\n-                final double[] luI = lu[i];\n+                final double luICol = lu[i][col];\n                 for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bp[col][j] * luI[col];\n+                    bpI[j] -= bpCol[j] * luICol;\n                 }\n             }\n         }\n             }\n             for (int i = 0; i < col; i++) {\n                 final double[] bpI = bp[i];\n-                final double[] luI = lu[i];\n+                final double luICol = lu[i][col];\n                 for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bp[col][j] * luI[col];\n+                    bpI[j] -= bpCol[j] * luICol;\n                 }\n             }\n         }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Interface defining a real-valued vector with basic algebraic operations.\n+ * <p>\n+ * vector element indexing is 0-based -- e.g., <code>getEntry(0)</code>\n+ * returns the first element of the vector.\n+ * </p>\n+ * <p>\n+ * The various <code>mapXxx</code> and <code>mapXxxToSelf</code> methods operate\n+ * on vectors element-wise, i.e. they perform the same operation (adding a scalar,\n+ * applying a function ...) on each element in turn. The <code>mapXxx</code>\n+ * versions create a new vector to hold the result and do not change the instance.\n+ * The <code>mapXxxToSelf</code> versions use the instance itself to store the\n+ * results, so the instance is changed by these methods. In both cases, the result\n+ * vector is returned by the methods, this allows to use the <i>fluent API</i>\n+ * style, like this:\n+ * </p>\n+ * <pre>\n+ *   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();\n+ * </pre>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealVector {\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     * @return vector copy\n+     */\n+    RealVector copy();\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector add(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector subtract(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * @param d value to be added to each entry\n+     * @return this + d\n+     */\n+    RealVector mapAdd(double d);\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be added to each entry\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAddToSelf(double d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * @param d value to be subtracted to each entry\n+     * @return this - d\n+     */\n+    RealVector mapSubtract(double d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be subtracted to each entry\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSubtractToSelf(double d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * @param d value to multiply all entries by\n+     * @return this * d\n+     */\n+    RealVector mapMultiply(double d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to multiply all entries by\n+     * @return for convenience, return this\n+     */\n+    RealVector mapMultiplyToSelf(double d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * @param d value to divide all entries by\n+     * @return this / d\n+     */\n+    RealVector mapDivide(double d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to divide all entries by\n+     * @return for convenience, return this\n+     */\n+    RealVector mapDivideToSelf(double d);\n+\n+    /**\n+     * Map a power operation to each entry.\n+     * @param d value to raise all entries to\n+     * @return this ^ d\n+     */\n+    RealVector mapPow(double d);\n+\n+    /**\n+     * Map a power operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to raise all entries to\n+     * @return for convenience, return this\n+     */\n+    RealVector mapPowToSelf(double d);\n+\n+    /**\n+     * Map the {@link Math#exp(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapExp();\n+\n+    /**\n+     * Map the {@link Math#exp(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapExpToSelf();\n+\n+    /**\n+     * Map the {@link Math#expm1(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapExpm1();\n+\n+    /**\n+     * Map the {@link Math#expm1(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapExpm1ToSelf();\n+\n+    /**\n+     * Map the {@link Math#log(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog();\n+\n+    /**\n+     * Map the {@link Math#log(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLogToSelf();\n+\n+    /**\n+     * Map the {@link Math#log10(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog10();\n+\n+    /**\n+     * Map the {@link Math#log10(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLog10ToSelf();\n+\n+    /**\n+     * Map the {@link Math#log1p(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog1p();\n+\n+    /**\n+     * Map the {@link Math#log1p(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLog1pToSelf();\n+\n+    /**\n+     * Map the {@link Math#cosh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCosh();\n+\n+    /**\n+     * Map the {@link Math#cosh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCoshToSelf();\n+\n+    /**\n+     * Map the {@link Math#sinh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSinh();\n+\n+    /**\n+     * Map the {@link Math#sinh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSinhToSelf();\n+\n+    /**\n+     * Map the {@link Math#tanh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapTanh();\n+\n+    /**\n+     * Map the {@link Math#tanh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapTanhToSelf();\n+\n+    /**\n+     * Map the {@link Math#cos(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCos();\n+\n+    /**\n+     * Map the {@link Math#cos(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCosToSelf();\n+\n+    /**\n+     * Map the {@link Math#sin(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSin();\n+\n+    /**\n+     * Map the {@link Math#sin(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSinToSelf();\n+\n+    /**\n+     * Map the {@link Math#tan(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapTan();\n+\n+    /**\n+     * Map the {@link Math#tan(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapTanToSelf();\n+\n+    /**\n+     * Map the {@link Math#acos(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAcos();\n+\n+    /**\n+     * Map the {@link Math#acos(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAcosToSelf();\n+\n+    /**\n+     * Map the {@link Math#asin(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAsin();\n+\n+    /**\n+     * Map the {@link Math#asin(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAsinToSelf();\n+\n+    /**\n+     * Map the {@link Math#atan(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAtan();\n+\n+    /**\n+     * Map the {@link Math#atan(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAtanToSelf();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapInv();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapInvToSelf();\n+\n+    /**\n+     * Map the {@link Math#abs(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAbs();\n+\n+    /**\n+     * Map the {@link Math#abs(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAbsToSelf();\n+\n+    /**\n+     * Map the {@link Math#sqrt(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSqrt();\n+\n+    /**\n+     * Map the {@link Math#sqrt(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSqrtToSelf();\n+\n+    /**\n+     * Map the {@link Math#cbrt(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCbrt();\n+\n+    /**\n+     * Map the {@link Math#cbrt(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCbrtToSelf();\n+\n+    /**\n+     * Map the {@link Math#ceil(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCeil();\n+\n+    /**\n+     * Map the {@link Math#ceil(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCeilToSelf();\n+\n+    /**\n+     * Map the {@link Math#floor(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapFloor();\n+\n+    /**\n+     * Map the {@link Math#floor(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapFloorToSelf();\n+\n+    /**\n+     * Map the {@link Math#rint(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapRint();\n+\n+    /**\n+     * Map the {@link Math#rint(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapRintToSelf();\n+\n+    /**\n+     * Map the {@link Math#signum(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSignum();\n+\n+    /**\n+     * Map the {@link Math#signum(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSignumToSelf();\n+\n+    /**\n+     * Map the {@link Math#ulp(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapUlp();\n+\n+    /**\n+     * Map the {@link Math#ulp(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapUlpToSelf();\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeMultiply(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeDivide(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns vector entries as a double array.\n+     * @return double array of entries\n+     */\n+     double[] getData();\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    double dotProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the L<sub>2</sub> norm of the vector.\n+     * <p>The L<sub>2</sub> norm is the root of the sum of\n+     * the squared elements.</p>\n+     * @return norm\n+     * @see #getL1Norm()\n+     * @see #getLInfNorm()\n+     * @see #getDistance(RealVector)\n+     */\n+    double getNorm();\n+\n+    /**\n+     * Returns the L<sub>1</sub> norm of the vector.\n+     * <p>The L<sub>1</sub> norm is the sum of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getLInfNorm()\n+     * @see #getL1Distance(RealVector)\n+     */\n+    double getL1Norm();\n+\n+    /**\n+     * Returns the L<sub>&infty;</sub> norm of the vector.\n+     * <p>The L<sub>&infty;</sub> norm is the max of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getL1Norm()\n+     * @see #getLInfDistance(RealVector)\n+     */\n+    double getLInfNorm();\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfDistance(RealVector)\n+     * @see #getNorm()\n+     */\n+    double getDistance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getLInfDistance(RealVector)\n+     * @see #getL1Norm()\n+     */\n+    double getL1Distance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infty;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfNorm()\n+     */\n+    double getLInfDistance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /** Creates a unit vector pointing in the direction of this vector.\n+     * <p>The instance is not changed by this method.</p>\n+     * @return a unit vector pointing in direction of this vector\n+     * @exception ArithmeticException if the norm is null\n+     */\n+    RealVector unitVector();\n+\n+    /** Converts this vector into a unit vector.\n+     * <p>The instance itself is changed by this method.</p>\n+     * @exception ArithmeticException if the norm is null\n+     */\n+    void unitize();\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector projection(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the entry in the specified index.\n+     * <p>\n+     * The index start at 0 and must be lesser than the size,\n+     * otherwise a {@link MatrixIndexException} is thrown.\n+     * </p>\n+     * @param index  index location of entry to be fetched\n+     * @return vector entry at index\n+     * @throws MatrixIndexException if the index is not valid\n+     */\n+    double getEntry(int index)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Returns the size of the vector.\n+     * @return size\n+     */\n+    int getDimension();\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    RealVector append(RealVector v);\n+\n+    /**\n+     * Construct a vector by appending a double to this vector.\n+     * @param d double to append.\n+     * @return a new vector\n+     */\n+    RealVector append(double d);\n+\n+    /**\n+     * Construct a vector by appending a double array to this vector.\n+     * @param a double array to append.\n+     * @return a new vector\n+     */\n+    RealVector append(double[] a);\n+\n+    /**\n+     * Get a subvector from consecutive elements.\n+     * @param index index of first element.\n+     * @param n number of elements to be retrieved.\n+     * @return a vector containing n elements.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    RealVector get(int index, int n)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a single element.\n+     * @param index element index.\n+     * @param value new value for the element.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    void set(int index, double value)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    void set(int index, RealVector v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set all elements to a single value.\n+     * @param value single value to set for all elements\n+     */\n+    void set(double value);\n+\n+    /**\n+     * Convert the vector to a double array.\n+     * <p>The array is independent from vector data, it's elements\n+     * are copied.</p>\n+     * @return array containing a copy of vector elements\n+     */\n+    double[] toArray();\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN();\n+    \n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a vector in components list format \"{v0; v1; ...; vk-1}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RealVectorFormat extends CompositeFormat {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -708767813036157690L;\n+\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"{\";\n+\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** The default separator: \", \". */\n+    private static final String DEFAULT_SEPARATOR = \"; \";\n+\n+    /** Prefix. */\n+    private final String prefix;\n+\n+    /** Suffix. */\n+    private final String suffix;\n+\n+    /** Separator. */\n+    private final String separator;\n+\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+\n+    /** The format used for components. */\n+    private NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public RealVectorFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public RealVectorFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public RealVectorFormat(final String prefix, final String suffix,\n+                            final String separator) {\n+        this(prefix, suffix, separator, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public RealVectorFormat(final String prefix, final String suffix,\n+                            final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which real vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available real vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the current locale.\n+     * @return the default real vector format.\n+     */\n+    public static RealVectorFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the real vector format specific to the given locale.\n+     */\n+    public static RealVectorFormat getInstance(final Locale locale) {\n+        return new RealVectorFormat(getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n+     * RealVectorFormat.\n+     *\n+     * @param v RealVector object to format\n+     * @return A formatted vector\n+     */\n+    public static String formatRealVector(RealVector v) {\n+        return getInstance().format(v);\n+    }\n+\n+    /**\n+     * Formats a {@link RealVector} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(RealVector vector, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        for (int i = 0; i < vector.getDimension(); ++i) {\n+            if (i > 0) {\n+                toAppendTo.append(separator);\n+            }\n+            formatDouble(vector.getEntry(i), format, toAppendTo, pos);\n+        }\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+\n+    }\n+\n+    /**\n+     * Formats a object to produce a string.\n+     * <p><code>obj</code> must be a  {@link RealVector} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        if (obj instanceof RealVector) {\n+            return format( (RealVector)obj, toAppendTo, pos);\n+        }\n+\n+        throw new IllegalArgumentException(\"Cannot format given Object as a RealVector\");\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link RealVector} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link RealVector} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public RealVectorImpl parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        RealVectorImpl result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new ParseException(\"Unparseable real vector: \\\"\" + source +\n+                                     \"\\\"\", parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link RealVector} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link RealVector} object.\n+     */\n+    public RealVectorImpl parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse components\n+        List<Number> components = new ArrayList<Number>();\n+        for (boolean loop = true; loop;){\n+\n+            if (!components.isEmpty()) {\n+                parseAndIgnoreWhitespace(source, pos);\n+                if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+                    loop = false;\n+                }\n+            }\n+\n+            if (loop) {\n+                parseAndIgnoreWhitespace(source, pos);\n+                Number component = parseNumber(source, format, pos);\n+                if (component != null) {\n+                    components.add(component);\n+                } else {\n+                    // invalid component\n+                    // set index back to initial, error index should already be set\n+                    pos.setIndex(initialIndex);\n+                    return null;\n+                }\n+            }\n+\n+        }\n+\n+        // parse suffix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        // build vector\n+        double[] data = new double[components.size()];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = components.get(i).doubleValue();\n+        }\n+        return new RealVectorImpl(data, false);\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This class implements the {@link RealVector} interface with a double array.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RealVectorImpl implements RealVector, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7838747548772166404L;\n+\n+    /** Default format. */\n+    private static final RealVectorFormat DEFAULT_FORMAT =\n+        RealVectorFormat.getInstance();\n+\n+    /** Entries of the vector. */\n+    protected double data[];\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #RealVectorImpl(RealVectorImpl, RealVectorImpl)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(double[])}, {@link #append(RealVectorImpl)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public RealVectorImpl() {\n+        data = new double[0];\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param size size of the vector\n+     */\n+    public RealVectorImpl(int size) {\n+        data = new double[size];\n+    }\n+\n+    /**\n+     * Construct an (size)-length vector with preset values.\n+     * @param size size of the vector\n+     * @param preset fill the vector with this scalar value\n+     */\n+    public RealVectorImpl(int size, double preset) {\n+        data = new double[size];\n+        Arrays.fill(data, preset);\n+    }\n+\n+    /**\n+     * Construct a vector from an array, copying the input array.\n+     * @param d array of doubles.\n+     */\n+    public RealVectorImpl(double[] d) {\n+        data = d.clone();\n+    }\n+\n+    /**\n+     * Create a new RealVectorImpl using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealVectorImpl and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new vector\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealVectorImpl(double[])\n+     */\n+    public RealVectorImpl(double[] d, boolean copyArray)\n+        throws NullPointerException, IllegalArgumentException {\n+        if (d == null) {\n+            throw new NullPointerException();\n+        }   \n+        if (d.length == 0) {\n+            throw new IllegalArgumentException(\"Vector must have at least one element.\"); \n+        }\n+        data = copyArray ? d.clone() :  d;\n+    }\n+\n+    /**\n+     * Construct a vector from part of a array.\n+     * @param d array of doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public RealVectorImpl(double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw new IllegalArgumentException(\"Position \" + pos + \" and size \" + size +\n+                                               \" don't fit to the size of the input array \" +\n+                                               d.length);\n+        }\n+        data = new double[size];\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n+     * Construct a vector from an array.\n+     * @param d array of Doubles.\n+     */\n+    public RealVectorImpl(Double[] d) {\n+        data = new double[d.length];\n+        for (int i = 0; i < d.length; i++) {\n+            data[i] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from part of a Double array\n+     * @param d array of Doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public RealVectorImpl(Double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw new IllegalArgumentException(\"Position \" + pos + \" and size \" + size +\n+                                               \" don't fit to the size of the input array \" +\n+                                               d.length);\n+        }\n+        data = new double[size];\n+        for (int i = pos; i < pos + size; i++) {\n+            data[i-pos] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public RealVectorImpl(RealVector v) {\n+        data = new double[v.getDimension()];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = v.getEntry(i);\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public RealVectorImpl(RealVectorImpl v) {\n+        data = v.data.clone();\n+    }\n+\n+    /**\n+     * Construct a vector from another vector.\n+     * @param v vector to copy\n+     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     */\n+    public RealVectorImpl(RealVectorImpl v, boolean deep) {\n+        data = deep ? v.data.clone() : v.data;\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(RealVectorImpl v1, RealVectorImpl v2) {\n+        data = new double[v1.data.length + v2.data.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector copy() {\n+        return new RealVectorImpl(this, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return add((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] + v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl add(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + v.data[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return subtract((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] - v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl subtract(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - v.data[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAdd(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAddToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] + d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtractToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] - d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiplyToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] * d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivide(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] / d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivideToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] / d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPow(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.pow(data[i], d);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPowToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.pow(data[i], d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.exp(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.exp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.expm1(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.expm1(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLogToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log10(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log10(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1p() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log1p(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1pToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log1p(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cosh(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCoshToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cosh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sinh(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sinh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tanh(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tanh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cos(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sin(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tan(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.acos(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.acos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.asin(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.asin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.atan(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.atan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInv() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = 1.0 / data[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInvToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = 1.0 / data[i];\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbs() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.abs(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbsToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.abs(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sqrt(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sqrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cbrt(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cbrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeil() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ceil(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeilToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ceil(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloor() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.floor(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloorToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.floor(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRint() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.rint(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRintToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.rint(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignum() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.signum(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignumToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.signum(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ulp(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ulp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeMultiply((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl ebeMultiply(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * v.data[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeDivide((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl ebeDivide(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v.data[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>Does not make a fresh copy of the underlying data.</p>\n+     * @return array of entries\n+     */\n+    public double[] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return dotProduct((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public double dotProduct(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double dot = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            dot += data[i] * v.getEntry(i);\n+        }\n+        return dot;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += a * a;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += Math.abs(a);\n+        }\n+        return sum;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double max = 0;\n+        for (double a : data) {\n+            max += Math.max(max, Math.abs(a));\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getDistance((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += delta * delta;\n+            }\n+            return Math.sqrt(sum);\n+        }\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVectorImpl)\n+     * @see #getLInfDistance(RealVectorImpl)\n+     * @see #getNorm()\n+     */\n+    public double getDistance(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v.data[i];\n+            sum += delta * delta;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getL1Distance((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += Math.abs(delta);\n+            }\n+            return sum;\n+        }\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVectorImpl)\n+     * @see #getLInfDistance(RealVectorImpl)\n+     * @see #getNorm()\n+     */\n+    public double getL1Distance(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v.data[i];\n+            sum += Math.abs(delta);\n+        }\n+        return sum;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getLInfDistance((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double max = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                max = Math.max(max, Math.abs(delta));\n+            }\n+            return max;\n+        }\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infty;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVectorImpl)\n+     * @see #getLInfDistance(RealVectorImpl)\n+     * @see #getNorm()\n+     */\n+    public double getLInfDistance(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double max = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v.data[i];\n+            max = Math.max(max, Math.abs(delta));\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector unitVector() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw new ArithmeticException(\"null norm\");\n+        }\n+        return mapDivide(getNorm());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw new ArithmeticException(\"null norm\");\n+        }\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] /= norm;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(RealVector v) {\n+        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl projection(RealVectorImpl v) {\n+        return (RealVectorImpl) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return outerProduct((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[][] out = new double[data.length][data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                for (int j = 0; j < data.length; j++) {\n+                    out[i][j] = data[i] * v.getEntry(j);\n+                }\n+            }\n+            return new RealMatrixImpl(out);\n+        }\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealMatrixImpl outerProduct(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v);\n+        double[][] out = new double[data.length][data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out[i][j] = data[i] * v.data[j];\n+            }\n+        }\n+        return new RealMatrixImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(int index) throws MatrixIndexException {\n+        return data[index];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(RealVector v) {\n+        try {\n+            return append((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            return new RealVectorImpl(this,new RealVectorImpl(v));\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public RealVectorImpl append(RealVectorImpl v) {\n+        return new RealVectorImpl(this, v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double in) {\n+        final double[] out = new double[data.length + 1];\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        out[data.length] = in;\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double[] in) {\n+        final double[] out = new double[data.length + in.length];\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        System.arraycopy(in, 0, out, data.length, in.length);\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector get(int index, int n) {\n+        try {\n+            RealVectorImpl out = new RealVectorImpl(n);\n+            System.arraycopy(data, index, out.data, 0, n);\n+\n+            return out;\n+        } catch (IndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(e.getMessage());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, double value) {\n+        try {\n+            data[index] = value;\n+        } catch (IndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(e.getMessage());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, RealVector v) {\n+        try {\n+            try {\n+                set(index, (RealVectorImpl) v);\n+            } catch (ClassCastException cce) {\n+                for (int i = index; i < index + v.getDimension(); ++i) {\n+                    data[i] = v.getEntry(i-index);\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * \n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    public void set(int index, RealVectorImpl v)\n+        throws MatrixIndexException {\n+        try {\n+            System.arraycopy(v.data, 0, data, index, v.data.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(e.getMessage());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        Arrays.fill(data, value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray(){\n+        return data.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString(){\n+        return DEFAULT_FORMAT.format(this);\n+    }\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    public void checkVectorDimensions(RealVector v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    public void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        if (data.length != n) {\n+            throw new IllegalArgumentException(\"vector dimension is \" + data.length +\n+                                               \", not \" + n + \" as expected\");\n+        }\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN() {\n+        for (double v : data) {\n+            if (Double.isNaN(v)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite() {\n+\n+        if (isNaN()) {\n+            return false;\n+        }\n+\n+        for (double v : data) {\n+            if (Double.isInfinite(v)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+\n+    }\n+    \n+    /**\n+     * Test for the equality of two real vectors.\n+     * <p>\n+     * If all coordinates of two real vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n+     * a vector with all <code>Double.NaN</code> coordinates.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     * \n+     */\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          RealVector rhs = (RealVector) other;\n+          if (data.length != rhs.getDimension()) {\n+              return false;\n+          }\n+\n+          if (rhs.isNaN()) {\n+              return this.isNaN();\n+          }\n+\n+          for (int i = 0; i < data.length; ++i) {\n+              if (Double.doubleToRawLongBits(data[i]) !=\n+                  Double.doubleToRawLongBits(rhs.getEntry(i))) {\n+                  return false;\n+              }\n+          }\n+          return true;\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /**\n+     * Get a hashCode for the real vector.\n+     * <p>All NaN values have the same hash code.</p>\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 9;\n+        }\n+        return MathUtils.hash(data);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/FrenchRealVectorFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {\n+    \n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrix mInv = new RealMatrixImpl(testDataInv);\n         // being a bit slothful here -- actually testing that X = A^-1 * B\n-        assertClose(\"inverse-operate\",mInv.operate(testVector),\n-            m.solve(testVector),normTolerance);\n+        assertClose(\"inverse-operate\", mInv.operate(testVector),\n+                    m.solve(testVector), normTolerance);\n+        assertClose(\"inverse-operate\", mInv.operate(testVector),\n+                    m.solve(new RealVectorImpl(testVector)).getData(), normTolerance);\n         try {\n             m.solve(testVector2);\n             fail(\"expecting IllegalArgumentException\");\n     /** test operate */\n     public void testOperate() {\n         RealMatrix m = new RealMatrixImpl(id);\n-        double[] x = m.operate(testVector);\n-        assertClose(\"identity operate\",testVector,x,entryTolerance);\n+        assertClose(\"identity operate\", testVector,\n+                    m.operate(testVector), entryTolerance);\n+        assertClose(\"identity operate\", testVector,\n+                    m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);\n         m = new RealMatrixImpl(bigSingular);\n         try {\n             m.operate(testVector);\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         RealMatrix m = new RealMatrixImpl(testData);\n-        assertClose(\"premultiply\",m.preMultiply(testVector),preMultTest,normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(testVector),\n+                    preMultTest, normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(new RealVectorImpl(testVector).getData()),\n+                    preMultTest, normTolerance);\n         m = new RealMatrixImpl(bigSingular);\n         try {\n             m.preMultiply(testVector);\n             // expected\n         }\n     }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n+        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+   }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new RealVectorImpl(data, false);\n+    }\n     \n     public void testEqualsAndHashCode() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+public abstract class RealVectorFormatAbstractTest extends TestCase {\n+ \n+    RealVectorFormat realVectorFormat = null;\n+    RealVectorFormat realVectorFormatSquare = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+    \n+    protected void setUp() throws Exception {\n+        realVectorFormat = RealVectorFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        realVectorFormatSquare = new RealVectorFormat(\"[\", \"]\", \" : \", nf);\n+    }\n+   \n+    public void testSimpleNoDecimals() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});\n+        String expected = \"{1; 1; 1}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimals() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimalsTrunc() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeX() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});\n+        String expected =\n+            \"{-1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeY() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; -1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeZ() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; -1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNonDefaultSetting() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});\n+        String expected = \"[1 : 1 : 1]\";\n+        String actual = realVectorFormatSquare.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testStaticFormatRealVectorImpl() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+        RealVectorImpl c = new RealVectorImpl(new double[] {232.222, -342.33, 432.444});\n+        String expected =\n+            \"{232\"    + getDecimalCharacter() +\n+            \"22; -342\" + getDecimalCharacter() +\n+            \"33; 432\" + getDecimalCharacter() +\n+            \"44}\";\n+        String actual = RealVectorFormat.formatRealVector(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    public void testNan() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN});\n+        String expected = \"{(NaN); (NaN); (NaN)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testPositiveInfinity() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {\n+                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n+        });\n+        String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void tesNegativeInfinity() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {\n+                Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n+        });\n+        String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"{1; 1; 1}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseIgnoredWhitespace() {\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"{1;1;1}\";\n+        assertEquals(expected, realVectorFormat.parseObject(source1, pos1));\n+        assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" { 1 ; 1 ; 1 } \";\n+        assertEquals(expected, realVectorFormat.parseObject(source2, pos2));\n+        assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeX() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeY() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeZ() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, -1.4343, -1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroX() {\n+        String source =\n+            \"{0\" + getDecimalCharacter() +\n+            \"0; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {0.0, -1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormatSquare.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"{(NaN); (NaN); (NaN)}\";\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"{(Infinity); (Infinity); (Infinity)}\";\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); \n+            assertEquals(new RealVectorImpl(new double[] {\n+                    Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n+            }), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeInfinity() {\n+        String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); \n+            assertEquals(new RealVectorImpl(new double[] {\n+                    Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n+            }), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNoComponents() {\n+        try {\n+            realVectorFormat.parseObject(\"{ }\");\n+        } catch (ParseException pe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testParseManyComponents() throws ParseException {\n+        RealVectorImpl parsed =\n+            (RealVectorImpl) realVectorFormat.parseObject(\"{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}\");\n+        assertEquals(24, parsed.getDimension());\n+    }\n+\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        RealVectorFormat cf = new RealVectorFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getFormat());\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            CompositeFormat cf = new RealVectorFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"1; 1; 1}\", pos));\n+        assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"{1; 1 1}\", pos));\n+        assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"{1; 1; 1 \", pos));\n+        assertEquals(8, pos.getErrorIndex());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/RealVectorFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Locale;\n+\n+\n+public class RealVectorFormatTest extends RealVectorFormatAbstractTest {\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link RealVectorImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class RealVectorImplTest extends TestCase {\n+\n+    // \n+    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n+    protected double[] vec1 = {1d, 2d, 3d};\n+    protected double[] vec2 = {4d, 5d, 6d};\n+    protected double[] vec3 = {7d, 8d, 9d};\n+    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[] vec_null = {0d, 0d, 0d};\n+    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    // Testclass to test the RealVector interface \n+    // only with enough content to support the test\n+    public class RealVectorTestImpl implements RealVector, Serializable {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 8731816072271374422L;\n+\n+        /** Entries of the vector. */\n+        protected double data[];\n+\n+        public RealVectorTestImpl(double[] d) {\n+            data = d.clone();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public RealVector copy() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAdd(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAddToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtract(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtractToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapMultiply(double d) {\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * d;\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+\n+        public RealVector mapMultiplyToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivide(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivideToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPow(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPowToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLogToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1p() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1pToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCoshToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbs() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbsToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeil() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeilToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloor() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloorToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRint() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRintToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignum() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignumToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double[] getData() {\n+            throw unsupported();\n+        }\n+\n+        public double dotProduct(RealVector v) throws IllegalArgumentException {\n+\n+            //\tcheckVectorDimensions(v);\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector unitVector() {\n+            throw unsupported();\n+        }\n+\n+        public void unitize() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector get(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(double value) {\n+            throw unsupported();\n+        }\n+\n+        public double[] toArray() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RealVectorImplTest.class);\n+        suite.setName(\"RealVectorImpl Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        RealVectorImpl v0 = new RealVectorImpl();\n+        assertEquals(\"testData len\", 0, v0.getDimension());\n+\n+        RealVectorImpl v1 = new RealVectorImpl(7);\n+        assertEquals(\"testData len\", 7, v1.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+\n+        RealVectorImpl v2 = new RealVectorImpl(5, 1.23);\n+        assertEquals(\"testData len\", 5, v2.getDimension());\n+        assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4));\n+\n+        RealVectorImpl v3 = new RealVectorImpl(vec1);\n+        assertEquals(\"testData len\", 3, v3.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+\n+        RealVectorImpl v4 = new RealVectorImpl(vec4, 3, 2);\n+        assertEquals(\"testData len\", 2, v4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        try {\n+            new RealVectorImpl(vec4, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVector v5_i = new RealVectorImpl(dvec1);\n+        assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+\n+        RealVectorImpl v5 = new RealVectorImpl(dvec1);\n+        assertEquals(\"testData len\", 9, v5.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+\n+        RealVectorImpl v6 = new RealVectorImpl(dvec1, 3, 2);\n+        assertEquals(\"testData len\", 2, v6.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0));\n+        try {\n+            new RealVectorImpl(dvec1, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v7 = new RealVectorImpl(v1);\n+        assertEquals(\"testData len\", 7, v7.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+\n+        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);\n+\n+        RealVectorImpl v7_2 = new RealVectorImpl(v7_i);\n+        assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+\n+        RealVectorImpl v8 = new RealVectorImpl(v1, true);\n+        assertEquals(\"testData len\", 7, v8.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n+        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        RealVectorImpl v8_2 = new RealVectorImpl(v1, false);\n+        assertEquals(\"testData len\", 7, v8_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8_2.getEntry(6));\n+        assertEquals(\"testData same object \", v1.data, v8_2.data);\n+\n+        RealVectorImpl v9 = new RealVectorImpl(v1, v3);\n+        assertEquals(\"testData len\", 10, v9.getDimension());\n+        assertEquals(\"testData is 1.0 \", 1.0, v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+        RealVectorImpl v2 = new RealVectorImpl(vec2);\n+        RealVectorImpl v4 = new RealVectorImpl(vec4);\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        RealVector v_append_1 = v1.append(v2);\n+        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+\n+        RealVector v_append_2 = v1.append(2.0);\n+        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+\n+        RealVector v_append_3 = v1.append(vec2);\n+        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+\n+        RealVector v_append_4 = v1.append(v2_t);\n+        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+\n+        RealVector v_copy = v1.copy();\n+        assertEquals(\"testData len\", 3, v_copy.getDimension());\n+        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+\n+        double[] a_double = v1.toArray();\n+        assertEquals(\"testData len\", 3, a_double.length);\n+        assertNotSame(\"testData not same object \", v1.data, a_double);\n+\n+\n+//      RealVectorImpl vout4 = (RealVectorImpl) v1.clone();\n+//      assertEquals(\"testData len\", 3, vout4.getDimension());\n+//      assertEquals(\"testData not same object \", v1.data, vout4.data);\n+\n+\n+        RealVector vout5 = v4.get(3, 3);\n+        assertEquals(\"testData len\", 3, vout5.getDimension());\n+        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        try {\n+            v4.get(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set1 = (RealVectorImpl) v1.copy();\n+        v_set1.set(1, 11.0);\n+        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        try {\n+            v_set1.set(3, 11.0);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set2 = (RealVectorImpl) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set3 = (RealVectorImpl) v1.copy();\n+        v_set3.set(13.0);\n+        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"ArrayIndexOutOfBoundsException expected\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set4 = (RealVectorImpl) v4.copy();\n+        v_set4.set(3, v2_t);\n+        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        try {\n+            v_set4.set(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        RealVectorImpl vout10 = (RealVectorImpl) v1.copy();       \n+        RealVectorImpl vout10_2 = (RealVectorImpl) v1.copy();\n+        assertEquals(vout10, vout10_2);\n+        vout10_2.set(0, 1.1);\n+        assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAdd = v1.mapAdd(2.0d);\n+        double[] result_mapAdd = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData(),normTolerance);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(2.0d);\n+        double[] result_mapAddToSelf = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtract = v1.mapSubtract(2.0d);\n+        double[] result_mapSubtract = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);\n+        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiply = v1.mapMultiply(2.0d);\n+        double[] result_mapMultiply = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);\n+        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivide = v1.mapDivide(2.0d);\n+        double[] result_mapDivide = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(2.0d);\n+        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPow = v1.mapPow(2.0d);\n+        double[] result_mapPow = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPow,v_mapPow.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPowToSelf = v1.copy();\n+        v_mapPowToSelf.mapPowToSelf(2.0d);\n+        double[] result_mapPowToSelf = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExp = v1.mapExp();\n+        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExpToSelf = v1.copy();\n+        v_mapExpToSelf.mapExpToSelf();\n+        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n+\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1 = v1.mapExpm1();\n+        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1ToSelf = v1.copy();\n+        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog = v1.mapLog();\n+        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLogToSelf = v1.copy();\n+        v_mapLogToSelf.mapLogToSelf();\n+        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n+\n+        //octave =  log10(v1)\n+        RealVector v_mapLog10 = v1.mapLog10();\n+        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog10ToSelf = v1.copy();\n+        v_mapLog10ToSelf.mapLog10ToSelf();\n+        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1p = v1.mapLog1p();\n+        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1pToSelf = v1.copy();\n+        v_mapLog1pToSelf.mapLog1pToSelf();\n+        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCosh = v1.mapCosh();\n+        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCoshToSelf = v1.copy();\n+        v_mapCoshToSelf.mapCoshToSelf();\n+        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinh = v1.mapSinh();\n+        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinhToSelf = v1.copy();\n+        v_mapSinhToSelf.mapSinhToSelf();\n+        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanh = v1.mapTanh();\n+        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanhToSelf = v1.copy();\n+        v_mapTanhToSelf.mapTanhToSelf();\n+        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCos = v1.mapCos();\n+        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCosToSelf = v1.copy();\n+        v_mapCosToSelf.mapCosToSelf();\n+        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSin = v1.mapSin();\n+        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSinToSelf = v1.copy();\n+        v_mapSinToSelf.mapSinToSelf();\n+        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTan = v1.mapTan();\n+        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTanToSelf = v1.copy();\n+        v_mapTanToSelf.mapTanToSelf();\n+        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n+\n+        double[] vat_a = {0d, 0.5d, 1.0d};\n+        RealVectorImpl vat = new RealVectorImpl(vat_a);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcos = vat.mapAcos();\n+        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcosToSelf = vat.copy();\n+        v_mapAcosToSelf.mapAcosToSelf();\n+        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsin = vat.mapAsin();\n+        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsinToSelf = vat.copy();\n+        v_mapAsinToSelf.mapAsinToSelf();        \n+        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtan = vat.mapAtan();\n+        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtanToSelf = vat.copy();\n+        v_mapAtanToSelf.mapAtanToSelf();\n+        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInv = v1.mapInv();\n+        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n+\n+        double[] abs_a = {-1.0d, 0.0d, 1.0d};\n+        RealVectorImpl abs_v = new RealVectorImpl(abs_a);\n+\n+        //octave =  abs(abs_v)\n+        RealVector v_mapAbs = abs_v.mapAbs();\n+        double[] result_mapAbs = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n+\n+        //octave = abs(abs_v)\n+        RealVector v_mapAbsToSelf = abs_v.copy();\n+        v_mapAbsToSelf.mapAbsToSelf();\n+        double[] result_mapAbsToSelf = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n+\n+        //octave =   sqrt(v1)\n+        RealVector v_mapSqrt = v1.mapSqrt();\n+        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n+\n+        //octave =  sqrt(v1)\n+        RealVector v_mapSqrtToSelf = v1.copy();\n+        v_mapSqrtToSelf.mapSqrtToSelf();\n+        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n+\n+        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};\n+        RealVectorImpl cbrt_v = new RealVectorImpl(cbrt_a);\n+\n+        //octave =  ???\n+        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapCbrtToSelf = cbrt_v.copy();\n+        v_mapCbrtToSelf.mapCbrtToSelf();\n+        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n+\n+        double[] ceil_a = {-1.1d, 0.9d, 1.1d};\n+        RealVectorImpl ceil_v = new RealVectorImpl(ceil_a);\n+\n+        //octave =  ceil(ceil_v)\n+        RealVector v_mapCeil = ceil_v.mapCeil();\n+        double[] result_mapCeil = {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n+\n+        //octave = ceil(ceil_v)\n+        RealVector v_mapCeilToSelf = ceil_v.copy();\n+        v_mapCeilToSelf.mapCeilToSelf();\n+        double[] result_mapCeilToSelf =  {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n+\n+        //octave =  floor(ceil_v)\n+        RealVector v_mapFloor = ceil_v.mapFloor();\n+        double[] result_mapFloor = {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n+\n+        //octave = floor(ceil_v)\n+        RealVector v_mapFloorToSelf = ceil_v.copy();\n+        v_mapFloorToSelf.mapFloorToSelf();\n+        double[] result_mapFloorToSelf =  {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapRint = ceil_v.mapRint();\n+        double[] result_mapRint = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapRintToSelf = ceil_v.copy();\n+        v_mapRintToSelf.mapRintToSelf();\n+        double[] result_mapRintToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapSignum = ceil_v.mapSignum();\n+        double[] result_mapSignum = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapSignumToSelf = ceil_v.copy();\n+        v_mapSignumToSelf.mapSignumToSelf();\n+        double[] result_mapSignumToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n+\n+\n+        // Is with the used resolutions of limited value as test\n+        //octave =  ???\n+        RealVector v_mapUlp = ceil_v.mapUlp();\n+        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapUlpToSelf = ceil_v.copy();\n+        v_mapUlpToSelf.mapUlpToSelf();\n+        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+        RealVectorImpl v2 = new RealVectorImpl(vec2);\n+        RealVectorImpl v_null = new RealVectorImpl(vec_null);\n+\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        //octave =  sqrt(sumsq(v1))\n+        double d_getNorm = v1.getNorm();\n+        assertEquals(\"compare values  \", 3.7416573867739413,d_getNorm);\n+\n+        double d_getL1Norm = v1.getL1Norm();\n+        assertEquals(\"compare values  \",6.0, d_getL1Norm);\n+\n+        double d_getLInfNorm = v1.getLInfNorm();\n+        assertEquals(\"compare values  \",6.0, d_getLInfNorm);\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist = v1.getDistance(v2);\n+        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist_2 = v1.getDistance(v2_t);\n+        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+\n+        //octave =  ???\n+        double d_getL1Distance = v1. getL1Distance(v2);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance );\n+\n+        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n+\n+        //octave =  ???\n+        double d_getLInfDistance = v1. getLInfDistance(v2);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+\n+        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+\n+        //octave =  v1 + v2\n+        RealVectorImpl v_add = v1.add(v2);\n+        double[] result_add = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n+\n+        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n+        RealVector v_add_i = v1.add(vt2);\n+        double[] result_add_i = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n+\n+        //octave =  v1 - v2\n+        RealVectorImpl v_subtract = v1.subtract(v2);\n+        double[] result_subtract = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        RealVector v_subtract_i = v1.subtract(vt2);\n+        double[] result_subtract_i = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        RealVectorImpl  v_ebeMultiply = v1.ebeMultiply(v2);\n+        double[] result_ebeMultiply = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        RealVectorImpl  v_ebeDivide = v1.ebeDivide(v2);\n+        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        double dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",32d, dot);\n+\n+        // octave  dot(v1,v2_t)\n+        double dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",32d, dot_2);\n+\n+        RealMatrixImpl m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+\n+        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+\n+        RealVector v_unitVector = v1.unitVector();\n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n+\n+        try {\n+            v_null.unitVector();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_unitize = (RealVectorImpl)v1.copy();\n+        v_unitize.unitize();\n+        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n+        try {\n+            v_null.unitize();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_projection = v1.projection(v2);\n+        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n+\n+        RealVector v_projection_2 = v1.projection(v2_t);\n+        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n+\n+    }  \n+\n+    public void testMisc() { \n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+        RealVectorImpl v4 = new RealVectorImpl(vec4);\n+        RealVector v4_2 = new RealVectorImpl(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         double[] dout1 = v1.copyOut();\n+        assertEquals(\"testData len\", 3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+       try {\n+            v1.checkVectorDimensions(v4); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+        try {\n+            v1.checkVectorDimensions(v4_2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        RealVectorImpl v = new RealVectorImpl(new double[] { 0, 1, 2 });\n+\n+        assertFalse(v.isNaN());\n+        v.set(1, Double.NaN);\n+        assertTrue(v.isNaN());\n+\n+        assertFalse(v.isInfinite());\n+        v.set(0, Double.POSITIVE_INFINITY);\n+        assertFalse(v.isInfinite());\n+        v.set(1, 1);\n+        assertTrue(v.isInfinite());\n+\n+        v.set(0, 0);\n+        assertEquals(v, new RealVectorImpl(new double[] { 0, 1, 2 }));\n+        assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2, 3 }));\n+\n+        assertEquals(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode(),\n+                     new RealVectorImpl(new double[] { 0, Double.NaN, 2 }).hashCode());\n+\n+        assertTrue(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n+                   new RealVectorImpl(new double[] { 0, 1, 2 }).hashCode());\n+\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+        }\n+    }\n+\n+}", "timestamp": 1217186122, "metainfo": ""}