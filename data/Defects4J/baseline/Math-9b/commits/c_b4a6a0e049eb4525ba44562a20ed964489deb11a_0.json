{"sha": "b4a6a0e049eb4525ba44562a20ed964489deb11a", "log": "Added an utility equality method between double numbers using tolerance in ulps (Units in Last Position)  JIRA: MATH-264  ", "commit": "\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n \n     /** 2 &pi;. */\n     private static final double TWO_PI = 2 * Math.PI;\n+\n+    private static final int NAN_GAP = 4 * 1024 * 1024;\n+    private static final long SGN_MASK = 0x8000000000000000L;\n \n     /**\n      * Private Constructor\n       return equals(x, y) || (Math.abs(y - x) <= eps);\n     }\n     \n+    /**\n+     * Returns true iff both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if there are less than {@code maxUlps} floating\n+     * point values between {@code x} and {@code y}\n+     */\n+    public static boolean equals(double x, double y, int maxUlps) {\n+        // Check that \"maxUlps\" is non-negative and small enough so that the\n+        // default NAN won't compare as equal to anything.\n+        assert maxUlps > 0 && maxUlps < NAN_GAP;\n+\n+        long xInt = Double.doubleToLongBits(x);\n+        long yInt = Double.doubleToLongBits(y);\n+\n+        // Make lexicographically ordered as a two's-complement integer.\n+        if (xInt < 0) {\n+            xInt = SGN_MASK - xInt;\n+        }\n+        if (yInt < 0) {\n+            yInt = SGN_MASK - yInt;\n+        }\n+\n+        return Math.abs(xInt - yInt) <= maxUlps;\n+    }\n+\n     /**\n      * Returns true iff both arguments are null or have same dimensions\n      * and all their elements are {@link #equals(double,double) equals}\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n         assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));\n         assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));\n     }\n+\n+    public void testEqualsWithAllowedUlps() {\n+        assertTrue(MathUtils.equals(153, 153, 1));\n+\n+        assertTrue(MathUtils.equals(153, 153.00000000000003, 1));\n+        assertFalse(MathUtils.equals(153, 153.00000000000006, 1));\n+        assertTrue(MathUtils.equals(153, 152.99999999999997, 1));\n+        assertFalse(MathUtils.equals(153, 152.99999999999994, 1));\n+        \n+        assertTrue(MathUtils.equals(-128, -127.99999999999999, 1));\n+        assertFalse(MathUtils.equals(-128, -127.99999999999997, 1));\n+        assertTrue(MathUtils.equals(-128, -128.00000000000003, 1));\n+        assertFalse(MathUtils.equals(-128, -128.00000000000006, 1));\n+\n+        assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+\n+        assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n+\n+\n+        assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1));\n+\n+        assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n+    }\n     \n     public void testArrayEquals() {\n         assertFalse(MathUtils.equals(new double[] { 1d }, null));", "timestamp": 1241030039, "metainfo": ""}