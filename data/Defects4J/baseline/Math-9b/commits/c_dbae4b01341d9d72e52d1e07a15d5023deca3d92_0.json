{"sha": "dbae4b01341d9d72e52d1e07a15d5023deca3d92", "log": "renamed RealMatrixImpl, RealVectorImpl, FieldMatrixImpl and FieldVectorImpl into Array2DRowRealMatrix, ArrayRealVector, Array2DRowFieldMatrix and ArrayFieldVector as suggested by Sam in http://markmail.org/message/hh37ivxpzaoapekj  ", "commit": "\n--- a/src/experimental/org/apache/commons/math/linear/CholeskySolver.java\n+++ b/src/experimental/org/apache/commons/math/linear/CholeskySolver.java\n     private double numericalZero = 10E-12;\n     \n     /** The lower triangular matrix */\n-    private RealMatrixImpl decompMatrix;\n+    private Array2DRowRealMatrix decompMatrix;\n     \n    \n     /** \n            \n        }//for all columns\n        \n-       decompMatrix = new RealMatrixImpl(decomp);\n+       decompMatrix = new Array2DRowRealMatrix(decomp);\n        \n     }//decompose\n     \n      * Caution: Every call of this Method will return the same object.\n      * Decomposing another matrix will generate a new one.\n      */\n-    public RealMatrixImpl getDecomposition() {\n+    public Array2DRowRealMatrix getDecomposition() {\n         return decompMatrix;\n     }//getDecomposition\n     \n--- a/src/experimental/org/apache/commons/math/linear/CholeskySolverTest.java\n+++ b/src/experimental/org/apache/commons/math/linear/CholeskySolverTest.java\n         \n         try {\n             solver.decompose(\n-                new RealMatrixImpl(new double[][]{{numericalZero/2, 0},\n+                new Array2DRowRealMatrix(new double[][]{{numericalZero/2, 0},\n                                                   {0, numericalZero/2}}));\n             fail(\"testing numericalZero\");\n         } catch (IllegalArgumentException e) {}\n         \n          try {\n              CholeskySolver solver = new CholeskySolver();\n-             solver.decompose(new RealMatrixImpl(m7));\n+             solver.decompose(new Array2DRowRealMatrix(m7));\n              fail(\"Decomposing matrix m7\"); \n         } catch (IllegalArgumentException e) {}\n         \n \n          try {\n              CholeskySolver solver = new CholeskySolver();\n-             solver.solve(new RealMatrixImpl(m3), new double[] {1, 2, 3, 4});\n+             solver.solve(new Array2DRowRealMatrix(m3), new double[] {1, 2, 3, 4});\n              fail(\"Solving matrix m3[3x3], v[4]\"); \n         } catch (IllegalArgumentException e) {}\n         \n     private void testDecompose(double[][] lowerTriangularMatrix, String message) \n     throws IllegalArgumentException {\n     \n-        RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);\n+        RealMatrix triangularMatrix = new Array2DRowRealMatrix(lowerTriangularMatrix);\n         RealMatrix pdMatrix = \n             triangularMatrix.multiply(triangularMatrix.transpose());\n         \n     private void testSolve(double[][] lowerTriangularMatrix, String message)  {\n       \n         RealMatrix triangularMatrix = \n-            new RealMatrixImpl(lowerTriangularMatrix);\n-        RealMatrixImpl pdMatrix = \n-            (RealMatrixImpl) triangularMatrix.multiply(triangularMatrix.transpose());\n+            new Array2DRowRealMatrix(lowerTriangularMatrix);\n+        Array2DRowRealMatrix pdMatrix = \n+            (Array2DRowRealMatrix) triangularMatrix.multiply(triangularMatrix.transpose());\n         CholeskySolver solver = \n             new CholeskySolver();\n         \n                 c[i] += lowerTriangularMatrix[i][j];\n         \n         solver.decompose(pdMatrix);\n-        RealMatrix x = new RealMatrixImpl(solver.solve(c));\n+        RealMatrix x = new Array2DRowRealMatrix(solver.solve(c));\n \n         assertTrue(message, \n-            areEqual(pdMatrix.multiply(x),  new RealMatrixImpl(c), 1.0E-10));\n+            areEqual(pdMatrix.multiply(x),  new Array2DRowRealMatrix(c), 1.0E-10));\n     }//testSolve\n \n     \n                                     String message) \n     throws IllegalArgumentException {\n     \n-        RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);\n+        RealMatrix triangularMatrix = new Array2DRowRealMatrix(lowerTriangularMatrix);\n         RealMatrix pdMatrix = \n             triangularMatrix.multiply(triangularMatrix.transpose());\n         double pdDeterminant = determinant * determinant;\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n  */\n package org.apache.commons.math;\n \n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n /**\n  * Exception thrown when an error occurs evaluating a function.\n      * @since 2.0\n      */\n     public FunctionEvaluationException(double[] argument) {\n-        super(\"evaluation failed for argument = {0}\", new RealVectorImpl(argument));\n+        super(\"evaluation failed for argument = {0}\", new ArrayRealVector(argument));\n         this.argument = argument.clone();\n     }\n     \n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.linear.decomposition.LUDecompositionImpl\n     // org.apache.commons.math.linear.decomposition.QRDecompositionImpl\n     // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl\n-    // org.apache.commons.math.linear.RealVectorImpl\n+    // org.apache.commons.math.linear.ArrayRealVector\n     // org.apache.commons.math.linear.SparseRealVector\n     { \"vector length mismatch: got {0} but expected {1}\",\n       \"dimension de vecteur erronn\\u00e9e : {0} \\u00e0 la place de {1}\" },\n       \n-    // org.apache.commons.math.linear.RealVectorImpl\n-    // org.apache.commons.math.linear.FieldVectorImpl\n+    // org.apache.commons.math.linear.ArrayRealVector\n+    // org.apache.commons.math.linear.ArrayFieldVector\n     // org.apache.commons.math.linear.SparseRealVector\n     { \"index {0} out of allowed range [{1}, {2}]\",\n       \"index {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n      \"norme nulle pour un axe de d\\u00e9finition de rotation\" },\n \n    // org.apache.commons.math.geometry.Vector3D\n-   // org.apache.commons.math.linear.RealVectorImpl\n+   // org.apache.commons.math.linear.ArrayRealVector\n    { \"cannot normalize a zero norm vector\",\n      \"impossible de normer un vecteur de norme nulle\" },\n    { \"zero norm\",\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n /** \n  * This class implements a solver for estimation problems.\n \n         // work matrices\n         double[] grad             = new double[parameters.length];\n-        RealVectorImpl bDecrement = new RealVectorImpl(parameters.length);\n+        ArrayRealVector bDecrement = new ArrayRealVector(parameters.length);\n         double[] bDecrementData   = bDecrement.getDataRef();\n         RealMatrix wGradGradT     = MatrixUtils.createRealMatrix(parameters.length, parameters.length);\n \n \n             // build the linear problem\n             incrementJacobianEvaluationsCounter();\n-            RealVector b = new RealVectorImpl(parameters.length);\n+            RealVector b = new ArrayRealVector(parameters.length);\n             RealMatrix a = MatrixUtils.createRealMatrix(parameters.length, parameters.length);\n             for (int i = 0; i < measurements.length; ++i) {\n                 if (! measurements [i].isIgnored()) {\n--- a/src/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n     /** {@inheritDoc} */\n     public FieldVector<T> getRowVector(final int row)\n         throws MatrixIndexException {\n-        return new FieldVectorImpl<T>(getRow(row), false);\n+        return new ArrayFieldVector<T>(getRow(row), false);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public FieldVector<T> getColumnVector(final int column)\n         throws MatrixIndexException {\n-        return new FieldVectorImpl<T>(getColumn(column), false);\n+        return new ArrayFieldVector<T>(getColumn(column), false);\n     }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> operate(final FieldVector<T> v)\n         throws IllegalArgumentException {\n         try {\n-            return new FieldVectorImpl<T>(operate(((FieldVectorImpl<T>) v).getDataRef()), false);\n+            return new ArrayFieldVector<T>(operate(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n                 out[row] = sum;\n             }\n \n-            return new FieldVectorImpl<T>(out, false);\n+            return new ArrayFieldVector<T>(out, false);\n         }\n     }\n \n     public FieldVector<T> preMultiply(final FieldVector<T> v)\n         throws IllegalArgumentException {\n         try {\n-            return new FieldVectorImpl<T>(preMultiply(((FieldVectorImpl<T>) v).getDataRef()), false);\n+            return new ArrayFieldVector<T>(preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n \n             final int nRows = getRowDimension();\n                 out[col] = sum;\n             }\n \n-            return new FieldVectorImpl<T>(out);\n+            return new ArrayFieldVector<T>(out);\n \n         }\n     }\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     /** {@inheritDoc} */\n     public RealVector getRowVector(final int row)\n         throws MatrixIndexException {\n-        return new RealVectorImpl(getRow(row), false);\n+        return new ArrayRealVector(getRow(row), false);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public RealVector getColumnVector(final int column)\n         throws MatrixIndexException {\n-        return new RealVectorImpl(getColumn(column), false);\n+        return new ArrayRealVector(getColumn(column), false);\n     }\n \n     /** {@inheritDoc} */\n     public RealVector operate(final RealVector v)\n         throws IllegalArgumentException {\n         try {\n-            return new RealVectorImpl(operate(((RealVectorImpl) v).getDataRef()), false);\n+            return new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n                 out[row] = sum;\n             }\n \n-            return new RealVectorImpl(out, false);\n+            return new ArrayRealVector(out, false);\n         }\n     }\n \n     public RealVector preMultiply(final RealVector v)\n         throws IllegalArgumentException {\n         try {\n-            return new RealVectorImpl(preMultiply(((RealVectorImpl) v).getDataRef()), false);\n+            return new ArrayRealVector(preMultiply(((ArrayRealVector) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n \n             final int nRows = getRowDimension();\n                 out[col] = sum;\n             }\n \n-            return new RealVectorImpl(out);\n+            return new ArrayRealVector(out);\n \n         }\n     }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of FieldMatrix<T> using a {@link FieldElement}[][] array to store entries.\n+ * <p>\n+ * As specified in the {@link FieldMatrix} interface, matrix element indexing\n+ * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</li></ul>\n+ * </p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ */\n+public class Array2DRowFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7260756672015356458L;\n+\n+    /** Entries of the matrix */\n+    protected T[][] data;\n+\n+    /**\n+     * Creates a matrix with no data\n+     * @param field field to which the elements belong\n+     */\n+    public Array2DRowFieldMatrix(final Field<T> field) {\n+        super(field);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public Array2DRowFieldMatrix(final Field<T> field,\n+                           final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(field, rowDimension, columnDimension);\n+        data = buildArray(field, rowDimension, columnDimension);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * data array.\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #Array2DRowFieldMatrix(FieldElement[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowFieldMatrix(FieldElement[][], boolean)\n+     */\n+    public Array2DRowFieldMatrix(final T[][] d)\n+        throws IllegalArgumentException, NullPointerException {\n+        super(extractField(d));\n+        copyIn(d);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * FieldMatrix<T> and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowFieldMatrix(FieldElement[][])\n+     */\n+    public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray)\n+        throws IllegalArgumentException, NullPointerException {\n+        super(extractField(d));\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, d[r].length);\n+                }\n+            }       \n+            data = d;\n+        }\n+    }\n+\n+    /**\n+     * Create a new (column) FieldMatrix<T> using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix\n+     * created.\n+     * <p>The input array is copied, not referenced.</p>\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public Array2DRowFieldMatrix(final T[] v) {\n+        super(extractField(v));\n+        final int nRows = v.length;\n+        data = buildArray(getField(), nRows, 1);\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new Array2DRowFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+        return new Array2DRowFieldMatrix<T>(copyOut(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> add(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((Array2DRowFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final T[][] outData = buildArray(getField(), rowCount, columnCount);\n+        for (int row = 0; row < rowCount; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] mRow       = m.data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].add(mRow[col]);\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((Array2DRowFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.subtract(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final T[][] outData = buildArray(getField(), rowCount, columnCount);\n+        for (int row = 0; row < rowCount; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] mRow       = m.data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((Array2DRowFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.multiply(m);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public Array2DRowFieldMatrix<T> multiply(final Array2DRowFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final T[][] outData = buildArray(getField(), nRows, nCols);\n+        for (int row = 0; row < nRows; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < nCols; col++) {\n+                T sum = getField().getZero();\n+                for (int i = 0; i < nSum; i++) {\n+                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n+                }\n+                outDataRow[col] = sum;\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[][] getData() {\n+        return copyOut();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public T[][] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) \n+    throws MatrixIndexException {\n+        if (data == null) {\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n+            }\n+            final int nRows = subMatrix.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n+            final int nCols = subMatrix[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            data = buildArray(getField(), subMatrix.length, nCols);\n+            for (int i = 0; i < data.length; ++i) {\n+                if (subMatrix[i].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, subMatrix[i].length); \n+                }\n+                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n+            }\n+        } else {\n+            super.setSubMatrix(subMatrix, row, column);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = data[row][column].add(increment);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = data[row][column].multiply(factor);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return (data == null) ? 0 : data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+        final T[] out = buildArray(getField(), nRows);\n+        for (int row = 0; row < nRows; row++) {\n+            final T[] dataRow = data[row];\n+            T sum = getField().getZero();\n+            for (int i = 0; i < nCols; i++) {\n+                sum = sum.add(dataRow[i].multiply(v[i]));\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final T[] out = buildArray(getField(), nCols);\n+        for (int col = 0; col < nCols; ++col) {\n+            T sum = getField().getZero();\n+            for (int i = 0; i < nRows; ++i) {\n+                sum = sum.add(data[i][col].multiply(v[i]));\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                final T[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                final T[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private T[][] copyOut() {\n+        final int nRows = this.getRowDimension();\n+        final T[][] out = buildArray(getField(), nRows, getColumnDimension());\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     * <p>\n+     * Verifies that the input array is rectangular and non-empty.</p>\n+     *\n+     * @param in data to copy in\n+     * @throws IllegalArgumentException if input array is empty or not\n+     *    rectangular\n+     * @throws NullPointerException if input array is null\n+     */\n+    private void copyIn(final T[][] in) {\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of RealMatrix using a double[][] array to store entries and\n+ * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+ * LU decomposition</a> to support linear system\n+ * solution and inverse.\n+ * <p>\n+ * The LU decomposition is performed as needed, to support the following operations: <ul>\n+ * <li>solve</li>\n+ * <li>isSingular</li>\n+ * <li>getDeterminant</li>\n+ * <li>inverse</li> </ul></p>\n+ * <p>\n+ * <strong>Usage notes</strong>:<br>\n+ * <ul><li>\n+ * The LU decomposition is cached and reused on subsequent calls.   \n+ * If data are modified via references to the underlying array obtained using\n+ * <code>getDataRef()</code>, then the stored LU decomposition will not be\n+ * discarded.  In this case, you need to explicitly invoke \n+ * <code>LUDecompose()</code> to recompute the decomposition\n+ * before using any of the methods above.</li>\n+ * <li>\n+ * As specified in the {@link RealMatrix} interface, matrix element indexing\n+ * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</li></ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Array2DRowRealMatrix extends AbstractRealMatrix implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1067294169172445528L;\n+\n+    /** Entries of the matrix */\n+    protected double data[][];\n+\n+    /**\n+     * Creates a matrix with no data\n+     */\n+    public Array2DRowRealMatrix() {\n+    }\n+\n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(rowDimension, columnDimension);\n+        data = new double[rowDimension][columnDimension];\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowRealMatrix(double[][], boolean)\n+     */\n+    public Array2DRowRealMatrix(final double[][] d)\n+        throws IllegalArgumentException, NullPointerException {\n+        copyIn(d);\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowRealMatrix(double[][])\n+     */\n+    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n+        throws IllegalArgumentException, NullPointerException {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, d[r].length);\n+                }\n+            }       \n+            data = d;\n+        }\n+    }\n+\n+    /**\n+     * Create a new (column) RealMatrix using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix\n+     * created.\n+     * <p>The input array is copied, not referenced.</p>\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public Array2DRowRealMatrix(final double[] v) {\n+        final int nRows = v.length;\n+        data = new double[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix copy() {\n+        return new Array2DRowRealMatrix(copyOut(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((Array2DRowRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowRealMatrix add(final Array2DRowRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col] + mRow[col];\n+            }\n+        }\n+\n+        return new Array2DRowRealMatrix(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((Array2DRowRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.subtract(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col] - mRow[col];\n+            }\n+        }\n+\n+        return new Array2DRowRealMatrix(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((Array2DRowRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.multiply(m);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final double[][] outData = new double[nRows][nCols];\n+        for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < nCols; col++) {\n+                double sum = 0;\n+                for (int i = 0; i < nSum; i++) {\n+                    sum += dataRow[i] * m.data[i][col];\n+                }\n+                outDataRow[col] = sum;\n+            }\n+        }\n+\n+        return new Array2DRowRealMatrix(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[][] getData() {\n+        return copyOut();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public double[][] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+    throws MatrixIndexException {\n+        if (data == null) {\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n+            }\n+            final int nRows = subMatrix.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n+            final int nCols = subMatrix[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            data = new double[subMatrix.length][nCols];\n+            for (int i = 0; i < data.length; ++i) {\n+                if (subMatrix[i].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, subMatrix[i].length); \n+                }\n+                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n+            }\n+        } else {\n+            super.setSubMatrix(subMatrix, row, column);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] += increment;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] *= factor;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return (data == null) ? 0 : data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+        final double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n+            double sum = 0;\n+            for (int i = 0; i < nCols; i++) {\n+                sum += dataRow[i] * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final double[] out = new double[nCols];\n+        for (int col = 0; col < nCols; ++col) {\n+            double sum = 0;\n+            for (int i = 0; i < nRows; ++i) {\n+                sum += data[i][col] * v[i];\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private double[][] copyOut() {\n+        final int nRows = this.getRowDimension();\n+        final double[][] out = new double[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     * <p>\n+     * Verifies that the input array is rectangular and non-empty.</p>\n+     *\n+     * @param in data to copy in\n+     * @throws IllegalArgumentException if input array is empty or not\n+     *    rectangular\n+     * @throws NullPointerException if input array is null\n+     */\n+    private void copyIn(final double[][] in) {\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * This class implements the {@link FieldVector} interface with a {@link FieldElement} array.\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7648186910365927050L;\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /** Entries of the vector. */\n+    protected T[] data;\n+\n+    /** Build an array of elements.\n+     * @param length size of the array to build\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+    }\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #ArrayFieldVector(ArrayFieldVector, ArrayFieldVector)} constructor\n+     * or one of the <code>append</code> methods ({@link #append(FieldElement[])},\n+     * {@link #add(FieldVector)}, {@link #append(ArrayFieldVector)}) to gather data\n+     * into this vector.</p>\n+     * @param field field to which the elements belong\n+     */\n+    public ArrayFieldVector(final Field<T> field) {\n+        this(field, 0);\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param field field to which the elements belong\n+     * @param size size of the vector\n+     */\n+    public ArrayFieldVector(Field<T> field, int size) {\n+        this.field = field;\n+        data = buildArray(size);\n+        Arrays.fill(data, field.getZero());\n+    }\n+\n+    /**\n+     * Construct an (size)-length vector with preset values.\n+     * @param size size of the vector\n+     * @param preset fill the vector with this scalar value\n+     */\n+    public ArrayFieldVector(int size, T preset) {\n+        this(preset.getField(), size);\n+        Arrays.fill(data, preset);\n+    }\n+\n+    /**\n+     * Construct a vector from an array, copying the input array.\n+     * @param d array of Ts.\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     */\n+    public ArrayFieldVector(T[] d)\n+        throws IllegalArgumentException {\n+        try {\n+            field = d[0].getField();\n+            data = d.clone();\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\"); \n+        }\n+    }\n+\n+    /**\n+     * Create a new ArrayFieldVector using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * ArrayFieldVector and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new vector\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #ArrayFieldVector(FieldElement[])\n+     */\n+    public ArrayFieldVector(T[] d, boolean copyArray)\n+        throws NullPointerException, IllegalArgumentException {\n+        try {\n+            field = d[0].getField();\n+            data = copyArray ? d.clone() :  d;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\");\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from part of a array.\n+     * @param d array of Ts.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public ArrayFieldVector(T[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n+        }\n+        field = d[0].getField();\n+        data = buildArray(size);\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayFieldVector(FieldVector<T> v) {\n+        field = v.getField();\n+        data = buildArray(v.getDimension());\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = v.getEntry(i);\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v) {\n+        field = v.getField();\n+        data = v.data.clone();\n+    }\n+\n+    /**\n+     * Construct a vector from another vector.\n+     * @param v vector to copy\n+     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v, boolean deep) {\n+        field = v.getField();\n+        data = deep ? v.data.clone() : v.data;\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v1, ArrayFieldVector<T> v2) {\n+        field = v1.getField();\n+        data = buildArray(v1.data.length + v2.data.length);\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v1, T[] v2) {\n+        field = v1.getField();\n+        data = buildArray(v1.data.length + v2.length);\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayFieldVector(T[] v1, ArrayFieldVector<T> v2) {\n+        field = v2.getField();\n+        data = buildArray(v1.length + v2.data.length);\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     * @exception IllegalArgumentException if both vectors are empty\n+     */\n+    public ArrayFieldVector(T[] v1, T[] v2) {\n+        try {\n+            data = buildArray(v1.length + v2.length);\n+            System.arraycopy(v1, 0, data, 0, v1.length);\n+            System.arraycopy(v2, 0, data, v1.length, v2.length);\n+            field = data[0].getField();\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\");\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Field<T> getField() {\n+        return field;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> copy() {\n+        return new ArrayFieldVector<T>(this, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+        try {\n+            return add((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].add(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].add(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> add(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) add(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {\n+        try {\n+            return subtract((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].subtract(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].subtract(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) subtract(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAdd(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].add(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAddToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].add(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtract(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].subtract(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtractToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].subtract(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiply(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].multiply(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiplyToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].multiply(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapDivide(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].divide(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapDivideToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].divide(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInv() {\n+        T[] out = buildArray(data.length);\n+        final T one = field.getOne();\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = one.divide(data[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInvToSelf() {\n+        final T one = field.getOne();\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = one.divide(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeMultiply((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].multiply(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].multiply(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) ebeMultiply(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeDivide((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].divide(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].divide(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) ebeDivide(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] getData() {\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>Does not make a fresh copy of the underlying data.</p>\n+     * @return array of entries\n+     */\n+    public T[] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return dotProduct((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v.getEntry(i)));\n+            }\n+            return dot;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T dot = field.getZero();\n+        for (int i = 0; i < data.length; i++) {\n+            dot = dot.add(data[i].multiply(v[i]));\n+        }\n+        return dot;\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public T dotProduct(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return dotProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(FieldVector<T> v) {\n+        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(T[] v) {\n+        return projection(new ArrayFieldVector<T>(v, false));\n+    }\n+\n+   /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> projection(ArrayFieldVector<T> v) {\n+        return (ArrayFieldVector<T>) v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return outerProduct((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            final int m = data.length;\n+            final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < data.length; i++) {\n+                for (int j = 0; j < data.length; j++) {\n+                    out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n+                }\n+            }\n+            return out;\n+        }\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return outerProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        final int m = data.length;\n+        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, m);\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out.setEntry(i, j, data[i].multiply(v[j]));\n+            }\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T getEntry(int index) throws MatrixIndexException {\n+        return data[index];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(FieldVector<T> v) {\n+        try {\n+            return append((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            return new ArrayFieldVector<T>(this,new ArrayFieldVector<T>(v));\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public ArrayFieldVector<T> append(ArrayFieldVector<T> v) {\n+        return new ArrayFieldVector<T>(this, v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T in) {\n+        final T[] out = buildArray(data.length + 1);\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        out[data.length] = in;\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T[] in) {\n+        return new ArrayFieldVector<T>(this, in);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> getSubVector(int index, int n) {\n+        ArrayFieldVector<T> out = new ArrayFieldVector<T>(field, n);\n+        try {\n+            System.arraycopy(data, index, out.data, 0, n);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + n - 1);\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, T value) {\n+        try {\n+            data[index] = value;\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, FieldVector<T> v) {\n+        try {\n+            try {\n+                set(index, (ArrayFieldVector<T>) v);\n+            } catch (ClassCastException cce) {\n+                for (int i = index; i < index + v.getDimension(); ++i) {\n+                    data[i] = v.getEntry(i-index);\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, T[] v) {\n+        try {\n+            System.arraycopy(v, 0, data, index, v.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.length - 1);\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * \n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    public void set(int index, ArrayFieldVector<T> v)\n+        throws MatrixIndexException {\n+        setSubVector(index, v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(T value) {\n+        Arrays.fill(data, value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] toArray(){\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    protected void checkVectorDimensions(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        if (data.length != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    data.length, n);\n+        }\n+    }\n+\n+    /**\n+     * Test for the equality of two real vectors.\n+     * <p>\n+     * If all coordinates of two real vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n+     * a vector with all <code>Double.NaN</code> coordinates.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     * \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          FieldVector<T> rhs = (FieldVector<T>) other;\n+          if (data.length != rhs.getDimension()) {\n+              return false;\n+          }\n+\n+          for (int i = 0; i < data.length; ++i) {\n+              if (!data[i].equals(rhs.getEntry(i))) {\n+                  return false;\n+              }\n+          }\n+          return true;\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /**\n+     * Get a hashCode for the real vector.\n+     * <p>All NaN values have the same hash code.</p>\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        int h = 3542;\n+        for (final T a : data) {\n+            h = h ^ a.hashCode();\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/ArrayRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This class implements the {@link RealVector} interface with a double array.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ArrayRealVector implements RealVector, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1097961340710804027L;\n+\n+    /** Default format. */\n+    private static final RealVectorFormat DEFAULT_FORMAT =\n+        RealVectorFormat.getInstance();\n+\n+    /** Entries of the vector. */\n+    protected double data[];\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #ArrayRealVector(ArrayRealVector, ArrayRealVector)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(double[])}, {@link #append(ArrayRealVector)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public ArrayRealVector() {\n+        data = new double[0];\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param size size of the vector\n+     */\n+    public ArrayRealVector(int size) {\n+        data = new double[size];\n+    }\n+\n+    /**\n+     * Construct an (size)-length vector with preset values.\n+     * @param size size of the vector\n+     * @param preset fill the vector with this scalar value\n+     */\n+    public ArrayRealVector(int size, double preset) {\n+        data = new double[size];\n+        Arrays.fill(data, preset);\n+    }\n+\n+    /**\n+     * Construct a vector from an array, copying the input array.\n+     * @param d array of doubles.\n+     */\n+    public ArrayRealVector(double[] d) {\n+        data = d.clone();\n+    }\n+\n+    /**\n+     * Create a new ArrayRealVector using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * ArrayRealVector and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new vector\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #ArrayRealVector(double[])\n+     */\n+    public ArrayRealVector(double[] d, boolean copyArray)\n+        throws NullPointerException, IllegalArgumentException {\n+        if (d == null) {\n+            throw new NullPointerException();\n+        }   \n+        if (d.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\"); \n+        }\n+        data = copyArray ? d.clone() :  d;\n+    }\n+\n+    /**\n+     * Construct a vector from part of a array.\n+     * @param d array of doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public ArrayRealVector(double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n+        }\n+        data = new double[size];\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n+     * Construct a vector from an array.\n+     * @param d array of Doubles.\n+     */\n+    public ArrayRealVector(Double[] d) {\n+        data = new double[d.length];\n+        for (int i = 0; i < d.length; i++) {\n+            data[i] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from part of a Double array\n+     * @param d array of Doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public ArrayRealVector(Double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n+        }\n+        data = new double[size];\n+        for (int i = pos; i < pos + size; i++) {\n+            data[i-pos] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayRealVector(RealVector v) {\n+        data = new double[v.getDimension()];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = v.getEntry(i);\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayRealVector(ArrayRealVector v) {\n+        data = v.data.clone();\n+    }\n+\n+    /**\n+     * Construct a vector from another vector.\n+     * @param v vector to copy\n+     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     */\n+    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n+        data = deep ? v.data.clone() : v.data;\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(ArrayRealVector v1, ArrayRealVector v2) {\n+        data = new double[v1.data.length + v2.data.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(ArrayRealVector v1, double[] v2) {\n+        data = new double[v1.data.length + v2.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(double[] v1, ArrayRealVector v2) {\n+        data = new double[v1.length + v2.data.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(double[] v1, double[] v2) {\n+        data = new double[v1.length + v2.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2, 0, data, v1.length, v2.length);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector copy() {\n+        return new ArrayRealVector(this, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return add((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] + v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector add(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) add(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return subtract((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] - v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector subtract(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) subtract(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAdd(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAddToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] + d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtractToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] - d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiplyToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] * d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivide(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] / d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivideToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] / d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPow(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.pow(data[i], d);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPowToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.pow(data[i], d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.exp(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.exp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.expm1(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.expm1(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLogToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log10(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log10(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1p() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log1p(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1pToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log1p(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cosh(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCoshToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cosh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sinh(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sinh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tanh(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tanh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cos(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sin(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tan(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.acos(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.acos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.asin(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.asin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.atan(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.atan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInv() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = 1.0 / data[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInvToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = 1.0 / data[i];\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbs() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.abs(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbsToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.abs(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sqrt(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sqrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cbrt(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cbrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeil() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ceil(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeilToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ceil(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloor() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.floor(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloorToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.floor(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRint() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.rint(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRintToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.rint(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignum() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.signum(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignumToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.signum(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ulp(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ulp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeMultiply((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector ebeMultiply(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) ebeMultiply(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeDivide((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector ebeDivide(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) ebeDivide(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>Does not make a fresh copy of the underlying data.</p>\n+     * @return array of entries\n+     */\n+    public double[] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return dotProduct((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double dot = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            dot += data[i] * v[i];\n+        }\n+        return dot;\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public double dotProduct(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return dotProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += a * a;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += Math.abs(a);\n+        }\n+        return sum;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double max = 0;\n+        for (double a : data) {\n+            max += Math.max(max, Math.abs(a));\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getDistance((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += delta * delta;\n+            }\n+            return Math.sqrt(sum);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += delta * delta;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+   /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(ArrayRealVector)\n+     * @see #getLInfDistance(ArrayRealVector)\n+     * @see #getNorm()\n+     */\n+    public double getDistance(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return getDistance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getL1Distance((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += Math.abs(delta);\n+            }\n+            return sum;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += Math.abs(delta);\n+        }\n+        return sum;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(ArrayRealVector)\n+     * @see #getLInfDistance(ArrayRealVector)\n+     * @see #getNorm()\n+     */\n+    public double getL1Distance(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return getL1Distance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getLInfDistance((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double max = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                max = Math.max(max, Math.abs(delta));\n+            }\n+            return max;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            max = Math.max(max, Math.abs(delta));\n+        }\n+        return max;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(ArrayRealVector)\n+     * @see #getLInfDistance(ArrayRealVector)\n+     * @see #getNorm()\n+     */\n+    public double getLInfDistance(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return getLInfDistance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector unitVector() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw MathRuntimeException.createArithmeticException(\"zero norm\");\n+        }\n+        return mapDivide(getNorm());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+        }\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] /= norm;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(RealVector v) {\n+        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(double[] v) {\n+        return projection(new ArrayRealVector(v, false));\n+    }\n+\n+   /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector projection(ArrayRealVector v) {\n+        return (ArrayRealVector) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return outerProduct((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            final int m = data.length;\n+            final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < data.length; i++) {\n+                for (int j = 0; j < data.length; j++) {\n+                    out.setEntry(i, j, data[i] * v.getEntry(j));\n+                }\n+            }\n+            return out;\n+        }\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealMatrix outerProduct(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return outerProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        final int m = data.length;\n+        final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out.setEntry(i, j, data[i] * v[j]);\n+            }\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(int index) throws MatrixIndexException {\n+        return data[index];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(RealVector v) {\n+        try {\n+            return append((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            return new ArrayRealVector(this,new ArrayRealVector(v));\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public ArrayRealVector append(ArrayRealVector v) {\n+        return new ArrayRealVector(this, v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double in) {\n+        final double[] out = new double[data.length + 1];\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        out[data.length] = in;\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double[] in) {\n+        return new ArrayRealVector(this, in);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getSubVector(int index, int n) {\n+        ArrayRealVector out = new ArrayRealVector(n);\n+        try {\n+            System.arraycopy(data, index, out.data, 0, n);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + n - 1);\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, double value) {\n+        try {\n+            data[index] = value;\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, RealVector v) {\n+        try {\n+            try {\n+                set(index, (ArrayRealVector) v);\n+            } catch (ClassCastException cce) {\n+                for (int i = index; i < index + v.getDimension(); ++i) {\n+                    data[i] = v.getEntry(i-index);\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, double[] v) {\n+        try {\n+            System.arraycopy(v, 0, data, index, v.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.length - 1);\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * \n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    public void set(int index, ArrayRealVector v)\n+        throws MatrixIndexException {\n+        setSubVector(index, v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        Arrays.fill(data, value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray(){\n+        return data.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String toString(){\n+        return DEFAULT_FORMAT.format(this);\n+    }\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    protected void checkVectorDimensions(RealVector v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        if (data.length != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    data.length, n);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN() {\n+        for (double v : data) {\n+            if (Double.isNaN(v)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite() {\n+\n+        if (isNaN()) {\n+            return false;\n+        }\n+\n+        for (double v : data) {\n+            if (Double.isInfinite(v)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+\n+    }\n+    \n+    /**\n+     * Test for the equality of two real vectors.\n+     * <p>\n+     * If all coordinates of two real vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n+     * a vector with all <code>Double.NaN</code> coordinates.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two vector objects are equal, false if\n+     *         object is null, not an instance of RealVector, or\n+     *         not equal to this RealVector instance\n+     * \n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          RealVector rhs = (RealVector) other;\n+          if (data.length != rhs.getDimension()) {\n+              return false;\n+          }\n+\n+          if (rhs.isNaN()) {\n+              return this.isNaN();\n+          }\n+\n+          for (int i = 0; i < data.length; ++i) {\n+              if (data[i] != rhs.getEntry(i)) {\n+                  return false;\n+              }\n+          }\n+          return true;\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /**\n+     * Get a hashCode for the real vector.\n+     * <p>All NaN values have the same hash code.</p>\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 9;\n+        }\n+        return MathUtils.hash(data);\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n  * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.</li></ul></p>\n  * \n- * @deprecated as of 2.0, replaced by {@link FieldMatrixImpl} with a {@link\n+ * @deprecated as of 2.0, replaced by {@link Array2DRowFieldMatrix} with a {@link\n  * org.apache.commons.math.util.BigReal} parameter\n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n             outIndex += jWidth;\n         }\n \n-        return new FieldVectorImpl<T>(outData, false);\n+        return new ArrayFieldVector<T>(outData, false);\n \n     }\n \n     public void setRowVector(final int row, final FieldVector<T> vector)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n-            setRow(row, ((FieldVectorImpl<T>) vector).getDataRef());\n+            setRow(row, ((ArrayFieldVector<T>) vector).getDataRef());\n         } catch (ClassCastException cce) {\n             super.setRowVector(row, vector);\n         }\n             }\n         }\n \n-        return new FieldVectorImpl<T>(outData, false);\n+        return new ArrayFieldVector<T>(outData, false);\n \n     }\n \n     public void setColumnVector(final int column, final FieldVector<T> vector)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n-            setColumn(column, ((FieldVectorImpl<T>) vector).getDataRef());\n+            setColumn(column, ((ArrayFieldVector<T>) vector).getDataRef());\n         } catch (ClassCastException cce) {\n             super.setColumnVector(column, vector);\n         }\n--- a/src/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/BlockRealMatrix.java\n             outIndex += jWidth;\n         }\n \n-        return new RealVectorImpl(outData, false);\n+        return new ArrayRealVector(outData, false);\n \n     }\n \n     public void setRowVector(final int row, final RealVector vector)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n-            setRow(row, ((RealVectorImpl) vector).getDataRef());\n+            setRow(row, ((ArrayRealVector) vector).getDataRef());\n         } catch (ClassCastException cce) {\n             super.setRowVector(row, vector);\n         }\n             }\n         }\n \n-        return new RealVectorImpl(outData, false);\n+        return new ArrayRealVector(outData, false);\n \n     }\n \n     public void setColumnVector(final int column, final RealVector vector)\n         throws MatrixIndexException, InvalidMatrixException {\n         try {\n-            setColumn(column, ((RealVectorImpl) vector).getDataRef());\n+            setColumn(column, ((ArrayRealVector) vector).getDataRef());\n         } catch (ClassCastException cce) {\n             super.setColumnVector(column, vector);\n         }\n--- a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n         public RealVector solve(RealVector b)\n             throws IllegalArgumentException, InvalidMatrixException {\n             try {\n-                return solve((RealVectorImpl) b);\n+                return solve((ArrayRealVector) b);\n             } catch (ClassCastException cce) {\n \n                 final int m = lTData.length;\n                     }\n                 }\n \n-                return new RealVectorImpl(x, false);\n+                return new ArrayRealVector(x, false);\n \n             }\n         }\n          * @exception IllegalArgumentException if matrices dimensions don't match\n          * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n-        public RealVectorImpl solve(RealVectorImpl b)\n+        public ArrayRealVector solve(ArrayRealVector b)\n             throws IllegalArgumentException, InvalidMatrixException {\n-            return new RealVectorImpl(solve(b.getDataRef()), false);\n+            return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n                 }\n             }\n \n-            return new RealMatrixImpl(x, false);\n+            return new Array2DRowRealMatrix(x, false);\n \n         }\n \n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n     private double[] imagEigenvalues;\n \n     /** Eigenvectors. */\n-    private RealVectorImpl[] eigenvectors;\n+    private ArrayRealVector[] eigenvectors;\n \n     /** Cached value of V. */\n     private RealMatrix cachedV;\n         private double[] imagEigenvalues;\n \n         /** Eigenvectors. */\n-        private final RealVectorImpl[] eigenvectors;\n+        private final ArrayRealVector[] eigenvectors;\n \n         /**\n          * Build a solver from decomposed matrix.\n          * @param eigenvectors eigenvectors\n          */\n         private Solver(final double[] realEigenvalues, final double[] imagEigenvalues,\n-                       final RealVectorImpl[] eigenvectors) {\n+                       final ArrayRealVector[] eigenvectors) {\n             this.realEigenvalues = realEigenvalues;\n             this.imagEigenvalues = imagEigenvalues;\n             this.eigenvectors    = eigenvectors; \n \n             final double[] bp = new double[m];\n             for (int i = 0; i < m; ++i) {\n-                final RealVectorImpl v = eigenvectors[i];\n+                final ArrayRealVector v = eigenvectors[i];\n                 final double[] vData = v.getDataRef();\n                 final double s = v.dotProduct(b) / realEigenvalues[i];\n                 for (int j = 0; j < m; ++j) {\n \n             final double[] bp = new double[m];\n             for (int i = 0; i < m; ++i) {\n-                final RealVectorImpl v = eigenvectors[i];\n+                final ArrayRealVector v = eigenvectors[i];\n                 final double[] vData = v.getDataRef();\n                 final double s = v.dotProduct(b) / realEigenvalues[i];\n                 for (int j = 0; j < m; ++j) {\n                 }\n             }\n \n-            return new RealVectorImpl(bp, false);\n+            return new ArrayRealVector(bp, false);\n \n         }\n \n             final double[][] bp = new double[m][nColB];\n             for (int k = 0; k < nColB; ++k) {\n                 for (int i = 0; i < m; ++i) {\n-                    final RealVectorImpl v = eigenvectors[i];\n+                    final ArrayRealVector v = eigenvectors[i];\n                     final double[] vData = v.getDataRef();\n                     double s = 0;\n                     for (int j = 0; j < m; ++j) {\n     private void findEigenVectors() {\n \n         final int m = main.length;\n-        eigenvectors = new RealVectorImpl[m];\n+        eigenvectors = new ArrayRealVector[m];\n \n         // perform an initial non-shifted LDLt decomposition\n         final double[] d = new double[m];\n      * @param l off-diagonal elements of the initial non-shifted L matrix\n      * @return an eigenvector\n      */\n-    private RealVectorImpl findEigenvector(final double eigenvalue,\n+    private ArrayRealVector findEigenvector(final double eigenvalue,\n                                            final double[] d, final double[] l) {\n \n         // compute the LDLt and UDUt decompositions of the\n         }\n \n         return (transformer == null) ?\n-               new RealVectorImpl(eigenvector, false) :\n-               new RealVectorImpl(transformer.getQ().operate(eigenvector), false);\n+               new ArrayRealVector(eigenvector, false) :\n+               new ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n \n     }\n \n--- a/src/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n     public FieldMatrix<T> getL() {\n         if ((cachedL == null) && !singular) {\n             final int m = pivot.length;\n-            cachedL = new FieldMatrixImpl<T>(field, m, m);\n+            cachedL = new Array2DRowFieldMatrix<T>(field, m, m);\n             for (int i = 0; i < m; ++i) {\n                 final T[] luI = lu[i];\n                 for (int j = 0; j < i; ++j) {\n     public FieldMatrix<T> getU() {\n         if ((cachedU == null) && !singular) {\n             final int m = pivot.length;\n-            cachedU = new FieldMatrixImpl<T>(field, m, m);\n+            cachedU = new Array2DRowFieldMatrix<T>(field, m, m);\n             for (int i = 0; i < m; ++i) {\n                 final T[] luI = lu[i];\n                 for (int j = i; j < m; ++j) {\n     public FieldMatrix<T> getP() {\n         if ((cachedP == null) && !singular) {\n             final int m = pivot.length;\n-            cachedP = new FieldMatrixImpl<T>(field, m, m);\n+            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n             for (int i = 0; i < m; ++i) {\n                 cachedP.setEntry(i, pivot[i], field.getOne());\n             }\n         public FieldVector<T> solve(FieldVector<T> b)\n             throws IllegalArgumentException, InvalidMatrixException {\n             try {\n-                return solve((FieldVectorImpl<T>) b);\n+                return solve((ArrayFieldVector<T>) b);\n             } catch (ClassCastException cce) {\n \n                 final int m = pivot.length;\n                     }\n                 }\n \n-                return new FieldVectorImpl<T>(bp, false);\n+                return new ArrayFieldVector<T>(bp, false);\n \n             }\n         }\n          * @exception IllegalArgumentException if matrices dimensions don't match\n          * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n-        public FieldVectorImpl<T> solve(FieldVectorImpl<T> b)\n+        public ArrayFieldVector<T> solve(ArrayFieldVector<T> b)\n             throws IllegalArgumentException, InvalidMatrixException {\n-            return new FieldVectorImpl<T>(solve(b.getDataRef()), false);\n+            return new ArrayFieldVector<T>(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n                 }\n             }\n \n-            return new FieldMatrixImpl<T>(bp, false);\n+            return new Array2DRowFieldMatrix<T>(bp, false);\n \n         }\n \n         public FieldMatrix<T> getInverse() throws InvalidMatrixException {\n             final int m = pivot.length;\n             final T one = field.getOne();\n-            FieldMatrix<T> identity = new FieldMatrixImpl<T>(field, m, m);\n+            FieldMatrix<T> identity = new Array2DRowFieldMatrix<T>(field, m, m);\n             for (int i = 0; i < m; ++i) {\n                 identity.setEntry(i, i, one);\n             }\n--- a/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n         public RealVector solve(RealVector b)\n             throws IllegalArgumentException, InvalidMatrixException {\n             try {\n-                return solve((RealVectorImpl) b);\n+                return solve((ArrayRealVector) b);\n             } catch (ClassCastException cce) {\n \n                 final int m = pivot.length;\n                     }\n                 }\n \n-                return new RealVectorImpl(bp, false);\n+                return new ArrayRealVector(bp, false);\n \n             }\n         }\n          * @exception IllegalArgumentException if matrices dimensions don't match\n          * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n-        public RealVectorImpl solve(RealVectorImpl b)\n+        public ArrayRealVector solve(ArrayRealVector b)\n             throws IllegalArgumentException, InvalidMatrixException {\n-            return new RealVectorImpl(solve(b.getDataRef()), false);\n+            return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n                 }\n             }\n \n-            return new RealMatrixImpl(bp, false);\n+            return new Array2DRowRealMatrix(bp, false);\n \n         }\n \n--- a/src/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixUtils.java\n      * <p>The type of matrix returned depends on the dimension. Below\n      * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n      * square matrix) which can be stored in a 32kB array, a {@link\n-     * RealMatrixImpl} instance is built. Above this threshold a {@link\n+     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n      * BlockRealMatrix} instance is built.</p>\n      * <p>The matrix elements are all set to 0.0.</p>\n      * @param rows number of rows of the matrix\n      */\n     public static RealMatrix createRealMatrix(final int rows, final int columns) {\n         return (rows * columns <= 4096) ?\n-                new RealMatrixImpl(rows, columns) : new BlockRealMatrix(rows, columns);\n+                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n     }\n \n     /**\n                                                                                final int rows,\n                                                                                final int columns) {\n         return (rows * columns <= 4096) ?\n-                new FieldMatrixImpl<T>(field, rows, columns) : new BlockFieldMatrix<T>(field, rows, columns);\n+                new Array2DRowFieldMatrix<T>(field, rows, columns) : new BlockFieldMatrix<T>(field, rows, columns);\n     }\n \n     /**\n      * <p>The type of matrix returned depends on the dimension. Below\n      * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n      * square matrix) which can be stored in a 32kB array, a {@link\n-     * RealMatrixImpl} instance is built. Above this threshold a {@link\n+     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n      * BlockRealMatrix} instance is built.</p>\n      * <p>The input array is copied, not referenced.</p>\n      * \n      */\n     public static RealMatrix createRealMatrix(double[][] data) {\n         return (data.length * data[0].length <= 4096) ?\n-                new RealMatrixImpl(data) : new BlockRealMatrix(data);\n+                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n     }\n \n     /**\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) {\n         return (data.length * data[0].length <= 4096) ?\n-                new FieldMatrixImpl<T>(data) : new BlockFieldMatrix<T>(data);\n+                new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);\n     }\n \n     /**\n             Arrays.fill(dRow, zero);\n             dRow[row] = one;\n         }\n-        return new FieldMatrixImpl<T>(d, false);\n+        return new Array2DRowFieldMatrix<T>(d, false);\n     }\n \n     /**\n      * @throws NullPointerException if <code>data</code>is null\n      */\n     public static RealVector createRealVector(double[] data) {\n-        return new RealVectorImpl(data, true);\n+        return new ArrayRealVector(data, true);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>data</code>is null\n      */\n     public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n-        return new FieldVectorImpl<T>(data, true);\n+        return new ArrayFieldVector<T>(data, true);\n     }\n     \n     /**\n          * @return converted matrix\n          */\n         RealMatrix getConvertedMatrix() {\n-            return new RealMatrixImpl(data, false);\n+            return new Array2DRowRealMatrix(data, false);\n         }\n \n     }\n          * @return converted matrix\n          */\n         RealMatrix getConvertedMatrix() {\n-            return new RealMatrixImpl(data, false);\n+            return new Array2DRowRealMatrix(data, false);\n         }\n \n     }\n             }\n \n             // create the instance\n-            final RealVector vector = new RealVectorImpl(data, false);\n+            final RealVector vector = new ArrayRealVector(data, false);\n \n             // set up the field\n             final java.lang.reflect.Field f =\n             }\n \n             // create the instance\n-            final RealMatrix matrix = new RealMatrixImpl(data, false);\n+            final RealMatrix matrix = new Array2DRowRealMatrix(data, false);\n \n             // set up the field\n             final java.lang.reflect.Field f =\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n         public RealVector solve(RealVector b)\n         throws IllegalArgumentException, InvalidMatrixException {\n             try {\n-                return solve((RealVectorImpl) b);\n+                return solve((ArrayRealVector) b);\n             } catch (ClassCastException cce) {\n-                return new RealVectorImpl(solve(b.getData()), false);\n+                return new ArrayRealVector(solve(b.getData()), false);\n             }\n         }\n \n          * @throws IllegalArgumentException if matrices dimensions don't match\n          * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public RealVectorImpl solve(RealVectorImpl b)\n+        public ArrayRealVector solve(ArrayRealVector b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-            return new RealVectorImpl(solve(b.getDataRef()), false);\n+            return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n  * </p>\n  *\n  * @version $Revision$ $Date$\n+ * @deprecated as of 2.0 replaced by {@link Array2DRowRealMatrix}\n  */\n+@Deprecated\n public class RealMatrixImpl extends AbstractRealMatrix implements Serializable {\n     \n     /** Serializable version identifier */\n--- a/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n      * @exception ParseException if the beginning of the specified string\n      *            cannot be parsed.\n      */\n-    public RealVectorImpl parse(String source) throws ParseException {\n+    public ArrayRealVector parse(String source) throws ParseException {\n         ParsePosition parsePosition = new ParsePosition(0);\n-        RealVectorImpl result = parse(source, parsePosition);\n+        ArrayRealVector result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n             throw MathRuntimeException.createParseException(\n                     parsePosition.getErrorIndex(),\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link RealVector} object.\n      */\n-    public RealVectorImpl parse(String source, ParsePosition pos) {\n+    public ArrayRealVector parse(String source, ParsePosition pos) {\n         int initialIndex = pos.getIndex();\n \n         // parse prefix\n         for (int i = 0; i < data.length; ++i) {\n             data[i] = components.get(i).doubleValue();\n         }\n-        return new RealVectorImpl(data, false);\n+        return new ArrayRealVector(data, false);\n \n     }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n import org.apache.commons.math.linear.FieldMatrix;\n-import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.MatrixVisitorException;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n             }\n         }\n \n-        return coefficients.msToN.multiply(new RealMatrixImpl(multistep, false));\n+        return coefficients.msToN.multiply(new Array2DRowRealMatrix(multistep, false));\n \n     }\n \n             shiftedP[0] = new BigFraction[order - 1];\n             Arrays.fill(shiftedP[0], BigFraction.ZERO);\n             FieldMatrix<BigFraction> bigMSupdate =\n-                bigMStoN.multiply(new FieldMatrixImpl<BigFraction>(shiftedP, false));\n+                bigMStoN.multiply(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n \n             // convert coefficients to double\n             msToN    = MatrixUtils.bigFractionMatrixToRealMatrix(bigMStoN);\n                 }\n             }\n \n-            return new FieldMatrixImpl<BigFraction>(pData, false);\n+            return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n \n         }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n import org.apache.commons.math.linear.FieldMatrix;\n-import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.MatrixVisitorException;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n             }\n         }\n \n-        return coefficients.msToN.multiply(new RealMatrixImpl(multistep, false));\n+        return coefficients.msToN.multiply(new Array2DRowRealMatrix(multistep, false));\n \n     }\n \n             shiftedP[0] = new BigFraction[order - 1];\n             Arrays.fill(shiftedP[0], BigFraction.ZERO);\n             FieldMatrix<BigFraction> bigMSupdate =\n-                bigMStoN.multiply(new FieldMatrixImpl<BigFraction>(shiftedP, false));\n+                bigMStoN.multiply(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n \n             // convert coefficients to double\n             msToN    = MatrixUtils.bigFractionMatrixToRealMatrix(bigMStoN);\n                 }\n             }\n \n-            return new FieldMatrixImpl<BigFraction>(pData, false);\n+            return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n \n         }\n \n--- a/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n import java.util.Arrays;\n \n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n \n /**\n                     nI[j] = in.readDouble();\n                 }\n             }\n-            nordsieck = new RealMatrixImpl(nData, false);\n+            nordsieck = new Array2DRowRealMatrix(nData, false);\n         } else {\n             nordsieck = null;\n         }\n--- a/src/java/org/apache/commons/math/optimization/linear/LinearConstraint.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/LinearConstraint.java\n \n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n \n /**\n      */\n     public LinearConstraint(final double[] coefficients, final Relationship relationship,\n                             final double value) {\n-        this(new RealVectorImpl(coefficients), relationship, value);\n+        this(new ArrayRealVector(coefficients), relationship, value);\n     }\n \n     /**\n         for (int i = 0; i < sub.length; ++i) {\n             sub[i] = lhsCoefficients[i] - rhsCoefficients[i];\n         }\n-        this.coefficients = new RealVectorImpl(sub, false);\n+        this.coefficients = new ArrayRealVector(sub, false);\n         this.relationship = relationship;\n         this.value        = rhsConstant - lhsConstant;\n     }\n--- a/src/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n \n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n /**\n  * An objective function for a linear optimization problem.\n      * @param constantTerm The constant term of the linear equation\n      */\n     public LinearObjectiveFunction(double[] coefficients, double constantTerm) {\n-        this(new RealVectorImpl(coefficients), constantTerm);\n+        this(new ArrayRealVector(coefficients), constantTerm);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n \n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n                                       getConstraintTypeCounts(Relationship.GEQ);\n         this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                       getConstraintTypeCounts(Relationship.GEQ);\n-        this.tableau = new RealMatrixImpl(createTableau(goalType == GoalType.MAXIMIZE));\n+        this.tableau = new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));\n         initialize();\n     }\n \n             }\n             matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());\n         }\n-        this.tableau = new RealMatrixImpl(matrix);\n+        this.tableau = new Array2DRowRealMatrix(matrix);\n         this.numArtificialVariables = 0;\n     }\n \n--- a/src/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n /**\n  * Abstract base class for implementations of MultipleLinearRegression.\n                 x[i][j] = data[pointer++];\n             }\n         }\n-        this.X = new RealMatrixImpl(x);\n-        this.Y = new RealVectorImpl(y);\n+        this.X = new Array2DRowRealMatrix(x);\n+        this.Y = new ArrayRealVector(y);\n     }\n     \n     /**\n      * @param y the [n,1] array representing the y sample\n      */\n     protected void newYSampleData(double[] y) {\n-        this.Y = new RealVectorImpl(y);\n+        this.Y = new ArrayRealVector(y);\n     }\n \n     /**\n      * @param x the [n,k] array representing the x sample\n      */\n     protected void newXSampleData(double[][] x) {\n-        this.X = new RealMatrixImpl(x);\n+        this.X = new Array2DRowRealMatrix(x);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n \n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealVector;\n \n \n      * @param omega the [n,n] array representing the covariance\n      */\n     protected void newCovarianceData(double[][] omega){\n-        this.Omega = new RealMatrixImpl(omega);\n+        this.Omega = new Array2DRowRealMatrix(omega);\n         this.OmegaInverse = null;\n     }\n \n--- a/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n import org.apache.commons.math.linear.QRDecomposition;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n /**\n  * <p>Implements ordinary least squares (OLS) to estimate the parameters of a \n         RealMatrix Q = qr.getQ();\n         final int p = qr.getR().getColumnDimension();\n         final int n = Q.getColumnDimension();\n-        RealMatrixImpl augI = new RealMatrixImpl(n, n);\n+        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n         double[][] augIData = augI.getDataRef();\n         for (int i = 0; i < n; i++) {\n             for (int j =0; j < n; j++) {\n      */\n     @Override\n     protected void newXSampleData(double[][] x) {\n-        this.X = new RealMatrixImpl(x);\n+        this.X = new Array2DRowRealMatrix(x);\n         qr = new QRDecompositionImpl(X);\n     }\n     \n             }\n             x[index] = (constants.getEntry(index) - sum) / coefficients.getEntry(index, index);\n         } \n-        return new RealVectorImpl(x);\n+        return new ArrayRealVector(x);\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link Array2DRowRealMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class Array2DRowRealMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public Array2DRowRealMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(Array2DRowRealMatrixTest.class);\n+        suite.setName(\"Array2DRowRealMatrix Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData());\n+        assertEquals(m2,m1);\n+        Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);\n+        assertEquals(m4,m3);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+    /** test Frobenius norm */\n+    public void testFrobeniusNorm() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);\n+        TestUtils.assertEquals(\"m-n = m + -n\",m.subtract(m2),\n+            m2.scalarMultiply(-1d).add(m),entryTolerance);        \n+        try {\n+            m.subtract(new Array2DRowRealMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n+        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n+        TestUtils.assertEquals(\"inverse multiply\",m.multiply(mInv),\n+            identity,entryTolerance);\n+        TestUtils.assertEquals(\"inverse multiply\",mInv.multiply(m),\n+            identity,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m.multiply(identity),\n+            m,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",identity.multiply(mInv),\n+            mInv,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m2.multiply(identity),\n+            m2,entryTolerance); \n+        try {\n+            m.multiply(new Array2DRowRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }   \n+    \n+    //Additional Test for Array2DRowRealMatrixTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       RealMatrix m3 = new Array2DRowRealMatrix(d3);   \n+       RealMatrix m4 = new Array2DRowRealMatrix(d4);\n+       RealMatrix m5 = new Array2DRowRealMatrix(d5);\n+       TestUtils.assertEquals(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new Array2DRowRealMatrix(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new Array2DRowRealMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        TestUtils.assertEquals(\"scalar add\",new Array2DRowRealMatrix(testDataPlus2),\n+            m.scalarAdd(2d),entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new Array2DRowRealMatrix(id);\n+        TestUtils.assertEquals(\"identity operate\", testVector,\n+                    m.operate(testVector), entryTolerance);\n+        TestUtils.assertEquals(\"identity operate\", testVector,\n+                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);\n+        m = new Array2DRowRealMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new Array2DRowRealMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        }, false);\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData); \n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(\"inverse-transpose\", mIT, mTI, normTolerance);\n+        m = new Array2DRowRealMatrix(testData2);\n+        RealMatrix mt = new Array2DRowRealMatrix(testData2T);\n+        TestUtils.assertEquals(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        TestUtils.assertEquals(\"premultiply\", m.preMultiply(testVector),\n+                    preMultTest, normTolerance);\n+        TestUtils.assertEquals(\"premultiply\", m.preMultiply(new ArrayRealVector(testVector).getData()),\n+                    preMultTest, normTolerance);\n+        m = new Array2DRowRealMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        RealMatrix m3 = new Array2DRowRealMatrix(d3);   \n+        RealMatrix m4 = new Array2DRowRealMatrix(d4);\n+        RealMatrix m5 = new Array2DRowRealMatrix(d5);\n+        TestUtils.assertEquals(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n+        Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);\n+        TestUtils.assertEquals(\"inverse multiply\",m.preMultiply(mInv),\n+                identity,entryTolerance);\n+        TestUtils.assertEquals(\"inverse multiply\",mInv.preMultiply(m),\n+                identity,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",m.preMultiply(identity),\n+                m,entryTolerance);\n+        TestUtils.assertEquals(\"identity multiply\",identity.preMultiply(mInv),\n+                mInv,entryTolerance);\n+        try {\n+            m.preMultiply(new Array2DRowRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        TestUtils.assertEquals(\"get row\",m.getRow(0),testDataRow1,entryTolerance);\n+        TestUtils.assertEquals(\"get col\",m.getColumn(2),testDataCol3,entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n+        RealMatrix m = new Array2DRowRealMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n+        RealMatrix n = new Array2DRowRealMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n+        RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);\n+        double[] constants = {1, -2, 1};\n+        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new Array2DRowRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new Array2DRowRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testCopySubMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                             new double[1][1] :\n+                             new double[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                    new double[1][1] :\n+                    new double[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);\n+        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, \n+                m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, \n+                m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testSetRowMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);\n+        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, \n+                m.getColumnMatrix(1));\n+        assertEquals(\"Column3\", mColumn3, \n+                m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayRealVector(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetColumn() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        double[] mColumn1 = columnToArray(subColumn1);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        RealMatrix m = new Array2DRowRealMatrix(subTestData);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private double[] columnToArray(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(double[] expected, double[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();\n+        Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        assertEquals(\"Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+                m.toString());\n+        m = new Array2DRowRealMatrix();\n+        assertEquals(\"Array2DRowRealMatrix{}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        RealMatrix expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = MatrixUtils.createRealMatrix\n+            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        Array2DRowRealMatrix m2 = new Array2DRowRealMatrix();\n+        try {\n+            m2.setSubMatrix(testData,0,1);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        try {\n+            m2.setSubMatrix(testData,1,0);\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new Array2DRowRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+\n+    public void testSerial()  {\n+        Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+    \n+    \n+    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n+        @Override\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n+        private int count = 0;\n+        @Override\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    //--------------- -----------------Protected methods\n+    \n+    /** extracts the l  and u matrices from compact lu representation */\n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   \n+        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n+                lowerData.length != upperData.length\n+                || lowerData.length != lu.getRowDimension()) {\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n+        }    \n+        int n = lu.getRowDimension();\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                if (j < i) {\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = 0d;\n+                } else if (i == j) {\n+                    lowerData[i][j] = 1d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                } else {\n+                    lowerData[i][j] = 0d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n+                }   \n+            }\n+        }\n+    }\n+    \n+    /** Returns the result of applying the given row permutation to the matrix */\n+    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {\n+        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n+            throw new IllegalArgumentException(\"dimension mismatch\");\n+        }\n+        int n = matrix.getRowDimension();\n+        int m = matrix.getColumnDimension();\n+        double out[][] = new double[m][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n+            }\n+        }\n+        return new Array2DRowRealMatrix(out);\n+    }\n+    \n+//    /** Useful for debugging */\n+//    private void dumpMatrix(RealMatrix m) {\n+//          for (int i = 0; i < m.getRowDimension(); i++) {\n+//              String os = \"\";\n+//              for (int j = 0; j < m.getColumnDimension(); j++) {\n+//                  os += m.getEntry(i, j) + \" \";\n+//              }\n+//              System.out.println(os);\n+//          }\n+//    }\n+        \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+/**\n+ * Test cases for the {@link ArrayFieldVector} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ArrayFieldVectorTest extends TestCase {\n+\n+    // \n+    protected Fraction[][] ma1 = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6)},\n+            {new Fraction(7), new Fraction(8), new Fraction(9)}\n+    };\n+    protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};\n+    protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};\n+    protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3),\n+                                  new Fraction(4), new Fraction(5), new Fraction(6),\n+                                  new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)};\n+    protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3),\n+                                  new Fraction(4), new Fraction(5), new Fraction(6),\n+                                  new Fraction(7), new Fraction(8), new Fraction(9)};\n+    protected Fraction[][] mat1 = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6)},\n+            {new Fraction(7), new Fraction(8), new Fraction(9)}\n+    };\n+\n+    // Testclass to test the FieldVector<Fraction> interface \n+    // only with enough content to support the test\n+    public static class FieldVectorTestImpl<T extends FieldElement<T>>\n+        implements FieldVector<T>, Serializable {\n+\n+        private static final long serialVersionUID = 3970959016014158539L;\n+\n+        private final Field<T> field;\n+\n+        /** Entries of the vector. */\n+        protected T[] data;\n+\n+        /** Build an array of elements.\n+         * @param length size of the array to build\n+         * @return a new array\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        private T[] buildArray(final int length) {\n+            return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        }\n+\n+        public FieldVectorTestImpl(T[] d) {\n+            field = d[0].getField();\n+            data = d.clone();\n+        }\n+\n+        public Field<T> getField() {\n+            return field;\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public FieldVector<T> copy() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapAdd(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapAddToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapSubtract(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapSubtractToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapMultiply(T d) {\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].multiply(d);\n+            }\n+            return new FieldVectorTestImpl<T>(out);\n+        }\n+\n+        public FieldVector<T> mapMultiplyToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapDivide(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapDivideToSelf(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeMultiply(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeDivide(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public T[] getData() {\n+            return data.clone();\n+        }\n+\n+        public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v.getEntry(i)));\n+            }\n+            return dot;\n+        }\n+\n+        public T dotProduct(T[] v) throws IllegalArgumentException {\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v[i]));\n+            }\n+            return dot;\n+        }\n+\n+        public FieldVector<T> projection(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> projection(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldMatrix<T> outerProduct(FieldVector<T> v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public T getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public FieldVector<T> append(FieldVector<T> v) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> append(T d) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> append(T[] a) {\n+            throw unsupported();\n+        }\n+\n+        public FieldVector<T> getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, T value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, FieldVector<T> v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, T[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(T value) {\n+            throw unsupported();\n+        }\n+\n+        public T[] toArray() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayFieldVectorTest.class);\n+        suite.setName(\"ArrayFieldVector<Fraction> Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        ArrayFieldVector<Fraction> v0 = new ArrayFieldVector<Fraction>(FractionField.getInstance());\n+        assertEquals(0, v0.getDimension());\n+\n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), 7);\n+        assertEquals(7, v1.getDimension());\n+        assertEquals(new Fraction(0), v1.getEntry(6));\n+\n+        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(5, new Fraction(123, 100));\n+        assertEquals(5, v2.getDimension());\n+        assertEquals(new Fraction(123, 100), v2.getEntry(4));\n+\n+        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(vec1);\n+        assertEquals(3, v3.getDimension());\n+        assertEquals(new Fraction(2), v3.getEntry(1));\n+\n+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4, 3, 2);\n+        assertEquals(2, v4.getDimension());\n+        assertEquals(new Fraction(4), v4.getEntry(0));\n+        try {\n+            new ArrayFieldVector<Fraction>(vec4, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        FieldVector<Fraction> v5_i = new ArrayFieldVector<Fraction>(dvec1);\n+        assertEquals(9, v5_i.getDimension());\n+        assertEquals(new Fraction(9), v5_i.getEntry(8));\n+\n+        ArrayFieldVector<Fraction> v5 = new ArrayFieldVector<Fraction>(dvec1);\n+        assertEquals(9, v5.getDimension());\n+        assertEquals(new Fraction(9), v5.getEntry(8));\n+\n+        ArrayFieldVector<Fraction> v6 = new ArrayFieldVector<Fraction>(dvec1, 3, 2);\n+        assertEquals(2, v6.getDimension());\n+        assertEquals(new Fraction(4), v6.getEntry(0));\n+        try {\n+            new ArrayFieldVector<Fraction>(dvec1, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v7 = new ArrayFieldVector<Fraction>(v1);\n+        assertEquals(7, v7.getDimension());\n+        assertEquals(new Fraction(0), v7.getEntry(6));\n+\n+        FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1);\n+\n+        ArrayFieldVector<Fraction> v7_2 = new ArrayFieldVector<Fraction>(v7_i);\n+        assertEquals(3, v7_2.getDimension());\n+        assertEquals(new Fraction(2), v7_2.getEntry(1));\n+\n+        ArrayFieldVector<Fraction> v8 = new ArrayFieldVector<Fraction>(v1, true);\n+        assertEquals(7, v8.getDimension());\n+        assertEquals(new Fraction(0), v8.getEntry(6));\n+        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        ArrayFieldVector<Fraction> v8_2 = new ArrayFieldVector<Fraction>(v1, false);\n+        assertEquals(7, v8_2.getDimension());\n+        assertEquals(new Fraction(0), v8_2.getEntry(6));\n+        assertEquals(v1.data, v8_2.data);\n+\n+        ArrayFieldVector<Fraction> v9 = new ArrayFieldVector<Fraction>(v1, v3);\n+        assertEquals(10, v9.getDimension());\n+        assertEquals(new Fraction(1), v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);\n+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);\n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+\n+        FieldVector<Fraction> v_append_1 = v1.append(v2);\n+        assertEquals(6, v_append_1.getDimension());\n+        assertEquals(new Fraction(4), v_append_1.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2));\n+        assertEquals(4, v_append_2.getDimension());\n+        assertEquals(new Fraction(2), v_append_2.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_3 = v1.append(vec2);\n+        assertEquals(6, v_append_3.getDimension());\n+        assertEquals(new Fraction(4), v_append_3.getEntry(3));\n+\n+        FieldVector<Fraction> v_append_4 = v1.append(v2_t);\n+        assertEquals(6, v_append_4.getDimension());\n+        assertEquals(new Fraction(4), v_append_4.getEntry(3));\n+\n+        FieldVector<Fraction> v_copy = v1.copy();\n+        assertEquals(3, v_copy.getDimension());\n+        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+\n+        Fraction[] a_frac = v1.toArray();\n+        assertEquals(3, a_frac.length);\n+        assertNotSame(\"testData not same object \", v1.data, a_frac);\n+\n+\n+//      ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone();\n+//      assertEquals(3, vout4.getDimension());\n+//      assertEquals(v1.data, vout4.data);\n+\n+\n+        FieldVector<Fraction> vout5 = v4.getSubVector(3, 3);\n+        assertEquals(3, vout5.getDimension());\n+        assertEquals(new Fraction(5), vout5.getEntry(1));\n+        try {\n+            v4.getSubVector(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set1 = (ArrayFieldVector<Fraction>) v1.copy();\n+        v_set1.setEntry(1, new Fraction(11));\n+        assertEquals(new Fraction(11), v_set1.getEntry(1));\n+        try {\n+            v_set1.setEntry(3, new Fraction(11));\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set2 = (ArrayFieldVector<Fraction>) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(new Fraction(1), v_set2.getEntry(3));\n+        assertEquals(new Fraction(7), v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set3 = (ArrayFieldVector<Fraction>) v1.copy();\n+        v_set3.set(new Fraction(13));\n+        assertEquals(new Fraction(13), v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"ArrayIndexOutOfBoundsException expected\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayFieldVector<Fraction> v_set4 = (ArrayFieldVector<Fraction>) v4.copy();\n+        v_set4.setSubVector(3, v2_t);\n+        assertEquals(new Fraction(4), v_set4.getEntry(3));\n+        assertEquals(new Fraction(7), v_set4.getEntry(6));\n+        try {\n+            v_set4.setSubVector(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();       \n+        ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy();\n+        assertEquals(vout10, vout10_2);\n+        vout10_2.setEntry(0, new Fraction(11, 10));\n+        assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2));\n+        Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        checkArray(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData());\n+\n+        //octave =  v1 .+ 2.0\n+        FieldVector<Fraction> v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(new Fraction(2));\n+        Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)};\n+        checkArray(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2));\n+        Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        checkArray(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData());\n+\n+        //octave =  v1 .- 2.0\n+        FieldVector<Fraction> v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));\n+        Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)};\n+        checkArray(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2));\n+        Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        checkArray(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData());\n+\n+        //octave =  v1 .* 2.0\n+        FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));\n+        Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)};\n+        checkArray(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2));\n+        Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};\n+        checkArray(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData());\n+\n+        //octave =  v1 ./ 2.0\n+        FieldVector<Fraction> v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));\n+        Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)};\n+        checkArray(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInv = v1.mapInv();\n+        Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};\n+        checkArray(\"compare vectors\" ,result_mapInv,v_mapInv.getData());\n+\n+        //octave =  v1 .^-1\n+        FieldVector<Fraction> v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)};\n+        checkArray(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData());\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+        ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);\n+        new ArrayFieldVector<Fraction>(vec_null);\n+\n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+\n+        //octave =  v1 + v2\n+        ArrayFieldVector<Fraction> v_add = v1.add(v2);\n+        Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        checkArray(\"compare vect\" ,v_add.getData(),result_add);\n+\n+        FieldVectorTestImpl<Fraction> vt2 = new FieldVectorTestImpl<Fraction>(vec2);\n+        FieldVector<Fraction> v_add_i = v1.add(vt2);\n+        Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)};\n+        checkArray(\"compare vect\" ,v_add_i.getData(),result_add_i);\n+\n+        //octave =  v1 - v2\n+        ArrayFieldVector<Fraction> v_subtract = v1.subtract(v2);\n+        Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        checkArray(\"compare vect\" ,v_subtract.getData(),result_subtract);\n+\n+        FieldVector<Fraction> v_subtract_i = v1.subtract(vt2);\n+        Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)};\n+        checkArray(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i);\n+\n+        // octave v1 .* v2\n+        ArrayFieldVector<Fraction>  v_ebeMultiply = v1.ebeMultiply(v2);\n+        Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        checkArray(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply);\n+\n+        FieldVector<Fraction>  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)};\n+        checkArray(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2);\n+\n+        // octave v1 ./ v2\n+        ArrayFieldVector<Fraction>  v_ebeDivide = v1.ebeDivide(v2);\n+        Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};\n+        checkArray(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide);\n+\n+        FieldVector<Fraction>  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)};\n+        checkArray(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2);\n+\n+        // octave  dot(v1,v2)\n+        Fraction dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(32), dot);\n+\n+        // octave  dot(v1,v2_t)\n+        Fraction dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(32), dot_2);\n+\n+        FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct.getEntry(0,0));\n+\n+        FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",new Fraction(4), m_outerProduct_2.getEntry(0,0));\n+\n+        ArrayFieldVector<Fraction> v_projection = v1.projection(v2);\n+        Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n+        checkArray(\"compare vect\", v_projection.getData(), result_projection);\n+\n+        FieldVector<Fraction> v_projection_2 = v1.projection(v2_t);\n+        Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n+        checkArray(\"compare vect\", v_projection_2.getData(), result_projection_2);\n+\n+    }  \n+\n+    public void testMisc() { \n+        ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);\n+        FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         Fraction[] dout1 = v1.copyOut();\n+        assertEquals(3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+       try {\n+            v1.checkVectorDimensions(v4); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+        try {\n+            v1.checkVectorDimensions(v4_2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+    }\n+\n+    public void testSerial()  {\n+        ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1);\n+        assertEquals(v,TestUtils.serializeAndRecover(v));\n+    }\n+  \n+    /** verifies that two vectors are equals */\n+    protected void checkArray(String msg, Fraction[] m, Fraction[] n) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link ArrayRealVector} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ArrayRealVectorTest extends TestCase {\n+\n+    // \n+    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n+    protected double[] vec1 = {1d, 2d, 3d};\n+    protected double[] vec2 = {4d, 5d, 6d};\n+    protected double[] vec3 = {7d, 8d, 9d};\n+    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[] vec_null = {0d, 0d, 0d};\n+    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    // Testclass to test the RealVector interface \n+    // only with enough content to support the test\n+    public static class RealVectorTestImpl implements RealVector, Serializable {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4715341047369582908L;\n+\n+        /** Entries of the vector. */\n+        protected double data[];\n+\n+        public RealVectorTestImpl(double[] d) {\n+            data = d.clone();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public RealVector copy() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAdd(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAddToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtract(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtractToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapMultiply(double d) {\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * d;\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+\n+        public RealVector mapMultiplyToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivide(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivideToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPow(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPowToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLogToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1p() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1pToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCoshToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbs() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbsToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeil() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeilToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloor() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloorToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRint() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRintToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignum() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignumToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double[] getData() {\n+            return data.clone();\n+        }\n+\n+        public double dotProduct(RealVector v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+\n+        public double dotProduct(double[] v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v[i];\n+            }\n+            return dot;\n+        }\n+\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector unitVector() {\n+            throw unsupported();\n+        }\n+\n+        public void unitize() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(double value) {\n+            throw unsupported();\n+        }\n+\n+        public double[] toArray() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ArrayRealVectorTest.class);\n+        suite.setName(\"ArrayRealVector Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        ArrayRealVector v0 = new ArrayRealVector();\n+        assertEquals(\"testData len\", 0, v0.getDimension());\n+\n+        ArrayRealVector v1 = new ArrayRealVector(7);\n+        assertEquals(\"testData len\", 7, v1.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+\n+        ArrayRealVector v2 = new ArrayRealVector(5, 1.23);\n+        assertEquals(\"testData len\", 5, v2.getDimension());\n+        assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4));\n+\n+        ArrayRealVector v3 = new ArrayRealVector(vec1);\n+        assertEquals(\"testData len\", 3, v3.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+\n+        ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2);\n+        assertEquals(\"testData len\", 2, v4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        try {\n+            new ArrayRealVector(vec4, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVector v5_i = new ArrayRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+\n+        ArrayRealVector v5 = new ArrayRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+\n+        ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2);\n+        assertEquals(\"testData len\", 2, v6.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0));\n+        try {\n+            new ArrayRealVector(dvec1, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v7 = new ArrayRealVector(v1);\n+        assertEquals(\"testData len\", 7, v7.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+\n+        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);\n+\n+        ArrayRealVector v7_2 = new ArrayRealVector(v7_i);\n+        assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+\n+        ArrayRealVector v8 = new ArrayRealVector(v1, true);\n+        assertEquals(\"testData len\", 7, v8.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n+        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        ArrayRealVector v8_2 = new ArrayRealVector(v1, false);\n+        assertEquals(\"testData len\", 7, v8_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8_2.getEntry(6));\n+        assertEquals(\"testData same object \", v1.data, v8_2.data);\n+\n+        ArrayRealVector v9 = new ArrayRealVector(v1, v3);\n+        assertEquals(\"testData len\", 10, v9.getDimension());\n+        assertEquals(\"testData is 1.0 \", 1.0, v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+        ArrayRealVector v2 = new ArrayRealVector(vec2);\n+        ArrayRealVector v4 = new ArrayRealVector(vec4);\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        RealVector v_append_1 = v1.append(v2);\n+        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+\n+        RealVector v_append_2 = v1.append(2.0);\n+        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+\n+        RealVector v_append_3 = v1.append(vec2);\n+        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+\n+        RealVector v_append_4 = v1.append(v2_t);\n+        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+\n+        RealVector v_copy = v1.copy();\n+        assertEquals(\"testData len\", 3, v_copy.getDimension());\n+        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+\n+        double[] a_double = v1.toArray();\n+        assertEquals(\"testData len\", 3, a_double.length);\n+        assertNotSame(\"testData not same object \", v1.data, a_double);\n+\n+\n+//      ArrayRealVector vout4 = (ArrayRealVector) v1.clone();\n+//      assertEquals(\"testData len\", 3, vout4.getDimension());\n+//      assertEquals(\"testData not same object \", v1.data, vout4.data);\n+\n+\n+        RealVector vout5 = v4.getSubVector(3, 3);\n+        assertEquals(\"testData len\", 3, vout5.getDimension());\n+        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        try {\n+            v4.getSubVector(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set1 = (ArrayRealVector) v1.copy();\n+        v_set1.setEntry(1, 11.0);\n+        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        try {\n+            v_set1.setEntry(3, 11.0);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set2 = (ArrayRealVector) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set3 = (ArrayRealVector) v1.copy();\n+        v_set3.set(13.0);\n+        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"ArrayIndexOutOfBoundsException expected\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_set4 = (ArrayRealVector) v4.copy();\n+        v_set4.setSubVector(3, v2_t);\n+        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        try {\n+            v_set4.setSubVector(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        ArrayRealVector vout10 = (ArrayRealVector) v1.copy();       \n+        ArrayRealVector vout10_2 = (ArrayRealVector) v1.copy();\n+        assertEquals(vout10, vout10_2);\n+        vout10_2.setEntry(0, 1.1);\n+        assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAdd = v1.mapAdd(2.0d);\n+        double[] result_mapAdd = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData(),normTolerance);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(2.0d);\n+        double[] result_mapAddToSelf = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtract = v1.mapSubtract(2.0d);\n+        double[] result_mapSubtract = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);\n+        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiply = v1.mapMultiply(2.0d);\n+        double[] result_mapMultiply = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);\n+        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivide = v1.mapDivide(2.0d);\n+        double[] result_mapDivide = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(2.0d);\n+        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPow = v1.mapPow(2.0d);\n+        double[] result_mapPow = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPow,v_mapPow.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPowToSelf = v1.copy();\n+        v_mapPowToSelf.mapPowToSelf(2.0d);\n+        double[] result_mapPowToSelf = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExp = v1.mapExp();\n+        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExpToSelf = v1.copy();\n+        v_mapExpToSelf.mapExpToSelf();\n+        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n+\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1 = v1.mapExpm1();\n+        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1ToSelf = v1.copy();\n+        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog = v1.mapLog();\n+        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLogToSelf = v1.copy();\n+        v_mapLogToSelf.mapLogToSelf();\n+        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n+\n+        //octave =  log10(v1)\n+        RealVector v_mapLog10 = v1.mapLog10();\n+        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog10ToSelf = v1.copy();\n+        v_mapLog10ToSelf.mapLog10ToSelf();\n+        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1p = v1.mapLog1p();\n+        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1pToSelf = v1.copy();\n+        v_mapLog1pToSelf.mapLog1pToSelf();\n+        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCosh = v1.mapCosh();\n+        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCoshToSelf = v1.copy();\n+        v_mapCoshToSelf.mapCoshToSelf();\n+        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinh = v1.mapSinh();\n+        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinhToSelf = v1.copy();\n+        v_mapSinhToSelf.mapSinhToSelf();\n+        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanh = v1.mapTanh();\n+        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanhToSelf = v1.copy();\n+        v_mapTanhToSelf.mapTanhToSelf();\n+        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCos = v1.mapCos();\n+        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCosToSelf = v1.copy();\n+        v_mapCosToSelf.mapCosToSelf();\n+        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSin = v1.mapSin();\n+        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSinToSelf = v1.copy();\n+        v_mapSinToSelf.mapSinToSelf();\n+        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTan = v1.mapTan();\n+        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTanToSelf = v1.copy();\n+        v_mapTanToSelf.mapTanToSelf();\n+        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n+\n+        double[] vat_a = {0d, 0.5d, 1.0d};\n+        ArrayRealVector vat = new ArrayRealVector(vat_a);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcos = vat.mapAcos();\n+        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcosToSelf = vat.copy();\n+        v_mapAcosToSelf.mapAcosToSelf();\n+        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsin = vat.mapAsin();\n+        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsinToSelf = vat.copy();\n+        v_mapAsinToSelf.mapAsinToSelf();        \n+        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtan = vat.mapAtan();\n+        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtanToSelf = vat.copy();\n+        v_mapAtanToSelf.mapAtanToSelf();\n+        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInv = v1.mapInv();\n+        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n+\n+        double[] abs_a = {-1.0d, 0.0d, 1.0d};\n+        ArrayRealVector abs_v = new ArrayRealVector(abs_a);\n+\n+        //octave =  abs(abs_v)\n+        RealVector v_mapAbs = abs_v.mapAbs();\n+        double[] result_mapAbs = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n+\n+        //octave = abs(abs_v)\n+        RealVector v_mapAbsToSelf = abs_v.copy();\n+        v_mapAbsToSelf.mapAbsToSelf();\n+        double[] result_mapAbsToSelf = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n+\n+        //octave =   sqrt(v1)\n+        RealVector v_mapSqrt = v1.mapSqrt();\n+        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n+\n+        //octave =  sqrt(v1)\n+        RealVector v_mapSqrtToSelf = v1.copy();\n+        v_mapSqrtToSelf.mapSqrtToSelf();\n+        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n+\n+        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};\n+        ArrayRealVector cbrt_v = new ArrayRealVector(cbrt_a);\n+\n+        //octave =  ???\n+        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapCbrtToSelf = cbrt_v.copy();\n+        v_mapCbrtToSelf.mapCbrtToSelf();\n+        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n+\n+        double[] ceil_a = {-1.1d, 0.9d, 1.1d};\n+        ArrayRealVector ceil_v = new ArrayRealVector(ceil_a);\n+\n+        //octave =  ceil(ceil_v)\n+        RealVector v_mapCeil = ceil_v.mapCeil();\n+        double[] result_mapCeil = {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n+\n+        //octave = ceil(ceil_v)\n+        RealVector v_mapCeilToSelf = ceil_v.copy();\n+        v_mapCeilToSelf.mapCeilToSelf();\n+        double[] result_mapCeilToSelf =  {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n+\n+        //octave =  floor(ceil_v)\n+        RealVector v_mapFloor = ceil_v.mapFloor();\n+        double[] result_mapFloor = {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n+\n+        //octave = floor(ceil_v)\n+        RealVector v_mapFloorToSelf = ceil_v.copy();\n+        v_mapFloorToSelf.mapFloorToSelf();\n+        double[] result_mapFloorToSelf =  {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapRint = ceil_v.mapRint();\n+        double[] result_mapRint = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapRintToSelf = ceil_v.copy();\n+        v_mapRintToSelf.mapRintToSelf();\n+        double[] result_mapRintToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapSignum = ceil_v.mapSignum();\n+        double[] result_mapSignum = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapSignumToSelf = ceil_v.copy();\n+        v_mapSignumToSelf.mapSignumToSelf();\n+        double[] result_mapSignumToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n+\n+\n+        // Is with the used resolutions of limited value as test\n+        //octave =  ???\n+        RealVector v_mapUlp = ceil_v.mapUlp();\n+        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapUlpToSelf = ceil_v.copy();\n+        v_mapUlpToSelf.mapUlpToSelf();\n+        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+        ArrayRealVector v2 = new ArrayRealVector(vec2);\n+        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n+\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        //octave =  sqrt(sumsq(v1))\n+        double d_getNorm = v1.getNorm();\n+        assertEquals(\"compare values  \", 3.7416573867739413,d_getNorm);\n+\n+        double d_getL1Norm = v1.getL1Norm();\n+        assertEquals(\"compare values  \",6.0, d_getL1Norm);\n+\n+        double d_getLInfNorm = v1.getLInfNorm();\n+        assertEquals(\"compare values  \",6.0, d_getLInfNorm);\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist = v1.getDistance(v2);\n+        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist_2 = v1.getDistance(v2_t);\n+        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+\n+        //octave =  ???\n+        double d_getL1Distance = v1. getL1Distance(v2);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance );\n+\n+        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n+\n+        //octave =  ???\n+        double d_getLInfDistance = v1. getLInfDistance(v2);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+\n+        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+\n+        //octave =  v1 + v2\n+        ArrayRealVector v_add = v1.add(v2);\n+        double[] result_add = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n+\n+        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n+        RealVector v_add_i = v1.add(vt2);\n+        double[] result_add_i = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n+\n+        //octave =  v1 - v2\n+        ArrayRealVector v_subtract = v1.subtract(v2);\n+        double[] result_subtract = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        RealVector v_subtract_i = v1.subtract(vt2);\n+        double[] result_subtract_i = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n+        double[] result_ebeMultiply = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n+        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        double dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",32d, dot);\n+\n+        // octave  dot(v1,v2_t)\n+        double dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",32d, dot_2);\n+\n+        RealMatrix m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+\n+        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+\n+        RealVector v_unitVector = v1.unitVector();\n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n+\n+        try {\n+            v_null.unitVector();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n+        v_unitize.unitize();\n+        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n+        try {\n+            v_null.unitize();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        ArrayRealVector v_projection = v1.projection(v2);\n+        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n+\n+        RealVector v_projection_2 = v1.projection(v2_t);\n+        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n+\n+    }  \n+\n+    public void testMisc() { \n+        ArrayRealVector v1 = new ArrayRealVector(vec1);\n+        ArrayRealVector v4 = new ArrayRealVector(vec4);\n+        RealVector v4_2 = new ArrayRealVector(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         double[] dout1 = v1.copyOut();\n+        assertEquals(\"testData len\", 3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+       try {\n+            v1.checkVectorDimensions(v4); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+        try {\n+            v1.checkVectorDimensions(v4_2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });\n+\n+        assertFalse(v.isNaN());\n+        v.setEntry(1, Double.NaN);\n+        assertTrue(v.isNaN());\n+\n+        assertFalse(v.isInfinite());\n+        v.setEntry(0, Double.POSITIVE_INFINITY);\n+        assertFalse(v.isInfinite());\n+        v.setEntry(1, 1);\n+        assertTrue(v.isInfinite());\n+\n+        v.setEntry(0, 0);\n+        assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));\n+        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));\n+\n+        assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n+                     new ArrayRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());\n+\n+        assertTrue(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n+                   new ArrayRealVector(new double[] { 0, 1, 2 }).hashCode());\n+\n+    }\n+\n+    public void testSerial()  {\n+        ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });\n+        assertEquals(v,TestUtils.serializeAndRecover(v));\n+    }\n+    \n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+\n+/**\n+ * Test cases for the {@link BlockFieldMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class BlockFieldMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected Fraction[][] id = {\n+            {new Fraction(1),new Fraction(0),new Fraction(0)},\n+            {new Fraction(0),new Fraction(1),new Fraction(0)},\n+            {new Fraction(0),new Fraction(0),new Fraction(1)}\n+    };\n+    \n+    // Test data for group operations\n+    protected Fraction[][] testData = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3)},\n+            {new Fraction(1),new Fraction(0),new Fraction(8)}\n+    };\n+    protected Fraction[][] testDataLU = {\n+            {new Fraction(2), new Fraction(5), new Fraction(3)},\n+            {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)},\n+            {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}\n+    };\n+    protected Fraction[][] testDataPlus2 = {\n+            {new Fraction(3),new Fraction(4),new Fraction(5)},\n+            {new Fraction(4),new Fraction(7),new Fraction(5)},\n+            {new Fraction(3),new Fraction(2),new Fraction(10)}\n+    };\n+    protected Fraction[][] testDataMinus = {\n+            {new Fraction(-1),new Fraction(-2),new Fraction(-3)},\n+            {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, \n+            {new Fraction(-1),new Fraction(0),new Fraction(-8)}\n+    };\n+    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};\n+    protected Fraction[][] testDataInv = {\n+            {new Fraction(-40),new Fraction(16),new Fraction(9)},\n+            {new Fraction(13),new Fraction(-5),new Fraction(-3)},\n+            {new Fraction(5),new Fraction(-2),new Fraction(-1)}\n+    };\n+    protected Fraction[] preMultTest = {new Fraction(8), new Fraction(12), new Fraction(33)};\n+    protected Fraction[][] testData2 = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3)}\n+    };\n+    protected Fraction[][] testData2T = {\n+            {new Fraction(1),new Fraction(2)},\n+            {new Fraction(2),new Fraction(5)},\n+            {new Fraction(3),new Fraction(3)}\n+    };\n+    protected Fraction[][] testDataPlusInv = {\n+            {new Fraction(-39),new Fraction(18),new Fraction(12)},\n+            {new Fraction(15),new Fraction(0),new Fraction(0)},\n+            {new Fraction(6),new Fraction(-2),new Fraction(7)}\n+    };\n+    \n+    // lu decomposition tests\n+    protected Fraction[][] luData = {\n+            {new Fraction(2),new Fraction(3),new Fraction(3)},\n+            {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(6),new Fraction(9),new Fraction(8)}\n+    };\n+    protected Fraction[][] luDataLUDecomposition = {\n+            {new Fraction(6),new Fraction(9),new Fraction(8)},\n+            {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)}\n+    };\n+    \n+    // singular matrices\n+    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };\n+    protected Fraction[][] bigSingular = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},\n+            {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)},\n+            {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}\n+    }; // 4th row = 1st + 2nd\n+    protected Fraction[][] detData = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(4),new Fraction(5),new Fraction(6)},\n+            {new Fraction(7),new Fraction(8),new Fraction(10)}\n+    };\n+    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};\n+    \n+    // vectors\n+    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};\n+    \n+    // submatrix accessor tests\n+    protected Fraction[][] subTestData = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n+            {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},\n+            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}\n+    }; \n+    // array selections\n+    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};\n+    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};\n+    protected Fraction[][] subRows03Cols123 = {\n+            {new Fraction(2), new Fraction(3), new Fraction(4)},\n+            {new Fraction(5), new Fraction(6), new Fraction(7)}\n+    };\n+    // effective permutations\n+    protected Fraction[][] subRows20Cols123 = {\n+            {new Fraction(4), new Fraction(6), new Fraction(8)},\n+            {new Fraction(2), new Fraction(3), new Fraction(4)}\n+    };\n+    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};\n+    // contiguous ranges\n+    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};\n+    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};\n+    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};\n+    // row matrices\n+    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};\n+    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};\n+    // column matrices\n+    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};\n+    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public BlockFieldMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BlockFieldMatrixTest.class);\n+        suite.setName(\"BlockFieldMatrix<Fraction> Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Random r = new Random(66636328996002l);\n+        BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData());\n+        assertEquals(m1, m2);\n+        BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());\n+        assertEquals(m3, m4);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n+        Fraction[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);\n+        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));        \n+        try {\n+            m.subtract(new BlockFieldMatrix<Fraction>(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n+        TestUtils.assertEquals(m.multiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.multiply(m), identity);\n+        TestUtils.assertEquals(m.multiply(identity), m);\n+        TestUtils.assertEquals(identity.multiply(mInv), mInv);\n+        TestUtils.assertEquals(m2.multiply(identity), m2); \n+        try {\n+            m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    }\n+\n+    public void testSeveralBlocks() {\n+\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                m.setEntry(i, j, new Fraction(i * 11 + j, 11));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mT = m.transpose();\n+        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        for (int i = 0; i < mT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mT.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(j, i), mT.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mPm = m.add(m);\n+        for (int i = 0; i < mPm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mPmMm = mPm.subtract(m);\n+        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mTm = mT.multiply(m);\n+        for (int i = 0; i < mTm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mTm.getColumnDimension(); ++j) {\n+                Fraction sum = Fraction.ZERO;\n+                for (int k = 0; k < mT.getColumnDimension(); ++k) {\n+                    sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11)));\n+                }\n+                assertEquals(sum, mTm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mmT = m.multiply(mT);\n+        for (int i = 0; i < mmT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mmT.getColumnDimension(); ++j) {\n+                Fraction sum = Fraction.ZERO;\n+                for (int k = 0; k < m.getColumnDimension(); ++k) {\n+                    sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11)));\n+                }\n+                assertEquals(sum, mmT.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20);\n+        for (int i = 0; i < sub1.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40);\n+        for (int i = 0; i < sub2.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5);\n+        for (int i = 0; i < sub3.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35);\n+        for (int i = 0; i < sub4.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));\n+            }\n+        }\n+\n+    }\n+\n+    //Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply\n+\n+    private Fraction[][] d3 = new Fraction[][] {\n+            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},\n+            {new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}\n+    };\n+    private Fraction[][] d4 = new Fraction[][] {\n+            {new Fraction(1)},\n+            {new Fraction(2)},\n+            {new Fraction(3)},\n+            {new Fraction(4)}\n+    };\n+    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n+     \n+    public void testMultiply2() { \n+       FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+       FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n+       FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n+       TestUtils.assertEquals(m3.multiply(m4), m5);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n+        assertEquals(new Fraction(3),m.getTrace());\n+        m = new BlockFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test scalarAdd */\n+    public void testScalarAdd() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),\n+                               m.scalarAdd(new Fraction(2)));\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(testVector, m.operate(testVector));\n+        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());\n+        m = new BlockFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    public void testOperateLarge() {\n+        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;\n+        Random random = new Random(111007463902334l);\n+        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n+        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n+        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < r; ++i) {\n+            TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));\n+        }\n+    }\n+\n+    public void testOperatePremultiplyLarge() {\n+        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;\n+        Random random = new Random(111007463902334l);\n+        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n+        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n+        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < p; ++i) {\n+            TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2) },\n+                { new Fraction(3), new Fraction(4) },\n+                { new Fraction(5), new Fraction(6) }\n+        });\n+        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( new Fraction(3), b[0]);\n+        assertEquals( new Fraction(7), b[1]);\n+        assertEquals(new Fraction(11), b[2]);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); \n+        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(mIT, mTI);\n+        m = new BlockFieldMatrix<Fraction>(testData2);\n+        FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);\n+        TestUtils.assertEquals(mt, m.transpose());\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n+        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),\n+                               preMultTest);\n+        m = new BlockFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n+        FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n+        TestUtils.assertEquals(m4.preMultiply(m3), m5);\n+        \n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(m.preMultiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.preMultiply(m), identity);\n+        TestUtils.assertEquals(m.preMultiply(identity), m);\n+        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n+        try {\n+            m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.getRow(0), testDataRow1);\n+        TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        assertEquals(m.getEntry(0,1),new Fraction(2));\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        Fraction[][] matrixData = {\n+                {new Fraction(1),new Fraction(2),new Fraction(3)},\n+                {new Fraction(2),new Fraction(5),new Fraction(3)}\n+        };\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData);\n+        // One more with three rows, two columns\n+        Fraction[][] matrixData2 = {\n+                {new Fraction(1),new Fraction(2)},\n+                {new Fraction(2),new Fraction(5)},\n+                {new Fraction(1), new Fraction(7)}\n+        };\n+        FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2);\n+        // Now multiply m by n\n+        FieldMatrix<Fraction> p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        Fraction[][] coefficientsData = {\n+                {new Fraction(2), new Fraction(3), new Fraction(-2)},\n+                {new Fraction(-1), new Fraction(7), new Fraction(6)},\n+                {new Fraction(4), new Fraction(-3), new Fraction(-5)}\n+        };\n+        FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData);\n+        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n+        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n+        assertEquals(new Fraction(2).multiply(solution[0]).\n+                     add(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(2).multiply(solution[2])),\n+                     constants[0]);\n+        assertEquals(new Fraction(-1).multiply(solution[0]).\n+                     add(new Fraction(7).multiply(solution[1])).\n+                     add(new Fraction(6).multiply(solution[2])),\n+                     constants[1]);\n+        assertEquals(new Fraction(4).multiply(solution[0]).\n+                     subtract(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(5).multiply(solution[2])),\n+                     constants[2]);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetSetMatrixLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));\n+\n+        m.setSubMatrix(sub.getData(), 2, 2);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+\n+    public void testCopySubMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                             new Fraction[1][1] :\n+                             new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                    new Fraction[1][1] :\n+                    new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        FieldMatrix<Fraction> m     = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0);\n+        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetSetRowMatrixLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));\n+\n+        m.setRowMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n+        assertEquals(mColumn1, m.getColumnMatrix(1));\n+        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnMatrixLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));\n+\n+        m.setColumnMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+    \n+    public void testGetRowVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n+        assertEquals(mRow0, m.getRowVector(0));\n+        assertEquals(mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowVectorLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));\n+\n+        m.setRowVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowVector(2));\n+\n+    }\n+    \n+    public void testGetColumnVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertEquals(mColumn1, m.getColumnVector(1));\n+        assertEquals(mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnVectorLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1));\n+\n+        m.setColumnVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnVector(2));\n+\n+    }\n+    \n+    private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayFieldVector<Fraction>(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        Fraction[] sub = new Fraction[n];\n+        Arrays.fill(sub, new Fraction(1));\n+\n+        m.setRow(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getRow(2));\n+\n+    }\n+    \n+    public void testGetColumn() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn1 = columnToArray(subColumn1);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnLarge() {\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        Fraction[] sub = new Fraction[n];\n+        Arrays.fill(sub, new Fraction(1));\n+\n+        m.setColumn(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getColumn(2));\n+\n+    }\n+    \n+    private Fraction[] columnToArray(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(Fraction[] expected, Fraction[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();\n+        BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        assertEquals(\"BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new BlockFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new BlockFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        BlockFieldMatrix<Fraction> matrix =\n+            new BlockFieldMatrix<Fraction>(new Fraction[][] {\n+                    {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n+                    {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)},\n+                    {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)}\n+            });\n+        matrix.setSubMatrix(new Fraction[][] {\n+                {new Fraction(3), new Fraction(4)},\n+                {new Fraction(5), new Fraction(6)}\n+        }, 1, 1);\n+        expected =\n+            new BlockFieldMatrix<Fraction>(new Fraction[][] {\n+                    {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)},\n+                    {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},\n+                    {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}\n+            });\n+        assertEquals(expected, matrix);   \n+\n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+    }\n+\n+    public void testSerial()  {\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+\n+    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n+        public SetVisitor() {\n+            super(Fraction.ZERO);\n+        }\n+        @Override\n+        public Fraction visit(int i, int j, Fraction value) {\n+            return new Fraction(i * 11 + j, 11);\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {\n+        private int count;\n+        public GetVisitor() {\n+            super(Fraction.ZERO);\n+            count = 0;\n+        }\n+        @Override\n+        public void visit(int i, int j, Fraction value) {\n+            ++count;\n+            assertEquals(new Fraction(i * 11 + j, 11), value);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {\n+        BlockFieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < columns; ++j) {\n+                int p = r.nextInt(20) - 10;\n+                int q = r.nextInt(20) - 10;\n+                if (q == 0) {\n+                    q = 1;\n+                }\n+                m.setEntry(i, j, new Fraction(p, q));\n+            }\n+        }\n+        return m;\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+/**\n+ * Test cases for the {@link BlockRealMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class BlockRealMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    \n+    // Test data for group operations\n+    protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    protected double[] testDataRow1 = {1d,2d,3d};\n+    protected double[] testDataCol3 = {3d,3d,8d};\n+    protected double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    protected double[] preMultTest = {8,12,33};\n+    protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    protected double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    \n+    // lu decomposition tests\n+    protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n+            {0.33333333333333,0d,0.33333333333333} };\n+    \n+    // singular matrices\n+    protected double[][] singular = { {2d,3d}, {2d,3d} };\n+    protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    \n+    // vectors\n+    protected double[] testVector = {1,2,3};\n+    protected double[] testVector2 = {1,2,3,4};\n+    \n+    // submatrix accessor tests\n+    protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n+            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+    // array selections\n+    protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n+    protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n+    protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}};\n+    // effective permutations\n+    protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}};\n+    protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}};\n+    // contiguous ranges\n+    protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}};\n+    protected double[][] subRows23Cols00 = {{2} , {4}};\n+    protected double[][] subRows00Cols33 = {{4}};\n+    // row matrices\n+    protected double[][] subRow0 = {{1,2,3,4}};\n+    protected double[][] subRow3 = {{4,5,6,7}};\n+    // column matrices\n+    protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n+    protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public BlockRealMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BlockRealMatrixTest.class);\n+        suite.setName(\"BlockRealMatrix Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Random r = new Random(66636328996002l);\n+        BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);\n+        BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());\n+        assertEquals(m1, m2);\n+        BlockRealMatrix m3 = new BlockRealMatrix(testData);\n+        BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());\n+        assertEquals(m3, m4);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+    /** test Frobenius norm */\n+    public void testFrobeniusNorm() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);\n+        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        \n+        try {\n+            m.subtract(new BlockRealMatrix(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        BlockRealMatrix identity = new BlockRealMatrix(id);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n+        assertClose(m.multiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.multiply(m), identity, entryTolerance);\n+        assertClose(m.multiply(identity), m, entryTolerance);\n+        assertClose(identity.multiply(mInv), mInv, entryTolerance);\n+        assertClose(m2.multiply(identity), m2, entryTolerance); \n+        try {\n+            m.multiply(new BlockRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    }\n+\n+    public void testSeveralBlocks() {\n+\n+        RealMatrix m = new BlockRealMatrix(35, 71);\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                m.setEntry(i, j, i + j / 1024.0);\n+            }\n+        }\n+\n+        RealMatrix mT = m.transpose();\n+        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        for (int i = 0; i < mT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mT.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPm = m.add(m);\n+        for (int i = 0; i < mPm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n+                assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mPmMm = mPm.subtract(m);\n+        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mTm = mT.multiply(m);\n+        for (int i = 0; i < mTm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mTm.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < mT.getColumnDimension(); ++k) {\n+                    sum += (k + i / 1024.0) * (k + j / 1024.0);\n+                }\n+                assertEquals(sum, mTm.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix mmT = m.multiply(mT);\n+        for (int i = 0; i < mmT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mmT.getColumnDimension(); ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < m.getColumnDimension(); ++k) {\n+                    sum += (i + k / 1024.0) * (j + k / 1024.0);\n+                }\n+                assertEquals(sum, mmT.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20);\n+        for (int i = 0; i < sub1.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n+                assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70);\n+        for (int i = 0; i < sub2.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n+                assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5);\n+        for (int i = 0; i < sub3.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0);\n+            }\n+        }\n+\n+        RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65);\n+        for (int i = 0; i < sub4.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n+                assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0);\n+            }\n+        }\n+\n+    }\n+\n+    //Additional Test for DenseRealMatrixTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       RealMatrix m3 = new BlockRealMatrix(d3);   \n+       RealMatrix m4 = new BlockRealMatrix(d4);\n+       RealMatrix m5 = new BlockRealMatrix(d5);\n+       assertClose(m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new BlockRealMatrix(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new BlockRealMatrix(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test scalarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new BlockRealMatrix(id);\n+        assertClose(testVector, m.operate(testVector), entryTolerance);\n+        assertClose(testVector, m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);\n+        m = new BlockRealMatrix(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    public void testOperateLarge() {\n+        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * BlockRealMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < r; ++i) {\n+            checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));\n+        }\n+    }\n+\n+    public void testOperatePremultiplyLarge() {\n+        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * BlockRealMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        RealMatrix m1 = createRandomMatrix(random, p, q);\n+        RealMatrix m2 = createRandomMatrix(random, q, r);\n+        RealMatrix m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < p; ++i) {\n+            checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new BlockRealMatrix(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        });\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new BlockRealMatrix(testData); \n+        RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n+        assertClose(mIT, mTI, normTolerance);\n+        m = new BlockRealMatrix(testData2);\n+        RealMatrix mt = new BlockRealMatrix(testData2T);\n+        assertClose(mt, m.transpose(), normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertClose(m.preMultiply(testVector), preMultTest, normTolerance);\n+        assertClose(m.preMultiply(new ArrayRealVector(testVector).getData()),\n+                    preMultTest, normTolerance);\n+        m = new BlockRealMatrix(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        RealMatrix m3 = new BlockRealMatrix(d3);   \n+        RealMatrix m4 = new BlockRealMatrix(d4);\n+        RealMatrix m5 = new BlockRealMatrix(d5);\n+        assertClose(m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        BlockRealMatrix identity = new BlockRealMatrix(id);\n+        assertClose(m.preMultiply(mInv), identity, entryTolerance);\n+        assertClose(mInv.preMultiply(m), identity, entryTolerance);\n+        assertClose(m.preMultiply(identity), m, entryTolerance);\n+        assertClose(identity.preMultiply(mInv), mInv, entryTolerance);\n+        try {\n+            m.preMultiply(new BlockRealMatrix(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertClose(m.getRow(0), testDataRow1, entryTolerance);\n+        assertClose(m.getColumn(2), testDataCol3, entryTolerance);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n+        RealMatrix m = new BlockRealMatrix(matrixData);\n+        // One more with three rows, two columns\n+        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n+        RealMatrix n = new BlockRealMatrix(matrixData2);\n+        // Now multiply m by n\n+        RealMatrix p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n+        RealMatrix coefficients = new BlockRealMatrix(coefficientsData);\n+        double[] constants = {1, -2, 1};\n+        double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n+        assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n+        assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new BlockRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new BlockRealMatrix(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetSetMatrixLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1);\n+\n+        m.setSubMatrix(sub.getData(), 2, 2);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+\n+    public void testCopySubMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                             new double[1][1] :\n+                             new double[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(RealMatrix m, double[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            double[][] sub = (reference == null) ?\n+                    new double[1][1] :\n+                    new double[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        RealMatrix m     = new BlockRealMatrix(subTestData);\n+        RealMatrix mRow0 = new BlockRealMatrix(subRow0);\n+        RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetSetRowMatrixLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1);\n+\n+        m.setRowMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);\n+        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n+        assertEquals(mColumn1, m.getColumnMatrix(1));\n+        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnMatrixLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1);\n+\n+        m.setColumnMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+    \n+    public void testGetRowVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertEquals(mRow0, m.getRowVector(0));\n+        assertEquals(mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowVectorLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealVector sub = new ArrayRealVector(n, 1.0);\n+\n+        m.setRowVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowVector(2));\n+\n+    }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(mColumn1, m.getColumnVector(1));\n+        assertEquals(mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new ArrayRealVector(5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnVectorLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealVector sub = new ArrayRealVector(n, 1.0);\n+\n+        m.setColumnVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnVector(2));\n+\n+    }\n+    \n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new ArrayRealVector(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setRow(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getRow(2));\n+\n+    }\n+    \n+    public void testGetColumn() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        double[] mColumn1 = columnToArray(subColumn1);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        double[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new double[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnLarge() {\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        double[] sub = new double[n];\n+        Arrays.fill(sub, 1.0);\n+\n+        m.setColumn(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(0.0, m.getEntry(i, j), 0.0);\n+                } else {\n+                    assertEquals(1.0, m.getEntry(i, j), 0.0);\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getColumn(2));\n+\n+    }\n+    \n+    private double[] columnToArray(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(double[] expected, double[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m1 = (BlockRealMatrix) m.copy();\n+        BlockRealMatrix mt = (BlockRealMatrix) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new BlockRealMatrix(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        assertEquals(\"BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+                m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        RealMatrix expected = new BlockRealMatrix\n+            (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new BlockRealMatrix\n+            (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new BlockRealMatrix\n+            (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        BlockRealMatrix matrix = new BlockRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n+        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n+        expected = new BlockRealMatrix\n+            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n+        assertEquals(expected, matrix);   \n+\n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new double[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        RealMatrix m = new BlockRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new BlockRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n+        }\n+\n+    }\n+    \n+    public void testSerial()  {\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        assertEquals(m,TestUtils.serializeAndRecover(m));\n+    }\n+\n+    private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n+        @Override\n+        public double visit(int i, int j, double value) {\n+            return i + j / 1024.0;\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultRealMatrixPreservingVisitor {\n+        private int count = 0;\n+        @Override\n+        public void visit(int i, int j, double value) {\n+            ++count;\n+            assertEquals(i + j / 1024.0, value, 0.0);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    //--------------- -----------------Protected methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n+    protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {\n+        assertTrue(m.subtract(n).getNorm() < tolerance);\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(double[] m, double[] n, double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(m[i], n[i], tolerance);\n+        }\n+    }\n+\n+    private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) {\n+        BlockRealMatrix m = new BlockRealMatrix(rows, columns);\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < columns; ++j) {\n+                m.setEntry(i, j, 200 * r.nextDouble() - 100);\n+            }\n+        }\n+        return m;\n+    }\n+    \n+}\n+\n--- a/src/test/org/apache/commons/math/linear/CholeskySolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/CholeskySolverTest.java\n import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n public class CholeskySolverTest extends TestCase {\n \n             fail(\"wrong exception caught\");\n         }\n         try {\n-            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n-        // using RealVectorImpl\n+        // using ArrayRealVector\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n \n         // using RealVector with an alternate implementation\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n--- a/src/test/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenSolverTest.java\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.util.MathUtils;\n \n public class EigenSolverTest extends TestCase {\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            es.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(es.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new ArrayRealVector(es.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n         }\n \n-        // using RealMatrixImpl\n+        // using Array2DRowRealMatrix\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n                          es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n \n         // using RealMatrix with an alternate implementation\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n                          es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n--- a/src/test/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n import org.apache.commons.math.linear.FieldLUDecomposition;\n import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n import org.apache.commons.math.linear.FieldMatrix;\n-import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n import org.apache.commons.math.linear.InvalidMatrixException;\n \n public class FieldLUDecompositionImplTest extends TestCase {\n \n     /** test dimensions */\n     public void testDimensions() {\n-        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);\n         assertEquals(testData.length, LU.getL().getRowDimension());\n         assertEquals(testData.length, LU.getL().getColumnDimension());\n     /** test non-square matrix */\n     public void testNonSquare() {\n         try {\n-            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                     { Fraction.ZERO, Fraction.ZERO },\n                     { Fraction.ZERO, Fraction.ZERO },\n                     { Fraction.ZERO, Fraction.ZERO }\n \n     /** test PA = LU */\n     public void testPAEqualLU() {\n-        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         FieldMatrix<Fraction> l = lu.getL();\n         FieldMatrix<Fraction> u = lu.getU();\n         FieldMatrix<Fraction> p = lu.getP();\n         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n \n-        matrix = new FieldMatrixImpl<Fraction>(testDataMinus);\n+        matrix = new Array2DRowFieldMatrix<Fraction>(testDataMinus);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         l = lu.getL();\n         u = lu.getU();\n         p = lu.getP();\n         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n \n-        matrix = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), 17, 17);\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), 17, 17);\n         for (int i = 0; i < matrix.getRowDimension(); ++i) {\n             matrix.setEntry(i, i, Fraction.ONE);\n         }\n         p = lu.getP();\n         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n \n-        matrix = new FieldMatrixImpl<Fraction>(singular);\n+        matrix = new Array2DRowFieldMatrix<Fraction>(singular);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         assertFalse(lu.getSolver().isNonSingular());\n         assertNull(lu.getL());\n         assertNull(lu.getU());\n         assertNull(lu.getP());\n \n-        matrix = new FieldMatrixImpl<Fraction>(bigSingular);\n+        matrix = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         assertFalse(lu.getSolver().isNonSingular());\n         assertNull(lu.getL());\n \n     /** test that L is lower triangular with unit diagonal */\n     public void testLLowerTriangular() {\n-        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();\n         for (int i = 0; i < l.getRowDimension(); i++) {\n             assertEquals(Fraction.ONE, l.getEntry(i, i));\n \n     /** test that U is upper triangular */\n     public void testUUpperTriangular() {\n-        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();\n         for (int i = 0; i < u.getRowDimension(); i++) {\n             for (int j = 0; j < i; j++) {\n \n     /** test that P is a permutation matrix */\n     public void testPPermutation() {\n-        FieldMatrix<Fraction> matrix = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();\n \n         FieldMatrix<Fraction> ppT = p.multiply(p.transpose());\n         FieldMatrix<Fraction> id  =\n-            new FieldMatrixImpl<Fraction>(FractionField.getInstance(),\n+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),\n                                           p.getRowDimension(), p.getRowDimension());\n         for (int i = 0; i < id.getRowDimension(); ++i) {\n             id.setEntry(i, i, Fraction.ONE);\n     /** test singular */\n     public void testSingular() {\n         FieldLUDecomposition<Fraction> lu =\n-            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(testData));\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n         assertTrue(lu.getSolver().isNonSingular());\n-        lu = new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(singular));\n+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(singular));\n         assertFalse(lu.getSolver().isNonSingular());\n-        lu = new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(bigSingular));\n+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n         assertFalse(lu.getSolver().isNonSingular());\n     }\n \n     /** test matrices values */\n     public void testMatricesValues1() {\n        FieldLUDecomposition<Fraction> lu =\n-            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(testData));\n-        FieldMatrix<Fraction> lRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(2), new Fraction(1), new Fraction(0) },\n                 { new Fraction(1), new Fraction(-2), new Fraction(1) }\n         });\n-        FieldMatrix<Fraction> uRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1),  new Fraction(2), new Fraction(3) },\n                 { new Fraction(0), new Fraction(1), new Fraction(-3) },\n                 { new Fraction(0),  new Fraction(0), new Fraction(-1) }\n         });\n-        FieldMatrix<Fraction> pRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(0), new Fraction(1), new Fraction(0) },\n                 { new Fraction(0), new Fraction(0), new Fraction(1) }\n     /** test matrices values */\n     public void testMatricesValues2() {\n        FieldLUDecomposition<Fraction> lu =\n-            new FieldLUDecompositionImpl<Fraction>(new FieldMatrixImpl<Fraction>(luData));\n-        FieldMatrix<Fraction> lRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(luData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(3), new Fraction(1), new Fraction(0) },\n                 { new Fraction(1), new Fraction(0), new Fraction(1) }\n         });\n-        FieldMatrix<Fraction> uRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(2), new Fraction(3), new Fraction(3)    },\n                 { new Fraction(0), new Fraction(-3), new Fraction(-1)  },\n                 { new Fraction(0), new Fraction(0), new Fraction(4) }\n         });\n-        FieldMatrix<Fraction> pRef = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(0), new Fraction(0), new Fraction(1) },\n                 { new Fraction(0), new Fraction(1), new Fraction(0) }\n--- a/src/test/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/FieldMatrixImplTest.java\n import org.apache.commons.math.fraction.FractionField;\n \n /**\n- * Test cases for the {@link FieldMatrixImpl} class.\n+ * Test cases for the {@link Array2DRowFieldMatrix} class.\n  *\n  * @version $Revision$ $Date$\n  */\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite(FieldMatrixImplTest.class);\n-        suite.setName(\"FieldMatrixImpl<Fraction> Tests\");\n+        suite.setName(\"Array2DRowFieldMatrix<Fraction> Tests\");\n         return suite;\n     }\n     \n     /** test dimensions */\n     public void testDimensions() {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testData2);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n         assertEquals(\"testData row dimension\",3,m.getRowDimension());\n         assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n         assertTrue(\"testData is square\",m.isSquare());\n     \n     /** test copy functions */\n     public void testCopyFunctions() {\n-        FieldMatrixImpl<Fraction> m1 = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(m1.getData());\n+        Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(m1.getData());\n         assertEquals(m2,m1);\n-        FieldMatrixImpl<Fraction> m3 = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> m4 = new FieldMatrixImpl<Fraction>(m3.getData(), false);\n+        Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false);\n         assertEquals(m4,m3);\n     }           \n     \n     /** test add */\n     public void testAdd() {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> mInv = new FieldMatrixImpl<Fraction>(testDataInv);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n         FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n         Fraction[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n     \n     /** test add failure */\n     public void testAddFail() {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testData2);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n         try {\n             m.add(m2);\n             fail(\"IllegalArgumentException expected\");\n     \n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testDataInv);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n         TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));        \n         try {\n-            m.subtract(new FieldMatrixImpl<Fraction>(testData2));\n+            m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n    \n     /** test multiply */\n      public void testMultiply() {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> mInv = new FieldMatrixImpl<Fraction>(testDataInv);\n-        FieldMatrixImpl<Fraction> identity = new FieldMatrixImpl<Fraction>(id);\n-        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(testData2);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n+        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2);\n         TestUtils.assertEquals(m.multiply(mInv), identity);\n         TestUtils.assertEquals(mInv.multiply(m), identity);\n         TestUtils.assertEquals(m.multiply(identity), m);\n         TestUtils.assertEquals(identity.multiply(mInv), mInv);\n         TestUtils.assertEquals(m2.multiply(identity), m2); \n         try {\n-            m.multiply(new FieldMatrixImpl<Fraction>(bigSingular));\n+            m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n         }      \n     }   \n     \n-    //Additional Test for FieldMatrixImpl<Fraction>Test.testMultiply\n+    //Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply\n \n     private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}};\n     private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};\n     private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n      \n     public void testMultiply2() { \n-       FieldMatrix<Fraction> m3 = new FieldMatrixImpl<Fraction>(d3);   \n-       FieldMatrix<Fraction> m4 = new FieldMatrixImpl<Fraction>(d4);\n-       FieldMatrix<Fraction> m5 = new FieldMatrixImpl<Fraction>(d5);\n+       FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);   \n+       FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n+       FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);\n        TestUtils.assertEquals(m3.multiply(m4), m5);\n    }  \n         \n     /** test trace */\n     public void testTrace() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(id);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n         assertEquals(\"identity trace\",new Fraction(3),m.getTrace());\n-        m = new FieldMatrixImpl<Fraction>(testData2);\n+        m = new Array2DRowFieldMatrix<Fraction>(testData2);\n         try {\n             m.getTrace();\n             fail(\"Expecting NonSquareMatrixException\");\n     \n     /** test sclarAdd */\n     public void testScalarAdd() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        TestUtils.assertEquals(new FieldMatrixImpl<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));\n     }\n                     \n     /** test operate */\n     public void testOperate() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(id);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n         TestUtils.assertEquals(testVector, m.operate(testVector));\n-        TestUtils.assertEquals(testVector, m.operate(new FieldVectorImpl<Fraction>(testVector)).getData());\n-        m = new FieldMatrixImpl<Fraction>(bigSingular);\n+        TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData());\n+        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n \n     /** test issue MATH-209 */\n     public void testMath209() {\n-        FieldMatrix<Fraction> a = new FieldMatrixImpl<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> a = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) }\n         }, false);\n         Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n     \n     /** test transpose */\n     public void testTranspose() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData); \n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); \n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n         FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(mIT, mTI);\n-        m = new FieldMatrixImpl<Fraction>(testData2);\n-        FieldMatrix<Fraction> mt = new FieldMatrixImpl<Fraction>(testData2T);\n+        m = new Array2DRowFieldMatrix<Fraction>(testData2);\n+        FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T);\n         TestUtils.assertEquals(mt, m.transpose());\n     }\n     \n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n-        TestUtils.assertEquals(m.preMultiply(new FieldVectorImpl<Fraction>(testVector).getData()),\n+        TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()),\n                                preMultTest);\n-        m = new FieldMatrixImpl<Fraction>(bigSingular);\n+        m = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.preMultiply(testVector);\n             fail(\"expecting IllegalArgumentException\");\n     }\n     \n     public void testPremultiply() {\n-        FieldMatrix<Fraction> m3 = new FieldMatrixImpl<Fraction>(d3);   \n-        FieldMatrix<Fraction> m4 = new FieldMatrixImpl<Fraction>(d4);\n-        FieldMatrix<Fraction> m5 = new FieldMatrixImpl<Fraction>(d5);\n+        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n+        FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);\n         TestUtils.assertEquals(m4.preMultiply(m3), m5);\n         \n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> mInv = new FieldMatrixImpl<Fraction>(testDataInv);\n-        FieldMatrixImpl<Fraction> identity = new FieldMatrixImpl<Fraction>(id);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n+        Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);\n         TestUtils.assertEquals(m.preMultiply(mInv), identity);\n         TestUtils.assertEquals(mInv.preMultiply(m), identity);\n         TestUtils.assertEquals(m.preMultiply(identity), m);\n         TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n         try {\n-            m.preMultiply(new FieldMatrixImpl<Fraction>(bigSingular));\n+            m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n     }\n     \n     public void testGetVectors() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.getRow(0), testDataRow1);\n         TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n         try {\n     }\n     \n     public void testGetEntry() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         assertEquals(\"get entry\",m.getEntry(0,1),new Fraction(2));\n         try {\n             m.getEntry(10, 4);\n                 {new Fraction(1),new Fraction(2),new Fraction(3)},\n                 {new Fraction(2),new Fraction(5),new Fraction(3)}\n         };\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(matrixData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(matrixData);\n         // One more with three rows, two columns\n         Fraction[][] matrixData2 = {\n                 {new Fraction(1),new Fraction(2)},\n                 {new Fraction(2),new Fraction(5)},\n                 {new Fraction(1), new Fraction(7)}\n         };\n-        FieldMatrix<Fraction> n = new FieldMatrixImpl<Fraction>(matrixData2);\n+        FieldMatrix<Fraction> n = new Array2DRowFieldMatrix<Fraction>(matrixData2);\n         // Now multiply m by n\n         FieldMatrix<Fraction> p = m.multiply(n);\n         assertEquals(2, p.getRowDimension());\n                 {new Fraction(-1), new Fraction(7), new Fraction(6)},\n                 {new Fraction(4), new Fraction(-3), new Fraction(-5)}\n         };\n-        FieldMatrix<Fraction> coefficients = new FieldMatrixImpl<Fraction>(coefficientsData);\n+        FieldMatrix<Fraction> coefficients = new Array2DRowFieldMatrix<Fraction>(coefficientsData);\n         Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n         Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n         assertEquals(new Fraction(2).multiply(solution[0]).\n     \n     // test submatrix accessors\n     public void testGetSubMatrix() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n         checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n                                    boolean mustFail) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n-            assertEquals(new FieldMatrixImpl<Fraction>(reference), sub);\n+            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n                                    boolean mustFail) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n-            assertEquals(new FieldMatrixImpl<Fraction>(reference), sub);\n+            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n     }\n \n     public void testCopySubMatrix() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n         checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n                              new Fraction[1][1] :\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n-            assertEquals(new FieldMatrixImpl<Fraction>(reference), new FieldMatrixImpl<Fraction>(sub));\n+            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n                     new Fraction[1][1] :\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n-            assertEquals(new FieldMatrixImpl<Fraction>(reference), new FieldMatrixImpl<Fraction>(sub));\n+            assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n     }\n \n     public void testGetRowMatrix() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mRow0 = new FieldMatrixImpl<Fraction>(subRow0);\n-        FieldMatrix<Fraction> mRow3 = new FieldMatrixImpl<Fraction>(subRow3);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0);\n+        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n         assertEquals(\"Row0\", mRow0, \n                 m.getRowMatrix(0));\n         assertEquals(\"Row3\", mRow3, \n     }\n     \n     public void testSetRowMatrix() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mRow3 = new FieldMatrixImpl<Fraction>(subRow3);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n         assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowMatrix(0, mRow3);\n         assertEquals(mRow3, m.getRowMatrix(0));\n     }\n     \n     public void testGetColumnMatrix() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mColumn1 = new FieldMatrixImpl<Fraction>(subColumn1);\n-        FieldMatrix<Fraction> mColumn3 = new FieldMatrixImpl<Fraction>(subColumn3);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);\n         assertEquals(\"Column1\", mColumn1, \n                 m.getColumnMatrix(1));\n         assertEquals(\"Column3\", mColumn3, \n     }\n \n     public void testSetColumnMatrix() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mColumn3 = new FieldMatrixImpl<Fraction>(subColumn3);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);\n         assertNotSame(mColumn3, m.getColumnMatrix(1));\n         m.setColumnMatrix(1, mColumn3);\n         assertEquals(mColumn3, m.getColumnMatrix(1));\n     }\n \n     public void testGetRowVector() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n-        FieldVector<Fraction> mRow0 = new FieldVectorImpl<Fraction>(subRow0[0]);\n-        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n         assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n     }\n \n     public void testSetRowVector() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n-        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n         assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n         assertEquals(mRow3, m.getRowVector(0));\n             // expected\n         }\n         try {\n-            m.setRowVector(0, new FieldVectorImpl<Fraction>(FractionField.getInstance(), 5));\n+            m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n             fail(\"Expecting InvalidMatrixException\");\n         } catch (InvalidMatrixException ex) {\n             // expected\n     }\n     \n     public void testGetColumnVector() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n         assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n     }\n \n     public void testSetColumnVector() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n         assertNotSame(mColumn3, m.getColumnVector(1));\n         m.setColumnVector(1, mColumn3);\n             // expected\n         }\n         try {\n-            m.setColumnVector(0, new FieldVectorImpl<Fraction>(FractionField.getInstance(), 5));\n+            m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n             fail(\"Expecting InvalidMatrixException\");\n         } catch (InvalidMatrixException ex) {\n             // expected\n         for (int i = 0; i < data.length; ++i) {\n             data[i] = column[i][0];\n         }\n-        return new FieldVectorImpl<Fraction>(data, false);\n+        return new ArrayFieldVector<Fraction>(data, false);\n     }\n \n     public void testGetRow() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkArrays(subRow0[0], m.getRow(0));\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n     }\n \n     public void testSetRow() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n         m.setRow(0, subRow3[0]);\n         checkArrays(subRow3[0], m.getRow(0));\n     }\n     \n     public void testGetColumn() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn1 = columnToArray(subColumn1);\n         Fraction[] mColumn3 = columnToArray(subColumn3);\n         checkArrays(mColumn1, m.getColumn(1));\n     }\n \n     public void testSetColumn() {\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn3 = columnToArray(subColumn3);\n         assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n         m.setColumn(1, mColumn3);\n     }\n     \n     public void testEqualsAndHashCode() {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        FieldMatrixImpl<Fraction> m1 = (FieldMatrixImpl<Fraction>) m.copy();\n-        FieldMatrixImpl<Fraction> mt = (FieldMatrixImpl<Fraction>) m.transpose();\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy();\n+        Array2DRowFieldMatrix<Fraction> mt = (Array2DRowFieldMatrix<Fraction>) m.transpose();\n         assertTrue(m.hashCode() != mt.hashCode());\n         assertEquals(m.hashCode(), m1.hashCode());\n         assertEquals(m, m);\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new FieldMatrixImpl<Fraction>(bigSingular))); \n+        assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular))); \n     }\n     \n     public void testToString() {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n-        assertEquals(\"FieldMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance());\n-        assertEquals(\"FieldMatrixImpl{}\", m.toString());\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n+        assertEquals(\"Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n+        assertEquals(\"Array2DRowFieldMatrix{}\", m.toString());\n     }\n     \n     public void testSetSubMatrix() throws Exception {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         m.setSubMatrix(detData2,1,1);\n-        FieldMatrix<Fraction> expected = new FieldMatrixImpl<Fraction>\n+        FieldMatrix<Fraction> expected = new Array2DRowFieldMatrix<Fraction>\n             (new Fraction[][] {\n                     {new Fraction(1),new Fraction(2),new Fraction(3)},\n                     {new Fraction(2),new Fraction(1),new Fraction(3)},\n         assertEquals(expected, m);  \n         \n         m.setSubMatrix(detData2,0,0);\n-        expected = new FieldMatrixImpl<Fraction>\n+        expected = new Array2DRowFieldMatrix<Fraction>\n             (new Fraction[][] {\n                     {new Fraction(1),new Fraction(3),new Fraction(3)},\n                     {new Fraction(2),new Fraction(4),new Fraction(3)},\n         assertEquals(expected, m);  \n         \n         m.setSubMatrix(testDataPlus2,0,0);      \n-        expected = new FieldMatrixImpl<Fraction>\n+        expected = new Array2DRowFieldMatrix<Fraction>\n             (new Fraction[][] {\n                     {new Fraction(3),new Fraction(4),new Fraction(5)},\n                     {new Fraction(4),new Fraction(7),new Fraction(5)},\n         } catch (NullPointerException e) {\n             // expected\n         }\n-        FieldMatrixImpl<Fraction> m2 = new FieldMatrixImpl<Fraction>(FractionField.getInstance());\n+        Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n         try {\n             m2.setSubMatrix(testData,0,1);\n             fail(\"expecting IllegalStateException\");\n         int columns = 75;\n \n         FieldMatrix<Fraction> m =\n-            new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new FieldMatrixImpl<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n     }\n \n     public void testSerial()  {\n-        FieldMatrixImpl<Fraction> m = new FieldMatrixImpl<Fraction>(testData);\n+        Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n   \n                 out[i][j] = matrix.getEntry(permutation[i], j);\n             }\n         }\n-        return new FieldMatrixImpl<Fraction>(out);\n+        return new Array2DRowFieldMatrix<Fraction>(out);\n     }\n     \n }\n--- a/src/test/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/LUSolverTest.java\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n public class LUSolverTest extends TestCase {\n     private double[][] testData = {\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n-        // using RealVectorImpl\n+        // using ArrayRealVector\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n \n         // using RealVector with an alternate implementation\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n--- a/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n     }\n \n     public void testcreateFieldMatrix() {\n-        assertEquals(new FieldMatrixImpl<Fraction>(asFraction(testData)), \n+        assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)), \n                      MatrixUtils.createFieldMatrix(asFraction(testData)));\n-        assertEquals(new FieldMatrixImpl<Fraction>(fractionColMatrix), \n+        assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix), \n                      MatrixUtils.createFieldMatrix(fractionColMatrix));\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged\n     \n     public void testCreateRowFieldMatrix() {\n         assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),\n-                     new FieldMatrixImpl<Fraction>(asFraction(rowMatrix)));\n+                     new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));\n         assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow),\n-                     new FieldMatrixImpl<Fraction>(fractionRowMatrix));\n+                     new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix));\n         try {\n             MatrixUtils.createRowFieldMatrix(new Fraction[] {});  // empty\n             fail(\"Expecting IllegalArgumentException\");\n     \n     public void testCreateColumnFieldMatrix() {\n         assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),\n-                     new FieldMatrixImpl<Fraction>(asFraction(colMatrix)));\n+                     new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));\n         assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol),\n-                     new FieldMatrixImpl<Fraction>(fractionColMatrix));\n+                     new Array2DRowFieldMatrix<Fraction>(fractionColMatrix));\n \n         try {\n             MatrixUtils.createColumnFieldMatrix(new Fraction[] {});  // empty\n                 { new BigFraction(2), new BigFraction(5), new BigFraction(3) },\n                 { new BigFraction(1), new BigFraction(0), new BigFraction(8) }\n         };\n-        FieldMatrix<BigFraction> m = new FieldMatrixImpl<BigFraction>(bfData, false);\n+        FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false);\n         RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m);\n-        RealMatrix reference = new RealMatrixImpl(testData, false);\n+        RealMatrix reference = new Array2DRowRealMatrix(testData, false);\n         assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n     }\n \n                 { new Fraction(2), new Fraction(5), new Fraction(3) },\n                 { new Fraction(1), new Fraction(0), new Fraction(8) }\n         };\n-        FieldMatrix<Fraction> m = new FieldMatrixImpl<Fraction>(fData, false);\n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false);\n         RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m);\n-        RealMatrix reference = new RealMatrixImpl(testData, false);\n+        RealMatrix reference = new Array2DRowRealMatrix(testData, false);\n         assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0);\n     }\n \n--- a/src/test/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRSolverTest.java\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n \n public class QRSolverTest extends TestCase {\n     double[][] testData3x3NonSingular = { \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             final double[] x = solver.solve(b.getColumn(i));\n-            final double error = new RealVectorImpl(x).subtract(xRef.getColumnVector(i)).getNorm();\n+            final double error = new ArrayRealVector(x).subtract(xRef.getColumnVector(i)).getNorm();\n             assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n         }\n \n-        // using RealVectorImpl\n+        // using ArrayRealVector\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             final RealVector x = solver.solve(b.getColumnVector(i));\n             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n \n         // using RealVector with an alternate implementation\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n             final RealVector x = solver.solve(v);\n             final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n             assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n  *\n  * @version $Revision$ $Date$\n  */\n-\n+@Deprecated\n public final class RealMatrixImplTest extends TestCase {\n     \n     // 3 x 3 identity matrix\n         TestUtils.assertEquals(\"identity operate\", testVector,\n                     m.operate(testVector), entryTolerance);\n         TestUtils.assertEquals(\"identity operate\", testVector,\n-                    m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);\n+                    m.operate(new ArrayRealVector(testVector)).getData(), entryTolerance);\n         m = new RealMatrixImpl(bigSingular);\n         try {\n             m.operate(testVector);\n         RealMatrix m = new RealMatrixImpl(testData);\n         TestUtils.assertEquals(\"premultiply\", m.preMultiply(testVector),\n                     preMultTest, normTolerance);\n-        TestUtils.assertEquals(\"premultiply\", m.preMultiply(new RealVectorImpl(testVector).getData()),\n+        TestUtils.assertEquals(\"premultiply\", m.preMultiply(new ArrayRealVector(testVector).getData()),\n                     preMultTest, normTolerance);\n         m = new RealMatrixImpl(bigSingular);\n         try {\n \n     public void testGetRowVector() {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n-        RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n-        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n         assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n \n     public void testSetRowVector() {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n-        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n         assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n         assertEquals(mRow3, m.getRowVector(0));\n             // expected\n         }\n         try {\n-            m.setRowVector(0, new RealVectorImpl(5));\n+            m.setRowVector(0, new ArrayRealVector(5));\n             fail(\"Expecting InvalidMatrixException\");\n         } catch (InvalidMatrixException ex) {\n             // expected\n             // expected\n         }\n         try {\n-            m.setColumnVector(0, new RealVectorImpl(5));\n+            m.setColumnVector(0, new ArrayRealVector(5));\n             fail(\"Expecting InvalidMatrixException\");\n         } catch (InvalidMatrixException ex) {\n             // expected\n         for (int i = 0; i < data.length; ++i) {\n             data[i] = column[i][0];\n         }\n-        return new RealVectorImpl(data, false);\n+        return new ArrayRealVector(data, false);\n     }\n \n     public void testGetRow() {\n--- a/src/test/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n     }\n    \n     public void testSimpleNoDecimals() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});\n         String expected = \"{1; 1; 1}\";\n         String actual = realVectorFormat.format(c); \n         assertEquals(expected, actual);\n     }\n \n     public void testSimpleWithDecimals() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});\n         String expected =\n             \"{1\"    + getDecimalCharacter() +\n             \"23; 1\" + getDecimalCharacter() +\n     }\n \n     public void testSimpleWithDecimalsTrunc() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n         String expected =\n             \"{1\"    + getDecimalCharacter() +\n             \"23; 1\" + getDecimalCharacter() +\n     }\n \n     public void testNegativeX() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});\n         String expected =\n             \"{-1\"    + getDecimalCharacter() +\n             \"23; 1\" + getDecimalCharacter() +\n     }\n \n     public void testNegativeY() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});\n         String expected =\n             \"{1\"    + getDecimalCharacter() +\n             \"23; -1\" + getDecimalCharacter() +\n     }\n \n     public void testNegativeZ() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});\n         String expected =\n             \"{1\"    + getDecimalCharacter() +\n             \"23; 1\" + getDecimalCharacter() +\n     }\n \n     public void testNonDefaultSetting() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});\n         String expected = \"[1 : 1 : 1]\";\n         String actual = realVectorFormatSquare.format(c); \n         assertEquals(expected, actual);\n         Locale defaultLocal = Locale.getDefault();\n         Locale.setDefault(getLocale());\n         \n-        RealVectorImpl c = new RealVectorImpl(new double[] {232.222, -342.33, 432.444});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {232.222, -342.33, 432.444});\n         String expected =\n             \"{232\"    + getDecimalCharacter() +\n             \"22; -342\" + getDecimalCharacter() +\n     }\n \n     public void testNan() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN});\n+        ArrayRealVector c = new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN});\n         String expected = \"{(NaN); (NaN); (NaN)}\";\n         String actual = realVectorFormat.format(c); \n         assertEquals(expected, actual);\n     }\n \n     public void testPositiveInfinity() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {\n                 Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n         });\n         String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n     }\n \n     public void tesNegativeInfinity() {\n-        RealVectorImpl c = new RealVectorImpl(new double[] {\n+        ArrayRealVector c = new ArrayRealVector(new double[] {\n                 Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n         });\n         String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n \n     public void testParseSimpleNoDecimals() {\n         String source = \"{1; 1; 1}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n     }\n \n     public void testParseIgnoredWhitespace() {\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});\n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});\n         ParsePosition pos1 = new ParsePosition(0);\n         String source1 = \"{1;1;1}\";\n         assertEquals(expected, realVectorFormat.parseObject(source1, pos1));\n             \"23; 1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"2323; 1\" + getDecimalCharacter() +\n             \"4343; 1\" + getDecimalCharacter() +\n             \"6333}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"2323; 1\" + getDecimalCharacter() +\n             \"4343; 1\" + getDecimalCharacter() +\n             \"6333}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"2323; -1\" + getDecimalCharacter() +\n             \"4343; 1\" + getDecimalCharacter() +\n             \"6333}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"2323; 1\" + getDecimalCharacter() +\n             \"4343; -1\" + getDecimalCharacter() +\n             \"6333}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"2323; -1\" + getDecimalCharacter() +\n             \"4343; -1\" + getDecimalCharacter() +\n             \"6333}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, -1.4343, -1.6333});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, -1.4343, -1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"0; -1\" + getDecimalCharacter() +\n             \"4343; 1\" + getDecimalCharacter() +\n             \"6333}\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {0.0, -1.4343, 1.6333});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {0.0, -1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"2323 : 1\" + getDecimalCharacter() +\n             \"4343 : 1\" + getDecimalCharacter() +\n             \"6333]\";\n-        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n-        try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormatSquare.parseObject(source); \n+        ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormatSquare.parseObject(source); \n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n     public void testParseNan() {\n         String source = \"{(NaN); (NaN); (NaN)}\";\n         try {\n-            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n-            assertEquals(new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);\n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            assertEquals(new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         }\n     public void testParsePositiveInfinity() {\n         String source = \"{(Infinity); (Infinity); (Infinity)}\";\n         try {\n-            RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); \n-            assertEquals(new RealVectorImpl(new double[] {\n+            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source); \n+            assertEquals(new ArrayRealVector(new double[] {\n                     Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n             }), actual);\n         } catch (ParseException ex) {\n     public void testParseNegativeInfinity() {\n         String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n         try {\n-            RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); \n-            assertEquals(new RealVectorImpl(new double[] {\n+            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source); \n+            assertEquals(new ArrayRealVector(new double[] {\n                     Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n             }), actual);\n         } catch (ParseException ex) {\n     }\n \n     public void testParseManyComponents() throws ParseException {\n-        RealVectorImpl parsed =\n-            (RealVectorImpl) realVectorFormat.parseObject(\"{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}\");\n+        ArrayRealVector parsed =\n+            (ArrayRealVector) realVectorFormat.parseObject(\"{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}\");\n         assertEquals(24, parsed.getDimension());\n     }\n \n--- a/src/test/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/SingularValueSolverTest.java\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.SingularValueDecompositionImpl;\n \n public class SingularValueSolverTest extends TestCase {\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n-        // using RealMatrixImpl\n+        // using Array2DRowRealMatrix\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n \n         // using RealMatrix with an alternate implementation\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n--- a/src/test/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n         SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n         assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n                 entryTolerance);\n-        assertClose(\"inverse multiply\", m.multiply(new FieldMatrixImpl<Fraction>(testDataInv)), identity,\n+        assertClose(\"inverse multiply\", m.multiply(new Array2DRowFieldMatrix<Fraction>(testDataInv)), identity,\n                     entryTolerance);\n         assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n                 entryTolerance);\n         }\n     }\n \n-    // Additional Test for RealMatrixImplTest.testMultiply\n+    // Additional Test for Array2DRowRealMatrixTest.testMultiply\n \n     private Fraction[][] d3 = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) } };\n     private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } };\n         assertClose(\"identity operate\", testVector, m.operate(testVector),\n                 entryTolerance);\n         assertClose(\"identity operate\", testVector, m.operate(\n-                new FieldVectorImpl<Fraction>(testVector)).getData(), entryTolerance);\n+                new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance);\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.operate(testVector);\n         assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n             normTolerance);\n         assertClose(\"premultiply\", m.preMultiply(\n-            new FieldVectorImpl<Fraction>(testVector).getData()), preMultTest, normTolerance);\n+            new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest, normTolerance);\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n \n     public void testGetRowVector() {\n         FieldMatrix<Fraction> m = createSparseMatrix(subTestData);\n-        FieldVector<Fraction> mRow0 = new FieldVectorImpl<Fraction>(subRow0[0]);\n-        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]);\n         assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n         for (int i = 0; i < data.length; ++i) {\n             data[i] = column[i][0];\n         }\n-        return new FieldVectorImpl<Fraction>(data, false);\n+        return new ArrayFieldVector<Fraction>(data, false);\n     }\n \n     public void testEqualsAndHashCode() {\n--- a/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n         }\n     }\n \n-    // Additional Test for RealMatrixImplTest.testMultiply\n+    // Additional Test for Array2DRowRealMatrixTest.testMultiply\n \n     private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };\n     private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } };\n         assertClose(\"identity operate\", testVector, m.operate(testVector),\n                 entryTolerance);\n         assertClose(\"identity operate\", testVector, m.operate(\n-                new RealVectorImpl(testVector)).getData(), entryTolerance);\n+                new ArrayRealVector(testVector)).getData(), entryTolerance);\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.operate(testVector);\n         assertClose(\"premultiply\", m.preMultiply(testVector), preMultTest,\n             normTolerance);\n         assertClose(\"premultiply\", m.preMultiply(\n-            new RealVectorImpl(testVector).getData()), preMultTest, normTolerance);\n+            new ArrayRealVector(testVector).getData()), preMultTest, normTolerance);\n         m = createSparseMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n \n     public void testGetRowVector() {\n         RealMatrix m = createSparseMatrix(subTestData);\n-        RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n-        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n+        RealVector mRow3 = new ArrayRealVector(subRow3[0]);\n         assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n         for (int i = 0; i < data.length; ++i) {\n             data[i] = column[i][0];\n         }\n-        return new RealVectorImpl(data, false);\n+        return new ArrayRealVector(data, false);\n     }\n \n     public void testEqualsAndHashCode() {\n--- a/src/test/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n import java.util.Collection;\n \n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.RealVectorImpl;\n+import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n         String[] equationParts = s.split(\"[>|<]?=\");\n         double rhs = Double.parseDouble(equationParts[1].trim());\n \n-        RealVector lhs = new RealVectorImpl(numCoefficients);\n+        RealVector lhs = new ArrayRealVector(numCoefficients);\n         String left = equationParts[0].replaceAll(\" ?x\", \"\");\n         String[] coefficients = left.split(\" \");\n         for (String coefficient : coefficients) {\n--- a/src/test/org/apache/commons/math/stat/correlation/CovarianceTest.java\n+++ b/src/test/org/apache/commons/math/stat/correlation/CovarianceTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.Variance;\n \n import junit.framework.TestCase;\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n-        RealMatrix matrix = new RealMatrixImpl(new double[][] {{0},{1}});\n+        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {{0},{1}});\n         try {\n             new Covariance(matrix);\n             fail(\"Expecting IllegalArgumentException\");\n         assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);\n         \n         // All columns same -> all entries = column variance\n-        RealMatrix repeatedColumns = new RealMatrixImpl(47, 3);\n+        RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);\n         for (int i = 0; i < 3; i++) {\n             repeatedColumns.setColumnMatrix(i, matrix.getColumnMatrix(0));\n         }\n             System.arraycopy(data, ptr, matrixData[i], 0, nCols);\n             ptr += nCols;\n         }\n-        return new RealMatrixImpl(matrixData); \n+        return new Array2DRowRealMatrix(matrixData); \n     }\n }\n--- a/src/test/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.MatrixVisitorException;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.junit.Before;\n import org.junit.Test;\n \n         TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},\n                                1e-14);\n         RealMatrix errors =\n-            new RealMatrixImpl(regression.estimateRegressionParametersVariance(), false);\n+            new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(), false);\n         final double[] s = { 1.0, -1.0 /  2.0, -1.0 /  3.0, -1.0 /  4.0, -1.0 /  5.0, -1.0 /  6.0 };\n-        RealMatrix referenceVariance = new RealMatrixImpl(s.length, s.length);\n+        RealMatrix referenceVariance = new Array2DRowRealMatrix(s.length, s.length);\n         referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n             @Override\n             public double visit(int row, int column, double value)", "timestamp": 1244710442, "metainfo": ""}