{"sha": "a7fbd3edc48543cd58e9599a6a81583d30ecdf64", "log": "Applied Brent Wardens Bug fixes to Complex implementation and tests.   ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/ComplexMath.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexMath.java\n  * Reference:\n  *   http://myweb.lmu.edu/dmsmith/ZMLIB.pdf\n  * \n- * @version $Revision: 1.3 $ $Date: 2003/11/14 22:22:22 $\n+ * @version $Revision: 1.4 $ $Date: 2003/11/15 18:52:31 $\n  */\n public class ComplexMath {\n     \n             return Complex.NaN;\n         }\n         \n+        \n         return Complex.I.multiply(\n             log(Complex.I.add(z).divide(Complex.I.subtract(z))))\n-            .multiply(new Complex(2.0, 0.0));\n+            .divide(new Complex(2.0, 0.0));\n     }\n     \n     /**\n         if (a >= 0.0) {\n             return new Complex(t, b / (2.0 * t));\n         } else {\n-            double s = (b > 0.0 ? 1.0 : (b < 0.0 ? -1.0 : 0.0));\n-            return new Complex(Math.abs(z.getImaginary()) / (2.0 * t), s * t);\n+            return new Complex(Math.abs(z.getImaginary()) / (2.0 * t),\n+                MathUtils.sign(b) * t);\n         }\n     }\n     \n         double b2 = 2.0 * z.getImaginary();\n         double d = Math.cos(a2) + MathUtils.cosh(b2);\n         \n-        return new Complex(Math.sin(a2) / d, MathUtils.sinh(b2) / 2);\n+        return new Complex(Math.sin(a2) / d, MathUtils.sinh(b2) / d);\n     }\n     \n     /**\n         double b2 = 2.0 * z.getImaginary();\n         double d = MathUtils.cosh(a2) + Math.cos(b2);\n         \n-        return new Complex(MathUtils.sinh(a2) / d, Math.sin(b2) / 2);\n+        return new Complex(MathUtils.sinh(a2) / d, Math.sin(b2) / d);\n     }\n }\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n import org.apache.commons.math.stat.univariate.moment.Variance;\n import org.apache.commons.math.stat.univariate.rank.Max;\n import org.apache.commons.math.stat.univariate.rank.Min;\n+import org.apache.commons.math.stat.univariate.rank.Percentile;\n import org.apache.commons.math.stat.univariate.summary.Product;\n import org.apache.commons.math.stat.univariate.summary.Sum;\n import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n  * StatUtils provides easy static implementations of common double[] based\n  * statistical methods. These return a single result value or in some cases, as\n  * identified in the javadoc for each method, Double.NaN.\n- * @version $Revision: 1.21 $ $Date: 2003/11/14 22:22:18 $\n+ * @version $Revision: 1.22 $ $Date: 2003/11/15 18:52:31 $\n  */\n public final class StatUtils {\n \n-\t/** sum */\n-\tprivate static UnivariateStatistic sum = new Sum();\n-\t\n-\t/** sumSq */\n-\tprivate static UnivariateStatistic sumSq = new SumOfSquares();\n-\t\n-\t/** prod */\n-\tprivate static UnivariateStatistic prod = new Product();\n-\t\n-\t/** sumLog */\n-\tprivate static UnivariateStatistic sumLog = new SumOfLogs();\n-\t\n-\t/** min */\n-\tprivate static UnivariateStatistic min = new Min();\t\n-\t\n-\t/** max */\n-\tprivate static UnivariateStatistic max = new Max();\t\n-\t\n-\t/** mean */\n-\tprivate static UnivariateStatistic mean = new Mean();\t\n-\t\n-\t/** variance */\n-\tprivate static UnivariateStatistic variance = new Variance();\t\n-\t\t\n+    /** sum */\n+    private static UnivariateStatistic sum = new Sum();\n+\n+    /** sumSq */\n+    private static UnivariateStatistic sumSq = new SumOfSquares();\n+\n+    /** prod */\n+    private static UnivariateStatistic prod = new Product();\n+\n+    /** sumLog */\n+    private static UnivariateStatistic sumLog = new SumOfLogs();\n+\n+    /** min */\n+    private static UnivariateStatistic min = new Min();\n+\n+    /** max */\n+    private static UnivariateStatistic max = new Max();\n+\n+    /** mean */\n+    private static UnivariateStatistic mean = new Mean();\n+\n+    /** variance */\n+    private static UnivariateStatistic variance = new Variance();\n+\n+    /** variance */\n+    private static Percentile percentile = new Percentile();\n+\n     /**\n      * Private Constructor\n      */\n      * @return the sum of the values or Double.NaN if the array is empty\n      */\n     public static double sum(final double[] values) {\n-\t\treturn sum.evaluate(values);\n+        return sum.evaluate(values);\n     }\n \n     /**\n      * @return the sum of the squared values or Double.NaN if the array is empty\n      */\n     public static double sumSq(final double[] values) {\n-\t\treturn sumSq.evaluate(values);\n+        return sumSq.evaluate(values);\n     }\n \n     /**\n      * @return the sumLog value or Double.NaN if the array is empty\n      */\n     public static double sumLog(final double[] values) {\n-\t\treturn sumLog.evaluate(values);\n+        return sumLog.evaluate(values);\n     }\n \n     /**\n         final double[] values,\n         final int begin,\n         final int length) {\n-\t\treturn sumLog.evaluate(values, begin, length);\n+        return sumLog.evaluate(values, begin, length);\n     }\n \n     /**\n      * @return the mean of the values or Double.NaN if the array is empty\n      */\n     public static double mean(final double[] values) {\n-\t\treturn mean.evaluate(values);\n+        return mean.evaluate(values);\n     }\n \n     /**\n      * or 0.0 for a single value set.\n      */\n     public static double variance(final double[] values) {\n-\t\treturn variance.evaluate(values);\n+        return variance.evaluate(values);\n     }\n \n     /**\n      * @return the maximum of the values or Double.NaN if the array is empty\n      */\n     public static double max(final double[] values) {\n-\t\treturn max.evaluate(values);\n+        return max.evaluate(values);\n     }\n \n     /**\n      * @return the minimum of the values or Double.NaN if the array is empty\n      */\n     public static double min(final double[] values) {\n-\t\treturn min.evaluate(values);\n+        return min.evaluate(values);\n     }\n \n     /**\n         final int length) {\n         return min.evaluate(values, begin, length);\n     }\n+    \n+    /**\n+     * Returns an estimate for the pth percentile of the stored values. \n+     * This estimate follows the interpolation-adjusted defintion presented \n+     * <a href=\"http://www.utdallas.edu/~ammann/stat5311/node8.html\">here</a>\n+     * <p/>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>0 &lt; p &lt; 100</code> (otherwise an \n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li>at least one value must be stored (returns <code>Double.NaN\n+     *     </code> otherwise)</li>\n+     * </ul>\n+     * \n+     * @param values Is a double[] containing the values\n+     * @param p the requested percentile (scaled from 0 - 100)\n+     * @return An estimate for the pth percentile of the data values\n+     */\n+    public static double percentile(final double[] values, final double p) {\n+            return percentile.evaluate(values,p);\n+    }\n+\n+    /**\n+     * Returns an estimate for the pth percentile of the stored values. \n+     * This estimate follows the interpolation-adjusted defintion presented \n+     * <a href=\"http://www.utdallas.edu/~ammann/stat5311/node8.html\">here</a>\n+     * <p/>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>0 &lt; p &lt; 100</code> (otherwise an \n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li>at least one value must be stored (returns <code>Double.NaN\n+     *     </code> otherwise)</li>\n+     * </ul>\n+     * \n+     * @param values Is a double[] containing the values\n+     * @param begin processing at this point in the array\n+     * @param length processing at this point in the array\n+     * @param p the requested percentile (scaled from 0 - 100)\n+     * @return An estimate for the pth percentile of the data values\n+     */\n+    public static double percentile(\n+            final double[] values,\n+            final int begin,\n+            final int length, \n+            final double p) {\n+            return percentile.evaluate(values, begin, length, p);\n+    }\n+    \n \n }\n--- a/src/test/org/apache/commons/math/TestUtils.java\n+++ b/src/test/org/apache/commons/math/TestUtils.java\n \n package org.apache.commons.math;\n \n+import org.apache.commons.math.complex.Complex;\n+\n import junit.framework.Assert;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/11/14 22:22:23 $\n+ * @version $Revision: 1.7 $ $Date: 2003/11/15 18:52:31 $\n  */\n public class TestUtils {\n     /**\n             Assert.assertEquals(expected, actual, delta);\n         }\n     }\n+\n+    /**\n+     * \n+     */\n+    public static void assertEquals(Complex expected, Complex actual, double delta) {\n+        assertEquals(expected.getReal(), actual.getReal(), delta);\n+        assertEquals(expected.getImaginary(), actual.getImaginary(), delta);\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/complex/ComplexMathTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2003/11/15 18:52:31 $\n+ */\n+public class ComplexMathTest extends TestCase {\n+    \n+    public void testAcos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.936812, -2.30551);\n+        TestUtils.assertEquals(expected, ComplexMath.acos(z), 1.0e-5);\n+    }\n+    \n+    public void testAcosNaN() {\n+        assertTrue(ComplexMath.acos(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testAsin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(0.633984, 2.30551);\n+        TestUtils.assertEquals(expected, ComplexMath.asin(z), 1.0e-5);\n+    }\n+    \n+    public void testAsinNaN() {\n+        assertTrue(ComplexMath.asin(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testAtan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.44831, 0.158997);\n+        TestUtils.assertEquals(expected, ComplexMath.atan(z), 1.0e-5);\n+    }\n+    \n+    public void testAtanNaN() {\n+        assertTrue(ComplexMath.atan(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testCos() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-27.03495, -3.851153);\n+        TestUtils.assertEquals(expected, ComplexMath.cos(z), 1.0e-5);\n+    }\n+    \n+    public void testCosh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.58066, -7.58155);\n+        TestUtils.assertEquals(expected, ComplexMath.cosh(z), 1.0e-5);\n+    }\n+    \n+    public void testCoshNaN() {\n+        assertTrue(ComplexMath.cosh(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testCosNaN() {\n+        assertTrue(ComplexMath.cos(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testExp() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-13.12878, -15.20078);\n+        TestUtils.assertEquals(expected, ComplexMath.exp(z), 1.0e-5);\n+    }\n+    \n+    public void testExpNaN() {\n+        assertTrue(ComplexMath.exp(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testLog() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.60944, 0.927295);\n+        TestUtils.assertEquals(expected, ComplexMath.log(z), 1.0e-5);\n+    }\n+    \n+    public void testLogNaN() {\n+        assertTrue(ComplexMath.log(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testPow() {\n+        Complex x = new Complex(3, 4);\n+        Complex y = new Complex(5, 6);\n+        Complex expected = new Complex(-1.860893, 11.83677);\n+        TestUtils.assertEquals(expected, ComplexMath.pow(x, y), 1.0e-5);\n+    }\n+    \n+    public void testPowNaNBase() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(ComplexMath.pow(Complex.NaN, x).isNaN());\n+    }\n+    \n+    public void testPowNaNExponent() {\n+        Complex x = new Complex(3, 4);\n+        assertTrue(ComplexMath.pow(x, Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSin() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(3.853738, -27.01681);\n+        TestUtils.assertEquals(expected, ComplexMath.sin(z), 1.0e-5);\n+    }\n+    \n+    public void testSinh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-6.54812, -7.61923);\n+        TestUtils.assertEquals(expected, ComplexMath.sinh(z), 1.0e-5);\n+    }\n+    \n+    public void testSinhNaN() {\n+        assertTrue(ComplexMath.sinh(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSinNaN() {\n+        assertTrue(ComplexMath.sin(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSqrtRealPositive() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(2, 1);\n+        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealZero() {\n+        Complex z = new Complex(0.0, 4);\n+        Complex expected = new Complex(1.41421, 1.41421);\n+        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtRealNegative() {\n+        Complex z = new Complex(-3.0, 4);\n+        Complex expected = new Complex(1, 2);\n+        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryZero() {\n+        Complex z = new Complex(-3.0, 0.0);\n+        Complex expected = new Complex(0.0, 1.73205);\n+        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrtImaginaryNegative() {\n+        Complex z = new Complex(-3.0, -4.0);\n+        Complex expected = new Complex(1.0, -2.0);\n+        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);\n+    }\n+\n+    public void testSqrt1z() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(4.08033, -2.94094);\n+        TestUtils.assertEquals(expected, ComplexMath.sqrt1z(z), 1.0e-5);\n+    }\n+    \n+    public void testSqrt1zNaN() {\n+        assertTrue(ComplexMath.sqrt1z(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSqrtNaN() {\n+        assertTrue(ComplexMath.sqrt(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testTan() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(-0.000187346, 0.999356);\n+        TestUtils.assertEquals(expected, ComplexMath.tan(z), 1.0e-5);\n+    }\n+    \n+    public void testTanh() {\n+        Complex z = new Complex(3, 4);\n+        Complex expected = new Complex(1.00071, 0.00490826);\n+        TestUtils.assertEquals(expected, ComplexMath.tanh(z), 1.0e-5);\n+    }\n+    \n+    public void testTanhNaN() {\n+        assertTrue(ComplexMath.tanh(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testTanNaN() {\n+        assertTrue(ComplexMath.tan(Complex.NaN).isNaN());\n+    }\n+}\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.3 $ $Date: 2003/11/14 22:22:24 $\n+ * @version $Revision: 1.4 $ $Date: 2003/11/15 18:52:31 $\n  */\n public class ComplexTest extends TestCase {\n     \n         assertEquals(5.0, z.abs(), 1.0e-5);\n     }\n     \n+    public void testAbsNaN() {\n+        assertTrue(Double.isNaN(Complex.NaN.abs()));\n+    }\n+    \n     public void testAdd() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         Complex z = x.subtract(Complex.NaN);\n         assertTrue(z.isNaN());\n     }\n+    \n+    public void testEqualsNull() {\n+        Complex x = new Complex(3.0, 4.0);\n+        assertFalse(x.equals(null));\n+    }\n+    \n+    public void testEqualsClass() {\n+        Complex x = new Complex(3.0, 4.0);\n+        assertFalse(x.equals(this));\n+    }\n+    \n+    public void testEqualsSame() {\n+        Complex x = new Complex(3.0, 4.0);\n+        assertTrue(x.equals(x));\n+    }\n+    \n+    public void testEqualsTrue() {\n+        Complex x = new Complex(3.0, 4.0);\n+        Complex y = new Complex(3.0, 4.0);\n+        assertTrue(x.equals(y));\n+    }\n+    \n+    public void testEqualsRealDifference() {\n+        Complex x = new Complex(0.0, 0.0);\n+        Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);\n+        assertFalse(x.equals(y));\n+    }\n+    \n+    public void testEqualsImaginaryDifference() {\n+        Complex x = new Complex(0.0, 0.0);\n+        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n+        assertFalse(x.equals(y));\n+    }\n }\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n  */\n package org.apache.commons.math.util;\n \n+import org.apache.commons.math.TestUtils;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n /**\n  * Test cases for the MathUtils class.\n  *\n- * @version $Revision: 1.6 $ $Date: 2003/11/14 22:22:23 $\n+ * @version $Revision: 1.7 $ $Date: 2003/11/15 18:52:31 $\n  */\n \n public final class MathUtilsTest extends TestCase {\n         assertEquals( 1L, MathUtils.sign( 2L ) ) ;\n         assertEquals( -1L, MathUtils.sign( -2L ) ) ;\n     }\n+    \n+    public void testCosh() {\n+        double x = 3.0;\n+        double expected = 10.06766;\n+        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);\n+    }   \n+    \n+    public void testSinh() {\n+        double x = 3.0;\n+        double expected = 10.01787;\n+        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);\n+    }   \n+    \n+    public void testCoshNaN() {\n+        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));\n+    }   \n+    \n+    public void testSinhNaN() {\n+        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));\n+    }   \n }", "timestamp": 1068922351, "metainfo": ""}