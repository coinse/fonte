{"sha": "3e237d53870388445f5a1b664f6d1f98d8d61738", "log": "Added test class for PolynomialSplineFunction.   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/PolynomialSplineFunctionTest.java\n+/*\n+ * \n+ * Copyright (c) 2004 The Apache Software Foundation. All rights reserved.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy\n+ * of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *  \n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.util.Arrays;\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Tests the PolynomialSplineFunction implementation.\n+ *\n+ * @version $Revision: 1.1 $\n+ */\n+public class PolynomialSplineFunctionTest extends TestCase {\n+\n+    /** Error tolerance for tests */\n+    protected double tolerance = 1.0e-12;\n+    \n+    /** \n+     * Quadratic polynomials used in tests: \n+     * \n+     * x^2 + x            [-1, 0)\n+     * x^2 + x + 2        [0, 1)\n+     * x^2 + x + 4        [1, 2)\n+     * \n+     * Defined so that evaluation using PolynomialSplineFunction evaluation\n+     * algorithm agrees at knot point boundaries.\n+     */\n+    protected PolynomialFunction[] polynomials = {\n+        new PolynomialFunction(new double[] {0d, 1d, 1d}), \n+        new PolynomialFunction(new double[] {2d, 1d, 1d}),\n+        new PolynomialFunction(new double[] {4d, 1d, 1d})\n+    };\n+    \n+    /** Knot points  */\n+    protected double[] knots = {-1, 0, 1, 2};\n+    \n+    /** Derivative of test polynomials -- 2x + 1  */\n+    protected PolynomialFunction dp = \n+        new PolynomialFunction(new double[] {1d, 2d});\n+    \n+    \n+    public void testConstructor() {\n+        PolynomialSplineFunction spline = \n+            new PolynomialSplineFunction(knots, polynomials);\n+        assertTrue(Arrays.equals(knots, spline.getKnots()));\n+        assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);\n+        \n+        try { // too few knots\n+            spline = \n+                new PolynomialSplineFunction(new double[] {0}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try { // too many knots\n+            spline = \n+                new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try { // knots not increasing\n+            spline = \n+                new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testValues() throws Exception {\n+        PolynomialSplineFunction spline = \n+            new PolynomialSplineFunction(knots, polynomials);\n+        UnivariateRealFunction dSpline = spline.derivative();\n+        \n+        /**\n+         * interior points -- spline value at x should equal p(x - knot)\n+         * where knot is the largest knot point less than or equal to x and p \n+         * is the polynomial defined over the knot segment to which x belongs.\n+         */\n+        double x = -1;\n+        int index = 0;\n+        for (int i = 0; i < 10; i++) {\n+           x+=0.25;\n+           index = findKnot(knots, x);\n+           assertEquals(\"spline function evaluation failed for x=\" + x, \n+                   polynomials[index].value(x - knots[index]), spline.value(x), tolerance);\n+           assertEquals(\"spline derivative evaluation failed for x=\" + x,\n+                   dp.value(x - knots[index]), dSpline.value(x), tolerance);\n+        }\n+        \n+        // knot points -- centering should zero arguments\n+        for (int i = 0; i < 3; i++) {\n+            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+                    polynomials[i].value(0), spline.value(knots[i]), tolerance);\n+            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+                    dp.value(0), dSpline.value(knots[i]), tolerance);\n+        }\n+        \n+        try { //outside of domain -- under min\n+            x = spline.value(-1.5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (FunctionEvaluationException ex) {\n+            // expected\n+        }\n+        \n+        try { //outside of domain -- over max\n+            x = spline.value(2.5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (FunctionEvaluationException ex) {\n+            // expected\n+        }         \n+    }  \n+    \n+    /**\n+     *  Do linear search to find largest knot point less than or equal to x.\n+     *  Implementation does binary search.\n+     */\n+     protected int findKnot(double[] knots, double x) {\n+         if (x < knots[0] || x >= knots[knots.length -1]) {\n+             throw new IllegalArgumentException(\"x is out of range\");\n+         }\n+         for (int i = 0; i < knots.length; i++) {\n+             if (knots[i] > x) {\n+                 return i -1;\n+             }\n+         }\n+         throw new IllegalArgumentException(\"x is out of range\");\n+     }\n+}\n+    ", "timestamp": 1090328242, "metainfo": ""}