{"sha": "dde7ece858a1686878c1b2cd8f438d5a0ebebf87", "log": "fixed checkstyle warnings (no functional changes)  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MathException.java\n+++ b/src/main/java/org/apache/commons/math/MathException.java\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 7428019509644517071L;\n+\n+    /** Deprecation message. */\n+    private static final String DEPRECATION_MESSAGE = \"This class is deprecated; calling this method is a bug.\";\n \n     /**\n      * Pattern used to build the message.\n     /** {@inheritDoc} */\n     public void addMessage(Localizable pat,\n                            Object ... args) {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /** {@inheritDoc} */\n     public void setContext(String key, Object value) {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /** {@inheritDoc} */\n     public Object getContext(String key) {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /** {@inheritDoc} */\n     public Set<String> getContextKeys() {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /** Gets the message in a specified locale.\n--- a/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 9058794795027570002L;\n \n+    /** Deprecation message. */\n+    private static final String DEPRECATION_MESSAGE = \"This class is deprecated; calling this method is a bug.\";\n+\n     /**\n      * Pattern used to build the message.\n      */\n     /** {@inheritDoc} */\n     public void addMessage(Localizable pat,\n                            Object ... args) {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /** {@inheritDoc} */\n     public void setContext(String key, Object value) {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /** {@inheritDoc} */\n     public Object getContext(String key) {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /** {@inheritDoc} */\n     public Set<String> getContextKeys() {\n-        throw new UnsupportedOperationException(\"This class is deprecated; calling this method is a bug.\");\n+        throw new UnsupportedOperationException(DEPRECATION_MESSAGE);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n      *\n      * @param count maximum number of iterations\n      */\n-    public void setMaximalIterationCount(int count);\n+    void setMaximalIterationCount(int count);\n \n     /**\n      * Get the upper limit for the number of iterations.\n      *\n      * @return the actual upper limit\n      */\n-    public int getMaximalIterationCount();\n+    int getMaximalIterationCount();\n \n     /**\n      * Set the absolute accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n      * the solver or is otherwise deemed unreasonable.\n      */\n-    public void setAbsoluteAccuracy(double accuracy);\n+    void setAbsoluteAccuracy(double accuracy);\n \n     /**\n      * Get the actual absolute accuracy.\n      *\n      * @return the accuracy\n      */\n-    public double getAbsoluteAccuracy();\n+    double getAbsoluteAccuracy();\n \n     /**\n      * Set the relative accuracy.\n      *\n      * @param accuracy the relative accuracy.\n      */\n-    public void setRelativeAccuracy(double accuracy);\n+    void setRelativeAccuracy(double accuracy);\n \n     /**\n      * Get the actual relative accuracy.\n      * @return the accuracy\n      */\n-    public double getRelativeAccuracy();\n+    double getRelativeAccuracy();\n \n     /**\n      * Set the lower limit for the number of iterations.\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n      * Convenience function for implementations.\n      *\n      * @param newResult the result to set\n-     * @param iterationCount the iteration count to set\n+     * @param newCount the iteration count to set\n      */\n-    protected final void setResult(final double newResult, final int iterationCount) {\n+    protected final void setResult(final double newResult, final int newCount) {\n         this.result         = newResult;\n-        this.iterationCount = iterationCount;\n+        this.iterationCount = newCount;\n         this.resultComputed = true;\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n public abstract class AbstractContinuousDistribution\n     extends AbstractDistribution\n     implements ContinuousDistribution, Serializable {\n+\n+    /** Default accuracy. */\n+    public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n-    /** Default accuracy. */\n-    public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n     /**\n      * RandomData instance used to generate samples from the distribution\n      * @since 2.2\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n package org.apache.commons.math.distribution;\n \n /**\n- * Treats the distribution of the two-sided \n+ * Treats the distribution of the two-sided\n  * {@code P(D}<sub>{@code n}</sub>{@code < d)}\n- * where {@code D}<sub>{@code n}</sub>{@code = sup_x | G(x) - Gn (x) |} for the \n+ * where {@code D}<sub>{@code n}</sub>{@code = sup_x | G(x) - Gn (x) |} for the\n  * theoretical cdf G and the emperical cdf Gn.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface KolmogorovSmirnovDistribution {\n-    \n+\n     /**\n      * Calculates {@code P(D}<sub>n</sub> {@code < d)}.\n-     * \n+     *\n      * @param d statistic\n      * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n      */\n-    public double cdf(double d);\n-    \n+    double cdf(double d);\n+\n }\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n \n /**\n  * The default implementation of {@link KolmogorovSmirnovDistribution}.\n- * \n- * <p>Treats the distribution of the two-sided \n+ *\n+ * <p>Treats the distribution of the two-sided\n  * {@code P(D}<sub>{@code n}</sub>{@code < d)}\n- * where {@code D}<sub>{@code n}</sub>{@code = sup_x | G(x) - Gn (x) |} for the \n+ * where {@code D}<sub>{@code n}</sub>{@code = sup_x | G(x) - Gn (x) |} for the\n  * theoretical cdf G and the emperical cdf Gn.</p>\n- * \n- * <p>This implementation is based on [1] with certain quick \n+ *\n+ * <p>This implementation is based on [1] with certain quick\n  * decisions for extreme values given in [2].</p>\n- * \n- * <p>In short, when wanting to evaluate {@code P(D}<sub>{@code n}</sub>{@code < d)}, \n- * the method in [1] is to write {@code d = (k - h) / n} for positive \n- * integer {@code k} and {@code 0 <= h < 1}. Then \n+ *\n+ * <p>In short, when wanting to evaluate {@code P(D}<sub>{@code n}</sub>{@code < d)},\n+ * the method in [1] is to write {@code d = (k - h) / n} for positive\n+ * integer {@code k} and {@code 0 <= h < 1}. Then\n  * {@code P(D}<sub>{@code n}</sub>{@code < d) = (n!/n}<sup>{@code n}</sup>{@code ) * t_kk}\n- * where {@code t_kk} is the {@code (k, k)}'th entry in the special \n- * matrix {@code H}<sup>{@code n}</sup>, i.e. {@code H} to the {@code n}'th power.</p> \n- * \n+ * where {@code t_kk} is the {@code (k, k)}'th entry in the special\n+ * matrix {@code H}<sup>{@code n}</sup>, i.e. {@code H} to the {@code n}'th power.</p>\n+ *\n  * <p>See also <a href=\"http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test\">\n  * Kolmogorov-Smirnov test on Wikipedia</a> for details.</p>\n- * \n- * <p>References: \n+ *\n+ * <p>References:\n  * <ul>\n  * <li>[1] <a href=\"http://www.jstatsoft.org/v08/i18/\">\n  * Evaluating Kolmogorov's Distribution</a> by George Marsaglia, Wai\n  * Computing the Two-Sided Kolmogorov-Smirnov Distribution</a> by Richard Simard\n  * and Pierre L'Ecuyer</li>\n  * </ul>\n- * Note that [1] contains an error in computing h, refer to \n+ * Note that [1] contains an error in computing h, refer to\n  * <a href=\"https://issues.apache.org/jira/browse/MATH-437\">MATH-437</a> for details.\n  * </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class KolmogorovSmirnovDistributionImpl implements KolmogorovSmirnovDistribution, Serializable {\n-    \n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -4670676796862967187L;\n \n+    /** Number of observations. */\n     private int n;\n-    \n+\n     /**\n      * @param n Number of observations\n      * @throws NotStrictlyPositiveException\n         if (n <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES, n);\n         }\n-        \n+\n         this.n = n;\n     }\n \n     /**\n      * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n      * [1] with quick decisions for extreme values given in [2] (see above). The\n-     * result is not exact as with \n+     * result is not exact as with\n      * {@link KolmogorovSmirnovDistributionImpl#cdfExact(double)} because\n-     * calculations are based on double rather than \n+     * calculations are based on double rather than\n      * {@link org.apache.commons.math.fraction.BigFraction}.\n-     * \n-     * @param d statistic\n-     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert {@code h} to a \n-     *             {@link org.apache.commons.math.fraction.BigFraction} in\n-     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a\n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer\n      *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     public double cdf(double d) throws MathArithmeticException {\n \n     /**\n      * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n-     * [1] with quick decisions for extreme values given in [2] (see above). \n-     * The result is exact in the sense that BigFraction/BigReal is used everywhere \n-     * at the expense of very slow execution time. Almost never choose this in \n+     * [1] with quick decisions for extreme values given in [2] (see above).\n+     * The result is exact in the sense that BigFraction/BigReal is used everywhere\n+     * at the expense of very slow execution time. Almost never choose this in\n      * real applications unless you are very sure; this is almost solely for\n-     * verification purposes. Normally, you would choose \n+     * verification purposes. Normally, you would choose\n      * {@link KolmogorovSmirnovDistributionImpl#cdf(double)}\n-     * \n-     * @param d statistic\n-     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert {@code h} to a \n-     *             {@link org.apache.commons.math.fraction.BigFraction} in\n-     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a\n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer\n      *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     public double cdfExact(double d) throws MathArithmeticException {\n     /**\n      * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n      * [1] with quick decisions for extreme values given in [2] (see above).\n-     * \n+     *\n      * @param d statistic\n      * @param exact\n      *            whether the probability should be calculated exact using\n      *            BigFraction everywhere at the expense of very\n      *            slow execution time, or if double should be used convenient\n-     *            places to gain speed. Almost never choose {@code true} in \n-     *            real applications unless you are very sure; {@code true} is \n+     *            places to gain speed. Almost never choose {@code true} in\n+     *            real applications unless you are very sure; {@code true} is\n      *            almost solely for verification purposes.\n      * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n      * @throws MathArithmeticException\n-     *             if algorithm fails to convert {@code h} to a \n-     *             {@link org.apache.commons.math.fraction.BigFraction} in\n-     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *             if algorithm fails to convert {@code h} to a\n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer\n      *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     public double cdf(double d, boolean exact)\n             throws MathArithmeticException {\n-        \n-        final int n = this.n;\n \n         final double ninv = 1 / ((double) n);\n         final double ninvhalf = 0.5 * ninv;\n             return 1;\n         }\n \n-        return (exact) ? this.exactK(d) : this.roundedK(d);\n+        return exact ? exactK(d) : roundedK(d);\n     }\n \n     /**\n      * Calculates {@code P(D}<sub>n</sub> {@code < d)} exact using method\n      * described in [1] and BigFraction (see above).\n-     * \n-     * @param d statistic\n-     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert {@code h} to a \n-     *             {@link org.apache.commons.math.fraction.BigFraction} in\n-     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a\n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer\n      *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     private double exactK(double d)\n             throws MathArithmeticException {\n \n-        final int n = this.n;\n         final int k = (int) Math.ceil(n * d);\n \n         final FieldMatrix<BigFraction> H = this.createH(d);\n          * denominator to double and divides afterwards. That gives NaN quite\n          * easy. This does not (scale is the number of digits):\n          */\n-        return pFrac.bigDecimalValue(20, BigDecimal.ROUND_HALF_UP)\n-                .doubleValue();\n+        return pFrac.bigDecimalValue(20, BigDecimal.ROUND_HALF_UP).doubleValue();\n     }\n \n     /**\n      * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n      * [1] and doubles (see above).\n-     * \n-     * @param d statistic\n-     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert {@code h} to a \n-     *             {@link org.apache.commons.math.fraction.BigFraction} in\n-     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *\n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a\n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer\n      *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     private double roundedK(double d)\n             throws MathArithmeticException {\n-        \n-        final int n = this.n;\n+\n         final int k = (int) Math.ceil(n * d);\n         final FieldMatrix<BigFraction> HBigFraction = this.createH(d);\n         final int m = HBigFraction.getRowDimension();\n \n     /***\n      * Creates {@code H} of size {@code m x m} as described in [1] (see above).\n-     * \n-     * @param d statistic\n-     *            \n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert {@code h} to a \n-     *             {@link org.apache.commons.math.fraction.BigFraction} in\n-     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *\n+     * @param d statistic\n+     * @return H matrix\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a\n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer\n      *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     private FieldMatrix<BigFraction> createH(double d)\n             throws MathArithmeticException {\n \n-        int n = this.n;\n         int k = (int) Math.ceil(n * d);\n-        \n+\n         int m = 2 * k - 1;\n         double hDouble = k - n * d;\n \n         if (hDouble >= 1) {\n             throw new ArithmeticException(\"Could not \");\n         }\n-        \n+\n         BigFraction h = null;\n \n         try {\n          * 1/2 is sufficient to check:\n          */\n         if (h.compareTo(BigFraction.ONE_HALF) == 1) {\n-            Hdata[m - 1][0] = Hdata[m - 1][0].add(h.multiply(2).subtract(1)\n-                    .pow(m));\n+            Hdata[m - 1][0] = Hdata[m - 1][0].add(h.multiply(2).subtract(1).pow(m));\n         }\n \n         /*\n          * put, so only division with (i - j + 1)! is needed in the elements\n          * that have 1's. There is no need to calculate (i - j + 1)! and then\n          * divide - small steps avoid overflows.\n-         * \n+         *\n          * Note that i - j + 1 > 0 <=> i + 1 > j instead of j'ing all the way to\n          * m. Also note that it is started at g = 2 because dividing by 1 isn't\n          * really necessary.\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n     public FieldMatrix<T> preMultiply(final FieldMatrix<T> m) {\n         return m.multiply(this);\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public FieldMatrix<T> power(final int p) {\n         if (p < 0) {\n             throw new IllegalArgumentException(\"p must be >= 0\");\n         }\n-        \n+\n         if (!isSquare()) {\n             throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n-        \n+\n         if (p == 0) {\n             return MatrixUtils.createFieldIdentityMatrix(this.getField(), this.getRowDimension());\n         }\n-        \n+\n         if (p == 1) {\n             return this.copy();\n         }\n         /*\n          * Only log_2(p) operations is used by doing as follows:\n          * 5^214 = 5^128 * 5^64 * 5^16 * 5^4 * 5^2\n-         * \n+         *\n          * In general, the same approach is used for A^p.\n          */\n \n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     /** {@inheritDoc} */\n     public RealMatrix preMultiply(final RealMatrix m) {\n         return m.multiply(this);\n-    }    \n+    }\n \n     /** {@inheritDoc} */\n     public RealMatrix power(final int p) {\n         if (p < 0) {\n             throw new IllegalArgumentException(\"p must be >= 0\");\n         }\n-        \n+\n         if (!isSquare()) {\n             throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n-        \n+\n         if (p == 0) {\n             return MatrixUtils.createRealIdentityMatrix(this.getRowDimension());\n         }\n-        \n+\n         if (p == 1) {\n             return this.copy();\n         }\n \n         final int power = p - 1;\n-        \n+\n         /*\n          * Only log_2(p) operations is used by doing as follows:\n          * 5^214 = 5^128 * 5^64 * 5^16 * 5^4 * 5^2\n-         * \n+         *\n          * In general, the same approach is used for A^p.\n-         */        \n-        \n-        final char[] binaryRepresentation = Integer.toBinaryString(power).toCharArray();       \n+         */\n+\n+        final char[] binaryRepresentation = Integer.toBinaryString(power).toCharArray();\n         final ArrayList<Integer> nonZeroPositions = new ArrayList<Integer>();\n         int maxI = -1;\n-        \n-        for (int i = 0; i < binaryRepresentation.length; ++i) {            \n+\n+        for (int i = 0; i < binaryRepresentation.length; ++i) {\n             if (binaryRepresentation[i] == '1') {\n                 final int pos = binaryRepresentation.length - i - 1;\n                 nonZeroPositions.add(pos);\n-                \n+\n                 // The positions are taken in turn, so maxI is only changed once\n                 if (maxI == -1) {\n                     maxI = pos;\n                 }\n             }\n         }\n-        \n+\n         RealMatrix[] results = new RealMatrix[maxI + 1];\n         results[0] = this.copy();\n-        \n+\n         for (int i = 1; i <= maxI; ++i) {\n             results[i] = results[i-1].multiply(results[i-1]);\n         }\n-        \n+\n         RealMatrix result = this.copy();\n-        \n+\n         for (Integer i : nonZeroPositions) {\n             result = result.multiply(results[i]);\n-        }        \n-        \n+        }\n+\n         return result;\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n     FieldMatrix<T> preMultiply(FieldMatrix<T> m);\n \n     /**\n-     * Returns the result multiplying this with itself <code>p</code> times. \n-     * Depending on the type of the field elements, T, \n-     * instability for high powers might occur. \n+     * Returns the result multiplying this with itself <code>p</code> times.\n+     * Depending on the type of the field elements, T,\n+     * instability for high powers might occur.\n      * @param      p raise this to power p\n      * @return     this^p\n      * @throws     IllegalArgumentException if p < 0\n      *             NonSquareMatrixException if the matrix is not square\n      */\n     FieldMatrix<T> power(final int p);\n-    \n+\n     /**\n      * Returns matrix entries as a two-dimensional array.\n      *\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n      *             if rowDimension(this) != columnDimension(m)\n      */\n     RealMatrix preMultiply(RealMatrix m);\n-    \n-    /**\n-     * Returns the result multiplying this with itself <code>p</code> times. \n-     * Depending on the underlying storage, instability for high powers might occur. \n+\n+    /**\n+     * Returns the result multiplying this with itself <code>p</code> times.\n+     * Depending on the underlying storage, instability for high powers might occur.\n      * @param      p raise this to power p\n      * @return     this^p\n      * @throws     IllegalArgumentException if p < 0\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n     private class FitnessFunction {\n \n         /** Determines the penalty for boundary violations */\n-        private double valueRange = 1.0;\n+        private double valueRange;\n         /**\n          * Flag indicating whether the objective variables are forced into their\n          * bounds if defined\n          */\n-        private boolean isRepairMode = true;\n+        private boolean isRepairMode;\n+\n+        /** Simple constructor.\n+         */\n+        public FitnessFunction() {\n+            valueRange = 1.0;\n+            isRepairMode = true;\n+        }\n \n         /**\n          * @param x\n          *            Original objective variables.\n          * @return Normalized objective variables.\n          */\n-        private double[] encode(final double[] x) {\n+        public double[] encode(final double[] x) {\n             if (boundaries == null)\n                 return x;\n             double[] res = new double[x.length];\n          *            Normalized objective variables.\n          * @return Original objective variables.\n          */\n-        private double[] decode(final double[] x) {\n+        public double[] decode(final double[] x) {\n             if (boundaries == null)\n                 return x;\n             double[] res = new double[x.length];\n          *            Normalized objective variables.\n          * @return Objective value + penalty for violated bounds.\n          */\n-        private double value(final double[] point) {\n+        public double value(final double[] point) {\n             double value;\n             if (boundaries != null && isRepairMode) {\n                 double[] repaired = repair(point);\n          *            Normalized objective variables.\n          * @return True if in bounds\n          */\n-        private boolean isFeasible(final double[] x) {\n+        public boolean isFeasible(final double[] x) {\n             if (boundaries == null)\n                 return true;\n             for (int i = 0; i < x.length; i++) {\n          * @param valueRange\n          *            Adjusts the penalty computation.\n          */\n-        private void setValueRange(double valueRange) {\n+        public void setValueRange(double valueRange) {\n             this.valueRange = valueRange;\n         }\n \n--- a/src/main/java/org/apache/commons/math/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math/special/Beta.java\n      * @return the regularized beta function I(x, a, b).\n      * @throws org.apache.commons.math.exception.MaxCountExceededException\n      * if the algorithm fails to converge.\n-     * @throws MathException if the algorithm fails to converge.\n      */\n     public static double regularizedBeta(double x, double a, double b) {\n         return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n--- a/src/main/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n      * @param a the a parameter.\n      * @param x the value.\n      * @return the regularized gamma function Q(a, x)\n-     * @throws MathException if the algorithm fails to converge.\n+     * @throws MaxCountExceededException if the algorithm fails to converge.\n      */\n     public static double regularizedGammaQ(double a, double x) {\n         return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n \n         // sanity checks\n         MathUtils.checkNotNull(points);\n-        \n+\n         // number of clusters has to be smaller or equal the number of data points\n         if (points.size() < k) {\n             throw new NumberIsTooSmallException(points.size(), k, false);\n         }\n-        \n+\n         // create the initial clusters\n         List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\n         assignPointsToClusters(clusters, points);\n--- a/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTestImpl.java\n  * @version $Revision$ $Date$\n  */\n public class MannWhitneyUTestImpl implements MannWhitneyUTest {\n+\n+    /** Ranking algorithm. */\n     private NaturalRanking naturalRanking;\n \n     /**\n     /**\n      * Ensures that the provided arrays fulfills the assumptions.\n      *\n-     * @param x\n-     * @param y\n+     * @param x first sample\n+     * @param y second sample\n      * @throws IllegalArgumentException\n      *             if assumptions are not met\n      */\n         }\n     }\n \n-    private double[] concatinateSamples(final double[] x, final double[] y) {\n+    /** Concatenate the samples into one array.\n+     * @param x first sample\n+     * @param y second sample\n+     * @return concatenated array\n+     */\n+    private double[] concatenateSamples(final double[] x, final double[] y) {\n         final double[] z = new double[x.length + y.length];\n \n         System.arraycopy(x, 0, z, 0, x.length);\n \n         ensureDataConformance(x, y);\n \n-        final double[] z = concatinateSamples(x, y);\n+        final double[] z = concatenateSamples(x, y);\n         final double[] ranks = naturalRanking.rank(z);\n \n         double sumRankX = 0;\n--- a/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestImpl.java\n  * @version $Revision$ $Date$\n  */\n public class WilcoxonSignedRankTestImpl implements WilcoxonSignedRankTest {\n+\n+    /** Ranking algorithm. */\n     private NaturalRanking naturalRanking;\n \n     /**\n     /**\n      * Ensures that the provided arrays fulfills the assumptions.\n      *\n-     * @param x\n-     * @param y\n+     * @param x first sample\n+     * @param y second sample\n      * @throws IllegalArgumentException\n      *             if assumptions are not met\n      */\n     /**\n      * Calculates y[i] - x[i] for all i\n      *\n-     * @param x\n-     * @param y\n-     * @throws IllegalArgumentException\n-     *             if assumptions are not met\n-     */\n-    private double[] calculateDifferences(final double[] x, final double[] y)\n-            throws IllegalArgumentException {\n+     * @param x first sample\n+     * @param y second sample\n+     * @return z = y - x\n+     */\n+    private double[] calculateDifferences(final double[] x, final double[] y) {\n \n         final double[] z = new double[x.length];\n \n     /**\n      * Calculates |z[i]| for all i\n      *\n-     * @param z\n+     * @param z sample\n+     * @return |z|\n      * @throws IllegalArgumentException\n      *             if assumptions are not met\n      */", "timestamp": 1301243521, "metainfo": ""}