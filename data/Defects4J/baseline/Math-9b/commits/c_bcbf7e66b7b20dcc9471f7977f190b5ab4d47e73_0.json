{"sha": "bcbf7e66b7b20dcc9471f7977f190b5ab4d47e73", "log": "This is the second half of this pr. Commit of analysis solver tests. PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20844 Submitted by:\tJ. Pietschman   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/QuinticFunction.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Auxillary class for testing solvers.\n+ * \n+ * @author pietsch at apache.org\n+ *\n+ */\n+public class QuinticFunction implements UnivariateRealFunction {\n+\n+    /* Evaluate quintic.\n+     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     */\n+    public double value(double x) throws MathException {\n+        return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);\n+    }\n+\n+    /* First derivative of quintic.\n+     * @see org.apache.commons.math.UnivariateRealFunction#firstDerivative(double)\n+     */\n+    public double firstDerivative(double x) throws MathException {\n+        return (5*x*x-3.75)*x*x+0.25;\n+    }\n+\n+    /* Second order derivative of quintic.\n+     * Unsupported.\n+     * @see org.apache.commons.math.UnivariateRealFunction#secondDerivative(double)\n+     */\n+    public double secondDerivative(double x) throws MathException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/RealSolverTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Testcase for UnivariateRealSolver.\n+ * Because Brent-Dekker is guaranteed to converge in less than the default\n+ * maximum iteration count due to bisection fallback, it is quite hard to\n+ * debug. I include measured iteration counts plus one in order to detect\n+ * regressions. On average Brent-Dekker should use 4..5 iterations for the\n+ * default absolute accuracy of 10E-8 for sinus and the quintic function around\n+ * zero, and 5..10 iterations for the other zeros.\n+ * \n+ * @author pietsch at apache.org\n+ *\n+ */\n+public final class RealSolverTest extends TestCase {\n+\n+    public RealSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RealSolverTest.class);\n+        suite.setName(\"UnivariateRealSolver Tests\");\n+        return suite;\n+    }\n+\n+    public void testSinZero() throws MathException {\n+        // The sinus function is behaved well around the root at #pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically. \n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        // Somewhat benign interval. The function is monotonous.\n+        result = solver.solve(3, 4);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        // Larger and somewhat less benign interval. The function is grows first.\n+        result = solver.solve(1, 4);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        solver = new SecantSolver(f);\n+        result = solver.solve(3, 4);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        result = solver.solve(1, 4);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+    }\n+\n+    public void testQuinticZero() throws MathException {\n+        // The quintic function has zeroes at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second derivative\n+        // of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1, because\n+        // the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        // intervals containing these values are harder for the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        // Brent-Dekker solver.\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        // Symmetric bracket around 0. Test whether solvers can handle hitting\n+        // the root in the first iteration.\n+        result = solver.solve(-0.2, 0.2);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertTrue(solver.getIterationCount() <= 2);\n+        // 1 iterations on i586 JDK 1.4.1.\n+        // Asymmetric bracket around 0, just for fun. Contains extremum.\n+        result = solver.solve(-0.1, 0.3);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        // Large bracket around 0. Contains two extrema.\n+        result = solver.solve(-0.3, 0.45);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Benign bracket around 0.5, function is monotonous.\n+        result = solver.solve(0.3, 0.7);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Less benign bracket around 0.5, contains one extremum.\n+        result = solver.solve(0.2, 0.6);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Large, less benign bracket around 0.5, contains both extrema.\n+        result = solver.solve(0.05, 0.95);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1\n+        // is still a problem.\n+        result = solver.solve(0.85, 1.25);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Less benign bracket around 1 with extremum.\n+        result = solver.solve(0.8, 1.2);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Large bracket around 1. Monotonous.\n+        result = solver.solve(0.85, 1.75);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        // Large bracket around 1. Interval contains extremum.\n+        result = solver.solve(0.55, 1.45);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        // Very large bracket around 1 for testing fast growth behaviour.\n+        result = solver.solve(0.85, 5);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 12 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 13);\n+        // Secant solver.\n+        solver = new SecantSolver(f);\n+        result = solver.solve(-0.2, 0.2);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 1 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 2);\n+        result = solver.solve(-0.1, 0.3);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        result = solver.solve(-0.3, 0.45);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(0.3, 0.7);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(0.2, 0.6);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(0.05, 0.95);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(0.85, 1.25);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        result = solver.solve(0.8, 1.2);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(0.85, 1.75);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // The followig is especially slow because the solver first has to reduce\n+        // the bracket to exclude the extremum. After that, convergence is rapide.\n+        result = solver.solve(0.55, 1.45);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(0.85, 5);\n+        System.out.println(\n+            \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // Static solve method\n+        result = UnivariateRealSolverFactory.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        result = UnivariateRealSolverFactory.solve(f, -0.1, 0.3);\n+        Assert.assertEquals(result, 0, 1E-8);\n+        result = UnivariateRealSolverFactory.solve(f, -0.3, 0.45);\n+        Assert.assertEquals(result, 0, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.3, 0.7);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.2, 0.6);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.05, 0.95);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.85, 1.25);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.8, 1.2);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.85, 1.75);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.55, 1.45);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverFactory.solve(f, 0.85, 5);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/SinFunction.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Auxillary class for testing solvers.\n+ *\n+ * The function is extraordinarily well behaved around zero roots: it\n+ * has an inflection point there (second order derivative is zero),\n+ * which means linear approximation (Regula Falsi) will converge\n+ * quadratically.\n+ * \n+ * @author pietsch at apache.org\n+ *\n+ */\n+public class SinFunction implements UnivariateRealFunction {\n+\n+    /* Evaluate sinus fuction.\n+     * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n+     */\n+    public double value(double x) throws MathException {\n+        return Math.sin(x);\n+    }\n+\n+    /* First derivative of sinus function\n+     * @see org.apache.commons.math.UnivariateRealFunction#firstDerivative(double)\n+     */\n+    public double firstDerivative(double x) throws MathException {\n+        return Math.cos(x);\n+    }\n+\n+    /* Second derivative of sinus function.\n+     * Unsupported.\n+     * @see org.apache.commons.math.UnivariateRealFunction#secondDerivative(double)\n+     */\n+    public double secondDerivative(double x) throws MathException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}", "timestamp": 1056423748, "metainfo": ""}