{"sha": "b0d18a4cc0be57b3bf37735848b2742cb2594c22", "log": "Javadoc fixes.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/AVLTree.java\n package org.apache.commons.math3.geometry.partitioning.utilities;\n \n /** This class implements AVL trees.\n-\n+ *\n  * <p>The purpose of this class is to sort elements while allowing\n  * duplicate elements (i.e. such that {@code a.equals(b)} is\n  * true). The {@code SortedSet} interface does not allow this, so\n  * a specific class is needed. Null elements are not allowed.</p>\n-\n+ *\n  * <p>Since the {@code equals} method is not sufficient to\n  * differentiate elements, the {@link #delete delete} method is\n  * implemented using the equality operator.</p>\n-\n+ *\n  * <p>In order to clearly mark the methods provided here do not have\n  * the same semantics as the ones specified in the\n  * {@code SortedSet} interface, different names are used\n  * ({@code add} has been replaced by {@link #insert insert} and\n  * {@code remove} has been replaced by {@link #delete\n  * delete}).</p>\n-\n+ *\n  * <p>This class is based on the C implementation Georg Kraml has put\n  * in the public domain. Unfortunately, his <a\n  * href=\"www.purists.org/georg/avltree/index.html\">page</a> seems not\n  * to exist any more.</p>\n-\n+ *\n  * @param <T> the type of the elements\n-\n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n--- a/src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple.java\n import org.apache.commons.math3.util.FastMath;\n \n /** This class implements an ordering operation for T-uples.\n-\n+ *\n  * <p>Ordering is done by encoding all components of the T-uple into a\n  * single scalar value and using this value as the sorting\n  * key. Encoding is performed using the method invented by Georg\n  * 2<sup>p</sup> offset is added to the components in order to avoid\n  * negative numbers (this offset is adjusted as needed during the\n  * comparison operations).</p>\n-\n+ *\n  * <p>The more interesting property of the encoding method for our\n  * purpose is that it allows to select all the points that are in a\n  * given range. This is depicted in dimension 2 by the following\n- * picure:</p>\n-\n+ * picture:</p>\n+ *\n  * <img src=\"doc-files/OrderedTuple.png\" />\n-\n+ *\n  * <p>This picture shows a set of 100000 random 2-D pairs having their\n  * first component between -50 and +150 and their second component\n  * between -350 and +50. We wanted to extract all pairs having their\n  * the points having their first component between +30 and +31 and\n  * their second component between -91 and -90, we get a subset of 11\n  * points, 2 of which really belonging to the desired rectangle.</p>\n-\n+ *\n  * <p>the previous selection technique can be applied in all\n  * dimensions, still using two points to define the interval. The\n  * first point will have all its components set to their lower bounds\n  * while the second point will have all its components set to their\n  * upper bounds.</p>\n-\n+ *\n  * <p>T-uples with negative infinite or positive infinite components\n  * are sorted logically.</p>\n-\n+ *\n  * <p>Since the specification of the {@code Comparator} interface\n  * allows only {@code ClassCastException} errors, some arbitrary\n  * choices have been made to handle specific cases. The rationale for\n  * are considered as if they had {@code Double.NaN}\n  * components</li>\n  * </ul>\n-\n+ *\n  * @version $Id$\n  * @since 3.0\n  */", "timestamp": 1348581417, "metainfo": ""}