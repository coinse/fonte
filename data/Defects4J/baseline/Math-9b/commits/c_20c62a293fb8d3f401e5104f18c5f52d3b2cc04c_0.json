{"sha": "20c62a293fb8d3f401e5104f18c5f52d3b2cc04c", "log": "added multivariate summary statistics  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>Computes summary statistics for a stream of data values added using the \n+ * {@link #addValue(double[]) addValue} method. The data values are not stored in\n+ * memory, so this class can be used to compute statistics for very large\n+ * data streams.</p>\n+ * \n+ * <p>The {@link StorelessUnivariateStatistic} array instances used to maintain\n+ * summary state and compute statistics are configurable via setters.\n+ * For example, the default implementation for the mean can be overridden by\n+ * calling {@link #setMeanImpl(StorelessUnivariateStatistic[])}. Actual\n+ * parameters to these methods must implement the \n+ * {@link StorelessUnivariateStatistic} interface and configuration must be\n+ * completed before <code>addValue</code> is called. No configuration is\n+ * necessary to use the default, commons-math provided implementations.</p>\n+ * \n+ * <p>Note: This class is not thread-safe. Use \n+ * {@link SynchronizedMultivariateSummaryStatistics} if concurrent access from multiple\n+ * threads is required.</p>\n+ *\n+ * @since 1.2\n+ * @version $Revision: 618097 $ $Date: 2008-02-03 22:39:08 +0100 (dim., 03 f\u00e9vr. 2008) $\n+ */\n+public class MultivariateSummaryStatistics\n+  implements StatisticalMultivariateSummary, Serializable {\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = 2271900808994826718L;\n+\n+    /**\n+     * Construct a MultivariateSummaryStatistics instance\n+     * @param k dimension of the data\n+     * @param isCovarianceBiasCorrected if true, the unbiased sample\n+     * covariance is computed, otherwise the biased population covariance\n+     * is computed\n+     */\n+    public MultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n+        this.k = k;\n+\n+        sumImpl     = new StorelessUnivariateStatistic[k];\n+        sumSqImpl   = new StorelessUnivariateStatistic[k];\n+        minImpl     = new StorelessUnivariateStatistic[k];\n+        maxImpl     = new StorelessUnivariateStatistic[k];\n+        sumLogImpl  = new StorelessUnivariateStatistic[k];\n+        geoMeanImpl = new StorelessUnivariateStatistic[k];\n+        meanImpl    = new StorelessUnivariateStatistic[k];\n+\n+        for (int i = 0; i < k; ++i) {\n+            sumImpl[i]     = new Sum();\n+            sumSqImpl[i]   = new SumOfSquares();\n+            minImpl[i]     = new Min();\n+            maxImpl[i]     = new Max();\n+            sumLogImpl[i]  = new SumOfLogs();\n+            geoMeanImpl[i] = new GeometricMean();\n+            meanImpl[i]    = new Mean();\n+        }\n+\n+        covarianceImpl =\n+            new VectorialCovariance(k, isCovarianceBiasCorrected);\n+\n+    }\n+\n+    /** Dimension of the data. */\n+    private int k;\n+\n+    /** Count of values that have been added */\n+    private long n = 0;\n+    \n+    /** Sum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumImpl;\n+    \n+    /** Sum of squares statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumSqImpl;\n+    \n+    /** Minimum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] minImpl;\n+    \n+    /** Maximum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] maxImpl;\n+    \n+    /** Sum of log statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumLogImpl;\n+    \n+    /** Geometric mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] geoMeanImpl;\n+    \n+    /** Mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] meanImpl;\n+    \n+    /** Covariance statistic implementation - cannot be reset. */\n+    private VectorialCovariance covarianceImpl;\n+\n+    /**\n+     * Return a {@link StatisticalMultivariateSummary} instance reporting current\n+     * statistics.\n+     * \n+     * @return Current values of statistics \n+     */\n+    public StatisticalMultivariateSummary getSummary() {\n+        return new StatisticalMultivariateSummaryValues(getDimension(), getMean(),\n+                                                        getCovariance(), getStandardDeviation(),\n+                                                        getN(), getMax(), getMin(),\n+                                                        getSum(), getSumSq(), getSumLog());\n+    }\n+    \n+    /**\n+     * Add a value to the data\n+     * \n+     * @param value  the value to add\n+     * @throws DimensionMismatchException if the value dimension\n+     * does not match the one used at construction\n+     */\n+    public void addValue(double[] value)\n+      throws DimensionMismatchException {\n+        if (value.length != k) {\n+            throw new DimensionMismatchException(value.length, k);\n+        }\n+\n+        for (int i = 0; i < k; ++i) {\n+            double v = value[i];\n+            sumImpl[i].increment(v);\n+            sumSqImpl[i].increment(v);\n+            minImpl[i].increment(v);\n+            maxImpl[i].increment(v);\n+            sumLogImpl[i].increment(v);\n+            geoMeanImpl[i].increment(v);\n+            meanImpl[i].increment(v);\n+        }\n+        covarianceImpl.increment(value);\n+        n++;\n+    }\n+\n+    /** \n+     * Returns the dimension of the data\n+     * @return The dimension of the data\n+     */\n+    public int getDimension() {\n+        return k;\n+    }\n+\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns an array of the results of a statistic.\n+     * @param stats univariate statistic array\n+     * @return results array\n+     */\n+    private double[] getResults(StorelessUnivariateStatistic[] stats) {\n+        double[] results = new double[stats.length];\n+        for (int i = 0; i < results.length; ++i) {\n+            results[i] = stats[i].getResult();\n+        }\n+        return results;\n+    }\n+\n+    /**\n+     * Returns the sum of the values that have been added\n+     * @return The sum or <code>Double.NaN</code> if no values have been added\n+     */\n+    public double[] getSum() {\n+        return getResults(sumImpl);\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     * \n+     * @return The sum of squares\n+     */\n+    public double[] getSumSq() {\n+        return getResults(sumSqImpl);\n+    }\n+\n+    /**\n+     * Returns the sum of the logarithms of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     * \n+     * @return The sum of logarithms\n+     */\n+    public double[] getSumLog() {\n+        return getResults(sumLogImpl);\n+    }\n+\n+    /**\n+     * Returns the mean of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     * \n+     * @return the mean\n+     */\n+    public double[] getMean() {\n+        return getResults(meanImpl);\n+    }\n+\n+    /**\n+     * Returns the standard deviation of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     * \n+     * @return the standard deviation\n+     */\n+    public double[] getStandardDeviation() {\n+        double[] stdDev = new double[k];\n+        if (getN() < 1) {\n+            Arrays.fill(stdDev, Double.NaN);\n+        } else if (getN() < 2) {\n+            Arrays.fill(stdDev, 0.0);\n+        } else {\n+            RealMatrix matrix = covarianceImpl.getResult();\n+            for (int i = 0; i < k; ++i) {\n+                stdDev[i] = Math.sqrt(matrix.getEntry(i, i));\n+            }\n+        }\n+        return stdDev;\n+    }\n+\n+    /**\n+     * Returns the covariance of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the variance \n+     */\n+    public RealMatrix getCovariance() {\n+        return covarianceImpl.getResult();\n+    }\n+\n+    /**\n+     * Returns the maximum of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the maximum  \n+     */\n+    public double[] getMax() {\n+        return getResults(maxImpl);\n+    }\n+\n+    /**\n+     * Returns the minimum of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the minimum  \n+     */\n+    public double[] getMin() {\n+        return getResults(minImpl);\n+    }\n+\n+    /**\n+     * Returns the geometric mean of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the geometric mean  \n+     */\n+    public double[] getGeometricMean() {\n+        return getResults(geoMeanImpl);\n+    }\n+    \n+    /**\n+     * Generates a text report displaying\n+     * summary statistics from values that\n+     * have been added.\n+     * @return String with line feeds displaying statistics\n+     */\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"MultivariateSummaryStatistics:\\n\");\n+        outBuffer.append(\"n: \" + getN() + \"\\n\");\n+        append(outBuffer, getMin(), \"min: \", \", \", \"\\n\");\n+        append(outBuffer, getMax(), \"max: \", \", \", \"\\n\");\n+        append(outBuffer, getMean(), \"mean: \", \", \", \"\\n\");\n+        append(outBuffer, getGeometricMean(), \"geometric mean: \", \", \", \"\\n\");\n+        append(outBuffer, getSumSq(), \"sum of squares: \", \", \", \"\\n\");\n+        append(outBuffer, getSumLog(), \"sum of logarithms: \", \", \", \"\\n\");\n+        append(outBuffer, getStandardDeviation(), \"standard deviation: \", \", \", \"\\n\");\n+        outBuffer.append(\"covariance: \" + getCovariance().toString() + \"\\n\");\n+        return outBuffer.toString();\n+    }\n+\n+    /**\n+     * Append a text representation of an array to a buffer.\n+     * @param buffer buffer to fill\n+     * @param data data array\n+     * @param prefix text prefix\n+     * @param separator elements separator\n+     * @param suffix text suffix\n+     */\n+    private void append(StringBuffer buffer, double[] data,\n+                        String prefix, String separator, String suffix) {\n+        buffer.append(prefix);\n+        for (int i = 0; i < data.length; ++i) {\n+            if (i > 0) {\n+                buffer.append(separator);\n+            }\n+            buffer.append(data[i]);\n+        }\n+        buffer.append(suffix);\n+    }\n+\n+    /** \n+     * Resets all statistics and storage\n+     */\n+    public void clear() {\n+        this.n = 0;\n+        for (int i = 0; i < k; ++i) {\n+            minImpl[i].clear();\n+            maxImpl[i].clear();\n+            sumImpl[i].clear();\n+            sumLogImpl[i].clear();\n+            sumSqImpl[i].clear();\n+            geoMeanImpl[i].clear();\n+            meanImpl[i].clear();\n+        }\n+        covarianceImpl.clear();\n+    }\n+    \n+    /**\n+     * Returns true iff <code>object</code> is a <code>SummaryStatistics</code>\n+     * instance and all statistics have the same values as this.\n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof MultivariateSummaryStatistics == false) {\n+            return false;\n+        }\n+        MultivariateSummaryStatistics stat = (MultivariateSummaryStatistics) object;\n+        return (MathUtils.equals(stat.getGeometricMean(), \n+                this.getGeometricMean()) &&\n+                MathUtils.equals(stat.getMax(), this.getMax()) && \n+                MathUtils.equals(stat.getMean(),this.getMean()) &&\n+                MathUtils.equals(stat.getMin(),this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getSumSq(),this.getSumSq()) &&\n+                MathUtils.equals(stat.getSumLog(),this.getSumLog()) &&\n+                stat.getCovariance().equals(this.getCovariance()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on values of statistics\n+     * \n+     * @return hash code\n+     */\n+    public int hashCode() {\n+        int result = 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getMax());\n+        result = result * 31 + MathUtils.hash(getMean());\n+        result = result * 31 + MathUtils.hash(getMin());\n+        result = result * 31 + MathUtils.hash(getN());\n+        result = result * 31 + MathUtils.hash(getSum());\n+        result = result * 31 + MathUtils.hash(getSumSq());\n+        result = result * 31 + MathUtils.hash(getSumLog());\n+        result = result * 31 + getCovariance().hashCode();\n+        return result;\n+    }\n+\n+    // Getters and setters for statistics implementations\n+    /**\n+     * Returns the currently configured Sum implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the sum\n+     */\n+    public StorelessUnivariateStatistic[] getSumImpl() {\n+        return sumImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the Sum.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param sumImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the Sum\n+     * @throws IllegalArgumentException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setSumImpl(StorelessUnivariateStatistic[] sumImpl) {\n+        checkEmpty();\n+        this.sumImpl = sumImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured sum of squares implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the sum of squares\n+     */\n+    public StorelessUnivariateStatistic[] getSumsqImpl() {\n+        return sumSqImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the sum of squares.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param sumsqImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the sum of squares\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl) {\n+        checkEmpty();\n+        this.sumSqImpl = sumsqImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured minimum implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the minimum\n+     */\n+    public StorelessUnivariateStatistic[] getMinImpl() {\n+        return minImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the minimum.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param minImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the minimum\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setMinImpl(StorelessUnivariateStatistic[] minImpl) {\n+        checkEmpty();\n+        this.minImpl = minImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured maximum implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the maximum\n+     */\n+    public StorelessUnivariateStatistic[] getMaxImpl() {\n+        return maxImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the maximum.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param maxImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the maximum\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setMaxImpl(StorelessUnivariateStatistic[] maxImpl) {\n+        checkEmpty();\n+        this.maxImpl = maxImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured sum of logs implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the log sum\n+     */\n+    public StorelessUnivariateStatistic[] getSumLogImpl() {\n+        return sumLogImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the sum of logs.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param sumLogImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the log sum\n+     * @throws IllegalStateException if data has already been added \n+     *  (i.e if n > 0)\n+     */\n+    public void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl) {\n+        checkEmpty();\n+        this.sumLogImpl = sumLogImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured geometric mean implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the geometric mean\n+     */\n+    public StorelessUnivariateStatistic[] getGeoMeanImpl() {\n+        return geoMeanImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the geometric mean.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param geoMeanImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the geometric mean\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl) {\n+        checkEmpty();\n+        this.geoMeanImpl = geoMeanImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured mean implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the mean\n+     */\n+    public StorelessUnivariateStatistic[] getMeanImpl() {\n+        return meanImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the mean.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param meanImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the mean\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setMeanImpl(StorelessUnivariateStatistic[] meanImpl) {\n+        checkEmpty();\n+        this.meanImpl = meanImpl;\n+    }\n+\n+    /**\n+     * Throws IllegalStateException if n > 0.\n+     */\n+    private void checkEmpty() {\n+        if (n > 0) {\n+            throw new IllegalStateException(\n+                \"Implementations must be configured before values are added.\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ *  Reporting interface for basic multivariate statistics.\n+ *\n+ * @since 1.2\n+ * @version $Revision: 480440 $ $Date: 2006-11-29 08:14:12 +0100 (mer., 29 nov. 2006) $\n+ */\n+public interface StatisticalMultivariateSummary {\n+    /** \n+     * Returns the dimension of the data\n+     * @return The dimension of the data\n+     */\n+    public int getDimension();\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n+     * arithmetic mean </a> of the available values \n+     * @return The mean or null if no values have been added.\n+     */\n+    public abstract double[] getMean();\n+    /** \n+     * Returns the covariance of the available values.\n+     * @return The covariance, null if no values have been added \n+     * or a zeroed matrix for a single value set.  \n+     */\n+    public abstract RealMatrix getCovariance();\n+    /** \n+     * Returns the standard deviation of the available values.\n+     * @return The standard deviation, null if no values have been added \n+     * or a zeroed array for a single value set. \n+     */\n+    public abstract double[] getStandardDeviation();\n+    /** \n+     * Returns the maximum of the available values\n+     * @return The max or null if no values have been added.\n+     */\n+    public abstract double[] getMax();\n+    /** \n+    * Returns the minimum of the available values\n+    * @return The min or null if no values have been added.\n+    */\n+    public abstract double[] getMin();\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public abstract long getN();\n+    /**\n+     * Returns the sum of the values that have been added.\n+     * @return The sum or null if no values have been added\n+     */\n+    public abstract double[] getSum();\n+    /**\n+     * Returns the sum of the squares of the values that have been added.\n+     * @return The sum or null if no values have been added\n+     */\n+    public abstract double[] getSumSq();\n+    /**\n+     * Returns the sum of the logarithms of the values that have been added.\n+     * @return The sum or null if no values have been added\n+     */\n+    public abstract double[] getSumLog();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummaryValues.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ *  Value object representing the results of a statistical multivariate summary.\n+ *\n+ * @since 1.2\n+ * @version $Revision: 480440 $ $Date: 2006-11-29 08:14:12 +0100 (mer., 29 nov. 2006) $\n+ */\n+public class StatisticalMultivariateSummaryValues\n+  implements Serializable, StatisticalMultivariateSummary {\n+   \n+    /** Serialization id */\n+    private static final long serialVersionUID = 8152538650791979064L;\n+\n+    /** Dimension of the data. */\n+    private final int k;\n+\n+    /** The sample mean */\n+    private final double[] mean;\n+    \n+    /** The sample covariance */\n+    private final RealMatrix covariance;\n+\n+    /** The sample standard deviation. */\n+    private double[] stdev;\n+    \n+    /** The number of observations in the sample */\n+    private final long n;\n+    \n+    /** The maximum value */\n+    private final double[] max;\n+    \n+    /** The minimum value */\n+    private final double[] min;\n+    \n+    /** The sum of the sample values */\n+    private final double[] sum;\n+    \n+    /** The sum of the squares of the sample values */\n+    private final double[] sumSq;\n+    \n+    /** The sum of the logarithms of the sample values */\n+    private final double[] sumLog;\n+    \n+    /**\n+      * Constructor\n+      * \n+      * @param mean  the sample mean\n+      * @param covariance  the sample covariance\n+      * @param stdev  the sample standard deviation\n+      * @param k dimension of the data\n+      * @param n  the number of observations in the sample \n+      * @param max  the maximum value\n+      * @param min  the minimum value\n+      * @param sum  the sum of the values\n+      * @param sumSq the sum of the squares of the values\n+      * @param sumLog the sum of the logarithms of the values\n+      */\n+    public StatisticalMultivariateSummaryValues(int k, double[] mean,\n+                                                RealMatrix covariance, double[] stdev,\n+                                                long n, double[] max, double[] min,\n+                                                double[] sum, double[] sumSq, double[] sumLog) {\n+        super();\n+        this.k = k;\n+        this.mean = mean;\n+        this.covariance = covariance;\n+        this.stdev = stdev;\n+        this.n = n;\n+        this.max = max;\n+        this.min = min;\n+        this.sum = sum;\n+        this.sumSq = sumSq;\n+        this.sumLog = sumLog;\n+    }\n+\n+    /** \n+     * Returns the dimension of the data\n+     * @return The dimension of the data\n+     */\n+    public int getDimension() {\n+        return k;\n+    }\n+\n+    /**\n+     * @return Returns the max.\n+     */\n+    public double[] getMax() {\n+        return max;\n+    }\n+\n+    /**\n+     * @return Returns the mean.\n+     */\n+    public double[] getMean() {\n+        return mean;\n+    }\n+\n+    /**\n+     * @return Returns the min.\n+     */\n+    public double[] getMin() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return Returns the number of values.\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * @return Returns the sum.\n+     */\n+    public double[] getSum() {\n+        return sum;\n+    }\n+    \n+    /**\n+     * @return Returns the sum of the squares.\n+     */\n+    public double[] getSumSq() {\n+        return sumSq;\n+    }\n+    \n+    /**\n+     * @return Returns the sum of the logarithms.\n+     */\n+    public double[] getSumLog() {\n+        return sumLog;\n+    }\n+    \n+    /**\n+     * @return Returns the standard deviation (roots of the diagonal elements)\n+     */\n+    public double[] getStandardDeviation() {\n+        return stdev; \n+    }\n+\n+    /**\n+     * @return Returns the covariance.\n+     */\n+    public RealMatrix getCovariance() {\n+        return covariance;\n+    }\n+    \n+    /**\n+     * Returns true iff <code>object</code> is a \n+     * <code>StatisticalSummaryValues</code> instance and all statistics have\n+     *  the same values as this.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof StatisticalMultivariateSummaryValues == false) {\n+            return false;\n+        }\n+        StatisticalMultivariateSummaryValues stat = (StatisticalMultivariateSummaryValues) object;\n+        return ((stat.getDimension() == this.getDimension()) &&\n+                MathUtils.equals(stat.getMax(), this.getMax()) && \n+                MathUtils.equals(stat.getMean(),this.getMean()) &&\n+                MathUtils.equals(stat.getMin(),this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getSumSq(), this.getSumSq()) &&\n+                MathUtils.equals(stat.getSumLog(), this.getSumLog()) &&\n+                MathUtils.equals(stat.getStandardDeviation(), this.getStandardDeviation()) &&\n+                stat.getCovariance().equals(this.getCovariance()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on values of statistics\n+     * \n+     * @return hash code\n+     */\n+    public int hashCode() {\n+        int result = getDimension();\n+        result = result * 31 + MathUtils.hash(getMax());\n+        result = result * 31 + MathUtils.hash(getMean());\n+        result = result * 31 + MathUtils.hash(getMin());\n+        result = result * 31 + MathUtils.hash(getN());\n+        result = result * 31 + MathUtils.hash(getSum());\n+        result = result * 31 + MathUtils.hash(getSumSq());\n+        result = result * 31 + MathUtils.hash(getSumLog());\n+        result = result * 31 + getCovariance().hashCode();\n+        result = result * 31 + MathUtils.hash(getStandardDeviation());\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * Implementation of\n+ * {@link org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics} that\n+ * is safe to use in a multithreaded environment.  Multiple threads can safely\n+ * operate on a single instance without causing runtime exceptions due to race\n+ * conditions.  In effect, this implementation makes modification and access\n+ * methods atomic operations for a single instance.  That is to say, as one\n+ * thread is computing a statistic from the instance, no other thread can modify\n+ * the instance nor compute another statistic.\n+ * @since 1.2\n+ * @version $Revision: 618097 $ $Date: 2008-02-03 22:39:08 +0100 (dim., 03 f\u00e9vr. 2008) $\n+ */\n+public class SynchronizedMultivariateSummaryStatistics\n+  extends MultivariateSummaryStatistics {\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = 7099834153347155363L;\n+\n+    /**\n+     * Construct a SynchronizedMultivariateSummaryStatistics instance\n+     * @param k dimension of the data\n+     * @param isCovarianceBiasCorrected if true, the unbiased sample\n+     * covariance is computed, otherwise the biased population covariance\n+     * is computed\n+     */\n+    public SynchronizedMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n+        super(k, isCovarianceBiasCorrected);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getSummary()\n+     */\n+    public synchronized StatisticalMultivariateSummary getSummary() {\n+        return super.getSummary();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#addValue(double[])\n+     */\n+    public synchronized void addValue(double[] value)\n+      throws DimensionMismatchException {\n+      super.addValue(value);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getDimension()\n+     */\n+    public synchronized int getDimension() {\n+        return super.getDimension();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getN()\n+     */\n+    public synchronized long getN() {\n+        return super.getN();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getSum()\n+     */\n+    public synchronized double[] getSum() {\n+        return super.getSum();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getSummSq()\n+     */\n+    public synchronized double[] getSumSq() {\n+        return super.getSumSq();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getSumLog()\n+     */\n+    public synchronized double[] getSumLog() {\n+        return super.getSumLog();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getMean()\n+     */\n+    public synchronized double[] getMean() {\n+        return super.getMean();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getStandardDeviation()\n+     */\n+    public synchronized double[] getStandardDeviation() {\n+        return super.getStandardDeviation();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getCovariance()\n+     */\n+    public synchronized RealMatrix getCovariance() {\n+        return super.getCovariance();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getMax()\n+     */\n+    public synchronized double[] getMax() {\n+        return super.getMax();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getMin()\n+     */\n+    public synchronized double[] getMin() {\n+        return super.getMin();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getGeometricMean()\n+     */\n+    public synchronized double[] getGeometricMean() {\n+        return super.getGeometricMean();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#toString()\n+     */\n+    public synchronized String toString() {\n+        return super.toString();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#clear()\n+     */\n+    public synchronized void clear() {\n+        super.clear();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#equals()\n+     */\n+    public synchronized boolean equals(Object object) {\n+        return super.equals(object);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#hashCode()\n+     */\n+    public synchronized int hashCode() {\n+        return super.hashCode();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getSumImpl()\n+     */\n+    public synchronized StorelessUnivariateStatistic[] getSumImpl() {\n+        return super.getSumImpl();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#setSumImpl(StorelessUnivariateStatistic[])\n+     */\n+    public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl) {\n+        super.setSumImpl(sumImpl);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getSumsqImpl()\n+     */\n+    public synchronized StorelessUnivariateStatistic[] getSumsqImpl() {\n+        return super.getSumsqImpl();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#setSumsqImpl(StorelessUnivariateStatistic[])\n+     */\n+    public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl) {\n+        super.setSumsqImpl(sumsqImpl);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getMinImpl()\n+     */\n+    public synchronized StorelessUnivariateStatistic[] getMinImpl() {\n+        return super.getMinImpl();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#setMinImpl(StorelessUnivariateStatistic[])\n+     */\n+    public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl) {\n+        super.setMinImpl(minImpl);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getMaxImpl()\n+     */\n+    public synchronized StorelessUnivariateStatistic[] getMaxImpl() {\n+        return super.getMaxImpl();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#setMaxImpl(StorelessUnivariateStatistic[])\n+     */\n+    public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl) {\n+        super.setMaxImpl(maxImpl);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getSumLogImpl()\n+     */\n+    public synchronized StorelessUnivariateStatistic[] getSumLogImpl() {\n+        return super.getSumLogImpl();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#setSumLogImpl(StorelessUnivariateStatistic[])\n+     */\n+    public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl) {\n+        super.setSumLogImpl(sumLogImpl);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getGeoMeanImpl()\n+     */\n+    public synchronized StorelessUnivariateStatistic[] getGeoMeanImpl() {\n+        return super.getGeoMeanImpl();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#setGeoMeanImpl(StorelessUnivariateStatistic[])\n+     */\n+    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl) {\n+        super.setGeoMeanImpl(geoMeanImpl);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#getMeanImpl()\n+     */\n+    public synchronized StorelessUnivariateStatistic[] getMeanImpl() {\n+        return super.getMeanImpl();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.MultivariateSummary#setMeanImpl(StorelessUnivariateStatistic[])\n+     */\n+    public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl) {\n+        super.setMeanImpl(meanImpl);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+\n+/**\n+ * Test cases for the {@link MultivariateSummaryStatistics} class.\n+ *\n+ * @version $Revision: 566833 $ $Date: 2007-08-16 13:36:33 -0700 (Thu, 16 Aug 2007) $\n+ */\n+\n+public class MultivariateSummaryStatisticsTest extends TestCase {\n+\n+    public MultivariateSummaryStatisticsTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MultivariateSummaryStatisticsTest.class);\n+        suite.setName(\"MultivariateSummaryStatistics tests\");\n+        return suite;\n+    }\n+\n+    public void testSetterInjection() throws Exception {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);\n+        u.setMeanImpl(new StorelessUnivariateStatistic[] {\n+                        new sumMean(), new sumMean()\n+                      });\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals(4, u.getMean()[0], 1E-14);\n+        assertEquals(6, u.getMean()[1], 1E-14);\n+        u.clear();\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals(4, u.getMean()[0], 1E-14);\n+        assertEquals(6, u.getMean()[1], 1E-14);\n+        u.clear();\n+        u.setMeanImpl(new StorelessUnivariateStatistic[] {\n+                        new Mean(), new Mean()\n+                      }); // OK after clear\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals(2, u.getMean()[0], 1E-14);\n+        assertEquals(3, u.getMean()[1], 1E-14);\n+    }\n+    \n+    public void testSetterIllegalState() throws Exception {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 3, 4 });\n+        try {\n+            u.setMeanImpl(new StorelessUnivariateStatistic[] {\n+                            new sumMean(), new sumMean()\n+                          });\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    /**\n+     * Bogus mean implementation to test setter injection.\n+     * Returns the sum instead of the mean.\n+     */\n+    static class sumMean implements StorelessUnivariateStatistic {   \n+        private static final long serialVersionUID = 6492471391340853423L;\n+        private double sum = 0;\n+        private long n = 0;\n+        public double evaluate(double[] values, int begin, int length) {\n+            return 0;\n+        }\n+        public double evaluate(double[] values) {\n+            return 0;\n+        }\n+        public void clear() {\n+          sum = 0; \n+          n = 0;\n+        }\n+        public long getN() {\n+            return n;\n+        }\n+        public double getResult() {\n+            return sum;\n+        }\n+        public void increment(double d) {\n+            sum += d;\n+            n++;\n+        }\n+        public void incrementAll(double[] values, int start, int length) {\n+        }\n+        public void incrementAll(double[] values) {\n+        }   \n+    }\n+\n+    public void testDimension() {\n+        try {\n+            new MultivariateSummaryStatistics(2, true).addValue(new double[3]);\n+        } catch (DimensionMismatchException dme) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test stats */\n+    public void testStats() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);\n+        assertEquals(0, u.getN());\n+        u.addValue(new double[] { 1, 2 });\n+        u.addValue(new double[] { 2, 3 });\n+        u.addValue(new double[] { 2, 3 });\n+        u.addValue(new double[] { 3, 4 });\n+        assertEquals( 4, u.getN());\n+        assertEquals( 8, u.getSum()[0], 1.0e-10);\n+        assertEquals(12, u.getSum()[1], 1.0e-10);\n+        assertEquals(18, u.getSumSq()[0], 1.0e-10);\n+        assertEquals(38, u.getSumSq()[1], 1.0e-10);\n+        assertEquals( 1, u.getMin()[0], 1.0e-10);\n+        assertEquals( 2, u.getMin()[1], 1.0e-10);\n+        assertEquals( 3, u.getMax()[0], 1.0e-10);\n+        assertEquals( 4, u.getMax()[1], 1.0e-10);\n+        assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10);\n+        assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10);\n+        assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10);\n+        assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);\n+        assertEquals( 2, u.getMean()[0], 1.0e-10);\n+        assertEquals( 3, u.getMean()[1], 1.0e-10);\n+        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);\n+        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);\n+        assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);\n+        u.clear();\n+        assertEquals(0, u.getN());    \n+    }     \n+\n+    public void testN0andN1Conditions() throws Exception {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(1, true);\n+        assertTrue(Double.isNaN(u.getMean()[0]));\n+        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));\n+\n+        /* n=1 */\n+        u.addValue(new double[] { 1 });\n+        assertEquals(1.0, u.getMean()[0], 1.0e-10);\n+        assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);\n+        assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);\n+\n+        /* n=2 */               \n+        u.addValue(new double[] { 2 });\n+        assertTrue(u.getStandardDeviation()[0] > 0);\n+\n+    }\n+\n+    public void testNaNContracts() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(1, true);\n+        assertTrue(Double.isNaN(u.getMean()[0])); \n+        assertTrue(Double.isNaN(u.getMin()[0])); \n+        assertTrue(Double.isNaN(u.getStandardDeviation()[0])); \n+        assertTrue(Double.isNaN(u.getGeometricMean()[0]));\n+\n+        u.addValue(new double[] { 1.0 });\n+        assertFalse(Double.isNaN(u.getMean()[0])); \n+        assertFalse(Double.isNaN(u.getMin()[0])); \n+        assertFalse(Double.isNaN(u.getStandardDeviation()[0])); \n+        assertFalse(Double.isNaN(u.getGeometricMean()[0]));\n+\n+    }\n+\n+    public void testGetSummary() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);\n+        StatisticalMultivariateSummary summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(new double[] { 1, 2 });\n+        summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(new double[] { 2, 5 });\n+        summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(new double[] { 2, 2 });\n+        summary = u.getSummary();\n+        verifySummary(u, summary);     \n+    }\n+\n+    public void testSerialization() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);\n+        // Empty test\n+        TestUtils.checkSerializedEquality(u);\n+        MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);\n+        StatisticalMultivariateSummary summary = s.getSummary();\n+        verifySummary(u, summary);\n+\n+        // Add some data\n+        u.addValue(new double[] { 2d, 1d });\n+        u.addValue(new double[] { 1d, 1d });\n+        u.addValue(new double[] { 3d, 1d });\n+        u.addValue(new double[] { 4d, 1d });\n+        u.addValue(new double[] { 5d, 1d });\n+\n+        // Test again\n+        TestUtils.checkSerializedEquality(u);\n+        s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u);\n+        summary = s.getSummary();\n+        verifySummary(u, summary);\n+\n+    }\n+\n+    public void testEqualsAndHashCode() throws DimensionMismatchException {\n+        MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true);\n+        MultivariateSummaryStatistics t = null;\n+        int emptyHash = u.hashCode();\n+        assertTrue(u.equals(u));\n+        assertFalse(u.equals(t));\n+        assertFalse(u.equals(new Double(0)));\n+        t = new MultivariateSummaryStatistics(2, true);\n+        assertTrue(t.equals(u));\n+        assertTrue(u.equals(t));\n+        assertEquals(emptyHash, t.hashCode());\n+\n+        // Add some data to u\n+        u.addValue(new double[] { 2d, 1d });\n+        u.addValue(new double[] { 1d, 1d });\n+        u.addValue(new double[] { 3d, 1d });\n+        u.addValue(new double[] { 4d, 1d });\n+        u.addValue(new double[] { 5d, 1d });\n+        assertFalse(t.equals(u));\n+        assertFalse(u.equals(t));\n+        assertTrue(u.hashCode() != t.hashCode());\n+\n+        //Add data in same order to t\n+        t.addValue(new double[] { 2d, 1d });\n+        t.addValue(new double[] { 1d, 1d });\n+        t.addValue(new double[] { 3d, 1d });\n+        t.addValue(new double[] { 4d, 1d });\n+        t.addValue(new double[] { 5d, 1d });\n+        assertTrue(t.equals(u));\n+        assertTrue(u.equals(t));\n+        assertEquals(u.hashCode(), t.hashCode());   \n+\n+        // Clear and make sure summaries are indistinguishable from empty summary\n+        u.clear();\n+        t.clear();\n+        assertTrue(t.equals(u));\n+        assertTrue(u.equals(t));\n+        assertEquals(emptyHash, t.hashCode());\n+        assertEquals(emptyHash, u.hashCode());\n+    }\n+\n+    private void verifySummary(MultivariateSummaryStatistics u, StatisticalMultivariateSummary s) {\n+        assertEquals(s.getN(), u.getN());\n+        for (int i = 0; i < u.getDimension(); ++i) {\n+            checkValue(s.getSum()[i], u.getSum()[i], 1.0e-10);\n+            checkValue(s.getStandardDeviation()[i], u.getStandardDeviation()[i], 1.0e-10);\n+            checkValue(s.getMean()[i], u.getMean()[i], 1.0e-10);\n+            checkValue(s.getMin()[i], u.getMin()[i], 1.0e-10);\n+            checkValue(s.getMax()[i], u.getMax()[i], 1.0e-10);\n+            checkValue(s.getSumSq()[i], u.getSumSq()[i], 1.0e-10);\n+            checkValue(s.getSumLog()[i], u.getSumLog()[i], 1.0e-10);\n+            checkValue(s.getMax()[i], u.getMax()[i], 1.0e-10);\n+        }\n+    }\n+\n+    private void checkValue(double expected, double actual, double tolerance) {\n+        if (Double.isNaN(expected)) {\n+            assertTrue(Double.isNaN(actual));\n+        } else {\n+            assertEquals(expected, actual, tolerance);\n+        }\n+    }\n+\n+}", "timestamp": 1202488954, "metainfo": ""}