{"sha": "fd0f87590d1c88c18f669e9b168c8fd20631f23c", "log": "replaced inefficient use of constructors for Integer, Long, Float and Double by the recommended static valueOf methods that cache results  ", "commit": "\n--- a/src/experimental/org/apache/commons/math/function/DefaultContext.java\n+++ b/src/experimental/org/apache/commons/math/function/DefaultContext.java\n         }\n                 \n         DefaultValue(double d) {\n-            value = new Double(d);\n+            value = Double.valueOf(d);\n         }\n \n         DefaultValue(float f) {\n-            value = new Float(f);\n+            value = Float.valueOf(f);\n         }\n \n         DefaultValue(int i) {\n-            value = new Integer(i);\n+            value = Integer.valueOf(i);\n         }\n \n         DefaultValue(long l) {\n-            value = new Long(l);\n+            value = Long.valueOf(l);\n         }\n         \n         /* (non-Javadoc)\n--- a/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImpl.java\n+++ b/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImpl.java\n \t    } catch (Exception ex) {              // InstantiationException, IllegalAccessException\n \t        throw new RuntimeException(ex);   // should never happen\n \t    }\n-\t\tdynaBean.set(propertyName, new Double(v));\n+\t\tdynaBean.set(propertyName, Double.valueOf(v));\n \t\taddObject(dynaBean);\n \t}\n \n--- a/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImplTest.java\n+++ b/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImplTest.java\n         patientList = new ArrayList();\n \n         // Create and add patient bean 1\n-        VitalStats vs1 = new VitalStats( new Double(120.0), \n-                                         new Double(96.4) );\n-        Patient p1 = new Patient( vs1, new Integer( 35 ) );\n+        VitalStats vs1 = new VitalStats( Double.valueOf(120.0), \n+                                         Double.valueOf(96.4) );\n+        Patient p1 = new Patient( vs1, Integer.valueOf( 35 ) );\n         patientList.add( p1 );\n \n         // Create and add patient bean 2\n-        VitalStats vs2 = new VitalStats( new Double(70.0), \n-                                         new Double(97.4) );\n-        Patient p2 = new Patient( vs2, new Integer( 23 ) );\n+        VitalStats vs2 = new VitalStats( Double.valueOf(70.0), \n+                                         Double.valueOf(97.4) );\n+        Patient p2 = new Patient( vs2, Integer.valueOf( 23 ) );\n         patientList.add( p2 );\n \n         // Create and add patient bean 3\n-        VitalStats vs3 = new VitalStats( new Double(90.0), \n-                                         new Double(98.6) );\n-        Patient p3 = new Patient( vs3, new Integer( 42 ) );\n+        VitalStats vs3 = new VitalStats( Double.valueOf(90.0), \n+                                         Double.valueOf(98.6) );\n+        Patient p3 = new Patient( vs3, Integer.valueOf( 42 ) );\n         patientList.add( p3 );\n     }\n     \n--- a/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n+++ b/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n     public ArgumentOutsideDomainException(double argument, double lower, double upper) {\n         super(argument,\n               \"Argument {0} outside domain [{1} ; {2}]\",\n-              new Object[] { new Double(argument), new Double(lower), new Double(upper) });\n+              new Object[] { Double.valueOf(argument), Double.valueOf(lower), Double.valueOf(upper) });\n     }\n \n }\n--- a/src/java/org/apache/commons/math/DimensionMismatchException.java\n+++ b/src/java/org/apache/commons/math/DimensionMismatchException.java\n     public DimensionMismatchException(int dimension1, int dimension2) {\n         super(\"dimension mismatch {0} != {1}\",\n               new Object[] {\n-                new Integer(dimension1), new Integer(dimension2)\n+                Integer.valueOf(dimension1), Integer.valueOf(dimension2)\n               });\n         this.dimension1 = dimension1;\n         this.dimension2 = dimension2;\n--- a/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+++ b/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n      */\n     public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {\n         super(\"Abscissa {0} is duplicated at both indices {1} and {2}\",\n-              new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });\n+              new Object[] { Double.valueOf(abscissa), Integer.valueOf(i1), Integer.valueOf(i2) });\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n      */\n     public FunctionEvaluationException(double argument) {\n         super(\"Evaluation failed for argument = {0}\",\n-              new Object[] { new Double(argument) });\n+              new Object[] { Double.valueOf(argument) });\n         this.argument = argument;\n     }\n     \n--- a/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n+++ b/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n      */\n     public MaxIterationsExceededException(int maxIterations) {\n         super(\"Maximal number of iterations ({0}) exceeded\",\n-              new Object[] { new Integer(maxIterations) });\n+              new Object[] { Integer.valueOf(maxIterations) });\n         this.maxIterations = maxIterations;\n     }\n \n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n         if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException\n             (\"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n-             new Object[] { new Integer(numIterations), new Integer(maximumIterations),\n-                            new Double(initial), new Double(lowerBound), new Double(upperBound),\n-                            new Double(a), new Double(b), new Double(fa), new Double(fb) });\n+             new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),\n+                            Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),\n+                            Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });\n         }\n         \n         return new double[]{a, b};\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n         int endIndex = startIndex + n;\n         if (endIndex < source.length()) {\n             if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n-                ret = new Double(value);\n+                ret = Double.valueOf(value);\n                 pos.setIndex(endIndex);\n             }\n         }\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n \n         if (++costEvaluations > maxCostEval) {\n             throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n-                                          new Object[] { new Integer(maxCostEval) });\n+                                          new Object[] { Integer.valueOf(maxCostEval) });\n         }\n \n         cost = 0;\n         int p = problem.getUnboundParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n-                                          new Object[] { new Integer(m), new Integer(p)});\n+                                          new Object[] { Integer.valueOf(m), Integer.valueOf(p)});\n         }\n         double[] errors = new double[problem.getUnboundParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n--- a/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n           throw new EstimationException(\"cost relative tolerance is too small ({0}),\" +\n                                         \" no further reduction in the\" +\n                                         \" sum of squares is possible\",\n-                                        new Object[] { new Double(costRelativeTolerance) });\n+                                        new Object[] { Double.valueOf(costRelativeTolerance) });\n         } else if (delta <= 2.2204e-16 * xNorm) {\n           throw new EstimationException(\"parameters relative tolerance is too small\" +\n                                         \" ({0}), no further improvement in\" +\n                                         \" the approximate solution is possible\",\n-                                        new Object[] { new Double(parRelativeTolerance) });\n+                                        new Object[] { Double.valueOf(parRelativeTolerance) });\n         } else if (maxCosine <= 2.2204e-16)  {\n           throw new EstimationException(\"orthogonality tolerance is too small ({0}),\" +\n                                         \" solution is orthogonal to the jacobian\",\n-                                        new Object[] { new Double(orthoTolerance) });\n+                                        new Object[] { Double.valueOf(orthoTolerance) });\n         }\n \n       }\n         }\n         if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n             throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n-                                          new Object[] { new Integer(rows), new Integer(cols) });\n+                                          new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });\n         }\n         if (norm2 > ak2) {\n           nextColumn = i;\n--- a/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n      */\n     public FractionConversionException(double value, int maxIterations) {\n         super(\"Unable to convert {0} to fraction after {1} iterations\",\n-              new Object[] { new Double(value), new Integer(maxIterations) });\n+              new Object[] { Double.valueOf(value), Integer.valueOf(maxIterations) });\n     }\n \n     /**\n      */\n     public FractionConversionException(double value, long p, long q) {\n         super(\"Overflow trying to convert {0} to fraction ({1}/{2})\",\n-              new Object[] { new Double(value), new Long(p), new Long(q) });\n+              new Object[] { Double.valueOf(value), Long.valueOf(p), Long.valueOf(q) });\n     }\n \n }\n--- a/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n           throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n                                         \" initial state vector has dimension {1}\",\n                                         new Object[] {\n-                                          new Integer(equations.getDimension()),\n-                                          new Integer(y0.length)\n+                                          Integer.valueOf(equations.getDimension()),\n+                                          Integer.valueOf(y0.length)\n                                         });\n       }\n       if (equations.getDimension() != y.length) {\n           throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n                                         \" final state vector has dimension {1}\",\n                                         new Object[] {\n-                                          new Integer(equations.getDimension()),\n-                                          new Integer(y.length)\n+                                          Integer.valueOf(equations.getDimension()),\n+                                          Integer.valueOf(y.length)\n                                         });\n       }\n       if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n           throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n                                         \" absolute tolerance vector has dimension {1}\",\n                                         new Object[] {\n-                                          new Integer(y0.length),\n-                                          new Integer(vecAbsoluteTolerance.length)\n+                                          Integer.valueOf(y0.length),\n+                                          Integer.valueOf(vecAbsoluteTolerance.length)\n                                         });\n       }\n       if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n           throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n                                         \" relative tolerance vector has dimension {1}\",\n                                         new Object[] {\n-                                          new Integer(y0.length),\n-                                          new Integer(vecRelativeTolerance.length)\n+                                          Integer.valueOf(y0.length),\n+                                          Integer.valueOf(vecRelativeTolerance.length)\n                                         });\n       }\n       if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n         throw new IntegratorException(\"too small integration interval: length = {0}\",\n-                                      new Object[] { new Double(Math.abs(t - t0)) });\n+                                      new Object[] { Double.valueOf(Math.abs(t - t0)) });\n       }\n       \n   }\n         throw new IntegratorException(\"minimal step size ({0}) reached,\" +\n                                       \" integration needs {1}\",\n                                       new Object[] {\n-                                        new Double(minStep),\n-                                        new Double(Math.abs(h))\n+                                        Double.valueOf(minStep),\n+                                        Double.valueOf(Math.abs(h))\n                                       });\n       }\n     }\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n       throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n                                     \" initial state vector has dimension {1}\",\n                                     new Object[] {\n-                                      new Integer(equations.getDimension()),\n-                                      new Integer(y0.length)\n+                                      Integer.valueOf(equations.getDimension()),\n+                                      Integer.valueOf(y0.length)\n                                     });\n     }\n     if (equations.getDimension() != y.length) {\n         throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n                                       \" final state vector has dimension {1}\",\n                                       new Object[] {\n-                                        new Integer(equations.getDimension()),\n-                                        new Integer(y.length)\n+                                        Integer.valueOf(equations.getDimension()),\n+                                        Integer.valueOf(y.length)\n                                       });\n       }\n     if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n       throw new IntegratorException(\"too small integration interval: length = {0}\",\n-                                    new Object[] { new Double(Math.abs(t - t0)) });\n+                                    new Object[] { Double.valueOf(Math.abs(t - t0)) });\n     }      \n   }\n \n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n             double val = 0.0;\n             sampleStats = new SummaryStatistics();\n             while ((str = inputStream.readLine()) != null) {\n-                val = new Double(str).doubleValue();\n+                val = Double.valueOf(str).doubleValue();\n                 sampleStats.addValue(val);\n             }\n             inputStream.close();\n         // Load array of bin upper bounds -- evenly spaced from min - max\n         double min = sampleStats.getMin();\n         double max = sampleStats.getMax();\n-        double delta = (max - min)/(new Double(binCount)).doubleValue();\n+        double delta = (max - min)/(Double.valueOf(binCount)).doubleValue();\n         double[] binUpperBounds = new double[binCount];\n         binUpperBounds[0] = min + delta;\n         for (int i = 1; i< binCount - 1; i++) {\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n \n         //Convert each byte to 2 hex digits\n         for (int i = 0; i < randomBytes.length; i++) {\n-            Integer c = new Integer(randomBytes[i]);\n+            Integer c = Integer.valueOf(randomBytes[i]);\n \n             /* Add 128 to byte value to make interval 0-255 before\n              * doing hex conversion.\n \n             //Loop over the hash, converting each byte to 2 hex digits\n             for (int i = 0; i < hash.length; i++) {\n-                Integer c = new Integer(hash[i]);\n+                Integer c = Integer.valueOf(hash[i]);\n \n                 /* Add 128 to byte value to make interval 0-255\n                  * This guarantees <= 2 hex digits from toHexString()\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n  * throw an IllegalArgumentException.</p>\n  * <p>\n  * Integer values (int, long, Integer, Long) are not distinguished by type -- \n- * i.e. <code>addValue(new Long(2)), addValue(2), addValue(2l)</code> all have\n+ * i.e. <code>addValue(Long.valueOf(2)), addValue(2), addValue(2l)</code> all have\n  * the same effect (similarly for arguments to <code>getCount,</code> etc.).</p>\n  * <p>\n  * The values are ordered using the default (natural order), unless a  \n     public void addValue(Object v) {\n         Object obj = v;\n         if (v instanceof Integer) {\n-           obj = new Long(((Integer) v).longValue());\n+           obj = Long.valueOf(((Integer) v).longValue());\n         }\n         try {\n             Long count = (Long) freqTable.get(obj);\n             if (count == null) {\n-                freqTable.put(obj, new Long(1));\n+                freqTable.put(obj, Long.valueOf(1));\n             } else {\n-                freqTable.put(obj, new Long(count.longValue() + 1));\n+                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n             }\n         } catch (ClassCastException ex) {   \n             //TreeMap will throw ClassCastException if v is not comparable\n      * @param v the value to add.\n      */\n     public void addValue(int v) {\n-        addValue(new Long(v));\n+        addValue(Long.valueOf(v));\n     }\n     \n     /**\n      * @param v the value to add.\n      */\n     public void addValue(Integer v) {\n-        addValue(new Long(v.longValue()));\n+        addValue(Long.valueOf(v.longValue()));\n     }\n \n     /**\n      * @param v the value to add.\n      */\n     public void addValue(long v) {\n-        addValue(new Long(v));\n+        addValue(Long.valueOf(v));\n     }\n     \n     /**\n      * @return the frequency of v.\n      */\n     public long getCount(int v) {\n-        return getCount(new Long(v));\n+        return getCount(Long.valueOf(v));\n     }\n     \n     /**\n      * @return the frequency of v.\n      */\n     public long getCount(long v) {\n-        return getCount(new Long(v));\n+        return getCount(Long.valueOf(v));\n     }\n     \n     /**\n      * @return the proportion of values equal to v\n      */\n     public double getPct(int v) {\n-        return getPct(new Long(v));       \n+        return getPct(Long.valueOf(v));       \n     }\n     \n     /**\n      * @return the proportion of values equal to v\n      */\n     public double getPct(long v) {\n-        return getPct(new Long(v));         \n+        return getPct(Long.valueOf(v));         \n     }\n     \n     /**\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(int v) {\n-        return getCumFreq(new Long(v));       \n+        return getCumFreq(Long.valueOf(v));       \n     }\n     \n      /**\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(long v) {\n-        return getCumFreq(new Long(v));         \n+        return getCumFreq(Long.valueOf(v));         \n     }\n     \n     /**\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(int v) {\n-        return getCumPct(new Long(v));       \n+        return getCumPct(Long.valueOf(v));       \n     }\n     \n     /**\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(long v) {\n-        return getCumPct(new Long(v));         \n+        return getCumPct(Long.valueOf(v));         \n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n             try {\n                 percentileImpl.getClass().getMethod(\"setQuantile\", \n                         new Class[] {Double.TYPE}).invoke(percentileImpl,\n-                                new Object[] {new Double(p)});\n+                                new Object[] {Double.valueOf(p)});\n             } catch (NoSuchMethodException e1) { // Setter guard should prevent\n                 throw new IllegalArgumentException(\n                    \"Percentile implementation does not support setQuantile\");\n         try {\n             percentileImpl.getClass().getMethod(\"setQuantile\", \n                     new Class[] {Double.TYPE}).invoke(percentileImpl,\n-                            new Object[] {new Double(50.0d)});\n+                            new Object[] {Double.valueOf(50.0d)});\n         } catch (NoSuchMethodException e1) { \n             throw new IllegalArgumentException(\n                     \"Percentile implementation does not support setQuantile\");\n--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n                     // can not scale an convergent is unbounded.\n                     throw new ConvergenceException(\n                         \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n-                        new Object[] { new Double(x) });\n+                        new Object[] { Double.valueOf(x) });\n                 }\n             }\n             double r = p2 / q2;\n         if (n >= maxIterations) {\n             throw new MaxIterationsExceededException(maxIterations,\n                 \"Continued fraction convergents failed to converge for value {0}\",\n-                new Object[] { new Double(x) });\n+                new Object[] { Double.valueOf(x) });\n         }\n \n         return c;\n--- a/src/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/java/org/apache/commons/math/util/DefaultTransformer.java\n         }\n             \n         try {\n-            return new Double(o.toString()).doubleValue();\n+            return Double.valueOf(o.toString()).doubleValue();\n         } catch (Exception e) {\n             throw new MathException(\"Conversion Exception in Transformation: {0}\",\n                                     new Object[] { e.getMessage() }, e);\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n       System.arraycopy((a.length < p.a.length) ? p.a : a,\n                        lowLength, newA, lowLength, highLength - lowLength);\n \n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n         System.arraycopy(a, lowLength, newA, lowLength, highLength - lowLength);\n       }\n \n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n       for (int i = 0; i < a.length; ++i) {\n         newA[i] = -a[i];\n       }\n-      return new Double(newA);\n+      return Double.valueOf(newA);\n     }\n \n     /** Multiply the instance by a polynomial.\n         }\n       }\n \n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n     public Polynomial multiply(double r) {\n \n       if (r == 0) {\n-        return new Double(new double[] { 0.0 });\n+        return Double.valueOf(new double[] { 0.0 });\n       }\n \n       double[] newA = new double[a.length];\n       for (int i = 0; i < a.length; ++i) {\n         newA[i] = a[i] * r;\n       }\n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n      */\n     public Polynomial getDerivative() {\n       if (a.length == 1) {\n-        return new Double();\n+        return Double.valueOf();\n       }\n       double[] newA = new double[a.length - 1];\n       for (int i = 1; i < a.length; ++i) {\n         newA[i - 1] = a[i] * i;\n       }\n-      return new Double(newA);\n+      return Double.valueOf(newA);\n     }\n \n     /** Returns a string representation of the polynomial.\n--- a/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         ConvergenceException ex = new ConvergenceException(pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);\n--- a/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"Evaluation failed for argument = {0}\";\n-        Object[] arguments = { new Double(0.0) };\n+        Object[] arguments = { Double.valueOf(0.0) };\n         FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"Evaluation failed for argument = {0}\";\n-        Object[] arguments = { new Double(0.0) };\n+        Object[] arguments = { Double.valueOf(0.0) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);\n--- a/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         MathConfigurationException ex = new MathConfigurationException(pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);\n--- a/src/test/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathExceptionTest.java\n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         MathException ex = new MathException(pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathException ex = new MathException(pattern, arguments, cause);\n--- a/src/test/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n         MaxIterationsExceededException ex =\n             new MaxIterationsExceededException(1000000,\n                 \"Continued fraction convergents failed to converge for value {0}\",\n-                new Object[] { new Double(1234567) });\n+                new Object[] { Double.valueOf(1234567) });\n         assertNull(ex.getCause());\n         assertNotNull(ex.getMessage());\n         assertTrue(ex.getMessage().indexOf(\"1,000,000\") < 0);\n--- a/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n     \n     public void testFormatNumber() {\n         ComplexFormat cf = ComplexFormat.getInstance(getLocale());\n-        Double pi = new Double(Math.PI);\n+        Double pi = Double.valueOf(Math.PI);\n         String text = cf.format(pi);\n         assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n     }\n--- a/src/test/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/org/apache/commons/math/fraction/FractionTest.java\n         Fraction nullFraction = null;\n         assertTrue( zero.equals(zero));\n         assertFalse(zero.equals(nullFraction));\n-        assertFalse(zero.equals(new Double(0)));\n+        assertFalse(zero.equals(Double.valueOf(0)));\n         Fraction zero2 = new Fraction(0,2);\n         assertTrue(zero.equals(zero2));\n         assertEquals(zero.hashCode(), zero2.hashCode());\n--- a/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n           double offset = t - middle;\n           if (offset > 0) {\n             throw new SwitchException(\"Evaluation failed for argument = {0}\",\n-                                      new Object[] { new Double(t) });\n+                                      new Object[] { Double.valueOf(t) });\n           }\n           return offset;\n         }\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n                         f.getCount(3) + f.getCount(4) + f.getCount(5);\n         long sumFreq = f.getSumFreq();\n         double cumPct = \n-            new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();\n+            Double.valueOf(cumFreq).doubleValue()/Double.valueOf(sumFreq).doubleValue();\n         assertEquals(\"cum Poisson(4)\",cumPct,0.7851,0.2);\n         try {\n             randomData.nextPoisson(-1);\n--- a/src/test/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/org/apache/commons/math/stat/FrequencyTest.java\n         assertEquals(\"zero cumulative frequency\", 0, f.getCumFreq(0));\n         assertEquals(\"one cumulative frequency\", 3,  f.getCumFreq(1));\n         assertEquals(\"two cumulative frequency\", 4,  f.getCumFreq(2));\n-        assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(new Integer(2)));\n+        assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(Integer.valueOf(2)));\n         assertEquals(\"five cumulative frequency\", 4,  f.getCumFreq(5));\n         assertEquals(\"foo cumulative frequency\", 0,  f.getCumFreq(\"foo\"));\n         \n         f = null;\n         Frequency f = new Frequency();\n         f.addValue(1);\n-        f.addValue(new Integer(1));\n-        f.addValue(new Long(1));\n+        f.addValue(Integer.valueOf(1));\n+        f.addValue(Long.valueOf(1));\n         f.addValue(2);\n-        f.addValue(new Integer(-1));\n+        f.addValue(Integer.valueOf(-1));\n         assertEquals(\"1 count\", 3, f.getCount(1));\n-        assertEquals(\"1 count\", 3, f.getCount(new Integer(1)));\n+        assertEquals(\"1 count\", 3, f.getCount(Integer.valueOf(1)));\n         assertEquals(\"0 cum pct\", 0.2, f.getCumPct(0), tolerance);\n-        assertEquals(\"1 pct\", 0.6, f.getPct(new Integer(1)), tolerance);\n+        assertEquals(\"1 pct\", 0.6, f.getPct(Integer.valueOf(1)), tolerance);\n         assertEquals(\"-2 cum pct\", 0, f.getCumPct(-2), tolerance);\n         assertEquals(\"10 cum pct\", 1, f.getCumPct(10), tolerance);   \n         \n         f.addValue(3);\n         f.addValue(threeI);\n         assertEquals(\"one pct\",0.25,f.getPct(1),tolerance);\n-        assertEquals(\"two pct\",0.25,f.getPct(new Long(2)),tolerance);\n+        assertEquals(\"two pct\",0.25,f.getPct(Long.valueOf(2)),tolerance);\n         assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);\n         assertEquals(\"five pct\",0,f.getPct(5),tolerance);\n         assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);\n         assertEquals(\"one cum pct\",0.25,f.getCumPct(1),tolerance);\n-        assertEquals(\"two cum pct\",0.50,f.getCumPct(new Long(2)),tolerance);\n-        assertEquals(\"Integer argument\",0.50,f.getCumPct(new Integer(2)),tolerance);\n+        assertEquals(\"two cum pct\",0.50,f.getCumPct(Long.valueOf(2)),tolerance);\n+        assertEquals(\"Integer argument\",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);\n         assertEquals(\"three cum pct\",1.0,f.getCumPct(threeL),tolerance);\n         assertEquals(\"five cum pct\",1.0,f.getCumPct(5),tolerance);\n         assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n     public void testEmptyTable() {\n         assertEquals(\"freq sum, empty table\", 0, f.getSumFreq());\n         assertEquals(\"count, empty table\", 0, f.getCount(0));\n-        assertEquals(\"count, empty table\",0, f.getCount(new Integer(0)));\n+        assertEquals(\"count, empty table\",0, f.getCount(Integer.valueOf(0)));\n         assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(0));\n         assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(\"x\"));\n         assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(0)));\n-        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(new Integer(0))));\n+        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(Integer.valueOf(0))));\n         assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(0)));\n-        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(new Integer(0))));   \n+        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(Integer.valueOf(0))));   \n     }\n     \n     /**\n     }\n     public void testIntegerValues() {\n         Object obj1 = null;\n-        obj1 = new Integer(1);\n-        Integer int1 = new Integer(1);\n+        obj1 = Integer.valueOf(1);\n+        Integer int1 = Integer.valueOf(1);\n         f.addValue(obj1);\n         f.addValue(int1);\n         f.addValue(2);\n-        f.addValue(new Long(2));\n+        f.addValue(Long.valueOf(2));\n         assertEquals(\"Integer 1 count\", 2, f.getCount(1));\n-        assertEquals(\"Integer 1 count\", 2, f.getCount(new Integer(1)));\n-        assertEquals(\"Integer 1 count\", 2, f.getCount(new Long(1)));\n+        assertEquals(\"Integer 1 count\", 2, f.getCount(Integer.valueOf(1)));\n+        assertEquals(\"Integer 1 count\", 2, f.getCount(Long.valueOf(1)));\n         assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(1), tolerance);\n-        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(new Long(1)), tolerance);\n-        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(new Integer(1)), tolerance);\n+        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);\n+        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);\n         Iterator it = f.valuesIterator();\n         while (it.hasNext()) {\n             assertTrue(it.next() instanceof Long);\n--- a/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n                         // certified value\n                         String name = line.substring(0, n).trim();\n                         String valueString = line.substring(n + 1).trim();\n-                        Double value = new Double(valueString);\n+                        Double value = Double.valueOf(valueString);\n                         certifiedValues.put(name, value);\n                     }\n                 }\n             if (meth.getReturnType().equals(Double.TYPE)) {\n                 return (Double) property;\n             } else if (meth.getReturnType().equals(Long.TYPE)) {\n-                return new Double(((Long) property).doubleValue());\n+                return Double.valueOf(((Long) property).doubleValue());\n             } else {\n                 fail(\"wrong type: \" + meth.getReturnType().getName());\n             }\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n      * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)\n      */\n     public void addValue(double v) {\n-        list.add(new Double(v));\n+        list.add(Double.valueOf(v));\n     }\n     \n     /**\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n         assertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n         assertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n \n-        list.add( new Double(one));\n+        list.add( Double.valueOf(one));\n \n         assertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n         assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n--- a/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n             new ListUnivariateImpl(new ArrayList<Object>(), transformers);\n \n         u.addObject(\"12.5\");\n-        u.addObject(new Integer(12));\n+        u.addObject(Integer.valueOf(12));\n         u.addObject(\"11.8\");\n         u.addObject(\"14.2\");\n         u.addObject(new Foo());\n         u.addObject(\"14.5\");\n-        u.addObject(new Long(21));\n+        u.addObject(Long.valueOf(21));\n         u.addObject(\"8.2\");\n         u.addObject(\"10.3\");\n         u.addObject(\"11.3\");\n-        u.addObject(new Float(14.1));\n+        u.addObject(Float.valueOf(14.1f));\n         u.addObject(\"9.9\");\n         u.addObject(\"12.2\");\n         u.addObject(new Bar());\n         u.addObject(\"12.1\");\n         u.addObject(\"11\");\n-        u.addObject(new Double(19.8));\n+        u.addObject(Double.valueOf(19.8));\n         u.addObject(\"11\");\n         u.addObject(\"10\");\n         u.addObject(\"8.8\");\n--- a/src/test/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n         int emptyHash = u.hashCode();\n         assertTrue(u.equals(u));\n         assertFalse(u.equals(t));\n-        assertFalse(u.equals(new Double(0)));\n+        assertFalse(u.equals(Double.valueOf(0)));\n         t = new MultivariateSummaryStatistics(2, true);\n         assertTrue(t.equals(u));\n         assertTrue(u.equals(t));\n--- a/src/test/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n         StatisticalSummaryValues t = null;\n         assertTrue(\"reflexive\", u.equals(u));\n         assertFalse(\"non-null compared to null\", u.equals(t));\n-        assertFalse(\"wrong type\", u.equals(new Double(0)));\n+        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n         t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n         assertTrue(\"instances with same data should be equal\", t.equals(u));\n         assertEquals(\"hash code\", u.hashCode(), t.hashCode());\n--- a/src/test/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n         int emptyHash = u.hashCode();\n         assertTrue(\"reflexive\", u.equals(u));\n         assertFalse(\"non-null compared to null\", u.equals(t));\n-        assertFalse(\"wrong type\", u.equals(new Double(0)));\n+        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n         t = createSummaryStatistics();\n         assertTrue(\"empty instances should be equal\", t.equals(u));\n         assertTrue(\"empty instances should be equal\", u.equals(t));\n--- a/src/test/org/apache/commons/math/util/DefaultTransformerTest.java\n+++ b/src/test/org/apache/commons/math/util/DefaultTransformerTest.java\n      */\n     public void testTransformDouble() throws Exception {\n         double expected = 1.0;\n-        Double input = new Double(expected);\n+        Double input = Double.valueOf(expected);\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n      */\n     public void testTransformInteger() throws Exception {\n         double expected = 1.0;\n-        Integer input = new Integer(1);\n+        Integer input = Integer.valueOf(1);\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n     }        \n--- a/src/test/org/apache/commons/math/util/TestBean.java\n+++ b/src/test/org/apache/commons/math/util/TestBean.java\n  * @version $Revision$ $Date$\n  */\n public class TestBean {\n-    private Double x = new Double(1.0);\n+    private Double x = Double.valueOf(1.0);\n \n     private String y = \"1.0\";\n ", "timestamp": 1213126372, "metainfo": ""}