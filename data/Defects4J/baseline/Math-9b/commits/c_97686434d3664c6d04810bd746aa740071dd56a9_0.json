{"sha": "97686434d3664c6d04810bd746aa740071dd56a9", "log": "updated optimization main interfaces to handle scalar and vectorial functions and to handle functions with or without explicit derivatives  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.DimensionMismatchException\n     // org.apache.commons.math.optimization.LeastSquaresConverter\n     // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n+    // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer\n     { \"dimension mismatch {0} != {1}\",\n       \"dimensions incompatibles {0} != {1}\" },\n \n       \"le simplex doit contenir au moins un point\" },\n     { \"equals vertices {0} and {1} in simplex configuration\",\n       \"sommets {0} et {1} \\u00e9gaux dans la configuration du simplex\" },\n+\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n+    // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer\n     { \"maximal number of evaluations exceeded ({0})\",\n       \"nombre maximal d''\\u00e9valuations d\\u00e9pass\\u00e9 ({0})\" },\n \n-    // org.apache.commons.math.optimization.general.AbstractEstimator\n+    // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer\n     { \"unable to compute covariances: singular problem\",\n       \"impossible de calculer les covariances : probl\\u00e8me singulier\"},\n     { \"no degrees of freedom ({0} measurements, {1} parameters)\",\n       \"aucun degr\\u00e9 de libert\\u00e9 ({0} mesures, {1} param\\u00e8tres)\" },\n \n-    // org.apache.commons.math.optimization.general.GaussNewtonEstimator\n+    // org.apache.commons.math.optimization.general.GaussNewtonOptimizer\n     { \"unable to solve: singular problem\",\n       \"r\\u00e9solution impossible : probl\\u00e8me singulier\" },\n \n--- a/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.linear.RealMatrix;\n \n-/** This class converts {@link MultiObjectiveFunction vectorial\n- * objective functions} to {@link ObjectiveFunction scalar objective functions}\n+/** This class converts {@link VectorialObjectiveFunction vectorial\n+ * objective functions} to {@link ScalarObjectiveFunction scalar objective functions}\n  * when the goal is to minimize them.\n  * <p>\n  * This class is mostly used when the vectorial objective function represents\n  * This class computes a possibly weighted squared sum of the residuals, which is\n  * a scalar value. The residuals are the difference between the theoretical model\n  * (i.e. the output of the vectorial objective function) and the observations. The\n- * class implements the {@link ObjectiveFunction} interface and can therefore be\n+ * class implements the {@link ScalarObjectiveFunction} interface and can therefore be\n  * minimized by any optimizer supporting scalar objectives functions.This is one way\n  * to perform a least square estimation. There are other ways to do this without using\n  * this converter, as some optimization algorithms directly support vectorial objective\n  * This class support combination of residuals with or without weights and correlations.\n  * </p>\n   *\n- * @see ObjectiveFunction\n- * @see MultiObjectiveFunction\n+ * @see ScalarObjectiveFunction\n+ * @see VectorialObjectiveFunction\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n \n-public class LeastSquaresConverter implements ObjectiveFunction {\n+public class LeastSquaresConverter implements ScalarObjectiveFunction {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 2424320989874772110L;\n+    private static final long serialVersionUID = -4369653306135732243L;\n \n     /** Underlying vectorial function. */\n-    private final MultiObjectiveFunction function;\n+    private final VectorialObjectiveFunction function;\n \n     /** Observations to be compared to objective function to compute residuals. */\n     private final double[] observations;\n      * @param function vectorial residuals function to wrap\n      * @param observations observations to be compared to objective function to compute residuals\n      */\n-    public LeastSquaresConverter (final MultiObjectiveFunction function,\n-                                  final double[] observations) {\n+    public LeastSquaresConverter(final VectorialObjectiveFunction function,\n+                                 final double[] observations) {\n         this.function     = function;\n         this.observations = observations.clone();\n         this.weights      = null;\n      * vector dimensions don't match (objective function dimension is checked only when\n      * the {@link #objective} method is called)\n      */\n-    public LeastSquaresConverter (final MultiObjectiveFunction function,\n-                                  final double[] observations, final double[] weights)\n+    public LeastSquaresConverter(final VectorialObjectiveFunction function,\n+                                 final double[] observations, final double[] weights)\n         throws IllegalArgumentException {\n         if (observations.length != weights.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n      * matrix dimensions don't match (objective function dimension is checked only when\n      * the {@link #objective} method is called)\n      */\n-    public LeastSquaresConverter (final MultiObjectiveFunction function,\n-                                  final double[] observations, final RealMatrix scale)\n+    public LeastSquaresConverter(final VectorialObjectiveFunction function,\n+                                 final double[] observations, final RealMatrix scale)\n         throws IllegalArgumentException {\n         if (observations.length != scale.getColumnDimension()) {\n             throw MathRuntimeException.createIllegalArgumentException(\n--- a/src/java/org/apache/commons/math/optimization/MultiStartOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartOptimizer.java\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /** \n- * Special implementation of the {@link Optimizer} interface adding\n+ * Special implementation of the {@link ScalarOptimizer} interface adding\n  * multi-start features to an existing optimizer.\n  * <p>\n  * This class wraps a classical optimizer to use it several times in\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class MultiStartOptimizer implements Optimizer {\n+public class MultiStartOptimizer implements ScalarOptimizer {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 6648351778723282863L;\n \n     /** Underlying classical optimizer. */\n-    private final Optimizer optimizer;\n+    private final ScalarOptimizer optimizer;\n \n     /** Number of evaluations already performed for all starts. */\n     private int totalEvaluations;\n     private RandomVectorGenerator generator;\n \n     /** Found optima. */\n-    private PointValuePair[] optima;\n+    private ScalarPointValuePair[] optima;\n \n     /**\n      * Create a multi-start optimizer from a single-start optimizer\n      * equal to 1\n      * @param generator random vector generator to use for restarts\n      */\n-    public MultiStartOptimizer(final Optimizer optimizer, final int starts,\n+    public MultiStartOptimizer(final ScalarOptimizer optimizer, final int starts,\n                                final RandomVectorGenerator generator) {\n         this.optimizer        = optimizer;\n         this.totalEvaluations = 0;\n     }\n \n     /** Get all the optima found during the last call to {@link\n-     * #optimize(ObjectiveFunction, GoalType, double[]) optimize}.\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}.\n      * <p>The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(ObjectiveFunction, GoalType,\n+     * restarts. The {@link #optimize(ScalarObjectiveFunction, GoalType,\n      * double[]) optimize} method returns the best point only. This\n      * method returns all the points found at the end of each starts,\n      * including the best one already returned by the {@link\n-     * #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n      * method.\n      * </p>\n      * <p>\n      * objective value (i.e in ascending order if minimizing and in\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(ObjectiveFunction,\n+     * elements will be null if the {@link #optimize(ScalarObjectiveFunction,\n      * GoalType, double[]) optimize} method did throw a {@link\n      * ConvergenceException ConvergenceException}). This also means that\n      * if the first element is non null, it is the best point found across\n      * all starts.</p>\n      * @return array containing the optima\n-     * @exception IllegalStateException if {@link #optimize(ObjectiveFunction,\n+     * @exception IllegalStateException if {@link #optimize(ScalarObjectiveFunction,\n      * GoalType, double[]) optimize} has not been called\n      */\n-    public PointValuePair[] getOptima() throws IllegalStateException {\n+    public ScalarPointValuePair[] getOptima() throws IllegalStateException {\n         if (optima == null) {\n             throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n         }\n-        return (PointValuePair[]) optima.clone();\n+        return (ScalarPointValuePair[]) optima.clone();\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(ConvergenceChecker checker) {\n+    public void setConvergenceChecker(ScalarConvergenceChecker checker) {\n         optimizer.setConvergenceChecker(checker);\n     }\n \n     /** {@inheritDoc} */\n-    public ConvergenceChecker getConvergenceChecker() {\n+    public ScalarConvergenceChecker getConvergenceChecker() {\n         return optimizer.getConvergenceChecker();\n     }\n \n     /** {@inheritDoc} */\n-    public PointValuePair optimize(final ObjectiveFunction f,\n+    public ScalarPointValuePair optimize(final ScalarObjectiveFunction f,\n                                    final GoalType goalType,\n                                    double[] startPoint)\n         throws ObjectiveException, OptimizationException {\n \n-        optima = new PointValuePair[starts];\n+        optima = new ScalarPointValuePair[starts];\n         totalEvaluations = 0;\n \n         // multi-start loop\n         }\n \n         // sort the optima from best to worst, followed by null elements\n-        Arrays.sort(optima, new Comparator<PointValuePair>() {\n-            public int compare(final PointValuePair o1, final PointValuePair o2) {\n+        Arrays.sort(optima, new Comparator<ScalarPointValuePair>() {\n+            public int compare(final ScalarPointValuePair o1, final ScalarPointValuePair o2) {\n                 if (o1 == null) {\n                     return (o2 == null) ? 0 : +1;\n                 } else if (o2 == null) {\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ScalarConvergenceChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** This interface specifies how to check if an {@link ScalarOptimizer optimization\n+ * algorithm} has converged.\n+ *\n+ * <p>Deciding if convergence has been reached is a problem-dependent\n+ * issue. The user should provide a class implementing this interface\n+ * to allow the optimization algorithm to stop its search according to\n+ * the problem at hand.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public interface ScalarConvergenceChecker extends Serializable {\n+\n+  /** Check if the optimization algorithm has converged considering the last points.\n+   * <p>\n+   * This method may be called several time from the same algorithm iteration with\n+   * different points. This can be detected by checking the iteration number at each\n+   * call if needed. Each time this method is called, the previous and current point\n+   * correspond to points with the same role at each iteration, so they can be\n+   * compared. As an example, simplex-based algorithms call this method for all\n+   * points of the simplex, not only for the best or worst ones.\n+   * </p>\n+   * @param iteration index of current iteration\n+   * @param previous point from previous iteration\n+   * @param current point from current iteration\n+   * @return true if the algorithm is considered to have converged\n+   */\n+  boolean converged(int iteration, ScalarPointValuePair previous, ScalarPointValuePair current);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ScalarDifferentiableObjectiveFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+/** \n+ * This interface represents a scalar objective function that can be differentiated.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ScalarDifferentiableObjectiveFunction extends ScalarObjectiveFunction {\n+\n+    /** \n+     * Compute the partial derivatives of the objective function.\n+     * @param variables variables set\n+     * @return partial derivatives of the objective function\n+     * @exception ObjectiveException if no value can be computed for the parameters\n+     * @exception IllegalArgumentException if variables dimension is wrong\n+     */\n+    double[] partials(double[] variables)\n+        throws ObjectiveException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ScalarDifferentiableOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link ScalarDifferentiableObjectiveFunction\n+ * scalar differentiable objective functions}.\n+ * @see ScalarOptimizer\n+ * @see VectorialDifferentiableOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ScalarDifferentiableOptimizer extends Serializable {\n+\n+    /** Set the maximal number of objective function calls.\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+     * @param maxEvaluations maximal number of function calls\n+     * .\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of objective function calls.\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+      * @return maximal number of function calls\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+   int getEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(ScalarConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    ScalarConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * @param f objective function\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception ObjectiveException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    ScalarPointValuePair optimize(ScalarDifferentiableObjectiveFunction f,\n+                                  GoalType goalType,\n+                                  double[] startPoint)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ScalarObjectiveFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This interface represents a scalar objective function to be either minimized or maximized.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ScalarObjectiveFunction extends Serializable {\n+\n+    /** \n+     * Compute the function value for the given variables set.\n+     * @param variables variables set\n+     * @return function value for the given variables set\n+     * @exception ObjectiveException if no value can be computed for the parameters\n+     * @exception IllegalArgumentException if variables dimension is wrong\n+     */\n+    double objective(double[] variables)\n+        throws ObjectiveException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ScalarOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link ScalarObjectiveFunction\n+ * scalar objective functions}.\n+ * @see ScalarDifferentiableOptimizer\n+ * @see VectorialDifferentiableOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ScalarOptimizer extends Serializable {\n+\n+    /** Set the maximal number of objective function calls.\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+     * @param maxEvaluations maximal number of function calls\n+     * .\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of objective function calls.\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+      * @return maximal number of function calls\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+   int getEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(ScalarConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    ScalarConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * @param f objective function\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception ObjectiveException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    ScalarPointValuePair optimize(ScalarObjectiveFunction f,\n+                                  GoalType goalType,\n+                                  double[] startPoint)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ScalarPointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This class holds a point and the value of an objective function at this point.\n+ * <p>This is a simple immutable container.</p>\n+ * @see VectorialPointValuePair\n+ * @see ScalarObjectiveFunction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ScalarPointValuePair implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1003888396256744753L;\n+\n+    /** Point coordinates. */\n+    private final double[] point;\n+\n+    /** Value of the objective function at the point. */\n+    private final double value;\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     */\n+    public ScalarPointValuePair(final double[] point, final double value) {\n+        this.point = point.clone();\n+        this.value  = value;\n+    }\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     */\n+    public ScalarPointValuePair(final double[] point, final double value,\n+                          final boolean copyArray) {\n+        this.point = copyArray ? point.clone() : point;\n+        this.value  = value;\n+    }\n+\n+    /** Get the point.\n+     * @return a copy of the stored point\n+     */\n+    public double[] getPoint() {\n+        return point.clone();\n+    }\n+\n+    /** Get a reference to the point.\n+     * <p>This method is provided as a convenience to avoid copying\n+     * the array, the elements of the array should <em>not</em> be modified.</p>\n+     * @return a reference to the internal array storing the point\n+     */\n+    public double[] getPointRef() {\n+        return point;\n+    }\n+\n+    /** Get the value of the objective function.\n+     * @return the stored value of the objective function\n+     */\n+    public double getValue() {\n+        return value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/SimpleValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link ScalarConvergenceChecker} interface using\n+ * only objective function values.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimpleValueChecker implements ScalarConvergenceChecker {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 2490271385513842607L;\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleValueChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleValueChecker(final double relativeThreshold,\n+                                 final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final ScalarPointValuePair previous,\n+                             final ScalarPointValuePair current) {\n+        final double p          = previous.getValue();\n+        final double c          = current.getValue();\n+        final double difference = Math.abs(p - c);\n+        final double size       = Math.max(Math.abs(p), Math.abs(c));\n+        return (difference <= (size * relativeThreshold)) || (difference <= absoluteThreshold);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n+ * only objective function values.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold for all vectors elements.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimpleVectorialValueChecker implements VectorialConvergenceChecker {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3892196630780700808L;\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleVectorialValueChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleVectorialValueChecker(final double relativeThreshold,\n+                                       final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final VectorialPointValuePair previous,\n+                             final VectorialPointValuePair current) {\n+        final double[] p        = previous.getValueRef();\n+        final double[] c        = current.getValueRef();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double pi         = p[i];\n+            final double ci         = c[i];\n+            final double difference = Math.abs(pi - ci);\n+            final double size       = Math.max(Math.abs(pi), Math.abs(ci));\n+            if ((difference > (size * relativeThreshold)) &&\n+                (difference > absoluteThreshold)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** This interface specifies how to check if an {@link VectorialOptimizer optimization\n+ * algorithm} has converged.\n+ *\n+ * <p>Deciding if convergence has been reached is a problem-dependent\n+ * issue. The user should provide a class implementing this interface\n+ * to allow the optimization algorithm to stop its search according to\n+ * the problem at hand.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public interface VectorialConvergenceChecker extends Serializable {\n+\n+  /** Check if the optimization algorithm has converged considering the last points.\n+   * <p>\n+   * This method may be called several time from the same algorithm iteration with\n+   * different points. This can be detected by checking the iteration number at each\n+   * call if needed. Each time this method is called, the previous and current point\n+   * correspond to points with the same role at each iteration, so they can be\n+   * compared. As an example, simplex-based algorithms call this method for all\n+   * points of the simplex, not only for the best or worst ones.\n+   * </p>\n+   * @param iteration index of current iteration\n+   * @param previous point from previous iteration\n+   * @param current point from current iteration\n+   * @return true if the algorithm is considered to have converged\n+   */\n+  boolean converged(int iteration, VectorialPointValuePair previous, VectorialPointValuePair current);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/VectorialDifferentiableObjectiveFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+/** \n+ * This interface represents a vectorial objective function that can be differentiated.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface VectorialDifferentiableObjectiveFunction extends VectorialObjectiveFunction {\n+\n+    /** \n+     * Compute the jacobian of the objective function.\n+     * @param variables variables set\n+     * @param value value of the objective function (already computed)\n+     * @return jacobian of the objective function\n+     * @exception ObjectiveException if no cost can be computed for the parameters\n+     * @exception IllegalArgumentException if variables dimension is wrong\n+     */\n+    double[][] jacobian(double[] variables, double[] value)\n+        throws ObjectiveException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/VectorialDifferentiableOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link VectorialDifferentiableObjectiveFunction\n+ * vectorial differentiable objective functions}.\n+ * @see ScalarOptimizer\n+ * @see ScalarDifferentiableOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface VectorialDifferentiableOptimizer extends Serializable {\n+\n+    /** Set the maximal number of objective function calls.\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+     * @param maxEvaluations maximal number of function calls\n+     * .\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of objective function calls.\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+      * @return maximal number of function calls\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+   int getEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(VectorialConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    VectorialConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * <p>\n+     * Optimization is considered to be a weighted least-squares minimization.\n+     * The cost function to be minimized is\n+     * &sum;weight<sub>i</sub>(objective<sub>i</sub>-target<sub>i</sub>)<sup>2</sup>\n+     * </p>\n+     * @param f objective function\n+     * @param target target value for the objective functions at optimum\n+     * @param weights weight for the least squares cost computation\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception ObjectiveException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    VectorialPointValuePair optimize(VectorialDifferentiableObjectiveFunction f,\n+                                     double[] target, double[] weights,\n+                                     double[] startPoint)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/VectorialObjectiveFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This interface represents a vectorial objective function to be either minimized or maximized.\n+ * @see LeastSquaresConverter\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface VectorialObjectiveFunction extends Serializable {\n+\n+    /** \n+     * Compute the function value for the given variables set.\n+     * @param variables variables set\n+     * @return function value for the given variables set\n+     * @exception ObjectiveException if no cost can be computed for the parameters\n+     * @exception IllegalArgumentException if variables dimension is wrong\n+     */\n+    double[] objective(double[] variables)\n+        throws ObjectiveException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This class holds a point and the vectorial value of an objective function at this point.\n+ * <p>This is a simple immutable container.</p>\n+ * @see ScalarPointValuePair\n+ * @see VectorialObjectiveFunction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class VectorialPointValuePair implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1003888396256744753L;\n+\n+    /** Point coordinates. */\n+    private final double[] point;\n+\n+    /** Vectorial value of the objective function at the point. */\n+    private final double[] value;\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     */\n+    public VectorialPointValuePair(final double[] point, final double[] value) {\n+        this.point = point.clone();\n+        this.value = value.clone();\n+    }\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     * @param copyArray if true, the input arrays will be copied, otherwise\n+     * they will be referenced\n+     */\n+    public VectorialPointValuePair(final double[] point, final double[] value,\n+                                   final boolean copyArray) {\n+        this.point = copyArray ? point.clone() : point;\n+        this.value = copyArray ? value.clone() : value;\n+    }\n+\n+    /** Get the point.\n+     * @return a copy of the stored point\n+     */\n+    public double[] getPoint() {\n+        return point.clone();\n+    }\n+\n+    /** Get a reference to the point.\n+     * <p>This method is provided as a convenience to avoid copying\n+     * the array, the elements of the array should <em>not</em> be modified.</p>\n+     * @return a reference to the internal array storing the point\n+     */\n+    public double[] getPointRef() {\n+        return point;\n+    }\n+\n+    /** Get the value of the objective function.\n+     * @return a copy of the stored value of the objective function\n+     */\n+    public double[] getValue() {\n+        return value.clone();\n+    }\n+\n+    /** Get a reference to the value of the objective function.\n+     * <p>This method is provided as a convenience to avoid copying\n+     * the array, the elements of the array should <em>not</em> be modified.</p>\n+     * @return a reference to the internal array storing the value of the objective function\n+     */\n+    public double[] getValueRef() {\n+        return value;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n import java.util.Comparator;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.ScalarConvergenceChecker;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ObjectiveException;\n-import org.apache.commons.math.optimization.ObjectiveFunction;\n+import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.Optimizer;\n-import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.ObjectiveValueChecker;\n+import org.apache.commons.math.optimization.ScalarOptimizer;\n+import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n \n /** \n  * This class implements simplex-based direct search optimization\n  * before optimization is attempted, an explicit call to the first method\n  * with all steps set to +1 is triggered, thus building a default\n  * configuration from a unit hypercube. Each call to {@link\n- * #optimize(ObjectiveFunction, GoalType, double[]) optimize} will reuse\n+ * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize} will reuse\n  * the current start configuration and move it such that its first vertex\n  * is at the provided start point of the optimization. If the same optimizer\n  * is used to solve different problems and the number of parameters change,\n  * the start configuration <em>must</em> be reset or a dimension mismatch\n  * will occur.</p>\n  *\n- * <p>If {@link #setConvergenceChecker(ConvergenceChecker)} is not called,\n- * a default {@link ObjectiveValueChecker} is used.</p>\n+ * <p>If {@link #setConvergenceChecker(ScalarConvergenceChecker)} is not called,\n+ * a default {@link SimpleValueChecker} is used.</p>\n  *\n  * <p>Convergence is checked by providing the <em>worst</em> points of\n  * previous and current simplex to the convergence checker, not the best ones.</p>\n  * performed by the derived classes according to the implemented\n  * algorithms.</p>\n  *\n- * @see ObjectiveFunction\n+ * @see ScalarObjectiveFunction\n  * @see NelderMead\n  * @see MultiDirectional\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public abstract class DirectSearchOptimizer implements Optimizer {\n+public abstract class DirectSearchOptimizer implements ScalarOptimizer {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 4299910390345933369L;\n \n     /** Simplex. */\n-    protected PointValuePair[] simplex;\n+    protected ScalarPointValuePair[] simplex;\n \n     /** Objective function. */\n-    private ObjectiveFunction f;\n+    private ScalarObjectiveFunction f;\n \n     /** Convergence checker. */\n-    private ConvergenceChecker checker;\n+    private ScalarConvergenceChecker checker;\n \n     /** Number of evaluations already performed for the current start. */\n     private int evaluations;\n     /** Simple constructor.\n      */\n     protected DirectSearchOptimizer() {\n-        setConvergenceChecker(new ObjectiveValueChecker());\n+        setConvergenceChecker(new SimpleValueChecker());\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** Set start configuration for simplex.\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(ConvergenceChecker checker) {\n+    public void setConvergenceChecker(ScalarConvergenceChecker checker) {\n         this.checker = checker;\n     }\n \n     /** {@inheritDoc} */\n-    public ConvergenceChecker getConvergenceChecker() {\n+    public ScalarConvergenceChecker getConvergenceChecker() {\n         return checker;\n     }\n \n     /** {@inheritDoc} */\n-    public PointValuePair optimize(final ObjectiveFunction f, final GoalType goalType,\n+    public ScalarPointValuePair optimize(final ScalarObjectiveFunction f, final GoalType goalType,\n                                    final double[] startPoint)\n         throws ObjectiveException, OptimizationException, IllegalArgumentException {\n \n         }\n \n         this.f = f;\n-        final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n-            public int compare(final PointValuePair o1, final PointValuePair o2) {\n+        final Comparator<ScalarPointValuePair> comparator = new Comparator<ScalarPointValuePair>() {\n+            public int compare(final ScalarPointValuePair o1, final ScalarPointValuePair o2) {\n                 final double v1 = o1.getValue();\n                 final double v2 = o2.getValue();\n                 return (goalType == GoalType.MINIMIZE) ?\n         buildSimplex(startPoint);\n         evaluateSimplex(comparator);\n \n-        PointValuePair[] previous = new PointValuePair[simplex.length];\n+        ScalarPointValuePair[] previous = new ScalarPointValuePair[simplex.length];\n         int iterations = 0;\n         while (evaluations <= maxEvaluations) {\n \n      * @exception OptimizationException if the algorithm failed to converge\n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n-    protected abstract void iterateSimplex(final Comparator<PointValuePair> comparator)\n+    protected abstract void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n         throws ObjectiveException, OptimizationException, IllegalArgumentException;\n \n     /** Evaluate the objective function on one point.\n         }\n \n         // set first vertex\n-        simplex = new PointValuePair[n + 1];\n-        simplex[0] = new PointValuePair(startPoint, Double.NaN);\n+        simplex = new ScalarPointValuePair[n + 1];\n+        simplex[0] = new ScalarPointValuePair(startPoint, Double.NaN);\n \n         // set remaining vertices\n         for (int i = 0; i < n; ++i) {\n             for (int k = 0; k < n; ++k) {\n                 vertexI[k] = startPoint[k] + confI[k];\n             }\n-            simplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n+            simplex[i + 1] = new ScalarPointValuePair(vertexI, Double.NaN);\n         }\n \n     }\n      * @param comparator comparator to use to sort simplex vertices from best to worst\n      * @exception ObjectiveException if no value can be computed for the parameters\n      */\n-    protected void evaluateSimplex(final Comparator<PointValuePair> comparator)\n+    protected void evaluateSimplex(final Comparator<ScalarPointValuePair> comparator)\n         throws ObjectiveException {\n \n         // evaluate the objective function at all non-evaluated simplex points\n         for (int i = 0; i < simplex.length; ++i) {\n-            final PointValuePair vertex = simplex[i];\n-            final double[] point = vertex.getPoint();\n+            final ScalarPointValuePair vertex = simplex[i];\n+            final double[] point = vertex.getPointRef();\n             if (Double.isNaN(vertex.getValue())) {\n-                simplex[i] = new PointValuePair(point, evaluate(point));\n+                simplex[i] = new ScalarPointValuePair(point, evaluate(point), false);\n             }\n         }\n \n      * @param pointValuePair point to insert\n      * @param comparator comparator to use to sort simplex vertices from best to worst\n      */\n-    protected void replaceWorstPoint(PointValuePair pointValuePair,\n-                                     final Comparator<PointValuePair> comparator) {\n+    protected void replaceWorstPoint(ScalarPointValuePair pointValuePair,\n+                                     final Comparator<ScalarPointValuePair> comparator) {\n         int n = simplex.length - 1;\n         for (int i = 0; i < n; ++i) {\n             if (comparator.compare(simplex[i], pointValuePair) > 0) {\n-                PointValuePair tmp = simplex[i];\n+                ScalarPointValuePair tmp = simplex[i];\n                 simplex[i]         = pointValuePair;\n                 pointValuePair     = tmp;\n             }\n--- a/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n \n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.PointValuePair;\n+import org.apache.commons.math.optimization.ScalarPointValuePair;\n \n /** \n  * This class implements the multi-directional direct search method.\n     }\n \n     /** {@inheritDoc} */\n-    protected void iterateSimplex(final Comparator<PointValuePair> comparator)\n+    protected void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n         throws ObjectiveException, OptimizationException, IllegalArgumentException {\n \n         final int max = getMaxEvaluations();\n         while (getEvaluations() < max) {\n \n             // save the original vertex\n-            final PointValuePair[] original = simplex;\n-            final PointValuePair best = original[0];\n+            final ScalarPointValuePair[] original = simplex;\n+            final ScalarPointValuePair best = original[0];\n \n             // perform a reflection step\n-            final PointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n+            final ScalarPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n             if (comparator.compare(reflected, best) < 0) {\n \n                 // compute the expanded simplex\n-                final PointValuePair[] reflectedSimplex = simplex;\n-                final PointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n+                final ScalarPointValuePair[] reflectedSimplex = simplex;\n+                final ScalarPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                 if (comparator.compare(reflected, expanded) <= 0) {\n                     // accept the reflected simplex\n                     simplex = reflectedSimplex;\n             }\n \n             // compute the contracted simplex\n-            final PointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+            final ScalarPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n                 return;\n      * @exception ObjectiveException if the function cannot be evaluated at\n      * some point\n      */\n-    private PointValuePair evaluateNewSimplex(final PointValuePair[] original,\n+    private ScalarPointValuePair evaluateNewSimplex(final ScalarPointValuePair[] original,\n                                               final double coeff,\n-                                              final Comparator<PointValuePair> comparator)\n+                                              final Comparator<ScalarPointValuePair> comparator)\n         throws ObjectiveException {\n \n-        final double[] xSmallest = original[0].getPoint();\n+        final double[] xSmallest = original[0].getPointRef();\n         final int n = xSmallest.length;\n \n         // create the linearly transformed simplex\n-        simplex = new PointValuePair[n + 1];\n+        simplex = new ScalarPointValuePair[n + 1];\n         simplex[0] = original[0];\n         for (int i = 1; i <= n; ++i) {\n-            final double[] xOriginal    = original[i].getPoint();\n+            final double[] xOriginal    = original[i].getPointRef();\n             final double[] xTransformed = new double[n];\n             for (int j = 0; j < n; ++j) {\n                 xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n             }\n-            simplex[i] = new PointValuePair(xTransformed, Double.NaN);\n+            simplex[i] = new ScalarPointValuePair(xTransformed, Double.NaN, false);\n         }\n \n         // evaluate it\n--- a/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n import java.util.Comparator;\n \n import org.apache.commons.math.optimization.ObjectiveException;\n-import org.apache.commons.math.optimization.PointValuePair;\n+import org.apache.commons.math.optimization.ScalarPointValuePair;\n \n /** \n  * This class implements the Nelder-Mead direct search method.\n     }\n \n     /** {@inheritDoc} */\n-    protected void iterateSimplex(final Comparator<PointValuePair> comparator)\n+    protected void iterateSimplex(final Comparator<ScalarPointValuePair> comparator)\n         throws ObjectiveException {\n \n         // the simplex has n+1 point if dimension is n\n         final int n = simplex.length - 1;\n \n         // interesting values\n-        final PointValuePair best       = simplex[0];\n-        final PointValuePair secondBest = simplex[n-1];\n-        final PointValuePair worst      = simplex[n];\n-        final double[] xWorst = worst.getPoint();\n+        final ScalarPointValuePair best       = simplex[0];\n+        final ScalarPointValuePair secondBest = simplex[n-1];\n+        final ScalarPointValuePair worst      = simplex[n];\n+        final double[] xWorst = worst.getPointRef();\n \n         // compute the centroid of the best vertices\n         // (dismissing the worst point at index n)\n         final double[] centroid = new double[n];\n         for (int i = 0; i < n; ++i) {\n-            final double[] x = simplex[i].getPoint();\n+            final double[] x = simplex[i].getPointRef();\n             for (int j = 0; j < n; ++j) {\n                 centroid[j] += x[j];\n             }\n         for (int j = 0; j < n; ++j) {\n             xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n         }\n-        final PointValuePair reflected = new PointValuePair(xR, evaluate(xR));\n+        final ScalarPointValuePair reflected = new ScalarPointValuePair(xR, evaluate(xR), false);\n \n         if ((comparator.compare(best, reflected) <= 0) &&\n             (comparator.compare(reflected, secondBest) < 0)) {\n             for (int j = 0; j < n; ++j) {\n                 xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n             }\n-            final PointValuePair expanded = new PointValuePair(xE, evaluate(xE));\n+            final ScalarPointValuePair expanded = new ScalarPointValuePair(xE, evaluate(xE), false);\n \n             if (comparator.compare(expanded, reflected) < 0) {\n                 // accept the expansion point\n                 for (int j = 0; j < n; ++j) {\n                     xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n                 }\n-                final PointValuePair outContracted = new PointValuePair(xC, evaluate(xC));\n+                final ScalarPointValuePair outContracted = new ScalarPointValuePair(xC, evaluate(xC), false);\n \n                 if (comparator.compare(outContracted, reflected) <= 0) {\n                     // accept the contraction point\n                 for (int j = 0; j < n; ++j) {\n                     xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n                 }\n-                final PointValuePair inContracted = new PointValuePair(xC, evaluate(xC));\n+                final ScalarPointValuePair inContracted = new ScalarPointValuePair(xC, evaluate(xC), false);\n \n                 if (comparator.compare(inContracted, worst) < 0) {\n                     // accept the contraction point\n             }\n \n             // perform a shrink\n-            final double[] xSmallest = simplex[0].getPoint();\n+            final double[] xSmallest = simplex[0].getPointRef();\n             for (int i = 1; i < simplex.length; ++i) {\n                 final double[] x = simplex[i].getPoint();\n                 for (int j = 0; j < n; ++j) {\n                     x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n                 }\n-                simplex[i] = new PointValuePair(x, Double.NaN);\n+                simplex[i] = new ScalarPointValuePair(x, Double.NaN, false);\n             }\n             evaluateSimplex(comparator);\n \n--- a/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n import org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ObjectiveException;\n-import org.apache.commons.math.optimization.ObjectiveFunction;\n-import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.ObjectiveValueChecker;\n+import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n+import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n \n public class MultiDirectionalTest\n   extends TestCase {\n   }\n \n   public void testObjectiveExceptions() throws ConvergenceException {\n-      ObjectiveFunction wrong =\n-          new ObjectiveFunction() {\n+      ScalarObjectiveFunction wrong =\n+          new ScalarObjectiveFunction() {\n             private static final long serialVersionUID = 4751314470965489371L;\n             public double objective(double[] x) throws ObjectiveException {\n                 if (x[0] < 0) {\n       final double valueXmYp = -valueXmYm;                // local  minimum\n       final double valueXpYm = -0.7290400707055187115322; // global minimum\n       final double valueXpYp = -valueXpYm;                // global maximum\n-      ObjectiveFunction fourExtrema = new ObjectiveFunction() {\n+      ScalarObjectiveFunction fourExtrema = new ScalarObjectiveFunction() {\n           private static final long serialVersionUID = -7039124064449091152L;\n           public double objective(double[] variables) {\n               final double x = variables[0];\n       };\n \n       MultiDirectional optimizer = new MultiDirectional();\n-      optimizer.setConvergenceChecker(new ObjectiveValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setConvergenceChecker(new SimpleValueChecker(1.0e-10, 1.0e-30));\n       optimizer.setMaxEvaluations(200);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n-      PointValuePair optimum;\n+      ScalarPointValuePair optimum;\n \n       // minimization\n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n   public void testRosenbrock()\n     throws ObjectiveException, ConvergenceException {\n \n-    ObjectiveFunction rosenbrock =\n-      new ObjectiveFunction() {\n+    ScalarObjectiveFunction rosenbrock =\n+      new ScalarObjectiveFunction() {\n         private static final long serialVersionUID = -9044950469615237490L;\n         public double objective(double[] x) {\n           ++count;\n \n     count = 0;\n     MultiDirectional optimizer = new MultiDirectional();\n-    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1, 1.0e-3));\n+    optimizer.setConvergenceChecker(new SimpleValueChecker(-1, 1.0e-3));\n     optimizer.setMaxEvaluations(100);\n     optimizer.setStartConfiguration(new double[][] {\n             { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n     });\n-    PointValuePair optimum =\n+    ScalarPointValuePair optimum =\n         optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n     assertEquals(count, optimizer.getEvaluations());\n   public void testPowell()\n     throws ObjectiveException, ConvergenceException {\n \n-    ObjectiveFunction powell =\n-      new ObjectiveFunction() {\n+    ScalarObjectiveFunction powell =\n+      new ScalarObjectiveFunction() {\n         private static final long serialVersionUID = -832162886102041840L;\n         public double objective(double[] x) {\n           ++count;\n \n     count = 0;\n     MultiDirectional optimizer = new MultiDirectional();\n-    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1.0, 1.0e-3));\n+    optimizer.setConvergenceChecker(new SimpleValueChecker(-1.0, 1.0e-3));\n     optimizer.setMaxEvaluations(1000);\n-    PointValuePair optimum =\n+    ScalarPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n     assertEquals(count, optimizer.getEvaluations());\n     assertTrue(optimizer.getEvaluations() > 800);\n--- a/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n import org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ObjectiveException;\n-import org.apache.commons.math.optimization.ObjectiveFunction;\n-import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.ObjectiveValueChecker;\n+import org.apache.commons.math.optimization.ScalarObjectiveFunction;\n+import org.apache.commons.math.optimization.ScalarPointValuePair;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n \n public class NelderMeadTest\n   extends TestCase {\n   }\n \n   public void testObjectiveExceptions() throws ConvergenceException {\n-      ObjectiveFunction wrong =\n-          new ObjectiveFunction() {\n+      ScalarObjectiveFunction wrong =\n+          new ScalarObjectiveFunction() {\n             private static final long serialVersionUID = 4751314470965489371L;\n             public double objective(double[] x) throws ObjectiveException {\n                 if (x[0] < 0) {\n       final double valueXmYp = -valueXmYm;                // local  minimum\n       final double valueXpYm = -0.7290400707055187115322; // global minimum\n       final double valueXpYp = -valueXpYm;                // global maximum\n-      ObjectiveFunction fourExtrema = new ObjectiveFunction() {\n+      ScalarObjectiveFunction fourExtrema = new ScalarObjectiveFunction() {\n           private static final long serialVersionUID = -7039124064449091152L;\n           public double objective(double[] variables) {\n               final double x = variables[0];\n       };\n \n       NelderMead optimizer = new NelderMead();\n-      optimizer.setConvergenceChecker(new ObjectiveValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setConvergenceChecker(new SimpleValueChecker(1.0e-10, 1.0e-30));\n       optimizer.setMaxEvaluations(100);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n-      PointValuePair optimum;\n+      ScalarPointValuePair optimum;\n \n       // minimization\n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n   public void testRosenbrock()\n     throws ObjectiveException, ConvergenceException {\n \n-    ObjectiveFunction rosenbrock =\n-      new ObjectiveFunction() {\n+    ScalarObjectiveFunction rosenbrock =\n+      new ScalarObjectiveFunction() {\n         private static final long serialVersionUID = -9044950469615237490L;\n         public double objective(double[] x) {\n           ++count;\n \n     count = 0;\n     NelderMead optimizer = new NelderMead();\n-    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1, 1.0e-3));\n+    optimizer.setConvergenceChecker(new SimpleValueChecker(-1, 1.0e-3));\n     optimizer.setMaxEvaluations(100);\n     optimizer.setStartConfiguration(new double[][] {\n             { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n     });\n-    PointValuePair optimum =\n+    ScalarPointValuePair optimum =\n         optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n     assertEquals(count, optimizer.getEvaluations());\n   public void testPowell()\n     throws ObjectiveException, ConvergenceException {\n \n-    ObjectiveFunction powell =\n-      new ObjectiveFunction() {\n+    ScalarObjectiveFunction powell =\n+      new ScalarObjectiveFunction() {\n         private static final long serialVersionUID = -832162886102041840L;\n         public double objective(double[] x) {\n           ++count;\n \n     count = 0;\n     NelderMead optimizer = new NelderMead();\n-    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1.0, 1.0e-3));\n+    optimizer.setConvergenceChecker(new SimpleValueChecker(-1.0, 1.0e-3));\n     optimizer.setMaxEvaluations(200);\n-    PointValuePair optimum =\n+    ScalarPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n     assertEquals(count, optimizer.getEvaluations());\n     assertTrue(optimizer.getEvaluations() > 110);", "timestamp": 1237052149, "metainfo": ""}