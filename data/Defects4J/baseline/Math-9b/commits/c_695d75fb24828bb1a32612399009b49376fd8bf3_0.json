{"sha": "695d75fb24828bb1a32612399009b49376fd8bf3", "log": "[MATH-777] Added CycleCrossover policy.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/genetics/CycleCrossover.java\n+package org.apache.commons.math3.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+\n+/**\n+ * Cycle Crossover [CX] builds offspring from <b>ordered</b> chromosomes by identifying cycles\n+ * between two parent chromosomes. To form the children, the cycles are copied from the\n+ * respective parents.\n+ * <p>\n+ * To form a cycle the following procedure is applied:\n+ * <ol>\n+ *   <li>start with the first gene of parent 1</li>\n+ *   <li>look at the gene at the same position of parent 2</li>\n+ *   <li>go to the position with the same gene in parent 1</li>\n+ *   <li>add this gene index to the cycle</li>\n+ *   <li>repeat the steps 2-5 until we arrive at the starting gene of this cycle</li>\n+ * </ol>\n+ * The indices that form a cycle are then used to form the children in alternating order, i.e.\n+ * in cycle 1, the genes of parent 1 are copied to child 1, while in cycle 2 the genes of parent 1\n+ * are copied to child 2, and so forth ...\n+ * </p>\n+ *\n+ * Example (zero-start cycle):\n+ * <pre>\n+ * p1 = (8 4 7 3 6 2 5 1 9 0)    X   c1 = (8 1 2 3 4 5 6 7 9 0)\n+ * p2 = (0 1 2 3 4 5 6 7 8 9)    X   c2 = (0 4 7 3 6 2 5 1 8 9)\n+ *\n+ * cycle 1: 8 0 9\n+ * cycle 2: 4 1 7 2 5 6\n+ * cycle 3: 3\n+ * </pre>\n+ *\n+ * This policy works only on {@link AbstractListChromosome}, and therefore it\n+ * is parameterized by T. Moreover, the chromosomes must have same lengths.\n+ *\n+ * @see <a href=\"http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx\"\n+ * Cycle Crossover Operator</a>\n+ *\n+ * @param <T> generic type of the {@link AbstractListChromosome}s for crossover\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class CycleCrossover<T> implements CrossoverPolicy {\n+\n+    /** If the start index shall be chosen randomly. */\n+    private final boolean randomStart;\n+\n+    /**\n+     * Creates a new {@link CycleCrossover} policy.\n+     */\n+    public CycleCrossover() {\n+        this(false);\n+    }\n+\n+    /**\n+     * Creates a new {@link CycleCrossover} policy using the given {@code randomStart} behavior.\n+     *\n+     * @param randomStart whether the start index shall be chosen randomly or be set to 0\n+     */\n+    public CycleCrossover(final boolean randomStart) {\n+        this.randomStart = randomStart;\n+    }\n+\n+    /**\n+     * Returns whether the starting index is chosen randomly or set to zero.\n+     *\n+     * @return {@code true} if the starting index is chosen randomly, {@code false} otherwise\n+     */\n+    public boolean isRandomStart() {\n+        return randomStart;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+        if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n+        }\n+        return mate((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n+    }\n+\n+    /**\n+     * Helper for {@link #crossover(Chromosome, Chromosome)}. Performs the actual crossover.\n+     *\n+     * @param first the first chromosome\n+     * @param second the second chromosome\n+     * @return the pair of new chromosomes that resulted from the crossover\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n+     */\n+    protected ChromosomePair mate(final AbstractListChromosome<T> first, final AbstractListChromosome<T> second) {\n+        final int length = first.getLength();\n+        if (length != second.getLength()) {\n+            throw new DimensionMismatchException(second.getLength(), length);\n+        }\n+\n+        // array representations of the parents\n+        final List<T> parent1Rep = first.getRepresentation();\n+        final List<T> parent2Rep = second.getRepresentation();\n+        // and of the children: do a crossover copy to simplify the later processing\n+        final List<T> child1Rep = new ArrayList<T>(second.getRepresentation());\n+        final List<T> child2Rep = new ArrayList<T>(first.getRepresentation());\n+\n+        // the set of all visited indices so far\n+        final Set<Integer> visitedIndices = new HashSet<Integer>(length);\n+        // the indices of the current cycle\n+        final List<Integer> indices = new ArrayList<Integer>(length);\n+\n+        // determine the starting index\n+        int idx = randomStart ? GeneticAlgorithm.getRandomGenerator().nextInt(length) : 0;\n+        int cycle = 1;\n+\n+        while (visitedIndices.size() < length) {\n+            indices.add(idx);\n+\n+            T item = parent2Rep.get(idx);\n+            idx = parent1Rep.indexOf(item);\n+\n+            while (idx != indices.get(0)) {\n+                // add that index to the cycle indices\n+                indices.add(idx);\n+                // get the item in the second parent at that index\n+                item = parent2Rep.get(idx);\n+                // get the index of that item in the first parent\n+                idx = parent1Rep.indexOf(item);\n+            }\n+\n+            // for even cycles: swap the child elements on the indices found in this cycle\n+            if (cycle++ % 2 != 0) {\n+                for (int i : indices) {\n+                    T tmp = child1Rep.get(i);\n+                    child1Rep.set(i, child2Rep.get(i));\n+                    child2Rep.set(i, tmp);\n+                }\n+            }\n+\n+            visitedIndices.addAll(indices);\n+            // find next starting index: last one + 1 until we find an unvisited index\n+            idx = (indices.get(0) + 1) % length;\n+            while (visitedIndices.contains(idx) && visitedIndices.size() < length) {\n+                idx++;\n+                if (idx >= length) {\n+                    idx = 0;\n+                }\n+            }\n+            indices.clear();\n+        }\n+\n+        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n+                                  second.newFixedLengthChromosome(child2Rep));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/genetics/CycleCrossoverTest.java\n+package org.apache.commons.math3.genetics;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CycleCrossoverTest {\n+    \n+    @Test\n+    public void testCrossoverExample() {\n+        // taken from http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx\n+        final Integer[] p1 = new Integer[] { 8, 4, 7, 3, 6, 2, 5, 1, 9, 0 };\n+        final Integer[] p2 = new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+        final DummyListChromosome p1c = new DummyListChromosome(p1);\n+        final DummyListChromosome p2c = new DummyListChromosome(p2);\n+\n+        final CrossoverPolicy cp = new CycleCrossover<Integer>();\n+        final ChromosomePair pair = cp.crossover(p1c, p2c);\n+\n+        final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);\n+        final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);\n+\n+        final Integer[] c1e = new Integer[] { 8, 1, 2, 3, 4, 5, 6, 7, 9, 0 };\n+        final Integer[] c2e = new Integer[] { 0, 4, 7, 3, 6, 2, 5, 1, 8, 9 };\n+\n+        Assert.assertArrayEquals(c1e, c1);\n+        Assert.assertArrayEquals(c2e, c2);\n+    }\n+\n+    @Test\n+    public void testCrossoverExample2() {\n+        // taken from http://www.scribd.com/doc/54206412/32/Cycle-crossover\n+        final Integer[] p1 = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+        final Integer[] p2 = new Integer[] { 9, 3, 7, 8, 2, 6, 5, 1, 4};\n+        final DummyListChromosome p1c = new DummyListChromosome(p1);\n+        final DummyListChromosome p2c = new DummyListChromosome(p2);\n+\n+        final CrossoverPolicy cp = new CycleCrossover<Integer>();\n+        final ChromosomePair pair = cp.crossover(p1c, p2c);\n+\n+        final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);\n+        final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);\n+\n+        final Integer[] c1e = new Integer[] { 1, 3, 7, 4, 2, 6, 5, 8, 9 };\n+        final Integer[] c2e = new Integer[] { 9, 2, 3, 8, 5, 6, 7, 1, 4 };\n+\n+        Assert.assertArrayEquals(c1e, c1);\n+        Assert.assertArrayEquals(c2e, c2);\n+    }\n+\n+    @Test\n+    public void testCrossover() {\n+        final Integer[] p1 = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+        final Integer[] p2 = new Integer[] { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };\n+        final DummyListChromosome p1c = new DummyListChromosome(p1);\n+        final DummyListChromosome p2c = new DummyListChromosome(p2);\n+\n+        final CrossoverPolicy cp = new CycleCrossover<Integer>(true);\n+\n+        for (int i = 0; i < 20; i++) {\n+            final ChromosomePair pair = cp.crossover(p1c, p2c);\n+\n+            final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]);\n+            final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]);\n+\n+            int index = 0;\n+            // Determine if it is in the same spot as in the first parent, if \n+            // not it comes from the second parent.\n+            for (final Integer j : c1) {\n+                if (!p1[index].equals(j)) {\n+                    Assert.assertEquals(j, p2[index]);\n+                } else {\n+                    Assert.assertEquals(j, p1[index]);\n+                }\n+                index++;\n+            }\n+\n+            // Same as above only for the second parent.\n+            index = 0;\n+            for (final Integer k : c2) {\n+                if (p2[index] != k) {\n+                    Assert.assertEquals(k, p1[index]);\n+                } else {\n+                    Assert.assertEquals(k, p2[index]);\n+                }\n+                index++;\n+            }\n+        }\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testCrossoverDimensionMismatchException() {\n+        final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };\n+        final Integer[] p2 = new Integer[] { 0, 1, 1, 0, 1 };\n+\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+\n+        final CrossoverPolicy cp = new CycleCrossover<Integer>();\n+        cp.crossover(p1c, p2c);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeFirst() {\n+        final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final Chromosome p2c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new CycleCrossover<Integer>();\n+        cp.crossover(p1c, p2c);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeSecond() {\n+        final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 };\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p1);\n+        final Chromosome p1c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new CycleCrossover<Integer>();\n+        cp.crossover(p1c, p2c);\n+    }\n+}", "timestamp": 1344192414, "metainfo": ""}