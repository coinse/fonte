{"sha": "188ef9cfd13fd94f4fab18e750adff021d1e4ae6", "log": "Removed references to deprecated MathRuntimeException (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  */\n public class FastHadamardTransformer implements RealTransformer {\n \n-    /** {@inheritDoc} */\n-    public double[] transform(double[] f)\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n+     */\n+    public double[] transform(double[] f) throws MathIllegalArgumentException {\n+        return fht(f);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws NonMonotonicSequenceException if the lower bound is greater\n+     * than, or equal to the upper bound\n+     * @throws NotStrictlyPositiveException if the number of sample points is\n+     * negative\n+     * @throws MathIllegalArgumentException if the number of sample points is\n+     * not a power of two\n+     */\n+    public double[] transform(UnivariateFunction f,\n+        double min, double max, int n) throws\n+        NonMonotonicSequenceException,\n+        NotStrictlyPositiveException,\n+        MathIllegalArgumentException {\n+\n+        return fht(FastFourierTransformer.sample(f, min, max, n));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n+     */\n+    public double[] inverseTransform(double[] f)\n         throws IllegalArgumentException {\n-        return fht(f);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] transform(UnivariateFunction f,\n-                              double min, double max, int n)\n-        throws IllegalArgumentException {\n-        return fht(FastFourierTransformer.sample(f, min, max, n));\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] inverseTransform(double[] f)\n-    throws IllegalArgumentException {\n+\n         return FastFourierTransformer.scaleArray(fht(f), 1.0 / f.length);\n    }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws NonMonotonicSequenceException if the lower bound is greater\n+     * than, or equal to the upper bound\n+     * @throws NotStrictlyPositiveException if the number of sample points is\n+     * negative\n+     * @throws MathIllegalArgumentException if the number of sample points is\n+     * not a power of two\n+     */\n     public double[] inverseTransform(UnivariateFunction f,\n-                                     double min, double max, int n)\n-        throws IllegalArgumentException {\n+        double min, double max, int n) throws\n+        NonMonotonicSequenceException,\n+        NotStrictlyPositiveException,\n+        MathIllegalArgumentException {\n+\n         final double[] unscaled =\n             fht(FastFourierTransformer.sample(f, min, max, n));\n         return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);\n     }\n \n     /**\n-     * Transform the given real data set.\n-     * <p>The integer transform cannot be inverted directly, due to a scaling\n-     * factor it may lead to double results.</p>\n+     * Returns the forward transform of the specified integer data set.The\n+     * integer transform cannot be inverted directly, due to a scaling factor\n+     * which may lead to double results.\n+     *\n      * @param f the integer data array to be transformed (signal)\n      * @return the integer transformed array (spectrum)\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public int[] transform(int[] f)\n-        throws IllegalArgumentException {\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n+     */\n+    public int[] transform(int[] f) throws MathIllegalArgumentException {\n         return fht(f);\n     }\n \n      * </tbody>\n      * </table>\n      *\n-     * @param x the input vector\n-     * @return the output vector, {@code y}\n-     * @exception IllegalArgumentException if input array is not a power of 2\n-     */\n-    protected double[] fht(double[] x) throws IllegalArgumentException {\n-\n-        // n is the row count of the input vector x\n+     * @param x the real data array to be transformed\n+     * @return the real transformed array, {@code y}\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n+     */\n+    protected double[] fht(double[] x) throws MathIllegalArgumentException {\n+\n         final int n     = x.length;\n         final int halfN = n / 2;\n \n-        // n has to be of the form n = 2^p !!\n         if (!FastFourierTransformer.isPowerOf2(n)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            throw new MathIllegalArgumentException(\n                     LocalizedFormats.NOT_POWER_OF_TWO,\n-                    n);\n+                    Integer.valueOf(n));\n         }\n \n-        // Instead of creating a matrix with p+1 columns and n rows\n-        // we will use two single dimension arrays which we will use in an alternating way.\n+        /*\n+         * Instead of creating a matrix with p+1 columns and n rows, we use two\n+         * one dimension arrays which we are used in an alternating way.\n+         */\n         double[] yPrevious = new double[n];\n         double[] yCurrent  = x.clone();\n \n \n             // iterate from top to bottom (row)\n             for (int i = 0; i < halfN; ++i) {\n-                // D<sub>top</sub>\n-                // The top part works with addition\n+                // Dtop: the top part works with addition\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n             }\n             for (int i = halfN; i < n; ++i) {\n-                // D<sub>bottom</sub>\n-                // The bottom part works with subtraction\n+                // Dbottom: the bottom part works with subtraction\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n             }\n         }\n \n-        // return the last computed output vector y\n         return yCurrent;\n \n     }\n-    /**\n-     * The FHT (Fast Hadamard Transformation) which uses only subtraction and addition.\n-     * @param x input vector\n-     * @return y output vector\n-     * @exception IllegalArgumentException if input array is not a power of 2\n-     */\n-    protected int[] fht(int[] x) throws IllegalArgumentException {\n-\n-        // n is the row count of the input vector x\n+\n+    /**\n+     * Returns the forward transform of the specified integer data set. The FHT\n+     * (Fast Hadamard Transform) uses only subtraction and addition.\n+     *\n+     * @param x the integer data array to be transformed\n+     * @return the integer transformed array, {@code y}\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n+     */\n+    protected int[] fht(int[] x) throws MathIllegalArgumentException {\n+\n         final int n     = x.length;\n         final int halfN = n / 2;\n \n-        // n has to be of the form n = 2^p !!\n         if (!FastFourierTransformer.isPowerOf2(n)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            throw new MathIllegalArgumentException(\n                     LocalizedFormats.NOT_POWER_OF_TWO,\n-                    n);\n+                    Integer.valueOf(n));\n         }\n \n-        // Instead of creating a matrix with p+1 columns and n rows\n-        // we will use two single dimension arrays which we will use in an alternating way.\n+        /*\n+         * Instead of creating a matrix with p+1 columns and n rows, we use two\n+         * one dimension arrays which we are used in an alternating way.\n+         */\n         int[] yPrevious = new int[n];\n         int[] yCurrent  = x.clone();\n \n \n             // iterate from top to bottom (row)\n             for (int i = 0; i < halfN; ++i) {\n-                // D<sub>top</sub>\n-                // The top part works with addition\n+                // Dtop: the top part works with addition\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n             }\n             for (int i = halfN; i < n; ++i) {\n-                // D<sub>bottom</sub>\n-                // The bottom part works with subtraction\n+                // Dbottom: the bottom part works with subtraction\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n             }", "timestamp": 1325638639, "metainfo": ""}