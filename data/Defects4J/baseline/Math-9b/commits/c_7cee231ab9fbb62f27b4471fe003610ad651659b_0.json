{"sha": "7cee231ab9fbb62f27b4471fe003610ad651659b", "log": "MATH-854: populated throws clause of Array2DRowFieldMatrix.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n     }\n \n     /** {@inheritDoc} */\n-    public abstract FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension);\n+    public abstract FieldMatrix<T> createMatrix(final int rowDimension,\n+                                                final int columnDimension)\n+        throws NotStrictlyPositiveException;\n \n     /** {@inheritDoc} */\n     public abstract FieldMatrix<T> copy();\n     }\n \n     /** {@inheritDoc} */\n-    public abstract T getEntry(int row, int column);\n-\n-    /** {@inheritDoc} */\n-    public abstract void setEntry(int row, int column, T value);\n-\n-    /** {@inheritDoc} */\n-    public abstract void addToEntry(int row, int column, T increment);\n-\n-    /** {@inheritDoc} */\n-    public abstract void multiplyEntry(int row, int column, T factor);\n+    public abstract T getEntry(int row, int column) throws OutOfRangeException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void setEntry(int row, int column, T value) throws OutOfRangeException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void addToEntry(int row, int column, T increment) throws OutOfRangeException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void multiplyEntry(int row, int column, T factor) throws OutOfRangeException;\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> transpose() {\n--- a/src/main/java/org/apache/commons/math3/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/Array2DRowFieldMatrix.java\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.MathUtils;\n \n      * @param field Field to which the elements belong.\n      * @param rowDimension Number of rows in the new matrix.\n      * @param columnDimension Number of columns in the new matrix.\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if row or column dimension is not positive.\n-     */\n-    public Array2DRowFieldMatrix(final Field<T> field,\n-                                 final int rowDimension,\n-                                 final int columnDimension) {\n+     * @throws NotStrictlyPositiveException if row or column dimension is not positive.\n+     */\n+    public Array2DRowFieldMatrix(final Field<T> field, final int rowDimension,\n+                                 final int columnDimension)\n+        throws NotStrictlyPositiveException {\n         super(field, rowDimension, columnDimension);\n         data = buildArray(field, rowDimension, columnDimension);\n     }\n      *\n      * @param d Data for the new matrix.\n      * @throws DimensionMismatchException if {@code d} is not rectangular.\n-     * @throws org.apache.commons.math3.exception.NullArgumentException if\n-     * {@code d} is {@code null}.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n      * @throws NoDataException if there are not at least one row and one column.\n      * @see #Array2DRowFieldMatrix(FieldElement[][], boolean)\n      */\n-    public Array2DRowFieldMatrix(final T[][] d) {\n+    public Array2DRowFieldMatrix(final T[][] d)\n+        throws DimensionMismatchException, NullArgumentException,\n+        NoDataException {\n         this(extractField(d), d);\n     }\n \n      * @param field Field to which the elements belong.\n      * @param d Data for the new matrix.\n      * @throws DimensionMismatchException if {@code d} is not rectangular.\n-     * @throws org.apache.commons.math3.exception.NullArgumentException if\n-     * {@code d} is {@code null}.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n      * @throws NoDataException if there are not at least one row and one column.\n      * @see #Array2DRowFieldMatrix(FieldElement[][], boolean)\n      */\n-    public Array2DRowFieldMatrix(final Field<T> field, final T[][] d) {\n+    public Array2DRowFieldMatrix(final Field<T> field, final T[][] d)\n+        throws DimensionMismatchException, NullArgumentException,\n+        NoDataException {\n         super(field);\n         copyIn(d);\n     }\n      * @param copyArray Whether to copy or reference the input array.\n      * @throws DimensionMismatchException if {@code d} is not rectangular.\n      * @throws NoDataException if there are not at least one row and one column.\n-     * @throws org.apache.commons.math3.exception.NullArgumentException\n-     * if {@code d} is {@code null}.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n      * @see #Array2DRowFieldMatrix(FieldElement[][])\n      */\n-    public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray) {\n+    public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray)\n+        throws DimensionMismatchException, NoDataException,\n+        NullArgumentException {\n         this(extractField(d), d, copyArray);\n     }\n \n      * The input array is copied.\n      *\n      * @param v Column vector holding data for new matrix.\n-     */\n-    public Array2DRowFieldMatrix(final T[] v) {\n+     * @throws NoDataException if v is empty\n+     */\n+    public Array2DRowFieldMatrix(final T[] v) throws NoDataException {\n         this(extractField(v), v);\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension) {\n+    public FieldMatrix<T> createMatrix(final int rowDimension,\n+                                       final int columnDimension)\n+        throws NotStrictlyPositiveException {\n         return new Array2DRowFieldMatrix<T>(getField(), rowDimension, columnDimension);\n     }\n \n      *\n      * @param m Matrix to be added.\n      * @return {@code this} + m.\n-     * @throws MatrixDimensionMismatchException\n-     * if {@code m} is not the same size as this matrix.\n-     */\n-    public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m) {\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as this matrix.\n+     */\n+    public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         // safety check\n         checkAdditionCompatible(m);\n \n      *\n      * @param m Matrix to be subtracted.\n      * @return {@code this} + m.\n-     * @throws MatrixDimensionMismatchException\n-     * if {@code m} is not the same size as this matrix.\n-     */\n-    public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m) {\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as this matrix.\n+     */\n+    public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m)\n+        throws MatrixDimensionMismatchException {\n         // safety check\n         checkSubtractionCompatible(m);\n \n      * @throws DimensionMismatchException if the number of columns of this\n      * matrix is not equal to the number of rows of {@code m}.\n      */\n-    public Array2DRowFieldMatrix<T> multiply(final Array2DRowFieldMatrix<T> m) {\n+    public Array2DRowFieldMatrix<T> multiply(final Array2DRowFieldMatrix<T> m)\n+        throws DimensionMismatchException {\n         // safety check\n         checkMultiplicationCompatible(m);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n+    public void setSubMatrix(final T[][] subMatrix, final int row,\n+                             final int column)\n+        throws OutOfRangeException, NullArgumentException, NoDataException,\n+        DimensionMismatchException {\n         if (data == null) {\n             if (row > 0) {\n                 throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n \n     /** {@inheritDoc} */\n     @Override\n-    public T getEntry(final int row, final int column) {\n+    public T getEntry(final int row, final int column)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setEntry(final int row, final int column, final T value) {\n+    public void setEntry(final int row, final int column, final T value)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void addToEntry(final int row, final int column, final T increment) {\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void multiplyEntry(final int row, final int column, final T factor) {\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws OutOfRangeException {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] operate(final T[] v) {\n+    public T[] operate(final T[] v) throws DimensionMismatchException {\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] preMultiply(final T[] v) {\n+    public T[] preMultiply(final T[] v) throws DimensionMismatchException {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n     @Override\n     public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n                             final int startRow, final int endRow,\n-                            final int startColumn, final int endColumn) {\n+                            final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     @Override\n     public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                             final int startRow, final int endRow,\n-                            final int startColumn, final int endColumn) {\n+                            final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     @Override\n     public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn) {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+                               final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n+    checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int j = startColumn; j <= endColumn; ++j) {\n     @Override\n     public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n-                               final int startColumn, final int endColumn) {\n+                               final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n      * @param in Data to copy.\n      * @throws NoDataException if the input array is empty.\n      * @throws DimensionMismatchException if the input array is not rectangular.\n-     * @throws org.apache.commons.math3.exception.NullArgumentException if\n-     * the input array is {@code null}.\n-     */\n-    private void copyIn(final T[][] in) {\n+     * @throws NullArgumentException if the input array is {@code null}.\n+     */\n+    private void copyIn(final T[][] in)\n+        throws NullArgumentException, NoDataException,\n+        DimensionMismatchException {\n         setSubMatrix(in, 0, 0);\n     }\n }", "timestamp": 1349156159, "metainfo": ""}