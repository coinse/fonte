{"sha": "9be86f674f91fa3fe0a8694e7b98472dabe6886d", "log": "fixed a bracketing issue due to inconsistent checks JIRA: MATH-280  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n      /**\n      * This method attempts to find two values a and b satisfying <ul>\n      * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n-     * <li> <code> f(a) * f(b) < 0 </code> </li>\n+     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n      * </ul>\n      * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n      * and <code>b</code> bracket a root of f.\n      * function at <code>a</code> and <code>b</code> and keeps moving\n      * the endpoints out by one unit each time through a loop that terminates \n      * when one of the following happens: <ul>\n-     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n      * <li> <code> a = lower </code> and <code> b = upper</code> \n      * -- ConvergenceException </li>\n      * <li> <code> maximumIterations</code> iterations elapse \n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n         }\n \n         // by default, do simple root finding using bracketing and default solver.\n-        // subclasses can overide if there is a better method.\n+        // subclasses can override if there is a better method.\n         UnivariateRealFunction rootFindingFunction =\n             new UnivariateRealFunction() {\n             public double value(double x) throws FunctionEvaluationException {\n--- a/src/test/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.ConvergenceException;\n+import junit.framework.TestCase;\n+\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-\n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n         assertTrue(sin.value(result[1]) > 0);\n     }\n     \n-    public void testBracketCornerSolution() throws MathException {\n-        try {\n-            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0); \n-            fail(\"Expecting ConvergenceException\");\n-        } catch (ConvergenceException ex) {\n-            // expected\n-        }\n-    }\n-    \n     public void testBadParameters() throws MathException {\n         try { // null function\n             UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n--- a/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n  */\n \n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n \n /**\n  * Test cases for NormalDistribution.\n             }\n         } \n    }\n+\n+    public void testMath280() throws MathException {\n+        NormalDistribution normal = new NormalDistributionImpl(0,1);\n+        double result = normal.inverseCumulativeProbability(0.9772498680518209);\n+        assertEquals(2.0, result, 1.0e-12);\n+    }\n+\n }", "timestamp": 1246958386, "metainfo": ""}