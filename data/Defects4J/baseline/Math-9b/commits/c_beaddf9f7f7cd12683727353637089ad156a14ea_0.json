{"sha": "beaddf9f7f7cd12683727353637089ad156a14ea", "log": "Preliminary checkin of SoC code. Contributed by: Xiaogang Zhang   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/DividedDifferenceInterpolatorTest.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Divided Difference interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class DividedDifferenceInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/Expm1Function.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Auxillary class for testing purposes.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Expm1Function implements DifferentiableUnivariateRealFunction {\n+\n+    public double value(double x) throws FunctionEvaluationException {\n+        // Math.expm1() is available in jdk 1.5 but not in jdk 1.4.2.\n+        return Math.exp(x) - 1.0;\n+    }\n+\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) throws FunctionEvaluationException {\n+                return Math.exp(x);\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.complex.Complex;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Laguerre solver.\n+ * <p>\n+ * Laguerre's method is very efficient in solving polynomials. Test runs\n+ * show that for a default absolute accuracy of 1E-6, it generally takes\n+ * less than 5 iterations to find one root, provided solveAll() is not\n+ * invoked, and 15 to 20 iterations to find all roots for quintic function.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class LaguerreSolverTest extends TestCase {\n+\n+    /**\n+     * Test of solver for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 4x - 1\n+        double coefficients[] = { -1.0, 4.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = 0.0; max = 1.0; expected = 0.25;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = 0.0; max = 2.0; expected = 0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -4.0; max = -1.0; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)\n+        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = -2.0; max = 2.0; expected = -1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -5.0; max = -2.5; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 3.0; max = 6.0; expected = 4.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solveAll().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        double initial = 0.0, tolerance;\n+        Complex expected, result[];\n+\n+        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n+        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        LaguerreSolver solver = new LaguerreSolver(f);\n+        result = solver.solveAll(coefficients, initial);\n+\n+        // The order of roots returned by solveAll() depends on\n+        // initial value, solveAll() does no sorting.\n+        expected = new Complex(0.0, -2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        assertEquals(0.0, (expected.subtract(result[0])).abs(), tolerance);\n+\n+        expected = new Complex(0.0, 2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        assertEquals(0.0, (expected.subtract(result[1])).abs(), tolerance);\n+\n+        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        assertEquals(0.0, (expected.subtract(result[2])).abs(), tolerance);\n+\n+        expected = new Complex(-1.0, 0.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        assertEquals(0.0, (expected.subtract(result[3])).abs(), tolerance);\n+\n+        expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        assertEquals(0.0, (expected.subtract(result[4])).abs(), tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        try {\n+            // bad interval\n+            solver.solve(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad function\n+            UnivariateRealFunction f2 = new SinFunction();\n+            UnivariateRealSolver solver2 = new LaguerreSolver(f2);\n+            fail(\"Expecting IllegalArgumentException - bad function\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/MullerSolverTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Muller solver.\n+ * <p>\n+ * Muller's method converges almost quadratically near roots, but it can\n+ * be very slow in regions far away from zeros. Test runs show that for\n+ * reasonably good initial values, for a default absolute accuracy of 1E-6,\n+ * it generally takes 5 to 10 iterations for the solver to converge.\n+ * <p>\n+ * Tests for the exponential function illustrate the situations where\n+ * Muller solver performs poorly.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class MullerSolverTest extends TestCase {\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function using solve2().\n+     */\n+    public void testSinFunction2() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solve2().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     * <p>\n+     * It takes 10 to 15 iterations for the last two tests to converge.\n+     * In fact, if not for the bisection alternative, the solver would\n+     * exceed the default maximal iteration of 100.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function using solve2().\n+     * <p>\n+     * It takes 25 to 50 iterations for the last two tests to converge.\n+     */\n+    public void testExpm1Function2() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+\n+        try {\n+            // bad interval\n+            solver.solve(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/NevilleInterpolatorTest.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Neville interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class NevilleInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/PolynomialFunctionLagrangeFormTest.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Lagrange form of polynomial function.\n+ * <p>\n+ * We use n+1 points to interpolate a polynomial of degree n. This should\n+ * give us the exact same polynomial as result. Thus we can use a very\n+ * small tolerance to account only for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionLagrangeFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4\n+        double x[] = { 0.0, 3.0 };\n+        double y[] = { -4.0, 0.5 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(2, c.length);\n+        assertEquals(-4.0, c[0], tolerance);\n+        assertEquals(1.5, c[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)\n+        double x[] = { 0.0, -1.0, 0.5 };\n+        double y[] = { -3.0, -6.0, 0.0 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(3, c.length);\n+        assertEquals(-3.0, c[0], tolerance);\n+        assertEquals(5.0, c[1], tolerance);\n+        assertEquals(2.0, c[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)\n+        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };\n+        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(6, c.length);\n+        assertEquals(0.0, c[0], tolerance);\n+        assertEquals(6.0, c[1], tolerance);\n+        assertEquals(1.0, c[2], tolerance);\n+        assertEquals(-7.0, c[3], tolerance);\n+        assertEquals(-1.0, c[4], tolerance);\n+        assertEquals(1.0, c[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+        PolynomialFunctionLagrangeForm p;\n+\n+        try {\n+            // bad input array length\n+            double x[] = { 1.0 };\n+            double y[] = { 2.0 };\n+            p = new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double x[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double y[] = { 0.0, -4.0, -24.0 };\n+            p = new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/PolynomialFunctionNewtonFormTest.java\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Newton form of polynomial function.\n+ * <p>\n+ * The small tolerance number is used only to account for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionNewtonFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)\n+        double a[] = { 2.0, 1.5 };\n+        double c[] = { 4.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(2, coefficients.length);\n+        assertEquals(-4.0, coefficients[0], tolerance);\n+        assertEquals(1.5, coefficients[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)\n+        double a[] = { 4.0, 3.0, 2.0 };\n+        double c[] = { 1.0, -2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(3, coefficients.length);\n+        assertEquals(-3.0, coefficients[0], tolerance);\n+        assertEquals(5.0, coefficients[1], tolerance);\n+        assertEquals(2.0, coefficients[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x\n+        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)\n+        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };\n+        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(6, coefficients.length);\n+        assertEquals(0.0, coefficients[0], tolerance);\n+        assertEquals(6.0, coefficients[1], tolerance);\n+        assertEquals(1.0, coefficients[2], tolerance);\n+        assertEquals(-7.0, coefficients[3], tolerance);\n+        assertEquals(-1.0, coefficients[4], tolerance);\n+        assertEquals(1.0, coefficients[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+        PolynomialFunctionNewtonForm p;\n+\n+        try {\n+            // bad input array length\n+            double a[] = { 1.0 };\n+            double c[] = { 2.0 };\n+            p = new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double a[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double c[] = { 4.0, 3.0, 2.0, 1.0 };\n+            p = new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/RiddersSolverTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Ridders solver.\n+ * <p>\n+ * Ridders' method converges superlinearly, more specific, its rate of\n+ * convergence is sqrt(2). Test runs show that for a default absolute\n+ * accuracy of 1E-6, it generally takes less than 5 iterations for close\n+ * initial bracket and 5 to 10 iterations for distant initial bracket\n+ * to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class RiddersSolverTest extends TestCase {\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+\n+        try {\n+            // bad interval\n+            solver.solve(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}", "timestamp": 1125871227, "metainfo": ""}