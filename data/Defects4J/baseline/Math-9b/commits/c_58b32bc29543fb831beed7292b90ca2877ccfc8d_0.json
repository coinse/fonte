{"sha": "58b32bc29543fb831beed7292b90ca2877ccfc8d", "log": "Set up array building methods for generic types.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/AbstractFieldMatrix.java\n \n package org.apache.commons.math3.linear;\n \n-import java.lang.reflect.Array;\n import java.util.ArrayList;\n-import java.util.Arrays;\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NotPositiveException;\n-import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.MathArrays;\n \n /**\n  * Basic implementation of {@link FieldMatrix} methods regardless of the underlying storage.\n         return d[0].getField();\n     }\n \n-    /** Build an array of elements.\n-     * <p>\n-     * Complete arrays are filled with field.getZero()\n-     * </p>\n-     * @param <T> Type of the field elements\n-     * @param field field to which array elements belong\n-     * @param rows number of rows\n-     * @param columns number of columns (may be negative to build partial\n-     * arrays in the same way <code>new Field[rows][]</code> works)\n-     * @return a new array\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field,\n-                                                                  final int rows,\n-                                                                  final int columns) {\n-        if (columns < 0) {\n-            T[] dummyRow = (T[]) Array.newInstance(field.getRuntimeClass(), 0);\n-            return (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n-        }\n-        T[][] array =\n-            (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });\n-        for (int i = 0; i < array.length; ++i) {\n-            Arrays.fill(array[i], field.getZero());\n-        }\n-        return array;\n-    }\n-\n-    /** Build an array of elements.\n-     * <p>\n-     * Arrays are filled with field.getZero()\n-     * </p>\n-     * @param <T> the type of the field elements\n-     * @param field field to which array elements belong\n-     * @param length of the array\n-     * @return a new array\n-     */\n-    protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field,\n-                                                                final int length) {\n-        @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n-        T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n-        Arrays.fill(array, field.getZero());\n-        return array;\n-    }\n-\n     /** {@inheritDoc} */\n     public Field<T> getField() {\n         return field;\n \n     /** {@inheritDoc} */\n     public T[][] getData() {\n-        final T[][] data = buildArray(field, getRowDimension(), getColumnDimension());\n+        final T[][] data = MathArrays.buildArray(field, getRowDimension(), getColumnDimension());\n \n         for (int i = 0; i < data.length; ++i) {\n             final T[] dataI = data[i];\n     public T[] getRow(final int row) throws OutOfRangeException {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n-        final T[] out = buildArray(field, nCols);\n+        final T[] out = MathArrays.buildArray(field, nCols);\n         for (int i = 0; i < nCols; ++i) {\n             out[i] = getEntry(row, i);\n         }\n     public T[] getColumn(final int column) throws OutOfRangeException {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n-        final T[] out = buildArray(field, nRows);\n+        final T[] out = MathArrays.buildArray(field, nRows);\n         for (int i = 0; i < nRows; ++i) {\n             out[i] = getEntry(i, column);\n         }\n             throw new DimensionMismatchException(v.length, nCols);\n         }\n \n-        final T[] out = buildArray(field, nRows);\n+        final T[] out = MathArrays.buildArray(field, nRows);\n         for (int row = 0; row < nRows; ++row) {\n             T sum = field.getZero();\n             for (int i = 0; i < nCols; ++i) {\n                 throw new DimensionMismatchException(v.getDimension(), nCols);\n             }\n \n-            final T[] out = buildArray(field, nRows);\n+            final T[] out = MathArrays.buildArray(field, nRows);\n             for (int row = 0; row < nRows; ++row) {\n                 T sum = field.getZero();\n                 for (int i = 0; i < nCols; ++i) {\n             throw new DimensionMismatchException(v.length, nRows);\n         }\n \n-        final T[] out = buildArray(field, nCols);\n+        final T[] out = MathArrays.buildArray(field, nCols);\n         for (int col = 0; col < nCols; ++col) {\n             T sum = field.getZero();\n             for (int i = 0; i < nRows; ++i) {\n                 throw new DimensionMismatchException(v.getDimension(), nRows);\n             }\n \n-            final T[] out = buildArray(field, nCols);\n+            final T[] out = MathArrays.buildArray(field, nCols);\n             for (int col = 0; col < nCols; ++col) {\n                 T sum = field.getZero();\n                 for (int i = 0; i < nRows; ++i) {\n--- a/src/main/java/org/apache/commons/math3/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/Array2DRowFieldMatrix.java\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.MathArrays;\n import org.apache.commons.math3.util.MathUtils;\n \n /**\n                                  final int columnDimension)\n         throws NotStrictlyPositiveException {\n         super(field, rowDimension, columnDimension);\n-        data = buildArray(field, rowDimension, columnDimension);\n+        data = MathArrays.buildArray(field, rowDimension, columnDimension);\n     }\n \n     /**\n     public Array2DRowFieldMatrix(final Field<T> field, final T[] v) {\n         super(field);\n         final int nRows = v.length;\n-        data = buildArray(getField(), nRows, 1);\n+        data = MathArrays.buildArray(getField(), nRows, 1);\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = v[row];\n         }\n \n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        final T[][] outData = buildArray(getField(), rowCount, columnCount);\n+        final T[][] outData = MathArrays.buildArray(getField(), rowCount, columnCount);\n         for (int row = 0; row < rowCount; row++) {\n             final T[] dataRow    = data[row];\n             final T[] mRow       = m.data[row];\n \n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        final T[][] outData = buildArray(getField(), rowCount, columnCount);\n+        final T[][] outData = MathArrays.buildArray(getField(), rowCount, columnCount);\n         for (int row = 0; row < rowCount; row++) {\n             final T[] dataRow    = data[row];\n             final T[] mRow       = m.data[row];\n         final int nRows = this.getRowDimension();\n         final int nCols = m.getColumnDimension();\n         final int nSum = this.getColumnDimension();\n-        final T[][] outData = buildArray(getField(), nRows, nCols);\n+        final T[][] outData = MathArrays.buildArray(getField(), nRows, nCols);\n         for (int row = 0; row < nRows; row++) {\n             final T[] dataRow    = data[row];\n             final T[] outDataRow = outData[row];\n             if (nCols == 0) {\n                 throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n-            data = buildArray(getField(), subMatrix.length, nCols);\n+            data = MathArrays.buildArray(getField(), subMatrix.length, nCols);\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw new DimensionMismatchException(nCols, subMatrix[i].length);\n         if (v.length != nCols) {\n             throw new DimensionMismatchException(v.length, nCols);\n         }\n-        final T[] out = buildArray(getField(), nRows);\n+        final T[] out = MathArrays.buildArray(getField(), nRows);\n         for (int row = 0; row < nRows; row++) {\n             final T[] dataRow = data[row];\n             T sum = getField().getZero();\n             throw new DimensionMismatchException(v.length, nRows);\n         }\n \n-        final T[] out = buildArray(getField(), nCols);\n+        final T[] out = MathArrays.buildArray(getField(), nCols);\n         for (int col = 0; col < nCols; ++col) {\n             T sum = getField().getZero();\n             for (int i = 0; i < nRows; ++i) {\n      */\n     private T[][] copyOut() {\n         final int nRows = this.getRowDimension();\n-        final T[][] out = buildArray(getField(), nRows, getColumnDimension());\n+        final T[][] out = MathArrays.buildArray(getField(), nRows, getColumnDimension());\n         // can't copy 2-d array in one shot, otherwise get row references\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n package org.apache.commons.math3.linear;\n \n import java.io.Serializable;\n-import java.lang.reflect.Array;\n import java.util.Arrays;\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.ZeroException;\n-import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.MathArrays;\n \n /**\n  * This class implements the {@link FieldVector} interface with a {@link FieldElement} array.\n      */\n     public ArrayFieldVector(Field<T> field, int size) {\n         this.field = field;\n-        data = buildArray(size);\n-        Arrays.fill(data, field.getZero());\n+        this.data  = MathArrays.buildArray(field, size);\n     }\n \n     /**\n             throw new NumberIsTooLargeException(pos + size, d.length, true);\n         }\n         field = d[0].getField();\n-        data = buildArray(size);\n+        data = MathArrays.buildArray(field, size);\n         System.arraycopy(d, pos, data, 0, size);\n     }\n \n             throw new NumberIsTooLargeException(pos + size, d.length, true);\n         }\n         this.field = field;\n-        data = buildArray(size);\n+        data = MathArrays.buildArray(field, size);\n         System.arraycopy(d, pos, data, 0, size);\n     }\n \n             throw new NullArgumentException();\n         }\n         field = v.getField();\n-        data = buildArray(v.getDimension());\n+        data = MathArrays.buildArray(field, v.getDimension());\n         for (int i = 0; i < data.length; ++i) {\n             data[i] = v.getEntry(i);\n         }\n             throw new NullArgumentException();\n         }\n         field = v1.getField();\n-        data = buildArray(v1.data.length + v2.data.length);\n+        data = MathArrays.buildArray(field, v1.data.length + v2.data.length);\n         System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n         System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n     }\n             throw new NullArgumentException();\n         }\n         field = v1.getField();\n-        data = buildArray(v1.data.length + v2.length);\n+        data = MathArrays.buildArray(field, v1.data.length + v2.length);\n         System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n         System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n     }\n             throw new NullArgumentException();\n         }\n         field = v2.getField();\n-        data = buildArray(v1.length + v2.data.length);\n+        data = MathArrays.buildArray(field, v1.length + v2.data.length);\n         System.arraycopy(v1, 0, data, 0, v1.length);\n         System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n     }\n         if (v1.length + v2.length == 0) {\n             throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n-        data = buildArray(v1.length + v2.length);\n+        data = MathArrays.buildArray(v1[0].getField(), v1.length + v2.length);\n         System.arraycopy(v1, 0, data, 0, v1.length);\n         System.arraycopy(v2, 0, data, v1.length, v2.length);\n         field = data[0].getField();\n         if (v1.length + v2.length == 0) {\n             throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n-        data = buildArray(v1.length + v2.length);\n+        data = MathArrays.buildArray(field, v1.length + v2.length);\n         System.arraycopy(v1, 0, data, 0, v1.length);\n         System.arraycopy(v2, 0, data, v1.length, v2.length);\n         this.field = field;\n     }\n \n-    /**\n-     * Build an array of elements.\n-     *\n-     * @param length Size of the array to build.\n-     * @return a new array.\n-     */\n-    @SuppressWarnings(\"unchecked\") // field is of type T\n-    private T[] buildArray(final int length) {\n-        return (T[]) Array.newInstance(field.getRuntimeClass(), length);\n-    }\n-\n     /** {@inheritDoc} */\n     public Field<T> getField() {\n         return field;\n             return add((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n             checkVectorDimensions(v);\n-            T[] out = buildArray(data.length);\n+            T[] out = MathArrays.buildArray(field, data.length);\n             for (int i = 0; i < data.length; i++) {\n                 out[i] = data[i].add(v.getEntry(i));\n             }\n     public ArrayFieldVector<T> add(ArrayFieldVector<T> v)\n         throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].add(v.data[i]);\n         }\n             return subtract((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n             checkVectorDimensions(v);\n-            T[] out = buildArray(data.length);\n+            T[] out = MathArrays.buildArray(field, data.length);\n             for (int i = 0; i < data.length; i++) {\n                 out[i] = data[i].subtract(v.getEntry(i));\n             }\n     public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v)\n         throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].subtract(v.data[i]);\n         }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> mapAdd(T d) throws NullArgumentException {\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].add(d);\n         }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> mapSubtract(T d) throws NullArgumentException {\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].subtract(d);\n         }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> mapMultiply(T d) throws NullArgumentException {\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].multiply(d);\n         }\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].divide(d);\n         }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> mapInv() throws MathArithmeticException {\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         final T one = field.getOne();\n         for (int i = 0; i < data.length; i++) {\n             try {\n             return ebeMultiply((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n             checkVectorDimensions(v);\n-            T[] out = buildArray(data.length);\n+            T[] out = MathArrays.buildArray(field, data.length);\n             for (int i = 0; i < data.length; i++) {\n                 out[i] = data[i].multiply(v.getEntry(i));\n             }\n     public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)\n         throws DimensionMismatchException {\n         checkVectorDimensions(v.data.length);\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].multiply(v.data[i]);\n         }\n             return ebeDivide((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n             checkVectorDimensions(v);\n-            T[] out = buildArray(data.length);\n+            T[] out = MathArrays.buildArray(field, data.length);\n             for (int i = 0; i < data.length; i++) {\n                 try {\n                     out[i] = data[i].divide(v.getEntry(i));\n     public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n         throws DimensionMismatchException, MathArithmeticException {\n         checkVectorDimensions(v.data.length);\n-        T[] out = buildArray(data.length);\n+        T[] out = MathArrays.buildArray(field, data.length);\n         for (int i = 0; i < data.length; i++) {\n             try {\n                 out[i] = data[i].divide(v.data[i]);\n \n     /** {@inheritDoc} */\n     public FieldVector<T> append(T in) {\n-        final T[] out = buildArray(data.length + 1);\n+        final T[] out = MathArrays.buildArray(field, data.length + 1);\n         System.arraycopy(data, 0, out, 0, data.length);\n         out[data.length] = in;\n         return new ArrayFieldVector<T>(field, out, false);\n--- a/src/main/java/org/apache/commons/math3/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/BlockFieldMatrix.java\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n import org.apache.commons.math3.util.MathUtils;\n \n /**\n \n         if (copyArray) {\n             // allocate storage blocks, taking care of smaller ones at right and bottom\n-            blocks = buildArray(getField(), blockRows * blockColumns, -1);\n+            blocks = MathArrays.buildArray(getField(), blockRows * blockColumns, -1);\n         } else {\n             // reference existing array\n             blocks = blockData;\n \n         // convert array\n         final Field<T> field = extractField(rawData);\n-        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n                 final int jWidth = qEnd - qStart;\n \n                 // allocate new block\n-                final T[] block = buildArray(field, iHeight * jWidth);\n+                final T[] block = MathArrays.buildArray(field, iHeight * jWidth);\n                 blocks[blockIndex] = block;\n \n                 // copy data\n         final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n-        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n-                blocks[blockIndex] = buildArray(field, iHeight * jWidth);\n+                blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth);\n                 ++blockIndex;\n             }\n         }\n     @Override\n     public T[][] getData() {\n \n-        final T[][] data = buildArray(getField(), getRowDimension(), getColumnDimension());\n+        final T[][] data = MathArrays.buildArray(getField(), getRowDimension(), getColumnDimension());\n         final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n \n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n     public FieldVector<T> getRowVector(final int row)\n         throws OutOfRangeException {\n         checkRowIndex(row);\n-        final T[] outData = buildArray(getField(), columns);\n+        final T[] outData = MathArrays.buildArray(getField(), columns);\n \n         // perform copy block-wise, to ensure good cache behavior\n         final int iBlock  = row / BLOCK_SIZE;\n     public FieldVector<T> getColumnVector(final int column)\n         throws OutOfRangeException {\n         checkColumnIndex(column);\n-        final T[] outData = buildArray(getField(), rows);\n+        final T[] outData = MathArrays.buildArray(getField(), rows);\n \n         // perform copy block-wise, to ensure good cache behavior\n         final int jBlock  = column / BLOCK_SIZE;\n     @Override\n     public T[] getRow(final int row) throws OutOfRangeException {\n         checkRowIndex(row);\n-        final T[] out = buildArray(getField(), columns);\n+        final T[] out = MathArrays.buildArray(getField(), columns);\n \n         // perform copy block-wise, to ensure good cache behavior\n         final int iBlock  = row / BLOCK_SIZE;\n     @Override\n     public T[] getColumn(final int column) throws OutOfRangeException {\n         checkColumnIndex(column);\n-        final T[] out = buildArray(getField(), rows);\n+        final T[] out = MathArrays.buildArray(getField(), rows);\n \n         // perform copy block-wise, to ensure good cache behavior\n         final int jBlock  = column / BLOCK_SIZE;\n         if (v.length != columns) {\n             throw new DimensionMismatchException(v.length, columns);\n         }\n-        final T[] out = buildArray(getField(), rows);\n+        final T[] out = MathArrays.buildArray(getField(), rows);\n         final T zero = getField().getZero();\n \n         // perform multiplication block-wise, to ensure good cache behavior\n         if (v.length != rows) {\n             throw new DimensionMismatchException(v.length, rows);\n         }\n-        final T[] out = buildArray(getField(), columns);\n+        final T[] out = MathArrays.buildArray(getField(), columns);\n         final T zero = getField().getZero();\n \n         // perform multiplication block-wise, to ensure good cache behavior\n--- a/src/main/java/org/apache/commons/math3/linear/FieldLUDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/FieldLUDecomposition.java\n \n package org.apache.commons.math3.linear;\n \n-import java.lang.reflect.Array;\n-\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.util.MathArrays;\n \n /**\n  * Calculates the LUP-decomposition of a square matrix.\n                     throw new SingularMatrixException();\n                 }\n \n-                @SuppressWarnings(\"unchecked\") // field is of type T\n-                final T[] bp = (T[]) Array.newInstance(field.getRuntimeClass(), m);\n-\n                 // Apply permutations to b\n+                final T[] bp = MathArrays.buildArray(field, m);\n                 for (int row = 0; row < m; row++) {\n                     bp[row] = b.getEntry(pivot[row]);\n                 }\n                 throw new SingularMatrixException();\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n-            // field is of type T\n-            final T[] bp = (T[]) Array.newInstance(field.getRuntimeClass(),\n-                                                   m);\n-\n             // Apply permutations to b\n+            final T[] bp = MathArrays.buildArray(field, m);\n             for (int row = 0; row < m; row++) {\n                 bp[row] = b.getEntry(pivot[row]);\n             }\n             final int nColB = b.getColumnDimension();\n \n             // Apply permutations to b\n-            @SuppressWarnings(\"unchecked\") // field is of type T\n-            final T[][] bp = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { m, nColB });\n+            final T[][] bp = MathArrays.buildArray(field, m, nColB);\n             for (int row = 0; row < m; row++) {\n                 final T[] bpRow = bp[row];\n                 final int pRow = pivot[row];\n--- a/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.lang.reflect.Array;\n import java.util.Arrays;\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.NoDataException;\n-import org.apache.commons.math3.exception.NumberIsTooSmallException;\n-import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.fraction.BigFraction;\n import org.apache.commons.math3.fraction.Fraction;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n import org.apache.commons.math3.util.Precision;\n \n /**\n         createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n         final T zero = field.getZero();\n         final T one  = field.getOne();\n-        @SuppressWarnings(\"unchecked\")\n-        final T[][] d = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { dimension, dimension });\n+        final T[][] d = MathArrays.buildArray(field, dimension, dimension);\n         for (int row = 0; row < dimension; row++) {\n             final T[] dRow = d[row];\n             Arrays.fill(dRow, zero);", "timestamp": 1361732780, "metainfo": ""}