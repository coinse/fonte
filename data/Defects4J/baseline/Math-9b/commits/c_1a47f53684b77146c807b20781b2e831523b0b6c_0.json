{"sha": "1a47f53684b77146c807b20781b2e831523b0b6c", "log": "continued refactoring of optimization framework:  - improved general interfaces at top optimization level  - added a simple implementation of ConvergenceChecker (ObjectiveValueChecker)  - added a general multi-start wrapper  - changed the direct search optimizers to the new interfaces  This work is still not complete yet. The general package classes are very close to the former design, they have almost not been changed structurally.  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n \n     // org.apache.commons.math.DimensionMismatchException\n     // org.apache.commons.math.optimization.LeastSquaresConverter\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     { \"dimension mismatch {0} != {1}\",\n       \"dimensions incompatibles {0} != {1}\" },\n \n     { \"Conversion Exception in Transformation: {0}\",\n       \"Exception de conversion dans une transformation : {0}\" },\n \n-    // org.apache.commons.math.optimization.general.AbstractEstimator\n+    // org.apache.commons.math.optimization.MultiStartOptimizer\n+    { \"no optimum computed yet\",\n+      \"aucun optimum n''a encore \\u00e9t\\u00e9 calcul\\u00e9\" },\n+\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n+    { \"simplex must contain at least one point\",\n+      \"le simplex doit contenir au moins un point\" },\n+    { \"equals vertices {0} and {1} in simplex configuration\",\n+      \"sommets {0} et {1} \\u00e9gaux dans la configuration du simplex\" },\n     { \"maximal number of evaluations exceeded ({0})\",\n       \"nombre maximal d''\\u00e9valuations d\\u00e9pass\\u00e9 ({0})\" },\n+\n+    // org.apache.commons.math.optimization.general.AbstractEstimator\n     { \"unable to compute covariances: singular problem\",\n       \"impossible de calculer les covariances : probl\\u00e8me singulier\"},\n     { \"no degrees of freedom ({0} measurements, {1} parameters)\",\n--- a/src/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n+++ b/src/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.optimization.direct.DirectSearchOptimizer;\n+import java.io.Serializable;\n \n-\n-/** This interface specifies how to check if a {@link\n- * DirectSearchOptimizer direct search method} has converged.\n+/** This interface specifies how to check if an {@link Optimizer optimization\n+ * algorithm} has converged.\n  *\n  * <p>Deciding if convergence has been reached is a problem-dependent\n  * issue. The user should provide a class implementing this interface\n  * the problem at hand.</p>\n  *\n  * @version $Revision$ $Date$\n- * @since 1.2\n+ * @since 2.0\n  */\n \n-public interface ConvergenceChecker {\n+public interface ConvergenceChecker extends Serializable {\n \n-  /** Check if the optimization algorithm has converged on the simplex.\n+  /** Check if the optimization algorithm has converged considering the last points.\n    * <p>\n-   * When this method is called, all points in the simplex have been evaluated\n-   * and are sorted from lowest to largest value. The values are either the\n-   * original objective function values if the optimizer was configured for\n-   * minimization, or the opposites of the original objective function values\n-   * if the optimizer was configured for maximization.\n+   * This method may be called several time from the same algorithm iteration with\n+   * different points. This can be detected by checking the iteration number at each\n+   * call if needed. Each time this method is called, the previous and current point\n+   * correspond to points with the same role at each iteration, so they can be\n+   * compared. As an example, simplex-based algorithms call this method for all\n+   * points of the simplex, not only for the best or worst ones.\n    * </p>\n-   * @param simplex ordered simplex\n+   * @param iteration index of current iteration\n+   * @param previous point from previous iteration\n+   * @param current point from current iteration\n    * @return true if the algorithm is considered to have converged\n    */\n-  boolean converged(PointValuePair[] simplex);\n+  boolean converged(int iteration, PointValuePair previous, PointValuePair current);\n \n }\n--- a/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.linear.RealMatrix;\n \n /** This class converts {@link MultiObjectiveFunction vectorial\n  * when the goal is to minimize them.\n  * <p>\n  * This class is mostly used when the vectorial objective function represents\n- * residuals, i.e. differences between a theoretical result computed from a\n- * variables set applied to a model and a reference. Residuals are intended to be\n- * minimized in order to get the variables set that best fit the model to the\n- * reference. The reference may be obtained for example from physical measurements\n- * whether the model is built from theoretical considerations.\n+ * a theoretical result computed from a variables set applied to a model and\n+ * the models variables must be adjusted to fit the theoretical result to some\n+ * reference observations. The observations may be obtained for example from\n+ * physical measurements whether the model is built from theoretical\n+ * considerations.\n  * </p>\n  * <p>\n  * This class computes a possibly weighted squared sum of the residuals, which is\n- * a scalar value. It implements the {@link ObjectiveFunction} interface and can\n- * therefore be minimized by any optimizer supporting scalar objectives functions.\n- * This correspond to a least square estimation.\n+ * a scalar value. The residuals are the difference between the theoretical model\n+ * (i.e. the output of the vectorial objective function) and the observations. The\n+ * class implements the {@link ObjectiveFunction} interface and can therefore be\n+ * minimized by any optimizer supporting scalar objectives functions.This is one way\n+ * to perform a least square estimation. There are other ways to do this without using\n+ * this converter, as some optimization algorithms directly support vectorial objective\n+ * functions.\n  * </p>\n  * <p>\n  * This class support combination of residuals with or without weights and correlations.\n public class LeastSquaresConverter implements ObjectiveFunction {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -5174886571116126798L;\n+    private static final long serialVersionUID = 2424320989874772110L;\n \n     /** Underlying vectorial function. */\n     private final MultiObjectiveFunction function;\n+\n+    /** Observations to be compared to objective function to compute residuals. */\n+    private final double[] observations;\n \n     /** Optional weights for the residuals. */\n     private final double[] weights;\n \n     /** Build a simple converter for uncorrelated residuals with the same weight.\n      * @param function vectorial residuals function to wrap\n+     * @param observations observations to be compared to objective function to compute residuals\n      */\n-    public LeastSquaresConverter (final MultiObjectiveFunction function) {\n-        this.function = function;\n-        this.weights  = null;\n-        this.scale    = null;\n+    public LeastSquaresConverter (final MultiObjectiveFunction function,\n+                                  final double[] observations) {\n+        this.function     = function;\n+        this.observations = observations.clone();\n+        this.weights      = null;\n+        this.scale        = null;\n     }\n \n     /** Build a simple converter for uncorrelated residuals with the specific weights.\n      * <p>\n      * The scalar objective function value is computed as:\n      * <pre>\n-     * objective = &sum;(weight<sub>i</sub>residual<sub>i</sub>)<sup>2</sup>\n+     * objective = &sum;weight<sub>i</sub>(observation<sub>i</sub>-objective<sub>i</sub>)<sup>2</sup>\n      * </pre>\n      * </p>\n      * <p>\n      * Weights can be used for example to combine residuals with different standard\n-     * deviations. As an example, consider a 2000 elements residuals array in which\n-     * even elements are angular measurements in degrees with a 0.01&deg; standard\n-     * deviation and off elements are distance measurements in meters with a 15m\n-     * standard deviation. In this case, the weights array should be initialized with\n-     * value 1.0/0.01 in the even elements and 1.0/15.0 in the odd elements. \n+     * deviations. As an example, consider a residuals array in which even elements\n+     * are angular measurements in degrees with a 0.01&deg; standard deviation and\n+     * odd elements are distance measurements in meters with a 15m standard deviation.\n+     * In this case, the weights array should be initialized with value\n+     * 1.0/(0.01<sup>2</sup>) in the even elements and 1.0/(15.0<sup>2</sup>) in the\n+     * odd elements (i.e. reciprocals of variances). \n      * </p>\n      * <p>\n-     * The residuals array computed by the function and the weights array must\n-     * have consistent sizes or a {@link ObjectiveException} will be triggered while\n-     * computing the scalar objective.\n+     * The array computed by the objective function, the observations array and the\n+     * weights array must have consistent sizes or a {@link ObjectiveException} will be\n+     * triggered while computing the scalar objective.\n      * </p>\n      * @param function vectorial residuals function to wrap\n+     * @param observations observations to be compared to objective function to compute residuals\n      * @param weights weights to apply to the residuals\n+     * @exception IllegalArgumentException if the observations vector and the weights\n+     * vector dimensions don't match (objective function dimension is checked only when\n+     * the {@link #objective} method is called)\n      */\n     public LeastSquaresConverter (final MultiObjectiveFunction function,\n-                                  final double[] weights) {\n-        this.function = function;\n-        this.weights  = weights.clone();\n-        this.scale    = null;\n+                                  final double[] observations, final double[] weights)\n+        throws IllegalArgumentException {\n+        if (observations.length != weights.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimension mismatch {0} != {1}\",\n+                    observations.length, weights.length);\n+        }\n+        this.function     = function;\n+        this.observations = observations.clone();\n+        this.weights      = weights.clone();\n+        this.scale        = null;\n     }\n \n-    /** Build a simple convertor for correlated residuals with the specific weights.\n+    /** Build a simple converter for correlated residuals with the specific weights.\n      * <p>\n      * The scalar objective function value is computed as:\n      * <pre>\n-     * objective = &sum;(y<sub>i</sub>)<sup>2</sup> with y = scale&times;residual\n+     * objective = y<sup>T</sup>y with y = scale&times;(observation-objective)\n      * </pre>\n      * </p>\n      * <p>\n-     * The residuals array computed by the function and the scaling matrix must\n-     * have consistent sizes or a {@link ObjectiveException} will be triggered while\n-     * computing the scalar objective.\n+     * The array computed by the objective function, the observations array and the\n+     * the scaling matrix must have consistent sizes or a {@link ObjectiveException}\n+     * will be triggered while computing the scalar objective.\n      * </p>\n      * @param function vectorial residuals function to wrap\n-     * @param scale scaling matrix (\n+     * @param observations observations to be compared to objective function to compute residuals\n+     * @param scale scaling matrix\n+     * @exception IllegalArgumentException if the observations vector and the scale\n+     * matrix dimensions don't match (objective function dimension is checked only when\n+     * the {@link #objective} method is called)\n      */\n     public LeastSquaresConverter (final MultiObjectiveFunction function,\n-                                  final RealMatrix scale) {\n-        this.function = function;\n-        this.weights  = null;\n-        this.scale    = scale.copy();\n+                                  final double[] observations, final RealMatrix scale)\n+        throws IllegalArgumentException {\n+        if (observations.length != scale.getColumnDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimension mismatch {0} != {1}\",\n+                    observations.length, scale.getColumnDimension());\n+        }\n+        this.function     = function;\n+        this.observations = observations.clone();\n+        this.weights      = null;\n+        this.scale        = scale.copy();\n     }\n \n     /** {@inheritDoc} */\n     public double objective(final double[] variables) throws ObjectiveException {\n \n+        // compute residuals\n         final double[] residuals = function.objective(variables);\n+        if (residuals.length != observations.length) {\n+            throw new ObjectiveException(\"dimension mismatch {0} != {1}\",\n+                                         residuals.length, observations.length);\n+        }\n+        for (int i = 0; i < residuals.length; ++i) {\n+            residuals[i] -= observations[i];\n+        }\n+\n+        // compute sum of squares\n         double sumSquares = 0;\n-\n         if (weights != null) {\n-            if (weights.length != residuals.length) {\n-                throw new ObjectiveException(\"dimension mismatch {0} != {1}\",\n-                                        weights.length, residuals.length);\n-            }\n-            for (int i = 0; i < weights.length; ++i) {\n-                final double ai = residuals[i] * weights[i];\n-                sumSquares += ai * ai;\n+            for (int i = 0; i < residuals.length; ++i) {\n+                final double ri = residuals[i];\n+                sumSquares +=  weights[i] * ri * ri;\n             }\n         } else if (scale != null) {\n-            if (scale.getColumnDimension() != residuals.length) {\n-                throw new ObjectiveException(\"dimension mismatch {0} != {1}\",\n-                                        scale.getColumnDimension(), residuals.length);\n-            }\n             for (final double yi : scale.operate(residuals)) {\n                 sumSquares += yi * yi;\n             }\n--- a/src/java/org/apache/commons/math/optimization/MultiObjectiveFunction.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiObjectiveFunction.java\n      * @param variables variables set\n      * @return function value for the given variables set\n      * @exception ObjectiveException if no cost can be computed for the parameters\n+     * @exception IllegalArgumentException if variables dimension is wrong\n      */\n-    double[] objective(double[] variables) throws ObjectiveException;\n+    double[] objective(double[] variables)\n+        throws ObjectiveException, IllegalArgumentException;\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link Optimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartOptimizer implements Optimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 6648351778723282863L;\n+\n+    /** Underlying classical optimizer. */\n+    private final Optimizer optimizer;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private PointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartOptimizer(final Optimizer optimizer, final int starts,\n+                               final RandomVectorGenerator generator) {\n+        this.optimizer        = optimizer;\n+        this.totalEvaluations = 0;\n+        this.maxEvaluations   = Integer.MAX_VALUE;\n+        this.starts           = starts;\n+        this.generator        = generator;\n+        this.optima           = null;\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(ObjectiveFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(ObjectiveFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(ObjectiveFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(ObjectiveFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public PointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return (PointValuePair[]) optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public PointValuePair optimize(final ObjectiveFunction f,\n+                                   final GoalType goalType,\n+                                   double[] startPoint)\n+        throws ObjectiveException, OptimizationException {\n+\n+        optima = new PointValuePair[starts];\n+        totalEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optima[i] = optimizer.optimize(f, goalType,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (ObjectiveException obe) {\n+                optima[i] = null;\n+            } catch (OptimizationException ope) {\n+                optima[i] = null;\n+            }\n+\n+            totalEvaluations += optimizer.getEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<PointValuePair>() {\n+            public int compare(final PointValuePair o1, final PointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/optimization/ObjectiveFunction.java\n+++ b/src/java/org/apache/commons/math/optimization/ObjectiveFunction.java\n      * @param variables variables set\n      * @return function value for the given variables set\n      * @exception ObjectiveException if no value can be computed for the parameters\n+     * @exception IllegalArgumentException if variables dimension is wrong\n      */\n-    double objective(double[] variables) throws ObjectiveException;\n+    double objective(double[] variables)\n+        throws ObjectiveException, IllegalArgumentException;\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/ObjectiveValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Special implementation of the {@link ConvergenceChecker} interface using\n+ * only objective function values.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ObjectiveValueChecker implements ConvergenceChecker {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 2490271385513842607L;\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public ObjectiveValueChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public ObjectiveValueChecker(final double relativeThreshold,\n+                                 final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final PointValuePair previous,\n+                             final PointValuePair current) {\n+        final double p          = previous.getValue();\n+        final double c          = current.getValue();\n+        final double difference = Math.abs(p - c);\n+        final double size       = Math.max(Math.abs(p), Math.abs(c));\n+        return (difference <= (size * relativeThreshold)) || (difference <= absoluteThreshold);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/optimization/Optimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/Optimizer.java\n public interface Optimizer extends Serializable {\n \n     /** Set the maximal number of objective function calls.\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number may be checked <em>after</em>\n-     * a few related calls have been made, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem and kind of optimizer).\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+     * @param maxEvaluations maximal number of function calls\n+     * .\n      */\n     void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of objective function calls.\n+     * <p>\n+     * The number of objective function calls may be checked <em>after</em> a few\n+     * related calls have been made. This implies that in some cases this number may\n+     * be exceeded by a few units, depending on the dimension of the problem and kind\n+     * of optimizer.\n+     * </p>\n+      * @return maximal number of function calls\n+     */\n+    int getMaxEvaluations();\n \n     /** Set the convergence checker.\n      * @param checker object to use to check for convergence\n      */\n     void setConvergenceChecker(ConvergenceChecker checker);\n \n+    /** Get the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    ConvergenceChecker getConvergenceChecker();\n+\n     /** Optimizes an objective function.\n      * @param f objective function\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n      * or {@link GoalType#MINIMIZE}\n+     * @param startPoint the start point for optimization\n      * @return the point/value pair giving the optimal value for objective function\n      * @exception ObjectiveException if the objective function throws one during\n      * the search\n      * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n-    PointValuePair optimize(final ObjectiveFunction f, final GoalType goalType)\n-        throws ObjectiveException, OptimizationException;\n+    PointValuePair optimize(ObjectiveFunction f, GoalType goalType,\n+                            double[] startPoint)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+   int getEvaluations();\n \n }\n--- a/src/java/org/apache/commons/math/optimization/PointValuePair.java\n+++ b/src/java/org/apache/commons/math/optimization/PointValuePair.java\n \n import java.io.Serializable;\n \n-\n /** \n  * This class holds a point and the value of an objective function at this point.\n  * <p>This is a simple immutable container.</p>\n public class PointValuePair implements Serializable {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 2254035971797977063L;\n+    private static final long serialVersionUID = 1003888396256744753L;\n \n     /** Point coordinates. */\n     private final double[] point;\n--- a/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import java.io.Serializable;\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.ObjectiveFunction;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.Optimizer;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.random.CorrelatedRandomVectorGenerator;\n-import org.apache.commons.math.random.JDKRandomGenerator;\n-import org.apache.commons.math.random.RandomGenerator;\n-import org.apache.commons.math.random.RandomVectorGenerator;\n-import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n-import org.apache.commons.math.random.UniformRandomGenerator;\n-import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n-import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n+import org.apache.commons.math.optimization.ObjectiveValueChecker;\n \n /** \n  * This class implements simplex-based direct search optimization\n  * (<a href=\"http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz\">Direct\n  * Search Methods: Once Scorned, Now Respectable</a>), they are used\n  * when either the computation of the derivative is impossible (noisy\n- * functions, unpredictable dicontinuities) or difficult (complexity,\n+ * functions, unpredictable discontinuities) or difficult (complexity,\n  * computation cost). In the first cases, rather than an optimum, a\n  * <em>not too bad</em> point is desired. In the latter cases, an\n  * optimum is desired but cannot be reasonably found. In all cases\n  * <p>Simplex-based direct search methods are based on comparison of\n  * the objective function values at the vertices of a simplex (which is a\n  * set of n+1 points in dimension n) that is updated by the algorithms\n- * steps.</p>\n- *\n- * <p>Optimization can be attempted either in single-start or in\n- * multi-start mode. Multi-start is a traditional way to try to avoid\n- * being trapped in a local optimum and miss the global optimum of a\n- * function. It can also be used to verify the convergence of an\n- * algorithm. The various multi-start-enabled <code>optimize</code>\n- * methods return the best optimum found after all starts, and the\n- * {@link #getOptimum getOptimum} method can be used to retrieve all\n- * optima from all starts (including the one already provided by the\n- * {@link #optimize(ObjectiveFunction, int, ConvergenceChecker, double[],\n- * double[]) optimize} method).</p>\n+ * steps.<p>\n+ *\n+ * <p>The initial configuration of the simplex can be set using either\n+ * {@link #setStartConfiguration(double[])} or {@link\n+ * #setStartConfiguration(double[][])}. If neither method has been called\n+ * before optimization is attempted, an explicit call to the first method\n+ * with all steps set to +1 is triggered, thus building a default\n+ * configuration from a unit hypercube. Each call to {@link\n+ * #optimize(ObjectiveFunction, GoalType, double[]) optimize} will reuse\n+ * the current start configuration and move it such that its first vertex\n+ * is at the provided start point of the optimization. If the same optimizer\n+ * is used to solve different problems and the number of parameters change,\n+ * the start configuration <em>must</em> be reset or a dimension mismatch\n+ * will occur.</p>\n+ *\n+ * <p>If {@link #setConvergenceChecker(ConvergenceChecker)} is not called,\n+ * a default {@link ObjectiveValueChecker} is used.</p>\n+ *\n+ * <p>Convergence is checked by providing the <em>worst</em> points of\n+ * previous and current simplex to the convergence checker, not the best ones.</p>\n  *\n  * <p>This class is the base class performing the boilerplate simplex\n  * initialization and handling. The simplex update by itself is\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public abstract class DirectSearchOptimizer implements Serializable {\n+public abstract class DirectSearchOptimizer implements Optimizer {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -3913013760494455466L;\n-\n-    /** Comparator for {@link PointValuePair} objects. */\n-    private static final Comparator<PointValuePair> PAIR_COMPARATOR =\n-        new Comparator<PointValuePair>() {\n-            public int compare(PointValuePair o1, PointValuePair o2) {\n-                if (o1 == null) {\n-                    return (o2 == null) ? 0 : +1;\n-                } else if (o2 == null) {\n-                    return -1;\n-                }\n-                return (o1.getValue() < o2.getValue()) ? -1 : ((o1 == o2) ? 0 : +1);\n-            }\n-        };\n+    private static final long serialVersionUID = 4299910390345933369L;\n \n     /** Simplex. */\n     protected PointValuePair[] simplex;\n     /** Objective function. */\n     private ObjectiveFunction f;\n \n-    /** Indicator for minimization. */\n-    private boolean minimizing;\n+    /** Convergence checker. */\n+    private ConvergenceChecker checker;\n \n     /** Number of evaluations already performed for the current start. */\n     private int evaluations;\n \n-    /** Number of evaluations already performed for all starts. */\n-    private int totalEvaluations;\n-\n-    /** Number of starts to go. */\n-    private int starts;\n-\n-    /** Random generator for multi-start. */\n-    private RandomVectorGenerator generator;\n-\n-    /** Found optima. */\n-    private PointValuePair[] optima;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Start simplex configuration. */\n+    private double[][] startConfiguration;\n \n     /** Simple constructor.\n      */\n     protected DirectSearchOptimizer() {\n-    }\n-\n-    /** Optimizes an objective function.\n-     * <p>The initial simplex is built from two vertices that are\n-     * considered to represent two opposite vertices of a box parallel\n-     * to the canonical axes of the space. The simplex is the subset of\n-     * vertices encountered while going from vertexA to vertexB\n-     * traveling along the box edges only. This can be seen as a scaled\n-     * regular simplex using the projected separation between the given\n-     * points as the scaling factor along each coordinate axis.</p>\n-     * <p>The optimization is performed in single-start mode.</p>\n-     * @param f objective function\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number will be checked <em>after</em>\n-     * complete simplices have been evaluated, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem)\n-     * @param checker object to use to check for convergence\n-     * @param minimizing if true, function must be minimize otherwise it must be maximized\n-     * @param vertexA first vertex\n-     * @param vertexB last vertex\n-     * @return the point/value pairs giving the optimal value for objective function\n-     * @exception ObjectiveException if the objective function throws one during\n-     * the search\n-     * @exception ConvergenceException if none of the starts did\n-     * converge (it is not thrown if at least one start did converge)\n-     */\n-    public PointValuePair optimize(final ObjectiveFunction f, final int maxEvaluations,\n-                                   final ConvergenceChecker checker, final boolean minimizing,\n-                                   final double[] vertexA, final double[] vertexB)\n-        throws ObjectiveException, ConvergenceException {\n-\n-        // set up optimizer\n-        buildSimplex(vertexA, vertexB);\n-        setSingleStart();\n-\n-        // compute optimum\n-        return optimize(f, maxEvaluations, checker, minimizing);\n-\n-    }\n-\n-    /** Optimizes an objective function.\n-     * <p>The initial simplex is built from two vertices that are\n-     * considered to represent two opposite vertices of a box parallel\n-     * to the canonical axes of the space. The simplex is the subset of\n-     * vertices encountered while going from vertexA to vertexB\n-     * traveling along the box edges only. This can be seen as a scaled\n-     * regular simplex using the projected separation between the given\n-     * points as the scaling factor along each coordinate axis.</p>\n-     * <p>The optimization is performed in multi-start mode.</p>\n-     * @param f objective function\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number will be checked <em>after</em>\n-     * complete simplices have been evaluated, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem)\n-     * @param checker object to use to check for convergence\n-     * @param minimizing if true, function must be minimize otherwise it must be maximized\n-     * @param vertexA first vertex\n-     * @param vertexB last vertex\n-     * @param starts number of starts to perform (including the\n-     * first one), multi-start is disabled if value is less than or\n-     * equal to 1\n-     * @param seed seed for the random vector generator\n-     * @return the point/value pairs giving the optimal value for objective function\n-     * @exception ObjectiveException if the obective function throws one during\n-     * the search\n-     * @exception ConvergenceException if none of the starts did\n-     * converge (it is not thrown if at least one start did converge)\n-     */\n-    public PointValuePair optimize(final ObjectiveFunction f, final int maxEvaluations,\n-                                   final ConvergenceChecker checker, final boolean minimizing,\n-                                   final double[] vertexA, final double[] vertexB,\n-                                   final int starts, final long seed)\n-        throws ObjectiveException, ConvergenceException {\n-\n-        // set up the simplex traveling around the box\n-        buildSimplex(vertexA, vertexB);\n-\n-        // we consider the simplex could have been produced by a generator\n-        // having its mean value at the center of the box, the standard\n-        // deviation along each axe being the corresponding half size\n-        final double[] mean              = new double[vertexA.length];\n-        final double[] standardDeviation = new double[vertexA.length];\n-        for (int i = 0; i < vertexA.length; ++i) {\n-            mean[i]              = 0.5 * (vertexA[i] + vertexB[i]);\n-            standardDeviation[i] = 0.5 * Math.abs(vertexA[i] - vertexB[i]);\n-        }\n-\n-        final RandomGenerator rg = new JDKRandomGenerator();\n-        rg.setSeed(seed);\n-        final UniformRandomGenerator urg = new UniformRandomGenerator(rg);\n-        final RandomVectorGenerator rvg =\n-            new UncorrelatedRandomVectorGenerator(mean, standardDeviation, urg);\n-        setMultiStart(starts, rvg);\n-\n-        // compute optimum\n-        return optimize(f, maxEvaluations, checker, minimizing);\n-\n-    }\n-\n-    /** Optimizes an objective function.\n-     * <p>The simplex is built from all its vertices.</p>\n-     * <p>The optimization is performed in single-start mode.</p>\n-     * @param f objective function\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number will be checked <em>after</em>\n-     * complete simplices have been evaluated, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem)\n-     * @param checker object to use to check for convergence\n-     * @param minimizing if true, function must be minimize otherwise it must be maximized\n-     * @param vertices array containing all vertices of the simplex\n-     * @return the point/value pairs giving the optimal value for objective function\n-     * @exception ObjectiveException if the objective function throws one during\n-     * the search\n-     * @exception ConvergenceException if none of the starts did\n-     * converge (it is not thrown if at least one start did converge)\n-     */\n-    public PointValuePair optimize(final ObjectiveFunction f, final int maxEvaluations,\n-                                   final ConvergenceChecker checker, final boolean minimizing,\n-                                   final double[][] vertices)\n-        throws ObjectiveException, ConvergenceException {\n-\n-        // set up optimizer\n-        buildSimplex(vertices);\n-        setSingleStart();\n-\n-        // compute optimum\n-        return optimize(f, maxEvaluations, checker, minimizing);\n-\n-    }\n-\n-    /** Optimizes an objective function.\n-     * <p>The simplex is built from all its vertices.</p>\n-     * <p>The optimization is performed in multi-start mode.</p>\n-     * @param f objective function\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number will be checked <em>after</em>\n-     * complete simplices have been evaluated, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem)\n-     * @param checker object to use to check for convergence\n-     * @param minimizing if true, function must be minimize otherwise it must be maximized\n-     * @param vertices array containing all vertices of the simplex\n-     * @param starts number of starts to perform (including the\n-     * first one), multi-start is disabled if value is less than or\n-     * equal to 1\n-     * @param seed seed for the random vector generator\n-     * @return the point/value pairs giving the optimal value for objective function\n-     * @exception NotPositiveDefiniteMatrixException if the vertices\n-     * array is degenerated\n-     * @exception ObjectiveException if the objective function throws one during\n-     * the search\n-     * @exception ConvergenceException if none of the starts did\n-     * converge (it is not thrown if at least one start did converge)\n-     */\n-    public PointValuePair optimize(final ObjectiveFunction f, final int maxEvaluations,\n-                                   final ConvergenceChecker checker, final boolean minimizing,\n-                                   final double[][] vertices,\n-                                   final int starts, final long seed)\n-        throws NotPositiveDefiniteMatrixException, ObjectiveException, ConvergenceException {\n-\n-        try {\n-            // store the points into the simplex\n-            buildSimplex(vertices);\n-\n-            // compute the statistical properties of the simplex points\n-            final VectorialMean meanStat = new VectorialMean(vertices[0].length);\n-            final VectorialCovariance covStat = new VectorialCovariance(vertices[0].length, true);\n-            for (int i = 0; i < vertices.length; ++i) {\n-                meanStat.increment(vertices[i]);\n-                covStat.increment(vertices[i]);\n-            }\n-            final double[] mean = meanStat.getResult();\n-            final RealMatrix covariance = covStat.getResult();\n-            \n-\n-            final RandomGenerator rg = new JDKRandomGenerator();\n-            rg.setSeed(seed);\n-            final RandomVectorGenerator rvg =\n-                new CorrelatedRandomVectorGenerator(mean,\n-                                                    covariance, 1.0e-12 * covariance.getNorm(),\n-                                                    new UniformRandomGenerator(rg));\n-            setMultiStart(starts, rvg);\n-\n-            // compute optimum\n-            return optimize(f, maxEvaluations, checker, minimizing);\n-\n-        } catch (DimensionMismatchException dme) {\n-            // this should not happen\n-            throw new MathRuntimeException(dme, \"unexpected exception caught\");\n-        }\n-\n-    }\n-\n-    /** Optimizes an objective function.\n-     * <p>The simplex is built randomly.</p>\n-     * <p>The optimization is performed in single-start mode.</p>\n-     * @param f objective function\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number will be checked <em>after</em>\n-     * complete simplices have been evaluated, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem)\n-     * @param checker object to use to check for convergence\n-     * @param minimizing if true, function must be minimize otherwise it must be maximized\n-     * @param generator random vector generator\n-     * @return the point/value pairs giving the optimal value for objective function\n-     * @exception ObjectiveException if the objective function throws one during\n-     * the search\n-     * @exception ConvergenceException if none of the starts did\n-     * converge (it is not thrown if at least one start did converge)\n-     */\n-    public PointValuePair optimize(final ObjectiveFunction f, final int maxEvaluations,\n-                                   final ConvergenceChecker checker, final boolean minimizing,\n-                                   final RandomVectorGenerator generator)\n-        throws ObjectiveException, ConvergenceException {\n-\n-        // set up optimizer\n-        buildSimplex(generator);\n-        setSingleStart();\n-\n-        // compute optimum\n-        return optimize(f, maxEvaluations, checker, minimizing);\n-\n-    }\n-\n-    /** Optimizes an objective function.\n-     * <p>The simplex is built randomly.</p>\n-     * <p>The optimization is performed in multi-start mode.</p>\n-     * @param f objective function\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number will be checked <em>after</em>\n-     * complete simplices have been evaluated, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem)\n-     * @param checker object to use to check for convergence\n-     * @param minimizing if true, function must be minimize otherwise it must be maximized\n-     * @param generator random vector generator\n-     * @param starts number of starts to perform (including the\n-     * first one), multi-start is disabled if value is less than or\n-     * equal to 1\n-     * @return the point/value pairs giving the optimal value for objective function\n-     * @exception ObjectiveException if the objective function throws one during\n-     * the search\n-     * @exception ConvergenceException if none of the starts did\n-     * converge (it is not thrown if at least one start did converge)\n-     */\n-    public PointValuePair optimize(final ObjectiveFunction f, final int maxEvaluations,\n-                                   final ConvergenceChecker checker, final boolean minimizing,\n-                                   final RandomVectorGenerator generator,\n-                                   final int starts)\n-        throws ObjectiveException, ConvergenceException {\n-\n-        // set up optimizer\n-        buildSimplex(generator);\n-        setMultiStart(starts, generator);\n-\n-        // compute optimum\n-        return optimize(f, maxEvaluations, checker, minimizing);\n-\n-    }\n-\n-    /** Build a simplex from two extreme vertices.\n-     * <p>The two vertices are considered to represent two opposite\n-     * vertices of a box parallel to the canonical axes of the\n-     * space. The simplex is the subset of vertices encountered while\n-     * going from vertexA to vertexB traveling along the box edges\n-     * only. This can be seen as a scaled regular simplex using the\n-     * projected separation between the given points as the scaling\n-     * factor along each coordinate axis.</p>\n-     * @param vertexA first vertex\n-     * @param vertexB last vertex\n-     */\n-    private void buildSimplex(final double[] vertexA, final double[] vertexB) {\n-\n-        final int n = vertexA.length;\n-        simplex = new PointValuePair[n + 1];\n-\n-        // set up the simplex traveling around the box\n-        for (int i = 0; i <= n; ++i) {\n-            final double[] vertex = new double[n];\n+        setConvergenceChecker(new ObjectiveValueChecker());\n+    }\n+\n+    /** Set start configuration for simplex.\n+     * <p>The start configuration for simplex is built from a box parallel to\n+     * the canonical axes of the space. The simplex is the subset of vertices\n+     * of a box parallel to the canonical axes. It is built as the path followed\n+     * while traveling from one vertex of the box to the diagonally opposite\n+     * vertex moving only along the box edges. The first vertex of the box will\n+     * be located at the start point of the optimization.</p>\n+     * <p>As an example, in dimension 3 a simplex has 4 vertices. Setting the\n+     * steps to (1, 10, 2) and the start point to (1, 1, 1) would imply the\n+     * start simplex would be: { (1, 1, 1), (2, 1, 1), (2, 11, 1), (2, 11, 3) }.\n+     * The first vertex would be set to the start point at (1, 1, 1) and the\n+     * last vertex would be set to the diagonally opposite vertex at (2, 11, 3).</p>\n+     * @param steps steps along the canonical axes representing box edges,\n+     * they may be negative but not null\n+     * @exception IllegalArgumentException if one step is null\n+     */\n+    public void setStartConfiguration(final double[] steps)\n+        throws IllegalArgumentException {\n+        // only the relative position of the n final vertices with respect\n+        // to the first one are stored\n+        final int n = steps.length;\n+        startConfiguration = new double[n][n];\n+        for (int i = 0; i < n; ++i) {\n+            final double[] vertexI = startConfiguration[i];\n+            for (int j = 0; j < i + 1; ++j) {\n+                if (steps[j] == 0.0) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"equals vertices {0} and {1} in simplex configuration\",\n+                            j, j + 1);\n+                }\n+                System.arraycopy(steps, 0, vertexI, 0, j + 1);\n+            }\n+        }\n+    }\n+\n+    /** Set start configuration for simplex.\n+     * <p>The real initial simplex will be set up by moving the reference\n+     * simplex such that its first point is located at the start point of the\n+     * optimization.</p>\n+     * @param referenceSimplex reference simplex\n+     * @exception IllegalArgumentException if the reference simplex does not\n+     * contain at least one point, or if there is a dimension mismatch\n+     * in the reference simplex or if one of its vertices is duplicated\n+     */\n+    public void setStartConfiguration(final double[][] referenceSimplex)\n+        throws IllegalArgumentException {\n+\n+        // only the relative position of the n final vertices with respect\n+        // to the first one are stored\n+        final int n = referenceSimplex.length - 1;\n+        if (n < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"simplex must contain at least one point\");\n+        }\n+        startConfiguration = new double[n][n];\n+        final double[] ref0 = referenceSimplex[0];\n+\n+        // vertices loop\n+        for (int i = 0; i < n + 1; ++i) {\n+\n+            final double[] refI = referenceSimplex[i];\n+\n+            // safety checks\n+            if (refI.length != n) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimension mismatch {0} != {1}\",\n+                        refI.length, n);\n+            }\n+            for (int j = 0; j < i; ++j) {\n+                final double[] refJ = referenceSimplex[j];\n+                boolean allEquals = true;\n+                for (int k = 0; k < n; ++k) {\n+                    if (refI[k] != refJ[k]) {\n+                        allEquals = false;\n+                        break;\n+                    }\n+                }\n+                if (allEquals) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"equals vertices {0} and {1} in simplex configuration\",\n+                            i, j);\n+                }\n+            }\n+\n+            // store vertex i position relative to vertex 0 position\n             if (i > 0) {\n-                System.arraycopy(vertexB, 0, vertex, 0, i);\n-            }\n-            if (i < n) {\n-                System.arraycopy(vertexA, i, vertex, i, n - i);\n-            }\n-            simplex[i] = new PointValuePair(vertex, Double.NaN);\n-        }\n-\n-    }\n-\n-    /** Build a simplex from all its points.\n-     * @param vertices array containing all vertices of the simplex\n-     */\n-    private void buildSimplex(final double[][] vertices) {\n-        final int n = vertices.length - 1;\n-        simplex = new PointValuePair[n + 1];\n-        for (int i = 0; i <= n; ++i) {\n-            simplex[i] = new PointValuePair(vertices[i], Double.NaN);\n-        }\n-    }\n-\n-    /** Build a simplex randomly.\n-     * @param generator random vector generator\n-     */\n-    private void buildSimplex(final RandomVectorGenerator generator) {\n-\n-        // use first vector size to compute the number of points\n-        final double[] vertex = generator.nextVector();\n-        final int n = vertex.length;\n-        simplex = new PointValuePair[n + 1];\n-        simplex[0] = new PointValuePair(vertex, Double.NaN);\n-\n-        // fill up the vertex\n-        for (int i = 1; i <= n; ++i) {\n-            simplex[i] = new PointValuePair(generator.nextVector(), Double.NaN);\n-        }\n-\n-    }\n-\n-    /** Set up single-start mode.\n-     */\n-    private void setSingleStart() {\n-        starts    = 1;\n-        generator = null;\n-        optima    = null;\n-    }\n-\n-    /** Set up multi-start mode.\n-     * @param starts number of starts to perform (including the\n-     * first one), multi-start is disabled if value is less than or\n-     * equal to 1\n-     * @param generator random vector generator to use for restarts\n-     */\n-    private void setMultiStart(final int starts, final RandomVectorGenerator generator) {\n-        if (starts < 2) {\n-            this.starts    = 1;\n-            this.generator = null;\n-            optima         = null;\n-        } else {\n-            this.starts    = starts;\n-            this.generator = generator;\n-            optima         = null;\n-        }\n-    }\n-\n-    /** Get all the optima found during the last call to {@link\n-     * #optimize(ObjectiveFunction, int, ConvergenceChecker, double[], double[])\n-     * minimize}.\n-     * <p>The optimizer stores all the optima found during a set of\n-     * restarts when multi-start mode is enabled. The {@link\n-     * #optimize(ObjectiveFunction, int, ConvergenceChecker, double[], double[])\n-     * optimize} method returns the best point only. This method\n-     * returns all the points found at the end of each starts, including\n-     * the best one already returned by the {@link #optimize(ObjectiveFunction,\n-     * int, ConvergenceChecker, double[], double[]) optimize} method.\n-     * The array as one element for each start as specified in the constructor\n-     * (it has one element only if optimizer has been set up for single-start).</p>\n-     * <p>The array containing the optimum is ordered with the results\n-     * from the runs that did converge first, sorted from lowest to\n-     * highest objective value if minimizing (from highest to lowest if maximizing),\n-     * and null elements corresponding to the runs that did not converge. This means\n-     * all elements will be null if the {@link #optimize(ObjectiveFunction, int,\n-     * ConvergenceChecker, double[], double[]) optimize} method did throw a {@link\n-     * ConvergenceException ConvergenceException}). This also means that if the first\n-     * element is non null, it is the best point found accross all starts.</p>\n-     * @return array containing the optima, or null if {@link\n-     * #optimize(ObjectiveFunction, int, ConvergenceChecker, double[], double[])\n-     * optimize} has not been called\n-     */\n-    public PointValuePair[] getOptima() {\n-        return (PointValuePair[]) optima.clone();\n-    }\n-\n-    /** Optimizes an objective function.\n-     * @param f objective function\n-     * @param maxEvaluations maximal number of function calls for each\n-     * start (note that the number will be checked <em>after</em>\n-     * complete simplices have been evaluated, this means that in some\n-     * cases this number will be exceeded by a few units, depending on\n-     * the dimension of the problem)\n-     * @param checker object to use to check for convergence\n-     * @param minimizing if true, function must be minimize otherwise it must be maximized\n-     * @return the point/value pairs giving the optimal value for objective function\n-     * @exception ObjectiveException if the objective function throws one during\n-     * the search\n-     * @exception ConvergenceException if none of the starts did\n-     * converge (it is not thrown if at least one start did converge)\n-     */\n-    private PointValuePair optimize(final ObjectiveFunction f, final int maxEvaluations,\n-                                   final ConvergenceChecker checker, final boolean minimizing)\n-        throws ObjectiveException, ConvergenceException {\n-\n-        this.f          = f;\n-        this.minimizing = minimizing;\n-        optima = new PointValuePair[starts];\n-        totalEvaluations = 0;\n-\n-        // multi-start loop\n-        for (int i = 0; i < starts; ++i) {\n-\n-            evaluations = 0;\n-            evaluateSimplex();\n-\n-            for (boolean loop = true; loop;) {\n-                if (checker.converged(simplex)) {\n+                final double[] confI = startConfiguration[i - 1];\n+                for (int k = 0; k < n; ++k) {\n+                    confI[k] = refI[k] - ref0[k];\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ConvergenceChecker checker) {\n+        this.checker = checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public PointValuePair optimize(final ObjectiveFunction f, final GoalType goalType,\n+                                   final double[] startPoint)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+\n+        if (startConfiguration == null) {\n+            // no initial configuration has been set up for simplex\n+            // build a default one from a unit hypercube\n+            final double[] unit = new double[startPoint.length];\n+            Arrays.fill(unit, 1.0);\n+            setStartConfiguration(unit);\n+        }\n+\n+        this.f = f;\n+        final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\n+            public int compare(final PointValuePair o1, final PointValuePair o2) {\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        };\n+\n+        // initialize search\n+        evaluations = 0;\n+        buildSimplex(startPoint);\n+        evaluateSimplex(comparator);\n+\n+        PointValuePair[] previous = new PointValuePair[simplex.length];\n+        int iterations = 0;\n+        while (evaluations <= maxEvaluations) {\n+\n+            if (++iterations > 1) {\n+                boolean converged = true;\n+                for (int i = 0; i < simplex.length; ++i) {\n+                    converged &= checker.converged(iterations, previous[i], simplex[i]);\n+                }\n+                if (converged) {\n                     // we have found an optimum\n-                    optima[i] = simplex[0];\n-                    loop = false;\n-                } else if (evaluations >= maxEvaluations) {\n-                    // this start did not converge, try a new one\n-                    optima[i] = null;\n-                    loop = false;\n-                } else {\n-                    iterateSimplex();\n-                }\n-            }\n-\n-            totalEvaluations += evaluations;\n-\n-            if (i < (starts - 1)) {\n-                // restart\n-                buildSimplex(generator);\n-            }\n-\n-        }\n-\n-        // sort the optima from best to poorest, followed by\n-        // null elements\n-        Arrays.sort(optima, PAIR_COMPARATOR);\n-\n-        if (!minimizing) {\n-            // revert objective function sign to match user original definition\n-            for (int i = 0; i < optima.length; ++i) {\n-                final PointValuePair current = optima[i];\n-                if (current != null) {\n-                    optima[i] = new PointValuePair(current.getPoint(), -current.getValue());\n-                }\n-            }\n-        }\n-\n-        // return the found point given the best objective function value\n-        if (optima[0] == null) {\n-            throw new ConvergenceException(\n-                    \"none of the {0} start points lead to convergence\",\n-                    starts);\n-        }\n-        return optima[0];\n-\n-    }\n-\n-    /** Get the total number of evaluations of the objective function.\n-     * <p>\n-     * The total number of evaluations includes all evaluations for all\n-     * starts if in optimization was done in multi-start mode.\n-     * </p>\n-     * @return total number of evaluations of the objective function\n-     */\n-    public int getTotalEvaluations() {\n-        return totalEvaluations;\n+                    return simplex[0];\n+                }\n+            }\n+\n+            // we still need to search\n+            System.arraycopy(simplex, 0, previous, 0, simplex.length);\n+            iterateSimplex(comparator);\n+\n+        }\n+\n+        throw new OptimizationException(\n+                \"maximal number of evaluations exceeded ({0})\",\n+                evaluations);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n     }\n \n     /** Compute the next simplex of the algorithm.\n+     * @param comparator comparator to use to sort simplex vertices from best to worst\n      * @exception ObjectiveException if the function cannot be evaluated at\n      * some point\n-     */\n-    protected abstract void iterateSimplex() throws ObjectiveException;\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    protected abstract void iterateSimplex(final Comparator<PointValuePair> comparator)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n \n     /** Evaluate the objective function on one point.\n      * <p>A side effect of this method is to count the number of\n      * @param x point on which the objective function should be evaluated\n      * @return objective function value at the given point\n      * @exception ObjectiveException if no value can be computed for the parameters\n-     */\n-    protected double evaluate(final double[] x) throws ObjectiveException {\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    protected double evaluate(final double[] x)\n+        throws ObjectiveException, IllegalArgumentException {\n         evaluations++;\n-        return minimizing ? f.objective(x) : -f.objective(x);\n+        return f.objective(x);\n+    }\n+\n+    /** Build an initial simplex.\n+     * @param startPoint the start point for optimization\n+     * @exception IllegalArgumentException\n+     */\n+    private void buildSimplex(final double[] startPoint)\n+        throws IllegalArgumentException {\n+\n+        final int n = startPoint.length;\n+        if (n != startConfiguration.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimension mismatch {0} != {1}\",\n+                    n, simplex.length);\n+        }\n+\n+        // set first vertex\n+        simplex = new PointValuePair[n + 1];\n+        simplex[0] = new PointValuePair(startPoint, Double.NaN);\n+\n+        // set remaining vertices\n+        for (int i = 0; i < n; ++i) {\n+            final double[] confI   = startConfiguration[i];\n+            final double[] vertexI = new double[n];\n+            for (int k = 0; k < n; ++k) {\n+                vertexI[k] = startPoint[k] + confI[k];\n+            }\n+            simplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n+        }\n+\n     }\n \n     /** Evaluate all the non-evaluated points of the simplex.\n+     * @param comparator comparator to use to sort simplex vertices from best to worst\n      * @exception ObjectiveException if no value can be computed for the parameters\n      */\n-    protected void evaluateSimplex() throws ObjectiveException {\n+    protected void evaluateSimplex(final Comparator<PointValuePair> comparator)\n+        throws ObjectiveException {\n \n         // evaluate the objective function at all non-evaluated simplex points\n         for (int i = 0; i < simplex.length; ++i) {\n-            PointValuePair pair = simplex[i];\n-            if (Double.isNaN(pair.getValue())) {\n-                simplex[i] = new PointValuePair(pair.getPoint(), evaluate(pair.getPoint()));\n-            }\n-        }\n-\n-        // sort the simplex from best to poorest\n-        Arrays.sort(simplex, PAIR_COMPARATOR);\n+            final PointValuePair vertex = simplex[i];\n+            final double[] point = vertex.getPoint();\n+            if (Double.isNaN(vertex.getValue())) {\n+                simplex[i] = new PointValuePair(point, evaluate(point));\n+            }\n+        }\n+\n+        // sort the simplex from best to worst\n+        Arrays.sort(simplex, comparator);\n \n     }\n \n     /** Replace the worst point of the simplex by a new point.\n      * @param pointValuePair point to insert\n-     */\n-    protected void replaceWorstPoint(PointValuePair pointValuePair) {\n+     * @param comparator comparator to use to sort simplex vertices from best to worst\n+     */\n+    protected void replaceWorstPoint(PointValuePair pointValuePair,\n+                                     final Comparator<PointValuePair> comparator) {\n         int n = simplex.length - 1;\n         for (int i = 0; i < n; ++i) {\n-            if (simplex[i].getValue() > pointValuePair.getValue()) {\n+            if (comparator.compare(simplex[i], pointValuePair) > 0) {\n                 PointValuePair tmp = simplex[i];\n-                simplex[i]        = pointValuePair;\n+                simplex[i]         = pointValuePair;\n                 pointValuePair     = tmp;\n             }\n         }\n--- a/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n \n package org.apache.commons.math.optimization.direct;\n \n+import java.util.Comparator;\n+\n import org.apache.commons.math.optimization.ObjectiveException;\n+import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.PointValuePair;\n \n /** \n         this.gamma = gamma;\n     }\n \n-    /** Compute the next simplex of the algorithm.\n-     * @exception ObjectiveException if the function cannot be evaluated at\n-     * some point\n-     */\n-    protected void iterateSimplex() throws ObjectiveException {\n+    /** {@inheritDoc} */\n+    protected void iterateSimplex(final Comparator<PointValuePair> comparator)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n \n-        while (true) {\n+        final int max = getMaxEvaluations();\n+        while (getEvaluations() < max) {\n \n             // save the original vertex\n             final PointValuePair[] original = simplex;\n-            final double originalValue = original[0].getValue();\n+            final PointValuePair best = original[0];\n \n             // perform a reflection step\n-            final double reflectedValue = evaluateNewSimplex(original, 1.0);\n-            if (reflectedValue < originalValue) {\n+            final PointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n+            if (comparator.compare(reflected, best) < 0) {\n \n                 // compute the expanded simplex\n-                final PointValuePair[] reflected = simplex;\n-                final double expandedValue = evaluateNewSimplex(original, khi);\n-                if (reflectedValue <= expandedValue) {\n+                final PointValuePair[] reflectedSimplex = simplex;\n+                final PointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n+                if (comparator.compare(reflected, expanded) <= 0) {\n                     // accept the reflected simplex\n-                    simplex = reflected;\n+                    simplex = reflectedSimplex;\n                 }\n \n                 return;\n             }\n \n             // compute the contracted simplex\n-            final double contractedValue = evaluateNewSimplex(original, gamma);\n-            if (contractedValue < originalValue) {\n+            final PointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+            if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n                 return;\n             }\n \n         }\n \n+        throw new OptimizationException(\n+                \"maximal number of evaluations exceeded ({0})\",\n+                getEvaluations());\n+\n     }\n \n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)\n      * @param coeff linear coefficient\n-     * @return smallest value in the transformed simplex\n+     * @param comparator comparator to use to sort simplex vertices from best to poorest\n+     * @return best point in the transformed simplex\n      * @exception ObjectiveException if the function cannot be evaluated at\n      * some point\n      */\n-    private double evaluateNewSimplex(final PointValuePair[] original,\n-                                      final double coeff)\n+    private PointValuePair evaluateNewSimplex(final PointValuePair[] original,\n+                                              final double coeff,\n+                                              final Comparator<PointValuePair> comparator)\n         throws ObjectiveException {\n \n         final double[] xSmallest = original[0].getPoint();\n         }\n \n         // evaluate it\n-        evaluateSimplex();\n-        return simplex[0].getValue();\n+        evaluateSimplex(comparator);\n+        return simplex[0];\n \n     }\n \n--- a/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/NelderMead.java\n  */\n \n package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Comparator;\n \n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.PointValuePair;\n     }\n \n     /** {@inheritDoc} */\n-    protected void iterateSimplex() throws ObjectiveException {\n+    protected void iterateSimplex(final Comparator<PointValuePair> comparator)\n+        throws ObjectiveException {\n \n         // the simplex has n+1 point if dimension is n\n         final int n = simplex.length - 1;\n \n         // interesting values\n-        final double   smallest      = simplex[0].getValue();\n-        final double   secondLargest = simplex[n-1].getValue();\n-        final double   largest       = simplex[n].getValue();\n-        final double[] xLargest      = simplex[n].getPoint();\n+        final PointValuePair best       = simplex[0];\n+        final PointValuePair secondBest = simplex[n-1];\n+        final PointValuePair worst      = simplex[n];\n+        final double[] xWorst = worst.getPoint();\n \n         // compute the centroid of the best vertices\n         // (dismissing the worst point at index n)\n         // compute the reflection point\n         final double[] xR = new double[n];\n         for (int j = 0; j < n; ++j) {\n-            xR[j] = centroid[j] + rho * (centroid[j] - xLargest[j]);\n+            xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n         }\n-        final double valueR = evaluate(xR);\n+        final PointValuePair reflected = new PointValuePair(xR, evaluate(xR));\n \n-        if ((smallest <= valueR) && (valueR < secondLargest)) {\n+        if ((comparator.compare(best, reflected) <= 0) &&\n+            (comparator.compare(reflected, secondBest) < 0)) {\n \n             // accept the reflected point\n-            replaceWorstPoint(new PointValuePair(xR, valueR));\n+            replaceWorstPoint(reflected, comparator);\n \n-        } else if (valueR < smallest) {\n+        } else if (comparator.compare(reflected, best) < 0) {\n \n             // compute the expansion point\n             final double[] xE = new double[n];\n             for (int j = 0; j < n; ++j) {\n                 xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n             }\n-            final double valueE = evaluate(xE);\n+            final PointValuePair expanded = new PointValuePair(xE, evaluate(xE));\n \n-            if (valueE < valueR) {\n+            if (comparator.compare(expanded, reflected) < 0) {\n                 // accept the expansion point\n-                replaceWorstPoint(new PointValuePair(xE, valueE));\n+                replaceWorstPoint(expanded, comparator);\n             } else {\n                 // accept the reflected point\n-                replaceWorstPoint(new PointValuePair(xR, valueR));\n+                replaceWorstPoint(reflected, comparator);\n             }\n \n         } else {\n \n-            if (valueR < largest) {\n+            if (comparator.compare(reflected, worst) < 0) {\n \n                 // perform an outside contraction\n                 final double[] xC = new double[n];\n                 for (int j = 0; j < n; ++j) {\n                     xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n                 }\n-                final double valueC = evaluate(xC);\n+                final PointValuePair outContracted = new PointValuePair(xC, evaluate(xC));\n \n-                if (valueC <= valueR) {\n+                if (comparator.compare(outContracted, reflected) <= 0) {\n                     // accept the contraction point\n-                    replaceWorstPoint(new PointValuePair(xC, valueC));\n+                    replaceWorstPoint(outContracted, comparator);\n                     return;\n                 }\n \n                 // perform an inside contraction\n                 final double[] xC = new double[n];\n                 for (int j = 0; j < n; ++j) {\n-                    xC[j] = centroid[j] - gamma * (centroid[j] - xLargest[j]);\n+                    xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n                 }\n-                final double valueC = evaluate(xC);\n+                final PointValuePair inContracted = new PointValuePair(xC, evaluate(xC));\n \n-                if (valueC < largest) {\n+                if (comparator.compare(inContracted, worst) < 0) {\n                     // accept the contraction point\n-                    replaceWorstPoint(new PointValuePair(xC, valueC));\n+                    replaceWorstPoint(inContracted, comparator);\n                     return;\n                 }\n \n                 }\n                 simplex[i] = new PointValuePair(x, Double.NaN);\n             }\n-            evaluateSimplex();\n+            evaluateSimplex(comparator);\n \n         }\n \n--- a/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException;\n-import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.ObjectiveFunction;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.ConvergenceException;\n-\n-import junit.framework.*;\n+import org.apache.commons.math.optimization.ObjectiveValueChecker;\n \n public class MultiDirectionalTest\n   extends TestCase {\n             }\n       };\n       try {\n-          new MultiDirectional(1.9, 0.4).optimize(wrong, 10, new ValueChecker(1.0e-3), true,\n-                                                  new double[] { -0.5 }, new double[] { 0.5 });\n+          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n           fail(\"an exception should have been thrown\");\n       } catch (ObjectiveException ce) {\n           // expected behavior\n           fail(\"wrong exception caught: \" + e.getMessage());\n       } \n       try {\n-          new MultiDirectional(1.9, 0.4).optimize(wrong, 10, new ValueChecker(1.0e-3), true,\n-                  new double[] { 0.5 }, new double[] { 1.5 });\n+          MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n           fail(\"an exception should have been thrown\");\n       } catch (ObjectiveException ce) {\n           // expected behavior\n           public double objective(double[] variables) {\n               final double x = variables[0];\n               final double y = variables[1];\n-              return Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y);\n+              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n           }\n       };\n \n-      MultiDirectional md = new MultiDirectional();\n+      MultiDirectional optimizer = new MultiDirectional();\n+      optimizer.setConvergenceChecker(new ObjectiveValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setMaxEvaluations(200);\n+      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n+      PointValuePair optimum;\n \n       // minimization\n-      md.optimize(fourExtrema, 200, new ValueChecker(1.0e-8), true,\n-                  new double[] { -4, -2 }, new double[] { 1, 2 }, 10, 38821113105892l);\n-      PointValuePair[] optima = md.getOptima();\n-      assertEquals(10, optima.length);\n-      int localCount  = 0;\n-      int globalCount = 0;\n-      for (PointValuePair optimum : optima) {\n-          if (optimum != null) {\n-              if (optimum.getPoint()[0] < 0) {\n-                  // this should be the local minimum\n-                  ++localCount;\n-                  assertEquals(xM,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yP,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXmYp, optimum.getValue(),     3.0e-8);\n-              } else {\n-                  // this should be the global minimum\n-                  ++globalCount;\n-                  assertEquals(xP,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yM,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXpYm, optimum.getValue(),     3.0e-8);              \n-              }\n-          }\n-      }\n-      assertTrue(localCount  > 0);\n-      assertTrue(globalCount > 0);\n-      assertTrue(md.getTotalEvaluations() > 1400);\n-      assertTrue(md.getTotalEvaluations() < 1700);\n-\n-      // minimization\n-      md.optimize(fourExtrema, 200, new ValueChecker(1.0e-8), false,\n-                  new double[] { -3.5, -1 }, new double[] { 0.5, 1.5 }, 10, 38821113105892l);\n-      optima = md.getOptima();\n-      assertEquals(10, optima.length);\n-      localCount  = 0;\n-      globalCount = 0;\n-      for (PointValuePair optimum : optima) {\n-          if (optimum != null) {\n-              if (optimum.getPoint()[0] < 0) {\n-                  // this should be the local maximum\n-                  ++localCount;\n-                  assertEquals(xM,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yM,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXmYm, optimum.getValue(),     4.0e-8);\n-              } else {\n-                  // this should be the global maximum\n-                  ++globalCount;\n-                  assertEquals(xP,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yP,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXpYp, optimum.getValue(),     4.0e-8);              \n-              }\n-          }\n-      }\n-      assertTrue(localCount  > 0);\n-      assertTrue(globalCount > 0);\n-      assertTrue(md.getTotalEvaluations() > 1400);\n-      assertTrue(md.getTotalEvaluations() < 1700);\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\n+      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n+      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n+\n+      // maximization\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\n+      assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\n+      assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n+      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 120);\n+      assertTrue(optimizer.getEvaluations() < 150);\n \n   }\n \n       };\n \n     count = 0;\n+    MultiDirectional optimizer = new MultiDirectional();\n+    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1, 1.0e-3));\n+    optimizer.setMaxEvaluations(100);\n+    optimizer.setStartConfiguration(new double[][] {\n+            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+    });\n     PointValuePair optimum =\n-      new MultiDirectional().optimize(rosenbrock, 100, new ValueChecker(1.0e-3), true,\n-                                      new double[][] {\n-                                        { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n-                                      });\n-\n-    assertTrue(count > 60);\n-    assertTrue(optimum.getValue() > 0.01);\n+        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+\n+    assertEquals(count, optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 70);\n+    assertTrue(optimizer.getEvaluations() < 100);\n+    assertTrue(optimum.getValue() > 1.0e-2);\n \n   }\n \n       };\n \n     count = 0;\n+    MultiDirectional optimizer = new MultiDirectional();\n+    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1.0, 1.0e-3));\n+    optimizer.setMaxEvaluations(1000);\n     PointValuePair optimum =\n-      new MultiDirectional().optimize(powell, 1000, new ValueChecker(1.0e-3), true,\n-                                      new double[] {  3.0, -1.0, 0.0, 1.0 },\n-                                      new double[] {  4.0,  0.0, 1.0, 2.0 });\n-    assertTrue(count > 850);\n-    assertTrue(optimum.getValue() > 0.015);\n-\n-  }\n-\n-  private static class ValueChecker implements ConvergenceChecker {\n-\n-    public ValueChecker(double threshold) {\n-      this.threshold = threshold;\n-    }\n-\n-    public boolean converged(PointValuePair[] simplex) {\n-      PointValuePair smallest = simplex[0];\n-      PointValuePair largest  = simplex[simplex.length - 1];\n-      return (largest.getValue() - smallest.getValue()) < threshold;\n-    }\n-\n-    private double threshold;\n-\n-  };\n+      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+    assertEquals(count, optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 800);\n+    assertTrue(optimizer.getEvaluations() < 900);\n+    assertTrue(optimum.getValue() > 1.0e-2);\n+\n+  }\n \n   public static Test suite() {\n     return new TestSuite(MultiDirectionalTest.class);\n--- a/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException;\n-import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.ObjectiveFunction;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.random.JDKRandomGenerator;\n-import org.apache.commons.math.random.RandomGenerator;\n-import org.apache.commons.math.random.RandomVectorGenerator;\n-import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n-import org.apache.commons.math.random.UniformRandomGenerator;\n-\n-import junit.framework.*;\n+import org.apache.commons.math.optimization.ObjectiveValueChecker;\n \n public class NelderMeadTest\n   extends TestCase {\n   public void testObjectiveExceptions() throws ConvergenceException {\n       ObjectiveFunction wrong =\n           new ObjectiveFunction() {\n-            private static final long serialVersionUID = 2624035220997628868L;\n+            private static final long serialVersionUID = 4751314470965489371L;\n             public double objective(double[] x) throws ObjectiveException {\n                 if (x[0] < 0) {\n                     throw new ObjectiveException(\"{0}\", \"oops\");\n             }\n       };\n       try {\n-          new NelderMead(0.9, 1.9, 0.4, 0.6).optimize(wrong, 10, new ValueChecker(1.0e-3), true,\n-                                                      new double[] { -0.5 }, new double[] { 0.5 });\n+          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n           fail(\"an exception should have been thrown\");\n       } catch (ObjectiveException ce) {\n           // expected behavior\n           fail(\"wrong exception caught: \" + e.getMessage());\n       } \n       try {\n-          new NelderMead(0.9, 1.9, 0.4, 0.6).optimize(wrong, 10, new ValueChecker(1.0e-3), true,\n-                                                      new double[] { 0.5 }, new double[] { 1.5 });\n+          NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n+          optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n           fail(\"an exception should have been thrown\");\n       } catch (ObjectiveException ce) {\n           // expected behavior\n       final double valueXpYm = -0.7290400707055187115322; // global minimum\n       final double valueXpYp = -valueXpYm;                // global maximum\n       ObjectiveFunction fourExtrema = new ObjectiveFunction() {\n-        private static final long serialVersionUID = -7039124064449091152L;\n-        public double objective(double[] variables) {\n+          private static final long serialVersionUID = -7039124064449091152L;\n+          public double objective(double[] variables) {\n               final double x = variables[0];\n               final double y = variables[1];\n-              return Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y);\n+              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n           }\n       };\n \n-      NelderMead nm = new NelderMead();\n+      NelderMead optimizer = new NelderMead();\n+      optimizer.setConvergenceChecker(new ObjectiveValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setMaxEvaluations(100);\n+      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n+      PointValuePair optimum;\n \n       // minimization\n-      nm.optimize(fourExtrema, 100, new ValueChecker(1.0e-8), true,\n-                  new double[] { -5, -5 }, new double[] { 5, 5 }, 10, 38821113105892l);\n-      PointValuePair[] optima = nm.getOptima();\n-      assertEquals(10, optima.length);\n-      int localCount  = 0;\n-      int globalCount = 0;\n-      for (PointValuePair optimum : optima) {\n-          if (optimum != null) {\n-              if (optimum.getPoint()[0] < 0) {\n-                  // this should be the local minimum\n-                  ++localCount;\n-                  assertEquals(xM,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yP,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXmYp, optimum.getValue(),     2.0e-8);\n-              } else {\n-                  // this should be the global minimum\n-                  ++globalCount;\n-                  assertEquals(xP,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yM,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXpYm, optimum.getValue(),     2.0e-8);              \n-              }\n-          }\n-      }\n-      assertTrue(localCount  > 0);\n-      assertTrue(globalCount > 0);\n-      assertTrue(nm.getTotalEvaluations() > 600);\n-      assertTrue(nm.getTotalEvaluations() < 800);\n-\n-      // minimization\n-      nm.optimize(fourExtrema, 100, new ValueChecker(1.0e-8), false,\n-                  new double[] { -5, -5 }, new double[] { 5, 5 }, 10, 38821113105892l);\n-      optima = nm.getOptima();\n-      assertEquals(10, optima.length);\n-      localCount  = 0;\n-      globalCount = 0;\n-      for (PointValuePair optimum : optima) {\n-          if (optimum != null) {\n-              if (optimum.getPoint()[0] < 0) {\n-                  // this should be the local maximum\n-                  ++localCount;\n-                  assertEquals(xM,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yM,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXmYm, optimum.getValue(),     2.0e-8);\n-              } else {\n-                  // this should be the global maximum\n-                  ++globalCount;\n-                  assertEquals(xP,        optimum.getPoint()[0], 1.0e-3);\n-                  assertEquals(yP,        optimum.getPoint()[1], 1.0e-3);\n-                  assertEquals(valueXpYp, optimum.getValue(),     2.0e-8);              \n-              }\n-          }\n-      }\n-      assertTrue(localCount  > 0);\n-      assertTrue(globalCount > 0);\n-      assertTrue(nm.getTotalEvaluations() > 600);\n-      assertTrue(nm.getTotalEvaluations() < 800);\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 2.0e-7);\n+      assertEquals(yP,        optimum.getPoint()[1], 2.0e-5);\n+      assertEquals(valueXmYp, optimum.getValue(),    6.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 5.0e-6);\n+      assertEquals(yM,        optimum.getPoint()[1], 6.0e-6);\n+      assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);              \n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n+\n+      // maximization\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n+      assertEquals(xM,        optimum.getPoint()[0], 1.0e-5);\n+      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n+      assertEquals(valueXmYm, optimum.getValue(),    3.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n+\n+      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n+      assertEquals(xP,        optimum.getPoint()[0], 4.0e-6);\n+      assertEquals(yP,        optimum.getPoint()[1], 5.0e-6);\n+      assertEquals(valueXpYp, optimum.getValue(),    7.0e-12);\n+      assertTrue(optimizer.getEvaluations() > 60);\n+      assertTrue(optimizer.getEvaluations() < 90);\n \n   }\n \n   public void testRosenbrock()\n-    throws ObjectiveException, ConvergenceException, NotPositiveDefiniteMatrixException {\n+    throws ObjectiveException, ConvergenceException {\n \n     ObjectiveFunction rosenbrock =\n       new ObjectiveFunction() {\n-        private static final long serialVersionUID = -7039124064449091152L;\n+        private static final long serialVersionUID = -9044950469615237490L;\n         public double objective(double[] x) {\n           ++count;\n           double a = x[1] - x[0] * x[0];\n       };\n \n     count = 0;\n-    NelderMead nm = new NelderMead();\n-    try {\n-      nm.optimize(rosenbrock, 100, new ValueChecker(1.0e-3), true,\n-                  new double[][] {\n-                    { -1.2, 1.0 }, { 3.5, -2.3 }, { 0.4, 1.5 }\n-                  }, 1, 5384353l);\n-      fail(\"an exception should have been thrown\");\n-    } catch (ConvergenceException ce) {\n-        // expected behavior\n-    } catch (Exception e) {\n-        e.printStackTrace(System.err);\n-        fail(\"wrong exception caught: \" + e.getMessage());\n-    }\n-\n-    count = 0;\n+    NelderMead optimizer = new NelderMead();\n+    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1, 1.0e-3));\n+    optimizer.setMaxEvaluations(100);\n+    optimizer.setStartConfiguration(new double[][] {\n+            { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+    });\n     PointValuePair optimum =\n-        nm.optimize(rosenbrock, 100, new ValueChecker(1.0e-3), true,\n-                    new double[][] {\n-                      { -1.2, 1.0 }, { 0.9, 1.2 }, { 3.5, -2.3 }\n-                    }, 10, 1642738l);\n-\n-    assertTrue(count > 700);\n-    assertTrue(count < 800);\n-    assertEquals(0.0, optimum.getValue(), 5.0e-5);\n-    assertEquals(1.0, optimum.getPoint()[0], 0.01);\n-    assertEquals(1.0, optimum.getPoint()[1], 0.01);\n-\n-    PointValuePair[] minima = nm.getOptima();\n-    assertEquals(10, minima.length);\n-    assertNotNull(minima[0]);\n-    assertNull(minima[minima.length - 1]);\n-    for (int i = 0; i < minima.length; ++i) {\n-        if (minima[i] == null) {\n-            if ((i + 1) < minima.length) {\n-                assertTrue(minima[i+1] == null);\n-            }\n-        } else {\n-            if (i > 0) {\n-                assertTrue(minima[i-1].getValue() <= minima[i].getValue());\n-            }\n-        }\n-    }\n-\n-    RandomGenerator rg = new JDKRandomGenerator();\n-    rg.setSeed(64453353l);\n-    RandomVectorGenerator rvg =\n-        new UncorrelatedRandomVectorGenerator(new double[] { 0.9, 1.1 },\n-                                              new double[] { 0.2, 0.2 },\n-                                              new UniformRandomGenerator(rg));\n-    optimum =\n-        nm.optimize(rosenbrock, 100, new ValueChecker(1.0e-3), true, rvg);\n-    assertEquals(0.0, optimum.getValue(), 2.0e-4);\n-    optimum =\n-        nm.optimize(rosenbrock, 100, new ValueChecker(1.0e-3), true, rvg, 3);\n-    assertEquals(0.0, optimum.getValue(), 3.0e-5);\n+        optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+\n+    assertEquals(count, optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 40);\n+    assertTrue(optimizer.getEvaluations() < 50);\n+    assertTrue(optimum.getValue() < 8.0e-4);\n \n   }\n \n \n     ObjectiveFunction powell =\n       new ObjectiveFunction() {\n-        private static final long serialVersionUID = -7681075710859391520L;\n+        private static final long serialVersionUID = -832162886102041840L;\n         public double objective(double[] x) {\n           ++count;\n           double a = x[0] + 10 * x[1];\n       };\n \n     count = 0;\n-    NelderMead nm = new NelderMead();\n+    NelderMead optimizer = new NelderMead();\n+    optimizer.setConvergenceChecker(new ObjectiveValueChecker(-1.0, 1.0e-3));\n+    optimizer.setMaxEvaluations(200);\n     PointValuePair optimum =\n-      nm.optimize(powell, 200, new ValueChecker(1.0e-3), true,\n-                  new double[] {  3.0, -1.0, 0.0, 1.0 },\n-                  new double[] {  4.0,  0.0, 1.0, 2.0 },\n-                  1, 1642738l);\n-    assertTrue(count < 150);\n-    assertEquals(0.0, optimum.getValue(), 6.0e-4);\n-    assertEquals(0.0, optimum.getPoint()[0], 0.07);\n-    assertEquals(0.0, optimum.getPoint()[1], 0.07);\n-    assertEquals(0.0, optimum.getPoint()[2], 0.07);\n-    assertEquals(0.0, optimum.getPoint()[3], 0.07);\n-\n-  }\n-\n-  private static class ValueChecker implements ConvergenceChecker {\n-\n-    public ValueChecker(double threshold) {\n-      this.threshold = threshold;\n-    }\n-\n-    public boolean converged(PointValuePair[] simplex) {\n-      PointValuePair smallest = simplex[0];\n-      PointValuePair largest  = simplex[simplex.length - 1];\n-      return (largest.getValue() - smallest.getValue()) < threshold;\n-    }\n-\n-    private double threshold;\n-\n-  };\n+      optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n+    assertEquals(count, optimizer.getEvaluations());\n+    assertTrue(optimizer.getEvaluations() > 110);\n+    assertTrue(optimizer.getEvaluations() < 130);\n+    assertTrue(optimum.getValue() < 2.0e-3);\n+\n+  }\n \n   public static Test suite() {\n     return new TestSuite(NelderMeadTest.class);", "timestamp": 1236125271, "metainfo": ""}