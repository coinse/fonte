{"sha": "dcc13b296ff134115768457c8607ebdc131a92a5", "log": "Added Hermite interpolator for ExtendFieldElement instances.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/FieldHermiteInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.interpolation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.ZeroException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/** Polynomial interpolator using both sample values and sample derivatives.\n+ * <p>\n+ * The interpolation polynomials match all sample points, including both values\n+ * and provided derivatives. There is one polynomial for each component of\n+ * the values vector. All polynomials have the same degree. The degree of the\n+ * polynomials depends on the number of points and number of derivatives at each\n+ * point. For example the interpolation polynomials for n sample points without\n+ * any derivatives all have degree n-1. The interpolation polynomials for n\n+ * sample points with the two extreme points having value and first derivative\n+ * and the remaining points having value only all have degree n+1. The\n+ * interpolation polynomial for n sample points with value, first and second\n+ * derivative for all points all have degree 3n-1.\n+ * </p>\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class FieldHermiteInterpolator<T extends FieldElement<T>> {\n+\n+    /** Sample abscissae. */\n+    private final List<T> abscissae;\n+\n+    /** Top diagonal of the divided differences array. */\n+    private final List<T[]> topDiagonal;\n+\n+    /** Bottom diagonal of the divided differences array. */\n+    private final List<T[]> bottomDiagonal;\n+\n+    /** Create an empty interpolator.\n+     */\n+    public FieldHermiteInterpolator() {\n+        this.abscissae      = new ArrayList<T>();\n+        this.topDiagonal    = new ArrayList<T[]>();\n+        this.bottomDiagonal = new ArrayList<T[]>();\n+    }\n+\n+    /** Add a sample point.\n+     * <p>\n+     * This method must be called once for each sample point. It is allowed to\n+     * mix some calls with values only with calls with values and first\n+     * derivatives.\n+     * </p>\n+     * <p>\n+     * The point abscissae for all calls <em>must</em> be different.\n+     * </p>\n+     * @param x abscissa of the sample point\n+     * @param value value and derivatives of the sample point\n+     * (if only one row is passed, it is the value, if two rows are\n+     * passed the first one is the value and the second the derivative\n+     * and so on)\n+     * @exception ZeroException if the abscissa difference between added point\n+     * and a previous point is zero (i.e. the two points are at same abscissa)\n+     * @exception MathArithmeticException if the number of derivatives is larger\n+     * than 20, which prevents computation of a factorial\n+     */\n+    public void addSamplePoint(final T x, final T[] ... value)\n+        throws ZeroException, MathArithmeticException {\n+\n+        T factorial = x.getField().getOne();\n+        for (int i = 0; i < value.length; ++i) {\n+\n+            final T[] y = value[i].clone();\n+            if (i > 1) {\n+                factorial = factorial.multiply(i);\n+                final T inv = factorial.reciprocal();\n+                for (int j = 0; j < y.length; ++j) {\n+                    y[j] = y[j].multiply(inv);\n+                }\n+            }\n+\n+            // update the bottom diagonal of the divided differences array\n+            final int n = abscissae.size();\n+            bottomDiagonal.add(n - i, y);\n+            T[] bottom0 = y;\n+            for (int j = i; j < n; ++j) {\n+                final T[] bottom1 = bottomDiagonal.get(n - (j + 1));\n+                if (x.equals(abscissae.get(n - (j + 1)))) {\n+                    throw new ZeroException(LocalizedFormats.DUPLICATED_ABSCISSA_DIVISION_BY_ZERO, x);\n+                }\n+                final T inv = x.subtract(abscissae.get(n - (j + 1))).reciprocal();\n+                for (int k = 0; k < y.length; ++k) {\n+                    bottom1[k] = inv.multiply(bottom0[k].subtract(bottom1[k]));\n+                }\n+                bottom0 = bottom1;\n+            }\n+\n+            // update the top diagonal of the divided differences array\n+            topDiagonal.add(bottom0.clone());\n+\n+            // update the abscissae array\n+            abscissae.add(x);\n+\n+        }\n+\n+    }\n+\n+    /** Interpolate value at a specified abscissa.\n+     * @param x interpolation abscissa\n+     * @return interpolated value\n+     * @exception NoDataException if sample is empty\n+     */\n+    public T[] value(T x) throws NoDataException {\n+\n+        // safety check\n+        if (abscissae.isEmpty()) {\n+            throw new NoDataException(LocalizedFormats.EMPTY_INTERPOLATION_SAMPLE);\n+        }\n+\n+        final T[] value = MathArrays.buildArray(x.getField(), topDiagonal.get(0).length);\n+        T valueCoeff = x.getField().getOne();\n+        for (int i = 0; i < topDiagonal.size(); ++i) {\n+            T[] dividedDifference = topDiagonal.get(i);\n+            for (int k = 0; k < value.length; ++k) {\n+                value[k] = value[k].add(dividedDifference[k].multiply(valueCoeff));\n+            }\n+            final T deltaX = x.subtract(abscissae.get(i));\n+            valueCoeff = valueCoeff.multiply(deltaX);\n+        }\n+\n+        return value;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/interpolation/FieldHermiteInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.interpolation;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math3.dfp.Dfp;\n+import org.apache.commons.math3.dfp.DfpField;\n+import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.fraction.BigFraction;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class FieldHermiteInterpolatorTest {\n+\n+    @Test\n+    public void testZero() {\n+        FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>();\n+        interpolator.addSamplePoint(new BigFraction(0), new BigFraction[] { new BigFraction(0) });\n+        for (int x = -10; x < 10; x++) {\n+            BigFraction y = interpolator.value(new BigFraction(x))[0];\n+            Assert.assertEquals(BigFraction.ZERO, y);\n+        }\n+    }\n+\n+    @Test\n+    public void testQuadratic() {\n+        FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>();\n+        interpolator.addSamplePoint(new BigFraction(0), new BigFraction[] { new BigFraction(2) });\n+        interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(0) });\n+        interpolator.addSamplePoint(new BigFraction(2), new BigFraction[] { new BigFraction(0) });\n+        for (double x = -10; x < 10; x += 1.0) {\n+            BigFraction y = interpolator.value(new BigFraction(x))[0];\n+            Assert.assertEquals((x - 1) * (x - 2), y.doubleValue(), 1.0e-15);\n+        }\n+    }\n+\n+    @Test\n+    public void testMixedDerivatives() {\n+        FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>();\n+        interpolator.addSamplePoint(new BigFraction(0), new BigFraction[] { new BigFraction(1) }, new BigFraction[] { new BigFraction(2) });\n+        interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(4) });\n+        interpolator.addSamplePoint(new BigFraction(2), new BigFraction[] { new BigFraction(5) }, new BigFraction[] { new BigFraction(2) });\n+        Assert.assertEquals(new BigFraction(1), interpolator.value(new BigFraction(0))[0]);\n+        Assert.assertEquals(new BigFraction(4), interpolator.value(new BigFraction(1))[0]);\n+        Assert.assertEquals(new BigFraction(5), interpolator.value(new BigFraction(2))[0]);\n+    }\n+\n+    @Test\n+    public void testRandomPolynomialsValuesOnly() {\n+\n+        Random random = new Random(0x42b1e7dbd361a932l);\n+\n+        for (int i = 0; i < 100; ++i) {\n+\n+            int maxDegree = 0;\n+            PolynomialFunction[] p = new PolynomialFunction[5];\n+            for (int k = 0; k < p.length; ++k) {\n+                int degree = random.nextInt(7);\n+                p[k] = randomPolynomial(degree, random);\n+                maxDegree = FastMath.max(maxDegree, degree);\n+            }\n+\n+            DfpField field = new DfpField(30);\n+            Dfp step = field.getOne().divide(field.newDfp(10));\n+            FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>();\n+            for (int j = 0; j < 1 + maxDegree; ++j) {\n+                Dfp x = field.newDfp(j).multiply(step);\n+                Dfp[] values = new Dfp[p.length];\n+                for (int k = 0; k < p.length; ++k) {\n+                    values[k] = field.newDfp(p[k].value(x.getReal()));\n+                }\n+                interpolator.addSamplePoint(x, values);\n+            }\n+\n+            for (int j = 0; j < 20; ++j) {\n+                Dfp x = field.newDfp(j).multiply(step);\n+                Dfp[] values = interpolator.value(x);\n+                Assert.assertEquals(p.length, values.length);\n+                for (int k = 0; k < p.length; ++k) {\n+                    Assert.assertEquals(p[k].value(x.getReal()),\n+                                        values[k].getReal(),\n+                                        1.0e-8 * FastMath.abs(p[k].value(x.getReal())));\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testRandomPolynomialsFirstDerivative() {\n+\n+        Random random = new Random(0x570803c982ca5d3bl);\n+\n+        for (int i = 0; i < 100; ++i) {\n+\n+            int maxDegree = 0;\n+            PolynomialFunction[] p      = new PolynomialFunction[5];\n+            PolynomialFunction[] pPrime = new PolynomialFunction[5];\n+            for (int k = 0; k < p.length; ++k) {\n+                int degree = random.nextInt(7);\n+                p[k]      = randomPolynomial(degree, random);\n+                pPrime[k] = p[k].polynomialDerivative();\n+                maxDegree = FastMath.max(maxDegree, degree);\n+            }\n+\n+            DfpField field = new DfpField(30);\n+            Dfp step = field.getOne().divide(field.newDfp(10));\n+            FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>();\n+            for (int j = 0; j < 1 + maxDegree / 2; ++j) {\n+                Dfp x = field.newDfp(j).multiply(step);\n+                Dfp[] values      = new Dfp[p.length];\n+                Dfp[] derivatives = new Dfp[p.length];\n+                for (int k = 0; k < p.length; ++k) {\n+                    values[k]      = field.newDfp(p[k].value(x.getReal()));\n+                    derivatives[k] = field.newDfp(pPrime[k].value(x.getReal()));\n+                }\n+                interpolator.addSamplePoint(x, values, derivatives);\n+            }\n+\n+            Dfp h = step.divide(field.newDfp(100000));\n+            for (int j = 0; j < 20; ++j) {\n+                Dfp x = field.newDfp(j).multiply(step);\n+                Dfp[] y  = interpolator.value(x);\n+                Dfp[] yP = interpolator.value(x.add(h));\n+                Dfp[] yM = interpolator.value(x.subtract(h));\n+                Assert.assertEquals(p.length, y.length);\n+                for (int k = 0; k < p.length; ++k) {\n+                    Assert.assertEquals(p[k].value(x.getReal()),\n+                                        y[k].getReal(),\n+                                        1.0e-8 * FastMath.abs(p[k].value(x.getReal())));\n+                    Assert.assertEquals(pPrime[k].value(x.getReal()),\n+                                        yP[k].subtract(yM[k]).divide(h.multiply(2)).getReal(),\n+                                        4.0e-8 * FastMath.abs(p[k].value(x.getReal())));\n+                }\n+                System.out.println();\n+            }\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testSine() {\n+        DfpField field = new DfpField(30);\n+        FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>();\n+        for (Dfp x = field.getZero(); x.getReal() < FastMath.PI; x = x.add(0.5)) {\n+            interpolator.addSamplePoint(x, new Dfp[] { x.sin() });\n+        }\n+        for (Dfp x = field.newDfp(0.1); x.getReal() < 2.9; x = x.add(0.01)) {\n+            Dfp y = interpolator.value(x)[0];\n+            Assert.assertEquals( x.sin().getReal(), y.getReal(), 3.5e-5);\n+        }\n+    }\n+\n+    @Test\n+    public void testSquareRoot() {\n+        DfpField field = new DfpField(30);\n+        FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>();\n+        for (Dfp x = field.getOne(); x.getReal() < 3.6; x = x.add(0.5)) {\n+            interpolator.addSamplePoint(x, new Dfp[] { x.sqrt() });\n+        }\n+        for (Dfp x = field.newDfp(1.1); x.getReal() < 3.5; x = x.add(0.01)) {\n+            Dfp y = interpolator.value(x)[0];\n+            Assert.assertEquals(x.sqrt().getReal(), y.getReal(), 1.5e-4);\n+        }\n+    }\n+\n+    @Test\n+    public void testWikipedia() {\n+        // this test corresponds to the example from Wikipedia page:\n+        // http://en.wikipedia.org/wiki/Hermite_interpolation\n+        FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>();\n+        interpolator.addSamplePoint(new BigFraction(-1),\n+                                    new BigFraction[] { new BigFraction( 2) },\n+                                    new BigFraction[] { new BigFraction(-8) },\n+                                    new BigFraction[] { new BigFraction(56) });\n+        interpolator.addSamplePoint(new BigFraction( 0),\n+                                    new BigFraction[] { new BigFraction( 1) },\n+                                    new BigFraction[] { new BigFraction( 0) },\n+                                    new BigFraction[] { new BigFraction( 0) });\n+        interpolator.addSamplePoint(new BigFraction( 1),\n+                                    new BigFraction[] { new BigFraction( 2) },\n+                                    new BigFraction[] { new BigFraction( 8) },\n+                                    new BigFraction[] { new BigFraction(56) });\n+        for (BigFraction x = new BigFraction(-1); x.doubleValue() <= 1.0; x = x.add(new BigFraction(1, 8))) {\n+            BigFraction y = interpolator.value(x)[0];\n+            BigFraction x2 = x.multiply(x);\n+            BigFraction x4 = x2.multiply(x2);\n+            BigFraction x8 = x4.multiply(x4);\n+            Assert.assertEquals(x8.add(new BigFraction(1)), y);\n+        }\n+    }\n+\n+    @Test\n+    public void testOnePointParabola() {\n+        FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>();\n+        interpolator.addSamplePoint(new BigFraction(0),\n+                                    new BigFraction[] { new BigFraction(1) },\n+                                    new BigFraction[] { new BigFraction(1) },\n+                                    new BigFraction[] { new BigFraction(2) });\n+        for (BigFraction x = new BigFraction(-1); x.doubleValue() <= 1.0; x = x.add(new BigFraction(1, 8))) {\n+            BigFraction y = interpolator.value(x)[0];\n+            Assert.assertEquals(BigFraction.ONE.add(x.multiply(BigFraction.ONE.add(x))), y);\n+        }\n+    }\n+\n+    private PolynomialFunction randomPolynomial(int degree, Random random) {\n+        double[] coeff = new double[ 1 + degree];\n+        for (int j = 0; j < degree; ++j) {\n+            coeff[j] = random.nextDouble();\n+        }\n+        return new PolynomialFunction(coeff);\n+    }\n+\n+    @Test(expected=NoDataException.class)\n+    public void testEmptySample() {\n+        new FieldHermiteInterpolator<BigFraction>().value(BigFraction.ZERO);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testDuplicatedAbscissa() {\n+        FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>();\n+        interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(0) });\n+        interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(1) });\n+    }\n+\n+}\n+", "timestamp": 1361789950, "metainfo": ""}