{"sha": "2cb671bd661fab68c6ce6c2cf36de45a3cf9805d", "log": "Made PRNG pluggable for classes in the random package.   * Added RandomGeneratorinterface extracted from java.util.random. * Added and abstract implementation, AbstractRandomGenerator providing default   implementations of methods based on nextDouble(). * Added a constructor taking a RandomGenerator as an argument to RandomDataImpl * Changed ValueServer to use a RandomData in its constructor. * Changes to 1.0 classes should be backward compatible   (including serialization).   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+/**\n+ * Abstract class implementing the {@link  RandomGenerator} interface.\n+ * Default implementations for all methods other than {@link #nextDouble()} and\n+ * {@link #setSeed(long)} are provided. \n+ * <p>\n+ * All data generation methods are based on <code>nextDouble().</code>\n+ * Concrete implementations <strong>must</strong> overrride\n+ * this method and <strong>should</strong> provide better / more\n+ * performant implementations of the other methods if the underlying PRNG\n+ * supplies them.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractRandomGenerator implements RandomGenerator {\n+    \n+    /** \n+     * Cached random normal value.  The default implementation for \n+     * {@link #nextGaussian} generates pairs of values and this field caches the\n+     * second value so that the full algorithm is not executed for every\n+     * activation.  The value <code>Double.NaN</code> signals that there is\n+     * no cached value.  Use {@link #clear} to clear the cached value.\n+     */\n+    private double cachedNormalDeviate = Double.NaN;\n+    \n+    /**\n+     * Construct a RandomGenerator.\n+     */\n+    public AbstractRandomGenerator() {\n+        super();\n+        \n+    }\n+    \n+    /**\n+     * Clears the cache used by the default implementation of {@link #nextGaussian}.\n+     * Implemementations that do not override the default\n+     * implementation of <code>nextGaussian</code> should call this method\n+     * in the implementation of {@link #setSeed(long)}\n+     */\n+    public void clear() {\n+        cachedNormalDeviate = Double.NaN;\n+    }\n+    \n+    /**\n+     * Sets the seed of the underyling random number generator using a \n+     * <code>long</code> seed.  Sequences of values generated starting with the\n+     * same seeds should be identical.\n+     * <p>\n+     * Implementations that do not override the default implementation of \n+     * <code>nextGaussian</code> should include a call to {@link #clear} in the\n+     * implementation of this method.\n+     *\n+     * @param seed the seed value\n+     */\n+    public abstract void setSeed(long seed);  \n+\n+    /**\n+     * Generates random bytes and places them into a user-supplied \n+     * byte array.  The number of random bytes produced is equal to \n+     * the length of the byte array.\n+     * <p>\n+     * The default implementation provided here fills the array with bytes\n+     * extracted from random integers generated using {@link #nextInt}.\n+     * \n+     * @param bytes the non-null byte array in which to put the \n+     * random bytes\n+     */\n+    public void nextBytes(byte[] bytes) {\n+        int bytesOut = 0;\n+        while (bytesOut < bytes.length) {\n+          int randInt = nextInt();\n+          for (int i = 0; i < 3; i++) {\n+              if ( i > 0) {\n+                  randInt = randInt >> 8;\n+              }\n+              bytes[bytesOut++] = (byte) randInt;\n+              if (bytesOut == bytes.length) {\n+                  return;\n+              }\n+          }\n+        }\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed <code>int</code>\n+     * value from this random number generator's sequence.  \n+     * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n+     * should be produced with  (approximately) equal probability. \n+     * <p>\n+     * The default implementation provided here returns \n+     * <pre>\n+     * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>\n+     * </pre>\n+     *\n+     * @return the next pseudorandom, uniformly distributed <code>int</code>\n+     *  value from this random number generator's sequence\n+     */\n+    public int nextInt() {\n+        return (int) (nextDouble() * Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence. \n+     * <p>  \n+     * The default implementation provided here returns \n+     * <pre>\n+     * <code>(int) (nextDouble() * n</code>\n+     * </pre>\n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>int</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException if n is not positive.\n+     */\n+    public int nextInt(int n) {\n+        if (n <= 0 ) {\n+            throw new IllegalArgumentException(\"upper bound must be positive\");\n+        }\n+        int result = (int) (nextDouble() * n);\n+        return result < n ? result : n - 1;\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed <code>long</code>\n+     * value from this random number generator's sequence.  All \n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n+     * should be produced with (approximately) equal probability. \n+     * <p>  \n+     * The default implementation provided here returns \n+     * <pre>\n+     * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>\n+     * </pre>\n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>long</code>\n+     *value from this random number generator's sequence\n+     */\n+    public long nextLong() {\n+        return (long) (nextDouble() * Long.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence.  \n+     * <p>  \n+     * The default implementation provided here returns \n+     * <pre>\n+     * <code>nextDouble() <= 0.5</code>\n+     * </pre>\n+     * \n+     * @return  the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence\n+     */\n+    public boolean nextBoolean() {\n+        return nextDouble() <= 0.5;\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this random\n+     * number generator's sequence.  \n+     * <p>  \n+     * The default implementation provided here returns \n+     * <pre>\n+     * <code>(float) nextDouble() </code>\n+     * </pre>\n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this\n+     * random number generator's sequence\n+     */\n+    public float nextFloat() {\n+        return (float) nextDouble();\n+    }\n+\n+    /**\n+     * Returns the next pseudorandom, uniformly distributed \n+     * <code>double</code> value between <code>0.0</code> and\n+     * <code>1.0</code> from this random number generator's sequence.  \n+     * <p>\n+     * This method provides the underlying source of random data used by the\n+     * other methods.   \n+     *\n+     * @return  the next pseudorandom, uniformly distributed \n+     *  <code>double</code> value between <code>0.0</code> and\n+     *  <code>1.0</code> from this random number generator's sequence\n+     */  \n+    public abstract double nextDouble();  \n+\n+    /**\n+     * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and standard\n+     * deviation <code>1.0</code> from this random number generator's sequence.\n+     * <p>\n+     * The default implementation provided here uses the <em>Polar Method</em>\n+     * due to G.E.P. Box, M.E. Muller and G. Marsaglia, as described in \n+     * D. Knuth, <u>The Art of Computer Programming</u>, 3.4.1C.\n+     * <p>\n+     * The algorithm generates a pair of independent random values.  One of\n+     * these is cached for reuse, so the full algorithm is not executed on each\n+     * activation.  Implementations that do not override this method should\n+     * make sure to call {@link #clear} to clear the cached value in the \n+     * implementation of {@link #setSeed(long)}.\n+     * \n+     * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and\n+     * standard deviation <code>1.0</code> from this random number\n+     *  generator's sequence\n+     */\n+    public double nextGaussian() {\n+        if (!Double.isNaN(cachedNormalDeviate)) {\n+            double dev = cachedNormalDeviate;\n+            cachedNormalDeviate = Double.NaN;\n+            return dev;\n+        }\n+        double v1 =0;\n+        double v2 = 0;\n+        double s = 1;\n+        while (s >=1 ) { \n+            v1 = 2 * nextDouble() - 1; \n+            v2 = 2 * nextDouble() - 1; \n+            s = v1 * v1 + v2 * v2;\n+        }\n+        if (s != 0) {\n+            s = Math.sqrt(-2 * Math.log(s)/s);   \n+        }\n+        cachedNormalDeviate = v2 * s;\n+        return v1 * s;      \n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/JDKRandomGenerator.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import java.util.Random;\n+\n+/**\n+ * Extension of <code>java.util.Random</code> to implement \n+ * {@link RandomGenerator}.\n+ *\n+ * @version $Revision:$ $Date$\n+ */\n+public class JDKRandomGenerator extends Random implements RandomGenerator {\n+}\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n import java.security.SecureRandom;\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n-import java.util.Random;\n import java.util.Collection;\n \n /**\n- * Implements the {@link RandomData} interface using\n- * {@link java.util.Random} and {@link java.util.Random.SecureRandom} instances\n- * to generate data.\n+ * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n+ * instance to generate non-secure data and a \n+ * {@link java.security.SecureRandom} instance to provide data for the\n+ * <code>nextSecureXxx</code> methods.  If no <code>RandomGenerator</code>\n+ * is provided in the constructor, the default is to use a generator based on\n+ * {@link java.util.Random}.   To plug in a different implementation, \n+ * either implement <code>RandomGenerator</code> directly or extend\n+ * {@link AbstractRandomGenerator}.\n  * <p>\n  * Supports reseeding the underlying pseudo-random number generator (PRNG). \n  * The <code>SecurityProvider</code> and <code>Algorithm</code>\n  * used by the <code>SecureRandom</code> instance can also be reset.\n  * <p>\n- * For details on the PRNGs, see {@link java.util.Random} and\n- * {@link java.util.Random.SecureRandom}.\n+ * For details on the default PRNGs, see {@link java.util.Random} and\n+ * {@link java.security.SecureRandom}. \n  * <p>\n  * <strong>Usage Notes</strong>: <ul>\n  * <li>\n- * Instance variables are used to maintain <code>Random</code> and\n+ * Instance variables are used to maintain <code>RandomGenerator</code> and\n  * <code>SecureRandom</code> instances used in data generation. Therefore,\n  * to generate a random sequence of values or strings, you should use just\n  * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n  * it any easier to predict subsequent values.</li>\n  * <li>\n  * When a new <code>RandomDataImpl</code> is created, the underlying random\n- * number generators are <strong>not</strong> intialized.  The first call to a\n- * data generation method, or to a <code>reSeed()</code> method instantiates\n- * the appropriate generator.  If you do not explicitly seed the generator, it\n- * is by default seeded with the current time in milliseconds</li>\n+ * number generators are <strong>not</strong> intialized.  If you do not\n+ * explicitly seed the default non-secure generator, it is seeded with the current time\n+ * in milliseconds on first use.  The same holds for the secure generator.  \n+ * If you provide a <code>RandomGenerator</code> to the constructor, however,\n+ * this generator is not reseeded by the constructor nor is it reseeded on\n+ * first use. </li>\n  * <li>\n  * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate\n- * to the corresponding methods on the underlying <code>Random</code> and\n- * <code>SecureRandom</code> instances.  Therefore, the contracts of these\n- * methods are as defined in the JDK documentation.  In particular,\n+ * to the corresponding methods on the underlying <code>RandomGenerator</code>\n+ * and<code>SecureRandom</code> instances.  Therefore, \n  * <code>reSeed(long)</code> fully resets the initial state of the non-secure\n  * random number generator (so that reseeding with a specific value always\n  * results in the same subsequent random sequence); whereas reSeedSecure(long)\n     static final long serialVersionUID = -626730818244969716L;\n \n     /** underlying random number generator */\n-    private Random rand = null;\n+    private RandomGenerator rand = null;\n \n     /** underlying secure random number generator */\n     private SecureRandom secRand = null;\n      * Construct a RandomDataImpl.\n      */\n     public RandomDataImpl() {\n+    }\n+    \n+    /**\n+     * Construct a RandomDataImpl using the supplied {@link RandomGenerator}\n+     * as the source of (non-secure) random data.\n+     * \n+     * @param rand  the source of (non-secure) random data\n+     */\n+    public RandomDataImpl(RandomGenerator rand) {\n+        super();\n+        this.rand = rand;\n     }\n \n     /**\n         }\n \n         //Get a random number generator\n-        Random ran = getRan();\n+        RandomGenerator ran = getRan();\n \n         //Initialize output buffer\n         StringBuffer outBuffer = new StringBuffer();\n             throw new IllegalArgumentException\n                 (\"upper bound must be > lower bound\");\n         }\n-        Random rand = getRan();\n+        RandomGenerator rand = getRan();\n         return lower + (int) (rand.nextDouble() * (upper - lower + 1));\n     }\n \n             throw new IllegalArgumentException\n                 (\"upper bound must be > lower bound\");\n         }\n-        Random rand = getRan();\n+        RandomGenerator rand = getRan();\n         return lower + (long) (rand.nextDouble() * (upper - lower + 1));\n     }\n \n         long n = 0;\n         double r = 1.0d;\n         double rnd = 1.0d;\n-        Random rand = getRan();\n+        RandomGenerator rand = getRan();\n         while (n < 1000 * mean) {\n             rnd = rand.nextDouble();\n             r = r * rnd;\n         if (sigma <= 0) {\n             throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n         }\n-        Random rand = getRan();\n+        RandomGenerator rand = getRan();\n         return sigma * rand.nextGaussian() + mu;\n     }\n \n             throw new IllegalArgumentException\n                 (\"Exponential mean must be >= 0\");\n         }\n-        Random rand = getRan();\n+        RandomGenerator rand = getRan();\n         double unif = rand.nextDouble();\n         while (unif == 0.0d) {\n             unif = rand.nextDouble();\n      * random double if Random.nextDouble() returns 0).\n      * This is necessary to provide a symmetric output interval\n      * (both endpoints excluded).\n+     * \n      * @param lower the lower bound.\n      * @param upper the upper bound.\n-     * @return the random value.\n+     * @return a uniformly distributed random value from the interval (lower, upper)\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n             (\"lower bound must be <= upper bound\");\n         }\n-        Random rand = getRan();\n-\n-        // insure nextDouble() isn't 0.0\n+        RandomGenerator rand = getRan();\n+\n+        // ensure nextDouble() isn't 0.0\n         double u = rand.nextDouble();\n         while(u <= 0.0){\n             u = rand.nextDouble();\n     }\n \n     /**\n-     * Returns the static Random used to generate random data.\n+     * Returns the RandomGenerator used to generate non-secure\n+     * random data.\n+     * <p>\n+     * Creates and initializes a default generator if null.\n+     *\n+     * @return the Random used to generate random data\n+     */\n+    private RandomGenerator getRan() {\n+        if (rand == null) {\n+            rand = new JDKRandomGenerator();\n+            rand.setSeed(System.currentTimeMillis());\n+        }\n+        return rand;\n+    }\n+\n+    /**\n+     * Returns the SecureRandom used to generate secure random data.\n      * <p>\n      * Creates and initializes if null.\n      *\n-     * @return the static Random used to generate random data\n-     */\n-    private Random getRan() {\n-        if (rand == null) {\n-            rand = new Random();\n-            rand.setSeed(System.currentTimeMillis());\n-        }\n-        return rand;\n-    }\n-\n-    /**\n-     * Returns the static SecureRandom used to generate secure random data.\n-     * <p>\n-     * Creates and initializes if null.\n-     *\n-     * @return the static SecureRandom used to generate secure random data\n+     * @return the SecureRandom used to generate secure random data\n      */\n     private SecureRandom getSecRan() {\n         if (secRand == null) {\n      */\n     public void reSeed(long seed) {\n         if (rand == null) {\n-            rand = new Random();\n+            rand = new JDKRandomGenerator();\n         }\n         rand.setSeed(seed);\n     }\n      */\n     public void reSeed() {\n         if (rand == null) {\n-            rand = new Random();\n+            rand = new JDKRandomGenerator();\n         }\n         rand.setSeed(System.currentTimeMillis());\n     }\n         }\n         return natural;\n     }\n-\n-}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/RandomGenerator.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+/**\n+ * Interface extracted from <code>java.util.Random</code>.  This interface is\n+ * implemented by {@link AbstractRandomGenerator}.  \n+ *\n+ * @version $Revision:$ $Date$\n+ */\n+public interface RandomGenerator {\n+    \n+    /**\n+     * Sets the seed of the underyling random number generator using a \n+     * <code>long</code> seed.  Sequences of values generated starting with the\n+     * same seeds should be identical.\n+     *\n+     * @param seed the seed value\n+     */\n+    void setSeed(long seed);\n+    \n+    /**\n+     * Generates random bytes and places them into a user-supplied \n+     * byte array.  The number of random bytes produced is equal to \n+     * the length of the byte array.\n+     * \n+     * @param bytes the non-null byte array in which to put the \n+     * random bytes\n+     */\n+    void nextBytes(byte[] bytes);\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>int</code>\n+     * value from this random number generator's sequence.  \n+     * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n+     * should be produced with  (approximately) equal probability. \n+     *\n+     * @return the next pseudorandom, uniformly distributed <code>int</code>\n+     *  value from this random number generator's sequence\n+     */\n+    int nextInt();\n+    \n+    /**\n+     * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence.   \n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>int</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException  if n is not positive.\n+     */\n+    int nextInt(int n);\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>long</code>\n+     * value from this random number generator's sequence.  All \n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n+     * should be produced with (approximately) equal probability. \n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>long</code>\n+     *value from this random number generator's sequence\n+     */\n+    long nextLong();\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence.  \n+     * \n+     * @return  the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence\n+     */\n+    boolean nextBoolean();\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this random\n+     * number generator's sequence.  \n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this\n+     * random number generator's sequence\n+     */\n+    float nextFloat();\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed \n+     * <code>double</code> value between <code>0.0</code> and\n+     * <code>1.0</code> from this random number generator's sequence.  \n+     *\n+     * @return  the next pseudorandom, uniformly distributed \n+     *  <code>double</code> value between <code>0.0</code> and\n+     *  <code>1.0</code> from this random number generator's sequence\n+     */  \n+    double nextDouble();\n+    \n+    /**\n+     * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and standard\n+     * deviation <code>1.0</code> from this random number generator's sequence.\n+     * \n+     * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and\n+     * standard deviation <code>1.0</code> from this random number\n+     *  generator's sequence\n+     */\n+    double nextGaussian();\n+}\n--- a/src/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/java/org/apache/commons/math/random/ValueServer.java\n     private BufferedReader filePointer = null;\n \n     /** RandomDataImpl to use for random data generation */\n-    private RandomDataImpl randomData = new RandomDataImpl();\n+    private RandomData randomData = new RandomDataImpl();\n \n     // Data generation modes ======================================\n \n         return randomData.nextGaussian(mu, sigma);\n     }\n \n+    /**\n+     * Construct a ValueServer instance using a RandomData as its source\n+     * of random data.\n+     * \n+     * @param randomData the RandomData instance used to source random data\n+     */\n+    public ValueServer(RandomData randomData) {\n+        super();\n+        this.randomData = randomData;\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the AbstractRandomGenerator class\n+ *\n+ * @version $Revision:$ $Date$\n+ */\n+\n+public class AbstractRandomGeneratorTest extends RandomDataTest {\n+    public AbstractRandomGeneratorTest(String name) {\n+        super(name);\n+        randomData = new RandomDataImpl(new TestRandomGenerator());\n+    } \n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class);\n+        suite.setName(\"AbstractRandomGenerator Tests\");\n+        return suite;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n  * @version $Revision$ $Date$\n  */\n \n-public final class RandomDataTest extends RetryTestCase {\n+public class RandomDataTest extends RetryTestCase {\n \n     public RandomDataTest(String name) {\n         super(name);\n+        randomData = new RandomDataImpl();\n     }\n \n     private long smallSampleSize = 1000;\n     private int tolerance = 50;\n     private String[] hex = \n         {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"}; \n-    private RandomDataImpl randomData = new RandomDataImpl(); \n+    protected RandomDataImpl randomData = null; \n     private ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n     \n     public void setUp() { \n     \n     /** test reseeding, algorithm/provider games */\n     public void testConfig() throws NoSuchProviderException, \n-      NoSuchAlgorithmException{\n+      NoSuchAlgorithmException {\n         randomData.reSeed(1000);\n         double v = randomData.nextUniform(0,1);\n         randomData.reSeed();\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/random/TestRandomGenerator.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+import java.util.Random;\n+\n+/**\n+ * Dummy AbstractRandomGenerator concrete subclass that just wraps a \n+ * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test\n+ * default implementations in AbstractRandomGenerator.\n+ *\n+ * @version $Revision:$ $Date$\n+ */\n+public class TestRandomGenerator extends AbstractRandomGenerator {\n+    private Random random = new Random();\n+    \n+    public void setSeed(long seed) {\n+       clear();\n+       random.setSeed(seed);\n+    }\n+    \n+    public double nextDouble() {\n+        return random.nextDouble();\n+    }\n+\n+}", "timestamp": 1116181415, "metainfo": ""}