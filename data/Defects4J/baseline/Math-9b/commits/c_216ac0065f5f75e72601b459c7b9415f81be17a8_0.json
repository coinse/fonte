{"sha": "216ac0065f5f75e72601b459c7b9415f81be17a8", "log": "MATH-782 Moved incorrectly placed block of code (user-defined stopping criterion). Added unit test. New utility class for simple stopping criterion based on (univariate) function values.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n                     fw = fx;\n                     x = u;\n                     fx = fu;\n+\n+                    // User-defined convergence checker.\n+                    previous = current;\n+                    current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+\n+                    if (checker != null) {\n+                        if (checker.converged(iter, previous, current)) {\n+                            return current;\n+                        }\n+                    }\n                 } else {\n                     if (u < x) {\n                         a = u;\n                         fv = fu;\n                     }\n                 }\n-\n-                previous = current;\n-                current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-\n-                // User-defined convergence checker.\n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return current;\n-                    }\n-                }\n             } else { // Default termination (Brent's criterion).\n                 return current;\n             }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.optimization.univariate;\n+\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.optimization.AbstractConvergenceChecker;\n+\n+/**\n+ * Simple implementation of the\n+ * {@link org.apache.commons.math3.optimization.ConvergenceChecker} interface\n+ * that uses only objective function values.\n+ *\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class SimpleUnivariateValueChecker\n+    extends AbstractConvergenceChecker<UnivariatePointValuePair> {\n+    /**\n+     * Build an instance with default thresholds.\n+     */\n+    public SimpleUnivariateValueChecker() {}\n+\n+    /** Build an instance with specified thresholds.\n+     *\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     *\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleUnivariateValueChecker(final double relativeThreshold,\n+                                        final double absoluteThreshold) {\n+        super(relativeThreshold, absoluteThreshold);\n+    }\n+\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n+     * @return {@code true} if the algorithm has converged.\n+     */\n+    @Override\n+    public boolean converged(final int iteration,\n+                             final UnivariatePointValuePair previous,\n+                             final UnivariatePointValuePair current) {\n+        final double p = previous.getValue();\n+        final double c = current.getValue();\n+        final double difference = FastMath.abs(p - c);\n+        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n+        return difference <= size * getRelativeThreshold() ||\n+            difference <= getAbsoluteThreshold();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java\n import org.apache.commons.math3.analysis.SinFunction;\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.optimization.GoalType;\n+import org.apache.commons.math3.optimization.ConvergenceChecker;\n import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;\n import org.junit.Assert;\n import org.junit.Test;\n         } catch (TooManyEvaluationsException fee) {\n             // expected\n         }\n+    }\n+\n+    @Test\n+    public void testSinMinWithValueChecker() {\n+        final UnivariateFunction f = new SinFunction();\n+        final ConvergenceChecker checker = new SimpleUnivariateValueChecker(1e-5, 1e-14);\n+        // The default stopping criterion of Brent's algorithm should not\n+        // pass, but the search will stop at the given relative tolerance\n+        // for the function value.\n+        final UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14, checker);\n+        final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5);\n+        Assert.assertEquals(3 * Math.PI / 2, result.getPoint(), 1e-3);\n     }\n \n     @Test", "timestamp": 1335365384, "metainfo": ""}