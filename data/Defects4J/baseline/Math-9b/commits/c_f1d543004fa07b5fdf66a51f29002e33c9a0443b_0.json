{"sha": "f1d543004fa07b5fdf66a51f29002e33c9a0443b", "log": "MATH-792:   - definition of RealVectorChangingVisitor,   - various methods to visit the entries of a RealVector (entries are possibly modified),   - default implementation in RealVector abstract class,   - unit tests in abstract RealVectorAbstractClass.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n         }\n         return this;\n     }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor) {\n+        visitor.start(data.length, 0, data.length - 1);\n+        for (int i = 0; i < data.length; i++) {\n+            visitor.visit(i, data[i]);\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,\n+                                     final int start, final int end) {\n+        checkIndices(start, end);\n+        visitor.start(data.length, start, end);\n+        for (int i = start; i <= end; i++) {\n+            visitor.visit(i, data[i]);\n+        }\n+        return visitor.end();\n+    }\n }\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n \n \n     /**\n-     * Visits (but does not change) all entries of this vector in default order\n+     * Visits (but does not alter) all entries of this vector in default order\n      * (increasing index).\n      *\n      * @param visitor the visitor to be used to process the entries of this\n     }\n \n     /**\n-     * Visits (and possibly change) some entries of this vector in default order\n+     * Visits (but does not alter) some entries of this vector in default order\n      * (increasing index).\n      *\n      * @param visitor visitor to be used to process the entries of this vector\n      * the indices are not valid.\n      */\n     public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,\n-                              int start, int end) {\n+                                     int start, int end) {\n         checkIndices(start, end);\n         visitor.start(getDimension(), start, end);\n         for (int i = start; i <= end; i++) {\n     }\n \n     /**\n-     * Visits (but does not change) all entries of this vector in optimized\n+     * Visits (but does not alter) all entries of this vector in optimized\n      * order. The order in which the entries are visited is selected so as to\n      * lead to the most efficient implementation; it might depend on the\n      * concrete implementation of this abstract class.\n     }\n \n     /**\n-     * Visits (and possibly change) some entries of this vector in default order\n-     * (increasing index). The order in which the entries are visited is\n-     * selected so as to lead to the most efficient implementation; it might\n-     * depend on the concrete implementation of this abstract class.\n+     * Visits (but does not alter) some entries of this vector in optimized\n+     * order. The order in which the entries are visited is selected so as to\n+     * lead to the most efficient implementation; it might depend on the\n+     * concrete implementation of this abstract class.\n      *\n      * @param visitor visitor to be used to process the entries of this vector\n      * @param start the index of the first entry to be visited\n      * the indices are not valid.\n      */\n     public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor,\n+                                       int start, int end) {\n+        return walkInDefaultOrder(visitor, start, end);\n+    }\n+\n+    /**\n+     * Visits (and possibly alters) all entries of this vector in default order\n+     * (increasing index).\n+     *\n+     * @param visitor the visitor to be used to process and modify the entries\n+     * of this vector\n+     * @return the value returned by {@link RealVectorChangingVisitor#end()}\n+     * at the end of the walk\n+     */\n+    public double walkInDefaultOrder(final RealVectorChangingVisitor visitor) {\n+        final int dim = getDimension();\n+        visitor.start(dim, 0, dim - 1);\n+        for (int i = 0; i < dim; i++) {\n+            setEntry(i, visitor.visit(i, getEntry(i)));\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Visits (and possibly alters) some entries of this vector in default order\n+     * (increasing index).\n+     *\n+     * @param visitor visitor to be used to process the entries of this vector\n+     * @param start the index of the first entry to be visited\n+     * @param end the index of the last entry to be visited (inclusive)\n+     * @return the value returned by {@link RealVectorChangingVisitor#end()}\n+     * at the end of the walk\n+     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n+     * the indices are not valid.\n+     */\n+    public double walkInDefaultOrder(final RealVectorChangingVisitor visitor,\n+                              int start, int end) {\n+        checkIndices(start, end);\n+        visitor.start(getDimension(), start, end);\n+        for (int i = start; i <= end; i++) {\n+            setEntry(i, visitor.visit(i, getEntry(i)));\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Visits (and possibly alters) all entries of this vector in optimized\n+     * order. The order in which the entries are visited is selected so as to\n+     * lead to the most efficient implementation; it might depend on the\n+     * concrete implementation of this abstract class.\n+     *\n+     * @param visitor the visitor to be used to process the entries of this\n+     * vector\n+     * @return the value returned by {@link RealVectorChangingVisitor#end()}\n+     * at the end of the walk\n+     */\n+    public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor) {\n+        return walkInDefaultOrder(visitor);\n+    }\n+\n+    /**\n+     * Visits (and possibly change) some entries of this vector in optimized\n+     * order. The order in which the entries are visited is selected so as to\n+     * lead to the most efficient implementation; it might depend on the\n+     * concrete implementation of this abstract class.\n+     *\n+     * @param visitor visitor to be used to process the entries of this vector\n+     * @param start the index of the first entry to be visited\n+     * @param end the index of the last entry to be visited (inclusive)\n+     * @return the value returned by {@link RealVectorChangingVisitor#end()}\n+     * at the end of the walk\n+     * @throws org.apache.commons.math3.exception.OutOfRangeException if\n+     * the indices are not valid.\n+     */\n+    public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor,\n                                        int start, int end) {\n         return walkInDefaultOrder(visitor, start, end);\n     }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVectorChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.linear;\n+\n+/**\n+ * This interface defines a visitor for the entries of a vector. Visitors\n+ * implementing this interface may alter the entries of the vector being\n+ * visited.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public interface RealVectorChangingVisitor {\n+    /**\n+     * Start visiting a vector. This method is called once, before any entry\n+     * of the vector is visited.\n+     *\n+     * @param dimension the size of the vector\n+     * @param start the index of the first entry to be visited\n+     * @param end the index of the last entry to be visited (inclusive)\n+     */\n+    void start(int dimension, int start, int end);\n+\n+    /**\n+     * Visit one entry of the vector.\n+     *\n+     * @param index the index of the entry being visited\n+     * @param value the value of the entry being visited\n+     * @return the new value of the entry being visited\n+     */\n+    double visit(int index, double value);\n+\n+    /**\n+     * End visiting a vector. This method is called once, after all entries of\n+     * the vector have been visited.\n+     *\n+     * @return the value returned by\n+     * {@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor)},\n+     * {@link RealVector#walkInDefaultOrder(RealVectorChangingVisitor, int, int)},\n+     * {@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor)}\n+     * or\n+     * {@link RealVector#walkInOptimizedOrder(RealVectorChangingVisitor, int, int)}\n+     */\n+    double end();\n+}\n--- a/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n             }\n \n             public double end() {\n-                return 0;\n+                return 0.0;\n             }\n         };\n         v.walkInDefaultOrder(visitor);\n     @Test\n     public void testWalkInDefaultOrderPreservingVisitor2() {\n         final RealVector v = create(new double[5]);\n-        try {\n-            v.walkInDefaultOrder(null, -1, 4);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInDefaultOrder(null, 5, 4);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInDefaultOrder(null, 0, -1);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInDefaultOrder(null, 0, 5);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInDefaultOrder(null, 4, 0);\n+        final RealVectorPreservingVisitor visitor;\n+        visitor = new RealVectorPreservingVisitor() {\n+\n+            public void visit(int index, double value) {\n+                // Do nothing\n+            }\n+\n+            public void start(int dimension, int start, int end) {\n+                // Do nothing\n+            }\n+\n+            public double end() {\n+                return 0.0;\n+            }\n+        };\n+        try {\n+            v.walkInDefaultOrder(visitor, -1, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 5, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 0, -1);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 0, 5);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 4, 0);\n             Assert.fail();\n         } catch (NumberIsTooSmallException e) {\n             // Expected behavior\n             }\n \n             public double end() {\n-                return 0;\n+                return 0.0;\n             }\n         };\n         v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);\n                     Assert.assertTrue(\"entry \" + i + \"has not been visited\",\n                                       visited[i]);\n                 }\n-                return 0;\n+                return 0.0;\n             }\n         };\n         v.walkInOptimizedOrder(visitor);\n     @Test\n     public void testWalkInOptimizedOrderPreservingVisitor2() {\n         final RealVector v = create(new double[5]);\n-        try {\n-            v.walkInOptimizedOrder(null, -1, 4);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInOptimizedOrder(null, 5, 4);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInOptimizedOrder(null, 0, -1);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInOptimizedOrder(null, 0, 5);\n-            Assert.fail();\n-        } catch (OutOfRangeException e) {\n-            // Expected behavior\n-        }\n-        try {\n-            v.walkInOptimizedOrder(null, 4, 0);\n+        final RealVectorPreservingVisitor visitor;\n+        visitor = new RealVectorPreservingVisitor() {\n+\n+            public void visit(int index, double value) {\n+                // Do nothing\n+            }\n+\n+            public void start(int dimension, int start, int end) {\n+                // Do nothing\n+            }\n+\n+            public double end() {\n+                return 0.0;\n+            }\n+        };\n+        try {\n+            v.walkInOptimizedOrder(visitor, -1, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 5, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 0, -1);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 0, 5);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 4, 0);\n             Assert.fail();\n         } catch (NumberIsTooSmallException e) {\n             // Expected behavior\n                     Assert.assertTrue(\"entry \" + i + \"has not been visited\",\n                                       visited[i]);\n                 }\n-                return 0;\n+                return 0.0;\n             }\n         };\n         v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);\n     }\n+\n+    /** The whole vector is visited. */\n+    @Test\n+    public void testWalkInDefaultOrderChangingVisitor1() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final RealVector v = create(data);\n+        final RealVectorChangingVisitor visitor;\n+        visitor = new RealVectorChangingVisitor() {\n+\n+            private int expectedIndex;\n+\n+            public double visit(final int actualIndex, final double actualValue) {\n+                Assert.assertEquals(expectedIndex, actualIndex);\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+                ++expectedIndex;\n+                return actualIndex + actualValue;\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(0, actualStart);\n+                Assert.assertEquals(data.length - 1, actualEnd);\n+                expectedIndex = 0;\n+            }\n+\n+            public double end() {\n+                return 0.0;\n+            }\n+        };\n+        v.walkInDefaultOrder(visitor);\n+        for (int i = 0; i < data.length; i++) {\n+            Assert.assertEquals(\"entry \" + i, i + data[i], v.getEntry(i), 0.0);\n+        }\n+    }\n+\n+    /** Visiting an invalid subvector. */\n+    @Test\n+    public void testWalkInDefaultOrderChangingVisitor2() {\n+        final RealVector v = create(new double[5]);\n+        final RealVectorChangingVisitor visitor;\n+        visitor = new RealVectorChangingVisitor() {\n+\n+            public double visit(int index, double value) {\n+                return 0.0;\n+            }\n+\n+            public void start(int dimension, int start, int end) {\n+                // Do nothing\n+            }\n+\n+            public double end() {\n+                return 0.0;\n+            }\n+        };\n+        try {\n+            v.walkInDefaultOrder(visitor, -1, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 5, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 0, -1);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 0, 5);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInDefaultOrder(visitor, 4, 0);\n+            Assert.fail();\n+        } catch (NumberIsTooSmallException e) {\n+            // Expected behavior\n+        }\n+    }\n+\n+    /** Visiting a valid subvector. */\n+    @Test\n+    public void testWalkInDefaultOrderChangingVisitor3() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final int expectedStart = 2;\n+        final int expectedEnd = 7;\n+        final RealVector v = create(data);\n+        final RealVectorChangingVisitor visitor;\n+        visitor = new RealVectorChangingVisitor() {\n+\n+            private int expectedIndex;\n+\n+            public double visit(final int actualIndex, final double actualValue) {\n+                Assert.assertEquals(expectedIndex, actualIndex);\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+                ++expectedIndex;\n+                return actualIndex + actualValue;\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(expectedStart, actualStart);\n+                Assert.assertEquals(expectedEnd, actualEnd);\n+                expectedIndex = expectedStart;\n+            }\n+\n+            public double end() {\n+                return 0.0;\n+            }\n+        };\n+        v.walkInDefaultOrder(visitor, expectedStart, expectedEnd);\n+        for (int i = expectedStart; i <= expectedEnd; i++) {\n+            Assert.assertEquals(\"entry \" + i, i + data[i], v.getEntry(i), 0.0);\n+        }\n+    }\n+\n+    /** The whole vector is visited. */\n+    @Test\n+    public void testWalkInOptimizedOrderChangingVisitor1() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final RealVector v = create(data);\n+        final RealVectorChangingVisitor visitor;\n+        visitor = new RealVectorChangingVisitor() {\n+            private final boolean[] visited = new boolean[data.length];\n+\n+            public double visit(final int actualIndex, final double actualValue) {\n+                visited[actualIndex] = true;\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+                return actualIndex + actualValue;\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(0, actualStart);\n+                Assert.assertEquals(data.length - 1, actualEnd);\n+                Arrays.fill(visited, false);\n+            }\n+\n+            public double end() {\n+                for (int i = 0; i < data.length; i++) {\n+                    Assert.assertTrue(\"entry \" + i + \"has not been visited\",\n+                                      visited[i]);\n+                }\n+                return 0.0;\n+            }\n+        };\n+        v.walkInOptimizedOrder(visitor);\n+        for (int i = 0; i < data.length; i++) {\n+            Assert.assertEquals(\"entry \" + i, i + data[i], v.getEntry(i), 0.0);\n+        }\n+    }\n+\n+    /** Visiting an invalid subvector. */\n+    @Test\n+    public void testWalkInOptimizedOrderChangingVisitor2() {\n+        final RealVector v = create(new double[5]);\n+        final RealVectorChangingVisitor visitor;\n+        visitor = new RealVectorChangingVisitor() {\n+\n+            public double visit(int index, double value) {\n+                return 0.0;\n+            }\n+\n+            public void start(int dimension, int start, int end) {\n+                // Do nothing\n+            }\n+\n+            public double end() {\n+                return 0.0;\n+            }\n+        };\n+        try {\n+            v.walkInOptimizedOrder(visitor, -1, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 5, 4);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 0, -1);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 0, 5);\n+            Assert.fail();\n+        } catch (OutOfRangeException e) {\n+            // Expected behavior\n+        }\n+        try {\n+            v.walkInOptimizedOrder(visitor, 4, 0);\n+            Assert.fail();\n+        } catch (NumberIsTooSmallException e) {\n+            // Expected behavior\n+        }\n+    }\n+\n+    /** Visiting a valid subvector. */\n+    @Test\n+    public void testWalkInOptimizedOrderChangingVisitor3() {\n+        final double[] data = new double[] {\n+            0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d\n+        };\n+        final int expectedStart = 2;\n+        final int expectedEnd = 7;\n+        final RealVector v = create(data);\n+        final RealVectorChangingVisitor visitor;\n+        visitor = new RealVectorChangingVisitor() {\n+            private final boolean[] visited = new boolean[data.length];\n+\n+            public double visit(final int actualIndex, final double actualValue) {\n+                Assert.assertEquals(Integer.toString(actualIndex),\n+                                    data[actualIndex], actualValue, 0d);\n+                visited[actualIndex] = true;\n+                return actualIndex + actualValue;\n+            }\n+\n+            public void start(final int actualSize, final int actualStart,\n+                              final int actualEnd) {\n+                Assert.assertEquals(data.length, actualSize);\n+                Assert.assertEquals(expectedStart, actualStart);\n+                Assert.assertEquals(expectedEnd, actualEnd);\n+                Arrays.fill(visited, true);\n+            }\n+\n+            public double end() {\n+                for (int i = expectedStart; i <= expectedEnd; i++) {\n+                    Assert.assertTrue(\"entry \" + i + \"has not been visited\",\n+                                      visited[i]);\n+                }\n+                return 0.0;\n+            }\n+        };\n+        v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd);\n+        for (int i = expectedStart; i <= expectedEnd; i++) {\n+            Assert.assertEquals(\"entry \" + i, i + data[i], v.getEntry(i), 0.0);\n+        }\n+    }\n }", "timestamp": 1338228224, "metainfo": ""}