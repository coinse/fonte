{"sha": "05e4d4bd0381215407b8d2247c1f7aba01c74bf6", "log": "Merged QRDecomposition and QRDecompositionImpl (see MATH-662).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n \n package org.apache.commons.math.linear;\n \n+import java.util.Arrays;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n+\n \n /**\n- * An interface to classes that implement an algorithm to calculate the\n- * QR-decomposition of a real matrix.\n- * <p>This interface is based on the class with similar name from the\n+ * Calculates the QR-decomposition of a matrix.\n+ * <p>The QR-decomposition of a matrix A consists of two matrices Q and R\n+ * that satisfy: A = QR, Q is orthogonal (Q<sup>T</sup>Q = I), and R is\n+ * upper triangular. If A is m&times;n, Q is m&times;m and R m&times;n.</p>\n+ * <p>This class compute the decomposition using Householder reflectors.</p>\n+ * <p>For efficiency purposes, the decomposition in packed form is transposed.\n+ * This allows inner loop to iterate inside rows, which is much more cache-efficient\n+ * in Java.</p>\n+ * <p>This class is based on the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\n  * <ul>\n  *   <li>a {@link #getQT() getQT} method has been added,</li>\n- *   <li>the <code>solve</code> and <code>isFullRank</code> methods have been replaced\n- *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n- *   the returned {@link DecompositionSolver}.</li>\n+ *   <li>the {@code solve} and {@code isFullRank} methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods\n+ *   provided by the returned {@link DecompositionSolver}.</li>\n  * </ul>\n  *\n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n+ *\n  * @version $Id$\n- * @since 1.2\n+ * @since 1.2 (changed to concrete class in 3.0)\n  */\n-public interface QRDecomposition {\n+public class QRDecomposition {\n+\n+    /**\n+     * A packed TRANSPOSED representation of the QR decomposition.\n+     * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+     * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+     * from which an explicit form of Q can be recomputed if desired.</p>\n+     */\n+    private double[][] qrt;\n+\n+    /** The diagonal elements of R. */\n+    private double[] rDiag;\n+\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+\n+    /** Cached value of QT. */\n+    private RealMatrix cachedQT;\n+\n+    /** Cached value of R. */\n+    private RealMatrix cachedR;\n+\n+    /** Cached value of H. */\n+    private RealMatrix cachedH;\n+\n+    /**\n+     * Calculates the QR-decomposition of the given matrix.\n+     * @param matrix The matrix to decompose.\n+     */\n+    public QRDecomposition(RealMatrix matrix) {\n+\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        qrt = matrix.transpose().getData();\n+        rDiag = new double[FastMath.min(m, n)];\n+        cachedQ  = null;\n+        cachedQT = null;\n+        cachedR  = null;\n+        cachedH  = null;\n+\n+        /*\n+         * The QR decomposition of a matrix A is calculated using Householder\n+         * reflectors by repeating the following operations to each minor\n+         * A(minor,minor) of A:\n+         */\n+        for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n+\n+            final double[] qrtMinor = qrt[minor];\n+\n+            /*\n+             * Let x be the first column of the minor, and a^2 = |x|^2.\n+             * x will be in the positions qr[minor][minor] through qr[m][minor].\n+             * The first column of the transformed minor will be (a,0,0,..)'\n+             * The sign of a is chosen to be opposite to the sign of the first\n+             * component of x. Let's find a:\n+             */\n+            double xNormSqr = 0;\n+            for (int row = minor; row < m; row++) {\n+                final double c = qrtMinor[row];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (qrtMinor[minor] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n+            rDiag[minor] = a;\n+\n+            if (a != 0.0) {\n+\n+                /*\n+                 * Calculate the normalized reflection vector v and transform\n+                 * the first column. We know the norm of v beforehand: v = x-ae\n+                 * so |v|^2 = <x-ae,x-ae> = <x,x>-2a<x,e>+a^2<e,e> =\n+                 * a^2+a^2-2a<x,e> = 2a*(a - <x,e>).\n+                 * Here <x, e> is now qr[minor][minor].\n+                 * v = x-ae is stored in the column at qr:\n+                 */\n+                qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n+\n+                /*\n+                 * Transform the rest of the columns of the minor:\n+                 * They will be transformed by the matrix H = I-2vv'/|v|^2.\n+                 * If x is a column vector of the minor, then\n+                 * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.\n+                 * Therefore the transformation is easily calculated by\n+                 * subtracting the column vector (2<x,v>/|v|^2)v from x.\n+                 *\n+                 * Let 2<x,v>/|v|^2 = alpha. From above we have\n+                 * |v|^2 = -2a*(qr[minor][minor]), so\n+                 * alpha = -<x,v>/(a*qr[minor][minor])\n+                 */\n+                for (int col = minor+1; col < n; col++) {\n+                    final double[] qrtCol = qrt[col];\n+                    double alpha = 0;\n+                    for (int row = minor; row < m; row++) {\n+                        alpha -= qrtCol[row] * qrtMinor[row];\n+                    }\n+                    alpha /= a * qrtMinor[minor];\n+\n+                    // Subtract the column vector alpha*v from x.\n+                    for (int row = minor; row < m; row++) {\n+                        qrtCol[row] -= alpha * qrtMinor[row];\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n     /**\n      * Returns the matrix R of the decomposition.\n      * <p>R is an upper-triangular matrix</p>\n      * @return the R matrix\n      */\n-    RealMatrix getR();\n+    public RealMatrix getR() {\n+\n+        if (cachedR == null) {\n+\n+            // R is supposed to be m x n\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            cachedR = MatrixUtils.createRealMatrix(m, n);\n+\n+            // copy the diagonal from rDiag and the upper triangle of qr\n+            for (int row = FastMath.min(m, n) - 1; row >= 0; row--) {\n+                cachedR.setEntry(row, row, rDiag[row]);\n+                for (int col = row + 1; col < n; col++) {\n+                    cachedR.setEntry(row, col, qrt[col][row]);\n+                }\n+            }\n+        }\n+\n+        // return the cached matrix\n+        return cachedR;\n+    }\n \n     /**\n      * Returns the matrix Q of the decomposition.\n      * <p>Q is an orthogonal matrix</p>\n      * @return the Q matrix\n      */\n-    RealMatrix getQ();\n+    public RealMatrix getQ() {\n+        if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n \n     /**\n      * Returns the transpose of the matrix Q of the decomposition.\n      * <p>Q is an orthogonal matrix</p>\n      * @return the Q matrix\n      */\n-    RealMatrix getQT();\n+    public RealMatrix getQT() {\n+        if (cachedQT == null) {\n+\n+            // QT is supposed to be m x m\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            cachedQT = MatrixUtils.createRealMatrix(m, m);\n+\n+            /*\n+             * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then\n+             * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in\n+             * succession to the result\n+             */\n+            for (int minor = m - 1; minor >= FastMath.min(m, n); minor--) {\n+                cachedQT.setEntry(minor, minor, 1.0);\n+            }\n+\n+            for (int minor = FastMath.min(m, n)-1; minor >= 0; minor--){\n+                final double[] qrtMinor = qrt[minor];\n+                cachedQT.setEntry(minor, minor, 1.0);\n+                if (qrtMinor[minor] != 0.0) {\n+                    for (int col = minor; col < m; col++) {\n+                        double alpha = 0;\n+                        for (int row = minor; row < m; row++) {\n+                            alpha -= cachedQT.getEntry(col, row) * qrtMinor[row];\n+                        }\n+                        alpha /= rDiag[minor] * qrtMinor[minor];\n+\n+                        for (int row = minor; row < m; row++) {\n+                            cachedQT.addToEntry(col, row, -alpha * qrtMinor[row]);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // return the cached matrix\n+        return cachedQT;\n+    }\n \n     /**\n      * Returns the Householder reflector vectors.\n      * to compute Q.</p>\n      * @return a matrix containing the Householder reflector vectors\n      */\n-    RealMatrix getH();\n+    public RealMatrix getH() {\n+        if (cachedH == null) {\n+\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            cachedH = MatrixUtils.createRealMatrix(m, n);\n+            for (int i = 0; i < m; ++i) {\n+                for (int j = 0; j < FastMath.min(i + 1, n); ++j) {\n+                    cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);\n+                }\n+            }\n+        }\n+\n+        // return the cached matrix\n+        return cachedH;\n+    }\n \n     /**\n      * Get a solver for finding the A &times; X = B solution in least square sense.\n      * @return a solver\n      */\n-    DecompositionSolver getSolver();\n-\n+    public DecompositionSolver getSolver() {\n+        return new Solver(qrt, rDiag);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+\n+        /**\n+         * A packed TRANSPOSED representation of the QR decomposition.\n+         * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+         * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+         * from which an explicit form of Q can be recomputed if desired.</p>\n+         */\n+        private final double[][] qrt;\n+\n+        /** The diagonal elements of R. */\n+        private final double[] rDiag;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param qrt packed TRANSPOSED representation of the QR decomposition\n+         * @param rDiag diagonal elements of R\n+         */\n+        private Solver(final double[][] qrt, final double[] rDiag) {\n+            this.qrt   = qrt;\n+            this.rDiag = rDiag;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+\n+            for (double diag : rDiag) {\n+                if (diag == 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b) {\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            if (b.getDimension() != m) {\n+                throw new DimensionMismatchException(b.getDimension(), m);\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] x = new double[n];\n+            final double[] y = b.toArray();\n+\n+            // apply Householder transforms to solve Q.y = b\n+            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n+\n+                final double[] qrtMinor = qrt[minor];\n+                double dotProduct = 0;\n+                for (int row = minor; row < m; row++) {\n+                    dotProduct += y[row] * qrtMinor[row];\n+                }\n+                dotProduct /= rDiag[minor] * qrtMinor[minor];\n+\n+                for (int row = minor; row < m; row++) {\n+                    y[row] += dotProduct * qrtMinor[row];\n+                }\n+            }\n+\n+            // solve triangular system R.x = y\n+            for (int row = rDiag.length - 1; row >= 0; --row) {\n+                y[row] /= rDiag[row];\n+                final double yRow = y[row];\n+                final double[] qrtRow = qrt[row];\n+                x[row] = yRow;\n+                for (int i = 0; i < row; i++) {\n+                    y[i] -= yRow * qrtRow[i];\n+                }\n+            }\n+\n+            return new ArrayRealVector(x, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            if (b.getRowDimension() != m) {\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int columns        = b.getColumnDimension();\n+            final int blockSize      = BlockRealMatrix.BLOCK_SIZE;\n+            final int cBlocks        = (columns + blockSize - 1) / blockSize;\n+            final double[][] xBlocks = BlockRealMatrix.createBlocksLayout(n, columns);\n+            final double[][] y       = new double[b.getRowDimension()][blockSize];\n+            final double[]   alpha   = new double[blockSize];\n+\n+            for (int kBlock = 0; kBlock < cBlocks; ++kBlock) {\n+                final int kStart = kBlock * blockSize;\n+                final int kEnd   = FastMath.min(kStart + blockSize, columns);\n+                final int kWidth = kEnd - kStart;\n+\n+                // get the right hand side vector\n+                b.copySubMatrix(0, m - 1, kStart, kEnd - 1, y);\n+\n+                // apply Householder transforms to solve Q.y = b\n+                for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n+                    final double[] qrtMinor = qrt[minor];\n+                    final double factor     = 1.0 / (rDiag[minor] * qrtMinor[minor]);\n+\n+                    Arrays.fill(alpha, 0, kWidth, 0.0);\n+                    for (int row = minor; row < m; ++row) {\n+                        final double   d    = qrtMinor[row];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            alpha[k] += d * yRow[k];\n+                        }\n+                    }\n+                    for (int k = 0; k < kWidth; ++k) {\n+                        alpha[k] *= factor;\n+                    }\n+\n+                    for (int row = minor; row < m; ++row) {\n+                        final double   d    = qrtMinor[row];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yRow[k] += alpha[k] * d;\n+                        }\n+                    }\n+                }\n+\n+                // solve triangular system R.x = y\n+                for (int j = rDiag.length - 1; j >= 0; --j) {\n+                    final int      jBlock = j / blockSize;\n+                    final int      jStart = jBlock * blockSize;\n+                    final double   factor = 1.0 / rDiag[j];\n+                    final double[] yJ     = y[j];\n+                    final double[] xBlock = xBlocks[jBlock * cBlocks + kBlock];\n+                    int index = (j - jStart) * kWidth;\n+                    for (int k = 0; k < kWidth; ++k) {\n+                        yJ[k]          *= factor;\n+                        xBlock[index++] = yJ[k];\n+                    }\n+\n+                    final double[] qrtJ = qrt[j];\n+                    for (int i = 0; i < j; ++i) {\n+                        final double rIJ  = qrtJ[i];\n+                        final double[] yI = y[i];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yI[k] -= yJ[k] * rIJ;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return new BlockRealMatrix(n, columns, xBlocks, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() {\n+            return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.QRDecomposition;\n-import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n \n /** Transformer to Nordsieck vectors for Adams integrators.\n \n         // solve the rectangular system in the least square sense\n         // to get the best estimate of the Nordsieck vector [s2 ... sk]\n-        QRDecomposition decomposition = new QRDecompositionImpl(new Array2DRowRealMatrix(a, false));\n+        QRDecomposition decomposition;\n+        decomposition = new QRDecomposition(new Array2DRowRealMatrix(a, false));\n         RealMatrix x = decomposition.getSolver().solve(new Array2DRowRealMatrix(b, false));\n         return new Array2DRowRealMatrix(x.getData(), false);\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.LUDecomposition;\n-import org.apache.commons.math.linear.QRDecompositionImpl;\n+import org.apache.commons.math.linear.QRDecomposition;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n                 RealMatrix mA = new BlockRealMatrix(a);\n                 DecompositionSolver solver = useLU ?\n                         new LUDecomposition(mA).getSolver() :\n-                        new QRDecompositionImpl(mA).getSolver();\n+                        new QRDecomposition(mA).getSolver();\n                 final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                 // update the estimated parameters\n                 for (int i = 0; i < cols; ++i) {\n--- a/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.LUDecomposition;\n import org.apache.commons.math.linear.QRDecomposition;\n-import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.stat.StatUtils;\n  * <pre><code> X<sup>T</sup> X b = X<sup>T</sup> y </code></pre></p>\n  *\n  * <p>To solve the normal equations, this implementation uses QR decomposition\n- * of the <code>X</code> matrix. (See {@link QRDecompositionImpl} for details on the\n+ * of the <code>X</code> matrix. (See {@link QRDecomposition} for details on the\n  * decomposition algorithm.) The <code>X</code> matrix, also known as the <i>design matrix,</i>\n  * has rows corresponding to sample observations and columns corresponding to independent\n  * variables.  When the model is estimated using an intercept term (i.e. when\n     @Override\n     public void newSampleData(double[] data, int nobs, int nvars) {\n         super.newSampleData(data, nobs, nvars);\n-        qr = new QRDecompositionImpl(X);\n+        qr = new QRDecomposition(X);\n     }\n \n     /**\n     @Override\n     protected void newXSampleData(double[][] x) {\n         super.newXSampleData(x);\n-        qr = new QRDecompositionImpl(X);\n+        qr = new QRDecomposition(X);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/QRDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class QRDecompositionTest {\n+    double[][] testData3x3NonSingular = {\n+            { 12, -51, 4 },\n+            { 6, 167, -68 },\n+            { -4, 24, -41 }, };\n+\n+    double[][] testData3x3Singular = {\n+            { 1, 4, 7, },\n+            { 2, 5, 8, },\n+            { 3, 6, 9, }, };\n+\n+    double[][] testData3x4 = {\n+            { 12, -51, 4, 1 },\n+            { 6, 167, -68, 2 },\n+            { -4, 24, -41, 3 }, };\n+\n+    double[][] testData4x3 = {\n+            { 12, -51, 4, },\n+            { 6, 167, -68, },\n+            { -4, 24, -41, },\n+            { -5, 34, 7, }, };\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() {\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkDimension(createTestMatrix(r, p, q));\n+        checkDimension(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkDimension(RealMatrix m) {\n+        int rows = m.getRowDimension();\n+        int columns = m.getColumnDimension();\n+        QRDecomposition qr = new QRDecomposition(m);\n+        Assert.assertEquals(rows,    qr.getQ().getRowDimension());\n+        Assert.assertEquals(rows,    qr.getQ().getColumnDimension());\n+        Assert.assertEquals(rows,    qr.getR().getRowDimension());\n+        Assert.assertEquals(columns, qr.getR().getColumnDimension());\n+    }\n+\n+    /** test A = QR */\n+    @Test\n+    public void testAEqualQR() {\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkAEqualQR(createTestMatrix(r, p, q));\n+\n+        checkAEqualQR(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkAEqualQR(RealMatrix m) {\n+        QRDecomposition qr = new QRDecomposition(m);\n+        double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test the orthogonality of Q */\n+    @Test\n+    public void testQOrthogonal() {\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkQOrthogonal(createTestMatrix(r, p, q));\n+\n+        checkQOrthogonal(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkQOrthogonal(RealMatrix m) {\n+        QRDecomposition qr = new QRDecomposition(m);\n+        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());\n+        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test that R is upper triangular */\n+    @Test\n+    public void testRUpperTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkUpperTriangular(new QRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkUpperTriangular(new QRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkUpperTriangular(new QRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkUpperTriangular(new QRDecomposition(matrix).getR());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new QRDecomposition(matrix).getR());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new QRDecomposition(matrix).getR());\n+\n+    }\n+\n+    private void checkUpperTriangular(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column < row) {\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+\n+    /** test that H is trapezoidal */\n+    @Test\n+    public void testHTrapezoidal() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkTrapezoidal(new QRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkTrapezoidal(new QRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkTrapezoidal(new QRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkTrapezoidal(new QRDecomposition(matrix).getH());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new QRDecomposition(matrix).getH());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new QRDecomposition(matrix).getH());\n+\n+    }\n+\n+    private void checkTrapezoidal(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column > row) {\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues() {\n+        QRDecomposition qr =\n+            new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+        RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n+                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n+                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }\n+        });\n+        RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -14.0,  -21.0, 14.0 },\n+                {   0.0, -175.0, 70.0 },\n+                {   0.0,    0.0, 35.0 }\n+        });\n+        RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 26.0 / 14.0, 0.0, 0.0 },\n+                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },\n+                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix q = qr.getQ();\n+        Assert.assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n+        RealMatrix qT = qr.getQT();\n+        Assert.assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);\n+        RealMatrix r = qr.getR();\n+        Assert.assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n+        RealMatrix h = qr.getH();\n+        Assert.assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(q == qr.getQ());\n+        Assert.assertTrue(r == qr.getR());\n+        Assert.assertTrue(h == qr.getH());\n+\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n+            @Override\n+            public double visit(int row, int column, double value) {\n+                return 2.0 * r.nextDouble() - 1.0;\n+            }\n+        });\n+        return m;\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n     @Test\n     public void testRank() {\n         DecompositionSolver solver =\n-            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n+            new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n         Assert.assertTrue(solver.isNonSingular());\n \n-        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n+        solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n         Assert.assertFalse(solver.isNonSingular());\n \n-        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)).getSolver();\n+        solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x4)).getSolver();\n         Assert.assertTrue(solver.isNonSingular());\n \n-        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)).getSolver();\n+        solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData4x3)).getSolver();\n         Assert.assertTrue(solver.isNonSingular());\n \n     }\n     @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n-            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n+            new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n     @Test\n     public void testSolveRankErrors() {\n         DecompositionSolver solver =\n-            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n+            new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n         try {\n             solver.solve(b);\n     @Test\n     public void testSolve() {\n         QRDecomposition decomposition =\n-            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+            new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n         DecompositionSolver solver = decomposition.getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n         });\n \n         // despite perturbation, the least square solution should be pretty good\n-        RealMatrix x = new QRDecompositionImpl(a).getSolver().solve(b);\n+        RealMatrix x = new QRDecomposition(a).getSolver().solve(b);\n         Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);\n \n     }\n         RealMatrix   a    = createTestMatrix(r, p, q);\n         RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n         RealMatrix   b    = a.multiply(xRef);\n-        RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);\n+        RealMatrix   x = new QRDecomposition(a).getSolver().solve(b);\n \n         // too many equations, the system cannot be solved at all\n         Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);", "timestamp": 1316839658, "metainfo": ""}