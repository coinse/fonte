{"sha": "d2a5bc02c002acfa220ce8bad23b9e8af137f47d", "log": "MATH-370 Removed deprecated methods.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n \n     /**\n      * Returns true iff they are equal as defined by\n-     * {@link #equals(double,double,int) this method}.\n+     * {@link #equals(double,double,int) equals(x, y, 1)}.\n      *\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double,double)\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x, y, 1);\n     }\n \n     /**\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n      * and equal elements.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n             }\n         }\n         return ret;\n-    }\n-\n-    /**\n-     * Get the next machine representable number after a number, moving\n-     * in the direction of another number.\n-     * <p>\n-     * If <code>direction</code> is greater than or equal to<code>d</code>,\n-     * the smallest machine representable number strictly greater than\n-     * <code>d</code> is returned; otherwise the largest representable number\n-     * strictly less than <code>d</code> is returned.</p>\n-     * <p>\n-     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n-     *\n-     * @param d base number\n-     * @param direction (the only important thing is whether\n-     * direction is greater or smaller than d)\n-     * @return the next machine representable number in the specified direction\n-     * @since 1.2\n-     * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\n-     */\n-    @Deprecated\n-    public static double nextAfter(double d, double direction) {\n-        return FastMath.nextAfter(d, direction);\n     }\n \n     /**\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_DOWN :\n-            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             break;\n         case BigDecimal.ROUND_FLOOR :\n             if (sign == -1) {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_HALF_DOWN : {\n-            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction > 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n             break;\n         }\n         case BigDecimal.ROUND_HALF_UP : {\n-            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction >= 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n-            unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n             throw MathRuntimeException.createIllegalArgumentException(\n      */\n     public static void checkOrder(double[] val) {\n         checkOrder(val, OrderDirection.INCREASING, true);\n-    }\n-\n-    /**\n-     * Checks that the given array is sorted.\n-     *\n-     * @param val Values\n-     * @param dir Order direction (-1 for decreasing, 1 for increasing)\n-     * @param strict Whether the order should be strict\n-     * @throws NonMonotonousSequenceException if the array is not sorted.\n-     * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)\n-     * checkOrder} method). To be removed in 3.0.\n-     */\n-    public static void checkOrder(double[] val, int dir, boolean strict) {\n-        if (dir > 0) {\n-            checkOrder(val, OrderDirection.INCREASING, strict);\n-        } else {\n-            checkOrder(val, OrderDirection.DECREASING, strict);\n-        }\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n         assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n         assertTrue(MathUtils.equals(new double[] {\n-                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.POSITIVE_INFINITY,\n                                       Double.NEGATIVE_INFINITY, 1d, 0d\n                                     }, new double[] {\n-                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.POSITIVE_INFINITY,\n                                       Double.NEGATIVE_INFINITY, 1d, 0d\n                                     }));\n+        assertFalse(MathUtils.equals(new double[] { Double.NaN },\n+                                     new double[] { Double.NaN }));\n         assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n                                      new double[] { Double.NEGATIVE_INFINITY }));\n         assertFalse(MathUtils.equals(new double[] { 1d },\n-                                     new double[] { FastMath.nextAfter(1d, 2d) }));\n+                                     new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n \n     }\n ", "timestamp": 1283348755, "metainfo": ""}