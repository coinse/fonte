{"sha": "379ad27ea0279c786847bf763cca4f26789ac151", "log": "trigger an error when the transform is not invertible  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n+++ b/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n import org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor;\n import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n import org.apache.commons.math.linear.decomposition.FieldDecompositionSolver;\n \n     /**\n      * Build a transformer for a specified order.\n-     * <p>states considered are y<sub>k-p</sub>, y<sub>k-(p+1)</sub> ...\n+     * <p>States considered are y<sub>k-p</sub>, y<sub>k-(p+1)</sub> ...\n      * y<sub>k-(q-1)</sub> and scaled derivatives considered are\n-     * h y'<sub>k-r</sub>, h y'<sub>k-(r+1)</sub> ... h y'<sub>k-(s-1)</sub>\n+     * h y'<sub>k-r</sub>, h y'<sub>k-(r+1)</sub> ... h y'<sub>k-(s-1)</sub><\\p>\n      * @param p start state index offset in multistep form\n      * @param q end state index offset in multistep form\n      * @param r start state derivative index offset in multistep form\n      * @param s end state derivative index offset in multistep form\n-     */\n-    public NordsieckTransformer(final int p, final int q, final int r, final int s) {\n+     * @exception InvalidMatrixException if the selected indices ranges define a\n+     * non-invertible transform (this typically happens when p == q)\n+     */\n+    public NordsieckTransformer(final int p, final int q, final int r, final int s)\n+        throws InvalidMatrixException {\n \n         // from Nordsieck to multistep\n         final FieldMatrix<BigFraction> bigNtoM = buildNordsieckToMultistep(p, q, r, s);\n \n     /**\n      * Build the transform from Nordsieck to multistep.\n-     * <p>states considered are y<sub>k-p</sub>, y<sub>k-(p+1)</sub> ...\n+     * <p>States considered are y<sub>k-p</sub>, y<sub>k-(p+1)</sub> ...\n      * y<sub>k-(q-1)</sub> and scaled derivatives considered are\n      * h y'<sub>k-r</sub>, h y'<sub>k-(r+1)</sub> ... h y'<sub>k-(s-1)</sub>\n      * @param p start state index offset in multistep form\n         for (int l = r; l < s; ++l) {\n             // handle previous state scaled derivative h y'<sub>(k-l)</sub>\n             // the following expressions are direct applications of Taylor series\n-            // h y'<sub>k-1</sub>: [ 0  1  -2   3  -4   5 ...]\n-            // h y'<sub>k-2</sub>: [ 0  1  -4   6  -8  10 ...]\n-            // h y'<sub>k-3</sub>: [ 0  1  -6   9 -12  15 ...]\n-            // h y'<sub>k-4</sub>: [ 0  1  -8  12 -16  20 ...]\n+            // h y'<sub>k-1</sub>: [ 0  1  -2   3   -4     5 ...]\n+            // h y'<sub>k-2</sub>: [ 0  1  -4  12  -32    80 ...]\n+            // h y'<sub>k-3</sub>: [ 0  1  -6  27 -108   405 ...]\n+            // h y'<sub>k-4</sub>: [ 0  1  -8  48 -256  1280 ...]\n             final BigFraction[] row = array[i++];\n             final BigInteger factor = BigInteger.valueOf(-l);\n             row[0] = BigFraction.ZERO;", "timestamp": 1242940875, "metainfo": ""}