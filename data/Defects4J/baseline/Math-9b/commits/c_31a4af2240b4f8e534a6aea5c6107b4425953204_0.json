{"sha": "31a4af2240b4f8e534a6aea5c6107b4425953204", "log": "Unthrown Exceptions  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n      * Test preconditions.\n      */\n     @Test\n-    public void testPreconditions() throws MathException {\n+    public void testPreconditions() throws Exception {\n         double[] xval = new double[] {3, 4, 5, 6.5};\n         double[] yval = new double[] {-4, -3, -1, 2.5};\n         double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};\n--- a/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n         }\n     }\n \n-    public void testDensity() throws MathException {\n+    public void testDensity() {\n         double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};\n         checkDensity(0.1, 0.1,\n                 x, new double[]{\n \n     }\n \n-    private void checkDensity(double alpha, double beta, double[] x, double[] expected) throws MathException {\n+    private void checkDensity(double alpha, double beta, double[] x, double[] expected) {\n         BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n         for (int i = 0; i < x.length; i++) {\n             assertEquals(String.format(\"density at x=%.1f for alpha=%.1f, beta=%.1f\", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n public class MultiStartDifferentiableMultivariateVectorialOptimizerTest {\n \n     @Test\n-    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+    public void testTrivial() throws FunctionEvaluationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n     }\n \n     @Test(expected = ConvergenceException.class)\n-    public void testNoOptimum() throws FunctionEvaluationException, OptimizationException {\n+    public void testNoOptimum() throws FunctionEvaluationException {\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n             new GaussNewtonOptimizer(true);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.direct.NelderMead;\n \n   @Test\n   public void testRosenbrock()\n-    throws FunctionEvaluationException, ConvergenceException {\n+    throws FunctionEvaluationException {\n \n     Rosenbrock rosenbrock = new Rosenbrock();\n     NelderMead underlying = new NelderMead();\n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n import org.apache.commons.math.util.FastMath;\n \n   @Test\n   public void testMinimizeMaximize()\n-      throws FunctionEvaluationException, ConvergenceException {\n+      throws FunctionEvaluationException {\n \n       // the following function has 4 local extrema:\n       final double xM        = -3.841947088256863675365;\n \n   @Test\n   public void testRosenbrock()\n-    throws FunctionEvaluationException, ConvergenceException {\n+    throws FunctionEvaluationException {\n \n     MultivariateRealFunction rosenbrock =\n       new MultivariateRealFunction() {\n \n   @Test\n   public void testPowell()\n-    throws FunctionEvaluationException, ConvergenceException {\n+    throws FunctionEvaluationException {\n \n     MultivariateRealFunction powell =\n       new MultivariateRealFunction() {\n \n   @Test\n   public void testMath283()\n-      throws FunctionEvaluationException, OptimizationException {\n+      throws FunctionEvaluationException {\n       // fails because MultiDirectional.iterateSimplex is looping forever\n       // the while(true) should be replaced with a convergence check\n       MultiDirectional multiDirectional = new MultiDirectional();\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n package org.apache.commons.math.optimization.fitting;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n \n     @Test\n     public void testMath303()\n-        throws OptimizationException, FunctionEvaluationException {\n+        throws FunctionEvaluationException {\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter fitter = new CurveFitter(optimizer);\n \n     @Test\n     public void testMath304()\n-        throws OptimizationException, FunctionEvaluationException {\n+        throws FunctionEvaluationException {\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter fitter = new CurveFitter(optimizer);\n \n     @Test\n     public void testMath372()\n-    throws OptimizationException, FunctionEvaluationException {\n+    throws FunctionEvaluationException {\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         CurveFitter curveFitter = new CurveFitter(optimizer);\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n         super(name);\n     }\n \n-    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n+    public void testTrivial() throws FunctionEvaluationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         NonLinearConjugateGradientOptimizer optimizer =\n         assertEquals(0.0, optimum.getValue(), 1.0e-10);\n     }\n \n-    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n+    public void testColumnsPermutation() throws FunctionEvaluationException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n \n     }\n \n-    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n+    public void testNoDependency() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n+    public void testOneSet() throws FunctionEvaluationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n \n     }\n \n-    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n+    public void testTwoSets() throws FunctionEvaluationException {\n         final double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n \n     }\n \n-    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {\n+    public void testNonInversible() throws FunctionEvaluationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n         assertTrue(optimum.getValue() > 0.5);\n     }\n \n-    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n+    public void testIllConditioned() throws FunctionEvaluationException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n     }\n \n     public void testMoreEstimatedParametersSimple()\n-        throws FunctionEvaluationException, OptimizationException {\n+        throws FunctionEvaluationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n     }\n \n     public void testMoreEstimatedParametersUnsorted()\n-        throws FunctionEvaluationException, OptimizationException {\n+        throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                  { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                  { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n         assertEquals(0, optimum.getValue(), 1.0e-10);\n     }\n \n-    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n+    public void testRedundantEquations() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n+    public void testInconsistentEquations() throws FunctionEvaluationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n+    public void testCircleFitting() throws FunctionEvaluationException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);", "timestamp": 1285898584, "metainfo": ""}