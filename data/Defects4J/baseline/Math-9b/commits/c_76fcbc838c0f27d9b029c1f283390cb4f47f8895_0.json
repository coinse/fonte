{"sha": "76fcbc838c0f27d9b029c1f283390cb4f47f8895", "log": "MATH-395: Another bug uncovered; all things being equal, the code now behaves like the Puthon implementation. MATH-397: Modified \"BrentOptimizer\" following the changes in \"AbstractUnivariateRealOptimizer\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n     /**\n      * Increment the iterations counter by 1.\n      *\n-     * @throws OptimizationException if the maximal number\n+     * @throws MaxIterationsExceededException if the maximal number\n      * of iterations is exceeded.\n      * @since 2.2\n      */\n     protected void incrementIterationsCounter()\n-        throws ConvergenceException {\n+        throws MaxIterationsExceededException {\n         if (++iterationCount > maximalIterationCount) {\n-            throw new ConvergenceException(new MaxIterationsExceededException(maximalIterationCount));\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n      *\n      * @return the optimum.\n      */\n-    protected abstract double doOptimize();\n+    protected abstract double doOptimize()\n+        throws MaxIterationsExceededException, FunctionEvaluationException;\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n      * Construct a solver.\n      */\n     public BrentOptimizer() {\n-        super(100, 1E-10);\n+        setMaxEvaluations(1000);\n+        setMaximalIterationCount(100);\n+        setAbsoluteAccuracy(1e-11);\n+        setRelativeAccuracy(1e-9);\n     }\n \n-    /** {@inheritDoc} */\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n-                           final double min, final double max, final double startValue)\n+    /**\n+     * Perform the optimization.\n+     *\n+     * @return the optimum.\n+     */\n+    protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        clearResult();\n-        return localMin(f, goalType, min, startValue, max,\n+        return localMin(getGoalType() == GoalType.MINIMIZE,\n+                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n \n-    /** {@inheritDoc} */\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n-                           final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n-    }\n-\n-    /**\n-     * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n+    /**\n+     * Find the minimum of the function within the interval {@code (lo, hi)}.\n      *\n-     * If the function {@code f} is defined on the interval {@code (a, b)}, then\n-     * this method finds an approximation {@code x} to the point at which {@code f}\n-     * attains its minimum.<br/>\n-     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n-     * {@code f} is never evaluated at two points closer together than {@code tol}.\n-     * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n-     * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n-     * machine precision. {@code t} should be positive.\n-     * @param f the function to solve.\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}.\n+     * If the function is defined on the interval {@code (lo, hi)}, then\n+     * this method finds an approximation {@code x} to the point at which\n+     * the function attains its minimum.<br/>\n+     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n+     * and the function is never evaluated at two points closer together than\n+     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n+     * preferable not much less than <em>sqrt(macheps)</em>, where\n+     * <em>macheps</em> is the relative machine precision. {@code t} should be\n+     * positive.\n+     * @param isMinim {@code true} when minimizing the function.\n      * @param lo Lower bound of the interval.\n      * @param mid Point inside the interval {@code [lo, hi]}.\n      * @param hi Higher bound of the interval.\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function.\n      */\n-    private double localMin(UnivariateRealFunction f,\n-                            GoalType goalType,\n+    private double localMin(boolean isMinim,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         double x = mid;\n         double v = x;\n         double w = x;\n+        double d = 0;\n         double e = 0;\n-        double fx = computeObjectiveValue(f, x);\n-        if (goalType == GoalType.MAXIMIZE) {\n+        double fx = computeObjectiveValue(x);\n+        if (!isMinim) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n \n-        int count = 0;\n-        while (count < maximalIterationCount) {\n+        while (true) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n-                double d = 0;\n                 double u = 0;\n \n                 if (Math.abs(e) > tol1) { // Fit parabola.\n                     u = x + d;\n                 }\n \n-                double fu = computeObjectiveValue(f, u);\n-                if (goalType == GoalType.MAXIMIZE) {\n+                double fu = computeObjectiveValue(u);\n+                if (!isMinim) {\n                     fu = -fu;\n                 }\n \n                     }\n                 }\n             } else { // termination\n-                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n+                setFunctionValue(isMinim ? fx : -fx);\n                 return x;\n             }\n-            ++count;\n-        }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n-    }\n-\n-    /** Temporary workaround. */\n-    protected double doOptimize() {\n-        throw new UnsupportedOperationException();\n+            incrementIterationsCounter();\n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n             assertEquals(-1.0, f.value(optima[i]), 1.0e-10);\n             assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n         }\n-        assertTrue(minimizer.getEvaluations() > 1500);\n-        assertTrue(minimizer.getEvaluations() < 1700);\n+        assertTrue(minimizer.getEvaluations() > 150);\n+        assertTrue(minimizer.getEvaluations() < 250);\n     }\n \n     @Test\n         }\n \n         double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n-        assertEquals(-0.27195612525275803, result, 1.0e-13);\n-        assertEquals(-0.27195612525275803, minimizer.getResult(), 1.0e-13);\n+        assertEquals(-0.2719561270319131, result, 1.0e-13);\n+        assertEquals(-0.2719561270319131, minimizer.getResult(), 1.0e-13);\n         assertEquals(-0.04433426954946637, minimizer.getFunctionValue(), 1.0e-13);\n \n         double[] optima = minimizer.getOptima();\n         for (int i = 0; i < optima.length; ++i) {\n             assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n         }\n-\n-        assertTrue(minimizer.getEvaluations()    >= 300);\n-        assertTrue(minimizer.getEvaluations()    <= 420);\n-        assertTrue(minimizer.getIterationCount() >= 100);\n-        assertTrue(minimizer.getIterationCount() <= 140);\n+        assertTrue(minimizer.getEvaluations()    >= 120);\n+        assertTrue(minimizer.getEvaluations()    <= 170);\n+        assertTrue(minimizer.getIterationCount() >= 120);\n+        assertTrue(minimizer.getIterationCount() <= 170);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.junit.Test;\n \n /**\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         }\n-        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n         assertTrue(minimizer.getIterationCount() <= 50);\n-        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n         assertTrue(minimizer.getIterationCount() <= 50);\n         assertTrue(minimizer.getEvaluations()    <= 100);\n-        assertTrue(minimizer.getEvaluations()    >=  30);\n-        minimizer.setMaxEvaluations(50);\n+        assertTrue(minimizer.getEvaluations()    >=  15);\n+        minimizer.setMaxEvaluations(10);\n         try {\n             minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n             fail(\"an exception should have been thrown\");\n     }\n \n     @Test\n-    public void testQuinticMinPythonComparison() throws MathException {\n+    public void testQuinticMinStatistics() throws MathException {\n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer minimizer = new BrentOptimizer();\n-        minimizer.setRelativeAccuracy(1e-12);\n+        minimizer.setRelativeAccuracy(1e-10);\n         minimizer.setAbsoluteAccuracy(1e-11);\n \n-        double result;\n-        int nIter, nEval;\n+        final DescriptiveStatistics[] stat = new DescriptiveStatistics[3];\n+        for (int i = 0; i < stat.length; i++) {\n+            stat[i] = new DescriptiveStatistics();\n+        }\n \n-        result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2, -0.25);\n-        nIter = minimizer.getIterationCount();\n-        nEval = minimizer.getEvaluations();\n-        // XXX Python: -0.27195612805911351 (instead of -0.2719561279558559).\n-        assertEquals(-0.2719561279558559, result, 1e-12);\n-        // XXX Python: 15 (instead of 18).\n-        assertEquals(18, nEval);\n-        // XXX Python: 11 (instead of 17).\n-        assertEquals(17, nIter);\n+        final double min = -0.75;\n+        final double max = 0.25;\n+        final int nSamples = 200;\n+        final double delta = (max - min) / nSamples;\n+        for (int i = 0; i < nSamples; i++) {\n+            final double start = min + i * delta;\n+            stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start));\n+            stat[1].addValue(minimizer.getIterationCount());\n+            stat[2].addValue(minimizer.getEvaluations());\n+        }\n \n-        result = minimizer.optimize(f, GoalType.MINIMIZE, 0.7, 0.9, 0.8);\n-        nIter = minimizer.getIterationCount();\n-        nEval = minimizer.getEvaluations();\n-        // XXX Python: 0.82221643488363705 (instead of 0.8222164326561908).\n-        assertEquals(0.8222164326561908, result, 1e-12);\n-        // XXX Python: 25 (instead of 43).\n-        assertEquals(43, nEval);\n-        // XXX Python: 21 (instead of 24).\n-        assertEquals(24, nIter);\n+        final double meanOptValue = stat[0].getMean();\n+        final double medianIter = stat[1].getPercentile(50);\n+        final double medianEval = stat[2].getPercentile(50);\n+        assertTrue(meanOptValue > -0.27195612812 && meanOptValue < -0.27195612811);\n+        assertEquals(medianIter, 17, Math.ulp(1d));\n+        assertEquals(medianEval, 18, Math.ulp(1d));\n     }\n \n     @Test\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer minimizer = new BrentOptimizer();\n         assertEquals(0.27195613, minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3), 1.0e-8);\n-        minimizer.setMaximalIterationCount(20);\n+        minimizer.setMaximalIterationCount(5);\n         try {\n             minimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3);\n             fail(\"an exception should have been thrown\");\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealOptimizer solver = new BrentOptimizer();\n \n+        solver.setRelativeAccuracy(1e-8);\n+\n         // endpoint is minimum\n         double result = solver.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5);\n-        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n+        assertEquals(3 * Math.PI / 2, result, 10 * solver.getRelativeAccuracy());\n \n         result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2);\n-        assertEquals(3 * Math.PI / 2, result, 80 * solver.getAbsoluteAccuracy());\n+        assertEquals(3 * Math.PI / 2, result, 10 * solver.getRelativeAccuracy());\n     }\n }", "timestamp": 1280318621, "metainfo": ""}