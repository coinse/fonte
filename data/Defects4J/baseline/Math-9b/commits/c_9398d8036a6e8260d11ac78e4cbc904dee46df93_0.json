{"sha": "9398d8036a6e8260d11ac78e4cbc904dee46df93", "log": "Added an expandable double array, this class simply contains a double[] and takes care of automatic expansion of an internal array when necessary.  Class added with accompanying unit test   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * An array of double primitives which can expand as needed.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ExpandableDoubleArray {\n+\n+\t// This is the internal storage array.\n+\tprivate double[] internalArray;\n+\n+\t// Number of elements in the array\n+\tprivate int numElements = 0;\n+\n+\t// The initial capacity of the array. \n+\t// Initial capacity is not exposed as a property as it is only meaningful\n+\t// when passed to a constructor.\n+\tprivate int initialCapacity = 16;\n+\n+\t// The expand factor of the array.  When the array need to be expanded, the new array size\n+\t// will be internalArray.length * expandFactor \n+\tprivate float expansionFactor = 2.0f;\n+\n+\t/**\n+\t * Create an expandable double array with the\n+\t * default initial capactiy of 16 and an expansion factor of 2.00\n+\t */\n+\tpublic ExpandableDoubleArray() {\n+\t\tinternalArray = new double[initialCapacity];\n+\t}\n+\n+\t/**\n+\t * Create an expandable double array with the\n+\t * specified initial capacity and the defult expansion factor of 2.00\n+\t * \n+\t * @param initialCapacity The initial size of the internal storage array\n+\t */\n+\tpublic ExpandableDoubleArray(int initialCapacity) {\n+\t\tsetInitialCapacity(initialCapacity);\n+\t\tinternalArray = new double[this.initialCapacity];\n+\t}\n+\n+\t/**\n+\t * Create an expandable double array with the\n+\t * specificed initial capacity and expand factor.\n+\t * \n+\t * @param initialCapacity The initial size of the internal storage array\n+\t * @param expansionFactor the array will be expanded based on this parameter\n+\t */\n+\tpublic ExpandableDoubleArray(int initialCapacity, float expansionFactor) {\n+\t\tsetInitialCapacity( initialCapacity );\n+\t\tsetExpansionFactor(expansionFactor);\n+\t\tthis.initialCapacity = initialCapacity;\n+\t\tinternalArray = new double[initialCapacity];\n+\t}\n+\n+\t/**\n+\t * The expansion factor controls the size of a new aray when an array needs to be expanded.\n+\t * When a value is inserted into a full array, the new array size is calculated as the \n+\t * current array size times this expansion factor.  The default expansion factor is 2.0\n+\t * \n+\t * @return the expansion factor of this expandable double array\n+\t */\n+\tpublic float getExpansionFactor() {\n+\t\treturn expansionFactor;\n+\t}\n+\n+\t/**\n+\t * Sets the expansion factor for this expandable double array.  The expansion factor will\n+\t * affect the next expansion of this array.\n+\t * \n+\t * @param expansionFactor the expansion factor of this array\n+\t */\n+\tpublic void setExpansionFactor(float expansionFactor) {\n+\n+\t\t// The expansion factor *must* be larger than 1.0, otherwise we'll have an inconsistency\n+\t\t// upon expansion we'll start shrinking which will lead to ArrayOutOfBound exceptions.\n+\t\tif (expansionFactor > 1.0) {\n+\t\t\tthis.expansionFactor = expansionFactor;\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"The expansion factor must be a number greater than\" + \"1.0\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the initial capacity\n+\t * \n+\t * @param initialCapacity\n+\t */\n+\tpublic void setInitialCapacity(int initialCapacity) {\n+\t\tif (initialCapacity > 0) {\n+\t\t\tthis.initialCapacity = initialCapacity;\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"The initial capacity supplied: \"\n+\t\t\t\t\t+ initialCapacity\n+\t\t\t\t\t+ \"must be a positive integer\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns the internal storage array\n+\t * \n+\t * @return the internal storage array used by this object\n+\t */\n+\tpublic double[] getValues() {\n+\t\treturn (internalArray);\n+\t}\n+\n+\t/**\n+\t * Returns the number of elements currently in the array.  Please note\n+\t * that this is different from the length of the internal storage array.  \n+\t * @return number of elements\n+\t */\n+\tpublic int getNumElements() {\n+\t\treturn (numElements);\n+\t}\n+\n+\t/**\n+\t * Returns the element at the specified index\n+\t * \n+\t * @param index index to fetch a value from\n+\t * @return value stored at the specified index\n+\t */\n+\tpublic double getElement(int index) throws NoSuchElementException {\n+\t\tdouble value = Double.NaN;\n+\t\tif (index >= numElements) {\n+\t\t\tthrow new NoSuchElementException(\n+\t\t\t\t\"The index specified: \"\n+\t\t\t\t\t+ index\n+\t\t\t\t\t+ \" is larger than the \"\n+\t\t\t\t\t+ \"current number of elements\");\n+\t\t} else if (index >= 0) {\n+\t\t\tvalue = internalArray[index];\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"Elements cannot be retrieved from negative array \" + \"index\");\n+\t\t}\n+\t\treturn value;\n+\t}\n+\n+\t/**\n+\t * Sets the element at the specified index.  This method will expand the internal storage array to\n+\t * accomodate the insertion of a value at an index beyond the current capacity.\n+\t * @param index index to store a value in\n+\t * @param value value to store at the specified index\n+\t */\n+\tpublic synchronized void setElement(int index, double value) {\n+\t\t\n+\t\tif( index < 0 ) {\n+\t\t\tthrow new IllegalArgumentException( \"Cannot set an element at a negative index\");\n+\t\t}\n+\t\t\n+\t\tif (index >= internalArray.length) {\n+\t\t\texpandTo(index + 1);\n+\t\t\tnumElements = index + 1;\n+\t\t}\n+\t\tinternalArray[index] = value;\n+\t}\n+\n+\t/**\n+\t * Expands the internal storage array to the specified size.\n+\t * \n+\t * @param size Size of the new internal storage array\n+\t */\n+\tprivate synchronized void expandTo(int size) {\n+\t\tdouble[] tempArray = new double[size];\n+\t\t// Copy and swap\n+\t\tSystem.arraycopy(internalArray,0,tempArray,0,internalArray.length);\n+\t\tinternalArray = tempArray;\n+\t}\n+\n+\t/**\n+\t * Expands the internal storage array using the expansion factor\n+\t */\n+\tprivate synchronized void expand() {\n+\n+\t\t// notice the use of Math.ceil(), this gaurantees that we will always have an array of at least\n+\t\t// currentSize + 1.   Assume that the current initial capacity is 1 and the expansion factor\n+\t\t// is 1.000000000000000001.  The newly calculated size will be rounded up to 2 after\n+\t\t// the multiplication is performed.\n+\t\tint newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n+\t\tdouble[] tempArray =\n+\t\t\tnew double[newSize];\n+\n+\t\t// Copy and swap\n+\t\tSystem.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n+\t\tinternalArray = tempArray;\n+\t}\n+\n+\t/**\n+\t * Adds an element to the end of this expandable array\n+\t * \n+\t * @return value to be added to end of array\n+\t */\n+\tpublic synchronized void addElement(double value) {\n+\t\tnumElements++;\n+\t\tif (numElements > internalArray.length) {\n+\t\t\texpand();\n+\t\t}\n+\t\tinternalArray[numElements - 1] = value;\n+\t}\n+\n+\t/**\n+\t * Notice the package scope on this method.   This method is simply here for the JUnit\n+\t * test, it allows us check if the expansion is working properly after a number of expansions.  This\n+\t * is not meant to be a part of the public interface of this class.\n+\t * \n+\t * @return the length of the internal storage array.\n+\t */\n+\tint getInternalLength() {\n+\t\treturn (internalArray.length);\n+\t}\n+\t\n+\t/**\n+\t * Clear the array, reset the size to the initialCapacity and the number of elements to zero\n+\t */\n+\tpublic synchronized void clear() {\n+\t\tnumElements = 0;\n+\t\tinternalArray = new double[initialCapacity];\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ExpandableDoubleArrayTest extends TestCase {\n+\n+\tpublic ExpandableDoubleArrayTest(String name) {\n+\t\tsuper( name );\n+\t}\n+\t\n+\t/** TEST NORMAL OPERATIONS **/\n+\t\n+\tpublic void testAdd1000() {\n+\n+\t\tExpandableDoubleArray exDoubleArr = new ExpandableDoubleArray();\n+\t\t\n+\t\tfor( int i = 0; i < 1000; i++) {\n+\t\t\texDoubleArr.addElement( i );\n+\t\t}\n+\t\t\n+\t\tassertTrue(\"Number of elements should be equal to 1000 after adding 1000 values\",\n+\t\t\t\t\t\t\texDoubleArr.getNumElements() == 1000);\n+\t\t\t\t\t\t\t\n+\t\tassertTrue(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n+\t\t\t\"16 and an expansion factor of 2.0\",\n+\t\t\t\t\t\t    exDoubleArr.getInternalLength() == 1024);\n+\t\t\t\t\t\t    \n+\t\tassertTrue(\"The element at the 56th index should be 56\", \n+\t\t\t\t\t\t\texDoubleArr.getElement(56) == 56 );\n+\t\t\t\t\t\t    \n+\t}\n+\t\n+\tpublic void testWithInitialCapacity() {\n+\t\tExpandableDoubleArray exDoubleArr = new ExpandableDoubleArray(2);\n+\n+\t\tassertTrue(\"Initial internal length should be 2\", exDoubleArr.getInternalLength() == 2);\n+\t\tassertTrue(\"Initial number of elements should be 0\", exDoubleArr.getNumElements() == 0);\n+\n+\t\tint iterations = (int) Math.pow(2.0, 15.0);\n+\n+\t\tfor( int i = 0; i < iterations; i++) {\n+\t\t\texDoubleArr.addElement( i );\n+\t\t}\n+\t\t\n+\t\tassertTrue(\"Number of elements should be equal to 2^15\", exDoubleArr.getNumElements() == (int) Math.pow(2.0, 15.0));\n+\t\tassertTrue(\"Internal length should be 2^15\", exDoubleArr.getInternalLength() == (int) Math.pow(2.0, 15.0));\n+\t\t\n+\t\texDoubleArr.addElement( 2.0 );\n+\t\t\n+\t\tassertTrue(\"Number of elements should be equals to 2^15 + 1\",\n+\t\t\t\t\t\t   exDoubleArr.getNumElements() == ( (int) Math.pow(2.0, 15.0) + 1 ) );\n+\t\tassertTrue(\"Internal length should be 2^16\", exDoubleArr.getInternalLength() == (int) Math.pow(2.0, 16.0));\n+\t\t\t\t\t\t   \n+\n+\t}\n+\n+\tpublic void testWithInitialCapacitAndExpansionFactor() {\n+\t\tExpandableDoubleArray exDoubleArr = new ExpandableDoubleArray(3, 3.0f);\n+\n+\t\tassertTrue(\"Initial internal length should be 3\", exDoubleArr.getInternalLength() == 3);\n+\t\tassertTrue(\"Initial number of elements should be 0\", exDoubleArr.getNumElements() == 0);\n+\n+\t\tint iterations = (int) Math.pow(3.0, 7.0);\n+\n+\t\tfor( int i = 0; i < iterations; i++) {\n+\t\t\texDoubleArr.addElement( i );\n+\t\t}\n+\t\t\n+\t\tassertTrue(\"Number of elements should be equal to 3^7\", exDoubleArr.getNumElements() == (int) Math.pow(3.0, 7.0));\n+\t\tassertTrue(\"Internal length should be 3^7\", exDoubleArr.getInternalLength() == (int) Math.pow(3.0, 7.0));\n+\t\t\n+\t\texDoubleArr.addElement( 2.0 );\n+\t\t\n+\t\tassertTrue(\"Number of elements should be equals to 3^7 + 1\",\n+\t\t\t\t\t\t   exDoubleArr.getNumElements() == ( (int) Math.pow(3.0, 7.0) + 1 ) );\n+\t\tassertTrue(\"Internal length should be 3^8\", exDoubleArr.getInternalLength() == (int) Math.pow(3.0, 8.0));\n+\t\t\t\t\t\t   \n+\t\tassertTrue(\"Expansion factor should equal 3.0\", exDoubleArr.getExpansionFactor() == 3.0f);\n+\t}\n+\t\n+\tpublic void testGetValues() {\n+\t\t\n+\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n+\t\t\n+\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n+\t\t\n+\t\teDA.addElement(2.0);\n+\t\teDA.addElement(4.0);\n+\t\teDA.addElement(6.0);\n+\t\tdouble[] testArray = eDA.getValues();\n+\t\t\n+\t\tfor( int i = 0; i < eDA.getNumElements(); i++) {\n+\t\t\tassertTrue( \"The testArray values should equal the controlArray values, index i: \" + i +\n+\t\t\t\t\" does not match\", testArray[i] == controlArray[i]);\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\tpublic void testSetElementArbitraryExpansion() {\n+\t\t\n+\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n+\t\t\n+\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n+\t\t\n+\t\teDA.addElement(2.0);\n+\t\teDA.addElement(4.0);\n+\t\teDA.addElement(6.0);\n+\t\teDA.setElement(1, 3.0);\n+\t\t\n+\t\t// Expand the array arbitrarily to 1000 items\n+\t\teDA.setElement(1000, 3.4);\n+\n+\t\tassertTrue( \"The length of the internal array should now be 1001, it isn't\", eDA.getInternalLength() == 1001);\n+\t\tassertTrue( \"The number of elements should now be 1001, it isn't\", eDA.getNumElements() == 1001);\n+\t\t\n+\t\tassertTrue( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", \n+\t\t\t\t\t\t\teDA.getElement( 760 ) == 0.0);\n+\t\t\n+\t\tassertTrue( \"The 1000th index should be 3.4, it isn't\", eDA.getElement(1000) == 3.4);\n+\t\tassertTrue( \"The 0th index should be 2.0, it isn't\", eDA.getElement(0) == 2.0);\t\t\n+\t\t\n+\t}\n+\n+\t/** TEST ERROR CONDITIONS **/\n+\n+\tpublic void testIllegalInitialCapacity() {\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(-3, 2.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the initialCapacity was negative, if it didn't then\" +\n+\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(0, 2.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the initialCapacity was ZERO if it didn't then\" +\n+\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t}\n+\t\n+\tpublic void testIllegalExpansionFactor() {\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.66f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for 0.66 which would shrink the array instead of expand the array\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for 0.0\");\n+\t\t} catch( IllegalArgumentException iae) {\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(3, -4.35f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for -4.35\");\n+\t\t} catch( IllegalArgumentException iae) {\n+\t\t}\n+\t}\n+\t\n+\tpublic void testGetOutOfBounds() {\n+\n+\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n+\t\teDA.addElement(2.0);\n+\t\teDA.addElement(3.0);\n+\t\t\n+\t\ttry {\n+\t\t\teDA.getElement(0);\n+\t\t\teDA.getElement(1);\n+\t\t} catch( NoSuchElementException nsee ) {\n+\t\t\tfail( \"There are values for index 0 and 1, this should not have thrown an exception\");\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\teDA.getElement(2);\n+\t\t\tfail( \"There are 2 elements in the array, you asked for index 2 implying that there are 3.  \" +\n+\t\t\t\t\"exception should have been thrown\");\n+\t\t} catch( NoSuchElementException nsee ) {\n+\t\t}\t\n+\t\t\n+\t\ttry {\n+\t\t\teDA.getElement(-234);\t\n+\t\t\tfail( \"You tried to retrieve a negative index, this should have thrown an exception. \" );\n+\t\t} catch( IllegalArgumentException iae) {\n+\t\t}\n+\t}\n+\n+\tpublic void testSetOutOfBounds() {\n+\n+\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray();\n+\t\t\n+\t\ttry {\n+\t\t\teDA.setElement( -3, 3.4 );\n+\t\t\tfail( \"You tried to set an element with a negative index, thisshould have thrown an error\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t}\n+\n+}", "timestamp": 1052975997, "metainfo": ""}