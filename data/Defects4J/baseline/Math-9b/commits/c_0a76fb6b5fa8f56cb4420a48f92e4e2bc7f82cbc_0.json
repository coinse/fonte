{"sha": "0a76fb6b5fa8f56cb4420a48f92e4e2bc7f82cbc", "log": "changed again the Adams-Bashforth and Adams-Moulton integrators they now both use Nordsieck representation this is the first really usable implementation, it still integrates only with fixed stepsize, but thanks to Nordsieck representation they will be improved to adaptive stepsize soon  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"too small integration interval: length = {0}\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n-    // org.apache.commons.math.ode.nonstiff.AdamsIntegrator\n+    // org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator\n+    // org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator\n     { \"{0} is supported only for orders 2 or more\",\n       \"la m\\u00e9thode {0} n''est disponible que pour les ordres 2 ou plus\" },\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements explicit Adams-Bashforth integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Bashforth methods (in fact due to Adams alone) are explicit\n+ * multistep ODE solvers with fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (3y'<sub>n</sub>-y'<sub>n-1</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (23y'<sub>n</sub>-16y'<sub>n-1</sub>+5y'<sub>n-2</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (55y'<sub>n</sub>-59y'<sub>n-1</sub>+37y'<sub>n-2</sub>-9y'<sub>n-3</sub>)/24</li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Bashforth method is of order k. There is no theoretical limit to the\n+ * value of k, but due to an implementation limitation k must be greater than 1.</p>\n+ *\n+ * <h3>Implementation details</h3>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>The definitions above use the classical representation with several previous first\n+ * derivatives. Lets define\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity). With these definitions,\n+ * Adams-Bashforth methods can be written:\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n)</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 3/2 s<sub>1</sub>(n) + [ -1/2 ] q<sub>n</sub></li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 23/12 s<sub>1</sub>(n) + [ -16/12 5/12 ] q<sub>n</sub></li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 55/24 s<sub>1</sub>(n) + [ -59/24 37/24 -9/24 ] q<sub>n</sub></li>\n+ *   <li>...</li>\n+ * </ul></p>\n+ *\n+ * <p>Instead of using the classical representation with first derivatives only (y<sub>n</sub>,\n+ * s<sub>1</sub>(n) and q<sub>n</sub>), our implementation uses the Nordsieck vector with\n+ * higher degrees scaled derivatives all taken at the same step (y<sub>n</sub>, s<sub>1</sub>(n)\n+ * and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity)\n+ * </p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation and Nordsieck vector. The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ * \n+ * <p>Using the Nordsieck vector has several advantages:\n+ * <ul>\n+ *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n+ *   Taylor series formulas,</li>\n+ *   <li>it simplifies step changes that occur when discrete events that truncate\n+ *   the step are triggered,</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize (not implemented yet).</li>\n+ * </ul></p>\n+ * \n+ * <p>The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre></p>\n+ *\n+ * <p>The P<sup>-1</sup>u vector and the P<sup>-1</sup> A P matrix do not depend on the state,\n+ * they only depend on k and therefore are precomputed once for all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsBashforthIntegrator extends MultistepIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 67792782787082199L;\n+\n+    /** Cache for already computed coefficients. */\n+    private static final Map<Integer, CachedCoefficients> cache =\n+        new HashMap<Integer, CachedCoefficients>();\n+\n+    /** Coefficients of the method. */\n+    private final transient CachedCoefficients coefficients;\n+\n+    /** Integration step. */\n+    private final double step;\n+\n+    /**\n+     * Build an Adams-Bashforth with the given order and step size.\n+     * @param order order of the method (must be greater than 1: due to\n+     * an implementation limitation the order 1 method is not supported)\n+     * @param step integration step size\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsBashforthIntegrator(final int order, final double step)\n+        throws IllegalArgumentException {\n+\n+        super(\"Adams-Bashforth\", order);\n+        if (order <= 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} is supported only for orders 2 or more\",\n+                  getName());\n+        }\n+\n+        // cache the coefficients for each order, to avoid recomputing them\n+        synchronized(cache) {\n+            CachedCoefficients coeff = cache.get(order);\n+            if (coeff == null) {\n+                coeff = new CachedCoefficients(order);\n+                cache.put(order, coeff);\n+            }\n+            coefficients = coeff;\n+        }\n+\n+        this.step = Math.abs(step);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final FirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] y0,\n+                            final double t, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        final int n = y0.length;\n+        sanityChecks(equations, t0, y0, t, y);\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, n);\n+        }\n+\n+        // set up an interpolator sharing the integrator arrays\n+        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n+        interpolator.reinitialize(y, forward);\n+\n+        // set up integration control objects\n+        stepStart = t0;\n+        stepSize  = forward ? step : -step;\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the first few steps using the configured starter integrator\n+        double stopTime =\n+            start(previousF.length, stepSize, manager, equations, stepStart, y);\n+        if (Double.isNaN(previousT[0])) {\n+            return stopTime;\n+        }\n+        stepStart = previousT[0];\n+\n+        // convert to Nordsieck representation\n+        double[]   scaled    = convertToNordsieckLow();\n+        RealMatrix nordsieck = convertToNordsieckHigh(scaled);\n+        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+        interpolator.storeTime(stepStart);\n+\n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            // discrete events handling\n+            interpolator.storeTime(stepStart + stepSize);\n+            if (manager.evaluateStep(interpolator)) {\n+                stepSize = manager.getEventTime() - stepStart;\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = stepStart + stepSize;\n+            interpolator.storeTime(nextStep);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, n);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // update the Nordsieck vector\n+            final double[] f0 = previousF[0];\n+            previousT[0] = nextStep;\n+            equations.computeDerivatives(nextStep, y, f0);\n+            nordsieck = coefficients.msUpdate.multiply(nordsieck);\n+            final double[] end = new double[y0.length];\n+            for (int j = 0; j < y0.length; ++j) {\n+                end[j] = stepSize * f0[j];\n+            }\n+            nordsieck.walkInOptimizedOrder(new NordsieckUpdater(scaled, end, coefficients.c1));\n+            scaled = end;\n+            interpolator.reinitialize(nextStep, stepSize, scaled, nordsieck);\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep && manager.reset(stepStart, y)) {\n+\n+                // some events handler has triggered changes that\n+                // invalidate the derivatives, we need to restart from scratch\n+                stopTime =\n+                    start(previousF.length, stepSize, manager, equations, stepStart, y);\n+                if (Double.isNaN(previousT[0])) {\n+                    return stopTime;\n+                }\n+                stepStart = previousT[0];\n+\n+                // convert to Nordsieck representation\n+                scaled    = convertToNordsieckLow();\n+                nordsieck = convertToNordsieckHigh(scaled);\n+                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+\n+            }\n+\n+        }\n+\n+        stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Convert the multistep representation after a restart to Nordsieck representation.\n+     * @return first scaled derivative\n+     */\n+    private double[] convertToNordsieckLow() {\n+\n+        final double[] f0 = previousF[0];\n+        final double[] scaled = new double[f0.length];\n+        for (int j = 0; j < f0.length; ++j) {\n+            scaled[j] = stepSize * f0[j];\n+        }\n+        return scaled;\n+\n+    }\n+\n+    /** Convert the multistep representation after a restart to Nordsieck representation.\n+     * @param scaled first scaled derivative\n+     * @return Nordsieck matrix of the higher scaled derivatives\n+     */\n+    private RealMatrix convertToNordsieckHigh(final double[] scaled) {\n+\n+        final double[] f0 = previousF[0];\n+        final double[][] multistep = new double[coefficients.msToN.getColumnDimension()][f0.length];\n+        for (int i = 0; i < multistep.length; ++i) {\n+            final double[] msI = multistep[i];\n+            final double[] fI  = previousF[i + 1];\n+            for (int j = 0; j < f0.length; ++j) {\n+                msI[j] = stepSize * fI[j] - scaled[j];\n+            }\n+        }\n+\n+        return coefficients.msToN.multiply(new RealMatrixImpl(multistep, false));\n+\n+    }\n+\n+    /** Updater for Nordsieck vector. */\n+    private static class NordsieckUpdater extends DefaultRealMatrixChangingVisitor {\n+\n+        /** Scaled first derivative at step start. */\n+        private final double[] start;\n+\n+        /** Scaled first derivative at step end. */\n+        private final double[] end;\n+\n+        /** Update coefficients. */\n+        private final double[] c1;\n+\n+        /** Simple constructor.\n+         * @param start scaled first derivative at step start\n+         * @param end scaled first derivative at step end\n+         * @param c1 update coefficients\n+         */\n+        public NordsieckUpdater(final double[] start, final double[] end,\n+                                final double[] c1) {\n+            this.start = start;\n+            this.end   = end;\n+            this.c1    = c1;\n+        }\n+\n+       /** {@inheritDoc} */\n+        @Override\n+        public double visit(int row, int column, double value)\n+            throws MatrixVisitorException {\n+            return value + c1[row] * (start[column] - end[column]);\n+        }\n+\n+    }\n+\n+    /** Cache for already computed coefficients. */\n+    private static class CachedCoefficients {\n+\n+        /** Transformer between multistep and Nordsieck representations. */\n+        private final RealMatrix msToN;\n+\n+        /** Update coefficients of the higher order derivatives wrt y'', y''' ... */\n+        private final RealMatrix msUpdate;\n+\n+        /** Update coefficients of the higher order derivatives wrt y'. */\n+        private final double[] c1;\n+\n+        /** Simple constructor.\n+         * @param order order of the method (must be greater than 1: due to\n+         * an implementation limitation the order 1 method is not supported)\n+         */\n+        public CachedCoefficients(int order) {\n+\n+            // compute exact coefficients\n+            FieldMatrix<BigFraction> bigNtoMS = buildP(order);\n+            FieldMatrix<BigFraction> bigMStoN =\n+                new FieldLUDecompositionImpl<BigFraction>(bigNtoMS).getSolver().getInverse();\n+            BigFraction[] u = new BigFraction[order - 1];\n+            Arrays.fill(u, BigFraction.ONE);\n+            BigFraction[] bigC1 = bigMStoN.operate(u);\n+\n+            // update coefficients are computed by combining transform from\n+            // Nordsieck to multistep, then shifting rows to represent step advance\n+            // then applying inverse transform\n+            BigFraction[][] shiftedP = bigNtoMS.getData();\n+            for (int i = shiftedP.length - 1; i > 0; --i) {\n+                // shift rows\n+                shiftedP[i] = shiftedP[i - 1];\n+            }\n+            shiftedP[0] = new BigFraction[order - 1];\n+            Arrays.fill(shiftedP[0], BigFraction.ZERO);\n+            FieldMatrix<BigFraction> bigMSupdate =\n+                bigMStoN.multiply(new FieldMatrixImpl<BigFraction>(shiftedP, false));\n+\n+            // convert coefficients to double\n+            msToN    = MatrixUtils.bigFractionMatrixToRealMatrix(bigMStoN);\n+            msUpdate = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n+            c1       = new double[order - 1];\n+            for (int i = 0; i < order - 1; ++i) {\n+                c1[i] = bigC1[i].doubleValue();\n+            }\n+\n+        }\n+\n+        /** Build the P matrix transforming multistep to Nordsieck.\n+         * <p>\n+         * <p>\n+         * Multistep representation uses y(k), s<sub>1</sub>(k), s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)).\n+         * Nordsieck representation uses y(k), s<sub>1</sub>(k), s<sub>2</sub>(k) ... s<sub>n</sub>(k).\n+         * The two representations share their two first components y(k) and\n+         * s<sub>1</sub>(k). The P matrix is used to transform the remaining ones:\n+         * <pre>\n+         * [ s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)]<sup>T</sup> = s<sub>1</sub>(k) [1 ... 1]<sup>T</sup> + P [s<sub>2</sub>(k) ... s<sub>n</sub>(k)]<sup>T</sup>\n+         * </pre>\n+         * </p>\n+         * @param order order of the method (must be strictly positive)\n+         * @return P matrix\n+         */\n+        private static FieldMatrix<BigFraction> buildP(final int order) {\n+\n+            final BigFraction[][] pData = new BigFraction[order - 1][order - 1];\n+\n+            for (int i = 0; i < pData.length; ++i) {\n+                // build the P matrix elements from Taylor series formulas\n+                final BigFraction[] pI = pData[i];\n+                final int factor = -(i + 1);\n+                int aj = factor;\n+                for (int j = 0; j < pI.length; ++j) {\n+                    pI[j] = new BigFraction(aj * (j + 2));\n+                    aj *= factor;\n+                }\n+            }\n+\n+            return new FieldMatrixImpl<BigFraction>(pData, false);\n+\n+        }\n+\n+    }\n+\n+    /** Serialize the instance.\n+     * @param oos stream where object should be written\n+     * @throws IOException if object cannot be written to stream\n+     */\n+    private void writeObject(ObjectOutputStream oos)\n+        throws IOException {\n+        oos.defaultWriteObject();\n+        oos.writeInt(coefficients.msToN.getRowDimension() + 1);\n+    }\n+\n+    /** Deserialize the instance.\n+     * @param ois stream from which the object should be read\n+     * @throws ClassNotFoundException if a class in the stream cannot be found\n+     * @throws IOException if object cannot be read from the stream\n+     */\n+    private void readObject(ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            ois.defaultReadObject();\n+            final int order = ois.readInt();\n+\n+            final Class<AdamsBashforthIntegrator> cl = AdamsBashforthIntegrator.class;\n+            final Field f = cl.getDeclaredField(\"coefficients\");\n+            f.setAccessible(true);\n+\n+            // cache the coefficients for each order, to avoid recomputing them\n+            synchronized(cache) {\n+                CachedCoefficients coeff = cache.get(order);\n+                if (coeff == null) {\n+                    coeff = new CachedCoefficients(order);\n+                    cache.put(order, coeff);\n+                }\n+                f.set(this, coeff);\n+            }\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(nsfe);\n+            throw ioe;\n+        } catch (IllegalAccessException iae) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(iae);\n+            throw ioe;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n+import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.FieldMatrixImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements implicit Adams-Moulton integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Moulton methods (in fact due to Adams alone) are implicit\n+ * multistep ODE solvers with fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n+1, n, n-1 ... Since y'<sub>n+1</sub> is needed to\n+ * compute y<sub>n+1</sub>, another method must be used to compute a first\n+ * estimate of y<sub>n+1</sub>, then compute y'<sub>n+1</sub>, then compute\n+ * a final estimate of y<sub>n+1</sub> using the following formulas. Depending\n+ * on the number k of previous steps one wants to use for computing the next\n+ * value, different formulas are available for the final estimate:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n+1</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (y'<sub>n+1</sub>+y'<sub>n</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (5y'<sub>n+1</sub>+8y'<sub>n</sub>-y'<sub>n-1</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (9y'<sub>n+1</sub>+19y'<sub>n</sub>-5y'<sub>n-1</sub>+y'<sub>n-2</sub>)/24</li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Moulton method is of order k+1. There is no theoretical limit to the\n+ * value of k, but due to an implementation limitation k must be greater than 1.</p>\n+ *\n+ * <h3>Implementation details</h3>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>The definitions above use the classical representation with several previous first\n+ * derivatives. Lets define\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity). With these definitions,\n+ * Adams-Moulton methods can be written:\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n+1)</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 1/2 s<sub>1</sub>(n+1) + [ 1/2 ] q<sub>n+1</sub></li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 5/12 s<sub>1</sub>(n+1) + [ 8/12 -1/12 ] q<sub>n+1</sub></li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 9/24 s<sub>1</sub>(n+1) + [ 19/24 -5/24 1/24 ] q<sub>n+1</sub></li>\n+ *   <li>...</li>\n+ * </ul></p>\n+ *\n+ * <p>Instead of using the classical representation with first derivatives only (y<sub>n</sub>,\n+ * s<sub>1</sub>(n+1) and q<sub>n+1</sub>), our implementation uses the Nordsieck vector with\n+ * higher degrees scaled derivatives all taken at the same step (y<sub>n</sub>, s<sub>1</sub>(n)\n+ * and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity)\n+ * </p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation and Nordsieck vector. The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ * \n+ * <p>Using the Nordsieck vector has several advantages:\n+ * <ul>\n+ *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n+ *   Taylor series formulas,</li>\n+ *   <li>it simplifies step changes that occur when discrete events that truncate\n+ *   the step are triggered,</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize (not implemented yet).</li>\n+ * </ul></p>\n+ * \n+ * <p>The predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step\n+ * n as follows:\n+ * <ul>\n+ *   <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>\n+ *   <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre>\n+ * From this predicted vector, the corrected vector is computed as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + S<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = R<sub>n+1</sub> + (s<sub>1</sub>(n+1) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u</li>\n+ * </ul>\n+ * where the upper case Y<sub>n+1</sub>, S<sub>1</sub>(n+1) and R<sub>n+1</sub> represent the\n+ * predicted states whereas the lower case y<sub>n+1</sub>, s<sub>n+1</sub> and r<sub>n+1</sub>\n+ * represent the corrected states.</p>\n+ *\n+ * <p>The P<sup>-1</sup>u vector and the P<sup>-1</sup> A P matrix do not depend on the state,\n+ * they only depend on k and therefore are precomputed once for all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsMoultonIntegrator extends MultistepIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -2740961714898447598L;\n+\n+    /** Cache for already computed coefficients. */\n+    private static final Map<Integer, CachedCoefficients> cache =\n+        new HashMap<Integer, CachedCoefficients>();\n+\n+    /** Coefficients of the method. */\n+    private final transient CachedCoefficients coefficients;\n+\n+    /** Integration step. */\n+    private final double step;\n+\n+    /**\n+     * Build an Adams-Moulton integrator with the given order and step size.\n+     * @param order order of the method (must be greater than 1: due to\n+     * an implementation limitation the order 1 method is not supported)\n+     * @param step integration step size\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsMoultonIntegrator(final int order, final double step)\n+        throws IllegalArgumentException {\n+\n+        super(\"Adams-Moulton\", order);\n+        if (order <= 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} is supported only for orders 2 or more\",\n+                  getName());\n+        }\n+\n+        // cache the coefficients for each order, to avoid recomputing them\n+        synchronized(cache) {\n+            CachedCoefficients coeff = cache.get(order);\n+            if (coeff == null) {\n+                coeff = new CachedCoefficients(order);\n+                cache.put(order, coeff);\n+            }\n+            coefficients = coeff;\n+        }\n+\n+        this.step = Math.abs(step);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final FirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] y0,\n+                            final double t, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        final int n = y0.length;\n+        sanityChecks(equations, t0, y0, t, y);\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, n);\n+        }\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up two interpolators sharing the integrator arrays\n+        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n+        interpolator.reinitialize(y, forward);\n+        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n+        interpolatorTmp.reinitialize(yTmp, forward);\n+\n+        // set up integration control objects\n+        stepStart = t0;\n+        stepSize  = forward ? step : -step;\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the first few steps using the configured starter integrator\n+        double stopTime =\n+            start(previousF.length, stepSize, manager, equations, stepStart, y);\n+        if (Double.isNaN(previousT[0])) {\n+            return stopTime;\n+        }\n+        stepStart = previousT[0];\n+        double hNew = 0;\n+\n+        // convert to Nordsieck representation\n+        double[]   scaled    = convertToNordsieckLow();\n+        RealMatrix nordsieck = convertToNordsieckHigh(scaled);\n+        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+        interpolator.storeTime(stepStart);\n+\n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            hNew  = forward ? step : -step;\n+            for (boolean loop = true; loop;) {\n+\n+                stepSize = hNew;\n+\n+                // predict a first estimate of the state at step end (P in the PECE sequence)\n+                final double stepEnd = stepStart + stepSize;\n+                interpolator.setInterpolatedTime(stepEnd);\n+                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n+\n+                // evaluate a first estimate of the derivative (first E in the PECE sequence)\n+                final double[] f0 = previousF[0];\n+                previousT[0] = stepEnd;\n+                equations.computeDerivatives(stepEnd, yTmp, f0);\n+\n+                // update Nordsieck vector\n+                final RealMatrix nordsieckTmp = coefficients.msUpdate.multiply(nordsieck);\n+                final double[] predictedScaled = new double[y0.length];\n+                for (int j = 0; j < y0.length; ++j) {\n+                    predictedScaled[j] = stepSize * f0[j];\n+                }\n+                nordsieckTmp.walkInOptimizedOrder(new NordsieckUpdater(scaled, predictedScaled, coefficients.c1));\n+\n+                // apply correction (C in the PECE sequence)\n+                nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n+\n+                // evaluate a final estimate of the derivative (second E in the PECE sequence)\n+                equations.computeDerivatives(stepEnd, yTmp, f0);\n+\n+                // update Nordsieck vector\n+                final double[] correctedScaled = new double[y0.length];\n+                for (int j = 0; j < y0.length; ++j) {\n+                    correctedScaled[j] = stepSize * f0[j];\n+                }\n+                nordsieckTmp.walkInOptimizedOrder(new NordsieckUpdater(predictedScaled, correctedScaled, coefficients.c1));\n+\n+                // discrete events handling\n+                interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n+                interpolatorTmp.storeTime(stepStart);\n+                interpolatorTmp.shift();\n+                interpolatorTmp.storeTime(stepEnd);\n+                if (manager.evaluateStep(interpolatorTmp)) {\n+                    // reject the step to match exactly the next switch time\n+                    hNew = manager.getEventTime() - stepStart;\n+                } else {\n+                    // accept the step\n+                    scaled    = correctedScaled;\n+                    nordsieck = nordsieckTmp;\n+                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n+                    loop = false;\n+                }\n+\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = stepStart + stepSize;\n+            System.arraycopy(yTmp, 0, y, 0, n);\n+            interpolator.storeTime(nextStep);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            interpolator.setInterpolatedTime(nextStep);\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep && manager.reset(stepStart, y)) {\n+\n+                // some events handler has triggered changes that\n+                // invalidate the derivatives, we need to restart from scratch\n+                stopTime =\n+                    start(previousF.length, stepSize, manager, equations, stepStart, y);\n+                if (Double.isNaN(previousT[0])) {\n+                    return stopTime;\n+                }\n+                stepStart = previousT[0];\n+\n+                // convert to Nordsieck representation\n+                scaled    = convertToNordsieckLow();\n+                nordsieck = convertToNordsieckHigh(scaled);\n+                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+                interpolator.storeTime(stepStart);\n+\n+            }\n+\n+        }\n+\n+        stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Convert the multistep representation after a restart to Nordsieck representation.\n+     * @return first scaled derivative\n+     */\n+    private double[] convertToNordsieckLow() {\n+\n+        final double[] f0 = previousF[0];\n+        final double[] scaled = new double[f0.length];\n+        for (int j = 0; j < f0.length; ++j) {\n+            scaled[j] = stepSize * f0[j];\n+        }\n+        return scaled;\n+\n+    }\n+\n+    /** Convert the multistep representation after a restart to Nordsieck representation.\n+     * @param scaled first scaled derivative\n+     * @return Nordsieck matrix of the higher scaled derivatives\n+     */\n+    private RealMatrix convertToNordsieckHigh(final double[] scaled) {\n+\n+        final double[] f0 = previousF[0];\n+        final double[][] multistep = new double[coefficients.msToN.getColumnDimension()][f0.length];\n+        for (int i = 0; i < multistep.length; ++i) {\n+            final double[] msI = multistep[i];\n+            final double[] fI  = previousF[i + 1];\n+            for (int j = 0; j < f0.length; ++j) {\n+                msI[j] = stepSize * fI[j] - scaled[j];\n+            }\n+        }\n+\n+        return coefficients.msToN.multiply(new RealMatrixImpl(multistep, false));\n+\n+    }\n+\n+    /** Corrector for current state in Adams-Moulton method.\n+     * <p>\n+     * This visitor implements the Taylor series formula:\n+     * <pre>\n+     * Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub>\n+     * </pre>\n+     * </p>\n+     */\n+    private static class Corrector implements RealMatrixPreservingVisitor {\n+\n+        /** Previous state. */\n+        private final double[] previous;\n+\n+        /** Current scaled first derivative. */\n+        private final double[] scaled;\n+\n+        /** Placeholder where to put the recomputed current state. */\n+        private final double[] corrected;\n+\n+        /** Simple constructor.\n+         * @param previous previous state\n+         * @param scaled current scaled first derivative\n+         * @param corrected placeholder where to put the corrected current state\n+         */\n+        public Corrector(final double[] previous, final double[] scaled, final double[] corrected) {\n+            this.previous = previous;\n+            this.scaled    = scaled;\n+            this.corrected  = corrected;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void start(int rows, int columns,\n+                          int startRow, int endRow, int startColumn, int endColumn) {\n+            Arrays.fill(corrected, 0.0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visit(int row, int column, double value)\n+            throws MatrixVisitorException {\n+            if ((row & 0x1) == 0) {\n+                corrected[column] -= value;\n+            } else {\n+                corrected[column] += value;\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double end() {\n+            for (int i = 0; i < corrected.length; ++i) {\n+                corrected[i] += previous[i] + scaled[i];\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /** Updater for Nordsieck vector. */\n+    private static class NordsieckUpdater extends DefaultRealMatrixChangingVisitor {\n+\n+        /** Scaled first derivative at step start. */\n+        private final double[] start;\n+\n+        /** Scaled first derivative at step end. */\n+        private final double[] end;\n+\n+        /** Update coefficients. */\n+        private final double[] c1;\n+\n+        /** Simple constructor.\n+         * @param start scaled first derivative at step start\n+         * @param end scaled first derivative at step end\n+         * @param c1 update coefficients\n+         */\n+        public NordsieckUpdater(final double[] start, final double[] end,\n+                                final double[] c1) {\n+            this.start = start;\n+            this.end   = end;\n+            this.c1    = c1;\n+        }\n+\n+       /** {@inheritDoc} */\n+        @Override\n+        public double visit(int row, int column, double value)\n+            throws MatrixVisitorException {\n+            return value + c1[row] * (start[column] - end[column]);\n+        }\n+\n+    }\n+\n+    /** Cache for already computed coefficients. */\n+    private static class CachedCoefficients {\n+\n+        /** Transformer between multistep and Nordsieck representations. */\n+        private final RealMatrix msToN;\n+\n+        /** Update coefficients of the higher order derivatives wrt y'', y''' ... */\n+        private final RealMatrix msUpdate;\n+\n+        /** Update coefficients of the higher order derivatives wrt y'. */\n+        private final double[] c1;\n+\n+        /** Simple constructor.\n+         * @param order order of the method (must be greater than 1: due to\n+         * an implementation limitation the order 1 method is not supported)\n+         */\n+        public CachedCoefficients(int order) {\n+\n+            // compute exact coefficients\n+            FieldMatrix<BigFraction> bigNtoMS = buildP(order);\n+            FieldMatrix<BigFraction> bigMStoN =\n+                new FieldLUDecompositionImpl<BigFraction>(bigNtoMS).getSolver().getInverse();\n+            BigFraction[] u = new BigFraction[order - 1];\n+            Arrays.fill(u, BigFraction.ONE);\n+            BigFraction[] bigC1 = bigMStoN.operate(u);\n+\n+            // update coefficients are computed by combining transform from\n+            // Nordsieck to multistep, then shifting rows to represent step advance\n+            // then applying inverse transform\n+            BigFraction[][] shiftedP = bigNtoMS.getData();\n+            for (int i = shiftedP.length - 1; i > 0; --i) {\n+                // shift rows\n+                shiftedP[i] = shiftedP[i - 1];\n+            }\n+            shiftedP[0] = new BigFraction[order - 1];\n+            Arrays.fill(shiftedP[0], BigFraction.ZERO);\n+            FieldMatrix<BigFraction> bigMSupdate =\n+                bigMStoN.multiply(new FieldMatrixImpl<BigFraction>(shiftedP, false));\n+\n+            // convert coefficients to double\n+            msToN    = MatrixUtils.bigFractionMatrixToRealMatrix(bigMStoN);\n+            msUpdate = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n+            c1       = new double[order - 1];\n+            for (int i = 0; i < order - 1; ++i) {\n+                c1[i] = bigC1[i].doubleValue();\n+            }\n+\n+        }\n+\n+        /** Build the P matrix transforming multistep to Nordsieck.\n+         * <p>\n+         * <p>\n+         * Multistep representation uses y(k), s<sub>1</sub>(k), s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)).\n+         * Nordsieck representation uses y(k), s<sub>1</sub>(k), s<sub>2</sub>(k) ... s<sub>n</sub>(k).\n+         * The two representations share their two first components y(k) and\n+         * s<sub>1</sub>(k). The P matrix is used to transform the remaining ones:\n+         * <pre>\n+         * [ s<sub>1</sub>(k-1) ... s<sub>1</sub>(k-(n-1)]<sup>T</sup> = s<sub>1</sub>(k) [1 ... 1]<sup>T</sup> + P [s<sub>2</sub>(k) ... s<sub>n</sub>(k)]<sup>T</sup>\n+         * </pre>\n+         * </p>\n+         * @param order order of the method (must be strictly positive)\n+         * @return P matrix\n+         */\n+        private static FieldMatrix<BigFraction> buildP(final int order) {\n+\n+            final BigFraction[][] pData = new BigFraction[order - 1][order - 1];\n+\n+            for (int i = 0; i < pData.length; ++i) {\n+                // build the P matrix elements from Taylor series formulas\n+                final BigFraction[] pI = pData[i];\n+                final int factor = -(i + 1);\n+                int aj = factor;\n+                for (int j = 0; j < pI.length; ++j) {\n+                    pI[j] = new BigFraction(aj * (j + 2));\n+                    aj *= factor;\n+                }\n+            }\n+\n+            return new FieldMatrixImpl<BigFraction>(pData, false);\n+\n+        }\n+\n+    }\n+\n+    /** Serialize the instance.\n+     * @param oos stream where object should be written\n+     * @throws IOException if object cannot be written to stream\n+     */\n+    private void writeObject(ObjectOutputStream oos)\n+        throws IOException {\n+        oos.defaultWriteObject();\n+        oos.writeInt(coefficients.msToN.getRowDimension() + 1);\n+    }\n+\n+    /** Deserialize the instance.\n+     * @param ois stream from which the object should be read\n+     * @throws ClassNotFoundException if a class in the stream cannot be found\n+     * @throws IOException if object cannot be read from the stream\n+     */\n+    private void readObject(ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            ois.defaultReadObject();\n+            final int order = ois.readInt();\n+\n+            final Class<AdamsMoultonIntegrator> cl = AdamsMoultonIntegrator.class;\n+            final Field f = cl.getDeclaredField(\"coefficients\");\n+            f.setAccessible(true);\n+\n+            // cache the coefficients for each order, to avoid recomputing them\n+            synchronized(cache) {\n+                CachedCoefficients coeff = cache.get(order);\n+                if (coeff == null) {\n+                    coeff = new CachedCoefficients(order);\n+                    cache.put(order, coeff);\n+                }\n+                f.set(this, coeff);\n+            }\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(nsfe);\n+            throw ioe;\n+        } catch (IllegalAccessException iae) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(iae);\n+            throw ioe;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.junit.Test;\n+\n+public class AdamsBashforthIntegratorTest {\n+\n+    @Test(expected=IntegratorException.class)\n+    public void dimensionCheck() throws DerivativeException, IntegratorException {\n+        TestProblem1 pb = new TestProblem1();\n+        new AdamsBashforthIntegrator(3, 0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()+10],\n+                                                        1.0, new double[pb.getDimension()+10]);\n+    }\n+\n+    @Test\n+    public void decreasingSteps() throws DerivativeException, IntegratorException {\n+\n+        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+        for (int k = 0; k < problems.length; ++k) {\n+\n+            double previousError = Double.NaN;\n+            for (int i = 6; i < 10; ++i) {\n+\n+                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+                FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);\n+                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+                integ.addStepHandler(handler);\n+                EventHandler[] functions = pb.getEventsHandlers();\n+                for (int l = 0; l < functions.length; ++l) {\n+                    integ.addEventHandler(functions[l],\n+                                          Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);\n+                }\n+                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                                  pb.getFinalTime(), new double[pb.getDimension()]);\n+                if (functions.length == 0) {\n+                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+                }\n+\n+                double error = handler.getMaximalValueError();\n+                if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {\n+                    assertTrue(error <= Math.abs(1.05 * previousError));\n+                }\n+                previousError = error;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n+    public void smallStep() throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double range = pb.getFinalTime() - pb.getInitialTime();\n+        double step = range * 0.001;\n+\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(3, step);\n+        integ.setStarterIntegrator(new DormandPrince853Integrator(0, range, 1.0e-12, 1.0e-12));\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 2.0e-9);\n+        assertTrue(handler.getMaximalValueError() < 9.0e-9);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+        assertEquals(\"Adams-Bashforth\", integ.getName());\n+\n+    }\n+\n+    @Test\n+    public void bigStep() throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() > 0.06);\n+        assertTrue(handler.getMaximalValueError() > 0.06);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+\n+    }\n+\n+    @Test\n+    public void backward() throws DerivativeException, IntegratorException {\n+\n+        TestProblem5 pb = new TestProblem5();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 8.0e-11);\n+        assertTrue(handler.getMaximalValueError() < 8.0e-11);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n+        assertEquals(\"Adams-Bashforth\", integ.getName());\n+    }\n+\n+    @Test\n+    public void polynomial() throws DerivativeException, IntegratorException {\n+        TestProblem6 pb = new TestProblem6();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;\n+\n+        for (int order = 2; order < 9; ++order) {\n+            AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(order, step);\n+            integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,\n+                                                                      1.0e-5, 1.0e-5));\n+            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+            if (order < 5) {\n+                assertTrue(handler.getMaximalValueError() > 1.0e-5);\n+            } else {\n+                assertTrue(handler.getMaximalValueError() < 7.0e-12);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void serialization()\n+        throws IntegratorException, DerivativeException,\n+               IOException, ClassNotFoundException {\n+\n+        TestProblem6 pb = new TestProblem6();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.01;\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+        oos.writeObject(new AdamsBashforthIntegrator(8, step));\n+        assertTrue(bos.size() > 2800);\n+        assertTrue(bos.size() < 2900);\n+\n+        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+        ObjectInputStream     ois = new ObjectInputStream(bis);\n+        FirstOrderIntegrator integ  = (AdamsBashforthIntegrator) ois.readObject();\n+        assertEquals(\"Adams-Bashforth\", integ.getName());\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        assertTrue(handler.getMaximalValueError() < 7.0e-13);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.junit.Test;\n+\n+public class AdamsMoultonIntegratorTest {\n+\n+    @Test(expected=IntegratorException.class)\n+    public void dimensionCheck()\n+        throws DerivativeException, IntegratorException {\n+        TestProblem1 pb = new TestProblem1();\n+        new AdamsMoultonIntegrator(3, 0.01).integrate(pb,\n+                                                      0.0, new double[pb.getDimension()+10],\n+                                                      1.0, new double[pb.getDimension()+10]);\n+    }\n+\n+    @Test\n+    public void decreasingSteps()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+        for (int k = 0; k < problems.length; ++k) {\n+\n+            double previousError = Double.NaN;\n+            for (int i = 6; i < 10; ++i) {\n+\n+                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+                FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);\n+                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+                integ.addStepHandler(handler);\n+                EventHandler[] functions = pb.getEventsHandlers();\n+                for (int l = 0; l < functions.length; ++l) {\n+                    integ.addEventHandler(functions[l],\n+                                          Double.POSITIVE_INFINITY, 1.0e-3 * step, 1000);\n+                }\n+                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                                  pb.getFinalTime(), new double[pb.getDimension()]);\n+                if (functions.length == 0) {\n+                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+                }\n+\n+                double error = handler.getMaximalValueError();\n+                if ((i > 6) && !(pb instanceof TestProblem4) && !(pb instanceof TestProblem6)) {\n+                    assertTrue(error <= Math.abs(1.05 * previousError));\n+                }\n+                previousError = error;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n+    public void smallStep()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double range = pb.getFinalTime() - pb.getInitialTime();\n+        double step = range * 0.001;\n+\n+        AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(3, step);\n+        integ.setStarterIntegrator(new DormandPrince853Integrator(0, range, 1.0e-12, 1.0e-12));\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 2.0e-10);\n+        assertTrue(handler.getMaximalValueError() < 1.0e-9);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+\n+    }\n+\n+    @Test\n+    public void bigStep()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getMaximalValueError() > 6.0e-6);\n+\n+    }\n+\n+    @Test\n+    public void backward()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem5 pb = new TestProblem5();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 4.0e-12);\n+        assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-15);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+    }\n+\n+    @Test\n+    public void polynomial()\n+        throws DerivativeException, IntegratorException {\n+        final TestProblem6 pb = new TestProblem6();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.02;\n+\n+        for (int order = 2; order < 9; ++order) {\n+            AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(order, step);\n+            integ.setStarterIntegrator(new DormandPrince853Integrator(1.0e-3 * step, 1.0e3 * step,\n+                                                                      1.0e-5, 1.0e-5));\n+            final TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+            integ.addStepHandler(handler);\n+            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                            pb.getFinalTime(), new double[pb.getDimension()]);\n+            if (order < 5) {\n+                assertTrue(handler.getMaximalValueError() > 1.0e-6);\n+            } else {\n+                assertTrue(handler.getMaximalValueError() < 4.0e-13);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void serialization()\n+        throws IntegratorException, DerivativeException,\n+               IOException, ClassNotFoundException {\n+\n+        TestProblem6 pb = new TestProblem6();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.01;\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+        oos.writeObject(new AdamsMoultonIntegrator(8, step));\n+        assertTrue(bos.size() > 2800);\n+        assertTrue(bos.size() < 2900);\n+\n+        ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+        ObjectInputStream     ois = new ObjectInputStream(bis);\n+        FirstOrderIntegrator integ  = (AdamsMoultonIntegrator) ois.readObject();\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        assertTrue(handler.getMaximalValueError() < 2.0e-13);\n+\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/sampling/NordsieckStepInterpolatorTest.java\n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.nonstiff.AdamsIntegrator;\n+import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;\n import org.apache.commons.math.ode.nonstiff.TestProblem1;\n import org.apache.commons.math.ode.nonstiff.TestProblem3;\n import org.junit.Test;\n     throws DerivativeException, IntegratorException {\n         TestProblem3 pb = new TestProblem3();\n         double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n-        AdamsIntegrator integ = new AdamsIntegrator(5, false, step);\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, step);\n         StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10);\n     }\n \n \n         TestProblem1 pb = new TestProblem1();\n         double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n-        AdamsIntegrator integ = new AdamsIntegrator(5, false, step);\n+        AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(5, step);\n         integ.addStepHandler(new ContinuousOutputModel());\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),", "timestamp": 1244402375, "metainfo": ""}