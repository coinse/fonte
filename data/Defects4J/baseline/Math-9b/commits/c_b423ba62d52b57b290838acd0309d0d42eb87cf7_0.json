{"sha": "b423ba62d52b57b290838acd0309d0d42eb87cf7", "log": "Clarified the javadoc of distribution.FastCosineTransformer (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n import org.apache.commons.math.util.FastMath;\n \n /**\n- * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n- * StandardPackages/LinearAlgebra/FourierTrig.html\">Fast Cosine Transform</a>\n- * for transformation of one-dimensional data sets. For reference, see\n- * <b>Fast Fourier Transforms</b>, ISBN 0849371635, chapter 3.\n- * <p>\n- * FCT is its own inverse, up to a multiplier depending on conventions.\n- * The equations are listed in the comments of the corresponding methods.</p>\n- * <p>\n- * Different from FFT and FST, FCT requires the length of data set to be\n- * power of 2 plus one. Users should especially pay attention to the\n- * function transformation on how this affects the sampling.</p>\n+ * <p>\n+ * Implements the Fast Cosine Transform for transformation of one-dimensional\n+ * real data sets. For reference, see James S. Walker, <em>Fast Fourier\n+ * Transforms</em>, chapter 3 (ISBN 0849371635).\n+ * <p>\n+ * <p>\n+ * There are several variants of the discrete cosine transform. The present\n+ * implementation corresponds to DCT-I, with various normalization conventions,\n+ * which are specified in the comments of the factory methods {@link #create()}\n+ * and {@link #createOrthogonal()}.\n+ * </p>\n+ * <p>\n+ * DCT-I is equivalent to DFT of an <em>even extension</em> of the data series.\n+ * More precisely, if x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is the data set\n+ * to be cosine transformed, the extended data set\n+ * x<sub>0</sub><sup>&#35;</sup>, &hellip;, x<sub>2N-2</sub><sup>&#35;</sup>\n+ * is defined as follows\n+ * <ul>\n+ * <li>x<sub>k</sub><sup>&#35;</sup> = x<sub>k</sub> if  0 &le; k &lt; N,</li>\n+ * <li>x<sub>k</sub><sup>&#35;</sup> = x<sub>2N-2-k</sub>\n+ * if  N &le; k &lt; 2N - 2.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Then, the \"standard\" DCT-I (as returned by {@link #create()}) of the real\n+ * data set x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is equal to\n+ * <em>half</em> of the N first elements of the DFT of the extended data set\n+ * x<sub>0</sub><sup>&#35;</sup>, &hellip;, x<sub>2N-2</sub><sup>&#35;</sup>.\n+ * </p>\n+ * <p>\n+ * The present implementation of the fast cosine transform requires the length\n+ * of the data set to be a power of two plus one\n+ * (N&nbsp;=&nbsp;2<sup>n</sup>&nbsp;+&nbsp;1). Besides, it implicitly assumes\n+ * that the sampled function is even.\n+ * </p>\n  * <p>As of version 2.0 this no longer implements Serializable</p>\n  *\n  * @version $Id$\n     /**\n      * <p>\n      * Returns a new instance of this class. The returned transformer uses the\n-     * normalizing conventions described below.\n+     * \"standard\" normalizing conventions\n      * <ul>\n      * <li>Forward transform:\n      * y<sub>n</sub> = (1/2) [x<sub>0</sub> + (-1)<sup>n</sup>x<sub>N-1</sub>]\n     /**\n      * <p>\n      * Returns a new instance of this class. The returned transformer uses the\n-     * normalizing conventions described below.\n+     * \"orthogonal\" normalizing conventions\n      * <ul>\n      * <li>Forward transform:\n      * y<sub>n</sub> = [2(N - 1)]<sup>-1/2</sup> [x<sub>0</sub>", "timestamp": 1323761697, "metainfo": ""}