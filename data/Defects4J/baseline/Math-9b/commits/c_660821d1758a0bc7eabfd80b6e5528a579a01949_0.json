{"sha": "660821d1758a0bc7eabfd80b6e5528a579a01949", "log": "MATH-707 Class name change:   \"AbstractUnivariateRealOptimizer\" -> \"BaseAbstractUnivariateOptimizer\"   \"MultiStartUnivariateRealOptimizer\" -> \"UnivariateMultiStartOptimizer\"   \"BaseUnivariateRealOptimizer\" -> \"BaseUnivariateOptimizer\"   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseAbstractUnivariateOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * optimizers.\n+ *\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public abstract class BaseAbstractUnivariateOptimizer\n+    implements UnivariateRealOptimizer {\n+    /** Convergence checker. */\n+    private final ConvergenceChecker<UnivariateRealPointValuePair> checker;\n+    /** Evaluations counter. */\n+    private final Incrementor evaluations = new Incrementor();\n+    /** Optimization type */\n+    private GoalType goal;\n+    /** Lower end of search interval. */\n+    private double searchMin;\n+    /** Higher end of search interval. */\n+    private double searchMax;\n+    /** Initial guess . */\n+    private double searchStart;\n+    /** Function to optimize. */\n+    private UnivariateFunction function;\n+\n+    /**\n+     * @param checker Convergence checking procedure.\n+     */\n+    protected BaseAbstractUnivariateOptimizer(ConvergenceChecker<UnivariateRealPointValuePair> checker) {\n+        this.checker = checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /**\n+     * @return the optimization type.\n+     */\n+    public GoalType getGoalType() {\n+        return goal;\n+    }\n+    /**\n+     * @return the lower end of the search interval.\n+     */\n+    public double getMin() {\n+        return searchMin;\n+    }\n+    /**\n+     * @return the higher end of the search interval.\n+     */\n+    public double getMax() {\n+        return searchMax;\n+    }\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double getStartValue() {\n+        return searchStart;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    protected double computeObjectiveValue(double point) {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+        return function.value(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(int maxEval, UnivariateFunction f,\n+                                                 GoalType goalType,\n+                                                 double min, double max,\n+                                                 double startValue) {\n+        // Checks.\n+        if (f == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (goalType == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        // Reset.\n+        searchMin = min;\n+        searchMax = max;\n+        searchStart = startValue;\n+        goal = goalType;\n+        function = f;\n+        evaluations.setMaximalCount(maxEval);\n+        evaluations.resetCount();\n+\n+        // Perform computation.\n+        return doOptimize();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(int maxEval,\n+                                                 UnivariateFunction f,\n+                                                 GoalType goalType,\n+                                                 double min, double max){\n+        return optimize(maxEval, f, goalType, min, max, min + 0.5 * (max - min));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /**\n+     * Method for implementing actual optimization algorithms in derived\n+     * classes.\n+     *\n+     * @return the optimum and its corresponding function value.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    protected abstract UnivariateRealPointValuePair doOptimize();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.optimization.BaseOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+\n+/**\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.univariate.UnivariateRealOptimizer}</li>\n+ * </ul>\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface BaseUnivariateOptimizer<FUNC extends UnivariateFunction>\n+    extends BaseOptimizer<UnivariateRealPointValuePair> {\n+    /**\n+     * Find an optimum in the given interval.\n+     *\n+     * An optimizer may require that the interval brackets a single optimum.\n+     *\n+     * @param f Function to optimize.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @return a (point, value) pair where the function is optimum.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximum evaluation count is exceeded.\n+     * @throws org.apache.commons.math.exception.ConvergenceException\n+     * if the optimizer detects a convergence problem.\n+     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n+     * do not satisfy the requirements specified by the optimizer.\n+     */\n+    UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                          double min, double max);\n+\n+    /**\n+     * Find an optimum in the given interval, start at startValue.\n+     * An optimizer may require that the interval brackets a single optimum.\n+     *\n+     * @param f Function to optimize.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @return a (point, value) pair where the function is optimum.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximum evaluation count is exceeded.\n+     * @throws org.apache.commons.math.exception.ConvergenceException if the\n+     * optimizer detects a convergence problem.\n+     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n+     * do not satisfy the requirements specified by the optimizer.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if any\n+     * argument is {@code null}.\n+     */\n+    UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                          double min, double max,\n+                                          double startValue);\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n  * @version $Id$\n  * @since 2.0\n  */\n-public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n+public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n     /**\n      * Golden section.\n      */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateMultiStartOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+\n+/**\n+ * Special implementation of the {@link UnivariateRealOptimizer} interface\n+ * adding multi-start features to an existing optimizer.\n+ *\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class UnivariateMultiStartOptimizer<FUNC extends UnivariateFunction>\n+    implements BaseUnivariateOptimizer<FUNC> {\n+    /** Underlying classical optimizer. */\n+    private final BaseUnivariateOptimizer<FUNC> optimizer;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+    /** Number of starts to go. */\n+    private int starts;\n+    /** Random generator for multi-start. */\n+    private RandomGenerator generator;\n+    /** Found optima. */\n+    private UnivariateRealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform. If {@code starts == 1},\n+     * the {@code optimize} methods will return the same solution as\n+     * {@code optimizer} would.\n+     * @param generator Random generator to use for restarts.\n+     * @throws NullArgumentException if {@code optimizer} or {@code generator}\n+     * is {@code null}.\n+     * @throws NotStrictlyPositiveException if {@code starts < 1}.\n+     */\n+    public UnivariateMultiStartOptimizer(final BaseUnivariateOptimizer<FUNC> optimizer,\n+                                             final int starts,\n+                                             final RandomGenerator generator) {\n+        if (optimizer == null ||\n+                generator == null) {\n+                throw new NullArgumentException();\n+        }\n+        if (starts < 1) {\n+            throw new NotStrictlyPositiveException(starts);\n+        }\n+\n+        this.optimizer = optimizer;\n+        this.starts = starts;\n+        this.generator = generator;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /**\n+     * Get all the optima found during the last call to {@link\n+     * #optimize(int,UnivariateFunction,GoalType,double,double) optimize}.\n+     * The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n+     * method returns the best point only. This method returns all the points\n+     * found at the end of each starts, including the best one already\n+     * returned by the {@link #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n+     * method.\n+     * <br/>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by {@code null} elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be {@code null} if the {@link\n+     * #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n+     * method did throw an exception.\n+     * This also means that if the first element is not {@code null}, it is\n+     * the best point found across all starts.\n+     *\n+     * @return an array containing the optima.\n+     * @throws MathIllegalStateException if {@link\n+     * #optimize(int,UnivariateFunction,GoalType,double,double) optimize}\n+     * has not been called.\n+     */\n+    public UnivariateRealPointValuePair[] getOptima() {\n+        if (optima == null) {\n+            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(int maxEval, final FUNC f,\n+                                                 final GoalType goal,\n+                                                 final double min, final double max) {\n+        return optimize(maxEval, f, goal, min, max, min + 0.5 * (max - min));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(int maxEval, final FUNC f,\n+                                                 final GoalType goal,\n+                                                 final double min, final double max,\n+                                                 final double startValue) {\n+        RuntimeException lastException = null;\n+        optima = new UnivariateRealPointValuePair[starts];\n+        totalEvaluations = 0;\n+\n+        // Multi-start loop.\n+        for (int i = 0; i < starts; ++i) {\n+            // CHECKSTYLE: stop IllegalCatch\n+            try {\n+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n+                optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal, min, max, s);\n+            } catch (RuntimeException mue) {\n+                lastException = mue;\n+                optima[i] = null;\n+            }\n+            // CHECKSTYLE: resume IllegalCatch\n+\n+            totalEvaluations += optimizer.getEvaluations();\n+        }\n+\n+        sortPairs(goal);\n+\n+        if (optima[0] == null) {\n+            throw lastException; // cannot be null if starts >=1\n+        }\n+\n+        // Return the point with the best objective function value.\n+        return optima[0];\n+    }\n+\n+    /**\n+     * Sort the optima from best to worst, followed by {@code null} elements.\n+     *\n+     * @param goal Goal type.\n+     */\n+    private void sortPairs(final GoalType goal) {\n+        Arrays.sort(optima, new Comparator<UnivariateRealPointValuePair>() {\n+                public int compare(final UnivariateRealPointValuePair o1,\n+                                   final UnivariateRealPointValuePair o2) {\n+                    if (o1 == null) {\n+                        return (o2 == null) ? 0 : 1;\n+                    } else if (o2 == null) {\n+                        return -1;\n+                    }\n+                    final double v1 = o1.getValue();\n+                    final double v2 = o2.getValue();\n+                    return (goal == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+                }\n+            });\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/UnivariateRealOptimizer.java\n  * @since 3.0\n  */\n public interface UnivariateRealOptimizer\n-    extends BaseUnivariateRealOptimizer<UnivariateFunction> {}\n+    extends BaseUnivariateOptimizer<UnivariateFunction> {}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/UnivariateMultiStartOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class UnivariateMultiStartOptimizerTest {\n+\n+    @Test\n+    public void testSinMin() {\n+        UnivariateFunction f = new SinFunction();\n+        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(44428400075l);\n+        UnivariateMultiStartOptimizer<UnivariateFunction> optimizer =\n+            new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 10, g);\n+        optimizer.optimize(300, f, GoalType.MINIMIZE, -100.0, 100.0);\n+        UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n+        for (int i = 1; i < optima.length; ++i) {\n+            double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);\n+            Assert.assertTrue(FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);\n+            Assert.assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10);\n+            Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10);\n+        }\n+        Assert.assertTrue(optimizer.getEvaluations() > 200);\n+        Assert.assertTrue(optimizer.getEvaluations() < 300);\n+    }\n+\n+    @Test\n+    public void testQuinticMin() {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        UnivariateFunction f = new QuinticFunction();\n+        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(4312000053L);\n+        UnivariateMultiStartOptimizer<UnivariateFunction> optimizer =\n+            new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 5, g);\n+\n+        UnivariateRealPointValuePair optimum\n+            = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n+        Assert.assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);\n+        Assert.assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n+\n+        UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n+        for (int i = 0; i < optima.length; ++i) {\n+            Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9);\n+        }\n+        Assert.assertTrue(optimizer.getEvaluations() >= 50);\n+        Assert.assertTrue(optimizer.getEvaluations() <= 100);\n+    }\n+\n+    @Test\n+    public void testBadFunction() {\n+        UnivariateFunction f = new UnivariateFunction() {\n+                public double value(double x) {\n+                    if (x < 0) {\n+                        throw new LocalException();\n+                    }\n+                    return 0;\n+                }\n+            };\n+        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(4312000053L);\n+        UnivariateMultiStartOptimizer<UnivariateFunction> optimizer =\n+            new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 5, g);\n+ \n+        try {\n+            optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n+            Assert.fail();\n+        } catch (LocalException e) {\n+            // Expected.\n+        }\n+\n+        // Ensure that the exception was thrown because no optimum was found.\n+        Assert.assertTrue(optimizer.getOptima()[0] == null);\n+    }\n+\n+    private static class LocalException extends RuntimeException {\n+        private static final long serialVersionUID = 1194682757034350629L;\n+    }\n+\n+}", "timestamp": 1323435611, "metainfo": ""}