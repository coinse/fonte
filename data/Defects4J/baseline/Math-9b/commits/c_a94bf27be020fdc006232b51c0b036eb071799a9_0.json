{"sha": "a94bf27be020fdc006232b51c0b036eb071799a9", "log": "improved robustness in case of events just at integration start  When an event occurs exactly at integration start, the first truncated steps ends up with zero size. This induced problems with forward/backward sensing based on this step alone. This also induced an infinite loop in the calling integrators.  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/java/org/apache/commons/math/ode/events/EventState.java\n \n             double ta = t0;\n             double ga = g0;\n-            double tb = t0 + ((t1 > t0) ? convergence : -convergence);\n+            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n             for (int i = 0; i < n; ++i) {\n \n                 // evaluate handler value at the end of the substep\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(ta, tb) : solver.solve(tb, ta);\n-                    if (Double.isNaN(previousEventTime) ||\n+                    if (Math.abs(root - ta) <= convergence) {\n+                        // we have found (again ?) a past event, we simply ignore it\n+                        ta = tb;\n+                        ga = gb;\n+                    } else if (Double.isNaN(previousEventTime) ||\n                         (Math.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n                         if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n         pendingEventTime  = Double.NaN;\n \n         return (nextAction == EventHandler.RESET_STATE) ||\n-        (nextAction == EventHandler.RESET_DERIVATIVES);\n+               (nextAction == EventHandler.RESET_DERIVATIVES);\n \n     }\n ", "timestamp": 1216047093, "metainfo": ""}