{"sha": "02f92a3273d8a1352f2b2a549234566d23405f28", "log": "Added a 3D SubLine class.  JIRA: MATH-593  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n  */\n package org.apache.commons.math.geometry.euclidean.threed;\n \n-import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.geometry.Vector;\n import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.partitioning.Embedding;\n import org.apache.commons.math.util.FastMath;\n /** The class represent lines in a three dimensional space.\n \n  * <p>Each oriented line is intrinsically associated with an abscissa\n- * wich is a coordinate on the line. The point at abscissa 0 is the\n+ * which is a coordinate on the line. The point at abscissa 0 is the\n  * orthogonal projection of the origin on the line, another equivalent\n  * way to express this is to say that it is the point of the line\n  * which is closest to the origin. Abscissa increases in the line\n     /** Line point closest to the origin. */\n     private Vector3D zero;\n \n-    /** Build a line from a point and a direction.\n-     * @param p point belonging to the line (this can be any point)\n-     * @param direction direction of the line\n-     * @exception MathArithmeticException if the direction norm is too small\n-     */\n-    public Line(final Vector3D p, final Vector3D direction) {\n-        reset(p, direction);\n+    /** Build a line from two points.\n+     * @param p1 first point belonging to the line (this can be any point)\n+     * @param p2 second point belonging to the line (this can be any point, different from p1)\n+     * @exception MathIllegalArgumentException if the points are equal\n+     */\n+    public Line(final Vector3D p1, final Vector3D p2) {\n+        reset(p1, p2);\n     }\n \n     /** Copy constructor.\n         this.zero      = line.zero;\n     }\n \n-    /** Reset the instance as if built from a point and a normal.\n-     * @param p point belonging to the line (this can be any point)\n-     * @param dir direction of the line\n-     * @exception MathArithmeticException if the direction norm is too small\n-     */\n-    public void reset(final Vector3D p, final Vector3D dir) {\n-        final double norm = dir.getNorm();\n-        if (norm == 0.0) {\n-            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+    /** Reset the instance as if built from two points.\n+     * @param p1 first point belonging to the line (this can be any point)\n+     * @param p2 second point belonging to the line (this can be any point, different from p1)\n+     * @exception MathIllegalArgumentException if the points are equal\n+     */\n+    public void reset(final Vector3D p1, final Vector3D p2) {\n+        final Vector3D delta = p2.subtract(p1);\n+        final double norm2 = delta.getNormSq();\n+        if (norm2 == 0.0) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n         }\n-        this.direction = new Vector3D(1.0 / norm, dir);\n-        zero = new Vector3D(1.0, p, -p.dotProduct(this.direction), this.direction);\n+        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n+        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n     }\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        return new Line(zero, direction.negate());\n+        return new Line(zero, zero.subtract(direction));\n     }\n \n     /** Get the normalized direction vector.\n         return line.contains(closest) ? closest : null;\n     }\n \n+    /** Build a sub-line covering the whole line.\n+     * @return a sub-line covering the whole line\n+     */\n+    public SubLine wholeLine() {\n+        return new SubLine(this, new IntervalsSet());\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n         if (direction.getNorm() < 1.0e-10) {\n             return null;\n         }\n-        return new Line(intersection(this, other, new Plane(direction)),\n-                        direction);\n+        final Vector3D point = intersection(this, other, new Plane(direction));\n+        return new Line(point, point.add(direction));\n     }\n \n     /** Get the intersection point of three planes.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Segment.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threed;\n+\n+\n+/** Simple container for a two-points segment.\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class Segment {\n+\n+    /** Start point of the segment. */\n+    private final Vector3D start;\n+\n+    /** End point of the segments. */\n+    private final Vector3D end;\n+\n+    /** Line containing the segment. */\n+    private final Line     line;\n+\n+    /** Build a segment.\n+     * @param start start point of the segment\n+     * @param end end point of the segment\n+     * @param line line containing the segment\n+     */\n+    public Segment(final Vector3D start, final Vector3D end, final Line line) {\n+        this.start  = start;\n+        this.end    = end;\n+        this.line   = line;\n+    }\n+\n+    /** Get the start point of the segment.\n+     * @return start point of the segment\n+     */\n+    public Vector3D getStart() {\n+        return start;\n+    }\n+\n+    /** Get the end point of the segment.\n+     * @return end point of the segment\n+     */\n+    public Vector3D getEnd() {\n+        return end;\n+    }\n+\n+    /** Get the line containing the segment.\n+     * @return line containing the segment\n+     */\n+    public Line getLine() {\n+        return line;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubLine.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threed;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.euclidean.oned.Interval;\n+import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n+import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region.Location;\n+\n+/** This class represents a subset of a {@link Line}.\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class SubLine {\n+\n+    /** Underlying line. */\n+    private final Line line;\n+\n+    /** Remaining region of the hyperplane. */\n+    private final IntervalsSet remainingRegion;\n+\n+    /** Simple constructor.\n+     * @param line underlying line\n+     * @param remainingRegion remaining region of the line\n+     */\n+    public SubLine(final Line line, final IntervalsSet remainingRegion) {\n+        this.line            = line;\n+        this.remainingRegion = remainingRegion;\n+    }\n+\n+    /** Create a sub-line from two endpoints.\n+     * @param start start point\n+     * @param end end point\n+     */\n+    public SubLine(final Vector3D start, final Vector3D end) {\n+        this(new Line(start, end), buildIntervalSet(start, end));\n+    }\n+\n+    /** Create a sub-line from a segment.\n+     * @param segment single segment forming the sub-line\n+     */\n+    public SubLine(final Segment segment) {\n+        this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));\n+    }\n+\n+    /** Get the endpoints of the sub-line.\n+     * <p>\n+     * A subline may be any arbitrary number of disjoints segments, so the endpoints\n+     * are provided as a list of endpoint pairs. Each element of the list represents\n+     * one segment, and each segment contains a start point at index 0 and an end point\n+     * at index 1. If the sub-line is unbounded in the negative infinity direction,\n+     * the start point of the first segment will have infinite coordinates. If the\n+     * sub-line is unbounded in the positive infinity direction, the end point of the\n+     * last segment will have infinite coordinates. So a sub-line covering the whole\n+     * line will contain just one row and both elements of this row will have infinite\n+     * coordinates. If the sub-line is empty, the returned list will contain 0 segments.\n+     * </p>\n+     * @return list of segments endpoints\n+     */\n+    public List<Segment> getSegments() {\n+\n+        final List<Interval> list = remainingRegion.asList();\n+        final List<Segment> segments = new ArrayList<Segment>();\n+\n+        for (final Interval interval : list) {\n+            final Vector3D start = line.toSpace(new Vector1D(interval.getLower()));\n+            final Vector3D end   = line.toSpace(new Vector1D(interval.getUpper()));\n+            segments.add(new Segment(start, end, line));\n+        }\n+\n+        return segments;\n+\n+    }\n+\n+    /** Get the intersection of the instance and another sub-line.\n+     * <p>\n+     * This method is related to the {@link Line#intersection(Hyperplane)\n+     * intersection} method in the {@link Line Line} class, but in addition\n+     * to compute the point along infinite lines, it also checks the point\n+     * lies on both sub-line ranges.\n+     * </p>\n+     * @param subLine other sub-line which may intersect instance\n+     * @param includeEndPoints if true, endpoints are considered to belong to\n+     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\n+     * are considered to not belong to instance (i.e. they are open sets) and intersection\n+     * occurring on endpoints lead to null being returned\n+     * @return the intersection point if there is one, null if the sub-lines don't intersect\n+     */\n+    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n+\n+        // compute the intersection on infinite line\n+        Vector3D v1D = line.intersection(subLine.line);\n+\n+        // check location of point with respect to first sub-line\n+        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n+\n+        // check location of point with respect to second sub-line\n+        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n+\n+        if (includeEndPoints) {\n+            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n+        } else {\n+            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n+        }\n+\n+    }\n+\n+    /** Build an interval set from two points.\n+     * @param start start point\n+     * @param end end point\n+     * @return an interval set\n+     */\n+    private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end) {\n+        final Line line = new Line(start, end);\n+        return new IntervalsSet(line.toSubSpace(start).getX(),\n+                                line.toSubSpace(end).getX());\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/threed/LineTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threed/LineTest.java\n     @Test\n     public void testContains() {\n         Vector3D p1 = new Vector3D(0, 0, 1);\n-        Line l = new Line(p1, new Vector3D(0, 0, 1));\n+        Line l = new Line(p1, new Vector3D(0, 0, 2));\n         Assert.assertTrue(l.contains(p1));\n         Assert.assertTrue(l.contains(new Vector3D(1.0, p1, 0.3, l.getDirection())));\n         Vector3D u = l.getDirection().orthogonal();\n     public void testSimilar() {\n         Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);\n         Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);\n-        Line     lA  = new Line(p1, p2.subtract(p1));\n-        Line     lB  = new Line(p2, p1.subtract(p2));\n+        Line     lA  = new Line(p1, p2);\n+        Line     lB  = new Line(p2, p1);\n         Assert.assertTrue(lA.isSimilarTo(lB));\n-        Assert.assertTrue(! lA.isSimilarTo(new Line(p1, lA.getDirection().orthogonal())));\n+        Assert.assertTrue(! lA.isSimilarTo(new Line(p1, p1.add(lA.getDirection().orthogonal()))));\n     }\n \n     @Test\n     public void testPointDistance() {\n-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 1, 1));\n+        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n         Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Vector3D(1, 0, 1)), 1.0e-10);\n         Assert.assertEquals(0, l.distance(new Vector3D(0, -4, -4)), 1.0e-10);\n     }\n \n     @Test\n     public void testLineDistance() {\n-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 1, 1));\n+        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n         Assert.assertEquals(1.0,\n-                            l.distance(new Line(new Vector3D(1, 0, 1), Vector3D.PLUS_K)),\n+                            l.distance(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))),\n                             1.0e-10);\n         Assert.assertEquals(0.5,\n-                            l.distance(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(0, -1, -1))),\n+                            l.distance(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n                             l.distance(l),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -1, -1))),\n+                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, 1, 0))),\n+                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(1, 0, 0))),\n+                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))),\n                             1.0e-10);\n         Assert.assertEquals(FastMath.sqrt(8),\n-                            l.distance(new Line(new Vector3D(0, -4, 0), new Vector3D(1, 0, 0))),\n+                            l.distance(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))),\n                             1.0e-10);\n     }\n \n     @Test\n     public void testClosest() {\n-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 1, 1));\n+        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n         Assert.assertEquals(0.0,\n-                            l.closestPoint(new Line(new Vector3D(1, 0, 1), Vector3D.PLUS_K)).distance(new Vector3D(0, 0, 0)),\n+                            l.closestPoint(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))).distance(new Vector3D(0, 0, 0)),\n                             1.0e-10);\n         Assert.assertEquals(0.5,\n-                            l.closestPoint(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(0, -1, -1))).distance(new Vector3D(-0.5, 0, 0)),\n+                            l.closestPoint(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))).distance(new Vector3D(-0.5, 0, 0)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n                             l.closestPoint(l).distance(new Vector3D(0, 0, 0)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -1, -1))).distance(new Vector3D(0, 0, 0)),\n+                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))).distance(new Vector3D(0, 0, 0)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, 1, 0))).distance(new Vector3D(0, -4, -4)),\n+                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))).distance(new Vector3D(0, -4, -4)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(1, 0, 0))).distance(new Vector3D(0, -4, -4)),\n+                            l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))).distance(new Vector3D(0, -4, -4)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.closestPoint(new Line(new Vector3D(0, -4, 0), new Vector3D(1, 0, 0))).distance(new Vector3D(0, -2, -2)),\n+                            l.closestPoint(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))).distance(new Vector3D(0, -2, -2)),\n                             1.0e-10);\n     }\n \n     @Test\n     public void testIntersection() {\n-        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 1, 1));\n-        Assert.assertNull(l.intersection(new Line(new Vector3D(1, 0, 1), Vector3D.PLUS_K)));\n-        Assert.assertNull(l.intersection(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(0, -1, -1))));\n+        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2));\n+        Assert.assertNull(l.intersection(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))));\n+        Assert.assertNull(l.intersection(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))));\n         Assert.assertEquals(0.0,\n                             l.intersection(l).distance(new Vector3D(0, 0, 0)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -1, -1))).distance(new Vector3D(0, 0, 0)),\n+                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))).distance(new Vector3D(0, 0, 0)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, 1, 0))).distance(new Vector3D(0, -4, -4)),\n+                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))).distance(new Vector3D(0, -4, -4)),\n                             1.0e-10);\n         Assert.assertEquals(0.0,\n-                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(1, 0, 0))).distance(new Vector3D(0, -4, -4)),\n+                            l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))).distance(new Vector3D(0, -4, -4)),\n                             1.0e-10);\n-        Assert.assertNull(l.intersection(new Line(new Vector3D(0, -4, 0), new Vector3D(1, 0, 0))));\n+        Assert.assertNull(l.intersection(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/threed/PlaneTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threed/PlaneTest.java\n     @Test\n     public void testIntersection() {\n         Plane p = new Plane(new Vector3D(1, 2, 3), new Vector3D(-4, 1, -5));\n-        Line  l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1, 1, -1));\n+        Line  l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1.2, -2.5, -0.3));\n         Vector3D point = p.intersection(l);\n         Assert.assertTrue(p.contains(point));\n         Assert.assertTrue(l.contains(point));\n         Assert.assertNull(p.intersection(new Line(new Vector3D(10, 10, 10),\n-                                                  p.getNormal().orthogonal())));\n+                                                  new Vector3D(10, 10, 10).add(p.getNormal().orthogonal()))));\n     }\n \n     @Test\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threed/SubLineTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threed;\n+\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+import org.apache.commons.math.geometry.euclidean.oned.IntervalsSet;\n+import org.apache.commons.math.geometry.partitioning.RegionFactory;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SubLineTest {\n+\n+    @Test\n+    public void testEndPoints() {\n+        Vector3D p1 = new Vector3D(-1, -7, 2);\n+        Vector3D p2 = new Vector3D(7, -1, 0);\n+        Segment segment = new Segment(p1, p2, new Line(p1, p2));\n+        SubLine sub = new SubLine(segment);\n+        List<Segment> segments = sub.getSegments();\n+        Assert.assertEquals(1, segments.size());\n+        Assert.assertEquals(0.0, new Vector3D(-1, -7, 2).distance(segments.get(0).getStart()), 1.0e-10);\n+        Assert.assertEquals(0.0, new Vector3D( 7, -1, 0).distance(segments.get(0).getEnd()), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testNoEndPoints() {\n+        SubLine wholeLine = new Line(new Vector3D(-1, 7, 2), new Vector3D(7, 1, 0)).wholeLine();\n+        List<Segment> segments = wholeLine.getSegments();\n+        Assert.assertEquals(1, segments.size());\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&\n+                          segments.get(0).getStart().getX() < 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&\n+                          segments.get(0).getStart().getY() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ()) &&\n+                          segments.get(0).getStart().getZ() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&\n+                          segments.get(0).getEnd().getX() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&\n+                          segments.get(0).getEnd().getY() < 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ()) &&\n+                          segments.get(0).getEnd().getZ() < 0);\n+    }\n+\n+    @Test\n+    public void testNoSegments() {\n+        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)),\n+                                    (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet()));\n+        List<Segment> segments = empty.getSegments();\n+        Assert.assertEquals(0, segments.size());\n+    }\n+\n+    @Test\n+    public void testSeveralSegments() {\n+        SubLine twoSubs = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)),\n+                                      (IntervalsSet) new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2),\n+                                                                                            new IntervalsSet(3, 4)));\n+        List<Segment> segments = twoSubs.getSegments();\n+        Assert.assertEquals(2, segments.size());\n+    }\n+\n+    @Test\n+    public void testHalfInfiniteNeg() {\n+        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)),\n+                                    new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0));\n+        List<Segment> segments = empty.getSegments();\n+        Assert.assertEquals(1, segments.size());\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) &&\n+                          segments.get(0).getStart().getX() < 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) &&\n+                          segments.get(0).getStart().getY() < 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ()) &&\n+                          segments.get(0).getStart().getZ() > 0);\n+        Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getEnd()), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testHalfInfinitePos() {\n+        SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)),\n+                                    new IntervalsSet(0.0, Double.POSITIVE_INFINITY));\n+        List<Segment> segments = empty.getSegments();\n+        Assert.assertEquals(1, segments.size());\n+        Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getStart()), 1.0e-10);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) &&\n+                          segments.get(0).getEnd().getX() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) &&\n+                          segments.get(0).getEnd().getY() > 0);\n+        Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ()) &&\n+                          segments.get(0).getEnd().getZ() < 0);\n+    }\n+\n+    @Test\n+    public void testIntersectionInsideInside() {\n+        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));\n+        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 2, 2));\n+        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n+        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, false)), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testIntersectionInsideBoundary() {\n+        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));\n+        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1));\n+        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionInsideOutside() {\n+        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1));\n+        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));\n+        Assert.assertNull(sub1.intersection(sub2, true));\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionBoundaryBoundary() {\n+        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1));\n+        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1));\n+        Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)),  1.0e-12);\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionBoundaryOutside() {\n+        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1));\n+        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));\n+        Assert.assertNull(sub1.intersection(sub2, true));\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+    @Test\n+    public void testIntersectionOutsideOutside() {\n+        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\n+        SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5));\n+        Assert.assertNull(sub1.intersection(sub2, true));\n+        Assert.assertNull(sub1.intersection(sub2, false));\n+    }\n+\n+}", "timestamp": 1313693408, "metainfo": ""}