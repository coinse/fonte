{"sha": "6f35d5bb66e6e085371c4a501e792886153fe709", "log": "delayed integrator internal state update after the call to step handler to ensure integrator.getStepStart() and interpolator.getPreviousTime() are consistent. renamed getStepsize() into getSignedStepsize()  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n     return stepStart;\n   }\n \n-  public double getCurrentStepsize() {\n+  public double getCurrentSignedStepsize() {\n     return stepSize;\n   }\n \n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n    * <p>This method solves an Initial Value Problem (IVP).</p>\n    * <p>Since this method stores some internal state variables made\n    * available in its public interface during integration ({@link\n-   * #getCurrentStepsize()}), it is <em>not</em> thread-safe.</p>\n+   * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n    * @param equations differential equations to integrate\n    * @param t0 initial time\n    * @param y0 initial value of the state vector at t0\n    */\n   public double getCurrentStepStart();\n \n-  /** Get the current value of the integration stepsize.\n+  /** Get the current signed value of the integration stepsize.\n    * <p>This method can be called during integration (typically by\n    * the object implementing the {@link FirstOrderDifferentialEquations\n-   * differential equations} problem) if the value of the current stepsize\n+   * differential equations} problem) if the signed value of the current stepsize\n    * that is tried is needed.</p>\n    * <p>The result is undefined if the method is called outside of\n    * calls to {@link #integrate}</p>\n-   * @return current value of the stepsize\n+   * @return current signed value of the stepsize\n    */\n-  public double getCurrentStepsize();\n+  public double getCurrentSignedStepsize();\n \n }\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n       if (! reject) {\n \n         // store end of step state\n-        stepStart += stepSize;\n+        double nextStep = stepStart + stepSize;\n         System.arraycopy(y1, 0, y, 0, y0.length);\n \n-        switchesHandler.stepAccepted(stepStart, y);\n+        switchesHandler.stepAccepted(nextStep, y);\n         if (switchesHandler.stop()) {\n           lastStep = true;\n         }\n \n         // provide the step data to the step handler\n-        interpolator.storeTime(stepStart);\n+        interpolator.storeTime(nextStep);\n         handler.handleStep(interpolator, lastStep);\n+        stepStart = nextStep;\n \n         if (switchesHandler.reset(stepStart, y) && ! lastStep) {\n           // some switching function has triggered changes that\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaFehlbergIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaFehlbergIntegrator.java\n       }\n \n       // the step has been accepted\n-      stepStart += stepSize;\n+      double nextStep = stepStart + stepSize;\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      switchesHandler.stepAccepted(stepStart, y);\n+      switchesHandler.stepAccepted(nextStep, y);\n       if (switchesHandler.stop()) {\n         lastStep = true;\n       } else {\n-        lastStep = forward ? (stepStart >= t) : (stepStart <= t);\n+        lastStep = forward ? (nextStep >= t) : (nextStep <= t);\n       }\n \n       // provide the step data to the step handler\n-      interpolator.storeTime(stepStart);\n+      interpolator.storeTime(nextStep);\n       handler.handleStep(interpolator, lastStep);\n+      stepStart = nextStep;\n \n       if (fsal) {\n         // save the last evaluation for the next step\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n       }\n \n       // the step has been accepted\n-      stepStart += stepSize;\n+      double nextStep = stepStart + stepSize;\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      switchesHandler.stepAccepted(stepStart, y);\n+      switchesHandler.stepAccepted(nextStep, y);\n       if (switchesHandler.stop()) {\n         lastStep = true;\n       } else {\n       }\n \n       // provide the step data to the step handler\n-      interpolator.storeTime(stepStart);\n+      interpolator.storeTime(nextStep);\n       handler.handleStep(interpolator, lastStep);\n+      stepStart = nextStep;\n \n       if (switchesHandler.reset(stepStart, y) && ! lastStep) {\n         // some switching function has triggered changes that\n     return stepStart;\n   }\n \n-  public double getCurrentStepsize() {\n+  public double getCurrentSignedStepsize() {\n     return stepSize;\n   }\n ", "timestamp": 1194115571, "metainfo": ""}