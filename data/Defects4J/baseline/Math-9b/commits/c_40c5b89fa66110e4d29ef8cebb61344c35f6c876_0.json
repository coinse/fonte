{"sha": "40c5b89fa66110e4d29ef8cebb61344c35f6c876", "log": "MATH-361   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.LocalizedFormats;\n      *\n      * @param c polynomial coefficients\n      * @throws NullPointerException if c is null\n-     * @throws IllegalArgumentException if c is empty\n+     * @throws NotStrictlyPositiveException if c is empty\n      */\n     public PolynomialFunction(double c[]) {\n         super();\n         if (c.length < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY,\n+                                                   c.length);\n         }\n         int l = c.length;\n         while ((l > 1) && (c[l - 1] == 0)) {\n      * @param coefficients  the coefficients of the polynomial to evaluate\n      * @param argument  the input value\n      * @return  the value of the polynomial\n-     * @throws IllegalArgumentException if coefficients is empty\n+     * @throws NotStrictlyPositiveException if coefficients is empty\n      * @throws NullPointerException if coefficients is null\n      */\n     protected static double evaluate(double[] coefficients, double argument) {\n         int n = coefficients.length;\n         if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY,\n+                                                   n);\n         }\n         double result = coefficients[n - 1];\n         for (int j = n -2; j >=0; j--) {\n      *\n      * @param coefficients  the coefficients of the polynomial to differentiate\n      * @return the coefficients of the derivative or null if coefficients has length 1.\n-     * @throws IllegalArgumentException if coefficients is empty\n+     * @throws NotStrictlyPositiveException if coefficients is empty\n      * @throws NullPointerException if coefficients is null\n      */\n     protected static double[] differentiate(double[] coefficients) {\n         int n = coefficients.length;\n         if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY,\n+                                                   n);\n         }\n         if (n == 1) {\n             return new double[]{0};\n--- a/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n  */\n package org.apache.commons.math.exception;\n \n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * Exception to be thrown when the argument is negative.\n     public NotPositiveException(Number value) {\n         super(value, 0, true);\n     }\n+    /**\n+     * Construct the exception with a specific context.\n+     *\n+     * @param specific Specific context where the error occurred.\n+     * @param value Argument.\n+     */\n+    public NotPositiveException(Localizable specific,\n+                                Number value) {\n+        super(specific, value, 0, true);\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java\n  */\n package org.apache.commons.math.exception;\n \n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.util.Localizable;\n \n /**\n  * Exception to be thrown when the argument is negative.\n     public NotStrictlyPositiveException(Number value) {\n         super(value, 0, false);\n     }\n+    /**\n+     * Construct the exception with a specific context.\n+     *\n+     * @param specific Specific context where the error occurred.\n+     * @param value Argument.\n+     */\n+    public NotStrictlyPositiveException(Localizable specific,\n+                                        Number value) {\n+        super(specific, value, 0, false);\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/exception/NumberIsTooLargeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NumberIsTooLargeException.java\n  */\n package org.apache.commons.math.exception;\n \n+import org.apache.commons.math.util.Localizable;\n import org.apache.commons.math.util.LocalizedFormats;\n \n /**\n     public NumberIsTooLargeException(Number wrong,\n                                      Number max,\n                                      boolean boundIsAllowed) {\n-        super((boundIsAllowed ?\n+        this(null, wrong, max, boundIsAllowed);\n+    }\n+    /**\n+     * Construct the exception with a specific context.\n+     *\n+     * @param specific Specific contexte pattern .\n+     * @param wrong Value that is larger than the maximum.\n+     * @param max maximum.\n+     */\n+    public NumberIsTooLargeException(Localizable specific,\n+                                     Number wrong,\n+                                     Number max,\n+                                     boolean boundIsAllowed) {\n+        super(specific,\n+              (boundIsAllowed ?\n                LocalizedFormats.NUMBER_TOO_LARGE :\n                LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED),\n               wrong, max);\n--- a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n  */\n package org.apache.commons.math.random;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Abstract class implementing the {@link  RandomGenerator} interface.\n  * Default implementations for all methods other than {@link #nextDouble()} and\n  * {@link #setSeed(long)} are provided.\n  * <p>\n- * All data generation methods are based on <code>nextDouble().</code>\n+ * All data generation methods are based on {@code code nextDouble()}.\n  * Concrete implementations <strong>must</strong> override\n  * this method and <strong>should</strong> provide better / more\n  * performant implementations of the other methods if the underlying PRNG\n      * Cached random normal value.  The default implementation for\n      * {@link #nextGaussian} generates pairs of values and this field caches the\n      * second value so that the full algorithm is not executed for every\n-     * activation.  The value <code>Double.NaN</code> signals that there is\n+     * activation.  The value {@code Double.NaN} signals that there is\n      * no cached value.  Use {@link #clear} to clear the cached value.\n      */\n     private double cachedNormalDeviate = Double.NaN;\n     /**\n      * Clears the cache used by the default implementation of\n      * {@link #nextGaussian}. Implemementations that do not override the\n-     * default implementation of <code>nextGaussian</code> should call this\n+     * default implementation of {@code nextGaussian} should call this\n      * method in the implementation of {@link #setSeed(long)}\n      */\n     public void clear() {\n \n     /**\n      * Sets the seed of the underyling random number generator using a\n-     * <code>long</code> seed.  Sequences of values generated starting with the\n+     * {@code long} seed.  Sequences of values generated starting with the\n      * same seeds should be identical.\n      * <p>\n      * Implementations that do not override the default implementation of\n-     * <code>nextGaussian</code> should include a call to {@link #clear} in the\n+     * {@code nextGaussian} should include a call to {@link #clear} in the\n      * implementation of this method.</p>\n      *\n      * @param seed the seed value\n     }\n \n      /**\n-     * Returns the next pseudorandom, uniformly distributed <code>int</code>\n+     * Returns the next pseudorandom, uniformly distributed {@code int}\n      * value from this random number generator's sequence.\n-     * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n+     * All 2<font size=\"-1\"><sup>32</sup></font> possible {@code int} values\n      * should be produced with  (approximately) equal probability.\n      * <p>\n      * The default implementation provided here returns\n      * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>\n      * </pre></p>\n      *\n-     * @return the next pseudorandom, uniformly distributed <code>int</code>\n+     * @return the next pseudorandom, uniformly distributed {@code int}\n      *  value from this random number generator's sequence\n      */\n     public int nextInt() {\n     }\n \n     /**\n-     * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n+     * Returns a pseudorandom, uniformly distributed {@code int} value\n      * between 0 (inclusive) and the specified value (exclusive), drawn from\n      * this random number generator's sequence.\n      * <p>\n      *\n      * @param n the bound on the random number to be returned.  Must be\n      * positive.\n-     * @return  a pseudorandom, uniformly distributed <tt>int</tt>\n+     * @return  a pseudorandom, uniformly distributed {@code int}\n      * value between 0 (inclusive) and n (exclusive).\n-     * @throws IllegalArgumentException if n is not positive.\n+     * @throws NotStrictlyPositiveException if {@code n <= 0}.\n      */\n     public int nextInt(int n) {\n         if (n <= 0 ) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_UPPER_BOUND, n);\n+            throw new NotStrictlyPositiveException(n);\n         }\n         int result = (int) (nextDouble() * n);\n         return result < n ? result : n - 1;\n     }\n \n      /**\n-     * Returns the next pseudorandom, uniformly distributed <code>long</code>\n+     * Returns the next pseudorandom, uniformly distributed {@code long}\n      * value from this random number generator's sequence.  All\n-     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values\n+     * 2<font size=\"-1\"><sup>64</sup></font> possible {@code long} values\n      * should be produced with (approximately) equal probability.\n      * <p>\n      * The default implementation returns\n      * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>\n      * </pre></p>\n      *\n-     * @return  the next pseudorandom, uniformly distributed <code>long</code>\n+     * @return  the next pseudorandom, uniformly distributed {@code long}\n      *value from this random number generator's sequence\n      */\n     public long nextLong() {\n \n     /**\n      * Returns the next pseudorandom, uniformly distributed\n-     * <code>boolean</code> value from this random number generator's\n+     * {@code boolean} value from this random number generator's\n      * sequence.\n      * <p>\n      * The default implementation returns\n      * </pre></p>\n      *\n      * @return  the next pseudorandom, uniformly distributed\n-     * <code>boolean</code> value from this random number generator's\n+     * {@code boolean} value from this random number generator's\n      * sequence\n      */\n     public boolean nextBoolean() {\n     }\n \n      /**\n-     * Returns the next pseudorandom, uniformly distributed <code>float</code>\n-     * value between <code>0.0</code> and <code>1.0</code> from this random\n+     * Returns the next pseudorandom, uniformly distributed {@code float}\n+     * value between {@code 0.0} and {@code 1.0} from this random\n      * number generator's sequence.\n      * <p>\n      * The default implementation returns\n      * <code>(float) nextDouble() </code>\n      * </pre></p>\n      *\n-     * @return  the next pseudorandom, uniformly distributed <code>float</code>\n-     * value between <code>0.0</code> and <code>1.0</code> from this\n+     * @return  the next pseudorandom, uniformly distributed {@code float}\n+     * value between {@code 0.0} and {@code 1.0} from this\n      * random number generator's sequence\n      */\n     public float nextFloat() {\n \n     /**\n      * Returns the next pseudorandom, uniformly distributed\n-     * <code>double</code> value between <code>0.0</code> and\n-     * <code>1.0</code> from this random number generator's sequence.\n+     * {@code double} value between {@code 0.0} and\n+     * {@code 1.0} from this random number generator's sequence.\n      * <p>\n      * This method provides the underlying source of random data used by the\n      * other methods.</p>\n      *\n      * @return  the next pseudorandom, uniformly distributed\n-     *  <code>double</code> value between <code>0.0</code> and\n-     *  <code>1.0</code> from this random number generator's sequence\n+     *  {@code double} value between {@code 0.0} and\n+     *  {@code 1.0} from this random number generator's sequence\n      */\n     public abstract double nextDouble();\n \n     /**\n      * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n-     * <code>double</code> value with mean <code>0.0</code> and standard\n-     * deviation <code>1.0</code> from this random number generator's sequence.\n+     * {@code double} value with mean {@code 0.0} and standard\n+     * deviation {@code 1.0} from this random number generator's sequence.\n      * <p>\n      * The default implementation uses the <em>Polar Method</em>\n      * due to G.E.P. Box, M.E. Muller and G. Marsaglia, as described in\n      * implementation of {@link #setSeed(long)}.</p>\n      *\n      * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n-     * <code>double</code> value with mean <code>0.0</code> and\n-     * standard deviation <code>1.0</code> from this random number\n+     * {@code double} value with mean {@code 0.0} and\n+     * standard deviation {@code 1.0} from this random number\n      *  generator's sequence\n      */\n     public double nextGaussian() {\n--- a/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n  */\n package org.apache.commons.math.random;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /** Base class for random number generators that generates bits streams.\n \n     public int nextInt(int n) throws IllegalArgumentException {\n \n         if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_UPPER_BOUND, n);\n+            throw new NotStrictlyPositiveException(n);\n         }\n \n         // find bit mask for n\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.distribution.BetaDistributionImpl;\n import org.apache.commons.math.distribution.BinomialDistributionImpl;\n import org.apache.commons.math.distribution.CauchyDistributionImpl;\n      * @param len\n      *            the desired string length.\n      * @return the random string.\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}.\n      */\n     public String nextHexString(int len) {\n         if (len <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_LENGTH, len);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n         }\n \n         // Get a random number generator\n      * @param upper\n      *            the upper bound.\n      * @return the random integer.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      */\n     public int nextInt(int lower, int upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                    upper, lower);\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n         return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n      * @param upper\n      *            the upper bound.\n      * @return the random integer.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      */\n     public long nextLong(long lower, long upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                  upper, lower);\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n         return (long) ((r * upper) + ((1.0 - r) * lower) + r);\n      * @param len\n      *            the length of the generated string\n      * @return the random string\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}.\n      */\n     public String nextSecureHexString(int len) {\n         if (len <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_LENGTH, len);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n         }\n \n         // Get SecureRandom and setup Digest provider\n      * @param upper\n      *            the upper bound.\n      * @return the random integer.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      */\n     public int nextSecureInt(int lower, int upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                  upper, lower);\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n         return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n      * @param upper\n      *            the upper bound.\n      * @return the random integer.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      */\n     public long nextSecureLong(long lower, long upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                  upper, lower);\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n         return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n      *\n      * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n      */\n     public long nextPoisson(double mean) {\n         if (mean <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, mean);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n         }\n \n         final RandomGenerator generator = getRan();\n      * @param sigma\n      *            the standard deviation of the distribution\n      * @return the random Normal value\n+     * @throws NotStrictlyPositiveException if {@code sigma <= 0}.\n      */\n     public double nextGaussian(double mu, double sigma) {\n         if (sigma <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION, sigma);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);\n         }\n         return sigma * getRan().nextGaussian() + mu;\n     }\n      *\n      * @param mean the mean of the distribution\n      * @return the random Exponential value\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n      */\n     public double nextExponential(double mean) {\n         if (mean <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_MEAN, mean);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n         }\n         final RandomGenerator generator = getRan();\n         double unif = generator.nextDouble();\n      *            the upper bound.\n      * @return a uniformly distributed random value from the interval (lower,\n      *         upper)\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                  upper, lower);\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper, false);\n         }\n         final RandomGenerator generator = getRan();\n \n      * @param k\n      *            size of the permutation (must satisfy 0 < k <= n).\n      * @return the random permutation as an int array\n+     * @throws NumberIsTooLargException if {@code k > n}.\n+     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n      */\n     public int[] nextPermutation(int n, int k) {\n         if (k > n) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.PERMUTATION_EXCEEDS_N, k, n);\n+            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n+                                                k, n, true);\n         }\n         if (k == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_PERMUTATION, k);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n+                                                   k);\n         }\n \n         int[] index = getNatural(n);\n      * @param k\n      *            sample size.\n      * @return the random sample.\n+     * @throws NumberIsTooLargeException if {@code k > c.size()}.\n+     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n      */\n     public Object[] nextSample(Collection<?> c, int k) {\n         int len = c.size();\n         if (k > len) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE);\n+            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n+                                                k, len, true);\n         }\n         if (k <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE, k);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n         }\n \n         Object[] objects = c.toArray();\n--- a/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * A {@link RandomVectorGenerator} that generates vectors with uncorrelated\n                                            double[] standardDeviation,\n                                            NormalizedRandomGenerator generator) {\n     if (mean.length != standardDeviation.length) {\n-      throw MathRuntimeException.createIllegalArgumentException(\n-            LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-            mean.length, standardDeviation.length);\n+        throw new DimensionMismatchException(mean.length, standardDeviation.length);\n     }\n     this.mean              = mean.clone();\n     this.standardDeviation = standardDeviation.clone();\n--- a/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n     DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Discrete cumulative probability function returned NaN for argument {0}\"),\n     DISTRIBUTION_NOT_LOADED(\"distribution not loaded\"),\n     DUPLICATED_ABSCISSA(\"Abscissa {0} is duplicated at both indices {1} and {2}\"),\n-    EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY(\"empty polynomials coefficients array\"),\n+    EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY(\"empty polynomials coefficients array\"), /* keep */\n     EMPTY_SELECTED_COLUMN_INDEX_ARRAY(\"empty selected column index array\"),\n     EMPTY_SELECTED_ROW_INDEX_ARRAY(\"empty selected row index array\"),\n     EMPTY_STRING_FOR_IMAGINARY_CHARACTER(\"empty string for imaginary character\"),\n     LCM_OVERFLOW_32_BITS(\"overflow: lcm({0}, {1}) is 2^31\"),\n     LCM_OVERFLOW_64_BITS(\"overflow: lcm({0}, {1}) is 2^63\"),\n     LOESS_EXPECTS_AT_LEAST_ONE_POINT(\"Loess expects at least 1 point\"),\n-    LOWER_BOUND_NOT_BELOW_UPPER_BOUND(\"upper bound ({0}) must be greater than lower bound ({1})\"),\n+    LOWER_BOUND_NOT_BELOW_UPPER_BOUND(\"lower bound ({0}) must be strictly less than upper bound ({1})\"), /* keep */\n     LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT(\"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\"),\n     MAP_MODIFIED_WHILE_ITERATING(\"map has been modified while iterating\"),\n     MAX_EVALUATIONS_EXCEEDED(\"maximal number of evaluations ({0}) exceeded\"),\n     NOT_POSITIVE_ELEMENT_AT_INDEX(\"element {0} is not positive: {1}\"),\n     NOT_POSITIVE_EXPONENT(\"invalid exponent {0} (must be positive)\"),\n     NOT_POSITIVE_LENGTH(\"length must be positive ({0})\"),\n+    LENGTH(\"length ({0})\"), /* keep */\n     NOT_POSITIVE_MEAN(\"mean must be positive ({0})\"),\n+    MEAN(\"mean ({0})\"), /* keep */\n     NOT_POSITIVE_NUMBER_OF_SAMPLES(\"number of sample is not positive: {0}\"),\n+    NUMBER_OF_SAMPLES(\"number of samples ({0})\"), /* keep */\n     NOT_POSITIVE_PERMUTATION(\"permutation k ({0}) must be positive\"),\n+    PERMUTATION_SIZE(\"permutation size ({0}\"), /* keep */\n     NOT_POSITIVE_POISSON_MEAN(\"the Poisson mean must be positive ({0})\"),\n     NOT_POSITIVE_POPULATION_SIZE(\"population size must be positive ({0})\"),\n     NOT_POSITIVE_ROW_DIMENSION(\"invalid row dimension: {0} (must be positive)\"),\n     NOT_POSITIVE_SCALE(\"scale must be positive ({0})\"),\n     NOT_POSITIVE_SHAPE(\"shape must be positive ({0})\"),\n     NOT_POSITIVE_STANDARD_DEVIATION(\"standard deviation must be positive ({0})\"),\n+    STANDARD_DEVIATION(\"standard deviation ({0})\"), /* keep */\n     NOT_POSITIVE_UPPER_BOUND(\"upper bound must be positive ({0})\"),\n     NOT_POSITIVE_WINDOW_SIZE(\"window size must be positive ({0})\"),\n     NOT_POWER_OF_TWO(\"{0} is not a power of 2\"),\n     OVERFLOW_IN_FRACTION(\"overflow in fraction {0}/{1}, cannot negate\"),\n     PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD(\"cannot access {0} method in percentile implementation {1}\"),\n     PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD(\"percentile implementation {0} does not support {1}\"),\n-    PERMUTATION_EXCEEDS_N(\"permutation k ({0}) exceeds n ({1})\"),\n+    PERMUTATION_EXCEEDS_N(\"permutation size ({0}) exceeds permuation domain ({1})\"), /* keep */\n     POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS(\"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\"),\n     POSITION_SIZE_MISMATCH_INPUT_ARRAY(\"position {0} and size {1} don't fit to the size of the input array {2}\"),\n     POWER_NEGATIVE_PARAMETERS(\"cannot raise an integral value to a negative power ({0}^{1})\"),\n     ROTATION_MATRIX_DIMENSIONS(\"a {0}x{1} matrix cannot be a rotation matrix\"),\n     ROW_INDEX_OUT_OF_RANGE(\"row index {0} out of allowed range [{1}, {2}]\"),\n     SAME_SIGN_AT_ENDPOINTS(\"function values at endpoints do not have different signs, endpoints: [{0}, {1}], values: [{2}, {3}]\"),\n-    SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE(\"sample size ({0}) exceeds collection size ({1})\"),\n+    SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE(\"sample size ({0}) exceeds collection size ({1})\"), /* keep */\n     SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE(\"sample size ({0}) must be less than or equal to population size ({1})\"),\n     SIMPLEX_NEED_ONE_POINT(\"simplex must contain at least one point\"),\n     SIMPLE_MESSAGE(\"{0}\"),", "timestamp": 1278681328, "metainfo": ""}