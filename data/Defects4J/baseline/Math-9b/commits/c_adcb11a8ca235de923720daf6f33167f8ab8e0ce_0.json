{"sha": "adcb11a8ca235de923720daf6f33167f8ab8e0ce", "log": "Moved variable declarations closer to their point of use.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n                 throw new NoDataException(LocalizedFormats.POLYNOMIAL);\n             }\n             // Coefficients for deflated polynomial.\n-            Complex c[] = new Complex[n + 1];\n+            final Complex c[] = new Complex[n + 1];\n             for (int i = 0; i <= n; i++) {\n                 c[i] = coefficients[i];\n             }\n \n             // Solve individual roots successively.\n-            Complex root[] = new Complex[n];\n+            final Complex root[] = new Complex[n];\n             for (int i = 0; i < n; i++) {\n-                Complex subarray[] = new Complex[n - i + 1];\n+                final Complex subarray[] = new Complex[n - i + 1];\n                 System.arraycopy(c, 0, subarray, 0, subarray.length);\n                 root[i] = solve(subarray, initial);\n                 // Polynomial deflation using synthetic division.\n             final double relativeAccuracy = getRelativeAccuracy();\n             final double functionValueAccuracy = getFunctionValueAccuracy();\n \n-            Complex N  = new Complex(n,     0.0);\n-            Complex N1 = new Complex(n - 1, 0.0);\n-\n-            Complex pv = null;\n-            Complex dv = null;\n-            Complex d2v = null;\n-            Complex G = null;\n-            Complex G2 = null;\n-            Complex H = null;\n-            Complex delta = null;\n-            Complex denominator = null;\n+            final Complex N  = new Complex(n, 0);\n+            final Complex N1 = new Complex(n - 1, 0);\n+\n             Complex z = initial;\n             Complex oldz = new Complex(Double.POSITIVE_INFINITY,\n                                        Double.POSITIVE_INFINITY);\n             while (true) {\n                 // Compute pv (polynomial value), dv (derivative value), and\n                 // d2v (second derivative value) simultaneously.\n-                pv = coefficients[n];\n-                dv = Complex.ZERO;\n-                d2v = Complex.ZERO;\n+                Complex pv = coefficients[n];\n+                Complex dv = Complex.ZERO;\n+                Complex d2v = Complex.ZERO;\n                 for (int j = n-1; j >= 0; j--) {\n                     d2v = dv.add(z.multiply(d2v));\n                     dv = pv.add(z.multiply(dv));\n                 d2v = d2v.multiply(new Complex(2.0, 0.0));\n \n                 // check for convergence\n-                double tolerance = FastMath.max(relativeAccuracy * z.abs(),\n-                                                absoluteAccuracy);\n+                final double tolerance = FastMath.max(relativeAccuracy * z.abs(),\n+                                                      absoluteAccuracy);\n                 if ((z.subtract(oldz)).abs() <= tolerance) {\n                     return z;\n                 }\n                 }\n \n                 // now pv != 0, calculate the new approximation\n-                G = dv.divide(pv);\n-                G2 = G.multiply(G);\n-                H = G2.subtract(d2v.divide(pv));\n-                delta = N1.multiply((N.multiply(H)).subtract(G2));\n+                final Complex G = dv.divide(pv);\n+                final Complex G2 = G.multiply(G);\n+                final Complex H = G2.subtract(d2v.divide(pv));\n+                final Complex delta = N1.multiply((N.multiply(H)).subtract(G2));\n                 // choose a denominator larger in magnitude\n-                Complex deltaSqrt = delta.sqrt();\n-                Complex dplus = G.add(deltaSqrt);\n-                Complex dminus = G.subtract(deltaSqrt);\n-                denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n+                final Complex deltaSqrt = delta.sqrt();\n+                final Complex dplus = G.add(deltaSqrt);\n+                final Complex dminus = G.subtract(deltaSqrt);\n+                final Complex denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n                 // Perturb z if denominator is zero, for instance,\n                 // p(x) = x^3 + 1, z = 0.\n                 if (denominator.equals(new Complex(0.0, 0.0))) {", "timestamp": 1342386393, "metainfo": ""}