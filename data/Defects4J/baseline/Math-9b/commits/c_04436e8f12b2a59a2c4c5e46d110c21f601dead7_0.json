{"sha": "04436e8f12b2a59a2c4c5e46d110c21f601dead7", "log": "Fixes MATH-437  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Treats the distribution of the two-sided \n+ * {@code P(D<sub>n</sup> &lt; d)}\n+ * where {@code D<sub>n</sup> = sup_x | G(x) - Gn (x) |} for the \n+ * theoretical cdf G and the emperical cdf Gn.\n+ * \n+ * This implementation is based on [1] with certain quick \n+ * decisions for extreme values given in [2].\n+ * \n+ * In short, when wanting to evaluate {@code P(D<sub>n</sup> &lt; d)}, \n+ * the method in [1] is to write {@code d = (k - h) / n} for positive \n+ * integer {@code k} and {@code 0 <= h < 1}. Then \n+ * {@code P(D<sub>n</sup> &lt; d) = (n!/n^n) * t_kk}\n+ * where {@code t_kk} is the (k, k)'th entry in the special matrix {@code H^n}, \n+ * i.e. {@code H} to the {@code n}'th power. \n+ * \n+ * See also <a href=\"http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test\">\n+ * Kolmogorov-Smirnov test on Wikipedia</a> for details.\n+ * \n+ * References: \n+ * [1] Evaluating Kolmogorov's Distribution by George Marsaglia, Wai\n+ * Wan Tsang, Jingbo Wang http://www.jstatsoft.org/v08/i18/paper\n+ * \n+ * [2] <a href=\"http://www.iro.umontreal.ca/~lecuyer/myftp/papers/ksdist.pdf\">\n+ * Computing the Two-Sided Kolmogorov-Smirnov Distribution</a> by Richard Simard\n+ * and Pierre L'Ecuyer\n+ * \n+ * Note that [1] contains an error in computing h, refer to \n+ * <a href=\"https://issues.apache.org/jira/browse/MATH-437\">MATH-437</a> for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public interface KolmogorovSmirnovDistribution {\n+    \n+    public double cdf(double d);\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.fraction.FractionConversionException;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * The default implementation of {@link KolmogorovSmirnovDistribution}.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class KolmogorovSmirnovDistributionImpl implements KolmogorovSmirnovDistribution, Serializable {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4670676796862967187L;\n+\n+    private int n;\n+    \n+    /**\n+     * @param n Number of observations\n+     * @throws NotStrictlyPositiveException\n+     *             if n <= 0\n+     */\n+    public KolmogorovSmirnovDistributionImpl(int n) {\n+        if (n <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES, n);\n+        }\n+        \n+        this.n = n;\n+    }\n+\n+    /**\n+     * Calculates {@code P(D<sub>n</sup> &lt; d)} using method described in\n+     * [1] with quick decisions for extreme values given in [2] (see above). The\n+     * result is not exact as with \n+     * {@link KolmogorovSmirnovDistributionImpl#cdfExact(double)} because\n+     * calculations are based on double rather than \n+     * {@link org.apache.commons.math.fraction.BigFraction}.\n+     * \n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert h to a BigFraction in\n+     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     */\n+    @Override\n+    public double cdf(double d) throws MathArithmeticException {\n+        return this.cdf(d, false);\n+    }\n+\n+    /**\n+     * Calculates {@code P(D<sub>n</sup> &lt; d)} using method described in\n+     * [1] with quick decisions for extreme values given in [2] (see above). \n+     * The result is exact in the sense that BigFraction/BigReal is used everywhere \n+     * at the expense of very slow execution time. Almost never choose this in \n+     * real applications unless you are very sure; this is almost solely for\n+     * verification purposes. Normally, you would choose \n+     * {@link KolmogorovSmirnovDistributionImpl#cdf(double)}\n+     * \n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert h to a BigFraction in\n+     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     */\n+    public double cdfExact(double d) throws MathArithmeticException {\n+        return this.cdf(d, true);\n+    }\n+\n+    /**\n+     * Calculates {@code P(D<sub>n</sup> &lt; d)} using method described in\n+     * [1] with quick decisions for extreme values given in [2] (see above).\n+     * \n+     * @param d statistic\n+     * @param exact\n+     *            whether the probability should be calculated exact using\n+     *            BigFraction everywhere at the expense of very\n+     *            slow execution time, or if double should be used convenient\n+     *            places to gain speed. Never choose true in real applications\n+     *            unless you are very sure; true is almost solely for\n+     *            verification purposes.\n+     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert h to a BigFraction in\n+     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     */\n+    public double cdf(double d, boolean exact)\n+            throws MathArithmeticException {\n+        \n+        final int n = this.n;\n+\n+        final double ninv = 1 / ((double) n);\n+        final double ninvhalf = 0.5 * ninv;\n+\n+        if (d <= ninvhalf) {\n+\n+            return 0;\n+\n+        } else if (ninvhalf < d && d <= ninv) {\n+\n+            double res = 1;\n+            double f = 2 * d - ninv;\n+\n+            // n! f^n = n*f * (n-1)*f * ... * 1*x\n+            for (int i = 1; i <= n; ++i) {\n+                res *= i * f;\n+            }\n+\n+            return res;\n+\n+        } else if (1 - ninv <= d && d < 1) {\n+\n+            return 1 - 2 * Math.pow(1 - d, n);\n+\n+        } else if (1 <= d) {\n+\n+            return 1;\n+        }\n+\n+        return (exact) ? this.exactK(d) : this.roundedK(d);\n+    }\n+\n+    /**\n+     * Calculates {@code P(D<sub>n</sup> &lt; d)} exact using method\n+     * described in [1] and BigFraction (see above).\n+     * \n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert h to a BigFraction in\n+     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     */\n+    private double exactK(double d)\n+            throws MathArithmeticException {\n+\n+        final int n = this.n;\n+        final int k = (int) Math.ceil(n * d);\n+\n+        final FieldMatrix<BigFraction> H = this.createH(d);\n+        final FieldMatrix<BigFraction> Hpower = H.power(n);\n+\n+        BigFraction pFrac = Hpower.getEntry(k - 1, k - 1);\n+\n+        for (int i = 1; i <= n; ++i) {\n+            pFrac = pFrac.multiply(i).divide(n);\n+        }\n+\n+        /*\n+         * BigFraction.doubleValue converts numerator to double and the\n+         * denominator to double and divides afterwards. That gives NaN quite\n+         * easy. This does not (scale is the number of digits):\n+         */\n+        return pFrac.bigDecimalValue(20, BigDecimal.ROUND_HALF_UP)\n+                .doubleValue();\n+    }\n+\n+    /**\n+     * Calculates <code>P(D<sub>n</sup> &lt; d)</code> using method described in\n+     * [1] and doubles (see above).\n+     * \n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert h to a BigFraction in\n+     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     */\n+    private double roundedK(double d)\n+            throws MathArithmeticException {\n+        \n+        final int n = this.n;\n+        final int k = (int) Math.ceil(n * d);\n+        final FieldMatrix<BigFraction> HBigFraction = this.createH(d);\n+        final int m = HBigFraction.getRowDimension();\n+\n+        /*\n+         * Here the rounding part comes into play: use\n+         * RealMatrix instead of FieldMatrix<BigFraction>\n+         */\n+        final RealMatrix H = new Array2DRowRealMatrix(m, m);\n+\n+        for (int i = 0; i < m; ++i) {\n+            for (int j = 0; j < m; ++j) {\n+                H.setEntry(i, j, HBigFraction.getEntry(i, j).doubleValue());\n+            }\n+        }\n+\n+        final RealMatrix Hpower = H.power(n);\n+\n+        double pFrac = Hpower.getEntry(k - 1, k - 1);\n+\n+        for (int i = 1; i <= n; ++i) {\n+            pFrac *= (double)i / (double)n;\n+        }\n+\n+        return pFrac;\n+    }\n+\n+    /***\n+     * Creates H of size m x m as described in [1] (see above).\n+     * \n+     * @param d statistic\n+     *            \n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert h to a BigFraction in\n+     *             expressing x as (k - h) / m for integer k, m and 0 <= h < 1.\n+     */\n+    private FieldMatrix<BigFraction> createH(double d)\n+            throws MathArithmeticException {\n+\n+        int n = this.n;\n+        int k = (int) Math.ceil(n * d);\n+        \n+        int m = 2 * k - 1;\n+        double hDouble = k - n * d;\n+\n+        if (hDouble >= 1) {\n+            throw new ArithmeticException(\"Could not \");\n+        }\n+        \n+        BigFraction h = null;\n+\n+        try {\n+            h = new BigFraction(hDouble, 1.0e-20, 10000);\n+        } catch (FractionConversionException e1) {\n+            try {\n+                h = new BigFraction(hDouble, 1.0e-10, 10000);\n+            } catch (FractionConversionException e2) {\n+                try {\n+                    h = new BigFraction(hDouble, 1.0e-5, 10000);\n+                } catch (FractionConversionException e3) {\n+                    //throw new MathArithmeticException(hDouble, 10000);\n+                    throw new MathArithmeticException(LocalizedFormats.CANNOT_CONVERT_OBJECT_TO_FRACTION, hDouble);\n+                }\n+            }\n+        }\n+\n+        final BigFraction[][] Hdata = new BigFraction[m][m];\n+\n+        /*\n+         * Start by filling everything with either 0 or 1.\n+         */\n+        for (int i = 0; i < m; ++i) {\n+            for (int j = 0; j < m; ++j) {\n+                if (i - j + 1 < 0)\n+                    Hdata[i][j] = BigFraction.ZERO;\n+                else\n+                    Hdata[i][j] = BigFraction.ONE;\n+            }\n+        }\n+\n+        /*\n+         * Setting up power-array to avoid calculating the same value twice:\n+         * hPowers[0] = h^1 ... hPowers[m-1] = h^m\n+         */\n+        final BigFraction[] hPowers = new BigFraction[m];\n+        hPowers[0] = h;\n+        for (int i = 1; i < m; ++i) {\n+            hPowers[i] = h.multiply(hPowers[i - 1]);\n+        }\n+\n+        /*\n+         * First column and last row has special values (each other reversed).\n+         */\n+        for (int i = 0; i < m; ++i) {\n+            Hdata[i][0] = Hdata[i][0].subtract(hPowers[i]);\n+            Hdata[m - 1][i] = Hdata[m - 1][i].subtract(hPowers[m - i - 1]);\n+        }\n+\n+        /*\n+         * [1] states: \"For 1/2 < h < 1 the bottom left element of the matrix\n+         * should be (1 - 2*h^m + (2h - 1)^m )/m!\" Since 0 <= h < 1, then if h >\n+         * 1/2 is sufficient to check:\n+         */\n+        if (h.compareTo(BigFraction.ONE_HALF) == 1) {\n+            Hdata[m - 1][0] = Hdata[m - 1][0].add(h.multiply(2).subtract(1)\n+                    .pow(m));\n+        }\n+\n+        /*\n+         * Aside from the first column and last row, the (i, j)-th element is\n+         * 1/(i - j + 1)! if i \u2212 j + 1 >= 0, else 0. 1's and 0's are already\n+         * put, so only division with (i - j + 1)! is needed in the elements\n+         * that have 1's. There is no need to calculate (i - j + 1)! and then\n+         * divide - small steps avoid overflows.\n+         * \n+         * Note that i - j + 1 > 0 <=> i + 1 > j instead of j'ing all the way to\n+         * m. Also note that it is started at g = 2 because dividing by 1 isn't\n+         * really necessary.\n+         */\n+        for (int i = 0; i < m; ++i) {\n+            for (int j = 0; j < i + 1; ++j) {\n+                if (i - j + 1 > 0) {\n+                    for (int g = 2; g <= i - j + 1; ++g) {\n+                        Hdata[i][j] = Hdata[i][j].divide(g);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<BigFraction>(Hdata);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for {@link KolmogorovSmirnovDistributionImpl}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class KolmogorovSmirnovDistributionTest extends TestCase {\n+    \n+    private static final double TOLERANCE = 10e-10;\n+\n+    public void testCumulativeDensityFunction() throws Exception {\n+        \n+        KolmogorovSmirnovDistributionImpl dist;\n+        \n+        /* The code below is generated using the R-script located in\n+         * /src/test/R/KolmogorovSmirnovDistributionTestCases.R\n+         */\n+        \n+        /* R version 2.11.1 (2010-05-31) */\n+\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.005), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n+         * 4.907829957616471622388047046469198862537e-86\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        assertEquals(4.907829957616471622388047046469198862537e-86, dist.cdf(0.005, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.02), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n+         * 5.151982014280041957199687829849210629618e-06\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        assertEquals(5.151982014280041957199687829849210629618e-06, dist.cdf(0.02, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.031111), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.01291614648162886340443389343590752105229\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        assertEquals(0.01291614648162886340443389343590752105229, dist.cdf(0.031111, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.04), n = as.integer(200), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.1067137011362679355208626930107129737735\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(200);\n+        assertEquals(0.1067137011362679355208626930107129737735, dist.cdf(0.04, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.005), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n+         * 1.914734701559404553985102395145063418825e-53\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        assertEquals(1.914734701559404553985102395145063418825e-53, dist.cdf(0.005, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.02), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.001171328985781981343872182321774744195864\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        assertEquals(0.001171328985781981343872182321774744195864, dist.cdf(0.02, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.031111), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.1142955196267499418105728636874118819833\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        assertEquals(0.1142955196267499418105728636874118819833, dist.cdf(0.031111, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.04), n = as.integer(341), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.3685529520496805266915885113121476024389\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(341);\n+        assertEquals(0.3685529520496805266915885113121476024389, dist.cdf(0.04, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.005), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n+         * 1.810657144595055888918455512707637574637e-47\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        assertEquals(1.810657144595055888918455512707637574637e-47, dist.cdf(0.005, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.02), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.003068542559702356568168690742481885536108\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        assertEquals(0.003068542559702356568168690742481885536108, dist.cdf(0.02, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.031111), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.1658291700122746237244797384846606291831\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        assertEquals(0.1658291700122746237244797384846606291831, dist.cdf(0.031111, false), TOLERANCE);\n+\n+        /* formatC(.C(\"pkolmogorov2x\", p = as.double(0.04), n = as.integer(389), PACKAGE = \"stats\")$p, 40) gives\n+         * 0.4513143712128902529379104180407011881471\n+         */\n+        dist = new KolmogorovSmirnovDistributionImpl(389);\n+        assertEquals(0.4513143712128902529379104180407011881471, dist.cdf(0.04, false), TOLERANCE);\n+\n+    }\n+\n+}", "timestamp": 1300700363, "metainfo": ""}