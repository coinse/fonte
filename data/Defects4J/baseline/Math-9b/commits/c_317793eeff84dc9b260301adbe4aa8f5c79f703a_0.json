{"sha": "317793eeff84dc9b260301adbe4aa8f5c79f703a", "log": "Prevent infinite loops in multi-directional direct optimization method when the start point is exactly at the optimal point JIRA: MATH-283  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n /** \n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n+        final RealConvergenceChecker checker = getConvergenceChecker();\n         while (true) {\n \n             incrementIterationsCounter();\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n+                return;\n+            }\n+\n+            // check convergence\n+            final int iter = getIterations();\n+            boolean converged = true;\n+            for (int i = 0; i < simplex.length; ++i) {\n+                converged &= checker.converged(iter, original[i], simplex[i]);\n+            }\n+            if (converged) {\n                 return;\n             }\n \n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n-\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n-\n-public class MultiDirectionalTest\n-  extends TestCase {\n-\n-  public MultiDirectionalTest(String name) {\n-    super(name);\n-  }\n-\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MultiDirectionalTest {\n+\n+  @Test\n   public void testFunctionEvaluationExceptions() {\n       MultivariateRealFunction wrong =\n           new MultivariateRealFunction() {\n       try {\n           MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { -1.0 });\n-          fail(\"an exception should have been thrown\");\n+          Assert.fail(\"an exception should have been thrown\");\n       } catch (FunctionEvaluationException ce) {\n           // expected behavior\n-          assertNull(ce.getCause());\n+          Assert.assertNull(ce.getCause());\n       } catch (Exception e) {\n-          fail(\"wrong exception caught: \" + e.getMessage());\n+          Assert.fail(\"wrong exception caught: \" + e.getMessage());\n       } \n       try {\n           MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n-          fail(\"an exception should have been thrown\");\n+          Assert.fail(\"an exception should have been thrown\");\n       } catch (FunctionEvaluationException ce) {\n           // expected behavior\n-          assertNotNull(ce.getCause());\n+          Assert.assertNotNull(ce.getCause());\n       } catch (Exception e) {\n-          fail(\"wrong exception caught: \" + e.getMessage());\n+          Assert.fail(\"wrong exception caught: \" + e.getMessage());\n       } \n   }\n \n+  @Test\n   public void testMinimizeMaximize()\n       throws FunctionEvaluationException, ConvergenceException {\n \n       };\n \n       MultiDirectional optimizer = new MultiDirectional();\n-      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-30));\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n       optimizer.setMaxIterations(200);\n       optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n       RealPointValuePair optimum;\n \n       // minimization\n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n-      assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\n-      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n-      assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\n-      assertTrue(optimizer.getEvaluations() > 120);\n-      assertTrue(optimizer.getEvaluations() < 150);\n+      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\n+      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n+      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\n+      Assert.assertTrue(optimizer.getEvaluations() > 120);\n+      Assert.assertTrue(optimizer.getEvaluations() < 150);\n \n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n-      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n-      assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n-      assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n-      assertTrue(optimizer.getEvaluations() > 120);\n-      assertTrue(optimizer.getEvaluations() < 150);\n+      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n+      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n+      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n+      Assert.assertTrue(optimizer.getEvaluations() > 120);\n+      Assert.assertTrue(optimizer.getEvaluations() < 150);\n \n       // maximization\n       optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n-      assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\n-      assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\n-      assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\n-      assertTrue(optimizer.getEvaluations() > 120);\n-      assertTrue(optimizer.getEvaluations() < 150);\n-\n+      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\n+      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\n+      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\n+      Assert.assertTrue(optimizer.getEvaluations() > 120);\n+      Assert.assertTrue(optimizer.getEvaluations() < 150);\n+\n+      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n       optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n-      assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n-      assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n-      assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\n-      assertTrue(optimizer.getEvaluations() > 120);\n-      assertTrue(optimizer.getEvaluations() < 150);\n-\n-  }\n-\n+      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n+      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n+      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\n+      Assert.assertTrue(optimizer.getEvaluations() > 180);\n+      Assert.assertTrue(optimizer.getEvaluations() < 220);\n+\n+  }\n+\n+  @Test\n   public void testRosenbrock()\n     throws FunctionEvaluationException, ConvergenceException {\n \n     RealPointValuePair optimum =\n         optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n-    assertEquals(count, optimizer.getEvaluations());\n-    assertTrue(optimizer.getEvaluations() > 70);\n-    assertTrue(optimizer.getEvaluations() < 100);\n-    assertTrue(optimum.getValue() > 1.0e-2);\n-\n-  }\n-\n+    Assert.assertEquals(count, optimizer.getEvaluations());\n+    Assert.assertTrue(optimizer.getEvaluations() > 50);\n+    Assert.assertTrue(optimizer.getEvaluations() < 100);\n+    Assert.assertTrue(optimum.getValue() > 1.0e-2);\n+\n+  }\n+\n+  @Test\n   public void testPowell()\n     throws FunctionEvaluationException, ConvergenceException {\n \n     optimizer.setMaxIterations(1000);\n     RealPointValuePair optimum =\n       optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n-    assertEquals(count, optimizer.getEvaluations());\n-    assertTrue(optimizer.getEvaluations() > 800);\n-    assertTrue(optimizer.getEvaluations() < 900);\n-    assertTrue(optimum.getValue() > 1.0e-2);\n-\n-  }\n-\n-  public static Test suite() {\n-    return new TestSuite(MultiDirectionalTest.class);\n+    Assert.assertEquals(count, optimizer.getEvaluations());\n+    Assert.assertTrue(optimizer.getEvaluations() > 800);\n+    Assert.assertTrue(optimizer.getEvaluations() < 900);\n+    Assert.assertTrue(optimum.getValue() > 1.0e-2);\n+\n+  }\n+\n+  @Test\n+  public void testMath283()\n+      throws FunctionEvaluationException, OptimizationException {\n+      // fails because MultiDirectional.iterateSimplex is looping forever\n+      // the while(true) should be replaced with a convergence check\n+      MultiDirectional multiDirectional = new MultiDirectional();\n+      multiDirectional.setMaxIterations(100);\n+      multiDirectional.setMaxEvaluations(1000);\n+\n+      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n+\n+      RealPointValuePair estimate = multiDirectional.optimize(function,\n+                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n+\n+      final double EPSILON = 1e-5;\n+\n+      final double expectedMaximum = function.getMaximum();\n+      final double actualMaximum = estimate.getValue();\n+      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);\n+\n+      final double[] expectedPosition = function.getMaximumPosition();\n+      final double[] actualPosition = estimate.getPoint();\n+      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );\n+      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n+      \n+  }\n+\n+  private static class Gaussian2D implements MultivariateRealFunction {\n+\n+      private final double[] maximumPosition;\n+\n+      private final double std;\n+      \n+      public Gaussian2D(double xOpt, double yOpt, double std) {\n+          maximumPosition = new double[] { xOpt, yOpt };\n+          this.std = std;\n+      }\n+\n+      public double getMaximum() {\n+          return value(maximumPosition);\n+      }\n+\n+      public double[] getMaximumPosition() {\n+          return maximumPosition.clone();\n+      }\n+\n+      public double value(double[] point) {\n+          final double x = point[0], y = point[1];\n+          final double twoS2 = 2.0 * std * std;\n+          return 1.0 / (twoS2 * Math.PI) * Math.exp(-(x * x + y * y) / twoS2);\n+      }\n   }\n \n   private int count;", "timestamp": 1250277807, "metainfo": ""}