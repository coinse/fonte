{"sha": "d6ddfb5701aa6d425e20f04ac48d64e4eda2e45c", "log": "MATH-707 Renamed \"SimpleVectorialValueChecker\" to \"SimpleVectorValueChecker\".   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Simple implementation of the {@link ConvergenceChecker} interface using\n+ * only objective function values.\n+ *\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold for all vectors elements.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class SimpleVectorValueChecker\n+    extends AbstractConvergenceChecker<PointVectorValuePair> {\n+    /**\n+     * Build an instance with default thresholds.\n+     */\n+    public SimpleVectorValueChecker() {}\n+\n+    /**\n+     * Build an instance with specified thresholds.\n+     *\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     *\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleVectorValueChecker(final double relativeThreshold,\n+                                       final double absoluteThreshold) {\n+        super(relativeThreshold, absoluteThreshold);\n+    }\n+\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n+     * @return {@code true} if the algorithm has converged.\n+     */\n+    @Override\n+    public boolean converged(final int iteration,\n+                             final PointVectorValuePair previous,\n+                             final PointVectorValuePair current) {\n+        final double[] p = previous.getValueRef();\n+        final double[] c = current.getValueRef();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double pi         = p[i];\n+            final double ci         = c[i];\n+            final double difference = FastMath.abs(pi - ci);\n+            final double size       = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n+            if (difference > size * getRelativeThreshold() &&\n+                difference > getAbsoluteThreshold()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n  * user should provide a class implementing this interface to allow the optimization\n  * algorithm to stop its search according to the problem at hand.</p>\n  * <p>For convenience, two implementations that fit simple needs are already provided:\n- * {@link SimpleVectorialValueChecker} and {@link SimplePointChecker<PointVectorValuePair>}. The first\n+ * {@link SimpleVectorValueChecker} and {@link SimplePointChecker<PointVectorValuePair>}. The first\n  * one considers convergence is reached when the objective function value does not\n  * change much anymore, it does not use the point set at all. The second one\n  * considers convergence is reached when the input point set does not change\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java\n import org.apache.commons.math.optimization.BaseMultivariateVectorOptimizer;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.PointVectorValuePair;\n-import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.SimpleVectorValueChecker;\n \n /**\n  * Base class for implementing optimizers for multivariate scalar functions.\n \n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link SimpleVectorialValueChecker} and\n+     * The convergence check is set to a {@link SimpleVectorValueChecker} and\n      * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n      */\n     protected BaseAbstractMultivariateVectorOptimizer() {\n-        this(new SimpleVectorialValueChecker());\n+        this(new SimpleVectorValueChecker());\n     }\n     /**\n      * @param checker Convergence checker.\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n     /**\n      * Simple constructor with default settings.\n      * The convergence check is set to a {@link\n-     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}.\n+     * org.apache.commons.math.optimization.SimpleVectorValueChecker}.\n      */\n     protected AbstractLeastSquaresOptimizer() {}\n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.SimpleVectorValueChecker;\n import org.apache.commons.math.optimization.PointVectorValuePair;\n \n /**\n     /**\n      * Simple constructor with default settings.\n      * The normal equations will be solved using LU decomposition and the\n-     * convergence check is set to a {@link SimpleVectorialValueChecker}\n+     * convergence check is set to a {@link SimpleVectorValueChecker}\n      * with default tolerances.\n      */\n     public GaussNewtonOptimizer() {\n \n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link SimpleVectorialValueChecker}\n+     * The convergence check is set to a {@link SimpleVectorValueChecker}\n      * with default tolerances.\n      *\n      * @param useLU If {@code true}, the normal equations will be solved\n      * decomposition.\n      */\n     public GaussNewtonOptimizer(final boolean useLU) {\n-        this(useLU, new SimpleVectorialValueChecker());\n+        this(useLU, new SimpleVectorValueChecker());\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorMultiStartOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorMultiStartOptimizerTest.java\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         DifferentiableMultivariateVectorOptimizer underlyingOptimizer =\n             new GaussNewtonOptimizer(true,\n-                                     new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+                                     new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(16069223052l);\n         RandomVectorGenerator generator =\n     public void testNoOptimum() {\n         DifferentiableMultivariateVectorOptimizer underlyingOptimizer =\n             new GaussNewtonOptimizer(true,\n-                                     new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+                                     new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(12373523445l);\n         RandomVectorGenerator generator =\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.SimpleVectorValueChecker;\n import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n                               new double[] { 4.0, 6.0, 1.0 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n         }, new double[] { 1, 1, 1});\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n         }, new double[] { 1, 1, 1 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n     }\n         }, new double[] { 32, 23, 33, 31 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum1 =\n             optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n         }, new double[] { 7.0, 3.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                            new double[] { 7, 6, 5, 4 });\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n                            new double[] { 2, 2, 2, 2, 2, 2 });\n         }, new double[] { 3.0, 1.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n         }, new double[] { 3.0, 1.0, 4.0 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n         Assert.assertTrue(optimizer.getRMS() > 0.1);\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n         circle.addPoint( 45.0,  97.0);\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-30, 1.0e-30));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-30, 1.0e-30));\n \n         optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n                            new double[] { 1, 1, 1, 1, 1 },\n         circle.addPoint( 45.0,  97.0);\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-13, 1.0e-13));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n         }\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n     }\n         }\n \n         GaussNewtonOptimizer optimizer\n-            = new GaussNewtonOptimizer(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+            = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6));\n \n         PointVectorValuePair optimum =\n             optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 });\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.SingularMatrixException;\n-import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.SimpleVectorValueChecker;\n import org.apache.commons.math.optimization.PointVectorValuePair;\n import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n             circle.addPoint(points[i][0], points[i][1]);\n         }\n         LevenbergMarquardtOptimizer optimizer\n-            = new LevenbergMarquardtOptimizer(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));\n+            = new LevenbergMarquardtOptimizer(new SimpleVectorValueChecker(1.0e-8, 1.0e-8));\n         PointVectorValuePair optimum =\n             optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);", "timestamp": 1329090228, "metainfo": ""}