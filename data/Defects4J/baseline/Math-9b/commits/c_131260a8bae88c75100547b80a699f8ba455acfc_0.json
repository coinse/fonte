{"sha": "131260a8bae88c75100547b80a699f8ba455acfc", "log": "New additions of CholeskySolver contributed by Stefan Koeberle   ", "commit": "\n--- /dev/null\n+++ b/src/experimental/org/apache/commons/math/linear/CholeskySolver.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Solves a linear equitation with symmetrical, positiv definit \n+ * coefficient matrix by Cholesky decomposition.\n+ * <p>\n+ * For every symmetric, positiv definit matrix <code>M</code> there is a\n+ * lower triangular matrix <code>L</code> so that <code>L*L^T=M</code>. \n+ * <code>L</code> is called the <i>Cholesky decomposition</i> of <code>M</code>.  \n+ * For any constant vector <code>c</code> it can be used to solve \n+ * the linear equitation <code>M*x=L*(L^T*x)=c</code>.<br>\n+ * Compared to the LU-decompoistion the Cholesky methods requires only half \n+ * the number of operations.\n+ * <p>\n+ * @author Stefan Koeberle, 11/2003\n+ */\n+public class CholeskySolver {\n+    \n+    private double numericalZero = 10E-12;\n+    \n+    /** The lower triangular matrix */\n+    private RealMatrixImpl decompMatrix;\n+    \n+   \n+    /** \n+     * Creates a new instance of CholeskySolver\n+     */\n+    public CholeskySolver() {\n+    }//constructor CholeskySolver\n+    \n+    \n+    /** \n+     * Every double <code>d</code> satisfying \n+     * <code>java.lang.Math.abs(d) <= numericalZero</code> \n+     * is considered equal to <code>0.0d.</code>\n+     */\n+    public void setNumericalZero(double numericalZero) {\n+        this.numericalZero = numericalZero;\n+    }//setNumericalZero\n+    \n+    /**\n+     * See <code>setNumericalZero</code>\n+     */\n+    public double getNumericalZero() {\n+        return numericalZero;\n+    }//getNumericalZero\n+    \n+    \n+    /**\n+     * Calculates the Cholesky-decomposition of the symmetrical, positiv definit \n+     * matrix <code>M</code>.\n+     * <p>\n+     * The decomposition matrix is internally stored.\n+     * <p>\n+     * @throws IllegalArgumentException   if <code>M</code> ist not square or \n+     *                                    not positiv definit\n+     */\n+    public void decompose(RealMatrix m) \n+    throws IllegalArgumentException {\n+       \n+       decompMatrix = null;\n+       double[][] mval = m.getData();\n+       int numRows = m.getRowDimension();\n+       int numCols = m.getColumnDimension();\n+       if (numRows != numCols) \n+           throw new IllegalArgumentException(\"matrix is not square\"); \n+       double[][] decomp = new double[numRows][numCols];       \n+       double sum;\n+       \n+       //for all columns\n+       for (int col=0; col<numCols; col++) {\n+          \n+           //diagonal element\n+           sum = mval[col][col];\n+           for (int k=0; k<col; k++) \n+               sum = sum - decomp[col][k]*decomp[col][k];\n+           if (sum <= numericalZero) {\n+               throw new IllegalArgumentException(\n+                             \"Matrix is not positiv definit\");\n+           }\n+           decomp[col][col] += Math.sqrt(sum);\n+           \n+           //column below diagonal\n+           for (int row=col+1; row<numRows; row++) {\n+               sum = mval[row][col];\n+               for (int k=0; k<col; k++) \n+                   sum = sum - decomp[col][k]*decomp[row][k];\n+               decomp[row][col] = sum/decomp[col][col]; \n+           }//for\n+           \n+       }//for all columns\n+       \n+       decompMatrix = new RealMatrixImpl(decomp);\n+       \n+    }//decompose\n+    \n+    \n+    /**\n+     * Returns the last calculated decomposition matrix.\n+     * <p>\n+     * Caution: Every call of this Method will return the same object.\n+     * Decomposing another matrix will generate a new one.\n+     */\n+    public RealMatrixImpl getDecomposition() {\n+        return decompMatrix;\n+    }//getDecomposition\n+    \n+    \n+    /**\n+     * Returns the solution for a linear system with constant vector <code>c</code>. \n+     * <p>\n+     * This method solves a linear system <code>M*x=c</code> for a symmetrical,\n+     * positiv definit coefficient matrix <code>M</code>. Before using this \n+     * method the matrix <code>M</code> must have been decomposed.\n+     * <p>\n+     * @throws IllegalStateException    if this methode is called before \n+     *                                  a matrix was decomposed\n+     * @throws IllegalArgumentException if the dimension of <code>c</code> doesn't\n+     *                                  match the row dimension of <code>M</code>\n+     */    \n+    public double[] solve(double[] c) \n+    throws IllegalStateException, IllegalArgumentException {\n+      \n+        if (decompMatrix == null) {\n+            throw new IllegalStateException(\"no decomposed matrix available\");\n+        }//if\n+        if (decompMatrix.getColumnDimension() != c.length) \n+           throw new IllegalArgumentException(\"matrix dimension mismatch\"); \n+       \n+        double[][] decomp = decompMatrix.getData();\n+        double[] x = new double[decomp.length];\n+        double sum;\n+        \n+        //forward elimination\n+        for (int i=0; i<x.length; i++) {\n+            sum = c[i];\n+            for (int k=0; k<i; k++) \n+                sum = sum - decomp[i][k]*x[k];\n+            x[i] = sum / decomp[i][i];\n+        }//forward elimination\n+        \n+        //backward elimination\n+        for (int i=x.length-1; i>=0; i--) {\n+            sum = x[i];\n+            for (int k=i+1; k<x.length; k++) \n+                sum = sum - decomp[k][i]*x[k];        \n+            x[i] = sum / decomp[i][i];\n+        }//backward elimination\n+        \n+        return x;\n+    }//solve\n+    \n+    \n+    /**\n+     * Returns the solution for a linear system with a symmetrical, \n+     * positiv definit coefficient matrix <code>M</code> and \n+     * constant vector <code>c</code>. \n+     * <p>\n+     * As a side effect, the Cholesky-decomposition <code>L*L^T=M</code> is \n+     * calculated and internally stored.\n+     * <p>\n+     * This is a convenience method for <code><pre>\n+     *   solver.decompose(m);\n+     *   solver.solve(c);\n+     * </pre></code>\n+     * @throws IllegalArgumentException if M ist not square, not positive definit\n+     *                                  or the dimensions of <code>M</code> and \n+     *                                  <code>c</code> don't match.                     \n+     */\n+    public double[] solve(RealMatrix m, double[] c) \n+    throws IllegalArgumentException {\n+        decompose(m);\n+        return solve(c);\n+    }//solve \n+    \n+    \n+    /**\n+     * Returns the determinant of the a matrix <code>M</code>.\n+     * <p>\n+     * Before using this  method the matrix <code>M</code> must \n+     * have been decomposed. \n+     * <p>\n+     * @throws IllegalStateException  if this method is called before \n+     *                                a matrix was decomposed\n+     */\n+    public double getDeterminant() {\n+        \n+        if (decompMatrix == null) {\n+            throw new IllegalStateException(\"no decomposed matrix available\");\n+        }//if\n+        \n+        double[][] data = decompMatrix.getData();\n+        double res = 1.0d; \n+        for (int i=0; i<data.length; i++) {\n+            res *= data[i][i];\n+        }//for\n+        res = res*res;\n+        \n+        return res;\n+    }//getDeterminant\n+    \n+}//class CholeskySolver\n--- /dev/null\n+++ b/src/experimental/org/apache/commons/math/linear/CholeskySolverTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test cases for the {@link CholeskySolver} class.\n+ * <p>\n+ * @author Stefan Koeberle, 11/2003\n+ */\n+public class CholeskySolverTest \n+extends TestCase {\n+    \n+        private double[][] m1 = {{1}};\n+        private double m1Det = 1.0d;\n+        \n+        private double[][] m2 = {{1, 0} , \n+                                 {0, 2}};\n+        private double m2Det = 2.0d;                                 \n+        \n+        private double[][] m3 = {{1, 0, 0}, \n+                                 {0, 2, 0}, \n+                                 {0, 0, 3}};\n+        private double m3Det = 6.0d;\n+                                 \n+        private double[][] m4 = {{1, 0, 0}, \n+                                 {2, 3, 0}, \n+                                 {4, 5, 6}};\n+        private double m4Det = 18.0d;\n+        \n+        private double[][] m5 = {{ 1,  0,  0,  0,  0}, \n+                                 {-2,  3,  0,  0,  0}, \n+                                 { 4, -5,  6,  0,  0},\n+                                 { 7,  8, -9, 10,  0},\n+                                 {11, 12, 13, 14, 15}};\n+        private double m5Det = 2700.0d;\n+\n+                                 \n+        private double[][] m6 = {{1, 0,  0}, \n+                                 {2, 0,  0}, \n+                                 {4, 5,  6}};\n+        \n+        private double[][] m7 = {{1, 2, 3}, \n+                                 {4, 5, 6}};  \n+                              \n+    /** \n+     * Creates a new instance of CholeskySolverTest \n+     */\n+    public CholeskySolverTest(String nameOfTest) {\n+        super(nameOfTest);\n+    }//constructor CholeskySolverTest\n+    \n+    public void setUp() \n+    throws java.lang.Exception { \n+       super.setUp();\n+    }//setUp\n+    \n+   \n+    public void tearDown() \n+    throws java.lang.Exception {\n+        super.tearDown();\n+    }//tearDown\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(CholeskySolverTest.class);\n+        suite.setName(\"CholeskySolver Tests\");\n+        return suite;\n+    }//suite\n+\n+    \n+    /** \n+     * tests CholeskySolver.setNumericalZero() \n+     */   \n+    public void testNumericalZero() {\n+        CholeskySolver solver = new CholeskySolver();\n+        double numericalZero = 77.77d;\n+        solver.setNumericalZero(numericalZero);\n+        assertEquals(solver.getNumericalZero(), numericalZero, 0.0d);\n+        \n+        try {\n+            solver.decompose(\n+                new RealMatrixImpl(new double[][]{{numericalZero/2, 0},\n+                                                  {0, numericalZero/2}}));\n+            fail(\"testing numericalZero\");\n+        } catch (IllegalArgumentException e) {}\n+        \n+    }//testNumericalZero\n+    \n+    \n+    /** \n+     * tests CholeskySolver.decompose(...) \n+     */\n+    public void testDecompose() {\n+        \n+        //The following decompositions should succeed.\n+        testDecompose(m1, \"Decomposing matrix m1\");\n+        testDecompose(m2, \"Decomposing matrix m2\");\n+        testDecompose(m3, \"Decomposing matrix m3\");\n+        testDecompose(m4, \"Decomposing matrix m4\");\n+        testDecompose(m5, \"Decomposing matrix m5\");\n+        \n+        //The following decompositions will fail. An IllegalArgumentException\n+        //should be thrown.\n+        try {\n+            testDecompose(m6, \"Decomposing matrix m6\");\n+            fail(\"Decomposing matrix m6\"); \n+        } catch (IllegalArgumentException e) {}\n+        \n+         try {\n+             CholeskySolver solver = new CholeskySolver();\n+             solver.decompose(new RealMatrixImpl(m7));\n+             fail(\"Decomposing matrix m7\"); \n+        } catch (IllegalArgumentException e) {}\n+        \n+    }//testDecomposition\n+    \n+    \n+    /** \n+     * tests CholeskySolver.solve(...) \n+     */\n+    public void testSolve() {\n+\n+        //If there's no matrix, there's no linear euqitation to solve ...\n+        try {\n+             CholeskySolver solver = new CholeskySolver();\n+             solver.solve(new double[] {1,2,3});\n+             fail(\"solving a liniar equitation with a missing matrix should fail\"); \n+        } catch (IllegalStateException e) {}\n+\n+        //The following operations should succeed.\n+        testSolve(m1, \"Solving matrix m1\");  \n+        testSolve(m2, \"Solving matrix m2\");\n+        testSolve(m3, \"Solving matrix m3\");\n+        testSolve(m4, \"Solving matrix m4\");\n+        testSolve(m5, \"Solving matrix m5\");\n+     \n+        //The following operations will fail. An IllegalArgumentException\n+        //should be thrown.\n+        try {\n+          testSolve(m6, \"Solving matrix m6\");\n+          fail(\"Solving matrix m6\"); \n+        } catch (IllegalArgumentException e) {}\n+\n+         try {\n+             CholeskySolver solver = new CholeskySolver();\n+             solver.solve(new RealMatrixImpl(m3), new double[] {1, 2, 3, 4});\n+             fail(\"Solving matrix m3[3x3], v[4]\"); \n+        } catch (IllegalArgumentException e) {}\n+        \n+    }//testDecomposition\n+    \n+    \n+    /** \n+     * tests CholeskySolver.getDeterminant(...) \n+     */\n+    public void testGetDeterminant() {\n+        \n+        //Since no matrix was decomposed, there's no determinant.\n+        try {\n+             CholeskySolver solver = new CholeskySolver();\n+             solver.getDeterminant();\n+             fail(\"Calculating determinant of missing matrix should fail\"); \n+        } catch (IllegalStateException e) {}\n+       \n+        //These test will suceed.\n+        testGetDeterminant(m1, m1Det, \"Calculating determinant of m1\");\n+        testGetDeterminant(m2, m2Det, \"Calculating determinant of m2\");\n+        testGetDeterminant(m3, m3Det, \"Calculating determinant of m3\");\n+        testGetDeterminant(m4, m4Det, \"Calculating determinant of m4\");\n+        testGetDeterminant(m5, m5Det, \"Calculating determinant of m5\");\n+    }//test\n+    \n+    \n+    /**\n+     * Generates the matrix \n+     * <code>m = lowerTriangularMatrix * lowerTriangularMatrix^T</code>.\n+     * If alle diagonalelements of <code>lowerTriangularMatrix</code> are\n+     * positiv, <code>m</code> will be positiv definit. \n+     * Decomposing <code>m</code> should result in\n+     * <code>lowerTriangularMatrix</code> again. So there's a simple test ...\n+     */\n+    private void testDecompose(double[][] lowerTriangularMatrix, String message) \n+    throws IllegalArgumentException {\n+    \n+        RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);\n+        RealMatrix pdMatrix = \n+            triangularMatrix.multiply(triangularMatrix.transpose());\n+        \n+        CholeskySolver solver = new CholeskySolver();\n+        solver.decompose(pdMatrix);\n+        \n+        assertTrue(message, \n+            areEqual(triangularMatrix, solver.getDecomposition(), 1.0E-10));\n+    \n+    }//testDecompose\n+  \n+    \n+    /**\n+     * Similar to <code> private testDecompose(...)</code>.\n+     */\n+    private void testSolve(double[][] lowerTriangularMatrix, String message)  {\n+      \n+        RealMatrix triangularMatrix = \n+            new RealMatrixImpl(lowerTriangularMatrix);\n+        RealMatrixImpl pdMatrix = \n+            (RealMatrixImpl) triangularMatrix.multiply(triangularMatrix.transpose());\n+        CholeskySolver solver = \n+            new CholeskySolver();\n+        \n+        double[] c = new double[lowerTriangularMatrix.length];\n+        for (int i=0; i<c.length; i++) \n+            for (int j=0; j<lowerTriangularMatrix[0].length; j++) \n+                c[i] += lowerTriangularMatrix[i][j];\n+        \n+        solver.decompose(pdMatrix);\n+        RealMatrix x = new RealMatrixImpl(solver.solve(c));\n+\n+        assertTrue(message, \n+            areEqual(pdMatrix.multiply(x),  new RealMatrixImpl(c), 1.0E-10));\n+    }//testSolve\n+\n+    \n+    /**\n+     * Similar to <code> private testDecompose(...)</code>.\n+     */\n+    private void testGetDeterminant(double[][] lowerTriangularMatrix, \n+                                    double determinant,\n+                                    String message) \n+    throws IllegalArgumentException {\n+    \n+        RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);\n+        RealMatrix pdMatrix = \n+            triangularMatrix.multiply(triangularMatrix.transpose());\n+        double pdDeterminant = determinant * determinant;\n+        \n+        CholeskySolver solver = new CholeskySolver();\n+        solver.decompose(pdMatrix);\n+        assertEquals(message, solver.getDeterminant(), pdDeterminant, 1.0E-10);\n+    }//testGetDeterminant\n+    \n+    \n+    /**\n+     * Are <code>m1</code> and <code>m2</code> equal?\n+     */\n+    private static boolean areEqual(RealMatrix m1, RealMatrix m2, double delta) {\n+        \n+        double[][] mv1 = m1.getData();\n+        double[][] mv2 = m2.getData();\n+        \n+        if (mv1.length != mv1.length  ||\n+            mv1[0].length != mv2[0].length) \n+            return false;\n+        \n+        for (int i=0; i<mv1.length; i++) \n+            for (int j=0; j<mv1[0].length; j++) \n+                if (Math.abs(mv1[i][j] -mv2[i][j]) > delta) \n+                    return false;\n+        \n+        return true;\n+    }//isEqual\n+ \n+     \n+    /**\n+     * Executes all tests of this class\n+     */\n+    public static void main(String[] args) {\n+        System.out.println(\"Start\");\n+        TestRunner runner = new TestRunner();\n+        runner.doRun(CholeskySolverTest.suite());\n+        System.out.println(\"End\");\n+    }//main\n+    \n+}//class CholeskySolverTest", "timestamp": 1069617220, "metainfo": ""}