{"sha": "de2c98de19f797d87ba76feee07b67a1cbcbbd67", "log": "MATH-632 Added explicit note on the different behaviors for NaN values between Java and IEEE-754.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n /**\n  * Representation of a Complex number, i.e. a number which has both a\n  * real and imaginary part.\n+ * <br/>\n  * Implementations of arithmetic operations handle {@code NaN} and\n- * infinite values according to the rules for {@link java.lang.Double}\n- * arithmetic, applying definitional formulas and returning {@code NaN} or\n- * infinite values in real or imaginary parts as these arise in computation.\n- * See individual method javadocs for details.\n+ * infinite values according to the rules for {@link java.lang.Double}, i.e.\n+ * {@link #equals} is an equivalence relation for all instances that have\n+ * a {@code NaN} in either real or imaginary part, e.g. the following are\n+ * considered equal:\n+ * <ul>\n+ *  <li>{@code 1 + NaNi}</li>\n+ *  <li>{@code NaN + i}</li>\n+ *  <li>{@code NaN + NaNi}</li>\n+ * </ul>\n+ * Note that this is in contradiction with the IEEE-754 standard for floating\n+ * point numbers (according to which the test {@code x == x} must fail if\n+ * {@code x} is {@code NaN}). The method\n+ * {@link MathUtils#equals(double,double,int) equals for primitive double} in\n+ * {@link MathUtils} conforms with IEEE-754 while this class conforms with\n+ * the standard behavior for Java object types.\n  * <br/>\n- * {@link #equals} identifies all values with {@code NaN} in either real\n- * or imaginary part, e.g.\n- * <pre>\n- *  {@code 1 + NaNi  == NaN + i == NaN + NaNi.}\n- * </pre>\n- *\n  * Implements Serializable since 2.0\n  *\n  * @version $Id$\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n         Assert.assertTrue(realNaN.equals(imaginaryNaN));\n         Assert.assertTrue(imaginaryNaN.equals(complexNaN));\n         Assert.assertTrue(realNaN.equals(complexNaN));\n-\n-        final double a = Double.NaN;\n-        final double b = Double.NaN;\n-        Assert.assertFalse(\"a == b\", a == b);\n-        Assert.assertEquals(\"a != b\", a, b, Double.MIN_VALUE);\n-        Assert.assertFalse(\"a == b\", MathUtils.equals(a, b));\n-        Assert.assertFalse(\"a == b\", MathUtils.equals(a, b, Double.MIN_VALUE));\n-        final Double dA = Double.valueOf(a);\n-        final Double dB = Double.valueOf(b);\n-        Assert.assertFalse(\"dA == dB\", dA.doubleValue() == dB.doubleValue());\n-        Assert.assertTrue(\"!dA.equals(dB)\", dA.equals(dB));\n-        final Complex cA = new Complex(a, 0);\n-        final Complex cB = new Complex(b, 0);\n-        Assert.assertTrue(\"!cA.equals(cB)\", cA.equals(cB));\n     }\n \n     @Test", "timestamp": 1312582051, "metainfo": ""}