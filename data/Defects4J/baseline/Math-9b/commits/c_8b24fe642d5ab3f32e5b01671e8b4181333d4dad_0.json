{"sha": "8b24fe642d5ab3f32e5b01671e8b4181333d4dad", "log": "Added Matrix-valued row, column, and subMatrix accessors as suggested by Kim van der Linde (Pr #30897). Implemented equals and hashcode. Modified toString() to handle empty matrix.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/BigMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrix.java\n  * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.\n  *\n- * @version $Revision: 1.7 $ $Date: 2004/09/05 01:19:23 $\n+ * @version $Revision: 1.8 $ $Date: 2004/10/25 02:21:20 $\n  */\n public interface BigMatrix {\n \n      * @return norm\n      */\n     BigDecimal getNorm();\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @return The subMatrix containing the data of the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+    BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n+            int endColumn) throws MatrixIndexException;\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @return The subMatrix containing the data in the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+    throws MatrixIndexException;\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be fetched\n+     * @return row matrix\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     */\n+    BigMatrix getRowMatrix(int row) throws MatrixIndexException;\n+    \n+    /**\n+     * Returns the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be fetched\n+     * @return column matrix\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     */\n+    BigMatrix getColumnMatrix(int column) throws MatrixIndexException;\n     \n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n  * As specified in the {@link BigMatrix} interface, matrix element indexing\n  * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.</li></ul>\n- * @version $Revision: 1.6 $ $Date: 2004/09/05 01:19:23 $\n+ * @version $Revision: 1.7 $ $Date: 2004/10/25 02:21:20 $\n  */\n public class BigMatrixImpl implements BigMatrix, Serializable {\n     \n             maxColSum = maxColSum.max(sum);\n         }\n         return maxColSum;\n+    }\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @return The subMatrix containing the data of the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n+            int endColumn) throws MatrixIndexException {\n+        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n+                startColumn < 0 || startColumn > endColumn ||\n+                endColumn > data[0].length ) {\n+            throw new MatrixIndexException(\n+            \"invalid row or column index selection\");\n+        }\n+        BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,\n+                endColumn - startColumn+1);\n+        BigDecimal[][] subMatrixData = subMatrix.getDataRef();\n+        for (int i = startRow; i <= endRow; i++) {\n+            for (int j = startColumn; j <= endColumn; j++) {\n+                subMatrixData[i - startRow][j - startColumn] = data[i][j];\n+            }\n+        }\n+        return subMatrix;\n+    }\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices must be non-empty\n+     * @param selectedColumns Array of column indices must be non-empty\n+     * @return The subMatrix containing the data in the\n+     *     specified rows and columns\n+     * @exception MatrixIndexException  if supplied row or column index arrays\n+     *     are not valid\n+     */\n+    public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+    throws MatrixIndexException {\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            throw new MatrixIndexException(\n+            \"selected row and column index arrays must be non-empty\");\n+        }\n+        BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,\n+                selectedColumns.length);\n+        BigDecimal[][] subMatrixData = subMatrix.getDataRef();\n+        try  {\n+            for (int i = 0; i < selectedRows.length; i++) {\n+                for (int j = 0; j < selectedColumns.length; j++) {\n+                    subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];\n+                }\n+            }\n+        }\n+        catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"matrix dimension mismatch\");\n+        }\n+        return subMatrix;\n+    } \n+    \n+    /**\n+     * Returns the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be fetched\n+     * @return row matrix\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     */\n+    public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n+        if ( !isValidCoordinate( row, 0)) {\n+            throw new MatrixIndexException(\"illegal row argument\");\n+        }\n+        int ncols = this.getColumnDimension();\n+        BigDecimal[][] out = new BigDecimal[1][ncols]; \n+        System.arraycopy(data[row], 0, out[0], 0, ncols);\n+        return new BigMatrixImpl(out);\n+    } \n+    \n+    /**\n+     * Returns the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be fetched\n+     * @return column matrix\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     */\n+    public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n+        if ( !isValidCoordinate( 0, column)) {\n+            throw new MatrixIndexException(\"illegal column argument\");\n+        }\n+        int nRows = this.getRowDimension();\n+        BigDecimal[][] out = new BigDecimal[nRows][1]; \n+        for (int row = 0; row < nRows; row++) {\n+            out[row][0] = data[row][column];\n+        }\n+        return new BigMatrixImpl(out);\n     }\n     \n     /**\n     public String toString() {\n         StringBuffer res = new StringBuffer();\n         res.append(\"BigMatrixImpl{\");\n-        for (int i = 0; i < data.length; i++) {\n-            if (i > 0)\n-                res.append(\",\");\n-            res.append(\"{\");\n-            for (int j = 0; j < data[0].length; j++) {\n-                if (j > 0)\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i > 0)\n                     res.append(\",\");\n-                res.append(data[i][j]);\n-            } //for\n-            res.append(\"}\");\n-        } //for\n+                res.append(\"{\");\n+                for (int j = 0; j < data[0].length; j++) {\n+                    if (j > 0)\n+                        res.append(\",\");\n+                    res.append(data[i][j]);\n+                } \n+                res.append(\"}\");\n+            } \n+        }\n         res.append(\"}\");\n         return res.toString();\n-    } //toString\n+    } \n+    \n+    /**\n+     * Returns true iff <code>object</code> is a \n+     * <code>BigMatrixImpl</code> instance with the same dimensions as this\n+     * and all corresponding matrix entries are equal.  BigDecimal.equals\n+     * is used to compare corresponding entries.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof BigMatrixImpl == false) {\n+            return false;\n+        }\n+        BigMatrix m = (BigMatrix) object;\n+        int nRows = getRowDimension();\n+        int nCols = getColumnDimension();\n+        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n+            return false;\n+        }\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                if (!data[row][col].equals(m.getEntry(row, col))) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Computes a hashcode for the matrix.\n+     * \n+     * @return hashcode for matrix\n+     */\n+    public int hashCode() {\n+        int ret = 7;\n+        int nRows = getRowDimension();\n+        int nCols = getColumnDimension();\n+        ret = ret * 31 + nRows;\n+        ret = ret * 31 + nCols;\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n+                data[row][col].hashCode();\n+            }\n+        }   \n+        return ret;\n+    }\n     \n     //------------------------ Protected methods\n     ", "timestamp": 1098670880, "metainfo": ""}