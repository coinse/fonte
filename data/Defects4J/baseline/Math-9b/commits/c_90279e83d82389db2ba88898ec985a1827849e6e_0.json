{"sha": "90279e83d82389db2ba88898ec985a1827849e6e", "log": "fixed errors with infinities added asin/acos  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n     private FastMath() {\n     }\n \n-    /** Compute the arc cosine of a number.\n-     * @param a number on which evaluation is done\n-     * @return arc cosine of a\n-     */\n-    public static double acos(final double a) {\n-        return Math.acos(a);\n-    }\n-\n-    /** Compute the arc sine of a number.\n-     * @param a number on which evaluation is done\n-     * @return arc sine of a\n-     */\n-    public static double asin(final double a) {\n-        return Math.asin(a);\n-    }\n-\n     /** Compute the square root of a number.\n      * @param a number on which evaluation is done\n      * @return square root of a\n             intVal = (int) -x;\n \n             if (intVal > 746) {\n+                if (hiPrec != null) {\n+                    hiPrec[0] = 0.0;\n+                    hiPrec[1] = 0.0;\n+                }\n                 return 0.0;\n             }\n \n             intVal = (int) x;\n \n             if (intVal > 709) {\n+                if (hiPrec != null) {\n+                    hiPrec[0] = Double.POSITIVE_INFINITY;\n+                    hiPrec[1] = 0.0;\n+                }\n                 return Double.POSITIVE_INFINITY;\n             }\n \n         double xpa = 1.0 + x;\n         double xpb = -(xpa - 1.0 - x);\n \n+        if (x == -1) {\n+            return x/0.0;   // -Infinity\n+        }\n+\n+        if (x > 0 && 1/x == 0) { // x = Infinity\n+            return x;\n+        }\n+\n         if (x>1e-6 || x<-1e-6) {\n             double hiPrec[] = new double[2];\n \n             return 1.0;\n         }\n \n+        if (x != x) { // X is NaN\n+            return x;\n+        }\n+\n+\n+        if (x == 0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if ((bits & 0x8000000000000000L) != 0) {\n+                // -zero\n+                long yi = (long) y;\n+\n+                if (y < 0 && y == yi && (yi & 1) == 1) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n+\n+                if (y < 0 && y == yi && (yi & 1) == 1) {\n+                    return -0.0;\n+                }\n+\n+                if (y > 0 && y == yi && (yi & 1) == 1) {\n+                    return -0.0;\n+                }\n+            }\n+\n+            if (y < 0) {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+            if (y > 0) {\n+                return 0.0;\n+            }\n+\n+            return Double.NaN;\n+        }\n+\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (y != y) { // y is NaN\n+                return y;\n+            }\n+            if (y < 0.0) {\n+                return 0.0;\n+            } else {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n+\n+        if (y == Double.POSITIVE_INFINITY) {\n+            if (x * x == 1.0)\n+              return Double.NaN;\n+\n+            if (x * x > 1.0) {\n+                return Double.POSITIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n+\n+        if (x == Double.NEGATIVE_INFINITY) {\n+            if (y != y) { // y is NaN\n+                return y;\n+            }\n+\n+            if (y < 0) {\n+                long yi = (long) y;\n+                if (y == yi && (yi & 1) == 1) {\n+                    return -0.0;\n+                }\n+\n+                return 0.0;\n+            }\n+\n+            if (y > 0)  {\n+                long yi = (long) y;\n+                if (y == yi && (yi & 1) == 1) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n+\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n+\n+        if (y == Double.NEGATIVE_INFINITY) {\n+\n+            if (x * x == 1.0) {\n+                return Double.NaN;\n+            }\n+\n+            if (x * x < 1.0) {\n+                return Double.POSITIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n+\n         /* Handle special case x<0 */\n         if (x < 0) {\n+            // y is an even integer in this case\n+            if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {\n+                return pow(-x, y);\n+            }\n+\n             if (y == (long) y) {\n                 // If y is an integer\n                 return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n             }\n         }\n \n-        if (x == 0) {\n-            long bits = Double.doubleToLongBits(x);\n-            if ((bits & 0x8000000000000000L) != 0) {\n-                // -zero\n-                if (y < 0 && y == (long)y)\n-                    return Double.NEGATIVE_INFINITY;\n-            }\n-\n-            if (y < 0) {\n-                return Double.POSITIVE_INFINITY;\n-            }\n-            if (y > 0) {\n-                return 0.0;\n-            }\n-\n-            return Double.NaN;\n-        }\n-\n-        if (x == Double.POSITIVE_INFINITY) {\n-            if (y < 0.0) {\n-                return 0.0;\n-            } else {\n-                return Double.POSITIVE_INFINITY;\n-            }\n-        }\n-\n-        if (y == Double.POSITIVE_INFINITY) {\n-            if (x * x > 1.0) {\n-                return Double.POSITIVE_INFINITY;\n-            } else {\n-                return 0.0;\n-            }\n-        }\n-\n-        if (y == Double.NEGATIVE_INFINITY) {\n-            if (x*x < 1.0) {\n-                return Double.NEGATIVE_INFINITY;\n-            } else {\n-                return 0.0;\n-            }\n-        }\n-\n         /* Split y into ya and yb such that y = ya+yb */\n-        double tmp1 = y * 1073741824.0;\n-        final double ya = y + tmp1 - tmp1;\n-        final double yb = y - ya;\n+        double ya;\n+        double yb;\n+        if (y < 8e298 && y > -8e298) {\n+            double tmp1 = y * 1073741824.0;\n+            ya = y + tmp1 - tmp1;\n+            yb = y - ya;\n+        } else {\n+            double tmp1 = y * 9.31322574615478515625E-10;\n+            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n+            ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;\n+            yb = y - ya;\n+        }\n \n         /* Compute ln(x) */\n         log(x, lns);\n         double lnb = lns[1];\n \n         /* resplit lns */\n-        tmp1 = lna * 1073741824.0;\n-        final double tmp2 = lna + tmp1 - tmp1;\n+        double tmp1 = lna * 1073741824.0;\n+        double tmp2 = lna + tmp1 - tmp1;\n         lnb += lna - tmp2;\n         lna = tmp2;\n \n             double b = -(a - pi2a + xa);\n             b += pi2b - xb;\n \n-            xa = a;\n-            xb = b;\n+            xa = a + b;\n+            xb = -(xa - a - b);\n             quadrant ^= 1;\n             negative ^= true;\n         }\n      */\n     private static double atan(double xa, double xb, boolean leftPlane) {\n         boolean negate = false;\n-        boolean recip = false;\n         int idx;\n \n         if (xa < 0) {\n \n         double result;\n         double resultb;\n-        if (recip) {\n-            final double pi2a = 1.5707963267948966;\n-            final double pi2b = 6.123233995736766E-17;\n-\n-            double za = pi2a - ya;\n-            double zb = -(za - pi2a + ya);\n-            temp = za - EIGHTHES[idx];\n-            zb += -(temp - za + EIGHTHES[idx]);\n-            za = temp;\n-\n-            zb += pi2b - yb;\n-            ya = za;\n-            yb = zb;\n-\n-            result = yb + ya;\n-            resultb = -(result - yb - ya);\n-        } else {\n-            //result = yb + eighths[idx] + ya;\n-            double za = EIGHTHES[idx] + ya;\n-            double zb = -(za - EIGHTHES[idx] - ya);\n-            temp = za + yb;\n-            zb += -(temp - za - yb);\n-            za = temp;\n-\n-            result = za + zb;\n-            resultb = -(result - za - zb);\n-        }\n+\n+        //result = yb + eighths[idx] + ya;\n+        double za = EIGHTHES[idx] + ya;\n+        double zb = -(za - EIGHTHES[idx] - ya);\n+        temp = za + yb;\n+        zb += -(temp - za - yb);\n+        za = temp;\n+\n+        result = za + zb;\n+        resultb = -(result - za - zb);\n \n         if (leftPlane) {\n             // Result is in the left plane\n             final double pia = 1.5707963267948966*2.0;\n             final double pib = 6.123233995736766E-17*2.0;\n \n-            final double za = pia - result;\n-            double zb = -(za - pia + result);\n+            za = pia - result;\n+            zb = -(za - pia + result);\n             zb += pib - resultb;\n \n             result = za + zb;\n             double invy = 1.0/y;\n \n             if (invx == 0.0) { // X is infinite\n-                return 0.0;\n+                if (x > 0) {\n+                    return 0.0;\n+                } else {\n+                    return Math.PI;\n+                }\n             }\n \n             if (result != result) { // y must be infinite\n         double result = atan(ra, rb, x < 0);\n \n         return result;\n+    }\n+\n+    /** Compute the arc sine of a number.\n+     * @param x number on which evaluation is done\n+     * @return arc sine of x\n+     */\n+    public static double asin(double x) {\n+      if (x != x) {\n+          return Double.NaN;\n+      }\n+\n+      if (x > 1.0 || x < -1.0) {\n+          return Double.NaN;\n+      }\n+\n+      if (x == 1.0) {\n+          return Math.PI/2.0;\n+      }\n+\n+      if (x == -1.0) {\n+          return -Math.PI/2.0;\n+      }\n+\n+      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n+\n+      /* Split x */\n+      double temp = x * 1073741824.0;\n+      final double xa = x + temp - temp;\n+      final double xb = x - xa;\n+\n+      /* Square it */\n+      double ya = xa*xa;\n+      double yb = xa*xb*2.0 + xb*xb;\n+\n+      /* Subtract from 1 */\n+      ya = -ya;\n+      yb = -yb;\n+\n+      double za = 1.0 + ya;\n+      double zb = -(za - 1.0 - ya);\n+\n+      temp = za + yb;\n+      zb += -(temp - za - yb);\n+      za = temp;\n+\n+      /* Square root */\n+      double y;\n+      y = sqrt(za);\n+      temp = y * 1073741824.0;\n+      ya = y + temp - temp;\n+      yb = y - ya;\n+\n+      /* Extend precision of sqrt */\n+      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n+\n+      /* Contribution of zb to sqrt */\n+      double dx = zb / (2.0*y);\n+\n+      // Compute ratio r = x/y\n+      double r = x/y;\n+      temp = r * 1073741824.0;\n+      double ra = r + temp - temp;\n+      double rb = r - ra;\n+\n+      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n+      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n+\n+      temp = ra + rb;\n+      rb = -(temp - ra - rb);\n+      ra = temp;\n+\n+      return atan(ra, rb, false);\n+    }\n+\n+    /** Compute the arc cosine of a number.\n+     * @param x number on which evaluation is done\n+     * @return arc cosine of x\n+     */\n+    public static double acos(double x) {\n+      if (x != x) {\n+          return Double.NaN;\n+      }\n+\n+      if (x > 1.0 || x < -1.0) {\n+          return Double.NaN;\n+      }\n+\n+      if (x == -1.0) {\n+          return Math.PI;\n+      }\n+\n+      if (x == 1.0) {\n+          return 0.0;\n+      }\n+\n+      if (x == 0) {\n+          return Math.PI/2.0;\n+      }\n+\n+      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n+\n+      /* Split x */\n+      double temp = x * 1073741824.0;\n+      final double xa = x + temp - temp;\n+      final double xb = x - xa;\n+\n+      /* Square it */\n+      double ya = xa*xa;\n+      double yb = xa*xb*2.0 + xb*xb;\n+\n+      /* Subtract from 1 */\n+      ya = -ya;\n+      yb = -yb;\n+\n+      double za = 1.0 + ya;\n+      double zb = -(za - 1.0 - ya);\n+\n+      temp = za + yb;\n+      zb += -(temp - za - yb);\n+      za = temp;\n+\n+      /* Square root */\n+      double y = sqrt(za);\n+      temp = y * 1073741824.0;\n+      ya = y + temp - temp;\n+      yb = y - ya;\n+\n+      /* Extend precision of sqrt */\n+      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n+\n+      /* Contribution of zb to sqrt */\n+      yb += zb / (2.0*y);\n+      y = ya+yb;\n+      yb = -(y - ya - yb);\n+\n+      // Compute ratio r = y/x\n+      double r = y/x;\n+      temp = r * 1073741824.0;\n+      double ra = r + temp - temp;\n+      double rb = r - ra;\n+\n+      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n+      rb += yb / x;  // Add in effect additional bits of sqrt.\n+\n+      temp = ra + rb;\n+      rb = -(temp - ra - rb);\n+      ra = temp;\n+\n+      return atan(ra, rb, x<0);\n     }\n \n     /**\n     public static double floor(double x) {\n         long y;\n \n+        if (x != x) { // NaN\n+            return x;\n+        }\n+\n         if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {\n             return x;\n         }\n \n         y = (long) x;\n-        if (x < 0) {\n+        if (x < 0 && y != x) {\n             y--;\n+        }\n+\n+        if (y == 0) {\n+            return x*y;\n         }\n \n         return (double) y;\n     public static double ceil(double x) {\n         double y;\n \n+        if (x != x) { // NaN\n+            return x;\n+        }\n+\n         y = floor(x);\n         if (y == x) {\n             return y;\n         }\n \n-        return y + 1.0;\n+        y += 1.0;\n+\n+        if (y == 0) {\n+            return x*y;\n+        }\n+\n+        return y;\n     }\n \n     /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.", "timestamp": 1283714825, "metainfo": ""}