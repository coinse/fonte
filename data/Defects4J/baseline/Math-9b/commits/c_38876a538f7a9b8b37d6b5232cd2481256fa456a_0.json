{"sha": "38876a538f7a9b8b37d6b5232cd2481256fa456a", "log": "Code simplified in AbstractLeastSquaresOptimizer  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n     protected VectorialConvergenceChecker checker;\n \n     /**\n-     * Jacobian matrix.\n+     * Jacobian matrix of the weighted residuals.\n      * <p>This matrix is in canonical form just after the calls to\n      * {@link #updateJacobian()}, but may be modified by the solver\n      * in the derived class (the {@link LevenbergMarquardtOptimizer\n      * Levenberg-Marquardt optimizer} does this).</p>\n      */\n-    protected double[][] jacobian;\n+    protected double[][] weightedResidualJacobian;\n \n     /** Number of columns of the jacobian matrix. */\n     protected int cols;\n \n     /** Current objective function value. */\n     protected double[] objective;\n-\n-    /** Current residuals. */\n-    protected double[] residuals;\n-    \n-    /** Weighted Jacobian */\n-    protected double[][] wjacobian;\n     \n     /** Weighted residuals */\n-    protected double[] wresiduals;\n+    protected double[] weightedResiduals;\n \n     /** Cost value (square root of the sum of the residuals). */\n     protected double cost;\n      */\n     protected void updateJacobian() throws FunctionEvaluationException {\n         ++jacobianEvaluations;\n-        jacobian = jF.value(point);\n-        if (jacobian.length != rows) {\n+        weightedResidualJacobian = jF.value(point);\n+        if (weightedResidualJacobian.length != rows) {\n             throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                                                  jacobian.length, rows);\n+                                                  weightedResidualJacobian.length, rows);\n         }\n         for (int i = 0; i < rows; i++) {\n-            final double[] ji = jacobian[i];\n+            final double[] ji = weightedResidualJacobian[i];\n             double wi = Math.sqrt(residualsWeights[i]);\n             for (int j = 0; j < cols; ++j) {\n-                ji[j] *=  -1.0;\n-                wjacobian[i][j] = ji[j]*wi;\n+                //ji[j] *=  -1.0;\n+                weightedResidualJacobian[i][j] = -ji[j]*wi;\n             }\n         }\n     }\n         int index = 0;\n         for (int i = 0; i < rows; i++) {\n             final double residual = targetValues[i] - objective[i];\n-            residuals[i] = residual;\n-            wresiduals[i]= residual*Math.sqrt(residualsWeights[i]);\n+            weightedResiduals[i]= residual*Math.sqrt(residualsWeights[i]);\n             cost += residualsWeights[i] * residual * residual;\n             index += cols;\n         }\n             for (int j = i; j < cols; ++j) {\n                 double sum = 0;\n                 for (int k = 0; k < rows; ++k) {\n-                    sum += wjacobian[k][i] * wjacobian[k][j];\n+                    sum += weightedResidualJacobian[k][i] * weightedResidualJacobian[k][j];\n                 }\n                 jTj[i][j] = sum;\n                 jTj[j][i] = sum;\n         targetValues     = target.clone();\n         residualsWeights = weights.clone();\n         this.point       = startPoint.clone();\n-        this.residuals   = new double[target.length];\n \n         // arrays shared with the other private methods\n         rows      = target.length;\n         cols      = point.length;\n-        jacobian  = new double[rows][cols];\n-\n-        wjacobian = new double[rows][cols];\n-        wresiduals = new double[rows];\n+\n+        weightedResidualJacobian = new double[rows][cols];\n+        this.weightedResiduals = new double[rows];\n         \n         cost = Double.POSITIVE_INFINITY;\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n             final double[][] a = new double[cols][cols];\n             for (int i = 0; i < rows; ++i) {\n \n-                final double[] grad   = jacobian[i];\n+                final double[] grad   = weightedResidualJacobian[i];\n                 final double weight   = residualsWeights[i];\n                 final double residual = objective[i] - targetValues[i];\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n             for (int i=0;i<rows;i++) {\n-                qtf[i]=wresiduals[i];\n+                qtf[i]=weightedResiduals[i];\n             }\n             incrementIterationsCounter();\n \n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n                 int pk = permutation[k];\n-                wjacobian[k][pk] = diagR[pk];\n+                weightedResidualJacobian[k][pk] = diagR[pk];\n             }\n \n             if (firstIteration) {\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += wjacobian[i][pj] * qtf[i];\n+                            sum += weightedResidualJacobian[i][pj] * qtf[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }\n                     oldX[pj] = point[pj];\n                 }\n                 double previousCost = cost;\n-                double[] tmpVec = residuals;\n-                residuals = oldRes;\n+                double[] tmpVec = weightedResiduals;\n+                weightedResiduals = oldRes;\n                 oldRes    = tmpVec;\n                 tmpVec    = objective;\n                 objective = oldObj;\n                     double dirJ = lmDir[pj];\n                     work1[j] = 0;\n                     for (int i = 0; i <= j; ++i) {\n-                        work1[i] += wjacobian[i][pj] * dirJ;\n+                        work1[i] += weightedResidualJacobian[i][pj] * dirJ;\n                     }\n                 }\n                 double coeff1 = 0;\n                         int pj = permutation[j];\n                         point[pj] = oldX[pj];\n                     }\n-                    tmpVec    = residuals;\n-                    residuals = oldRes;\n+                    tmpVec    = weightedResiduals;\n+                    weightedResiduals = oldRes;\n                     oldRes    = tmpVec;\n                     tmpVec    = objective;\n                     objective = oldObj;\n             int pk = permutation[k];\n             double ypk = lmDir[pk] / diagR[pk];\n             for (int i = 0; i < k; ++i) {\n-                lmDir[permutation[i]] -= ypk * wjacobian[i][pk];\n+                lmDir[permutation[i]] -= ypk * weightedResidualJacobian[i][pk];\n             }\n             lmDir[pk] = ypk;\n         }\n                 int pj = permutation[j];\n                 double sum = 0;\n                 for (int i = 0; i < j; ++i) {\n-                    sum += wjacobian[i][pj] * work1[permutation[i]];\n+                    sum += weightedResidualJacobian[i][pj] * work1[permutation[i]];\n                 }\n                 double s = (work1[pj] - sum) / diagR[pj];\n                 work1[pj] = s;\n             int pj = permutation[j];\n             double sum = 0;\n             for (int i = 0; i <= j; ++i) {\n-                sum += wjacobian[i][pj] * qy[i];\n+                sum += weightedResidualJacobian[i][pj] * qy[i];\n             }\n             sum /= diag[pj];\n             sum2 += sum * sum;\n                 work1[pj] /= work2[j];\n                 double tmp = work1[pj];\n                 for (int i = j + 1; i < solvedCols; ++i) {\n-                    work1[permutation[i]] -= wjacobian[i][pj] * tmp;\n+                    work1[permutation[i]] -= weightedResidualJacobian[i][pj] * tmp;\n                 }\n             }\n             sum2 = 0;\n         for (int j = 0; j < solvedCols; ++j) {\n             int pj = permutation[j];\n             for (int i = j + 1; i < solvedCols; ++i) {\n-                wjacobian[i][pj] = wjacobian[j][permutation[i]];\n+                weightedResidualJacobian[i][pj] = weightedResidualJacobian[j][permutation[i]];\n             }\n             lmDir[j] = diagR[pj];\n             work[j]  = qy[j];\n \n                     final double sin;\n                     final double cos;\n-                    double rkk = wjacobian[k][pk];\n+                    double rkk = weightedResidualJacobian[k][pk];\n                     if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n                         final double cotan = rkk / lmDiag[k];\n                         sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n \n                     // compute the modified diagonal element of R and\n                     // the modified element of (Qty,0)\n-                    wjacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n+                    weightedResidualJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                     final double temp = cos * work[k] + sin * qtbpj;\n                     qtbpj = -sin * work[k] + cos * qtbpj;\n                     work[k] = temp;\n \n                     // accumulate the tranformation in the row of s\n                     for (int i = k + 1; i < solvedCols; ++i) {\n-                        double rik = wjacobian[i][pk];\n+                        double rik = weightedResidualJacobian[i][pk];\n                         final double temp2 = cos * rik + sin * lmDiag[i];\n                         lmDiag[i] = -sin * rik + cos * lmDiag[i];\n-                        wjacobian[i][pk] = temp2;\n+                        weightedResidualJacobian[i][pk] = temp2;\n                     }\n \n                 }\n \n             // store the diagonal element of s and restore\n             // the corresponding diagonal element of R\n-            lmDiag[j] = wjacobian[j][permutation[j]];\n-            wjacobian[j][permutation[j]] = lmDir[j];\n+            lmDiag[j] = weightedResidualJacobian[j][permutation[j]];\n+            weightedResidualJacobian[j][permutation[j]] = lmDir[j];\n \n         }\n \n                 int pj = permutation[j];\n                 double sum = 0;\n                 for (int i = j + 1; i < nSing; ++i) {\n-                    sum += wjacobian[i][pj] * work[i];\n+                    sum += weightedResidualJacobian[i][pj] * work[i];\n                 }\n                 work[j] = (work[j] - sum) / lmDiag[j];\n             }\n         for (int k = 0; k < cols; ++k) {\n             permutation[k] = k;\n             double norm2 = 0;\n-            for (int i = 0; i < wjacobian.length; ++i) {\n-                double akk = wjacobian[i][k];\n+            for (int i = 0; i < weightedResidualJacobian.length; ++i) {\n+                double akk = weightedResidualJacobian[i][k];\n                 norm2 += akk * akk;\n             }\n             jacNorm[k] = Math.sqrt(norm2);\n             double ak2 = Double.NEGATIVE_INFINITY;\n             for (int i = k; i < cols; ++i) {\n                 double norm2 = 0;\n-                for (int j = k; j < wjacobian.length; ++j) {\n-                    double aki = wjacobian[j][permutation[i]];\n+                for (int j = k; j < weightedResidualJacobian.length; ++j) {\n+                    double aki = weightedResidualJacobian[j][permutation[i]];\n                     norm2 += aki * aki;\n                 }\n                 if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n             permutation[k]          = pk;\n \n             // choose alpha such that Hk.u = alpha ek\n-            double akk   = wjacobian[k][pk];\n+            double akk   = weightedResidualJacobian[k][pk];\n             double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n             double betak = 1.0 / (ak2 - akk * alpha);\n             beta[pk]     = betak;\n \n             // transform the current column\n             diagR[pk]        = alpha;\n-            wjacobian[k][pk] -= alpha;\n+            weightedResidualJacobian[k][pk] -= alpha;\n \n             // transform the remaining columns\n             for (int dk = cols - 1 - k; dk > 0; --dk) {\n                 double gamma = 0;\n-                for (int j = k; j < wjacobian.length; ++j) {\n-                    gamma += wjacobian[j][pk] * wjacobian[j][permutation[k + dk]];\n+                for (int j = k; j < weightedResidualJacobian.length; ++j) {\n+                    gamma += weightedResidualJacobian[j][pk] * weightedResidualJacobian[j][permutation[k + dk]];\n                 }\n                 gamma *= betak;\n-                for (int j = k; j < wjacobian.length; ++j) {\n-                    wjacobian[j][permutation[k + dk]] -= gamma * wjacobian[j][pk];\n+                for (int j = k; j < weightedResidualJacobian.length; ++j) {\n+                    weightedResidualJacobian[j][permutation[k + dk]] -= gamma * weightedResidualJacobian[j][pk];\n                 }\n             }\n \n             int pk = permutation[k];\n             double gamma = 0;\n             for (int i = k; i < rows; ++i) {\n-                gamma += wjacobian[i][pk] * y[i];\n+                gamma += weightedResidualJacobian[i][pk] * y[i];\n             }\n             gamma *= beta[pk];\n             for (int i = k; i < rows; ++i) {\n-                y[i] -= gamma * wjacobian[i][pk];\n+                y[i] -= gamma * weightedResidualJacobian[i][pk];\n             }\n         }\n     }", "timestamp": 1281948310, "metainfo": ""}