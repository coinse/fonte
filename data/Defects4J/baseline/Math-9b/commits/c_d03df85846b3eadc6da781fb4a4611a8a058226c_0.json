{"sha": "d03df85846b3eadc6da781fb4a4611a8a058226c", "log": "limit visibility of event states list to AbstractIntegrator class only  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n     protected boolean resetOccurred;\n \n     /** Events states. */\n-    protected Collection<EventState> eventsStates;\n+    private Collection<EventState> eventsStates;\n \n     /** Initialization indicator of events states. */\n     protected boolean statesInitialized;\n         eventsStates.clear();\n     }\n \n-    /** Check if one of the step handlers requires dense output.\n-     * @return true if one of the step handlers requires dense output\n+    /** Check if dense output is needed.\n+     * @return true if there is at least one event handler or if\n+     * one of the step handlers requires dense output\n      */\n     protected boolean requiresDenseOutput() {\n+        if (!eventsStates.isEmpty()) {\n+            return true;\n+        }\n         for (StepHandler handler : stepHandlers) {\n             if (handler.requiresDenseOutput()) {\n                 return true;\n \n     /** Accept a step, triggering events and step handlers.\n      * @param interpolator step interpolator\n-     * @param handlers step handlers\n      * @param y state vector at step end time, must be reset if an event\n      * asks for resetting or if an events stops integration during the step\n      * @param yDot placeholder array where to put the time derivative of the state vector\n      * @exception IntegratorException if the value of one event state cannot be evaluated\n      */\n     protected double acceptStep(final AbstractStepInterpolator interpolator,\n-                                final Collection<StepHandler> handlers,\n-                                final double[] y,\n-                                final double[] yDot, final double tEnd)\n+                                final double[] y, final double[] yDot, final double tEnd)\n         throws IntegratorException {\n \n         try {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n \n             // discrete events handling\n             interpolator.storeTime(stepEnd);\n-            stepStart = acceptStep(interpolator, stepHandlers, y, yDot, t);\n+            stepStart = acceptStep(interpolator, y, yDot, t);\n             scaled    = predictedScaled;\n             nordsieck = nordsieckTmp;\n             interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n             interpolator.storeTime(stepStart);\n             interpolator.shift();\n             interpolator.storeTime(stepEnd);\n-            stepStart = acceptStep(interpolator, stepHandlers, y, yDot, t);\n+            stepStart = acceptStep(interpolator, y, yDot, t);\n             scaled    = correctedScaled;\n             nordsieck = nordsieckTmp;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n-    if (requiresDenseOutput() || (! eventsStates.isEmpty())) {\n+    if (requiresDenseOutput()) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n       interpolator.storeTime(stepStart + stepSize);\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n-      stepStart = acceptStep(interpolator, stepHandlers, y, yDotTmp, t);\n+      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n \n       if (!isLastStep) {\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n     /** second order control factor. */\n     private double orderControl2;\n \n-    /** dense outpute required. */\n-    private boolean denseOutput;\n-\n     /** use interpolation error in stepsize control. */\n     private boolean useInterpolationError;\n \n                                       final double scalRelativeTolerance) {\n     super(METHOD_NAME, minStep, maxStep,\n           scalAbsoluteTolerance, scalRelativeTolerance);\n-    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n                                       final double[] vecRelativeTolerance) {\n     super(METHOD_NAME, minStep, maxStep,\n           vecAbsoluteTolerance, vecRelativeTolerance);\n-    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n     setOrderControl(-1, -1, -1);\n   public void addStepHandler (final StepHandler handler) {\n \n     super.addStepHandler(handler);\n-    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n \n     // reinitialize the arrays\n     initializeArrays();\n                               final double convergence,\n                               final int maxIterationCount) {\n     super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n-    denseOutput = requiresDenseOutput() || (! eventsStates.isEmpty());\n \n     // reinitialize the arrays\n     initializeArrays();\n       optimalStep     = new double[size];\n     }\n \n-    if (denseOutput) {\n+    if (requiresDenseOutput()) {\n       // step size sequence: 2, 6, 10, 14, ...\n       for (int k = 0; k < size; ++k) {\n         sequence[k] = 4 * k + 2;\n \n     double[] yDot1      = new double[y0.length];\n     double[][] yMidDots = null;\n+    final boolean denseOutput = requiresDenseOutput();\n     if (denseOutput) {\n       yMidDots = new double[1 + 2 * sequence.length][];\n       for (int j = 0; j < yMidDots.length; ++j) {\n     int targetIter = FastMath.max(1,\n                               FastMath.min(sequence.length - 2,\n                                        (int) FastMath.floor(0.5 - 0.6 * log10R)));\n+\n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator = null;\n-    if (denseOutput || (! eventsStates.isEmpty())) {\n+    if (denseOutput) {\n       interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,\n                                                             y1, yDot1,\n                                                             yMidDots, forward);\n \n         // Discrete events handling\n         interpolator.storeTime(stepStart + stepSize);\n-        stepStart = acceptStep(interpolator, stepHandlers, y1, yDot1, t);\n+        stepStart = acceptStep(interpolator, y1, yDot1, t);\n \n         // prepare next step\n         interpolator.storeTime(stepStart);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n \n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n-    if (requiresDenseOutput() || (! eventsStates.isEmpty())) {\n+    if (requiresDenseOutput()) {\n       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(this, yTmp, yDotK, forward);\n       interpolator = rki;\n       interpolator.storeTime(stepStart + stepSize);\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n-      stepStart = acceptStep(interpolator, stepHandlers, y, yDotTmp, t);\n+      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n \n       if (!isLastStep) {\n ", "timestamp": 1295559114, "metainfo": ""}