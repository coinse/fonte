{"sha": "39f6ac3266e8e6587c3e3b0f2f9d219100c09ded", "log": "javadoc.   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunction.java\n  * <a href=\"http://mathworld.wolfram.com/HornersMethod.html\">Horner's Method</a>\n  *  is used to evaluate the function.   \n  *\n- * @version $Revision: 1.11 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.12 $ $Date: 2004/07/20 12:55:01 $\n  */\n public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {\n \n     static final long serialVersionUID = 3322454535052136809L;\n     \n     /**\n-     * The coefficients of the polynomial, ordered by degree -- i.e.,  coefficients[0] is the constant term\n-     * and coefficients[n] is the coefficient of x^n where n is the degree of the polynomial.\n+     * The coefficients of the polynomial, ordered by degree -- i.e.,  \n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n      */\n     private double coefficients[];\n \n     /**\n-     * Construct a polynomial with the given coefficients.\n+     * Construct a polynomial with the given coefficients.  The first element\n+     * of the coefficients array is the constant term.  Higher degree\n+     * coefficients follow in sequence.  The degree of the resulting polynomial\n+     * is the length of the array minus 1. \n      * <p>\n      * The constructor makes a copy of the input array and assigns the copy to\n      *  the coefficients property.\n--- a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n /**\n  * Represents a polynomial spline function.\n  * <p>\n- * A <strong>polynomial spline function</strong> consists of a set of <i>interpolating polynomials</i> \n- * and an ascending array of  domain <i>knot points</i>, determining the intervals over which the \n- * spline function is defined by the constituent polynomials.  The polynomials are assumed to have \n- * been computed to match the values of another function at the knot points.  The value \n- * consistency constraints are not currently enforced by <code>PolynomialSplineFunction</code> itself,\n- * but are assumed to hold  among the polynomials and knot points passed to the constructor.\n- * <p>\n- * N.B.:  The polynomials in the <code>polynomials</code> property must be centered on the knot points\n- * to compute the spline function values.  See below.\n- * <p>\n- * The value of the polynomial spline function for an argument <code>x</code> is computed as follows:\n+ * A <strong>polynomial spline function</strong> consists of a set of \n+ * <i>interpolating polynomials</i> and an ascending array of  domain \n+ * <i>knot points</i>, determining the intervals over which the spline function\n+ * is defined by the constituent polynomials.  The polynomials are assumed to\n+ * have been computed to match the values of another function at the knot\n+ * points.  The value consistency constraints are not currently enforced by \n+ * <code>PolynomialSplineFunction</code> itself, but are assumed to hold among\n+ * the polynomials and knot points passed to the constructor.\n+ * <p>\n+ * N.B.:  The polynomials in the <code>polynomials</code> property must be\n+ * centered on the knot points to compute the spline function values.  See below.\n+ * <p>\n+ * The domain of the polynomial spline function is \n+ * <code>[smallest knot, largest knot)</code>.  Attempts to evaluate the\n+ * function at values outside of this range generate IllegalArgumentExceptions.\n+ * <p>\n+ * The value of the polynomial spline function for an argument <code>x</code>\n+ * is computed as follows:\n  * <ol>\n- * <li>The knot array is searched to find the segment to which <code>x</code> belongs.  \n- *  If <code>x</code> is less than the smallest knot point or greater than or equal to the largest one, an \n- *  <code>IllegalArgumentException</code> is thrown.</li>\n- * <li> Let <code>j</code> be the index of the largest knot point that is less than or equal to <code>x</code>. \n- *  The value returned is <br> <code>polynomials[j](x - knot[j])</code></li></ol>\n- *\n- * @version $Revision: 1.7 $ $Date: 2004/07/17 21:19:39 $\n+ * <li>The knot array is searched to find the segment to which <code>x</code>\n+ * belongs.  If <code>x</code> is less than the smallest knot point or greater\n+ * than or equal to the largest one, an <code>IllegalArgumentException</code>\n+ * is thrown.</li>\n+ * <li> Let <code>j</code> be the index of the largest knot point that is less\n+ * than or equal to <code>x</code>.  The value returned is <br>\n+ * <code>polynomials[j](x - knot[j])</code></li></ol>\n+ *\n+ * @version $Revision: 1.8 $ $Date: 2004/07/20 12:55:01 $\n  */\n public class PolynomialSplineFunction implements UnivariateRealFunction, Serializable {\n    \n     private double knots[];\n \n     /**\n-     * The polynomial functions that make up the spline.  The first element determines the value of the spline\n-     * over the first subinterval, the second over the second, etc.   Spline function values are determined by\n-     * evaluating these functions at <code>(x - knot[i])</code> where i is the knot segment to which x belongs.\n+     * The polynomial functions that make up the spline.  The first element\n+     * determines the value of the spline over the first subinterval, the\n+     * second over the second, etc.   Spline function values are determined by\n+     * evaluating these functions at <code>(x - knot[i])</code> where i is the\n+     * knot segment to which x belongs.\n      */\n     private PolynomialFunction polynomials[] = null;\n     \n-    /** Number of spline segments = number of polynomials = number of partition points - 1 */\n+    /** \n+     * Number of spline segments = number of polynomials\n+     *  = number of partition points - 1 \n+     */\n     private int n = 0;\n     \n \n     /**\n-     * Construct a polynomial spline function with the given segment delimiters and interpolating\n-     * polynomials.\n-     * <p>\n-     * The constructor copies both arrays and assigns the copies to the knots and polynomials properties,\n-     * respectively.\n+     * Construct a polynomial spline function with the given segment delimiters\n+     * and interpolating polynomials.\n+     * <p>\n+     * The constructor copies both arrays and assigns the copies to the knots\n+     * and polynomials properties, respectively.\n      * \n      * @param knots spline segment interval delimiters\n      * @param polynomials polynomial functions that make up the spline\n      * @throws NullPointerException if either of the input arrays is null\n      * @throws IllegalArgumentException if knots has length less than 2,  \n-     *     <code>polynomials.length != knots.length - 1 </code>, or the knots array\n-     *     is not strictly increasing.\n+     * <code>polynomials.length != knots.length - 1 </code>, or the knots array\n+     * is not strictly increasing.\n      * \n      */\n     public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n-        super();\n         if (knots.length < 2) {\n             throw new IllegalArgumentException\n             \t(\"Not enough knot values -- spline partition must have at least 2 points.\");\n \n     /**\n      * Compute the value for the function.\n+     * <p>\n+     * Throws FunctionEvaluationException if v is outside of the domain of the\n+     * function.  The domain is [smallest knot, largest knot).\n+     * <p>\n+     * See {@link PolynomialSplineFunction} for details on the algorithm for\n+     * computing the value of the function.\n      * \n      * @param v the point for which the function value should be computed\n      * @return the value\n      * @throws FunctionEvaluationException if v is outside of the domain of\n      * of the spline function (less than the smallest knot point or greater\n-     * than the largest knot point)\n+     * than or equal to the largest knot point)\n      */\n     public double value(double v) throws FunctionEvaluationException {\n         if (v < knots[0] || v >= knots[n]) {\n     }\n \n     /**\n-     * Returns the number of spline segments = the number of polynomials = the number of knot points - 1.\n+     * Returns the number of spline segments = the number of polynomials \n+     * = the number of knot points - 1.\n      * \n      * @return the number of spline segments\n      */\n     /**\n      * Determines if the given array is ordered in a strictly increasing\n      * fashion.\n+     * \n      * @param x the array to examine.\n      * @return <code>true</code> if the elements in <code>x</code> are ordered\n-     *         in a stricly increasing manner.  <code>false</code>, otherwise.\n+     * in a stricly increasing manner.  <code>false</code>, otherwise.\n      */\n     private static boolean isStrictlyIncreasing(double[] x) {\n         for (int i = 1; i < x.length; ++i) {\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n  *<strong>USAGE NOTES:</strong><ul>\n  *<li>The <code>binCount</code> is set by default to 1000.  A good rule of thumb\n  *    is to set the bin count to approximately the length of the input file divided\n- *    by 10.  See TODO: add reference </li>\n+ *    by 10. </li>\n  *<li>The input file <i>must</i> be a plain text file containing one valid numeric\n  *    entry per line.</li>\n  * </ul></p>\n  *\n- * @version $Revision: 1.28 $ $Date: 2004/07/18 23:57:11 $\n+ * @version $Revision: 1.29 $ $Date: 2004/07/20 12:53:54 $\n  */\n public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {\n ", "timestamp": 1090328101, "metainfo": ""}