{"sha": "6ef3b2932f4ca9219e41784bb0cd229dcabcdb11", "log": "Merged (final) src changes from MATH_1_1 release branch r321516-358399  ", "commit": "\n--- a/src/java/org/apache/commons/math/ConvergenceException.java\n+++ b/src/java/org/apache/commons/math/ConvergenceException.java\n public class ConvergenceException extends MathException implements Serializable{\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -3657394299929217890L;\n+    private static final long serialVersionUID = -3657394299929217890L;\n     \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n public class FunctionEvaluationException extends MathException  {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -317289374378977972L;\n+    private static final long serialVersionUID = -317289374378977972L;\n     \n     /** Argument causing function evaluation failure */\n     private double argument = Double.NaN;\n--- a/src/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/java/org/apache/commons/math/MathConfigurationException.java\n public class MathConfigurationException extends MathException implements Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -7958299004965931723L;\n+    private static final long serialVersionUID = -7958299004965931723L;\n \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n public class MathException extends Exception {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -8594613561393443827L;\n+    private static final long serialVersionUID = -8594613561393443827L;\n     \n     /**\n      * Does JDK support nested exceptions?\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n public class BisectionSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 7137520585963699578L;\n+    private static final long serialVersionUID = 7137520585963699578L;\n     \n     /**\n      * Construct a solver for the given function.\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n public class BrentSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 3350616277306882875L;\n+    private static final long serialVersionUID = 3350616277306882875L;\n \n     /**\n      * Construct a solver for the given function.\n--- a/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n \n package org.apache.commons.math.analysis;\n \n+import java.io.IOException;\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException; \n \n public class NewtonSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 2606474895443431607L;\n+    private static final long serialVersionUID = 2606474895443431607L;\n     \n     /** The first derivative of the target function. */\n-    private UnivariateRealFunction derivative;\n+    private transient UnivariateRealFunction derivative;\n     \n     /**\n      * Construct a solver for the given function.\n         throw new ConvergenceException\n             (\"Maximum number of iterations exceeded \" + i);\n     }\n-\n+    \n+    /**\n+     * Custom deserialization to initialize transient deriviate field.\n+     * \n+     * @param in serialized object input stream\n+     * @throws IOException if IO error occurs \n+     * @throws ClassNotFoundException if instantiation error occurs\n+     */\n+    private void readObject(java.io.ObjectInputStream in)\n+    throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        derivative = ((DifferentiableUnivariateRealFunction) f).derivative();\n+    }    \n }\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunction.java\n public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 3322454535052136809L;\n+    private static final long serialVersionUID = 3322454535052136809L;\n     \n     /**\n      * The coefficients of the polynomial, ordered by degree -- i.e.,  \n--- a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public class PolynomialSplineFunction implements UnivariateRealFunction, Serializable {\n+public class PolynomialSplineFunction \n+    implements DifferentiableUnivariateRealFunction, Serializable {\n    \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 7011031166416885789L;\n+    private static final long serialVersionUID = 7011031166416885789L;\n     \n     /** Spline segment interval delimiters (knots).   Size is n+1 for n segments. */\n     private double knots[];\n--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n public class SecantSolver extends UnivariateRealSolverImpl implements Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 1984971194738974867L;\n+    private static final long serialVersionUID = 1984971194738974867L;\n     \n     /**\n      * Construct a solver for the given function.\n--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n package org.apache.commons.math.analysis;\n \n /**\n- * Computes a natural (a.k.a. \"free\", \"unclamped\") cubic spline interpolation for the data set.\n+ * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n  * <p>\n  * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}\n  * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  \n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n     Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 1112491292565386596L;\n+    private static final long serialVersionUID = 1112491292565386596L;\n     \n     /** Maximum absolute error. */\n     protected double absoluteAccuracy;\n      */\n     protected boolean isBracketing(double lower, double upper, \n             UnivariateRealFunction f) throws FunctionEvaluationException {\n-    \tdouble f1 = f.value(lower);\n-    \tdouble f2 = f.value(upper);\n-    \treturn ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n+        double f1 = f.value(lower);\n+        double f2 = f.value(upper);\n+        return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n /*\n- * Copyright 2003-2004 The Apache Software Foundation.\n+ * Copyright 2003-2005 The Apache Software Foundation.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n /**\n  * Representation of a Complex number - a number which has both a \n  * real and imaginary part.\n+ * <p>\n+ * Implementations of arithmetic operations handle <code>NaN</code> and\n+ * infinite values according to the rules for {@link java.lang.Double}\n+ * arithmetic, applying definitional formulas and returning <code>NaN</code> or\n+ * infinite values in real or imaginary parts as these arise in computation. \n+ * See individual method javadocs for details.\n+ * <p>\n+ * {@link #equals} identifies all values with <code>NaN</code> in either real \n+ * or imaginary part - e.g., <pre>\n+ * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre>\n  *\n  * @author Apache Software Foundation\n  * @version $Revision$ $Date$\n public class Complex implements Serializable  {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -6530173849413811929L;\n-    \n-    /** The square root of -1. A number representing \"0.0 + 1.0i\".*/    \n+    private static final long serialVersionUID = -6530173849413811929L;\n+    \n+    /** The square root of -1. A number representing \"0.0 + 1.0i\" */    \n     public static final Complex I = new Complex(0.0, 1.0);\n     \n-    /** A complex number analogous to {@link java.lang.Double#NaN} */\n+    /** A complex number representing \"NaN + NaNi\" */\n     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n \n     /** A complex number representing \"1.0 + 0.0i\" */    \n     public static final Complex ONE = new Complex(1.0, 0.0);\n     \n-    /** The imaginary part. */\n+    /** A complex number representing \"0.0 + 0.0i\" */    \n+    public static final Complex ZERO = new Complex(0.0, 0.0);\n+    \n+    /** The imaginary part */\n     protected double imaginary;\n     \n-    /** The real part. */\n+    /** The real part */\n     protected double real;\n     \n     /**\n      * Create a complex number given the real and imaginary parts.\n      *\n-     * @param real the real part.\n-     * @param imaginary the imaginary part.\n+     * @param real the real part\n+     * @param imaginary the imaginary part\n      */\n     public Complex(double real, double imaginary) {\n         super();\n \n     /**\n      * Return the absolute value of this complex number.\n-     *\n-     * @return the absolute value.\n+     * <p>\n+     * Returns <code>NaN</code> if either real or imaginary part is\n+     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n+     * neither part is <code>NaN</code>, but at least one part takes an infinite\n+     * value.\n+     *\n+     * @return the absolute value\n      */\n     public double abs() {\n         if (isNaN()) {\n             return Double.NaN;\n         }\n+        \n+        if (isInfinite()) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        \n         if (Math.abs(real) < Math.abs(imaginary)) {\n             if (imaginary == 0.0) {\n                 return Math.abs(real);\n     \n     /**\n      * Return the sum of this complex number and the given complex number.\n-     *\n-     * @param rhs the other complex number.\n-     * @return the complex number sum.\n-     */\n-    public Complex add(Complex rhs) {\n-        if (isNaN() || rhs.isNaN()) {\n-            return NaN;\n-        }\n-        \n+     * <p>\n+     * Uses the definitional formula \n+     * <pre>\n+     * (a + bi) + (c + di) = (a+c) + (b+d)i\n+     * </pre>\n+     * <p>\n+     * If either this or <code>rhs</code> has a NaN value in either part,\n+     * {@link #NaN} is returned; otherwise Inifinite and NaN values are\n+     * returned in the parts of the result according to the rules for\n+     * {@link java.lang.Double} arithmetic. \n+     *\n+     * @param rhs the other complex number\n+     * @return the complex number sum\n+     * @throws NullPointerException if <code>rhs</code> is null\n+     */\n+    public Complex add(Complex rhs) {   \n         return new Complex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n     \n     /**\n-     * Return the conjugate of this complex number.  The conjugate of\n-     * \"A + Bi\" is \"A - Bi\".  Complex.NaN is returned if either the real or imaginary part of \n-     * this Complex number equals Double.NaN.\n+     * Return the conjugate of this complex number. The conjugate of\n+     * \"A + Bi\" is \"A - Bi\". \n+     * <p>\n+     * {@link #NaN} is returned if either the real or imaginary\n+     * part of this Complex number equals <code>Double.NaN</code>.\n+     * <p>\n+     * If the imaginary part is infinite, and the real part is not NaN, \n+     * the returned value has infinite imaginary part of the opposite\n+     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n+     * is <code>1 - NEGATIVE_INFINITY i</code>\n      *\n      * @return the conjugate of this Complex object\n      */\n     public Complex conjugate() {\n         if (isNaN()) {\n             return NaN;\n-        }\n-        \n+        }   \n         return new Complex(real, -imaginary);\n     }\n     \n     /**\n      * Return the quotient of this complex number and the given complex number.\n-     * @param rhs the other complex number.\n-     * @return the complex number quotient.\n+     * <p>\n+     * Implements the definitional formula\n+     * <pre><code>\n+     *    a + bi          ac + bd + (bc - ad)i\n+     *    ----------- = -------------------------\n+     *    c + di               c<sup>2</sup> + d<sup>2</sup>\n+     * </code></pre>\n+     * but uses \n+     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n+     * prescaling of operands</a> to limit the effects of overflows and\n+     * underflows in the computation.\n+     * <p>\n+     * Infinite and NaN values are handled / returned according to the\n+     * following rules, applied in the order presented:\n+     * <ul>\n+     * <li>If either this or <code>rhs</code> has a NaN value in either part,\n+     *  {@link #NaN} is returned.</li>\n+     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.\n+     * </li>\n+     * <li>If this and <code>rhs</code> are both infinite,\n+     * {@link #NaN} is returned.</li>\n+     * <li>If this is finite (i.e., has no infinite or NaN parts) and\n+     *  <code>rhs</code> is infinite (one or both parts infinite), \n+     * {@link #ZERO} is returned.</li>\n+     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n+     * returned in the parts of the result if the {@link java.lang.Double}\n+     * rules applied to the definitional formula force NaN results.</li>\n+     * </ul>\n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number quotient\n+     * @throws NullPointerException if <code>rhs</code> is null\n      */\n     public Complex divide(Complex rhs) {\n         if (isNaN() || rhs.isNaN()) {\n         double c = rhs.getReal();\n         double d = rhs.getImaginary();\n         if (c == 0.0 && d == 0.0) {\n-            throw new ArithmeticException(\"Error: division by zero.\");\n+            return NaN;\n+        }\n+        \n+        if (rhs.isInfinite() && !isInfinite()) {\n+            return ZERO;\n         }\n \n         if (Math.abs(c) < Math.abs(d)) {\n      * <p>\n      * All <code>NaN</code> values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal\n-     * to Double.NaN, the complex number is equal to \n+     * to <code>Double.NaN</code>, the complex number is equal to \n      * <code>Complex.NaN</code>.\n      *\n      * @param other Object to test for equality to this\n      * @return true if two Complex objects are equal, false if\n      *         object is null, not an instance of Complex, or\n-     *         not equal to this Complex instance.\n+     *         not equal to this Complex instance\n      * \n      */\n     public boolean equals(Object other) {\n     /**\n      * Access the imaginary part.\n      *\n-     * @return the imaginary part.\n+     * @return the imaginary part\n      */\n     public double getImaginary() {\n         return imaginary;\n     /**\n      * Access the real part.\n      *\n-     * @return the real part.\n+     * @return the real part\n      */\n     public double getReal() {\n         return real;\n     }\n     \n     /**\n-     * Returns true if this complex number is the special Not-a-Number (NaN)\n-     * value.\n-     *\n-     * @return true if the value represented by this object is NaN; false\n-     *         otherwise.\n+     * Returns true if either or both parts of this complex number is NaN;\n+     * false otherwise\n+     *\n+     * @return  true if either or both parts of this complex number is NaN;\n+     * false otherwise\n      */\n     public boolean isNaN() {\n         return Double.isNaN(real) || Double.isNaN(imaginary);        \n     }\n     \n     /**\n+     * Returns true if either the real or imaginary part of this complex number\n+     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or \n+     * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n+     * is <code>NaN</code>.\n+     * \n+     * @return true if one or both parts of this complex number are infinite\n+     * and neither part is <code>NaN</code>\n+     */\n+    public boolean isInfinite() {\n+        return !isNaN() && \n+        (Double.isInfinite(real) || Double.isInfinite(imaginary));        \n+    }\n+    \n+    /**\n      * Return the product of this complex number and the given complex number.\n-     *\n-     * @param rhs the other complex number.\n-     * @return the complex number product.\n+     * <p>\n+     * Implements the definitional formula:\n+     * <pre><code>\n+     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n+     * </code></pre>\n+     * <p>\n+     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n+     * NaN parts.\n+     * <p>\n+     * Returns NaN or infinite values in components of the result per the\n+     * definitional formula and and the rules for {@link java.lang.Double}\n+     * arithmetic.  Examples:\n+     * <pre><code>\n+     *  (1 + i) (INF + i)  =  INF + INFi\n+     *  (1 + INFi) (1 - INFi) = INF + NaNi\n+     *  (-INF + -INFi)(1 + NaNi) = NaN + NaNi\n+     *  </code></pre>\n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number product\n+     * @throws NullPointerException if <code>rhs</code> is null\n      */\n     public Complex multiply(Complex rhs) {\n         if (isNaN() || rhs.isNaN()) {\n             return NaN;\n         }\n-        \n-        double p = (real + imaginary) * (rhs.getReal() + rhs.getImaginary());\n-        double ac = real * rhs.getReal();\n-        double bd = imaginary * rhs.getImaginary();\n-        return new Complex(ac - bd, p - ac - bd);\n+        return new Complex(real * rhs.real - imaginary * rhs.imaginary,\n+                real * rhs.imaginary + imaginary * rhs.real);\n     }\n     \n     /**\n      * Return the additive inverse of this complex number.\n-     *\n-     * @return the negation of this complex number.\n+     * <p>\n+     * Returns <code>Complex.NaN</code> if either real or imaginary\n+     * part of this Complex number equals <code>Double.NaN</code>.\n+     *\n+     * @return the negation of this complex number\n      */\n     public Complex negate() {\n         if (isNaN()) {\n     /**\n      * Return the difference between this complex number and the given complex\n      * number.\n-     *\n-     * @param rhs the other complex number.\n-     * @return the complex number difference.\n+      * <p>\n+     * Uses the definitional formula \n+     * <pre>\n+     * (a + bi) - (c + di) = (a-c) + (b-d)i\n+     * </pre>\n+     * <p>\n+     * If either this or <code>rhs</code> has a NaN value in either part,\n+     * {@link #NaN} is returned; otherwise inifinite and NaN values are\n+     * returned in the parts of the result according to the rules for\n+     * {@link java.lang.Double} arithmetic. \n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number difference\n+     * @throws NullPointerException if <code>rhs</code> is null\n      */\n     public Complex subtract(Complex rhs) {\n         if (isNaN() || rhs.isNaN()) {\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n public class ComplexFormat extends Format implements Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -6337346779577272306L;\n+    private static final long serialVersionUID = -6337346779577272306L;\n     \n     /** The default imaginary character. */\n     private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n--- a/src/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexUtils.java\n /*\n- * Copyright 2003-2004 The Apache Software Foundation.\n+ * Copyright 2003-2005 The Apache Software Foundation.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Implementations of various transcendental functions for\n- * {@link org.apache.commons.math.complex.Complex} arguments.\n- *\n+ * Static implementations of common \n+ * {@link org.apache.commons.math.complex.Complex}-valued functions.  Included\n+ * are trigonometric, exponential, log, power and square root functions.\n+ *<p>\n  * Reference:\n  * <ul>\n  * <li><a href=\"http://myweb.lmu.edu/dmsmith/ZMLIB.pdf\">\n  * Multiple Precision Complex Arithmetic and Functions</a></li>\n  * </ul>\n+ * See individual method javadocs for the computational formulas used.\n+ * In general, NaN values in either real or imaginary parts of input arguments\n+ * result in {@link Complex#NaN} returned.  Otherwise, infinite or NaN values\n+ * are returned as they arise in computing the real functions specified in the\n+ * computational formulas.  Null arguments result in NullPointerExceptions.\n  *\n  * @version $Revision$ $Date$\n  */\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/InverseCosine.html\">\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n      * inverse cosine</a> for the given complex argument.\n-     * @param z the value whose inverse cosine is to be returned.\n-     * @return the inverse cosine of <code>z</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.\n+     * \n+     * @param z the value whose inverse cosine is to be returned\n+     * @return the inverse cosine of <code>z</code>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex acos(Complex z) {\n         if (z.isNaN()) {\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/InverseSine.html\">\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n      * inverse sine</a> for the given complex argument.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.\n+     * \n      * @param z the value whose inverse sine is to be returned.\n      * @return the inverse sine of <code>z</code>.\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex asin(Complex z) {\n         if (z.isNaN()) {\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/InverseTangent.html\">\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n      * inverse tangent</a> for the given complex argument.\n-     * @param z the value whose inverse tangent is to be returned.\n-     * @return the inverse tangent of <code>z</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite. \n+     * \n+     * @param z the value whose inverse tangent is to be returned\n+     * @return the inverse tangent of <code>z</code>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex atan(Complex z) {\n         if (z.isNaN()) {\n             return Complex.NaN;\n         }\n-        \n         \n         return Complex.I.multiply(\n             log(Complex.I.add(z).divide(Complex.I.subtract(z))))\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/Cosine.html\">cosine</a>\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n+     * cosine</a>\n      * for the given complex argument.\n-     * @param z the value whose cosine is to be returned.\n-     * @return the cosine of <code>z</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n+     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n+     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * \n+     * @param z the value whose cosine is to be returned\n+     * @return the cosine of <code>z</code>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex cos(Complex z) {\n         if (z.isNaN()) {\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n      * hyperbolic cosine</a> for the given complex argument.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n+     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * <p>\n+     * Throws <code>NullPointerException</code> if z is null.\n+     * \n      * @param z the value whose hyperbolic cosine is to be returned.\n      * @return the hyperbolic cosine of <code>z</code>.\n      */\n     \n     /**\n      * Compute the\n-     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\">\n+     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n      * exponential function</a> for the given complex argument.\n-     * @param z the value.\n-     * @return <i>e</i><sup><code>z</code></sup>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n+     * {@link java.lang.Math#sin}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * exp(INFINITY + i) = INFINITY + INFINITY i\n+     * exp(-INFINITY + i) = 0 + 0i\n+     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * <p>\n+     * Throws <code>NullPointerException</code> if z is null.\n+     * \n+     * @param z the value\n+     * @return <i>e</i><sup><code>z</code></sup>\n      */\n     public static Complex exp(Complex z) {\n         if (z.isNaN()) {\n         \n         double b = z.getImaginary();\n         double expA = Math.exp(z.getReal());\n-        double sinB = Math.sin(b);\n-        double cosB = Math.cos(b);\n-        return new Complex(expA * cosB, expA * sinB);\n-    }\n-    \n-    /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\">\n+        return new Complex(expA *  Math.cos(b), expA * Math.sin(b));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n      * natural logarithm</a> for the given complex argument.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n+     * where ln on the right hand side is {@link java.lang.Math#log},\n+     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n+     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite (or critical) values in real or imaginary parts of the input may\n+     * result in infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n+     * log(INFINITY + i) = INFINITY + 0i\n+     * log(-INFINITY + i) = INFINITY + &pi;i\n+     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n+     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n+     * log(0 + 0i) = -INFINITY + 0i\n+     * </code></pre>\n+     * Throws <code>NullPointerException</code> if z is null.\n+     * \n      * @param z the value.\n      * @return ln <code>z</code>.\n      */\n             Math.atan2(z.getImaginary(), z.getReal()));        \n     }\n     \n+    /**\n+     * Creates a complex number from the given polar representation.\n+     * <p>\n+     * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n+     * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code>\n+     * <p>\n+     * If either <code>r</code> or <code>theta</code> is NaN, or \n+     * <code>theta</code> is infinite, {@link Complex#NaN} is returned.\n+     * <p>\n+     * If <code>r</code> is infinite and <code>theta</code> is finite, \n+     * infinite or NaN values may be returned in parts of the result, following\n+     * the rules for double arithmetic.<pre>\n+     * Examples: \n+     * <code>\n+     * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n+     * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n+     * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n+     * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre>\n+     * \n+     * @param r the modulus of the complex number to create\n+     * @param theta  the argument of the complex number to create\n+     * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n+     * @throws IllegalArgumentException  if r is negative\n+     * @since 1.1\n+     */\n+    public static Complex polar2Complex(double r, double theta) {\n+        if (r < 0) {\n+            throw new IllegalArgumentException\n+                (\"Complex modulus must not be negative\");\n+        }\n+        return new Complex(r * Math.cos(theta), r * Math.sin(theta));\n+    }\n     \n     /**\n      * Returns of value of <code>y</code> raised to the power of <code>x</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> \n+     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n+     * {@link #log}, respectively.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n+     * equals {@link Complex#ZERO}.\n+     * \n      * @param y the base.\n      * @param x the exponent.\n-     * @return <code>y</code><sup><code>z</code></sup>.\n+     * @return <code>y</code><sup><code>x</code></sup>\n+     * @throws NullPointerException if either x or y is null\n      */\n     public static Complex pow(Complex y, Complex x) {\n         return exp(x.multiply(log(y)));\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/Sine.html\">sine</a>\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n+     * sine</a>\n      * for the given complex argument.\n+     * <p>\n+      * Implements the formula: <pre>\n+     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n+     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n+     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n+     * \n+     * Throws <code>NullPointerException</code> if z is null. \n+     * \n      * @param z the value whose sine is to be returned.\n      * @return the sine of <code>z</code>.\n      */\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n      * hyperbolic sine</a> for the given complex argument.\n-     * @param z the value whose hyperbolic sine is to be returned.\n-     * @return the hyperbolic sine of <code>z</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n+     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre\n+     * \n+     * @param z the value whose hyperbolic sine is to be returned\n+     * @return the hyperbolic sine of <code>z</code>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex sinh(Complex z) {\n         if (z.isNaN()) {\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/SquareRoot.html\">squre\n-     * root</a> for the given complex argument.\n-     * @param z the value whose square root is to be returned.\n-     * @return the square root of <code>z</code>.\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n+     * square root</a> for the given complex argument.\n+     * <p>\n+     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>: \n+     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n+     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n+     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n+     * </ol>\n+     * where <ul>\n+     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n+     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n+     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n+     * </ul>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n+     * sqrt(INFINITY + i) = INFINITY + 0i\n+     * sqrt(-INFINITY + i) = 0 + INFINITY i\n+     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n+     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n+     * </code></pre>\n+     * \n+     * @param z the value whose square root is to be returned\n+     * @return the square root of <code>z</code>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex sqrt(Complex z) {\n         if (z.isNaN()) {\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/SquareRoot.html\">squre\n-     * root of 1 - <code>z</code><sup>2</sup> for the given complex argument.\n-     * @param z the value.\n-     * @return the square root of 1 - <code>z</code><sup>2</sup>.\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n+     * square root</a> of 1 - <code>z</code><sup>2</sup> for the given complex\n+     * argument.\n+     * <p>\n+     * Computes the result directly as \n+     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result. \n+     * \n+     * @param z the value\n+     * @return the square root of 1 - <code>z</code><sup>2</sup>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex sqrt1z(Complex z) {\n         return sqrt(Complex.ONE.subtract(z.multiply(z)));\n     }\n     \n     /**\n-     * Compute the <a href=\"http://mathworld.wolfram.com/Tangent.html\">\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n      * tangent</a> for the given complex argument.\n-     * @param z the value whose tangent is to be returned.\n-     * @return the tangent of <code>z</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite (or critical) values in real or imaginary parts of the input may\n+     * result in infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n+     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n+     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     * tan(&plusmn;&pi/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre>\n+     * \n+     * @param z the value whose tangent is to be returned\n+     * @return the tangent of <code>z</code>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex tan(Complex z) {\n         if (z.isNaN()) {\n     \n     /**\n      * Compute the\n-     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\">\n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n      * hyperbolic tangent</a> for the given complex argument.\n-     * @param z the value whose hyperbolic tangent is to be returned.\n-     * @return the hyperbolic tangent of <code>z</code>.\n+    * <p>\n+     * Implements the formula: <pre>\n+     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n+     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     * tanh(0 + (&pi/2)i) = NaN + INFINITY i</code></pre>\n+     *\n+     * @param z the value whose hyperbolic tangent is to be returned\n+     * @return the hyperbolic tangent of <code>z</code>\n+     * @throws NullPointerException if <code>z</code> is null\n      */\n     public static Complex tanh(Complex z) {\n         if (z.isNaN()) {\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n     implements ContinuousDistribution, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -38038050983108802L;\n+    private static final long serialVersionUID = -38038050983108802L;\n     \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractDistribution.java\n     implements Distribution, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -38038050983108802L;\n+    private static final long serialVersionUID = -38038050983108802L;\n     \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n     implements IntegerDistribution, Serializable {\n         \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -1146319659338487221L;\n+    private static final long serialVersionUID = -1146319659338487221L;\n     \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n     implements BinomialDistribution, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 6751309484392813623L;\n+    private static final long serialVersionUID = 6751309484392813623L;\n \n     /** The number of trials. */\n     private int numberOfTrials;\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n         implements CauchyDistribution, Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 8589540077390120676L;\n+    private static final long serialVersionUID = 8589540077390120676L;\n \n     /** The median of this distribution. */\n     private double median = 0;\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     implements ChiSquaredDistribution, Serializable  {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -8352658048349159782L;\n+    private static final long serialVersionUID = -8352658048349159782L;\n \n     /** Internal Gamma distribution. */    \n     private GammaDistribution gamma;\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n import org.apache.commons.math.MathException;\n \n /**\n- * The default implementation of {@link ExponentialDistribution}\n+ * The default implementation of {@link ExponentialDistribution}.\n  *\n  * @version $Revision$ $Date$\n  */\n     implements ExponentialDistribution, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 2401296428283614780L;\n+    private static final long serialVersionUID = 2401296428283614780L;\n     \n     /** The mean of this distribution. */\n     private double mean;\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n     implements FDistribution, Serializable  {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -8516354193418641566L;\n+    private static final long serialVersionUID = -8516354193418641566L;\n \n     /** The numerator degrees of freedom*/\n     private double numeratorDegreesOfFreedom;\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n import org.apache.commons.math.special.Gamma;\n \n /**\n- * The default implementation of {@link GammaDistribution}\n+ * The default implementation of {@link GammaDistribution}.\n  *\n  * @version $Revision$ $Date$\n  */\n     implements GammaDistribution, Serializable  {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -3239549463135430361L;\n+    private static final long serialVersionUID = -3239549463135430361L;\n \n     /** The shape parameter. */\n     private double alpha;\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -436928820673516179L;\n+    private static final long serialVersionUID = -436928820673516179L;\n \n     /** The number of successes in the population. */\n     private int numberOfSuccesses;\n         super();\n         if (numberOfSuccesses > populationSize) {\n             throw new IllegalArgumentException(\n-            \t\"number of successes must be less than or equal to \" +\n-            \t\"population size\");\n+                \"number of successes must be less than or equal to \" +\n+                \"population size\");\n         }\n         if (sampleSize > populationSize) {\n             throw new IllegalArgumentException(\n         populationSize = size;\n     }\n     \n-\t/**\n+    /**\n      * Modify the sample size.\n      * @param size the new sample size.\n      * @throws IllegalArgumentException if <code>size</code> is negative.\n      * @return upper tail CDF for this distribution.\n      * @since 1.1\n      */\n-\tpublic double upperCumulativeProbability(int x) {\n-    \tdouble ret;\n-    \t\n+    public double upperCumulativeProbability(int x) {\n+        double ret;\n+        \n         int n = getPopulationSize();\n         int m = getNumberOfSuccesses();\n         int k = getSampleSize();\n         } else if(x > domain[1]) {\n             ret = 0.0;\n         } else {\n-        \tret = innerCumulativeProbability(domain[1], x, -1, n, m, k);\n+            ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);\n         }\n         \n         return ret;\n     }\n-\t\n+    \n     /**\n      * For this disbution, X, this method returns P(x0 &le; X &le; x1).  This\n      * probability is computed by summing the point probabilities for the values\n      * @return P(x0 &le; X &le; x1). \n      */\n     private double innerCumulativeProbability(\n-    \tint x0, int x1, int dx, int n, int m, int k)\n+        int x0, int x1, int dx, int n, int m, int k)\n     {\n-    \tdouble ret = probability(n, m, k, x0);\n-    \twhile (x0 != x1) {\n-    \t\tx0 += dx;\n-    \t\tret += probability(n, m, k, x0);\n-    \t}\n-\t\treturn ret;\n-\t}\n+        double ret = probability(n, m, k, x0);\n+        while (x0 != x1) {\n+            x0 += dx;\n+            ret += probability(n, m, k, x0);\n+        }\n+        return ret;\n+    }\n }\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n         implements NormalDistribution, Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 8589540077390120676L;\n+    private static final long serialVersionUID = 8589540077390120676L;\n \n     /** The mean of this distribution. */\n     private double mean = 0;\n--- a/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Implementation for the {@link PoissonDistribution}\n+ * Implementation for the {@link PoissonDistribution}.\n  * \n  * @version $Revision$ $Date$\n  */\n         implements PoissonDistribution, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -3349935121172596109L;\n+    private static final long serialVersionUID = -3349935121172596109L;\n     \n     /**\n      * Holds the Poisson mean for the distribution.\n--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n     implements TDistribution, Serializable  {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -5852615386664158222L;\n+    private static final long serialVersionUID = -5852615386664158222L;\n     \n     /** The degrees of freedom*/\n     private double degreesOfFreedom;\n--- a/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n         implements WeibullDistribution, Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 8589540077390120676L;\n+    private static final long serialVersionUID = 8589540077390120676L;\n     \n     /** The shape parameter. */\n     private double alpha;\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n     public static final Fraction ZERO = new Fraction(0, 1);\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 65382027393090L;\n+    private static final long serialVersionUID = 65382027393090L;\n     \n     /** The denominator. */\n     private int denominator;\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n public class FractionFormat extends Format implements Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -6337346779577272306L;\n+    private static final long serialVersionUID = -6337346779577272306L;\n \n     /** The format used for the denominator. */\n     private NumberFormat denominatorFormat;\n--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n public class ProperFractionFormat extends FractionFormat {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -6337346779577272307L;\n+    private static final long serialVersionUID = -6337346779577272307L;\n     \n     /** The format used for the whole number. */\n     private NumberFormat wholeFormat;\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n import java.math.BigDecimal;\n \n /**\n- * Implementation for {@link BigMatrix} using a BigDecimal[][] array to store entries\n+ * Implementation of {@link BigMatrix} using a BigDecimal[][] array to store entries\n  * and <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n  * LU decompostion</a> to support linear system \n  * solution and inverse.\n public class BigMatrixImpl implements BigMatrix, Serializable {\n     \n     /** Serialization id */\n-    static final long serialVersionUID = -1011428905656140431L;\n+    private static final long serialVersionUID = -1011428905656140431L;\n     \n     /** Entries of the matrix */\n     private BigDecimal data[][] = null;\n--- a/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n public class InvalidMatrixException extends RuntimeException {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 5318837237354354107L;\n+    private static final long serialVersionUID = 5318837237354354107L;\n \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n public class MatrixIndexException extends RuntimeException {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -1341109412864309526L;\n+    private static final long serialVersionUID = -1341109412864309526L;\n \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n \n \n /**\n- * Implementation for RealMatrix using a double[][] array to store entries and\n+ * Implementation of RealMatrix using a double[][] array to store entries and\n  * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n  * LU decompostion</a> to support linear system\n  * solution and inverse.\n public class RealMatrixImpl implements RealMatrix, Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 4237564493130426188L;\n+    private static final long serialVersionUID = 4237564493130426188L;\n \n     /** Entries of the matrix */\n     private double data[][] = null;\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -6773236347582113490L;\n+    private static final long serialVersionUID = -6773236347582113490L;\n \n     /** List of SummaryStatistics objects characterizing the bins */\n     private ArrayList binStats = null;\n \n     /** Sample statistics */\n-    SummaryStatistics sampleStats = null;\n+    private SummaryStatistics sampleStats = null;\n \n     /** number of bins */\n     private int binCount = 1000;\n     private class StreamDataAdapter extends DataAdapter{\n         \n         /** Input stream providng access to the data */\n-        BufferedReader inputStream;\n+        private BufferedReader inputStream;\n         \n         /**\n          * Create a StreamDataAdapter from a BufferedReader\n      * @param min  the minimum value\n      * @param value  the value whose bin we are trying to find\n      * @param delta  the grid size\n-     * @return\n+     * @return the index of the bin containing the value\n      */\n     private int findBin(double min, double value, double delta) {\n         return Math.min(\n     }\n \n     /**\n-     * Returns the array of upper bounds for the bins.  Bins are: <br/>\n+     * Returns (a fresh copy of) the array of upper bounds for the bins.\n+       Bins are: <br/>\n      * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n      *  (upperBounds[binCount-1],max]\n      * \n      * @return array of bin upper bounds\n      */\n     public double[] getUpperBounds() {\n-        return upperBounds;\n+        int len = upperBounds.length;\n+        double[] out = new double[len];\n+        System.arraycopy(upperBounds, 0, out, 0, len);\n+        return out;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/random/RandomData.java\n+++ b/src/java/org/apache/commons/math/random/RandomData.java\n import java.util.Collection;\n \n /**\n- * Random data generation utilities\n+ * Random data generation utilities.\n  * @version $Revision$ $Date$\n  */\n public interface RandomData {\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n public class RandomDataImpl implements RandomData, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -626730818244969716L;\n+    private static final long serialVersionUID = -626730818244969716L;\n \n     /** underlying random number generator */\n     private RandomGenerator rand = null;\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n public class Frequency implements Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -3845586908418844111L;\n+    private static final long serialVersionUID = -3845586908418844111L;\n \n     /** underlying collection */\n     private TreeMap freqTable = null;\n--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n \n /**\n  *\n- * Abstract Implementation for the {@link StorelessUnivariateStatistic} interface.\n+ * Abstract implementation of the {@link StorelessUnivariateStatistic} interface.\n  * <p>\n  * Provides default <code>evaluate()</code> and <code>incrementAll(double[])<code>\n  * implementations. \n     implements StorelessUnivariateStatistic, Serializable {\n \n     /** Serialization UID */\n-    static final long serialVersionUID = -44915725420072521L;\n+    private static final long serialVersionUID = -44915725420072521L;\n     \n     /**\n      * This default implementation calls {@link #clear}, then invokes \n--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n     implements UnivariateStatistic, Serializable {\n     \n     /** Serialization UID */\n-    static final long serialVersionUID = -8007759382851708045L;\n+    private static final long serialVersionUID = -8007759382851708045L;\n \n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n public abstract class DescriptiveStatistics implements StatisticalSummary, Serializable {\n     \n     /** Serialization UID */\n-    static final long serialVersionUID = 5188298269533339922L;\n+    private static final long serialVersionUID = 5188298269533339922L;\n     \n     /**\n      * Create an instance of a <code>DescriptiveStatistics</code>\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java\n public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -1868088725461221010L;\n+    private static final long serialVersionUID = -1868088725461221010L;\n     \n     /** hold the window size **/\n     protected int windowSize;\n--- a/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n     StatisticalSummary {\n    \n     /** Serialization id */\n-    static final long serialVersionUID = -5108854841843722536L;\n+    private static final long serialVersionUID = -5108854841843722536L;\n \n     /** The sample mean */\n     private final double mean;\n--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n public abstract class SummaryStatistics implements StatisticalSummary, Serializable {\n \n     /** Serialization UID */\n-    static final long serialVersionUID = -6400596334135654825L;\n+    private static final long serialVersionUID = -6400596334135654825L;\n      \n     /**\n      * Create an instance of a <code>SummaryStatistics</code>\n--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsImpl.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsImpl.java\n public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 8787174276883311692L;\n+    private static final long serialVersionUID = 8787174276883311692L;\n \n     /** count of values that have been added */\n     protected long n = 0;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n     implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -803343206421984070L; \n+    private static final long serialVersionUID = -803343206421984070L; \n     \n     /** Count of values that have been added */\n     protected long n;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n public class FourthMoment extends ThirdMoment implements Serializable{\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 4763990447117157611L;\n+    private static final long serialVersionUID = 4763990447117157611L;\n         \n     /** fourth moment of values that have been added */\n     protected double m4;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n public class GeometricMean extends AbstractStorelessUnivariateStatistic {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -8178734905303459453L;  \n+    private static final long serialVersionUID = -8178734905303459453L;  \n     \n     /** Wrapped SumOfLogs instance */\n     private SumOfLogs sumOfLogs;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n public class Kurtosis extends AbstractStorelessUnivariateStatistic  {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 2784465764798260919L;  \n+    private static final long serialVersionUID = 2784465764798260919L;  \n       \n     /**Fourth Moment on which this statistic is based */\n     protected FourthMoment moment;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n     implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -1296043746617791564L;    \n+    private static final long serialVersionUID = -1296043746617791564L;    \n     \n     /** First moment on which this statistic is based. */\n     protected FirstMoment moment;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n public class SecondMoment extends FirstMoment implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 3942403127395076445L;  \n+    private static final long serialVersionUID = 3942403127395076445L;  \n       \n     /** second moment of values that have been added */\n     protected double m2;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 7101857578996691352L;    \n+    private static final long serialVersionUID = 7101857578996691352L;    \n     \n     /** Third moment on which this statistic is based */\n     protected ThirdMoment moment = null;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n     implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 5728716329662425188L;  \n+    private static final long serialVersionUID = 5728716329662425188L;  \n     \n     /** Wrapped Variance instance */\n     private Variance variance = null;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n public class ThirdMoment extends SecondMoment implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -7818711964045118679L;  \n+    private static final long serialVersionUID = -7818711964045118679L;  \n       \n     /** third moment of values that have been added */\n     protected double m3;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -9111962718267217978L;  \n+    private static final long serialVersionUID = -9111962718267217978L;  \n       \n     /** SecondMoment is used in incremental calculation of Variance*/\n     protected SecondMoment moment = null;\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n public class Max extends AbstractStorelessUnivariateStatistic {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -5593383832225844641L;    \n+    private static final long serialVersionUID = -5593383832225844641L;    \n     \n     /** Number of values that have been added */\n     private long n;\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n public class Median extends Percentile implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -3961477041290915687L;    \n+    private static final long serialVersionUID = -3961477041290915687L;    \n \n     /**\n      * Default constructor.\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -2941995784909003131L;  \n+    private static final long serialVersionUID = -2941995784909003131L;  \n       \n     /**Number of values that have been added */\n     private long n;\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n public class Percentile extends AbstractUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -8091216485095130416L; \n+    private static final long serialVersionUID = -8091216485095130416L; \n        \n     /** Determines what percentile is computed when evaluate() is activated \n      * with no quantile argument */\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 2824226005990582538L;   \n+    private static final long serialVersionUID = 2824226005990582538L;   \n      \n     /**The number of values that have been added */\n     private long n;\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -8231831954703408316L;  \n+    private static final long serialVersionUID = -8231831954703408316L;  \n       \n     /** */\n     private long n;\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -370076995648386763L;    \n+    private static final long serialVersionUID = -370076995648386763L;    \n \n     /**Number of values that have been added */\n     private int n;\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 1460986908574398008L;  \n+    private static final long serialVersionUID = 1460986908574398008L;  \n       \n     /** */\n     private long n;\n--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n public class SimpleRegression implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -3004689053607543335L;\n+    private static final long serialVersionUID = -3004689053607543335L;\n \n     /** sum of x values */\n     private double sumX = 0d;\n--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n public abstract class ContinuedFraction implements Serializable {\n     \n     /** Serialization UID */\n-    static final long serialVersionUID = 1768555336266158242L;\n+    private static final long serialVersionUID = 1768555336266158242L;\n     \n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 10e-9;\n     public double evaluate(double x, double epsilon, int maxIterations)\n         throws MathException\n     {\n-    \tdouble p0 = 1.0;\n-    \tdouble p1 = getA(0, x);\n-    \tdouble q0 = 0.0;\n-    \tdouble q1 = 1.0;\n-    \tdouble c = p1 / q1;\n-    \tint n = 0;\n-    \tdouble relativeError = Double.MAX_VALUE;\n-    \twhile (n < maxIterations && relativeError > epsilon) {\n-    \t\t++n;\n-    \t\tdouble a = getA(n, x);\n-    \t\tdouble b = getB(n, x);\n-  \t\t\tdouble p2 = a * p1 + b * p0;\n-   \t\t\tdouble q2 = a * q1 + b * q0;\n-   \t\t\tif (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n-   \t\t\t\t// need to scale\n-   \t\t\t\tif (a != 0.0) {\n-   \t\t\t\t\tp2 = p1 + (b / a * p0);\n-   \t\t\t\t\tq2 = q1 + (b / a * q0);\n-   \t\t\t\t} else if (b != 0) {\n-   \t\t\t\t\tp2 = (a / b * p1) + p0;\n-   \t\t\t\t\tq2 = (a / b * q1) + q0;\n-   \t\t\t\t} else {\n-   \t\t\t\t\t// can not scale an convergent is unbounded.\n-   \t\t            throw new ConvergenceException(\n-   \t                \t\"Continued fraction convergents diverged to +/- \" +\n-   \t                \t\"infinity.\");\n-   \t\t\t\t}\n-   \t\t\t}\n-   \t\t\tdouble r = p2 / q2;\n-   \t\t\trelativeError = Math.abs(r / c - 1.0);\n-    \t\t\t\n-   \t\t\t// prepare for next iteration\n-   \t\t\tc = p2 / q2;\n-   \t\t\tp0 = p1;\n-   \t\t\tp1 = p2;\n-   \t\t\tq0 = q1;\n-   \t\t\tq1 = q2;\n-    \t}\n+        double p0 = 1.0;\n+        double p1 = getA(0, x);\n+        double q0 = 0.0;\n+        double q1 = 1.0;\n+        double c = p1 / q1;\n+        int n = 0;\n+        double relativeError = Double.MAX_VALUE;\n+        while (n < maxIterations && relativeError > epsilon) {\n+            ++n;\n+            double a = getA(n, x);\n+            double b = getB(n, x);\n+            double p2 = a * p1 + b * p0;\n+            double q2 = a * q1 + b * q0;\n+            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n+                // need to scale\n+                if (a != 0.0) {\n+                    p2 = p1 + (b / a * p0);\n+                    q2 = q1 + (b / a * q0);\n+                } else if (b != 0) {\n+                    p2 = (a / b * p1) + p0;\n+                    q2 = (a / b * q1) + q0;\n+                } else {\n+                    // can not scale an convergent is unbounded.\n+                    throw new ConvergenceException(\n+                        \"Continued fraction convergents diverged to +/- \" +\n+                        \"infinity.\");\n+                }\n+            }\n+            double r = p2 / q2;\n+            relativeError = Math.abs(r / c - 1.0);\n+                \n+            // prepare for next iteration\n+            c = p2 / q2;\n+            p0 = p1;\n+            p1 = p2;\n+            q0 = q1;\n+            q1 = q2;\n+        }\n \n-    \tif (n >= maxIterations) {\n+        if (n >= maxIterations) {\n             throw new ConvergenceException(\n                 \"Continued fraction convergents failed to converge.\");\n         }\n--- a/src/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/java/org/apache/commons/math/util/DefaultTransformer.java\n public class DefaultTransformer implements NumberTransformer, Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = 4019938025047800455L;\n+    private static final long serialVersionUID = 4019938025047800455L;\n     \n     /**\n      * @param o  the object that gets transformed.\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n     \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -3485529955529426875L; \n+    private static final long serialVersionUID = -3485529955529426875L; \n     \n     /** additive expansion mode */\n     public static final int ADDITIVE_MODE = 1;\n--- a/src/java/org/apache/commons/math/util/TransformerMap.java\n+++ b/src/java/org/apache/commons/math/util/TransformerMap.java\n public class TransformerMap implements NumberTransformer, Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -942772950698439883L;\n+    private static final long serialVersionUID = -942772950698439883L;\n     \n     /**\n      * A default Number Transformer for Numbers and numeric Strings.\n--- a/src/test/org/apache/commons/math/TestUtils.java\n+++ b/src/test/org/apache/commons/math/TestUtils.java\n         assertEquals(null, expected, actual, delta);\n     }\n \n+    /**\n+     * Verifies that expected and actual are within delta, or are both NaN or\n+     * infinities of the same sign.\n+     */\n     public static void assertEquals(String msg, double expected, double actual, double delta) {\n         // check for NaN\n         if(Double.isNaN(expected)){\n         }\n     }\n     \n+    /*\n+     * Verifies that the two arguments are exactly the same, either\n+     * both NaN or infinities of same sign, or identical floating point values.\n+     */\n+    public static void assertSame(double expected, double actual) {\n+     assertEquals(expected, actual, 0);\n+    }\n+    \n     /**\n-     * \n+     * Verifies that real and imaginary parts of the two complex arguments\n+     * are exactly the same.  Also ensures that NaN / infinite components match.\n+     */\n+    public static void assertSame(Complex expected, Complex actual) {\n+        assertSame(expected.getReal(), actual.getReal());\n+        assertSame(expected.getImaginary(), actual.getImaginary());\n+    }\n+    \n+    /**\n+     * Verifies that real and imaginary parts of the two complex arguments\n+     * differ by at most delta.  Also ensures that NaN / infinite components match.\n      */\n     public static void assertEquals(Complex expected, Complex actual, double delta) {\n         assertEquals(expected.getReal(), actual.getReal(), delta);\n             ObjectInputStream si = new ObjectInputStream(fi);  \n             result = si.readObject();\n         } catch (Exception ex) {\n-        \t\n+            \n         } finally {\n-        \tif (fo != null) {\n-        \t\ttry {\n-        \t\t\tfo.close();\n-        \t\t} catch (IOException ex) {\n-        \t\t}\n-        \t}\n+            if (fo != null) {\n+                try {\n+                    fo.close();\n+                } catch (IOException ex) {\n+                }\n+            }\n \n-        \tif (fi != null) {\n-        \t\ttry {\n-            \t\tfi.close();\n-        \t\t} catch (IOException ex) {\n-        \t\t}\n-        \t}\n+            if (fi != null) {\n+                try {\n+                    fi.close();\n+                } catch (IOException ex) {\n+                }\n+            }\n         }\n         \n         \n         if (tmp != null) {\n-        \ttmp.delete();\n+            tmp.delete();\n         }\n         \n         return result;\n         Assert.assertEquals(\"HashCode check\", object.hashCode(), object2.hashCode());\n     }\n \n-\tpublic static void assertRelativelyEquals(double expected, double actual, double relativeError) {\n-\t\tassertRelativelyEquals(null, expected, actual, relativeError);\n-\t}\n-\t\n-\tpublic static void assertRelativelyEquals(String msg, double expected, double actual, double relativeError) {\n+    public static void assertRelativelyEquals(double expected, double actual, double relativeError) {\n+        assertRelativelyEquals(null, expected, actual, relativeError);\n+    }\n+    \n+    public static void assertRelativelyEquals(String msg, double expected, double actual, double relativeError) {\n         if (Double.isNaN(expected)) {\n             Assert.assertTrue(msg, Double.isNaN(actual));\n         } else if (Double.isNaN(actual)) {\n-        \tAssert.assertTrue(msg, Double.isNaN(expected));\n+            Assert.assertTrue(msg, Double.isNaN(expected));\n         } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {\n             Assert.assertEquals(expected, actual, relativeError);\n         } else if (expected == 0.0) {\n             double x = Math.abs((expected - actual) / expected);\n             Assert.assertEquals(msg, 0.0, x, relativeError);\n         }\n-\t}\n+    }\n }\n--- a/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java\n         expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        assertEquals(0.0, (expected.subtract(result[2])).abs(), tolerance);\n+        assertEquals(0.0, (expected.subtract(result[3])).abs(), tolerance);\n \n         expected = new Complex(-1.0, 0.0);\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        assertEquals(0.0, (expected.subtract(result[3])).abs(), tolerance);\n+        assertEquals(0.0, (expected.subtract(result[4])).abs(), tolerance);\n \n         expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        assertEquals(0.0, (expected.subtract(result[4])).abs(), tolerance);\n+        assertEquals(0.0, (expected.subtract(result[2])).abs(), tolerance);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+\n \n import junit.framework.TestCase;\n \n         result = solver.solve(0.85, 5);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n     }\n+    \n+    /**\n+     * Test Serialization and Recovery\n+     */\n+    public void testSerialization() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        \n+        NewtonSolver solver = new NewtonSolver(f);\n+        NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);\n+        \n+        result = solver.solve(-0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(-0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(-0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());\n+        \n+        /* Test Reset */\n+        double newValue = 1.0e-2;\n+        f = new QuinticFunction();\n+        solver = new NewtonSolver(f);\n+        \n+        double oldValue = solver.getRelativeAccuracy();\n+        solver.setRelativeAccuracy(newValue);\n+        solver.resetRelativeAccuracy();\n+        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n+        \n+        solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver); \n+        \n+        assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+        \n+        solver2.setRelativeAccuracy(newValue);\n+        solver2.resetRelativeAccuracy();\n+        \n+        assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+        \n+    }\n }\n--- a/src/test/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/org/apache/commons/math/analysis/QuinticFunction.java\n  */\n public class QuinticFunction implements DifferentiableUnivariateRealFunction, Serializable {\n \n-    static final long serialVersionUID = -8866263034920607152L;\n+    private static final long serialVersionUID = -8866263034920607152L;\n \n     /* Evaluate quintic.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n /*\n- * Copyright 2003-2004 The Apache Software Foundation.\n+ * Copyright 2003-2005 The Apache Software Foundation.\n  * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  */\n public class ComplexTest extends TestCase {\n     \n+    private double inf = Double.POSITIVE_INFINITY;\n+    private double neginf = Double.NEGATIVE_INFINITY;\n+    private double nan = Double.NaN;\n+    private Complex oneInf = new Complex(1, inf);\n+    private Complex oneNegInf = new Complex(1, neginf);\n+    private Complex infOne = new Complex(inf, 1);\n+    private Complex negInfInf = new Complex(neginf, inf);\n+    private Complex negInfNegInf = new Complex(neginf, neginf);\n+    private Complex oneNaN = new Complex(1, nan);\n+    \n     public void testConstructor() {\n         Complex z = new Complex(3.0, 4.0);\n         assertEquals(3.0, z.getReal(), 1.0e-5);\n         Complex z = new Complex(3.0, Double.NaN);\n         assertTrue(z.isNaN());\n \n-        z = new Complex(Double.NaN, 4.0);\n+        z = new Complex(nan, 4.0);\n         assertTrue(z.isNaN());\n \n         z = new Complex(3.0, 4.0);\n     \n     public void testAbsNaN() {\n         assertTrue(Double.isNaN(Complex.NaN.abs()));\n+        Complex z = new Complex(inf, nan);\n+        assertTrue(Double.isNaN(z.abs()));\n+    }\n+    \n+    public void testAbsInfinite() {\n+        Complex z = new Complex(inf, 0);\n+        assertEquals(inf, z.abs(), 0);\n+        z = new Complex(0, neginf);\n+        assertEquals(inf, z.abs(), 0);\n+        z = new Complex(inf, neginf);\n+        assertEquals(inf, z.abs(), 0);     \n     }\n     \n     public void testAdd() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.add(Complex.NaN);\n         assertTrue(z.isNaN());\n+        z = new Complex(1, nan);\n+        Complex w = x.add(z);\n+        assertEquals(w.real, 4.0, 0);\n+        assertTrue(Double.isNaN(w.imaginary));\n+    }\n+    \n+    public void testAddInfinite() {\n+        Complex x = new Complex(1, 1);\n+        Complex z = new Complex(inf, 0);\n+        Complex w = x.add(z);\n+        assertEquals(w.imaginary, 1, 0);\n+        assertEquals(inf, w.real, 0);\n+        \n+        x = new Complex(neginf, 0);\n+        assertTrue(Double.isNaN(x.add(z).real));\n     }\n     \n     public void testConjugate() {\n         assertTrue(z.isNaN());\n     }\n     \n+    public void testConjugateInfiinite() {\n+        Complex z = new Complex(0, inf);\n+        assertEquals(neginf, z.conjugate().imaginary, 0);\n+        z = new Complex(0, neginf);\n+        assertEquals(inf, z.conjugate().imaginary, 0);\n+    }\n+    \n     public void testDivide() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);\n     }\n     \n+    public void testDivideInfinite() {\n+        Complex x = new Complex(3, 4);\n+        Complex w = new Complex(neginf, inf);\n+        assertTrue(x.divide(w).equals(Complex.ZERO));\n+        \n+        Complex z = w.divide(x);\n+        assertTrue(Double.isNaN(z.real));\n+        assertEquals(inf, z.imaginary, 0);\n+        \n+        w = new Complex(inf, inf);\n+        z = w.divide(x);\n+        assertTrue(Double.isNaN(z.imaginary));\n+        assertEquals(inf, z.real, 0);\n+        \n+        w = new Complex(1, inf);\n+        z = w.divide(w);\n+        assertTrue(Double.isNaN(z.real));\n+        assertTrue(Double.isNaN(z.imaginary));\n+    }\n+    \n     public void testDivideNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.divide(Complex.NaN);\n         assertTrue(z.isNaN());\n+    }\n+    \n+    public void testDivideNaNInf() {  \n+       Complex z = oneInf.divide(Complex.ONE);\n+       assertTrue(Double.isNaN(z.real));\n+       assertEquals(inf, z.imaginary, 0);\n+       \n+       z = negInfNegInf.divide(oneNaN);\n+       assertTrue(Double.isNaN(z.real));\n+       assertTrue(Double.isNaN(z.imaginary));\n+       \n+       z = negInfInf.divide(Complex.ONE);\n+       assertTrue(Double.isNaN(z.real));\n+       assertTrue(Double.isNaN(z.imaginary));\n     }\n     \n     public void testMultiply() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.multiply(Complex.NaN);\n         assertTrue(z.isNaN());\n+    }\n+    \n+    public void testMultiplyNaNInf() {\n+        Complex z = new Complex(1,1);\n+        Complex w = z.multiply(infOne);\n+        assertEquals(w.real, inf, 0);\n+        assertEquals(w.imaginary, inf, 0);\n+        \n+        w = oneInf.multiply(oneNegInf);\n+        assertEquals(w.real, inf, 0);\n+        assertTrue(Double.isNaN(w.imaginary));\n+        \n+        w = negInfNegInf.multiply(oneNaN);\n+        assertTrue(Double.isNaN(w.real));\n+        assertTrue(Double.isNaN(w.imaginary));  \n     }\n     \n     public void testNegate() {\n--- a/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java\n /*\n- * Copyright 2003-2004 The Apache Software Foundation.\n+ * Copyright 2003-2005 The Apache Software Foundation.\n  * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  */\n public class ComplexUtilsTest extends TestCase {\n     \n+    private double inf = Double.POSITIVE_INFINITY;\n+    private double negInf = Double.NEGATIVE_INFINITY;\n+    private double nan = Double.NaN;\n+    private double pi = Math.PI;\n+    \n+    private Complex oneInf = new Complex(1, inf);\n+    private Complex oneNegInf = new Complex(1, negInf);\n+    private Complex infOne = new Complex(inf, 1);\n+    private Complex negInfOne = new Complex(negInf, 1);\n+    private Complex negInfInf = new Complex(negInf, inf);\n+    private Complex infNegInf = new Complex(inf, negInf);\n+    private Complex infInf = new Complex(inf, inf);\n+    private Complex negInfNegInf = new Complex(negInf, negInf);\n+    private Complex oneNaN = new Complex(1, nan);\n+    private Complex infNaN = new Complex(inf, nan);\n+    private Complex negInfNaN = new Complex(negInf, nan);\n+    private Complex nanInf = new Complex(nan, inf);\n+    private Complex nanNegInf = new Complex(nan, negInf);\n+    private Complex zeroNaN = new Complex(0, nan);\n+    private Complex nanZero = new Complex(nan, 0);\n+    private Complex infZero = new Complex(inf, 0);\n+    private Complex zeroInf = new Complex(0, inf);\n+    private Complex zeroNegInf = new Complex(0, negInf);\n+    private Complex negInfZero = new Complex(negInf, 0);\n+    \n+    private ComplexFormat fmt = new ComplexFormat();\n+    \n     public void testAcos() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(0.936812, -2.30551);\n         TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);\n+        TestUtils.assertEquals(new Complex(Math.acos(0), 0), \n+                ComplexUtils.acos(Complex.ZERO), 1.0e-12);\n+    }\n+    \n+    public void testAcosInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));\n     }\n     \n     public void testAcosNaN() {\n         assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());\n     }\n     \n+    public void testAcosNull() {\n+        try {\n+            Complex z = ComplexUtils.acos(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n     public void testAsin() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(0.633984, 2.30551);\n         assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());\n     }\n     \n+    public void testAsinInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));\n+    }\n+    \n+    public void testAsinNull() {\n+        try {\n+            Complex z = ComplexUtils.asin(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n     public void testAtan() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.44831, 0.158997);\n         TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);\n     }\n     \n+    public void testAtanInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));\n+    } \n+    \n     public void testAtanNaN() {\n         assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());\n+        assertTrue(ComplexUtils.atan(Complex.I).isNaN());\n+    }\n+    \n+    public void testAtanNull() {\n+        try {\n+            Complex z = ComplexUtils.atan(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n     }\n     \n     public void testCos() {\n         TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);\n     }\n     \n+    public void testCosNaN() {\n+        assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testCosInf() {\n+        TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));\n+        TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));\n+    } \n+    \n+    public void testCosNull() {\n+        try {\n+            Complex z = ComplexUtils.cos(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n     public void testCosh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-6.58066, -7.58155);\n         assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());\n     }\n     \n-    public void testCosNaN() {\n-        assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());\n+    public void testCoshInf() {  \n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));\n+        TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));\n+        TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));\n+    } \n+    \n+    public void testCoshNull() {\n+        try {\n+            Complex z = ComplexUtils.cosh(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n     }\n     \n     public void testExp() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-13.12878, -15.20078);\n         TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);\n+        TestUtils.assertEquals(Complex.ONE, \n+                ComplexUtils.exp(Complex.ZERO), 10e-12);\n+        Complex iPi = Complex.I.multiply(new Complex(pi,0));\n+        TestUtils.assertEquals(Complex.ONE.negate(), \n+                ComplexUtils.exp(iPi), 10e-12);\n     }\n     \n     public void testExpNaN() {\n         assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());\n     }\n     \n+    public void testExpInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));\n+        TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));\n+        TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));\n+    }\n+    \n+    public void testExpNull() {\n+        try {\n+            Complex z = ComplexUtils.exp(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n     public void testLog() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.60944, 0.927295);\n     \n     public void testLogNaN() {\n         assertTrue(ComplexUtils.log(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testLogInf() {\n+        TestUtils.assertEquals(new Complex(inf, pi / 2),\n+                ComplexUtils.log(oneInf), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, -pi / 2),\n+                ComplexUtils.log(oneNegInf), 10e-12);\n+        TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, pi),\n+                ComplexUtils.log(negInfOne), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, pi / 4),\n+                ComplexUtils.log(infInf), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, -pi / 4),\n+                ComplexUtils.log(infNegInf), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),\n+                ComplexUtils.log(negInfInf), 10e-12);\n+        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),\n+                ComplexUtils.log(negInfNegInf), 10e-12);\n+    }\n+    \n+    public void testLogZero() {\n+        TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));\n+    }\n+    \n+    public void testlogNull() {\n+        try {\n+            Complex z = ComplexUtils.log(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testPolar2Complex() {\n+        TestUtils.assertEquals(Complex.ONE, \n+                ComplexUtils.polar2Complex(1, 0), 10e-12);\n+        TestUtils.assertEquals(Complex.ZERO, \n+                ComplexUtils.polar2Complex(0, 1), 10e-12);\n+        TestUtils.assertEquals(Complex.ZERO, \n+                ComplexUtils.polar2Complex(0, -1), 10e-12);\n+        TestUtils.assertEquals(Complex.I, \n+                ComplexUtils.polar2Complex(1, pi/2), 10e-12);\n+        TestUtils.assertEquals(Complex.I.negate(), \n+                ComplexUtils.polar2Complex(1, -pi/2), 10e-12);\n+        double r = 0;\n+        for (int i = 0; i < 5; i++) {\n+          r += i;\n+          double theta = 0;\n+          for (int j =0; j < 20; j++) {\n+              theta += pi / 6;\n+              TestUtils.assertEquals(altPolar(r, theta), \n+                      ComplexUtils.polar2Complex(r, theta), 10e-12);\n+          }\n+          theta = -2 * pi;\n+          for (int j =0; j < 20; j++) {\n+              theta -= pi / 6;\n+              TestUtils.assertEquals(altPolar(r, theta), \n+                      ComplexUtils.polar2Complex(r, theta), 10e-12);\n+          }\n+        }   \n+    }\n+    \n+    protected Complex altPolar(double r, double theta) {\n+        return ComplexUtils.exp(Complex.I.multiply\n+                (new Complex(theta, 0))).multiply(new Complex(r, 0));\n+    }\n+    \n+    public void testPolar2ComplexIllegalModulus() {\n+        try {\n+            Complex z = ComplexUtils.polar2Complex(-1, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }       \n+    }\n+    \n+    public void testPolar2ComplexNaN() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));\n+        TestUtils.assertSame(Complex.NaN, \n+                ComplexUtils.polar2Complex(nan, nan));     \n+    }\n+    \n+    public void testPolar2ComplexInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));\n+        TestUtils.assertSame(Complex.NaN,\n+                ComplexUtils.polar2Complex(1, negInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf));\n+        TestUtils.assertSame(Complex.NaN,\n+                ComplexUtils.polar2Complex(inf, negInf));\n+        TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4));\n+        TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0));\n+        TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4));\n+        TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4));\n+        TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));\n     }\n     \n     public void testPow() {\n         assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());\n     }\n     \n+   public void testPowInf() {\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));\n+       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   \n+   }\n+   \n+   public void testPowZero() {\n+       TestUtils.assertSame(Complex.NaN, \n+               ComplexUtils.pow(Complex.ZERO, Complex.ONE));\n+       TestUtils.assertSame(Complex.NaN, \n+               ComplexUtils.pow(Complex.ZERO, Complex.ZERO));\n+       TestUtils.assertSame(Complex.NaN, \n+               ComplexUtils.pow(Complex.ZERO, Complex.I));\n+       TestUtils.assertEquals(Complex.ONE,\n+               ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE,\n+               ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE,\n+               ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);\n+   }\n+    \n+    public void testpowNull() {\n+        try {\n+            Complex z = ComplexUtils.pow(null, Complex.ONE); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+        try {\n+            Complex z = ComplexUtils.pow(Complex.ONE, null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n     public void testSin() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(3.853738, -27.01681);\n         TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);\n     }\n     \n+    public void testSinInf() {\n+        TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));\n+        TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));\n+    }\n+    \n+    public void testSinNaN() {\n+        assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testSinNull() {\n+        try {\n+            Complex z = ComplexUtils.sin(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+     \n     public void testSinh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-6.54812, -7.61923);\n         assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());\n     }\n     \n-    public void testSinNaN() {\n-        assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());\n+    public void testSinhInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));\n+        TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));\n+        TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));\n+    }\n+    \n+    public void testsinhNull() {\n+        try {\n+            Complex z = ComplexUtils.sinh(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n     }\n     \n     public void testSqrtRealPositive() {\n         Complex expected = new Complex(1.0, -2.0);\n         TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n     }\n+    \n+    public void testSqrtPolar() {\n+        double r = 1;\n+        for (int i = 0; i < 5; i++) {\n+            r += i;\n+            double theta = 0;\n+            for (int j =0; j < 11; j++) {\n+                theta += pi /12;\n+                Complex z = ComplexUtils.polar2Complex(r, theta);\n+                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);\n+                TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);\n+            }\n+        }       \n+    }\n+    \n+    public void testSqrtNaN() {\n+        assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());\n+    }\n+      \n+    public void testSqrtInf() {\n+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));\n+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));\n+        TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));\n+        TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));\n+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));\n+        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));\n+        TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));\n+        TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));\n+    }\n+    \n+    public void testSqrtNull() {\n+        try {\n+            Complex z = ComplexUtils.sqrt(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n \n     public void testSqrt1z() {\n         Complex z = new Complex(3, 4);\n         assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());\n     }\n     \n-    public void testSqrtNaN() {\n-        assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());\n+    public void testSqrt1zNull() {\n+        try {\n+            Complex z = ComplexUtils.sqrt1z(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n     }\n     \n     public void testTan() {\n         TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);\n     }\n     \n+    public void testTanNaN() {\n+        assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());\n+    }\n+    \n+    public void testTanInf() {\n+        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));\n+        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));\n+    }\n+    \n+   public void testTanCritical() {\n+        TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));\n+        TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));\n+    }\n+    \n+    public void testTanNull() {\n+        try {\n+            Complex z = ComplexUtils.tan(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+    \n     public void testTanh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.00071, 0.00490826);\n         assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());\n     }\n     \n-    public void testTanNaN() {\n-        assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());\n+    public void testTanhInf() {\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));\n+        TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));\n+        TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));\n+        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));\n+    }\n+    \n+    public void testTanhCritical() {\n+        TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));\n+    }\n+    \n+    public void testTanhNull() {\n+        try {\n+            Complex z = ComplexUtils.tanh(null); \n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n     }\n     \n     public void testLargeValues() {\n-    \tint populationSize = 3456;\n-    \tint sampleSize = 789;\n-    \tint numberOfSucceses = 101;\n-    \tdouble[][] data = {\n-    \t    {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},\n-    \t    {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},\n-    \t    {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},\n-    \t    {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},\n-    \t    {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},\n-    \t    {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},\n-        \t{20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, \n+        int populationSize = 3456;\n+        int sampleSize = 789;\n+        int numberOfSucceses = 101;\n+        double[][] data = {\n+            {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},\n+            {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},\n+            {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},\n+            {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},\n+            {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},\n+            {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},\n+            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, \n             {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701}, \n             {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381}, \n             {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199}, \n             {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63}, \n             {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},\n             {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},\n-    \t};\n+        };\n         \n-    \ttestHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n-    }\n-\n-\tprivate void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {\n-\t\tHypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);\n-    \tfor (int i = 0; i < data.length; ++i) {\n-    \t\tint x = (int)data[i][0];\n-    \t\tdouble pdf = data[i][1];\n-    \t\tdouble actualPdf = dist.probability(x);\n-    \t\tTestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);\n-\n-    \t\tdouble cdf = data[i][2];\n-    \t\tdouble actualCdf = dist.cumulativeProbability(x);\n-\t\t\tTestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);\n-\n-\t\t\tdouble cdf1 = data[i][3];\n-    \t\tdouble actualCdf1 = dist.upperCumulativeProbability(x);\n-\t\t\tTestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);\n-    \t}\n-\t}\n+        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n+    }\n+\n+    private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {\n+        HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);\n+        for (int i = 0; i < data.length; ++i) {\n+            int x = (int)data[i][0];\n+            double pdf = data[i][1];\n+            double actualPdf = dist.probability(x);\n+            TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);\n+\n+            double cdf = data[i][2];\n+            double actualCdf = dist.cumulativeProbability(x);\n+            TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);\n+\n+            double cdf1 = data[i][3];\n+            double actualCdf1 = dist.upperCumulativeProbability(x);\n+            TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);\n+        }\n+    }\n     \n     public void testMoreLargeValues() {\n-    \tint populationSize = 26896;\n-    \tint sampleSize = 895;\n-    \tint numberOfSucceses = 55;\n-    \tdouble[][] data = {\n-    \t    {0.0, 0.155168304750504, 0.155168304750504, 1.0}, \n+        int populationSize = 26896;\n+        int sampleSize = 895;\n+        int numberOfSucceses = 55;\n+        double[][] data = {\n+            {0.0, 0.155168304750504, 0.155168304750504, 1.0}, \n             {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496}, \n-    \t    {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, \n-    \t    {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, \n-    \t    {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, \n-    \t    {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, \n+            {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, \n+            {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, \n+            {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, \n+            {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, \n             {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16}, \n             {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17}, \n             {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18}, \n             {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76}, \n             {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79}, \n             {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},        \n-    \t};\n-    \ttestHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n+        };\n+        testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java\n     }\n     \n     public void testLargeMeanCumulativeProbability() {\n-    \tPoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);\n-    \tdouble mean = 1.0;\n-    \twhile (mean <= 10000000.0) {\n-    \t\tdist.setMean(mean);\n-    \t\t\n-    \t\tdouble x = mean * 2.0;\n-    \t\tdouble dx = x / 10.0;\n-    \t\twhile (x >= 0) {\n-    \t\t\ttry {\n-    \t\t\t\tdist.cumulativeProbability(x);\n-    \t\t\t} catch (MathException ex) {\n-    \t\t\t\tfail(\"mean of \" + mean + \" and x of \" + x + \" caused \" + ex.getMessage());\n-    \t\t\t}\n-\t\t\t\tx -= dx;\n-    \t\t}\n-    \t\t\n-    \t\tmean *= 10.0;\n-    \t}\n+        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);\n+        double mean = 1.0;\n+        while (mean <= 10000000.0) {\n+            dist.setMean(mean);\n+            \n+            double x = mean * 2.0;\n+            double dx = x / 10.0;\n+            while (x >= 0) {\n+                try {\n+                    dist.cumulativeProbability(x);\n+                } catch (MathException ex) {\n+                    fail(\"mean of \" + mean + \" and x of \" + x + \" caused \" + ex.getMessage());\n+                }\n+                x -= dx;\n+            }\n+            \n+            mean *= 10.0;\n+        }\n     }\n     \n     public void testLargeMeanInverseCumulativeProbability() {\n-    \tPoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);\n-    \tdouble mean = 1.0;\n-    \twhile (mean <= 10000000.0) {\n-    \t\tdist.setMean(mean);\n-    \t\t\n-    \t\tdouble p = 0.1;\n-    \t\tdouble dp = p;\n-    \t\twhile (p < 1.0) {\n-    \t\t\ttry {\n-    \t\t\t\tdist.inverseCumulativeProbability(p);\n-    \t\t\t} catch (MathException ex) {\n-    \t\t\t\tfail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n-    \t\t\t}\n-\t\t\t\tp += dp;\n-    \t\t}\n-    \t\t\n-    \t\tmean *= 10.0;\n-    \t}\n+        PoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);\n+        double mean = 1.0;\n+        while (mean <= 10000000.0) {\n+            dist.setMean(mean);\n+            \n+            double p = 0.1;\n+            double dp = p;\n+            while (p < 1.0) {\n+                try {\n+                    dist.inverseCumulativeProbability(p);\n+                } catch (MathException ex) {\n+                    fail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n+                }\n+                p += dp;\n+            }\n+            \n+            mean *= 10.0;\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n         assertEquals\n           (empiricalDistribution2.getSampleStats().getStandardDeviation(),\n                 1.0173699343977738,10E-7);\n+        \n+        double[] bounds = empiricalDistribution2.getUpperBounds();\n+        assertEquals(bounds.length, 100);\n+        assertEquals(bounds[99], 1.0, 10e-12);\n+          \n     }\n    \n     /** \n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n         \n         /* remove this test back soon,\n          * since it takes about 4 seconds */\n-         \n-        randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\");\n+\n+        try {\n+            randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\");\n+        } catch (NoSuchProviderException ex) {\n+            ;\n+        }\n         assertTrue(\"different seeds\",\n             !hex.equals(randomData.nextSecureHexString(40)));\n         try {\n             randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n             fail(\"expecting NoSuchAlgorithmException\");\n+        } catch (NoSuchProviderException ex) {\n+            ;\n         } catch (NoSuchAlgorithmException ex) {\n             ;\n         }\n--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n             // expected\n         }\n         try {\n-        \tdouble[] single = {1.0};\n+            double[] single = {1.0};\n             StatUtils.varianceDifference(single, single, meanDifference);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n public class ListUnivariateImpl extends DescriptiveStatistics implements Serializable {\n \n     /** Serializable version identifier */\n-    static final long serialVersionUID = -8837442489133392138L;\n+    private static final long serialVersionUID = -8837442489133392138L;\n     \n     /**\n      * Holds a reference to a list - GENERICs are going to make\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n         \n         // invalid percentiles\n         try {\n-        \tp.evaluate(d, 0, d.length, -1.0);\n-        \tfail();\n+            p.evaluate(d, 0, d.length, -1.0);\n+            fail();\n         } catch (IllegalArgumentException ex) {\n-        \t// success\n+            // success\n         }\n         try {\n-        \tp.evaluate(d, 0, d.length, 101.0);\n-        \tfail();\n+            p.evaluate(d, 0, d.length, 101.0);\n+            fail();\n         } catch (IllegalArgumentException ex) {\n-        \t// success\n+            // success\n         }\n     }\n     ", "timestamp": 1135286192, "metainfo": ""}