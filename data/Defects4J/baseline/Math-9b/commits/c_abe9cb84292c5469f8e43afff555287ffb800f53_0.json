{"sha": "abe9cb84292c5469f8e43afff555287ffb800f53", "log": "Added missing @since tags.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n      * @param eps Relative tolerance.\n      * @throws NonSquareMatrixException if the matrix is not square.\n      * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @since 3.1\n      */\n     public static void checkSymmetric(RealMatrix matrix,\n                                       double eps) {\n      * @param matrix Matrix to check.\n      * @param eps Relative tolerance.\n      * @return {@code true} if {@code matrix} is symmetric.\n+     * @since 3.1\n      */\n     public static boolean isSymmetric(RealMatrix matrix,\n                                       double eps) {\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n      * @param end the index of the last entry of the subvector (inclusive)\n      * @throws OutOfRangeException if {@code start} of {@code end} are not valid\n      * @throws NumberIsTooSmallException if {@code end < start}\n+     * @since 3.1\n      */\n     protected void checkIndices(final int start, final int end)\n         throws NumberIsTooSmallException, OutOfRangeException {\n         return this;\n     }\n \n-\n     /**\n      * Visits (but does not alter) all entries of this vector in default order\n      * (increasing index).\n      * vector\n      * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n      * at the end of the walk\n+     * @since 3.1\n      */\n     public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor) {\n         final int dim = getDimension();\n      * at the end of the walk\n      * @throws NumberIsTooSmallException if {@code end < start}.\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @since 3.1\n      */\n     public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,\n                                      final int start, final int end)\n      * vector\n      * @return the value returned by {@link RealVectorPreservingVisitor#end()}\n      * at the end of the walk\n+     * @since 3.1\n      */\n     public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor) {\n         return walkInDefaultOrder(visitor);\n      * at the end of the walk\n      * @throws NumberIsTooSmallException if {@code end < start}.\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @since 3.1\n      */\n     public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor,\n                                        final int start, final int end)\n      * of this vector\n      * @return the value returned by {@link RealVectorChangingVisitor#end()}\n      * at the end of the walk\n+     * @since 3.1\n      */\n     public double walkInDefaultOrder(final RealVectorChangingVisitor visitor) {\n         final int dim = getDimension();\n      * at the end of the walk\n      * @throws NumberIsTooSmallException if {@code end < start}.\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @since 3.1\n      */\n     public double walkInDefaultOrder(final RealVectorChangingVisitor visitor,\n                               final int start, final int end)\n      * vector\n      * @return the value returned by {@link RealVectorChangingVisitor#end()}\n      * at the end of the walk\n+     * @since 3.1\n      */\n     public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor) {\n         return walkInDefaultOrder(visitor);\n      * at the end of the walk\n      * @throws NumberIsTooSmallException if {@code end < start}.\n      * @throws OutOfRangeException if the indices are not valid.\n+     * @since 3.1\n      */\n     public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor,\n                                        final int start, final int end)\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n      * @param matrix Symmetric positive semidefinite matrix.\n      * @exception NonPositiveDefiniteMatrixException if the matrix is not\n      * positive semidefinite.\n+     * @since 3.1\n      */\n     public RectangularCholeskyDecomposition(RealMatrix matrix)\n         throws NonPositiveDefiniteMatrixException {\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateOptimizer.java\n      * </ul>\n      * @return the point/value pair giving the optimal value of the objective\n      * function.\n+     * @since 3.1\n      */\n     public PointValuePair optimize(int maxEval,\n                                    FUNC f,\n      * function.\n      * @throws TooManyEvaluationsException if the maximal number of\n      * evaluations is exceeded.\n+     * @since 3.1\n      */\n     protected PointValuePair optimizeInternal(int maxEval,\n                                               FUNC f,\n     }\n     /**\n      * @return the lower bounds.\n+     * @since 3.1\n      */\n     public double[] getLowerBound() {\n         return lowerBound == null ? null : lowerBound.clone();\n     }\n     /**\n      * @return the upper bounds.\n+     * @since 3.1\n      */\n     public double[] getUpperBound() {\n         return upperBound == null ? null : upperBound.clone();\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n      * values are more likely to find a local optimum close to the initial\n      * guess).\n      * Too small values might however lead to early termination.\n+     * @since 3.1\n      */\n     public static class Sigma implements OptimizationData {\n         /** Sigma values. */\n      * Increasing the population size improves global search properties\n      * at the expense of speed (which in general decreases at most\n      * linearly with increasing population size).\n+     * @since 3.1\n      */\n     public static class PopulationSize implements OptimizationData {\n         /** Population size. */\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n      * @param lineAbs Absolute threshold for the internal line search optimizer.\n      * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n      * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n+     * @since 3.1\n      */\n     public PowellOptimizer(double rel,\n                            double abs,\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n      * Simple constructor.\n      *\n      * @param optimizer Optimizer to use for the fitting.\n+     * @since 3.1\n      */\n     public PolynomialFitter(DifferentiableMultivariateVectorOptimizer optimizer) {\n         super(optimizer);\n      * the number of evaluations exceeds {@code maxEval}.\n      * @throws org.apache.commons.math3.exception.ConvergenceException\n      * if the algorithm failed to converge.\n+     * @since 3.1\n      */\n     public double[] fit(int maxEval, double[] guess) {\n         return fit(maxEval, new PolynomialFunction.Parametric(), guess);\n      * @return the coefficients of the polynomial that best fits the observed points.\n      * @throws org.apache.commons.math3.exception.ConvergenceException\n      * if the algorithm failed to converge.\n+     * @since 3.1\n      */\n     public double[] fit(double[] guess) {\n         return fit(new PolynomialFunction.Parametric(), guess);\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n      * Gets the square-root of the weight matrix.\n      *\n      * @return the square-root of the weight matrix.\n+     * @since 3.1\n      */\n     public RealMatrix getWeightSquareRoot() {\n         return weightMatrixSqrt.copy();\n      * @return the covariance matrix.\n      * @throws org.apache.commons.math3.linear.SingularMatrixException\n      * if the covariance matrix cannot be computed (singular problem).\n+     * @since 3.1\n      */\n     public double[][] computeCovariances(double[] params,\n                                          double threshold) {\n      * @return an estimate of the standard deviation of the optimized parameters\n      * @throws org.apache.commons.math3.linear.SingularMatrixException\n      * if the covariance matrix cannot be computed.\n+     * @since 3.1\n      */\n     public double[] computeSigma(double[] params,\n                                  double covarianceSingularityThreshold) {\n      * @return the residuals.\n      * @throws DimensionMismatchException if {@code params} has a wrong\n      * length.\n+     * @since 3.1\n      */\n     protected double[] computeResiduals(double[] objectiveValue) {\n         final double[] target = getTarget();\n--- a/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n  * </li>\n  * </ul>\n  * </p>\n- *\n+ * @since 3.1\n  * @version $Id$\n  */\n public class RandomDataGenerator implements RandomData, Serializable {\n--- a/src/main/java/org/apache/commons/math3/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math3/special/Gamma.java\n     /**\n      * The value of the {@code g} constant in the Lanczos approximation, see\n      * {@link #lanczos(double)}.\n+     * @since 3.1\n      */\n     public static final double LANCZOS_G = 607.0 / 128.0;\n \n      * equations (1) through (5), and Paul Godfrey's\n      * <a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Note on the computation\n      * of the convergent Lanczos complex Gamma approximation</a>\n+     * @since 3.1\n      */\n     public static double lanczos(final double x) {\n         double sum = 0.0;\n      * @return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}.\n      * @throws NumberIsTooSmallException if {@code x < -0.5}\n      * @throws NumberIsTooLargeException if {@code x > 1.5}\n+     * @since 3.1\n      */\n     public static double invGamma1pm1(final double x) {\n \n      * @return The value of {@code log(Gamma(1 + x))}.\n      * @throws NumberIsTooSmallException if {@code x < -0.5}.\n      * @throws NumberIsTooLargeException if {@code x > 1.5}.\n+     * @since 3.1\n      */\n     public static double logGamma1p(final double x)\n         throws NumberIsTooSmallException, NumberIsTooLargeException {\n      *\n      * @param x Argument.\n      * @return the value of {@code Gamma(x)}.\n+     * @since 3.1\n      */\n     public static double gamma(final double x) {\n \n--- a/src/main/java/org/apache/commons/math3/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math3/stat/Frequency.java\n      * @param v the value to add.\n      * @param increment the amount by which the value should be incremented\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n+     * @since 3.1\n      */\n     public void incrementValue(Comparable<?> v, long increment){\n         Comparable<?> obj = v;\n      * map entries returned by the Iterator will in this case be Longs.</p>\n      *\n      * @return entry set Iterator\n+     * @since 3.1\n      */\n     public Iterator<Map.Entry<Comparable<?>, Long>> entrySetIterator() {\n         return freqTable.entrySet().iterator();\n      * by the counts represented by other.\n      *\n      * @param other the other {@link Frequency} object to be merged\n+     * @since 3.1\n      */\n     public void merge(Frequency other) {\n         for (Iterator<Map.Entry<Comparable<?>, Long>> iter = other.entrySetIterator(); iter.hasNext();) {\n      * by the counts represented by each of the others.\n      *\n      * @param others the other {@link Frequency} objects to be merged\n+     * @since 3.1\n      */\n     public void merge(Collection<Frequency> others) {\n         for (Iterator<Frequency> iter = others.iterator(); iter.hasNext();) {\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n      * Create a SpearmansCorrelation with the given ranking algorithm.\n      *\n      * @param rankingAlgorithm ranking algorithm\n+     * @since 3.1\n      */\n     public SpearmansCorrelation(final RankingAlgorithm rankingAlgorithm) {\n         data = null;\n--- a/src/main/java/org/apache/commons/math3/stat/inference/TestUtils.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/TestUtils.java\n \n      /**\n      * @see org.apache.commons.math3.stat.inference.GTest#g(double[], long[])\n+     * @since 3.1\n      */\n     public static double g(final double[] expected, final long[] observed)\n         throws NotPositiveException, NotStrictlyPositiveException,\n \n     /**\n      * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],  long[] )\n+     * @since 3.1\n      */\n     public static double gTest(final double[] expected, final long[] observed)\n         throws NotPositiveException, NotStrictlyPositiveException,\n \n     /**\n      * @see org.apache.commons.math3.stat.inference.GTest#gTestIntrinsic(double[], long[] )\n+     * @since 3.1\n      */\n     public static double gTestIntrinsic(final double[] expected, final long[] observed)\n         throws NotPositiveException, NotStrictlyPositiveException,\n \n      /**\n      * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],long[],double)\n+     * @since 3.1\n      */\n     public static boolean gTest(final double[] expected, final long[] observed,\n                                 final double alpha)\n \n     /**\n      * @see org.apache.commons.math3.stat.inference.GTest#gDataSetsComparison(long[], long[])\n+     * @since 3.1\n      */\n     public static double gDataSetsComparison(final long[] observed1,\n                                                   final long[] observed2)\n \n     /**\n      * @see org.apache.commons.math3.stat.inference.GTest#rootLogLikelihoodRatio(long, long, long, long)\n+     * @since 3.1\n      */\n     public static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22)\n         throws DimensionMismatchException, NotPositiveException, ZeroException {\n \n     /**\n      * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[], long[])\n-     *\n+     * @since 3.1\n      */\n     public static double gTestDataSetsComparison(final long[] observed1,\n                                                         final long[] observed2)\n \n     /**\n      * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[],long[],double)\n+     * @since 3.1\n      */\n     public static boolean gTestDataSetsComparison(final long[] observed1,\n                                                   final long[] observed2,\n--- a/src/main/java/org/apache/commons/math3/stat/ranking/NaNStrategy.java\n+++ b/src/main/java/org/apache/commons/math3/stat/ranking/NaNStrategy.java\n     /** NaNs are left in place */\n     FIXED,\n \n-    /** NaNs result in an exception */\n+    /** NaNs result in an exception\n+     * @since 3.1\n+     */\n     FAILED\n }\n--- a/src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java\n+++ b/src/main/java/org/apache/commons/math3/util/ArithmeticUtils.java\n      * @throws NumberIsTooLargeException if {@code k > n}.\n      * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n      * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n+     * @since 3.1\n      */\n     public static long stirlingS2(final int n, final int k)\n         throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n      * @param d Number to raise.\n      * @param e Exponent.\n      * @return d<sup>e</sup>\n+     * @since 3.1\n      */\n     public static double pow(double d, int e) {\n \n--- a/src/main/java/org/apache/commons/math3/util/IterationManager.java\n+++ b/src/main/java/org/apache/commons/math3/util/IterationManager.java\n      * @param callBack the function to be called when the maximum number of\n      * iterations has been reached\n      * @throws org.apache.commons.math3.exception.NullArgumentException if {@code callBack} is {@code null}\n+     * @since 3.1\n      */\n     public IterationManager(final int maxIterations,\n                             final Incrementor.MaxCountExceededCallback callBack) {\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n \n     /**\n      * Real-valued function that operate on an array or a part of it.\n+     * @since 3.1\n      */\n     public interface Function {\n         /**\n      * @param b Second term of the addition.\n      * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.\n      * @throws DimensionMismatchException if the array lengths differ.\n+     * @since 3.1\n      */\n     public static double[] ebeAdd(double[] a,\n                                   double[] b) {\n      * @param b Element to be subtracted.\n      * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.\n      * @throws DimensionMismatchException if the array lengths differ.\n+     * @since 3.1\n      */\n     public static double[] ebeSubtract(double[] a,\n                                        double[] b) {\n      * @param b Second factor of the multiplication.\n      * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.\n      * @throws DimensionMismatchException if the array lengths differ.\n+     * @since 3.1\n      */\n     public static double[] ebeMultiply(double[] a,\n                                        double[] b) {\n      * @param b Denominator of the division.\n      * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.\n      * @throws DimensionMismatchException if the array lengths differ.\n+     * @since 3.1\n      */\n     public static double[] ebeDivide(double[] a,\n                                      double[] b) {\n      * @param in array to be tested\n      * @throws NullArgumentException if input array is null\n      * @throws DimensionMismatchException if input array is not rectangular\n+     * @since 3.1\n      */\n     public static void checkRectangular(final long[][] in)\n         throws NullArgumentException, DimensionMismatchException {\n      * @param in Array to be tested\n      * @throws NotStrictlyPositiveException if any entries of the array are not\n      * strictly positive.\n+     * @since 3.1\n      */\n     public static void checkPositive(final double[] in)\n         throws NotStrictlyPositiveException {\n      *\n      * @param in Array to be tested\n      * @throws NotPositiveException if any array entries are less than 0.\n+     * @since 3.1\n      */\n     public static void checkNonNegative(final long[] in)\n         throws NotPositiveException {\n      *\n      * @param in Array to be tested\n      * @throws NotPositiveException if any array entries are less than 0.\n+     * @since 3.1\n      */\n     public static void checkNonNegative(final long[][] in)\n         throws NotPositiveException {\n--- a/src/main/java/org/apache/commons/math3/util/Pair.java\n+++ b/src/main/java/org/apache/commons/math3/util/Pair.java\n      * Get the first element of the pair.\n      *\n      * @return the first element of the pair.\n+     * @since 3.1\n      */\n     public K getFirst() {\n         return key;\n      * Get the second element of the pair.\n      *\n      * @return the second element of the pair.\n+     * @since 3.1\n      */\n     public V getSecond() {\n         return value;\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n      * @param eps Amount of allowed relative error.\n      * @return {@code true} if the values are two adjacent floating point\n      * numbers or they are within range of each other.\n+     * @since 3.1\n      */\n     public static boolean equalsWithRelativeTolerance(double x, double y, double eps) {\n         if (equals(x, y, 1)) {\n--- a/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n \n     /**\n      * Specification of expansion algorithm.\n+     * @since 3.1\n      */\n     public static enum ExpansionMode {\n         /** Multiplicative expansion mode. */\n      * @param expansionFactor The array will be expanded based on this\n      * parameter.\n      * @throws MathIllegalArgumentException if parameters are not valid.\n+     * @since 3.1\n      */\n     public ResizableDoubleArray(int initialCapacity,\n                                 double expansionFactor)\n      * parameter.\n      * @param contractionCriterion Contraction criterion.\n      * @throws MathIllegalArgumentException if the parameters are not valid.\n+     * @since 3.1\n      */\n     public ResizableDoubleArray(int initialCapacity,\n                                 double expansionFactor,\n      * @throws NumberIsTooSmallException if {@code contraction < expansion}.\n      * @throws NumberIsTooSmallException if {@code contraction <= 1}.\n      * @throws NumberIsTooSmallException if {@code expansion <= 1 }.\n+     * @since 3.1\n      */\n     protected void checkContractExpand(double contraction,\n                                        double expansion)\n      * <code>contractionFactor.</code>\n      *\n      * @return the contraction criterion used to reclaim memory.\n+     * @since 3.1\n      */\n     public double getContractionCriterion() {\n         return contractionCriterion;\n      * elements actually stored}.\n      *\n      * @return the length of the internal array.\n+     * @since 3.1\n      */\n     public int getCapacity() {\n         return internalArray.length;\n      *\n      * @param f Function to be applied on this array.\n      * @return the result.\n+     * @since 3.1\n      */\n     public double compute(MathArrays.Function f) {\n         return f.evaluate(internalArray, startIndex, numElements);", "timestamp": 1355597621, "metainfo": ""}