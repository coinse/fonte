{"sha": "6bf1c2a0cfa845cd03d9f9549257e9b0e2d83b10", "log": "MATH-653 \"RealVector\": Removed methods taking a \"double[]\" argument whenever another exists that takes a \"RealVector\" argument. Modified subclasses and unit tests accordingly. Fixed a bug in method \"subtract(RealVector)\" (in class \"RealVector\").   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n      * Zero-length vectors may be used to initialized construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #ArrayRealVector(ArrayRealVector, ArrayRealVector)} constructor\n-     * or one of the {@code append} method ({@link #append(double)}, {@link\n-     * #append(double[])}, {@link #append(ArrayRealVector)}) to gather data\n-     * into this vector.\n+     * or one of the {@code append} method ({@link #append(double)},\n+     * {@link #append(ArrayRealVector)}) to gather data into this vector.\n      */\n     public ArrayRealVector() {\n         data = new double[0];\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector add(RealVector v) {\n+    public ArrayRealVector add(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return add(((ArrayRealVector) v).data);\n         } else {\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector add(double[] v) {\n+    /**\n+     * Compute the sum of this vector and {@code v}.\n+     * Returns a new vector. Does not change instance data.\n+     *\n+     * @param v Vector to be added.\n+     * @return {@code this} + {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public ArrayRealVector add(double[] v) {\n         final int dim = v.length;\n         checkVectorDimensions(dim);\n         ArrayRealVector result = new ArrayRealVector(dim);\n         return result;\n     }\n \n-    /**\n-     * Add {@code v} to this vector.\n-     *\n-     * @param v Vector to be added\n-     * @return {@code this} + v.\n-     * @throws DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public ArrayRealVector add(ArrayRealVector v) {\n-        return (ArrayRealVector) add(v.data);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector subtract(RealVector v) {\n+    /** {@inheritDoc} */\n+    @Override\n+    public ArrayRealVector subtract(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return subtract(((ArrayRealVector) v).data);\n         } else {\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector subtract(double[] v) {\n+    /**\n+     * Subtract {@code v} from this vector.\n+     * Returns a new vector. Does not change instance data.\n+     *\n+     * @param v Vector to be subtracted.\n+     * @return {@code this} - {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public ArrayRealVector subtract(double[] v) {\n         final int dim = v.length;\n         checkVectorDimensions(dim);\n         ArrayRealVector result = new ArrayRealVector(dim);\n         return result;\n     }\n \n-    /**\n-     * Subtract {@code v} from this vector.\n-     *\n-     * @param v Vector to be subtracted.\n-     * @return {@code this} - v.\n-     * @throws DimensionMismatchException if {@code v} is not the\n-     * same size as this vector.\n-     */\n-    public ArrayRealVector subtract(ArrayRealVector v) {\n-        return (ArrayRealVector) subtract(v.data);\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public ArrayRealVector map(UnivariateRealFunction function) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeMultiply(RealVector v) {\n+    @Override\n+    public ArrayRealVector ebeMultiply(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return ebeMultiply(((ArrayRealVector) v).data);\n         } else {\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector ebeMultiply(double[] v) {\n+    /**\n+     * Element-by-element multiplication.\n+     *\n+     * @param v Vector by which instance elements must be multiplied.\n+     * @return a Vector containing {@code this[i] * v[i]} for all {@code i}.\n+     * @throws DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n+    public ArrayRealVector ebeMultiply(double[] v) {\n         final int dim = v.length;\n         checkVectorDimensions(dim);\n         ArrayRealVector result = new ArrayRealVector(dim);\n         return result;\n     }\n \n-    /**\n-     * Element-by-element multiplication.\n-     * @param v Vector by which instance elements must be multiplied.\n-     * @return a Vector containing {@code this[i] * v[i]} for all {@code i}.\n-     * @exception DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public ArrayRealVector ebeMultiply(ArrayRealVector v) {\n-        return (ArrayRealVector) ebeMultiply(v.data);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector ebeDivide(RealVector v) {\n+    /** {@inheritDoc} */\n+    public ArrayRealVector ebeDivide(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return ebeDivide(((ArrayRealVector) v).data);\n         } else {\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector ebeDivide(double[] v) {\n+    /**\n+     * Element-by-element division.\n+     *\n+     * @param v Vector by which instance elements must be divided.\n+     * @return a vector containing {@code this[i] / v[i]} for all {@code i}.\n+     * @exception DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n+    public ArrayRealVector ebeDivide(double[] v) {\n         final int dim = v.length;\n         checkVectorDimensions(dim);\n         ArrayRealVector result = new ArrayRealVector(dim);\n             resultData[i] = data[i] / v[i];\n         }\n         return result;\n-    }\n-\n-    /**\n-     * Element-by-element division.\n-     *\n-     * @param v Vector by which instance elements must be divided.\n-     * @return a vector containing {@code this[i] / v[i]} for all {@code i}.\n-     * @exception DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public ArrayRealVector ebeDivide(ArrayRealVector v) {\n-        return (ArrayRealVector) ebeDivide(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n+    /**\n+     * Compute the dot product.\n+     *\n+     * @param v Vector with which dot product should be computed\n+     * @return the scalar dot product between instance and {@code v}.\n+     * @throws DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n     public double dotProduct(double[] v) {\n         checkVectorDimensions(v.length);\n         double dot = 0;\n             dot += data[i] * v[i];\n         }\n         return dot;\n-    }\n-\n-    /**\n-     * Compute the dot product.\n-     *\n-     * @param v Vector with which dot product should be computed\n-     * @return the scalar dot product between instance and {@code v}.\n-     * @throws DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public double dotProduct(ArrayRealVector v) {\n-        return dotProduct(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n+    /**\n+     * Distance between two vectors.\n+     * This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.\n+     *\n+     * @param v Vector to which distance is requested.\n+     * @return the distance between two vectors.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * this vector.\n+     * @see #getDistance(RealVector)\n+     * @see #getNorm()\n+     */\n     public double getDistance(double[] v) {\n         checkVectorDimensions(v.length);\n         double sum = 0;\n             sum += delta * delta;\n         }\n         return FastMath.sqrt(sum);\n-    }\n-\n-   /**\n-     * Distance between two vectors.\n-     * This method computes the distance consistent with the\n-     * L<sub>2</sub> norm, i.e. the square root of the sum of\n-     * elements differences, or euclidian distance.\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * this vector.\n-     * @see #getDistance(RealVector)\n-     * @see #getL1Distance(ArrayRealVector)\n-     * @see #getLInfDistance(ArrayRealVector)\n-     * @see #getNorm()\n-     */\n-    public double getDistance(ArrayRealVector v) {\n-        return getDistance(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n+    /**\n+     * Distance between two vectors.\n+     * This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.\n+     *\n+     * @param v Vector to which distance is requested.\n+     * @return the distance between two vectors.\n+     * @throws DimensionMismatchException if {@code v} is not the same size\n+     * as this vector.\n+     * @see #getDistance(RealVector)\n+     * @see #getNorm()\n+     */\n     public double getL1Distance(double[] v) {\n         checkVectorDimensions(v.length);\n         double sum = 0;\n             sum += FastMath.abs(delta);\n         }\n         return sum;\n-    }\n-\n-    /**\n-     * Distance between two vectors.\n-     * This method computes the distance consistent with\n-     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n-     * elements differences.\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @throws DimensionMismatchException if {@code v} is not the same size\n-     * as this vector.\n-     * @see #getDistance(RealVector)\n-     * @see #getL1Distance(ArrayRealVector)\n-     * @see #getLInfDistance(ArrayRealVector)\n-     * @see #getNorm()\n-     */\n-    public double getL1Distance(ArrayRealVector v) {\n-        return getL1Distance(v.data);\n     }\n \n     /** {@inheritDoc} */\n         }\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n+    /**\n+     * Distance between two vectors.\n+     * This method computes the distance consistent with\n+     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.\n+     *\n+     * @param v Vector to which distance is requested.\n+     * @return the distance between two vectors.\n+     * @exception IllegalArgumentException if {@code v} is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getNorm()\n+     */\n     public double getLInfDistance(double[] v) {\n         checkVectorDimensions(v.length);\n         double max = 0;\n         return max;\n     }\n \n-    /**\n-     * Distance between two vectors.\n-     * This method computes the distance consistent with\n-     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n-     * elements differences.\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @exception IllegalArgumentException if {@code v} is not the same size as this\n-     * @see #getDistance(RealVector)\n-     * @see #getL1Distance(ArrayRealVector)\n-     * @see #getLInfDistance(ArrayRealVector)\n-     * @see #getNorm()\n-     */\n-    public double getLInfDistance(ArrayRealVector v) {\n-        return getLInfDistance(v.data);\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public RealVector unitVector() {\n     /** {@inheritDoc} */\n     public RealVector projection(RealVector v) {\n         return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector projection(double[] v) {\n-        return projection(new ArrayRealVector(v, false));\n-    }\n-\n-    /**\n-     * Find the orthogonal projection of this vector onto another vector.\n-     *\n-     * @param v Vector onto which instance must be projected.\n-     * @return Projection of this instance onto {@code v}.\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * this vector.\n-     */\n-    public ArrayRealVector projection(ArrayRealVector v) {\n-        return (ArrayRealVector) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n     }\n \n     /** {@inheritDoc} */\n      * @throws DimensionMismatchException if {@code v} is not the same\n      * size as this vector.\n      */\n-    public RealMatrix outerProduct(ArrayRealVector v) {\n-        return outerProduct(v.data);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     public RealMatrix outerProduct(double[] v) {\n         final int m = data.length;\n         final int n = v.length;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector append(double[] in) {\n-        return new ArrayRealVector(this, in);\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector getSubVector(int index, int n) {\n         ArrayRealVector out = new ArrayRealVector(n);\n         try {\n     /** {@inheritDoc} */\n     @Override\n     public void setSubVector(int index, RealVector v) {\n-        try {\n+        if (v instanceof ArrayRealVector) {\n+            setSubVector(index, ((ArrayRealVector) v).data);\n+        } else {\n             try {\n-                set(index, (ArrayRealVector) v);\n-            } catch (ClassCastException cce) {\n                 for (int i = index; i < index + v.getDimension(); ++i) {\n                     data[i] = v.getEntry(i - index);\n                 }\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            checkIndex(index);\n-            checkIndex(index + v.getDimension() - 1);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n+            } catch (IndexOutOfBoundsException e) {\n+                checkIndex(index);\n+                checkIndex(index + v.getDimension() - 1);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     *\n+     * @param index Index of first element to be set.\n+     * @param v Vector containing the values to set.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is inconsistent with the vector size.\n+     */\n     public void setSubVector(int index, double[] v) {\n         try {\n             System.arraycopy(v, 0, data, index, v.length);\n             checkIndex(index);\n             checkIndex(index + v.length - 1);\n         }\n-    }\n-\n-    /**\n-     * Set a set of consecutive elements.\n-     *\n-     * @param index Index of first element to be set.\n-     * @param v Vector containing the values to set.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is inconsistent with the vector size.\n-     */\n-    public void set(int index, ArrayRealVector v) {\n-        setSubVector(index, v.data);\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /**\n-     * Returns the linear combination of {@code this} and {@code y}.\n-     *\n-     * @param a Weight of {@code this}.\n-     * @param b Weight of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n-     * {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    public ArrayRealVector combine(double a, double b, ArrayRealVector y) {\n-        return (ArrayRealVector) copy().combineToSelf(a, b, y.data);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector combineToSelf(double a, double b, double[] y) {\n-        checkVectorDimensions(y.length);\n-        for (int i = 0; i < this.data.length; i++) {\n-            data[i] = a * data[i] + b * y[i];\n-        }\n-        return this;\n-    }\n-\n-    /**\n      * Updates {@code this} with the linear combination of {@code this} and\n      * {@code y}.\n      *\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if {@code y} is not the same size as this vector.\n      */\n-    public ArrayRealVector combineToSelf(double a, double b, ArrayRealVector y) {\n-        combineToSelf(a, b, y.data);\n+    public ArrayRealVector combine(double a, double b, double[] y) {\n+        return copy().combineToSelf(a, b, y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public ArrayRealVector combine(double a, double b, RealVector y) {\n+        return copy().combineToSelf(a, b, y);\n+    }\n+\n+    /**\n+     * Updates {@code this} with the linear combination of {@code this} and\n+     * {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return {@code this}, with components equal to\n+     * {@code a * this[i] + b * y[i]} for all {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    public ArrayRealVector combineToSelf(double a, double b, double[] y) {\n+        checkVectorDimensions(y.length);\n+        for (int i = 0; i < this.data.length; i++) {\n+            data[i] = a * data[i] + b * y[i];\n+        }\n         return this;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector combineToSelf(double a, double b, RealVector y) {\n+    public ArrayRealVector combineToSelf(double a, double b, RealVector y) {\n         if (y instanceof ArrayRealVector) {\n             return combineToSelf(a, b, ((ArrayRealVector) y).data);\n         } else {\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n      * Zero-length vectors may be used to initialized construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n-     * or one of the {@code append} method ({@link #append(double)}, {@link\n-     * #append(double[])}, {@link #append(RealVector)}) to gather data\n-     * into this vector.\n+     * or one of the {@code append} method ({@link #append(double)},\n+     * {@link #append(RealVector)}) to gather data into this vector.\n      */\n     public OpenMapRealVector() {\n         this(0, DEFAULT_ZERO_TOLERANCE);\n \n     /** {@inheritDoc} */\n     @Override\n-        public RealVector add(RealVector v) {\n+    public RealVector add(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return add((OpenMapRealVector) v);\n     public OpenMapRealVector append(RealVector v) {\n         if (v instanceof OpenMapRealVector) {\n             return append((OpenMapRealVector) v);\n-        }\n-        return append(v.getData());\n+        } else {\n+            final OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n+            for (int i = 0; i < v.getDimension(); i++) {\n+                res.setEntry(i + virtualSize, v.getEntry(i));\n+            }\n+            return res;\n+        }\n     }\n \n     /** {@inheritDoc} */\n     public OpenMapRealVector append(double d) {\n         OpenMapRealVector res = new OpenMapRealVector(this, 1);\n         res.setEntry(virtualSize, d);\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public OpenMapRealVector append(double[] a) {\n-        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n-        for (int i = 0; i < a.length; i++) {\n-            res.setEntry(i + virtualSize, a[i]);\n-        }\n         return res;\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    @Override\n-    public OpenMapRealVector ebeDivide(double[] v) {\n-        checkVectorDimensions(v.length);\n+    public OpenMapRealVector ebeMultiply(RealVector v) {\n+        checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n-        }\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public OpenMapRealVector ebeMultiply(RealVector v) {\n-        checkVectorDimensions(v.getDimension());\n-        OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n-        }\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public OpenMapRealVector ebeMultiply(double[] v) {\n-        checkVectorDimensions(v.length);\n-        OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n         }\n         return res;\n     }\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return getDistance((OpenMapRealVector) v);\n-        }\n-        return getDistance(v.getData());\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double getDistance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double res = 0;\n-        for (int i = 0; i < v.length; i++) {\n-            double delta = entries.get(i) - v[i];\n-            res += delta * delta;\n-        }\n-        return FastMath.sqrt(res);\n+        } else {\n+            return super.getDistance(v);\n+        }\n     }\n \n     /** {@inheritDoc} */\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return getL1Distance((OpenMapRealVector) v);\n-        }\n-        return getL1Distance(v.getData());\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double getL1Distance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double max = 0;\n-        for (int i = 0; i < v.length; i++) {\n-            double delta = FastMath.abs(getEntry(i) - v[i]);\n-            max += delta;\n-        }\n-        return max;\n+        } else {\n+            return super.getL1Distance(v);\n+        }\n     }\n \n     /**\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return getLInfDistance((OpenMapRealVector) v);\n-        }\n-        return getLInfDistance(v.getData());\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double getLInfDistance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double max = 0;\n-        for (int i = 0; i < v.length; i++) {\n-            double delta = FastMath.abs(getEntry(i) - v[i]);\n-            if (delta > max) {\n-                max = delta;\n-            }\n-        }\n-        return max;\n+        } else {\n+            return super.getLInfDistance(v);\n+        }\n     }\n \n     /** {@inheritDoc} */\n         return this;\n     }\n \n-     /** {@inheritDoc} */\n-    @Override\n-    public RealMatrix outerProduct(double[] v) {\n-        final int n = v.length;\n-        RealMatrix res = new OpenMapRealMatrix(virtualSize, n);\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            int row = iter.key();\n-            double value = iter.value();\n-            for (int col = 0; col < n; col++) {\n-                res.setEntry(row, col, value * v[col]);\n-            }\n-        }\n-        return res;\n-    }\n-\n     /** {@inheritDoc} */\n     public RealVector projection(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public OpenMapRealVector projection(double[] v) {\n-        checkVectorDimensions(v.length);\n-        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n     }\n \n     /** {@inheritDoc} */\n     public void setSubVector(int index, RealVector v) {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n-        setSubVector(index, v.getData());\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setSubVector(int index, double[] v) {\n-        checkIndex(index);\n-        checkIndex(index + v.length - 1);\n-        for (int i = 0; i < v.length; i++) {\n-            setEntry(i + index, v[i]);\n+        for (int i = 0; i < v.getDimension(); i++) {\n+            setEntry(i + index, v.getEntry(i));\n         }\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealVector subtract(RealVector v) {\n+    public RealVector subtract(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return subtract((OpenMapRealVector) v);\n-        }\n-        return subtract(v.getData());\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public OpenMapRealVector subtract(double[] v) {\n-        checkVectorDimensions(v.length);\n-        OpenMapRealVector res = new OpenMapRealVector(this);\n-        for (int i = 0; i < v.length; i++) {\n-            if (entries.containsKey(i)) {\n-                res.setEntry(i, entries.get(i) - v[i]);\n-            } else {\n-                res.setEntry(i, -v[i]);\n-            }\n-        }\n-        return res;\n-    }\n-\n+        } else {\n+            return super.subtract(v);\n+        }\n+    }\n \n     /** {@inheritDoc} */\n     @Override\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n     public abstract RealVector append(double d);\n \n     /**\n-     * Construct a new vector by appending a double array to this vector.\n-     *\n-     * @param a double array to append.\n-     * @return a new vector.\n-     */\n-    public abstract RealVector append(double[] a);\n-\n-    /**\n      * Get a subvector from consecutive elements.\n      *\n      * @param index index of first element.\n      * @param v vector containing the values to set.\n      * @throws org.apache.commons.math.exception.OutOfRangeException\n      * if the index is not valid.\n-     * @see #setSubVector(int, double[])\n      */\n     public abstract void setSubVector(int index, RealVector v);\n-\n-    /**\n-     * Set a sequence of consecutive elements.\n-     *\n-     * @param index index of first element to be set.\n-     * @param v vector containing the values to set.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is not valid.\n-     * @see #setSubVector(int, RealVector)\n-     */\n-    public abstract void setSubVector(int index, double[] v);\n \n     /**\n      * Check whether any coordinate of this vector is {@code NaN}.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if {@code v} is not the same size as this vector.\n      */\n-    public RealVector add(double[] v) {\n-        double[] result = v.clone();\n-        Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n-            result[e.getIndex()] += e.getValue();\n-        }\n-        return new ArrayRealVector(result, false);\n-    }\n-\n-    /**\n-     * Compute the sum of this vector and {@code v}.\n-     * Returns a new vector. Does not change instance data.\n-     *\n-     * @param v Vector to be added.\n-     * @return {@code this} + {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n     public RealVector add(RealVector v) {\n-        if (v instanceof ArrayRealVector) {\n-            double[] values = ((ArrayRealVector)v).getDataRef();\n-            return add(values);\n-        }\n         RealVector result = v.copy();\n         Iterator<Entry> it = sparseIterator();\n         Entry e;\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if {@code v} is not the same size as this vector.\n      */\n-    public RealVector subtract(double[] v) {\n-        double[] result = v.clone();\n-        Iterator<Entry> it = sparseIterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n-            final int index = e.getIndex();\n-            result[index] = e.getValue() - result[index];\n-        }\n-        return new ArrayRealVector(result, false);\n-    }\n-\n-    /**\n-     * Subtract {@code v} from this vector.\n-     * Returns a new vector. Does not change instance data.\n-     *\n-     * @param v Vector to be subtracted.\n-     * @return {@code this} - {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n     public RealVector subtract(RealVector v) {\n-        if (v instanceof ArrayRealVector) {\n-            double[] values = ((ArrayRealVector)v).getDataRef();\n-            return add(values);\n-        }\n         RealVector result = v.copy();\n         Iterator<Entry> it = sparseIterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n             final int index = e.getIndex();\n-            v.setEntry(index, e.getValue() - result.getEntry(index));\n+            result.setEntry(index, e.getValue() - result.getEntry(index));\n         }\n         return result;\n     }\n      * @return a vector copy.\n      */\n     public abstract RealVector copy();\n-\n-    /**\n-     * Compute the dot product of this vector with a vector built from the\n-     * entries in {@code v}.\n-     *\n-     * @param v vector with which dot product should be computed\n-     * @return the scalar dot product between instance and v\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public double dotProduct(double[] v) {\n-        return dotProduct(new ArrayRealVector(v, false));\n-    }\n \n     /**\n      * Compute the dot product of this vector with {@code v}.\n     }\n \n     /**\n-     * Computes the cosine of the angle between this vector and the\n-     * vector whose components are given as argument.\n-     *\n-     * @param v Components of a vector.\n-     * @return the cosine of the angle between this vector and {@code v}.\n-     */\n-    public double cosine(double[] v) {\n-        return cosine(new ArrayRealVector(v, false));\n-    }\n-\n-    /**\n      * Element-by-element division.\n      *\n      * @param v Vector by which instance elements must be divided.\n     public abstract RealVector ebeDivide(RealVector v);\n \n     /**\n-     * Element-by-element division.\n-     * Returns a new vector. Does not change instance data.\n-     *\n-     * @param v Vector by which instance elements must be divided\n-     * @return a vector containing this[i] / v[i] for all i.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public RealVector ebeDivide(double[] v) {\n-        return ebeDivide(new ArrayRealVector(v, false));\n-    }\n-\n-    /**\n      * Element-by-element multiplication.\n      *\n      * @param v Vector by which instance elements must be multiplied\n      * if {@code v} is not the same size as this vector.\n      */\n     public abstract RealVector ebeMultiply(RealVector v);\n-\n-    /**\n-     * Element-by-element multiplication.\n-     * Returns a new vector. Does not change instance data.\n-     *\n-     * @param v Vector by which instance elements must be multiplied\n-     * @return a vector containing this[i] * v[i] for all i.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public RealVector ebeMultiply(double[] v) {\n-        return ebeMultiply(new ArrayRealVector(v, false));\n-    }\n \n     /**\n      * Distance between two vectors.\n     }\n \n     /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with the\n-     * L<sub>2</sub> norm, i.e. the square root of the sum of\n-     * element differences, or Euclidian distance.</p>\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getL1Distance(double[])\n-     * @see #getLInfDistance(double[])\n-     * @see #getNorm()\n-     */\n-    public double getDistance(double[] v) {\n-        return getDistance(new ArrayRealVector(v,false));\n-    }\n-\n-    /**\n      * Returns the L<sub>2</sub> norm of the vector.\n      * <p>The L<sub>2</sub> norm is the root of the sum of\n      * the squared elements.</p>\n      * @return the distance between two vectors.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if {@code v} is not the same size as this vector.\n-     * @see #getDistance(double[])\n-     * @see #getLInfDistance(double[])\n-     * @see #getL1Norm()\n      */\n     public double getL1Distance(RealVector v) {\n         checkVectorDimensions(v);\n     /**\n      * Distance between two vectors.\n      * <p>This method computes the distance consistent with\n-     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n-     * element differences.</p>\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getDistance(double[])\n-     * @see #getLInfDistance(double[])\n-     * @see #getL1Norm()\n-     */\n-    public double getL1Distance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double d = 0;\n-        Iterator<Entry> it = iterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n-            d += FastMath.abs(e.getValue() - v[e.getIndex()]);\n-        }\n-        return d;\n-    }\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n      * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n      * element differences.</p>\n      *\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n             d = FastMath.max(FastMath.abs(e.getValue() - v.getEntry(e.getIndex())), d);\n-        }\n-        return d;\n-    }\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n-     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n-     * elements differences.</p>\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return Distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getDistance(double[])\n-     * @see #getL1Distance(double[])\n-     * @see #getLInfNorm()\n-     */\n-    public double getLInfDistance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double d = 0;\n-        Iterator<Entry> it = iterator();\n-        Entry e;\n-        while (it.hasNext() && (e = it.next()) != null) {\n-            d = FastMath.max(FastMath.abs(e.getValue() - v[e.getIndex()]), d);\n         }\n         return d;\n     }\n     }\n \n     /**\n-     * Compute the outer product.\n-     *\n-     * @param v Vector with which outer product should be computed\n-     * @return the matrix outer product between instance and {@code v}.\n-     */\n-    public RealMatrix outerProduct(double[] v) {\n-        return outerProduct(new ArrayRealVector(v, false));\n-    }\n-\n-    /**\n      * Find the orthogonal projection of this vector onto another vector.\n      *\n      * @param v vector onto which instance must be projected.\n      * if {@code v} is not the same size as this vector.\n      */\n     public abstract RealVector projection(RealVector v);\n-\n-    /**\n-     * Find the orthogonal projection of this vector onto another vector.\n-     *\n-     * @param v Vector onto which instance must be projected.\n-     * @return the projection of the instance onto {@code v.}\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public RealVector projection(double[] v) {\n-        return projection(new ArrayRealVector(v, false));\n-    }\n \n     /**\n      * Set all elements to a single value.\n     }\n \n     /**\n-     * Convert the vector to a double array.\n-     * <p>The array is independent from vector data, it's elements\n-     * are copied.</p>\n-     *\n-     * @return an array containing a copy of vector elements.\n+     * Convert the vector to an array of {@code double}s.\n+     * The array is independent from this vector data: the elements\n+     * are copied.\n+     *\n+     * @return an array containing a copy of the vector elements.\n      */\n     public double[] toArray() {\n         int dim = getDimension();\n     }\n \n     /**\n-     * Returns vector entries as a double array.\n-     * <p>The array is independent from vector data, it's elements\n-     * are copied.</p>\n-     *\n-     * @return a {@code double} array of entries.\n+     * Convert the vector to an array of {@code double}s.\n+     * The array is independent from this vector data: the elements\n+     * are copied.\n+     *\n+     * @return an array containing a copy of the vector elements.\n      */\n     public double[] getData() {\n         return toArray();\n     }\n \n     /**\n-     * Returns a new vector representing {@code a*this + b*y}, the linear\n-     * combination of {@code this} and a vector with components equal to the\n-     * entries in {@code y}.\n+     * Returns a new vector representing {@code a * this + b * y}, the linear\n+     * combination of {@code this} and {@code y}.\n      * Returns a new vector. Does not change instance data.\n      *\n      * @param a Coefficient of {@code this}.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if {@code y} is not the same size as this vector.\n      */\n-    public RealVector combine(double a, double b, double[] y) {\n-        return copy().combineToSelf(a, b, y);\n-    }\n-\n-    /**\n-     * Returns a new vector representing {@code a * this + b * y}, the linear\n-     * combination of {@code this} and {@code y}.\n-     * Returns a new vector. Does not change instance data.\n-     *\n-     * @param a Coefficient of {@code this}.\n-     * @param b Coefficient of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n-     * {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n     public RealVector combine(double a, double b, RealVector y) {\n         return copy().combineToSelf(a, b, y);\n-    }\n-\n-    /**\n-     * Updates {@code this} with the linear combination of {@code this} and\n-     * a vector with components equal to the entries of {@code y}.\n-     *\n-     * @param a Coefficient of {@code this}.\n-     * @param b Coefficient of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return {@code this}, with components equal to\n-     * {@code a * this[i] + b * y[i]} for all {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    public RealVector combineToSelf(double a, double b, double[] y) {\n-        return combineToSelf(a, b, new ArrayRealVector(y, false));\n     }\n \n     /**\n         return new RealVector() {\n             /** {@inheritDoc} */\n             @Override\n+            public double[] getData() {\n+                return v.getData();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n             public RealVector mapToSelf(UnivariateRealFunction function) {\n                 throw new MathUnsupportedOperationException();\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector add(double[] w) {\n-                return v.add(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public RealVector subtract(RealVector w) {\n                 return v.subtract(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector subtract(double[] w) {\n-                return v.subtract(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public RealVector mapAdd(double d) {\n                 return v.mapAdd(d);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector ebeMultiply(double[] w) {\n-                return v.ebeMultiply(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public RealVector ebeDivide(RealVector w) {\n                 return v.ebeDivide(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector ebeDivide(double[] w) {\n-                return v.ebeDivide(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n-            public double[] getData() {\n-                // TODO It is not specified in the javadoc that getData should\n-                // return a\n-                // deep copy\n-                return v.getData();\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public double dotProduct(RealVector w) {\n                 return v.dotProduct(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double dotProduct(double[] w) {\n-                return v.dotProduct(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public double cosine(RealVector w) {\n                 return v.cosine(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double cosine(double[] w) {\n-                return v.cosine(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public double getNorm() {\n                 return v.getNorm();\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double getDistance(double[] w) {\n-                return v.getDistance(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public double getL1Distance(RealVector w) {\n                 return v.getL1Distance(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double getL1Distance(double[] w) {\n-                return v.getL1Distance(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public double getLInfDistance(RealVector w) {\n                 return v.getLInfDistance(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public double getLInfDistance(double[] w) {\n-                return v.getLInfDistance(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public RealVector unitVector() {\n                 return v.unitVector();\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector projection(double[] w) {\n-                return v.projection(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public RealMatrix outerProduct(RealVector w) {\n                 return v.outerProduct(w);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealMatrix outerProduct(double[] w) {\n-                return v.outerProduct(w);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public double getEntry(int index) {\n                 return v.getEntry(index);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector append(double[] a) {\n-                return v.append(a);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public RealVector getSubVector(int index, int n) {\n                 return v.getSubVector(index, n);\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public void setSubVector(int index, double[] w) {\n-                throw new MathUnsupportedOperationException();\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public void set(double value) {\n                 throw new MathUnsupportedOperationException();\n             }\n \n             /** {@inheritDoc} */\n             @Override\n-            public RealVector combine(double a, double b, double[] y) {\n-                return v.combine(a, b, y);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n             public RealVector combine(double a, double b, RealVector y) {\n                 return v.combine(a, b, y);\n-            }\n-\n-            /** {@inheritDoc} */\n-            @Override\n-            public RealVector combineToSelf(double a, double b, double[] y) {\n-                throw new MathUnsupportedOperationException();\n             }\n \n             /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n      * @return value of the linear equation at the current point\n      */\n     public double getValue(final double[] point) {\n-        return coefficients.dotProduct(point) + constantTerm;\n+        return coefficients.dotProduct(new ArrayRealVector(point, false)) + constantTerm;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n                 }\n             };\n \n+        final UnivariateRealSolver solverS = new SecantSolver();\n+        final double rootS = solverS.solve(3624, f, 1, 10);\n+        System.out.println(\"rootS=\" + rootS + \" n=\" + solverS.getEvaluations());\n+        Assert.assertEquals(3.4341896575, rootS, 1e-10);\n+\n         final UnivariateRealSolver solver = new RegulaFalsiSolver();\n         final double root = solver.solve(3624, f, 1, 10);\n         Assert.assertEquals(3.4341896575482003, root, 1e-15);\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n         Assert.assertEquals(\"testData len\", 4, v_append_2.getDimension());\n         Assert.assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3), 0);\n \n-        RealVector v_append_3 = v1.append(vec2);\n-        Assert.assertEquals(\"testData len\", 6, v_append_3.getDimension());\n-        Assert.assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3), 0);\n-\n         RealVector v_append_4 = v1.append(v2_t);\n         Assert.assertEquals(\"testData len\", 6, v_append_4.getDimension());\n         Assert.assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3), 0);\n         Assert.assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1), 0);\n         try {\n             v_set1.setEntry(3, 11.0);\n-            Assert.fail(\"OutOfRangeException expected\");\n-        } catch (OutOfRangeException ex) {\n-            // expected behavior\n-        }\n-\n-        ArrayRealVector v_set2 = v4.copy();\n-        v_set2.set(3, v1);\n-        Assert.assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3), 0);\n-        Assert.assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6), 0);\n-        try {\n-            v_set2.set(7, v1);\n             Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n             // expected behavior\n         }\n \n-        ArrayRealVector v_projection = v1.projection(v2);\n+        RealVector v_projection = v1.projection(v2);\n         double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n         assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n \n         RealVector v_projection_2 = v1.projection(v2_t);\n         double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n         assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n-\n-        RealVector v_projection_3 = v1.projection(v2.getData());\n-        double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n-        assertClose(\"compare vect\", v_projection_3.getData(), result_projection_3, normTolerance);\n-\n     }\n \n     @Test\n \n         double[] wData = new double[] {1, 1, 0};\n         RealVector w = new ArrayRealVector(wData);\n-        Assert.assertEquals(FastMath.sqrt(2) / 2, v.cosine(wData), normTolerance);\n         Assert.assertEquals(FastMath.sqrt(2) / 2, v.cosine(w), normTolerance);\n \n         wData = new double[] {1, 0, 0};\n         w = new ArrayRealVector(wData);\n-        Assert.assertEquals(1, v.cosine(wData), normTolerance);\n         Assert.assertEquals(1, v.cosine(w), normTolerance);\n \n         wData = new double[] {0, 1, 0};\n         w = new ArrayRealVector(wData);\n-        Assert.assertEquals(0, v.cosine(wData), normTolerance);\n         Assert.assertEquals(0, v.cosine(w), 0);\n \n         wData = new double[] {-1, 0, 0};\n         w = new ArrayRealVector(wData);\n-        Assert.assertEquals(-1, v.cosine(wData), normTolerance);\n         Assert.assertEquals(-1, v.cosine(w), normTolerance);\n     }\n \n         final double a = 1d;\n         final double b = 2d;\n         double[] aux = new double[] { 3d, 4d, 5d };\n-        final RealVector x = new ArrayRealVector(aux, false);\n+        final ArrayRealVector x = new ArrayRealVector(aux, false);\n         final double[] y = new double[] { 6d, 7d };\n         x.combine(a, b, y);\n     }\n         final int dim = 10;\n         final double a = (2 * random.nextDouble() - 1);\n         final double b = (2 * random.nextDouble() - 1);\n-        final RealVector x = new ArrayRealVector(dim);\n+        final ArrayRealVector x = new ArrayRealVector(dim);\n         final double[] y = new double[dim];\n         final double[] expected = new double[dim];\n         for (int i = 0; i < dim; i++) {\n         final double a = 1d;\n         final double b = 2d;\n         double[] aux = new double[] { 3d, 4d, 5d };\n-        final RealVector x = new ArrayRealVector(aux, false);\n+        final ArrayRealVector x = new ArrayRealVector(aux, false);\n         final double[] y = new double[] { 6d, 7d };\n         x.combineToSelf(a, b, y);\n     }\n         final int dim = 10;\n         final double a = (2 * random.nextDouble() - 1);\n         final double b = (2 * random.nextDouble() - 1);\n-        final RealVector x = new ArrayRealVector(dim);\n+        final ArrayRealVector x = new ArrayRealVector(dim);\n         final double[] y = new double[dim];\n         final double[] expected = new double[dim];\n         for (int i = 0; i < dim; i++) {\n--- a/src/test/java/org/apache/commons/math/linear/RealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorTest.java\n         }\n \n         @Override\n-        public double[] getData() { return values; }\n+        public double[] toArray() { return values; }\n \n         @Override\n         public RealVector copy() {\n         double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };\n         RealVector v = new TestVectorImpl(vec1.clone());\n         RealVector w = v.map(new UnivariateRealFunction() { public double value(double x) { return x * x; } });\n-        double[] d2 = w.getData();\n+        double[] d2 = w.toArray();\n         Assert.assertEquals(vec1Squared.length, d2.length);\n         for(int i=0; i<vec1Squared.length; i++) {\n             Assert.assertEquals(vec1Squared[i], d2[i], 0);\n         }\n         final RealVector z = x.combine(a, b, y);\n         Assert.assertTrue(z != x);\n-        final double[] actual = z.getData();\n+        final double[] actual = z.toArray();\n         for (int i = 0; i < dim; i++) {\n             final double delta;\n             if (expected[i] == 0d) {\n             expected[i] = a * xi + b * yi;\n         }\n         Assert.assertSame(x, x.combineToSelf(a, b, y));\n-        final double[] actual = x.getData();\n+        final double[] actual = x.toArray();\n         for (int i = 0; i < dim; i++) {\n             final double delta;\n             if (expected[i] == 0d) {\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n             throw unsupported();\n         }\n \n-        @Override\n-        public RealVector add(double[] v) {\n-            throw unsupported();\n-        }\n \n         @Override\n         public RealVector subtract(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector subtract(double[] v) {\n             throw unsupported();\n         }\n \n             throw unsupported();\n         }\n \n-        @Override\n-        public RealVector ebeMultiply(double[] v) {\n-            throw unsupported();\n-        }\n-\n         public RealVector ebeDivide(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector ebeDivide(double[] v) {\n             throw unsupported();\n         }\n \n         }\n \n         @Override\n-        public double dotProduct(double[] v) {\n-            double dot = 0;\n-            for (int i = 0; i < data.length; i++) {\n-                dot += data[i] * v[i];\n-            }\n-            return dot;\n-        }\n-\n-        @Override\n         public double getNorm() {\n             throw unsupported();\n         }\n         }\n \n         @Override\n-        public double getDistance(double[] v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n         public double getL1Distance(RealVector v) {\n             throw unsupported();\n         }\n \n         @Override\n-        public double getL1Distance(double[] v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n         public double getLInfDistance(RealVector v) {\n             throw unsupported();\n         }\n \n         @Override\n-        public double getLInfDistance(double[] v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n         public RealVector unitVector() {\n             throw unsupported();\n         }\n         }\n \n         @Override\n-        public RealVector projection(double[] v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n         public RealMatrix outerProduct(RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealMatrix outerProduct(double[] v) {\n             throw unsupported();\n         }\n \n             throw unsupported();\n         }\n \n-        public RealVector append(double[] a) {\n-            throw unsupported();\n-        }\n-\n         public RealVector getSubVector(int index, int n) {\n             throw unsupported();\n         }\n \n         @Override\n         public void setSubVector(int index, RealVector v) {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public void setSubVector(int index, double[] v) {\n             throw unsupported();\n         }\n \n         Assert.assertEquals(\"testData len\", 4, v_append_2.getDimension());\n         Assert.assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3), 0);\n \n-        RealVector v_append_3 = v1.append(vec2);\n-        Assert.assertEquals(\"testData len\", 6, v_append_3.getDimension());\n-        Assert.assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3), 0);\n-\n         RealVector v_append_4 = v1.append(v2_t);\n         Assert.assertEquals(\"testData len\", 6, v_append_4.getDimension());\n         Assert.assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3), 0);\n \n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, double[] m, double[] n,\n-            double tolerance) {\n+                               double tolerance) {\n         if (m.length != n.length) {\n             Assert.fail(\"vectors have different lengths\");\n         }\n         u.setEntry(2, 2);\n \n         final RealVector v1 = new OpenMapRealVector(3, 1e-6);\n-        final double[] v2 = new double[3];\n         v1.setEntry(0, 0);\n-        v2[0] = 0;\n         v1.setEntry(1, 3);\n-        v2[1] = 3;\n         v1.setEntry(2, 0);\n-        v2[2] = 0;\n \n         RealVector w;\n \n         w = u.ebeMultiply(v1);\n-        w = u.ebeMultiply(v2);\n-\n         w = u.ebeDivide(v1);\n-        w = u.ebeDivide(v2);\n     }\n }", "timestamp": 1314582264, "metainfo": ""}