{"sha": "320475b3cdc3ea06af3b46b6c0dca20a8c2e6e53", "log": "MATH-874 First steps to upgrade the API of the classes in \"o.a.c.m.optimization.general\". Please note the introduction of a \"Weight\" matrix (whereas the current code assumes that the weights are given as an array).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n+import org.apache.commons.math3.optimization.OptimizationData;\n+import org.apache.commons.math3.optimization.InitialGuess;\n+import org.apache.commons.math3.optimization.Target;\n+import org.apache.commons.math3.optimization.Weight;\n import org.apache.commons.math3.optimization.BaseMultivariateVectorOptimizer;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n import org.apache.commons.math3.optimization.PointVectorValuePair;\n import org.apache.commons.math3.optimization.SimpleVectorValueChecker;\n+import org.apache.commons.math3.linear.RealMatrix;\n \n /**\n  * Base class for implementing optimizers for multivariate scalar functions.\n     private ConvergenceChecker<PointVectorValuePair> checker;\n     /** Target value for the objective functions at optimum. */\n     private double[] target;\n-    /** Weight for the least squares cost computation. */\n+    /** Weight matrix. */\n+    private RealMatrix weightMatrix;\n+    /** Weight for the least squares cost computation.\n+     * @deprecated\n+     */\n     private double[] weight;\n     /** Initial guess. */\n     private double[] start;\n     /** Objective function. */\n-    private MultivariateVectorFunction function;\n+    private FUNC function;\n \n     /**\n      * Simple constructor with default settings.\n         return function.value(point);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     *\n+     * @deprecated As of 3.1. Please use\n+     * {@link #optimize(int,MultivariateVectorFunction,OptimizationData[])}\n+     * instead.\n+     */\n+    @Deprecated\n     public PointVectorValuePair optimize(int maxEval, FUNC f, double[] t, double[] w,\n                                          double[] startPoint) {\n         return optimizeInternal(maxEval, f, t, w, startPoint);\n+    }\n+\n+    /**\n+     * Optimize an objective function.\n+     *\n+     * @param maxEval Allowed number of evaluations of the objective function.\n+     * @param f Objective function.\n+     * @param optData Optimization data. The following data will be looked for:\n+     * <ul>\n+     *  <li>{@link Target}</li>\n+     *  <li>{@link Weight}</li>\n+     *  <li>{@link InitialGuess}</li>\n+     * </ul>\n+     * @return the point/value pair giving the optimal value of the objective\n+     * function.\n+     * @throws TooManyEvaluationsException if the maximal number of\n+     * evaluations is exceeded.\n+     * @throws DimensionMismatchException if the initial guess, target, and weight\n+     * arguments have inconsistent dimensions.\n+     *\n+     * @since 3.1\n+     */\n+    protected PointVectorValuePair optimize(int maxEval,\n+                                            FUNC f,\n+                                            OptimizationData... optData)\n+        throws TooManyEvaluationsException,\n+               DimensionMismatchException {\n+        return optimizeInternal(maxEval, f, optData);\n     }\n \n     /**\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math3.exception.NullArgumentException if\n      * any argument is {@code null}.\n-     */\n-    protected PointVectorValuePair optimizeInternal(final int maxEval, final MultivariateVectorFunction f,\n+     * @deprecated As of 3.1. Please use\n+     * {@link #optimizeInternal(int,MultivariateVectorFunction,OptimizationData[])}\n+     * instead.\n+     */\n+    @Deprecated\n+    protected PointVectorValuePair optimizeInternal(final int maxEval, final FUNC f,\n                                                     final double[] t, final double[] w,\n                                                     final double[] startPoint) {\n         // Checks.\n             throw new DimensionMismatchException(t.length, w.length);\n         }\n \n-        // Reset.\n+        return optimizeInternal(maxEval, f,\n+                                new Target(t),\n+                                new Weight(w),\n+                                new InitialGuess(startPoint));\n+    }\n+\n+    /**\n+     * Optimize an objective function.\n+     *\n+     * @param maxEval Allowed number of evaluations of the objective function.\n+     * @param f Objective function.\n+     * @param optData Optimization data. The following data will be looked for:\n+     * <ul>\n+     *  <li>{@link Target}</li>\n+     *  <li>{@link Weight}</li>\n+     *  <li>{@link InitialGuess}</li>\n+     * </ul>\n+     * @return the point/value pair giving the optimal value of the objective\n+     * function.\n+     * @throws TooManyEvaluationsException if the maximal number of\n+     * evaluations is exceeded.\n+     * @throws DimensionMismatchException if the initial guess, target, and weight\n+     * arguments have inconsistent dimensions.\n+     *\n+     * @since 3.1\n+     */\n+    protected PointVectorValuePair optimizeInternal(int maxEval,\n+                                                    FUNC f,\n+                                                    OptimizationData... optData)\n+        throws TooManyEvaluationsException,\n+               DimensionMismatchException {\n+        // Set internal state.\n         evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n-\n-        // Store optimization problem characteristics.\n         function = f;\n-        target = t.clone();\n-        weight = w.clone();\n-        start = startPoint.clone();\n-\n+        // Retrieve other settings.\n+        parseOptimizationData(optData);\n+        // Check input consistency.\n+        checkParameters();\n+        // Allow subclasses to reset their own internal state.\n+        setUp();\n         // Perform computation.\n         return doOptimize();\n-\n-    }\n-\n-    /**\n+    }\n+\n+    /**\n+     * Gets the initial values of the optimized parameters.\n+     *\n      * @return the initial guess.\n      */\n     public double[] getStartPoint() {\n     }\n \n     /**\n+     * Gets the weight matrix of the observations.\n+     *\n+     * @return the weight matrix.\n+     * @since 3.1\n+     */\n+    public RealMatrix getWeight() {\n+        return weightMatrix.copy();\n+    }\n+    /**\n+     * Gets the observed values to be matched by the objective vector\n+     * function.\n+     *\n+     * @return the target values.\n+     * @since 3.1\n+     */\n+    public double[] getTarget() {\n+        return target.clone();\n+    }\n+\n+    /**\n+     * Computes the residuals.\n+     * The residual is the difference between the observed (target)\n+     * values and the model (objective function) value, for the given\n+     * parameters.\n+     * There is one residual for each element of the vector-valued\n+     * function.\n+     *\n+     * @param point Parameters of the model.\n+     * @return the residuals.\n+     * @throws DimensionMismatchException if {@code point} has a wrong\n+     * length.\n+     * @since 3.1\n+     */\n+    protected double[] computeResidual(double[] point) {\n+        if (point.length != start.length) {\n+            throw new DimensionMismatchException(point.length,\n+                                                 start.length);\n+        }\n+\n+        final double[] objective = computeObjectiveValue(point);\n+\n+        final double[] residuals = new double[target.length];\n+        for (int i = 0; i < target.length; i++) {\n+            residuals[i] = target[i] - objective[i];\n+        }\n+\n+        return residuals;\n+    }\n+\n+\n+    /**\n+     * Gets the objective vector function.\n+     * Note that this access bypasses the evaluation counter.\n+     *\n+     * @return the objective vector function.\n+     * @since 3.1\n+     */\n+    protected FUNC getObjectiveFunction() {\n+        return function;\n+    }\n+\n+    /**\n      * Perform the bulk of the optimization algorithm.\n      *\n      * @return the point/value pair giving the optimal value for the\n \n     /**\n      * @return a reference to the {@link #target array}.\n-     */\n+     * @deprecated As of 3.1.\n+     */\n+    @Deprecated\n     protected double[] getTargetRef() {\n         return target;\n     }\n     /**\n      * @return a reference to the {@link #weight array}.\n-     */\n+     * @deprecated As of 3.1.\n+     */\n+    @Deprecated\n     protected double[] getWeightRef() {\n         return weight;\n     }\n+\n+    /**\n+     * Method which a subclass <em>must</em> override whenever its internal\n+     * state depend on the {@link OptimizationData input} parsed by this base\n+     * class.\n+     * It will be called after the parsing step performed in the\n+     * {@link #optimize(int,MultivariateVectorFunction,OptimizationData[]) \n+     * optimize} method and just before {@link #doOptimize()}.\n+     *\n+     * @since 3.1\n+     */\n+    protected void setUp() {\n+        // XXX Temporary code until the new internal data is used everywhere.\n+        final int dim = target.length;\n+        weight = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            weight[i] = weightMatrix.getEntry(i, i);\n+        }\n+    }\n+\n+    /**\n+     * Scans the list of (required and optional) optimization data that\n+     * characterize the problem.\n+     *\n+     * @param optData Optimization data. The following data will be looked for:\n+     * <ul>\n+     *  <li>{@link Target}</li>\n+     *  <li>{@link Weight}</li>\n+     *  <li>{@link InitialGuess}</li>\n+     * </ul>\n+     */\n+    private void parseOptimizationData(OptimizationData... optData) {\n+        // The existing values (as set by the previous call) are reused if\n+        // not provided in the argument list.\n+        for (OptimizationData data : optData) {\n+            if (data instanceof Target) {\n+                target = ((Target) data).getTarget();\n+                continue;\n+            }\n+            if (data instanceof Weight) {\n+                weightMatrix = ((Weight) data).getWeight();\n+                continue;\n+            }\n+            if (data instanceof InitialGuess) {\n+                start = ((InitialGuess) data).getInitialGuess();\n+                continue;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check parameters consistency.\n+     *\n+     * @throws DimensionMismatchException if {@link #target} and\n+     * {@link #weightMatrix} have inconsistent dimensions.\n+     */\n+    private void checkParameters() {\n+        if (target.length != weightMatrix.getColumnDimension()) {\n+            throw new DimensionMismatchException(target.length,\n+                                                 weightMatrix.getColumnDimension());\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math3.linear.DecompositionSolver;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n+import org.apache.commons.math3.optimization.OptimizationData;\n+import org.apache.commons.math3.optimization.InitialGuess;\n+import org.apache.commons.math3.optimization.Target;\n+import org.apache.commons.math3.optimization.Weight;\n import org.apache.commons.math3.optimization.ConvergenceChecker;\n import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math3.optimization.PointVectorValuePair;\n     }\n \n     /** {@inheritDoc}\n-     * @deprecated as of 3.1 replaced by {@link #optimize(int,\n-     * MultivariateDifferentiableVectorFunction, double[], double[], double[])}\n+     * @deprecated As of 3.1. Please use\n+     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n+     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n+     * instead.\n      */\n     @Override\n     @Deprecated\n                                          final DifferentiableMultivariateVectorFunction f,\n                                          final double[] target, final double[] weights,\n                                          final double[] startPoint) {\n-        return optimize(maxEval, FunctionUtils.toMultivariateDifferentiableVectorFunction(f),\n-                        target, weights, startPoint);\n+        return optimizeInternal(maxEval,\n+                                FunctionUtils.toMultivariateDifferentiableVectorFunction(f),\n+                                new Target(target),\n+                                new Weight(weights),\n+                                new InitialGuess(startPoint));\n     }\n \n     /**\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math3.exception.NullArgumentException if\n      * any argument is {@code null}.\n-     */\n+     * @deprecated As of 3.1. Please use\n+     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n+     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n+     * instead.\n+     */\n+    @Deprecated\n     public PointVectorValuePair optimize(final int maxEval,\n                                          final MultivariateDifferentiableVectorFunction f,\n                                          final double[] target, final double[] weights,\n                                          final double[] startPoint) {\n+        return optimizeInternal(maxEval, f,\n+                                new Target(target),\n+                                new Weight(weights),\n+                                new InitialGuess(startPoint));\n+    }\n+\n+    /**\n+     * Optimize an objective function.\n+     * Optimization is considered to be a weighted least-squares minimization.\n+     * The cost function to be minimized is\n+     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n+     *\n+     * @param maxEval Allowed number of evaluations of the objective function.\n+     * @param f Objective function.\n+     * @param optData Optimization data. The following data will be looked for:\n+     * <ul>\n+     *  <li>{@link Target}</li>\n+     *  <li>{@link Weight}</li>\n+     *  <li>{@link InitialGuess}</li>\n+     * </ul>\n+     * @return the point/value pair giving the optimal value of the objective\n+     * function.\n+     * @throws TooManyEvaluationsException if the maximal number of\n+     * evaluations is exceeded.\n+     * @throws DimensionMismatchException if the target, and weight arguments\n+     * have inconsistent dimensions.\n+     * @see BaseAbstractMultivariateVectorOptimizer#optimizeInternal(int,MultivariateVectorFunction,OptimizationData[])\n+     *\n+     * @since 3.1\n+     */\n+    protected PointVectorValuePair optimizeInternal(final int maxEval,\n+                                                    final MultivariateDifferentiableVectorFunction f,\n+                                                    OptimizationData... optData) {\n+        // XXX Conversion will be removed when the generic argument of the\n+        // base class becomes \"MultivariateDifferentiableVectorFunction\".\n+        return super.optimizeInternal(maxEval, FunctionUtils.toDifferentiableMultivariateVectorFunction(f), optData);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void setUp() {\n+        super.setUp();\n \n         // Reset counter.\n         jacobianEvaluations = 0;\n \n         // Store least squares problem characteristics.\n-        jF = f;\n+        // XXX The conversion won't be necessary when the generic argument of\n+        // the base class becomes \"MultivariateDifferentiableVectorFunction\".\n+        // XXX \"jF\" is not strictly necessary anymore but is currently more\n+        // efficient than converting the value returned from \"getObjectiveFunction()\"\n+        // every time it is used.\n+        jF = FunctionUtils.toMultivariateDifferentiableVectorFunction((DifferentiableMultivariateVectorFunction) getObjectiveFunction());\n \n         // Arrays shared with the other private methods.\n-        point = startPoint.clone();\n-        rows = target.length;\n+        point = getStartPoint();\n+        rows = getTarget().length;\n         cols = point.length;\n \n         weightedResidualJacobian = new double[rows][cols];\n         this.weightedResiduals = new double[rows];\n \n         cost = Double.POSITIVE_INFINITY;\n-\n-        return optimizeInternal(maxEval, f, target, weights, startPoint);\n-    }\n-\n+    }\n }", "timestamp": 1351275580, "metainfo": ""}