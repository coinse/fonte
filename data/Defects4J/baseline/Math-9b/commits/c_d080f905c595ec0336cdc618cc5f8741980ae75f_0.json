{"sha": "d080f905c595ec0336cdc618cc5f8741980ae75f", "log": "fixed some javadoc  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n  * class from the now defunct <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a>\n  * library, with the following changes:</p>\n  * <ul>\n- *   <li><code>solve</code> methods have been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n- *   method has been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n- *   been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n- *   added (in the superinterface),</li>\n  *   <li>a {@link #getVT() getVt} method has been added,</li>\n  *   <li>a {@link #getEigenvalue(int) getEigenvalue} method to pick up a single\n  *   eigenvalue has been added,</li>\n--- a/src/java/org/apache/commons/math/linear/LUDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecomposition.java\n  * to rearrange the rows of A before so that it can be decomposed. L is a lower\n  * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n  * <p>This interface is based on the class with similar name from the now defunct\n- * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n- * following changes:</p>\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n  * <ul>\n- *   <li>several signatures have been added for the <code>solve</code> methods\n- *   (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n- *   method has been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n- *   been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n- *   added (in the superinterface),</li>\n+ *   <li>a {@link #getSolver() getSolver} method has been added.</li>\n  *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant() getDeterminant}.</li>\n  * </ul>\n  *   \n public interface LUDecomposition extends Serializable {\n \n     /**\n-     * Computes a new\n-     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n-     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n-     * <p>\n-     * <strong>Implementation Note</strong>:<br>\n-     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n-     * Crout's algorithm</a>, with partial pivoting.</p>\n-     * @param matrix The matrix to decompose.\n-     * @param singularityThreshold threshold (based on partial row norm)\n-     * under which a matrix is considered singular\n-     * @exception InvalidMatrixException if matrix is not square\n-     */\n-    void decompose(RealMatrix matrix, double singularityThreshold);\n-\n-    /**\n      * Returns the matrix L of the decomposition. \n      * <p>L is an lower-triangular matrix</p>\n      * @return the L matrix (or null if decomposed matrix is singular)\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getL() throws IllegalStateException;\n+    RealMatrix getL();\n \n     /**\n      * Returns the matrix U of the decomposition. \n      * <p>U is an upper-triangular matrix</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getU() throws IllegalStateException;\n+    RealMatrix getU();\n \n     /**\n      * Returns the P rows permutation matrix.\n      * <p>The positions of the 1 elements are given by the {@link #getPivot()\n      * pivot permutation vector}.</p>\n      * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getPivot()\n      */\n-    RealMatrix getP() throws IllegalStateException;\n+    RealMatrix getP();\n \n     /**\n      * Returns the pivot permutation vector.\n      * @return the pivot permutation vector\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getPermutation()\n      */\n-    int[] getPivot() throws IllegalStateException;\n+    int[] getPivot();\n \n     /**\n      * Get permutation parity.\n      * Get the singularity indicator.\n      * @return singularity indicator\n      */\n-    public boolean isSingular();\n+    boolean isSingular();\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    double getDeterminant();\n+\n+    /**\n+     * Get a solver for A &times; X = B.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n \n }\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\n  * <ul>\n- *   <li>several signatures have been added for the <code>solve</code> methods\n- *   (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n- *   method has been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n- *   added (in the superinterface),</li>\n- *   <li>the <code>isFullRank</code> method has been replaced by the {@link\n- *   DecompositionSolver#isNonSingular() isNonSingular} method in the superinterface.</li>\n+ *   <li>a {@link #getSolver() getSolver} method has been added.</li>\n  * </ul>\n  *   \n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n      * Returns the matrix R of the decomposition. \n      * <p>R is an upper-triangular matrix</p>\n      * @return the R matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n     RealMatrix getR() throws IllegalStateException;\n \n      * Returns the matrix Q of the decomposition.\n      * <p>Q is an orthogonal matrix</p>\n      * @return the Q matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getQ() throws IllegalStateException;\n+    RealMatrix getQ();\n \n     /**\n      * Returns the transpose of the matrix Q of the decomposition.\n      * <p>Q is an orthogonal matrix</p>\n      * @return the Q matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getQT() throws IllegalStateException;\n+    RealMatrix getQT();\n \n     /**\n      * Returns the Householder reflector vectors.\n      * each successive Householder reflector vector. This matrix is used\n      * to compute Q.</p>\n      * @return a matrix containing the Householder reflector vectors\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getH() throws IllegalStateException;\n+    RealMatrix getH();\n \n     /**\n      * Get a solver for A &times; X = B.\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\n  * <ul>\n- *   <li><code>solve</code> methods have been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n- *   method has been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n- *   been added (in the superinterface),</li>\n- *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n- *   added (in the superinterface),</li>\n  *   <li>the <code>norm2</code> method which has been renamed as {@link #getNorm()\n  *   getNorm},</li>\n  *   <li>the <code>cond</code> method which has been renamed as {@link\n      * Returns the matrix U of the decomposition. \n      * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the U matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getUT()\n      */\n-    RealMatrix getU() throws IllegalStateException;\n+    RealMatrix getU();\n \n     /**\n      * Returns the transpose of the matrix U of the decomposition. \n      * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getU()\n      */\n-    RealMatrix getUT() throws IllegalStateException;\n+    RealMatrix getUT();\n \n     /**\n      * Returns the diagonal matrix &Sigma; of the decomposition. \n      * <p>&Sigma; is a diagonal matrix. The singular values are provided in\n      * non-increasing order, for compatibility with Jama.</p>\n      * @return the &Sigma; matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getS() throws IllegalStateException;\n+    RealMatrix getS();\n \n     /**\n      * Returns the diagonal elements of the matrix &Sigma; of the decomposition.\n      * <p>The singular values are provided in non-increasing order, for\n      * compatibility with Jama.</p>\n      * @return the diagonal elements of the &Sigma; matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    double[] getSingularValues() throws IllegalStateException;\n+    double[] getSingularValues();\n \n     /**\n      * Returns the matrix V of the decomposition. \n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the V matrix (or null if decomposed matrix is singular)\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getVT()\n      */\n-    RealMatrix getV() throws IllegalStateException;\n+    RealMatrix getV();\n \n     /**\n      * Returns the transpose of the matrix V of the decomposition. \n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the V matrix (or null if decomposed matrix is singular)\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getV()\n      */\n-    RealMatrix getVT() throws IllegalStateException;\n+    RealMatrix getVT();\n \n     /**\n      * Returns the L<sub>2</sub> norm of the matrix.\n      * |u|<sub>2</sub>), where |.|<sub>2</sub> denotes the vectorial 2-norm\n      * (i.e. the traditional euclidian norm).</p>\n      * @return norm\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    double getNorm() throws IllegalStateException;\n+    double getNorm();\n \n     /**\n      * Return the condition number of the matrix.\n      * @return condition number of the matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    double getConditionNumber() throws IllegalStateException;\n+    double getConditionNumber();\n \n     /**\n      * Return the effective numerical matrix rank.\n      * terms is max(m,n) &times; ulp(s<sub>1</sub>) where ulp(s<sub>1</sub>)\n      * is the least significant bit of the largest singular value.</p>\n      * @return effective numerical matrix rank\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    int getRank() throws IllegalStateException;\n+    int getRank();\n \n }", "timestamp": 1229896413, "metainfo": ""}