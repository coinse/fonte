{"sha": "18b61a1b18ed7d80ec2bf28588ce95fdd3dddf28", "log": "removed compilation/findbugs warnings about type safety the changes include API changes (replacing Object by Comparable<?>). The class itself is still not generic as this would prevent mixing types which is a desired feature here that is checked in the unit tests JIRA: MATH-261  ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n /** \n  * Maintains a frequency distribution.\n  * <p>\n- * Accepts int, long, char or Object values.  New values added must be \n+ * Accepts int, long, char or Comparable values.  New values added must be \n  * comparable to those that have been added, otherwise the add method will \n  * throw an IllegalArgumentException.</p>\n  * <p>\n      * \n      * @param comparator Comparator used to order values\n      */\n-    public Frequency(Comparator comparator) {\n-        freqTable = new TreeMap<Comparable<?>, Long>(comparator);\n+    @SuppressWarnings(\"unchecked\")\n+    public Frequency(Comparator<?> comparator) {\n+        freqTable = new TreeMap<Comparable<?>, Long>((Comparator<? super Comparable<?>>) comparator);\n     }\n \n     /**\n         NumberFormat nf = NumberFormat.getPercentInstance();\n         StringBuffer outBuffer = new StringBuffer();\n         outBuffer.append(\"Value \\t Freq. \\t Pct. \\t Cum Pct. \\n\");\n-        Iterator<?> iter = freqTable.keySet().iterator();\n+        Iterator<Comparable<?>> iter = freqTable.keySet().iterator();\n         while (iter.hasNext()) {\n-            Object value = iter.next();\n+            Comparable<?> value = iter.next();\n             outBuffer.append(value);\n             outBuffer.append('\\t');\n             outBuffer.append(getCount(value));\n      */\n     public long getSumFreq() {\n         long result = 0;\n-        Iterator<?> iterator = freqTable.values().iterator();\n+        Iterator<Long> iterator = freqTable.values().iterator();\n         while (iterator.hasNext())  {\n-            result += ((Long) iterator.next()).longValue();\n+            result += iterator.next().longValue();\n         }\n         return result;\n     }\n      * \n      * @param v the value to lookup.\n      * @return the frequency of v.\n-     */\n+     * @deprecated replaced by {@link #getCount(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n     public long getCount(Object v) {\n+        return getCount((Comparable<?>) v);\n+    }\n+\n+    /**\n+     * Returns the number of values = v.\n+     * Returns 0 if the value is not comparable.\n+     * \n+     * @param v the value to lookup.\n+     * @return the frequency of v.\n+     */\n+    public long getCount(Comparable<?> v) {\n         if (v instanceof Integer) {\n             return getCount(((Integer) v).longValue());\n         }\n      * \n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n-     */\n+     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n     public double getPct(Object v) {\n+        return getCumPct((Comparable<?>) v);\n+    }\n+\n+    /**\n+     * Returns the percentage of values that are equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns <code>Double.NaN</code> if no values have been added.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public double getPct(Comparable<?> v) {\n         final long sumFreq = getSumFreq();\n         if (sumFreq == 0) {\n             return Double.NaN;\n      * \n      * @param v the value to lookup.\n      * @return the proportion of values equal to v\n-     */\n+     * @deprecated replaced by {@link #getCumFreq(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n     public long getCumFreq(Object v) {\n+        return getCumFreq((Comparable<?>) v);\n+    }\n+\n+    /**\n+     * Returns the cumulative frequency of values less than or equal to v.\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup.\n+     * @return the proportion of values equal to v\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+        public long getCumFreq(Comparable<?> v) {\n         if (getSumFreq() == 0) {\n             return 0;\n         }\n         if (v instanceof Integer) {\n             return getCumFreq(((Integer) v).longValue());\n         }\n-        Comparator c = freqTable.comparator();\n+        Comparator<Comparable<?>> c = (Comparator<Comparable<?>>) freqTable.comparator();\n         if (c == null) {\n             c = new NaturalComparator();\n         }\n         } catch (ClassCastException ex) {\n             return result;   // v is not comparable\n         }\n-        \n+\n         if (c.compare(v, freqTable.firstKey()) < 0) {\n             return 0;  // v is comparable, but less than first value\n         }\n             return getSumFreq();    // v is comparable, but greater than the last value\n         }\n         \n-        Iterator<?> values = valuesIterator();\n+        Iterator<Comparable<?>> values = valuesIterator();\n         while (values.hasNext()) {\n-            Object nextValue = values.next();\n+            Comparable<?> nextValue = values.next();\n             if (c.compare(v, nextValue) > 0) {\n                 result += getCount(nextValue);\n             } else {\n      * \n      * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n-     */\n+     * @deprecated replaced by {@link #getCumPct(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n     public double getCumPct(Object v) {\n+        return getCumPct((Comparable<?>) v);\n+        \n+    }\n+\n+    /**\n+     * Returns the cumulative percentage of values less than or equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns <code>Double.NaN</code> if no values have been added.\n+     * Returns 0 if at least one value has been added, but v is not comparable\n+     * to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values less than or equal to v\n+     */\n+    public double getCumPct(Comparable<?> v) {\n         final long sumFreq = getSumFreq();\n         if (sumFreq == 0) {\n             return Double.NaN;\n      * A Comparator that compares comparable objects using the\n      * natural order.  Copied from Commons Collections ComparableComparator.\n      */\n-    private static class NaturalComparator implements Comparator, Serializable {\n+    private static class NaturalComparator<T extends Comparable<T>> implements Comparator<Comparable<T>>, Serializable {\n \n         /** Serializable version identifier */\n         private static final long serialVersionUID = -3852193713161395148L;\n          * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable}, \n          *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n          */\n-        @SuppressWarnings(\"unchecked\") // See Javadoc, ClassCast is expected\n-        public int compare(Object o1, Object o2) {\n-            return ((Comparable<Object>)o1).compareTo(o2);\n+        @SuppressWarnings(\"unchecked\")\n+        public int compare(Comparable<T> o1, Comparable<T> o2) {\n+            return (o1.compareTo((T) o2));\n         }\n     }\n \n             return false;\n         return true;\n     }\n+\n }", "timestamp": 1246952692, "metainfo": ""}