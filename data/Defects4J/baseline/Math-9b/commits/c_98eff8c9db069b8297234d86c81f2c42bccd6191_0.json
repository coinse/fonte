{"sha": "98eff8c9db069b8297234d86c81f2c42bccd6191", "log": "Its more logical not to have increment return a value, this allows a  distict separation between the calculation of moments and the  calculation of the actually return value of getVlaue in Storageless  approaches. With this benifit it is no longer neccessary to calculate  all the statistics moment based statistics on addValue, only the  underlying moment itself.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/univariate/StorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/StorelessUnivariateStatistic.java\n      * the same value as <code>getValue()</code>, Double.NaN if it\n      * has been cleared or just instantiated.\n      */\n-    public double increment(double d);\n+    public void increment(double d);\n \n     /**\n      * Returns the current state of the statistic after the\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FirstMoment.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (n < 1) {\n              m1 = 0.0;\n         }\n         n0 = (double)n;\n         v = dev / n0;\n \n-        return m1 += v;                    \n+        m1 += v;                    \n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (n < 1) {\n             m4 = m3 = m2 = m1 = 0.0;\n         }\n                 - (4.0 * v * prevM3)\n                 + (6.0 * v2 * prevM2)\n                 + ((n0 * n0) - 3 * n1) * (v2 * v2 * n1 * n0);\n-\n-        return m4;\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n  */\n public class GeometricMean extends SumOfLogs {\n  \n-    private double geoMean = Double.NaN;\n-    \n     private int n = 0;\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         n++;\n-        return geoMean = Math.exp( super.increment(d) / (double)n );\n+        super.increment(d);\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return geoMean;\n+        return Math.exp( super.getValue() / (double)n );\n     }\n \n     /**\n      */\n     public void clear() {\n         super.clear();\n-        geoMean = Double.NaN;\n         n = 0;\n     }\n     \n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n  */\n public class Kurtosis extends AbstractStorelessUnivariateStatistic {\n \n-    private double kurtosis = Double.NaN;\n-\n     protected FourthMoment moment = null;\n \n     protected boolean incMoment = true;\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n-\n-        double variance =\n-            (moment.n < 1) ? 0.0 : moment.m2 / (double) (moment.n - 1);\n-\n-        kurtosis =\n-            (moment.n <= 3 || variance < 10E-20)\n-                ? 0.0\n-                : (moment.n0 * (moment.n0 + 1) * moment.m4\n-                    - 3 * moment.m2 * moment.m2 * moment.n1)\n-                    / (moment.n1 * moment.n2 * moment.n3 * variance * variance);\n-\n-        return kurtosis;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return kurtosis;\n+\n+        if (moment.n <= 0) {\n+            return Double.NaN;\n+        }\n+\n+        double variance =\n+            (moment.n < 1) ? 0.0 : moment.m2 / (double) (moment.n - 1);\n+\n+        if (moment.n <= 3 || variance < 10E-20) {\n+            return 0.0;\n+        }\n+\n+        return (moment.n0 * (moment.n0 + 1) * moment.m4\n+                - 3 * moment.m2 * moment.m2 * moment.n1)\n+                / (moment.n1 * moment.n2 * moment.n3 * variance * variance);\n+\n     }\n \n     /**\n         if (incMoment) {\n             moment.clear();\n         }\n-        kurtosis = Double.NaN;\n     }\n \n     /*UnvariateStatistic Approach */\n     * @return the kurtosis of the values or Double.NaN if the array is empty\n     */\n     public double evaluate(double[] values, int begin, int length) {\n-        test(values, begin, length);\n+        ;\n \n         // Initialize the kurtosis\n         double kurt = Double.NaN;\n \n-        // Get the mean and the standard deviation\n-        double m = mean.evaluate(values, begin, length);\n+        if (test(values, begin, length)) {\n+            if (length <= 3) {\n+                kurt = 0.0;\n+            } else {\n \n-        // Calc the std, this is implemented here instead of using the \n-        // standardDeviation method eliminate a duplicate pass to get the mean\n-        double accum = 0.0;\n-        double accum2 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow((values[i] - m), 2.0);\n-            accum2 += (values[i] - m);\n+                // Get the mean and the standard deviation\n+                double m = mean.evaluate(values, begin, length);\n+\n+                // Calc the std, this is implemented here instead of using the \n+                // standardDeviation method eliminate a duplicate pass to get the mean\n+                double accum = 0.0;\n+                double accum2 = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    accum += Math.pow((values[i] - m), 2.0);\n+                    accum2 += (values[i] - m);\n+                }\n+\n+                double stdDev =\n+                    Math.sqrt(\n+                        (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                            / (double) (length - 1));\n+\n+                // Sum the ^4 of the distance from the mean divided by the \n+                // standard deviation\n+                double accum3 = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    accum3 += Math.pow((values[i] - m) / stdDev, 4.0);\n+                }\n+\n+                // Get N\n+                double n = length;\n+\n+                double coefficientOne =\n+                    (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n+                double termTwo =\n+                    ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n+\n+                // Calculate kurtosis\n+                kurt = (coefficientOne * accum3) - termTwo;\n+            }\n         }\n-\n-        double stdDev =\n-            Math.sqrt(\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1));\n-\n-        // Sum the ^4 of the distance from the mean divided by the \n-        // standard deviation\n-        double accum3 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum3 += Math.pow((values[i] - m) / stdDev, 4.0);\n-        }\n-\n-        // Get N\n-        double n = length;\n-\n-        double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n-        double termTwo = ((3 * Math.pow(n - 1, 2.0)) / ((n - 2) * (n - 3)));\n-\n-        // Calculate kurtosis\n-        kurt = (coefficientOne * accum3) - termTwo;\n \n         return kurt;\n     }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Mean.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n-\n-        return moment.m1;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/SecondMoment.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (n < 1) {\n             m1 = m2 = 0.0;\n         }\n         \n         /* increment and return m2 */\n         m2 += n1 * dev * v;\n-        \n-        return m2;\n-        \n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n  */\n public class Skewness extends AbstractStorelessUnivariateStatistic {\n \n-    private double skewness = Double.NaN;\n-\n     protected ThirdMoment moment = null;\n \n     protected boolean incMoment = true;\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n-\n-        double variance =\n-            (moment.n < 1) ? 0.0 : moment.m2 / (double) (moment.n - 1);\n-\n-        skewness =\n-            (moment.n <= 2 || variance < 10E-20)\n-                ? 0.0\n-                : (moment.n0 * moment.m3)\n-                    / (moment.n1 * moment.n2 * Math.sqrt(variance) * variance);\n-\n-        return skewness;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return skewness;\n+        if (moment.n <= 0) {\n+            return Double.NaN;\n+        }\n+\n+        double variance =\n+            (moment.n < 1) ? 0.0 : moment.m2 / (double) (moment.n - 1);\n+\n+        if (moment.n <= 2 || variance < 10E-20) {\n+            return 0.0;\n+        }\n+\n+        return (moment.n0 * moment.m3)\n+                / (moment.n1 * moment.n2 * Math.sqrt(variance) * variance);\n     }\n \n     /**\n         if (incMoment) {\n             moment.clear();\n         }\n-        skewness = Double.NaN;\n     }\n \n     /*UnvariateStatistic Approach */\n      */\n     public double evaluate(double[] values, int begin, int length) {\n \n-        test(values, begin, length);\n-\n         // Initialize the skewness\n         double skew = Double.NaN;\n \n-        // Get the mean and the standard deviation\n-        double m = mean.evaluate(values, begin, length);\n+        if (test(values, begin, length)) {\n \n-        // Calc the std, this is implemented here instead of using the \n-        // standardDeviation method eliminate a duplicate pass to get the mean\n-        double accum = 0.0;\n-        double accum2 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum += Math.pow((values[i] - m), 2.0);\n-            accum2 += (values[i] - m);\n+            if (length <= 2) {\n+                skew = 0.0;\n+            } else {\n+                // Get the mean and the standard deviation\n+                double m = mean.evaluate(values, begin, length);\n+\n+                // Calc the std, this is implemented here instead of using the \n+                // standardDeviation method eliminate a duplicate pass to get the mean\n+                double accum = 0.0;\n+                double accum2 = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    accum += Math.pow((values[i] - m), 2.0);\n+                    accum2 += (values[i] - m);\n+                }\n+                double stdDev =\n+                    Math.sqrt(\n+                        (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                            / (double) (length - 1));\n+\n+                // Calculate the skew as the sum the cubes of the distance \n+                // from the mean divided by the standard deviation.\n+                double accum3 = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    accum3 += Math.pow((values[i] - m) / stdDev, 3.0);\n+                }\n+\n+                // Get N\n+                double n = length;\n+\n+                // Calculate skewness\n+                skew = (n / ((n - 1) * (n - 2))) * accum3;\n+            }\n         }\n-        double stdDev =\n-            Math.sqrt(\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1));\n-\n-        // Calculate the skew as the sum the cubes of the distance \n-        // from the mean divided by the standard deviation.\n-        double accum3 = 0.0;\n-        for (int i = begin; i < begin + length; i++) {\n-            accum3 += Math.pow((values[i] - m) / stdDev, 3.0);\n-        }\n-\n-        // Get N\n-        double n = length;\n-\n-        // Calculate skewness\n-        skew = (n / ((n - 1) * (n - 2))) * accum3;\n \n         return skew;\n     }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/StandardDeviation.java\n  */\n public class StandardDeviation extends Variance {\n \n-    private double std = Double.NaN;\n-    \n     public StandardDeviation(){\n         super();\n     }\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n-        super.increment(d);\n-        std = (variance != 0.0) ? Math.sqrt(variance) : 0.0;\n-        return std;\n+    public void increment(double d) {\n+        super.increment(d);        \n     }\n     \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return std;\n+        \n+        double var = super.getValue();\n+        \n+        if(Double.isNaN(var)){\n+            return Double.NaN;\n+        }else if (var == 0.0){\n+            return 0.0;\n+        }\n+        \n+        return Math.sqrt(var);\n     }\n     \n     /**\n      */\n     public void clear() {\n         super.clear();\n-        std = Double.NaN;\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n-        double tmp = super.evaluate(values, begin, length);\n-        return tmp != 0.0 ? Math.sqrt(tmp) : 0.0;\n+        double var = super.evaluate(values, begin, length);\n+        \n+        if(Double.isNaN(var)){\n+            return Double.NaN;\n+        }\n+\n+        return var != 0.0 ? Math.sqrt(var) : 0.0;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/ThirdMoment.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (n < 1) {\n             m3 = m2 = m1 = 0.0;\n         }\n \n         m3 = m3 - (3.0 * v * prevM2) + (n0 * n1 * n2 * v2 * v);\n \n-        return m3;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n+import org\n+    .apache\n+    .commons\n+    .math\n+    .stat\n+    .univariate\n+    .AbstractStorelessUnivariateStatistic;\n \n /**\n  *\n  *\n  */\n-public class Variance extends AbstractStorelessUnivariateStatistic{\n-\n-    protected double variance = Double.NaN;\n+public class Variance extends AbstractStorelessUnivariateStatistic {\n \n     protected SecondMoment moment = null;\n-    \n+\n     protected boolean incMoment = true;\n-    \n-    public Variance(){\n+\n+    public Variance() {\n         moment = new SecondMoment();\n     }\n-    \n-    public Variance(SecondMoment m2){\n+\n+    public Variance(SecondMoment m2) {\n         incMoment = false;\n         this.moment = m2;\n     }\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }\n-        \n-        variance = (moment.n < 1) ? 0.0 : moment.m2 / (double)(moment.n - 1);\n-        \n-        return variance;\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getValue()\n      */\n     public double getValue() {\n-        return variance;\n+        if (moment.n <= 0) {\n+            return Double.NaN;\n+        } else if (moment.n <= 1) {\n+            return 0.0;\n+        }\n+        return moment.m2 / (moment.n0 - 1);\n     }\n \n     /**\n         if (incMoment) {\n             moment.clear();\n         }\n-        variance = Double.NaN;\n     }\n-    \n+\n     /*UnvariateStatistic Approach */\n \n     Mean mean = new Mean();\n-    \n+\n     /**\n      * Returns the variance of the available values. This uses a corrected\n      * two pass algorithm of the following \n      * @see org.apache.commons.math.stat.univariate.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(double[] values, int begin, int length) {\n+\n         double var = Double.NaN;\n-        if (values.length == 1) {\n-            var = 0;\n-        } else if (values.length > 1) {\n-            double m = mean.evaluate(values, begin, length);\n-            double accum = 0.0;\n-            double accum2 = 0.0;\n-            for (int i = begin; i < begin + length; i++) {\n-                accum += Math.pow((values[i] - m), 2.0);\n-                accum2 += (values[i] - m);\n+\n+        if (test(values, begin, length)) {\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                double m = mean.evaluate(values, begin, length);\n+                double accum = 0.0;\n+                double accum2 = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    accum += Math.pow((values[i] - m), 2.0);\n+                    accum2 += (values[i] - m);\n+                }\n+                var =\n+                    (accum - (Math.pow(accum2, 2) / ((double) length)))\n+                        / (double) (length - 1);\n             }\n-            var =\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1);\n         }\n         return var;\n     }\n \n-\n-\n }\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Max.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n-        return value = Double.isNaN(value) ? d : Math.max(value, d);\n+    public void increment(double d) {\n+        value = Double.isNaN(value) ? d : Math.max(value, d);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/rank/Min.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         value = Double.isNaN(value) ? d : Math.min(value, d);\n-        return value;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Product.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (Double.isNaN(value)) {\n             value = d;\n         } else {\n             value *= d;\n         }\n-\n-        return value;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/Sum.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (Double.isNaN(value )) {\n             value  = d;\n         } else {\n             value  += d;\n         }\n-        return value ;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfLogs.java\n      */\n     private double value = Double.NaN;\n \n+    private boolean init = true;\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n-        if (Double.isNaN(value )) {\n+    public void increment(double d) {\n+        if (init) {\n             value = Math.log(d);\n+            init = false;\n         } else {\n             value += Math.log(d);\n         }\n-\n-        return value;\n     }\n \n     /**\n      */\n     public void clear() {\n         value = Double.NaN;\n+        init = true;\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/summary/SumOfSquares.java\n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n-    public double increment(double d) {\n+    public void increment(double d) {\n         if (Double.isNaN(value )) {\n             value = d * d;\n         } else {\n             value += d * d;\n         }\n-        return value;\n     }\n \n     /**", "timestamp": 1057635852, "metainfo": ""}