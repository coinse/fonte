{"sha": "35d0d2f9ef873ab3e74d6719ee363b80acfe64aa", "log": "minor style fixes (braces, javadoc ...)  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n     \n \n     /**\n-     * Creates a matrix with no data\n+     * Creates a matrix with no data.\n      * @param field field to which the elements belong\n      */\n     public SparseFieldMatrix(final Field<T> field) {\n      * @throws IllegalArgumentException if row or column dimension is not positive\n      */\n     public SparseFieldMatrix(final Field<T> field,\n-                                  final int rowDimension, final int columnDimension)\n+                             final int rowDimension, final int columnDimension)\n         throws IllegalArgumentException {\n         super(field, rowDimension, columnDimension);\n         this.rowDimension = rowDimension;\n     }\n     \n     /**\n-     * Copy construtor.\n+     * Copy constructor.\n      * @param other The instance to copy\n      */\n-    public SparseFieldMatrix(SparseFieldMatrix<T> other){\n+    public SparseFieldMatrix(SparseFieldMatrix<T> other) {\n         super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n         rowDimension = other.getRowDimension();\n         columnDimension = other.getColumnDimension();\n     }\n \n     /**\n-     * Generic copy construtor.\n+     * Generic copy constructor.\n      * @param other The instance to copy\n      */\n     public SparseFieldMatrix(FieldMatrix<T> other){\n         rowDimension = other.getRowDimension();\n         columnDimension = other.getColumnDimension();\n         entries = new OpenIntToFieldHashMap<T>(getField());\n-        for(int i=0; i < rowDimension; i++){\n-            for(int j=0; j < columnDimension; j++){\n+        for (int i = 0; i < rowDimension; i++) {\n+            for (int j = 0; j < columnDimension; j++) {\n                 setEntry(i, j, other.getEntry(i, j));\n             }\n         }\n--- a/src/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseFieldVector.java\n \n     /**\n      * Build a 0-length vector.\n-     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * <p>Zero-length vectors may be used to initialize construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #SparseFieldVector(SparseFieldVector<T>, int)} constructor\n      * or one of the <code>append</code> method ({@link #append(Field<T>)}, {@link\n     public SparseFieldVector(Field<T> field, int dimension, int expectedSize) {\n         this.field = field;\n         virtualSize = dimension;\n-        entries = new OpenIntToFieldHashMap<T> (field,expectedSize);\n+        entries = new OpenIntToFieldHashMap<T>(field,expectedSize);\n     }\n \n     /**\n     }\n     \n     /**\n-     * Optimzed method to add sparse vectors\n+     * Optimized method to add sparse vectors.\n      * @return The sum of <code>this</code> and <code>v</code>\n      * @throws IllegalArgumentException If the dimensions don't match\n-*/\n+     */\n     public FieldVector<T> add(SparseFieldVector<T> v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n \n     /** {@inheritDoc} */\n     public FieldVector<T> append(FieldVector<T> v) {\n-        if(v instanceof SparseFieldVector)\n-            return append((SparseFieldVector<T>)v);\n-        else\n+        if (v instanceof SparseFieldVector) {\n+            return append((SparseFieldVector<T>) v);\n+        } else {\n             return append(v.toArray());\n-            \n+        }   \n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public FieldVector<T> ebeDivide(FieldVector<T> v)\n-            throws IllegalArgumentException {\n+        throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n     }\n \n      /**\n-      * Optimized method to compute outer product when both vectors are sparse\n+      * Optimized method to compute outer product when both vectors are sparse.\n       * @param v vector with which outer product should be computed\n       * @return the square matrix outer product between instance and v\n       * @throws IllegalArgumentException if v is not the same size as {@code this}\n             return outerProduct(v.toArray());\n     }\n \n+    /** {@inheritDoc} */\n     public FieldVector<T> projection(FieldVector<T> v)\n     throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n \n     /** {@inheritDoc} */\n     public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n-        if(v instanceof SparseFieldVector)\n+        if (v instanceof SparseFieldVector) {\n             return add((SparseFieldVector<T>)v);\n-        else\n+        } else {\n             return add(v.toArray());\n+        }\n     }\n \n     /** Build an array of elements.\n \n \n     /** {@inheritDoc} */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public boolean equals(Object obj) {\n-        if (this == obj)\n+\n+        if (this == obj) {\n             return true;\n-        if (obj == null)\n+        }\n+\n+        if (obj == null) {\n             return false;\n-        if (!(obj instanceof SparseFieldVector))\n+        }\n+\n+        if (!(obj instanceof SparseFieldVector)) {\n             return false;\n+        }\n+\n         SparseFieldVector<T> other = (SparseFieldVector<T>) obj;\n         if (field == null) {\n-            if (other.field != null)\n+            if (other.field != null) {\n                 return false;\n-        } else if (!field.equals(other.field))\n+            }\n+        } else if (!field.equals(other.field)) {\n             return false;\n-        if (virtualSize != other.virtualSize)\n+        }\n+        if (virtualSize != other.virtualSize) {\n             return false;\n+        }\n+\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();", "timestamp": 1241433736, "metainfo": ""}