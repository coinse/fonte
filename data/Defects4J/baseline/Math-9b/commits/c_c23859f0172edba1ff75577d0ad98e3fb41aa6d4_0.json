{"sha": "c23859f0172edba1ff75577d0ad98e3fb41aa6d4", "log": "Further alterations to javadoc (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  * Implements the Fast Cosine Transform for transformation of one-dimensional\n  * real data sets. For reference, see James S. Walker, <em>Fast Fourier\n  * Transforms</em>, chapter 3 (ISBN 0849371635).\n- * <p>\n+ * </p>\n  * <p>\n  * There are several variants of the discrete cosine transform. The present\n  * implementation corresponds to DCT-I, with various normalization conventions,\n  * + [2 / (N - 1)]<sup>1/2</sup> &sum;<sub>n=1</sub><sup>N-2</sup>\n  * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n  * </ul>\n- * which make the transform orthogonal. N is the size of the data sample.\n+ * which makes the transform orthogonal. N is the size of the data sample.\n  * </p>\n  * <p> {@link RealTransformer}s following this convention are returned by the\n  * factory method {@link #createOrthogonal()}.\n  * of the N first elements of the DFT of the extended data set\n  * x<sub>0</sub><sup>&#35;</sup>, &hellip;, x<sub>2N-3</sub><sup>&#35;</sup>\n  * <br/>\n- * 2y<sub>n</sub> = &sum;<sub>k=0</sub><sup>2N-3</sup>\n+ * y<sub>n</sub> = (1 / 2) &sum;<sub>k=0</sub><sup>2N-3</sup>\n  * x<sub>k</sub><sup>&#35;</sup> exp[-2&pi;i nk / (2N - 2)]\n  * &nbsp;&nbsp;&nbsp;&nbsp;k = 0, &hellip;, N-1.\n  * </p>\n  * <p>\n- * The present implementation of the fast cosine transform requires the length\n- * of the data set to be a power of two plus one\n+ * The present implementation of the discrete cosine transform as a fast cosine\n+ * transform requires the length of the data set to be a power of two plus one\n  * (N&nbsp;=&nbsp;2<sup>n</sup>&nbsp;+&nbsp;1). Besides, it implicitly assumes\n  * that the sampled function is even.\n  * </p>\n- * <p>As of version 2.0 this no longer implements Serializable</p>\n+ * <p>As of version 2.0 this no longer implements Serializable.</p>\n  *\n  * @version $Id: FastCosineTransformer.java 1213585 2011-12-13 07:44:52Z\n  *          celestin $\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import org.apache.commons.math.util.FastMath;\n \n /**\n- * Implements the <a href=\"http://mathworld.wolfram.com/FastFourierTransform.html\">\n- * Fast Fourier Transform</a> for transformation of one-dimensional data sets.\n- * For reference, see <b>Applied Numerical Linear Algebra</b>, ISBN 0898713897,\n- * chapter 6.\n  * <p>\n- * There are several conventions for the definition of FFT and inverse FFT,\n- * mainly on different coefficient and exponent. The conventions adopted in the\n- * present implementation are specified in the comments of the two provided\n- * factory methods, {@link #create()} and {@link #createUnitary()}.\n+ * Implements the Fast Fourier Transform for transformation of one-dimensional\n+ * real or complex data sets. For reference, see <em>Applied Numerical Linear\n+ * Algebra</em>, ISBN 0898713897, chapter 6.\n  * </p>\n  * <p>\n- * We require the length of data set to be power of 2, this greatly simplifies\n- * and speeds up the code. Users can pad the data with zeros to meet this\n- * requirement. There are other flavors of FFT, for reference, see S. Winograd,\n+ * There are several variants of the discrete Fourier transform, with various\n+ * normalization conventions, which are described below.\n+ * </p>\n+ * <p>\n+ * The current implementation of the discrete Fourier transform as a fast\n+ * Fourier transform requires the length of the data set to be a power of 2.\n+ * This greatly simplifies and speeds up the code. Users can pad the data with\n+ * zeros to meet this requirement. There are other flavors of FFT, for\n+ * reference, see S. Winograd,\n  * <i>On computing the discrete Fourier transform</i>, Mathematics of\n  * Computation, 32 (1978), 175 - 199.\n  * </p>\n+ * <h3><a id=\"standard\">Standard DFT</a></h3>\n+ * <p>\n+ * The standard normalization convention is defined as follows\n+ * <ul>\n+ * <li>forward transform: y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n+ * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n+ * <li>inverse transform: x<sub>k</sub> = N<sup>-1</sup>\n+ * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n+ * </ul>\n+ * where N is the size of the data sample.\n+ * </p>\n+ * <p>\n+ * {@link FastFourierTransformer}s following this convention are returned by the\n+ * factory method {@link #create()}.\n+ * </p>\n+ * <h3><a id=\"unitary\">Unitary DFT</a></h3>\n+ * <p>\n+ * The unitary normalization convention is defined as follows\n+ * <ul>\n+ * <li>forward transform: y<sub>n</sub> = (1 / &radic;N)\n+ * &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n+ * <li>inverse transform: x<sub>k</sub> = (1 / &radic;N)\n+ * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> exp(2&pi;i n k / N),</li>\n+ * </ul>\n+ * which makes the transform unitary. N is the size of the data sample.\n+ * </p>\n+ * <p>\n+ * {@link FastFourierTransformer}s following this convention are returned by the\n+ * factory method {@link #createUnitary()}.\n+ * </p>\n  *\n- * @version $Id$\n+ * @version $Id: FastFourierTransformer.java 1212260 2011-12-09 06:45:09Z\n+ * celestin $\n  * @since 1.2\n  */\n public class FastFourierTransformer implements Serializable {\n         this.unitary = unitary;\n     }\n \n+\n     /**\n      * <p>\n      * Returns a new instance of this class. The returned transformer uses the\n-     * normalizing conventions described below.\n-     * <ul>\n-     * <li>Forward transform:\n-     * y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n-     * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n-     * <li>Inverse transform:\n-     * x<sub>k</sub> = N<sup>-1</sup> &sum;<sub>n=0</sub><sup>N-1</sup>\n-     * y<sub>n</sub> exp(2&pi;i n k / N),</li>\n-     * </ul>\n-     * where N is the size of the data sample.\n+     * <a href=\"#standard\">standard normalizing conventions</a>.\n      * </p>\n      *\n-     * @return a new DFT transformer, with \"standard\" normalizing conventions\n+     * @return a new DFT transformer, with standard normalizing conventions\n      */\n     public static FastFourierTransformer create() {\n         return new FastFourierTransformer(false);\n     /**\n      * <p>\n      * Returns a new instance of this class. The returned transformer uses the\n-     * normalizing conventions described below.\n-     * <ul>\n-     * <li>Forward transform:\n-     * y<sub>n</sub> = N<sup>-1/2</sup> &sum;<sub>k=0</sub><sup>N-1</sup>\n-     * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n-     * <li>Inverse transform:\n-     * x<sub>k</sub> = N<sup>-1/2</sup> &sum;<sub>n=0</sub><sup>N-1</sup>\n-     * y<sub>n</sub> exp(2&pi;i n k / N),</li>\n-     * </ul>\n-     * which make the transform unitary. N is the size of the data sample.\n+     * <a href=\"#unitary\">unitary normalizing conventions</a>.\n      * </p>\n      *\n-     * @return a new FFT transformer, with unitary normalizing conventions\n+     * @return a new DFT transformer, with unitary normalizing conventions\n      */\n     public static FastFourierTransformer createUnitary() {\n         return new FastFourierTransformer(true);\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n import org.apache.commons.math.util.FastMath;\n \n /**\n- * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n- * StandardPackages/LinearAlgebra/FourierTrig.html\">Fast Sine Transform</a>\n- * for transformation of one-dimensional data sets. For reference, see\n- * <b>Fast Fourier Transforms</b>, ISBN 0849371635, chapter 3.\n- * <p>\n- * FST is its own inverse, up to a multiplier depending on conventions.\n- * The equations are listed in the comments of the corresponding methods.</p>\n- * <p>\n- * Similar to FFT, we also require the length of data set to be power of 2.\n- * In addition, the first element must be 0 and it's enforced in function\n- * transformation after sampling.</p>\n- * <p>As of version 2.0 this no longer implements Serializable</p>\n+ * <p>\n+ * Implements the Fast Sine Transform for transformation of one-dimensional real\n+ * data sets. For reference, see James S. Walker, <em>Fast Fourier\n+ * Transforms</em>, chapter 3 (ISBN 0849371635).\n+ * </p>\n+ * <p>\n+ * There are several variants of the discrete sine transform. The present\n+ * implementation corresponds to DST-I, with various normalization conventions,\n+ * which are described below. <strong>It should be noted that regardless to the\n+ * convention, the first element of the dataset to be transformed must be\n+ * zero.</strong>\n+ * </p>\n+ * <h3><a id=\"standard\">Standard DST-I</a></h3>\n+ * <p>\n+ * The standard normalization convention is defined as follows\n+ * <ul>\n+ * <li>forward transform: y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n+ * x<sub>k</sub> sin(&pi; nk / N),</li>\n+ * <li>inverse transform: x<sub>k</sub> = (2 / N)\n+ * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> sin(&pi; nk / N),</li>\n+ * </ul>\n+ * where N is the size of the data sample, and x<sub>0</sub> = 0.\n+ * </p>\n+ * <p>\n+ * {@link RealTransformer}s following this convention are returned by the\n+ * factory method {@link #create()}.\n+ * </p>\n+ * <h3><a id=\"orthogonal\">Orthogonal DST-I</a></h3>\n+ * <p>\n+ * The orthogonal normalization convention is defined as follows\n+ * <ul>\n+ * <li>Forward transform: y<sub>n</sub> = &radic;(2 / N)\n+ * &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>k</sub> sin(&pi; nk / N),</li>\n+ * <li>Inverse transform: x<sub>k</sub> = &radic;(2 / N)\n+ * &sum;<sub>n=0</sub><sup>N-1</sup> y<sub>n</sub> sin(&pi; nk / N),</li>\n+ * </ul>\n+ * which makes the transform orthogonal. N is the size of the data sample, and\n+ * x<sub>0</sub> = 0.\n+ * </p>\n+ * <p>\n+ * {@link RealTransformer}s following this convention are returned by the\n+ * factory method {@link #createOrthogonal()}.\n+ * </p>\n+ * <h3>Link with the DFT, and assumptions on the layout of the data set</h3>\n+ * <p>\n+ * DST-I is equivalent to DFT of an <em>odd extension</em> of the data series.\n+ * More precisely, if x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is the data set\n+ * to be sine transformed, the extended data set x<sub>0</sub><sup>&#35;</sup>,\n+ * &hellip;, x<sub>2N-1</sub><sup>&#35;</sup> is defined as follows\n+ * <ul>\n+ * <li>x<sub>0</sub><sup>&#35;</sup> = x<sub>0</sub> = 0,</li>\n+ * <li>x<sub>k</sub><sup>&#35;</sup> = x<sub>k</sub> if 1 &le; k &lt; N,</li>\n+ * <li>x<sub>N</sub><sup>&#35;</sup> = 0,</li>\n+ * <li>x<sub>k</sub><sup>&#35;</sup> = -x<sub>2N-k</sub> if N + 1 &le; k &lt;\n+ * 2N.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Then, the standard DST-I y<sub>0</sub>, &hellip;, y<sub>N-1</sub> of the real\n+ * data set x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is equal to <em>half</em>\n+ * of i (the pure imaginary number) times the N first elements of the DFT of the\n+ * extended data set x<sub>0</sub><sup>&#35;</sup>, &hellip;,\n+ * x<sub>2N-1</sub><sup>&#35;</sup> <br />\n+ * y<sub>n</sub> = (i / 2) &sum;<sub>k=0</sub><sup>2N-1</sup>\n+ * x<sub>k</sub><sup>&#35;</sup> exp[-2&pi;i nk / (2N)]\n+ * &nbsp;&nbsp;&nbsp;&nbsp;k = 0, &hellip;, N-1.\n+ * </p>\n+ * <p>\n+ * The present implementation of the discrete sine transform as a fast sine\n+ * transform requires the length of the data to be a power of two. Besides,\n+ * it implicitly assumes that the sampled function is odd. In particular, the\n+ * first element of the data set must be 0, which is enforced in\n+ * {@link #transform(UnivariateFunction, double, double, int)} and\n+ * {@link #inverseTransform(UnivariateFunction, double, double, int)}, after\n+ * sampling.\n+ * </p>\n+ * <p>\n+ * As of version 2.0 this no longer implements Serializable.\n+ * </p>\n  *\n- * @version $Id$\n+ * @version $Id: FastSineTransformer.java 1213157 2011-12-12 07:19:23Z celestin$\n  * @since 1.2\n  */\n public class FastSineTransformer implements RealTransformer {\n     /**\n      * <p>\n      * Returns a new instance of this class. The returned transformer uses the\n-     * normalizing conventions described below.\n-     * <ul>\n-     * <li>Forward transform:\n-     * y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n-     * x<sub>k</sub> sin(&pi; nk / N),</li>\n-     * <li>Inverse transform:\n-     * x<sub>k</sub> = (2 / N) &sum;<sub>n=0</sub><sup>N-1</sup>\n-     * y<sub>n</sub> sin(&pi; nk / N),</li>\n-     * </ul>\n-     * where N is the size of the data sample.\n+     * <a href=\"#standard\">standard normalizing conventions</a>.\n      * </p>\n      *\n-     * @return a new DST transformer, with \"standard\" normalizing conventions\n+     * @return a new DST transformer, with standard normalizing conventions\n      */\n     public static FastSineTransformer create() {\n         return new FastSineTransformer(false);\n     /**\n      * <p>\n      * Returns a new instance of this class. The returned transformer uses the\n-     * normalizing conventions described below.\n-     * <ul>\n-     * <li>Forward transform:\n-     * y<sub>n</sub> = &radic;(2 / N) &sum;<sub>k=0</sub><sup>N-1</sup>\n-     * x<sub>k</sub> sin(&pi; nk / N),</li>\n-     * <li>Inverse transform:\n-     * x<sub>k</sub> = &radic;(2 / N) &sum;<sub>n=0</sub><sup>N-1</sup>\n-     * y<sub>n</sub> sin(&pi; nk / N),</li>\n-     * </ul>\n-     * which make the transform orthogonal. N is the size of the data sample.\n+     * <a href=\"#orthogonal\">orthogonal normalizing conventions</a>.\n      * </p>\n      *\n-     * @return a new DST transformer, with \"orthogonal\" normalizing conventions\n+     * @return a new DST transformer, with orthogonal normalizing conventions\n      */\n     public static FastSineTransformer createOrthogonal() {\n         return new FastSineTransformer(true);\n      * The first element of the specified data set is required to be {@code 0}.\n      */\n     public double[] transform(double[] f) throws IllegalArgumentException {\n-        if (orthogonal){\n+        if (orthogonal) {\n             final double s = FastMath.sqrt(2.0 / f.length);\n             return FastFourierTransformer.scaleArray(fst(f), s);\n         }", "timestamp": 1323978462, "metainfo": ""}