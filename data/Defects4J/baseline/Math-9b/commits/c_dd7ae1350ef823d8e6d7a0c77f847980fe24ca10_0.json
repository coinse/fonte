{"sha": "dd7ae1350ef823d8e6d7a0c77f847980fe24ca10", "log": "added Fast Hadamard Transform JIRA: MATH-215  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n    { \"invalid exponent {0} (must be positive)\",\n      \"exposant {0} invalide (doit \\u00eatre positif)\" },\n \n+   // org.apache.commons.math.transform.FastHadamardTransformer\n+   { \"{0} is not a power of 2\",\n+     \"{0} n''est pas une puissance de 2\" },\n+\n    // org.apache.commons.math.util.OpenIntToDoubleHashMap\n    { \"map has been modified while iterating\",\n      \"la table d''adressage a \\u00e9t\\u00e9 modifi\\u00e9e pendant l''it\\u00e9ration\" },\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implements the <a href=\"http://www.archive.chipcenter.com/dsp/DSP000517F1.html\">Fast Hadamard Transform</a> (FHT).\n+ * Transformation of an input vector x to the output vector y.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class FastHadamardTransformer implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5044269102877526860L;\n+\n+    /**\n+     * Wrapper method for fht() for double vectors\n+     *  \n+     * @param x input vector\n+     * @return y output vector\n+     * @throws IllegalArgumentException\n+     */\n+    public double[] transform(double x[]) throws IllegalArgumentException {\n+        return fht(x);\n+    }\n+\n+\n+    /**\n+     * The FHT (Fast Hadamard Transformation) which uses only subtraction and addition.\n+     * <br>\n+     * Requires <b>Nlog2N = n2</b><sup>n</sup> additions.\n+     * <br>\n+     * <br>\n+     * <b><u>Short Table of manual calculation for N=8:</u></b>\n+     * <ol>\n+     * <li><b>x</b> is the input vector we want to transform</li>\n+     * <li><b>y</b> is the output vector which is our desired result</li>\n+     * <li>a and b are just helper rows</li>\n+     * </ol>\n+     * <pre>\n+     * <code>\n+     * +----+----------+---------+----------+\n+     * | <b>x</b>  |    <b>a</b>     |    <b>b</b>    |    <b>y</b>     |\n+     * +----+----------+---------+----------+\n+     * | x<sub>0</sub> | a<sub>0</sub>=x<sub>0</sub>+x<sub>1</sub> | b<sub>0</sub>=a<sub>0</sub>+a<sub>1</sub> | y<sub>0</sub>=b<sub>0</sub>+b<sub>1</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>1</sub> | a<sub>1</sub>=x<sub>2</sub>+x<sub>3</sub> | b<sub>0</sub>=a<sub>2</sub>+a<sub>3</sub> | y<sub>0</sub>=b<sub>2</sub>+b<sub>3</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>2</sub> | a<sub>2</sub>=x<sub>4</sub>+x<sub>5</sub> | b<sub>0</sub>=a<sub>4</sub>+a<sub>5</sub> | y<sub>0</sub>=b<sub>4</sub>+b<sub>5</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>3</sub> | a<sub>3</sub>=x<sub>6</sub>+x<sub>7</sub> | b<sub>0</sub>=a<sub>6</sub>+a<sub>7</sub> | y<sub>0</sub>=b<sub>6</sub>+b<sub>7</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>4</sub> | a<sub>0</sub>=x<sub>0</sub>-x<sub>1</sub> | b<sub>0</sub>=a<sub>0</sub>-a<sub>1</sub> | y<sub>0</sub>=b<sub>0</sub>-b<sub>1</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>5</sub> | a<sub>1</sub>=x<sub>2</sub>-x<sub>3</sub> | b<sub>0</sub>=a<sub>2</sub>-a<sub>3</sub> | y<sub>0</sub>=b<sub>2</sub>-b<sub>3</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>6</sub> | a<sub>2</sub>=x<sub>4</sub>-x<sub>5</sub> | b<sub>0</sub>=a<sub>4</sub>-a<sub>5</sub> | y<sub>0</sub>=b<sub>4</sub>-b<sub>5</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>7</sub> | a<sub>3</sub>=x<sub>6</sub>-x<sub>7</sub> | b<sub>0</sub>=a<sub>6</sub>-a<sub>7</sub> | y<sub>0</sub>=b<sub>6</sub>-b<sub>7</sub> |\n+     * +----+----------+---------+----------+\n+     * </code>\n+     * </pre>\n+     * \n+     * <b><u>How it works</u></b>\n+     * <ol>\n+     * <li>Construct a matrix with N rows and n+1 columns<br>   <b>hadm[n+1][N]</b> \n+     * <br><i>(If I use [x][y] it always means [row-offset][column-offset] of a Matrix with n rows and m columns. Its entries go from M[0][0] to M[n][m])</i></li>\n+     * <li>Place the input vector <b>x[N]</b> in the first column of the matrix <b>hadm</b></li>\n+     * <li>The entries of the submatrix D<sub>top</sub> are calculated as follows.\n+     * <br>D<sub>top</sub> goes from entry [0][1] to [N/2-1][n+1].\n+     * <br>The columns of D<sub>top</sub> are the pairwise mutually exclusive sums of the previous column \n+     * </li>\n+     * <li>The entries of the submatrix D<sub>bottom</sub> are calculated as follows.\n+     * <br>D<sub>bottom</sub> goes from entry [N/2][1] to [N][n+1].\n+     * <br>The columns of D<sub>bottom</sub> are the pairwise differences of the previous column \n+     * </li>\n+     * <li>How D<sub>top</sub> and D<sub>bottom</sub> you can understand best with the example for N=8 above.\n+     * <li>The output vector y is now in the last column of <b>hadm</b></li>\n+     * <li><i>Algorithm from: http://www.archive.chipcenter.com/dsp/DSP000517F1.html</i></li>    \n+     * </ol>\n+     * <br>\n+     * <b><u>Visually</u></b>\n+     * <pre>\n+     *        +--------+---+---+---+-----+---+\n+     *        |   0    | 1 | 2 | 3 | ... |n+1|\n+     * +------+--------+---+---+---+-----+---+\n+     * |0     | x<sub>0</sub>     |       /\\            |\n+     * |1     | x<sub>1</sub>     |       ||            |\n+     * |2     | x<sub>2</sub>     |   <= D<sub>top</sub>  =>       |\n+     * |...   | ...    |       ||            |\n+     * |N/2-1 | x<sub>N/2-1</sub>  |       \\/            |\n+     * +------+--------+---+---+---+-----+---+\n+     * |N/2   | x<sub>N/2</sub>   |       /\\            |\n+     * |N/2+1 | x<sub>N/2+1</sub>  |       ||            |\n+     * |N/2+2 | x<sub>N/2+2</sub>  |  <= D<sub>bottom</sub>  =>      | which is in the last column of the matrix\n+     * |...   | ...    |       ||            |\n+     * |N     | x<sub>N/2</sub>   |        \\/           |\n+     * +------+--------+---+---+---+-----+---+\n+     * </pre>\n+     * \n+     * @param x input vector\n+     * @return y output vector\n+     * @throws IllegalArgumentException\n+     */\n+    protected double[] fht(double x[]) throws IllegalArgumentException {\n+\n+        // n is the row count of the input vector x\n+        int n = x.length;\n+\n+        // n has to be of the form n = 2^p !!\n+        int p    = 0;\n+        int twoP = 1;\n+        while (twoP < n) {\n+            ++p;\n+            twoP *= 2;\n+        }\n+        if (n != twoP) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} is not a power of 2\",\n+                                                                      new Object[] { n });\n+        }\n+\n+        // Instead of creating a matrix with p+1 columns and n rows\n+        // we will use two single dimension arrays which we will use in an alternating way.\n+        double[] yPrevious = new double[n];\n+        double[] yCurrent  = x.clone();\n+\n+        // iterate from left to right (column)\n+        for (int j = 0; j < p; j++) {\n+\n+            // switch columns\n+            final double[] yTmp = yCurrent;\n+            yCurrent  = yPrevious;\n+            yPrevious = yTmp;\n+\n+            // iterate from top to bottom (row)\n+            for (int i = 0; i < n; i++) { \n+                if (i < n / 2) {\n+                    // D<sub>top</sub>\n+                    // The top part works with addition\n+                    yCurrent[i] = yPrevious[i*2] + yPrevious[i*2 +1];\n+                } else {\n+                    // D<sub>bottom</sub>   \n+                    // The bottom part works with subtraction\n+                    yCurrent[i] = yPrevious[(i-n/2)*2] - yPrevious[(i-n/2)*2 +1];\n+                }\n+            }\n+        }\n+\n+        // return the last computed output vector y\n+        return yCurrent;\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit Test for HadamardTransformerTest\n+ * @see org.apache.commons.math.transform.FastHadamardTransformer\n+ */\n+public final class FastHadamardTransformerTest extends TestCase {\n+\n+    /**\n+     * Test of transformer for the a 8-point FHT (means n=8)\n+     */\n+    public void test8Points() {\n+        checkTransform(new double[] { 1.0, 4.0, -2.0, 3.0, 0.0, 1.0, 4.0, -1.0 },\n+                       new double[] { 10.0, -4.0, 2.0, -4.0, 2.0, -12.0, 6.0, 8.0 });\n+    }\n+\n+    /**\n+     * Test of transformer for the a 4-points FHT (means n=4)\n+     */\n+    public void test4Points() {\n+        checkTransform(new double[] { 1.0, 2.0, 3.0, 4.0 },\n+                       new double[] { 10.0, -2.0, -4.0, 0.0 });\n+    }\n+\n+    /**\n+     * Test of transformer for wrong number of points\n+     */\n+    public void test3Points() {\n+        try {\n+            new FastHadamardTransformer().transform(new double[3]);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+\n+    private void checkTransform(double[]x, double[] y) {\n+        // Initiate the transformer\n+        FastHadamardTransformer transformer = new FastHadamardTransformer();\n+\n+        // transform input vector x to output vector\n+        double result[] = transformer.transform(x);\n+\n+        for (int i=0;i<result.length;i++) {\n+            // compare computed results to precomputed results\n+            assertEquals(y[i], result[i]);\n+        }\n+    }\n+    \n+}", "timestamp": 1230409445, "metainfo": ""}