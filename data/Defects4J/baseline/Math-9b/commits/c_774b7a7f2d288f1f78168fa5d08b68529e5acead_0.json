{"sha": "774b7a7f2d288f1f78168fa5d08b68529e5acead", "log": "implemented correlated random vectors generation  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.random.CorrelatedRandomVectorGenerator;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.NotPositiveDefiniteMatrixException;\n                 meanStat.increment(vertices[i]);\n                 covStat.increment(vertices[i]);\n             }\n+            double[] mean = meanStat.getResult();\n+            RealMatrix covariance = covStat.getResult();\n+            \n \n             RandomGenerator rg = new JDKRandomGenerator();\n             rg.setSeed(seed);\n             RandomVectorGenerator rvg =\n-                new CorrelatedRandomVectorGenerator(meanStat.getResult(),\n-                                                    covStat.getResult(),\n+                new CorrelatedRandomVectorGenerator(mean,\n+                                                    covariance, 1.0e-12 * covariance.getNorm(),\n                                                     new UniformRandomGenerator(rg));\n             setMultiStart(starts, rvg);\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+\n+/** This class allows to generate random vectors with correlated components.\n+\n+ * <p>Random vectors with correlated components are built by combining\n+ * the uncorrelated components of another random vector in such a way\n+ * the resulting correlations are the ones specified by a positive\n+ * definite covariance matrix.</p>\n+\n+ * <p>Sometimes, the covariance matrix for a given simulation is not\n+ * strictly positive definite. This means that the correlations are\n+ * not all independant from each other. In this case, however, the non\n+ * strictly positive elements found during the Cholesky decomposition\n+ * of the covariance matrix should not be negative either, they\n+ * should be null. This implies that rather than computing <code>C =\n+ * U<sup>T</sup>.U</code> where <code>C</code> is the covariance matrix and\n+ * <code>U</code> is an uppertriangular matrix, we compute <code>C =\n+ * B.B<sup>T</sup></code> where <code>B</code> is a rectangular matrix having\n+ * more rows than columns. The number of columns of <code>B</code> is\n+ * the rank of the covariance matrix, and it is the dimension of the\n+ * uncorrelated random vector that is needed to compute the component\n+ * of the correlated vector. This class does handle this situation\n+ * automatically.</p>\n+\n+ * @version $Revision:$ $Date$\n+\n+ */\n+\n+public class CorrelatedRandomVectorGenerator\n+implements RandomVectorGenerator {\n+\n+    /** Simple constructor.\n+     * <p>Build a correlated random vector generator from its mean\n+     * vector and covariance matrix.</p>\n+     * @param mean expected mean values for all components\n+     * @param covariance covariance matrix\n+     * @param small diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded\n+     * @param generator underlying generator for uncorrelated normalized\n+     * components\n+     * @exception IllegalArgumentException if there is a dimension\n+     * mismatch between the mean vector and the covariance matrix\n+     * @exception NotPositiveDefiniteMatrixException if the\n+     * covariance matrix is not strictly positive definite\n+     * @exception DimensionMismatchException if the mean and covariance\n+     * arrays dimensions don't match\n+     */\n+    public CorrelatedRandomVectorGenerator(double[] mean,\n+                                           RealMatrix covariance, double small,\n+                                           NormalizedRandomGenerator generator)\n+    throws NotPositiveDefiniteMatrixException, DimensionMismatchException {\n+\n+        int order = covariance.getRowDimension();\n+        if (mean.length != order) {\n+            throw new DimensionMismatchException(mean.length, order);\n+        }\n+        this.mean = (double[]) mean.clone();\n+\n+        decompose(covariance, small);\n+\n+        this.generator = generator;\n+        normalized = new double[rank];\n+\n+    }\n+\n+    /** Simple constructor.\n+     * <p>Build a null mean random correlated vector generator from its\n+     * covariance matrix.</p>\n+     * @param covariance covariance matrix\n+     * @param small diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded\n+     * @param generator underlying generator for uncorrelated normalized\n+     * components\n+     * @exception NotPositiveDefiniteMatrixException if the\n+     * covariance matrix is not strictly positive definite\n+     */\n+    public CorrelatedRandomVectorGenerator(RealMatrix covariance, double small,\n+                                           NormalizedRandomGenerator generator)\n+    throws NotPositiveDefiniteMatrixException {\n+\n+        int order = covariance.getRowDimension();\n+        mean = new double[order];\n+        for (int i = 0; i < order; ++i) {\n+            mean[i] = 0;\n+        }\n+\n+        decompose(covariance, small);\n+\n+        this.generator = generator;\n+        normalized = new double[rank];\n+\n+    }\n+\n+    /** Get the underlying normalized components generator.\n+     * @return underlying uncorrelated components generator\n+     */\n+    public NormalizedRandomGenerator getGenerator() {\n+        return generator;\n+    }\n+\n+    /** Get the root of the covariance matrix.\n+     * The root is the rectangular matrix <code>B</code> such that\n+     * the covariance matrix is equal to <code>B.B<sup>T</sup></code>\n+     * @return root of the square matrix\n+     * @see #getRank()\n+     */\n+    public RealMatrix getRootMatrix() {\n+        return root;\n+    }\n+\n+    /** Get the rank of the covariance matrix.\n+     * The rank is the number of independant rows in the covariance\n+     * matrix, it is also the number of columns of the rectangular\n+     * matrix of the decomposition.\n+     * @return rank of the square matrix.\n+     * @see #getRootMatrix()\n+     */\n+    public int getRank() {\n+        return rank;\n+    }\n+\n+    /** Decompose the original square matrix.\n+     * <p>The decomposition is based on a Choleski decomposition\n+     * where additional transforms are performed:\n+     * <ul>\n+     *   <li>the rows of the decomposed matrix are permuted</li>\n+     *   <li>columns with the too small diagonal element are discarded</li>\n+     *   <li>the matrix is permuted</li>\n+     * </ul>\n+     * This means that rather than computing M = U<sup>T</sup>.U where U\n+     * is an upper triangular matrix, this method computed M=B.B<sup>T</sup>\n+     * where B is a rectangular matrix.\n+     * @param covariance covariance matrix\n+     * @param small diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded\n+     * @exception NotPositiveDefiniteMatrixException if the\n+     * covariance matrix is not strictly positive definite\n+     */\n+    private void decompose(RealMatrix covariance, double small)\n+    throws NotPositiveDefiniteMatrixException {\n+\n+        int order = covariance.getRowDimension();\n+        double[][] c = covariance.getData();\n+        double[][] b = new double[order][order];\n+\n+        int[] swap  = new int[order];\n+        int[] index = new int[order];\n+        for (int i = 0; i < order; ++i) {\n+            index[i] = i;\n+        }\n+\n+        rank = 0;\n+        for (boolean loop = true; loop;) {\n+\n+            // find maximal diagonal element\n+            swap[rank] = rank;\n+            for (int i = rank + 1; i < order; ++i) {\n+                int ii  = index[i];\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[rank] = i;\n+                }\n+            }\n+\n+\n+            // swap elements\n+            if (swap[rank] != rank) {\n+                int tmp = index[rank];\n+                index[rank] = index[swap[rank]];\n+                index[swap[rank]] = tmp;\n+            }\n+\n+            // check diagonal element\n+            int ir = index[rank];\n+            if (c[ir][ir] < small) {\n+\n+                if (rank == 0) {\n+                    throw new NotPositiveDefiniteMatrixException();\n+                }\n+\n+                // check remaining diagonal elements\n+                for (int i = rank; i < order; ++i) {\n+                    if (c[index[i]][index[i]] < -small) {\n+                        // there is at least one sufficiently negative diagonal element,\n+                        // the covariance matrix is wrong\n+                        throw new NotPositiveDefiniteMatrixException();\n+                    }\n+                }\n+\n+                // all remaining diagonal elements are close to zero,\n+                // we consider we have found the rank of the covariance matrix\n+                ++rank;\n+                loop = false;\n+\n+            } else {\n+\n+                // transform the matrix\n+                double sqrt = Math.sqrt(c[ir][ir]);\n+                b[rank][rank] = sqrt;\n+                double inverse = 1 / sqrt;\n+                for (int i = rank + 1; i < order; ++i) {\n+                    int ii = index[i];\n+                    double e = inverse * c[ii][ir];\n+                    b[i][rank] = e;\n+                    c[ii][ii] -= e * e;\n+                    for (int j = rank + 1; j < i; ++j) {\n+                        int ij = index[j];\n+                        double f = c[ii][ij] - e * b[j][rank];\n+                        c[ii][ij] = f;\n+                        c[ij][ii] = f;\n+                    }\n+                }\n+\n+                // prepare next iteration\n+                loop = ++rank < order;\n+\n+            }\n+\n+        }\n+\n+        // build the root matrix\n+        root = new RealMatrixImpl(order, rank);\n+        for (int i = 0; i < order; ++i) {\n+            System.arraycopy(b[i], 0, root.getDataRef()[swap[i]], 0, rank);\n+        }\n+\n+    }\n+\n+    /** Generate a correlated random vector.\n+     * @return a random vector as an array of double. The returned array\n+     * is created at each call, the caller can do what it wants with it.\n+     */\n+    public double[] nextVector() {\n+\n+        // generate uncorrelated vector\n+        for (int i = 0; i < rank; ++i) {\n+            normalized[i] = generator.nextNormalizedDouble();\n+        }\n+\n+        // compute correlated vector\n+        double[] correlated = new double[mean.length];\n+        for (int i = 0; i < correlated.length; ++i) {\n+            correlated[i] = mean[i];\n+            for (int j = 0; j < rank; ++j) {\n+                correlated[i] += root.getEntry(i, j) * normalized[j];\n+            }\n+        }\n+\n+        return correlated;\n+\n+    }\n+\n+    /** Mean vector. */\n+    private double[] mean;\n+\n+    /** Permutated Cholesky root of the covariance matrix. */\n+    private RealMatrixImpl root;\n+\n+    /** Rank of the covariance matrix. */\n+    private int rank;\n+\n+    /** Underlying generator. */\n+    private NormalizedRandomGenerator generator;\n+\n+    /** Storage for the normalized vector. */\n+    private double[] normalized;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n+//Licensed to the Apache Software Foundation (ASF) under one\n+//or more contributor license agreements.  See the NOTICE file\n+//distributed with this work for additional information\n+//regarding copyright ownership.  The ASF licenses this file\n+//to you under the Apache License, Version 2.0 (the\n+//\"License\"); you may not use this file except in compliance\n+//with the License.  You may obtain a copy of the License at\n+\n+//http://www.apache.org/licenses/LICENSE-2.0\n+\n+//Unless required by applicable law or agreed to in writing,\n+//software distributed under the License is distributed on an\n+//\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+//KIND, either express or implied.  See the License for the\n+//specific language governing permissions and limitations\n+//under the License.\n+\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n+\n+import junit.framework.*;\n+\n+public class CorrelatedRandomVectorGeneratorTest\n+extends TestCase {\n+\n+    public CorrelatedRandomVectorGeneratorTest(String name) {\n+        super(name);\n+        mean       = null;\n+        covariance = null;\n+        generator  = null;\n+    }\n+\n+    public void testRank() {\n+        assertEquals(3, generator.getRank());\n+    }\n+\n+    public void testRootMatrix() {\n+        RealMatrix b = generator.getRootMatrix();\n+        RealMatrix bbt = b.multiply(b.transpose());\n+        for (int i = 0; i < covariance.getRowDimension(); ++i) {\n+            for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n+                assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12);\n+            }\n+        }\n+    }\n+\n+    public void testMeanAndCovariance() throws DimensionMismatchException {\n+\n+        VectorialMean meanStat = new VectorialMean(mean.length);\n+        VectorialCovariance covStat = new VectorialCovariance(mean.length);\n+        for (int i = 0; i < 5000; ++i) {\n+            double[] v = generator.nextVector();\n+            meanStat.increment(v);\n+            covStat.increment(v);\n+        }\n+\n+        double[] estimatedMean = meanStat.getResult();\n+        RealMatrix estimatedCovariance = covStat.getResult();\n+        for (int i = 0; i < estimatedMean.length; ++i) {\n+            assertEquals(mean[i], estimatedMean[i], 0.07);\n+            for (int j = 0; j <= i; ++j) {\n+                assertEquals(covariance.getEntry(i, j),\n+                        estimatedCovariance.getEntry(i, j),\n+                        0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j])));\n+            }\n+        }\n+\n+    }\n+\n+    public void setUp() {\n+        try {\n+            mean = new double[] { 0.0, 1.0, -3.0, 2.3};\n+\n+            RealMatrixImpl b = new RealMatrixImpl(4, 3);\n+            double[][] bData = b.getDataRef();\n+            int counter = 0;\n+            for (int i = 0; i < bData.length; ++i) {\n+                double[] bi = bData[i];\n+                for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                    bi[j] = 1.0 + 0.1 * ++counter;\n+                }\n+            }\n+            RealMatrix bbt = b.multiply(b.transpose());\n+            covariance = new RealMatrixImpl(mean.length, mean.length);\n+            double[][] covData = covariance.getDataRef();\n+            for (int i = 0; i < covariance.getRowDimension(); ++i) {\n+                covData[i][i] = bbt.getEntry(i, i);\n+                for (int j = 0; j < covariance.getColumnDimension(); ++j) {\n+                    double s = bbt.getEntry(i, j);\n+                    covData[i][j] = s;\n+                    covData[j][i] = s;\n+                }\n+            }\n+\n+            RandomGenerator rg = new JDKRandomGenerator();\n+            rg.setSeed(17399225432l);\n+            GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg);\n+            generator = new CorrelatedRandomVectorGenerator(mean,\n+                                                            covariance,\n+                                                            1.0e-12 * covariance.getNorm(),\n+                                                            rawGenerator);\n+        } catch (DimensionMismatchException e) {\n+            fail(e.getMessage());\n+        } catch (NotPositiveDefiniteMatrixException e) {\n+            fail(\"not positive definite matrix\");\n+        }\n+    }\n+\n+    public void tearDown() {\n+        mean       = null;\n+        covariance = null;\n+        generator  = null;\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(CorrelatedRandomVectorGeneratorTest.class);\n+    }\n+\n+    private double[] mean;\n+    private RealMatrixImpl covariance;\n+    private CorrelatedRandomVectorGenerator generator;\n+\n+}", "timestamp": 1172692308, "metainfo": ""}