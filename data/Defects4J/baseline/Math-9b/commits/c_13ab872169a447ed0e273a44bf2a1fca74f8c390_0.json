{"sha": "13ab872169a447ed0e273a44bf2a1fca74f8c390", "log": "In o.a.c.m3.SymmLQ.State   - the current solution is now refined at each iteration, as the overhead is negligible   - SymmLQ.State.xL is no longer a reference to the parameter x passed to its constructor. This way, all transparent updates of the vector x are removed.   - SymmLQ.State.moveToCG(RealVector) is renamed SymmLQ.State.refineSolution(RealVector). In o.a.c.m3.SymmLQ.solveInPlace()   - SymmLQ.State.init() is now called explicitly   - a new DefaultIterativeLinearSolverEvent is created each time it is needed (no \"clever\" object reuse)   - SymmLQ.State.refineSolution(RealVector) is called explicitly See MATH-761.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n          * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n          * (can be {@code null})\n          * @param b the right-hand side vector\n-         * @param x the vector to be updated with the solution; {@code x} should\n-         * not be considered as an initial guess (<a href=\"#initguess\">more</a>)\n          * @param goodb usually {@code false}, except if {@code x} is expected\n          * to contain a large multiple of {@code b}\n          * @param shift the amount to be subtracted to all diagonal elements of\n         public State(final RealLinearOperator a,\n             final RealLinearOperator minv,\n             final RealVector b,\n-            final RealVector x,\n             final boolean goodb,\n             final double shift,\n             final double delta,\n             this.a = a;\n             this.minv = minv;\n             this.b = b;\n-            this.xL = x;\n+            this.xL = new ArrayRealVector(b.getDimension());\n             this.goodb = goodb;\n             this.shift = shift;\n             this.minvb = minv == null ? b : minv.operate(b);\n             this.hasConverged = false;\n             this.check = check;\n             this.delta = delta;\n-            init();\n         }\n \n         /**\n          * the convergence tests involve only cgnorm, so we're unlikely to stop\n          * at an LQ point, except if the iteration limit interferes.\n          *\n-         * @param xC the vector to be updated with the refined value of xL\n-         */\n-        void moveToCG(final RealVector xC) {\n+         * @param x the vector to be updated with the refined value of xL\n+         */\n+         void refineSolution(final RealVector x) {\n             final int n = this.xL.getDimension();\n             if (lqnorm < cgnorm) {\n                 if (!goodb) {\n-                    xC.setSubVector(0, this.xL);\n+                    x.setSubVector(0, this.xL);\n                 } else {\n                     final double step = bstep / beta1;\n                     for (int i = 0; i < n; i++) {\n                         final double bi = minvb.getEntry(i);\n                         final double xi = this.xL.getEntry(i);\n-                        xC.setEntry(i, xi + step * bi);\n+                        x.setEntry(i, xi + step * bi);\n                     }\n                 }\n             } else {\n                     for (int i = 0; i < n; i++) {\n                         final double xi = this.xL.getEntry(i);\n                         final double wi = wbar.getEntry(i);\n-                        xC.setEntry(i, xi + zbar * wi);\n+                        x.setEntry(i, xi + zbar * wi);\n                     }\n                 } else {\n                     for (int i = 0; i < n; i++) {\n                         final double xi = this.xL.getEntry(i);\n                         final double wi = wbar.getEntry(i);\n                         final double bi = minvb.getEntry(i);\n-                        xC.setEntry(i, xi + zbar * wi + step * bi);\n+                        x.setEntry(i, xi + zbar * wi + step * bi);\n                     }\n                 }\n             }\n          * value of the state variables of {@code this} object correspond to k =\n          * 1.\n          */\n-        private void init() {\n+         void init() {\n             this.xL.set(0.);\n             /*\n              * Set up y for the first Lanczos vector. y and beta1 will be zero\n         }\n \n         /**\n-         * Returns the right-hand side vector.\n-         *\n-         * @return the right-hand side vector, b\n-         */\n-        RealVector getRightHandSideVector() {\n-            return b;\n-        }\n-\n-        /**\n-         * Returns the current estimate of the solution (LQ point).\n-         *\n-         * @return the solution, xL\n-         */\n-        RealVector getSolution() {\n-            return xL;\n-        }\n-\n-        /**\n          * Returns the norm of the updated, preconditioned residual.\n          *\n          * @return the norm of the residual, ||P * r||\n          */\n         double getNormOfResidual() {\n             return rnorm;\n-        }\n-    }\n-\n-    /**\n-     * The type of all events fired by this implementation of the SYMMLQ method.\n-     *\n-     * @version $Id$\n-     */\n-    private static class SymmLQEvent extends IterativeLinearSolverEvent {\n-        /** Identifier. */\n-        private static final long serialVersionUID = 2012012801L;\n-\n-        /** A reference to the state of this solver. */\n-        private final transient State state;\n-\n-        /**\n-         * Creates a new instance of this class.\n-         *\n-         * @param source the iterative algorithm on which the event initially\n-         * occurred\n-         * @param state the state of this solver at the time of creation\n-         */\n-        public SymmLQEvent(final SymmLQ source, final State state) {\n-            super(source, source.getIterationManager().getIterations());\n-            this.state = state;\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public int getIterations() {\n-            return ((SymmLQ) getSource()).getIterationManager().getIterations();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public double getNormOfResidual() {\n-            return state.getNormOfResidual();\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public RealVector getRightHandSideVector() {\n-            return RealVector.unmodifiableRealVector(state.getRightHandSideVector());\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public RealVector getSolution() {\n-            final RealVector x = state.getSolution().copy();\n-            state.moveToCG(x);\n-            return x;\n         }\n     }\n \n         manager.resetIterationCount();\n         manager.incrementIterationCount();\n \n-        final State state = new State(a, minv, b, x.copy(), goodb, shift, delta, check);\n-        /*\n-         * There is no need to create a new SymmLQEvent each time the state is\n-         * updated, as SymmLQEvent keeps a reference to the current state.\n-         */\n-        final IterativeLinearSolverEvent event = new SymmLQEvent(this, state);\n+        final State state;\n+        state = new State(a, minv, b, goodb, shift, delta, check);\n+        state.init();\n+        state.refineSolution(x);\n+        IterativeLinearSolverEvent event;\n+        event = new DefaultIterativeLinearSolverEvent(this,\n+                                                      manager.getIterations(),\n+                                                      x,\n+                                                      b,\n+                                                      state.getNormOfResidual());\n         if (state.bEqualsNullVector()) {\n             /* If b = 0 exactly, stop with x = 0. */\n             manager.fireTerminationEvent(event);\n         if (!earlyStop) {\n             do {\n                 manager.incrementIterationCount();\n+                event = new DefaultIterativeLinearSolverEvent(this,\n+                                                              manager.getIterations(),\n+                                                              x,\n+                                                              b,\n+                                                              state.getNormOfResidual());\n                 manager.fireIterationStartedEvent(event);\n                 state.update();\n+                state.refineSolution(x);\n+                event = new DefaultIterativeLinearSolverEvent(this,\n+                                                              manager.getIterations(),\n+                                                              x,\n+                                                              b,\n+                                                              state.getNormOfResidual());\n                 manager.fireIterationPerformedEvent(event);\n             } while (!state.hasConverged());\n         }\n-        state.moveToCG(x);\n+        event = new DefaultIterativeLinearSolverEvent(this,\n+                                                      manager.getIterations(),\n+                                                      x,\n+                                                      b,\n+                                                      state.getNormOfResidual());\n         manager.fireTerminationEvent(event);\n         return x;\n     }", "timestamp": 1332532272, "metainfo": ""}