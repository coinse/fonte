{"sha": "60deb4c99ecf6d74c5e5110d6ed2bd7748ee8187", "log": "Added utility method \"copyOf\" in \"MathUtils\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n             double alphaMin = 0;\n \n             for (int i = 0; i < n; i++) {\n-                final double[] d = /* Arrays.*/ copyOf(direc[i], n); // Java 1.5 does not support Arrays.copyOf()\n+                final double[] d = MathUtils.copyOf(direc[i]);\n \n                 fX2 = fVal;\n \n                             bracket.getLo(), bracket.getHi(), bracket.getMid());\n         }\n     }\n-\n-    /**\n-     * Java 1.5 does not support Arrays.copyOf()\n-     *\n-     * @param source Array to be copied.\n-     * @param newLen Length of the copy to be returned.\n-     * @return the copied array, truncated or padded as necessary.\n-     */\n-     private double[] copyOf(double[] source, int newLen) {\n-         double[] output = new double[newLen];\n-         System.arraycopy(source, 0, output, 0, Math.min(source.length, newLen));\n-         return output;\n-     }\n }\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n             }\n         }\n     }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @return the copied array.\n+     */\n+     public static int[] copyOf(int[] source) {\n+         final int len = source.length;\n+         final int[] output = new int[len];\n+         System.arraycopy(source, 0, output, 0, len);\n+         return output;\n+     }\n+\n+    /**\n+     * Creates a copy of the {@code source} array.\n+     *\n+     * @param source Array to be copied.\n+     * @return the copied array.\n+     */\n+     public static double[] copyOf(double[] source) {\n+         final int len = source.length;\n+         final double[] output = new double[len];\n+         System.arraycopy(source, 0, output, 0, len);\n+         return output;\n+     }\n }\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Converter between unidimensional storage structure and multidimensional\n          * @return the indices within the multidimensional counter.\n          */\n         public int[] getCounts() {\n-            return /* Arrays.*/ copyOf(counter, dimension); // Java 1.5 does not support Arrays.copyOf()\n+            return MathUtils.copyOf(counter);\n         }\n \n         /**\n      */\n     public MultidimensionalCounter(int ... size) {\n         dimension = size.length;\n-        this.size = /* Arrays.*/ copyOf(size, dimension); // Java 1.5 does not support Arrays.copyOf()\n+        this.size = MathUtils.copyOf(size);\n \n         uniCounterOffset = new int[dimension];\n \n      * @return the sizes of the multidimensional counter in each dimension.\n      */\n     public int[] getSizes() {\n-        return /* Arrays.*/ copyOf(size, dimension); // Java 1.5 does not support Arrays.copyOf()\n+        return MathUtils.copyOf(size);\n     }\n \n     /**\n         }\n         return sb.toString();\n     }\n-\n-    /**\n-     * Java 1.5 does not support Arrays.copyOf()\n-     *\n-     * @param source Array to be copied.\n-     * @param newLen Length of the copy to be returned.\n-     * @return the copied array, truncated or padded as necessary.\n-     */\n-     private int[] copyOf(int[] source, int newLen) {\n-         int[] output = new int[newLen];\n-         System.arraycopy(source, 0, output, 0, Math.min(source.length, newLen));\n-         return output;\n-     }\n }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         assertEquals(25,  x2[4], Math.ulp(1d));\n         assertEquals(125, x3[4], Math.ulp(1d));\n     }\n+\n+    public void testCopyOfInt() {\n+        final int[] source = { Integer.MIN_VALUE,\n+                               -1, 0, 1, 3, 113, 4769,\n+                               Integer.MAX_VALUE };\n+        final int[] dest = MathUtils.copyOf(source);\n+\n+        assertEquals(dest.length, source.length);\n+        for (int i = 0; i < source.length; i++) {\n+            assertEquals(source[i], dest[i]);\n+        }\n+    }\n+\n+    public void testCopyOfDouble() {\n+        final double[] source = { Double.NEGATIVE_INFINITY,\n+                                  -Double.MAX_VALUE,\n+                                  -1, 0,\n+                                  Double.MIN_VALUE,\n+                                  Math.ulp(1d),\n+                                  1, 3, 113, 4769,\n+                                  Double.MAX_VALUE,\n+                                  Double.POSITIVE_INFINITY };\n+        final double[] dest = MathUtils.copyOf(source);\n+\n+        assertEquals(dest.length, source.length);\n+        for (int i = 0; i < source.length; i++) {\n+            assertEquals(source[i], dest[i], 0);\n+        }\n+    }\n }", "timestamp": 1296479618, "metainfo": ""}