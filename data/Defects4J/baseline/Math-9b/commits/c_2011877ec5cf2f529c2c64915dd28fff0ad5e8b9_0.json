{"sha": "2011877ec5cf2f529c2c64915dd28fff0ad5e8b9", "log": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 234481 through revision 240244.  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n      */\n     protected boolean isBracketing(double lower, double upper, \n             UnivariateRealFunction f) throws FunctionEvaluationException {\n-        return  (f.value(lower) * f.value(upper) < 0);\n+    \tdouble f1 = f.value(lower);\n+    \tdouble f2 = f.value(upper);\n+    \treturn ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n             ret = 0.0;\n         } else if(x >= domain[1]) {\n             ret = 1.0;\n-        } else if (x - domain[0] < domain[1] - x) {\n-            ret = lowerCumulativeProbability(domain[0], x, n, m, k);\n         } else {\n-        \tret = 1.0 - upperCumulativeProbability(x + 1, domain[1], n, m, k);\n+            ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);\n         }\n         \n         return ret;\n     }\n \n     /**\n-     * For this disbution, X, this method returns P(x0 &le; X &le; x1).  This\n-     * probability is computed by summing the point probabilities for the values\n-     * x0, x0 + 1, x0 + 2, ..., x1, in that order. \n-     * @param x0 the inclusive, lower bound\n-     * @param x1 the inclusive, upper bound\n-     * @param n the population size.\n-     * @param m number of successes in the population.\n-     * @param k the sample size.\n-     * @return P(x0 &le; X &le; x1). \n-     */\n-    private double lowerCumulativeProbability(\n-        int x0, int x1, int n, int m, int k)\n-    {\n-\t\tdouble ret;\n-\t\tret = 0.0;\n-\t\tfor (int i = x0; i <= x1; ++i) {\n-\t\t\tret += probability(n, m, k, i);\n-\t\t}\n-\t\treturn ret;\n-\t}\n-\n-    /**\n      * For this disbution, X, this method returns P(X = x).\n      * \n      * @param x the value at which the PMF is evaluated.\n     /**\n      * For this disbution, X, this method returns P(X &ge; x).\n      * @param x the value at which the CDF is evaluated.\n-     * @return upper tail CDF for this distribution. \n+     * @return upper tail CDF for this distribution.\n+     * @since 1.1\n      */\n \tpublic double upperCumulativeProbability(int x) {\n     \tdouble ret;\n         int[] domain = getDomain(n, m, k);\n         if (x < domain[0]) {\n             ret = 1.0;\n-        } else if(x >= domain[1]) {\n+        } else if(x > domain[1]) {\n             ret = 0.0;\n-        } else if (x - domain[0] < domain[1] - x) {\n-        \tret = 1.0 - lowerCumulativeProbability(domain[0], x - 1, n, m, k);\n         } else {\n-        \tret = upperCumulativeProbability(x, domain[1], n, m, k);\n+        \tret = innerCumulativeProbability(domain[1], x, -1, n, m, k);\n         }\n         \n         return ret;\n     }\n-    \n+\t\n     /**\n      * For this disbution, X, this method returns P(x0 &le; X &le; x1).  This\n      * probability is computed by summing the point probabilities for the values\n-     * x1, x1 - 1, x1 - 2, ..., x0, in that order. \n+     * x0, x0 + 1, x0 + 2, ..., x1, in the order directed by dx. \n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n+     * @param dx the direction of summation. 1 indicates summing from x0 to x1.\n+     *           0 indicates summing from x1 to x0.\n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n      * @return P(x0 &le; X &le; x1). \n      */\n-    private double upperCumulativeProbability(\n-    \tint x0, int x1, int n, int m, int k)\n+    private double innerCumulativeProbability(\n+    \tint x0, int x1, int dx, int n, int m, int k)\n     {\n-    \tdouble ret = 0.0;\n-    \tfor (int i = x1; i >= x0; --i) {\n-    \t\tret += probability(n, m, k, i);\n+    \tdouble ret = probability(n, m, k, x0);\n+    \twhile (x0 != x1) {\n+    \t\tx0 += dx;\n+    \t\tret += probability(n, m, k, x0);\n     \t}\n \t\treturn ret;\n \t}\n-\n }\n--- a/src/test/org/apache/commons/math/RetryTestCase.java\n+++ b/src/test/org/apache/commons/math/RetryTestCase.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public class RetryTestCase extends TestCase {\n+public abstract class RetryTestCase extends TestCase {\n \n     public RetryTestCase() {\n         super();\n--- a/src/test/org/apache/commons/math/TestUtils.java\n+++ b/src/test/org/apache/commons/math/TestUtils.java\n         Assert.assertEquals(\"Equals check\", object, object2);\n         Assert.assertEquals(\"HashCode check\", object.hashCode(), object2.hashCode());\n     }\n+\n+\tpublic static void assertRelativelyEquals(double expected, double actual, double relativeError) {\n+\t\tassertRelativelyEquals(null, expected, actual, relativeError);\n+\t}\n+\t\n+\tpublic static void assertRelativelyEquals(String msg, double expected, double actual, double relativeError) {\n+        if (Double.isNaN(expected)) {\n+            Assert.assertTrue(msg, Double.isNaN(actual));\n+        } else if (Double.isNaN(actual)) {\n+        \tAssert.assertTrue(msg, Double.isNaN(expected));\n+        } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) {\n+            Assert.assertEquals(expected, actual, relativeError);\n+        } else if (expected == 0.0) {\n+            Assert.assertEquals(msg, actual, expected, relativeError);\n+        } else {\n+            double x = Math.abs((expected - actual) / expected);\n+            Assert.assertEquals(msg, 0.0, x, relativeError);\n+        }\n+\t}\n }\n--- a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n  */\n \n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.TestUtils;\n \n /**\n  * Test cases for HyperGeometriclDistribution.\n         dist.setPopulationSize(10);\n         assertEquals(10, dist.getPopulationSize());\n     }\n+    \n+    public void testLargeValues() {\n+    \tint populationSize = 3456;\n+    \tint sampleSize = 789;\n+    \tint numberOfSucceses = 101;\n+    \tdouble[][] data = {\n+    \t    {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0},\n+    \t    {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244},\n+    \t    {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673},\n+    \t    {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},\n+    \t    {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},\n+    \t    {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},\n+        \t{20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, \n+            {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701}, \n+            {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381}, \n+            {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199}, \n+            {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718}, \n+            {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418}, \n+            {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},\n+            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59}, \n+            {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},\n+            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63}, \n+            {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},\n+            {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},\n+    \t};\n+        \n+    \ttestHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n+    }\n+\n+\tprivate void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) {\n+\t\tHypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize);\n+    \tfor (int i = 0; i < data.length; ++i) {\n+    \t\tint x = (int)data[i][0];\n+    \t\tdouble pdf = data[i][1];\n+    \t\tdouble actualPdf = dist.probability(x);\n+    \t\tTestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9);\n+\n+    \t\tdouble cdf = data[i][2];\n+    \t\tdouble actualCdf = dist.cumulativeProbability(x);\n+\t\t\tTestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9);\n+\n+\t\t\tdouble cdf1 = data[i][3];\n+    \t\tdouble actualCdf1 = dist.upperCumulativeProbability(x);\n+\t\t\tTestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);\n+    \t}\n+\t}\n+    \n+    public void testMoreLargeValues() {\n+    \tint populationSize = 26896;\n+    \tint sampleSize = 895;\n+    \tint numberOfSucceses = 55;\n+    \tdouble[][] data = {\n+    \t    {0.0, 0.155168304750504, 0.155168304750504, 1.0}, \n+            {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496}, \n+    \t    {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, \n+    \t    {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, \n+    \t    {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, \n+    \t    {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, \n+            {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16}, \n+            {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17}, \n+            {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18}, \n+            {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20}, \n+            {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21}, \n+            {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23}, \n+            {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69}, \n+            {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71}, \n+            {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74}, \n+            {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76}, \n+            {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79}, \n+            {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},        \n+    \t};\n+    \ttestHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n+    }\n }\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n             BigMatrix m4 = new BigMatrixImpl(new String[][] {{\"0\", \"hello\", \"1\"}});\n             fail(\"Expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {\n+            // expected\n+        }\n+        try {\n+            BigMatrix m4 = new BigMatrixImpl(new String[][] {});\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            BigMatrix m4 = new BigMatrixImpl(new String[][] {{},{}});\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            BigMatrix m4 = new BigMatrixImpl(new String[][] {{\"a\", \"b\"},{\"c\"}});\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            BigMatrix m4 = new BigMatrixImpl(0, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            BigMatrix m4 = new BigMatrixImpl(1, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         } catch (NullPointerException e) {\n             // expected\n         }\n+        RealMatrixImpl m2 = new RealMatrixImpl();\n+        try {\n+            m2.setSubMatrix(testData,0,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {\n+            m2.setSubMatrix(testData,1,0);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n         \n         // ragged\n         try {\n--- a/src/test/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/org/apache/commons/math/stat/FrequencyTest.java\n         assertEquals(\"one count\", 3 ,  f.getCount(\"one\"));\n         assertEquals(\"Z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"Z\"), tolerance);\n         assertEquals(\"z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"z\"), tolerance);\n-        \n+\n         f = null;\n         f = new Frequency();\n         assertEquals(0L, f.getCount('a'));\n         assertEquals(2L, f.getCumFreq('b'));\n         assertEquals(0.25, f.getPct('a'), 0.0);\n         assertEquals(0.5, f.getCumPct('b'), 0.0);\n+        assertEquals(1.0, f.getCumPct('e'), 0.0);\n     }     \n     \n     /** test pcts */", "timestamp": 1125065145, "metainfo": ""}