{"sha": "7fe539d9a17f79d558e11fb4288a33bb54996dd8", "log": "Merged ChiSquaredDistribution and ChiSquaredDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+\n /**\n- * The Chi-Squared Distribution.\n+ * Implementation of the chi-squared distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n- * Chi-Squared Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Chi-squared_distribution\">Chi-squared distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">Chi-squared Distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface ChiSquaredDistribution extends ContinuousDistribution {\n+public class ChiSquaredDistribution\n+    extends AbstractContinuousDistribution\n+    implements Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8352658048349159782L;\n+    /** Internal Gamma distribution. */\n+    private final GammaDistribution gamma;\n+    /** Inverse cumulative probability accuracy */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     */\n+    public ChiSquaredDistribution(double degreesOfFreedom) {\n+        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom and\n+     * inverse cumulative probability accuracy.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @since 2.1\n+     */\n+    public ChiSquaredDistribution(double degreesOfFreedom,\n+                                      double inverseCumAccuracy) {\n+        gamma = new GammaDistributionImpl(degreesOfFreedom / 2, 2);\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n     /**\n      * Access the number of degrees of freedom.\n      *\n      * @return the degrees of freedom.\n      */\n-    double getDegreesOfFreedom();\n+    public double getDegreesOfFreedom() {\n+        return gamma.getAlpha() * 2.0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        return gamma.density(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x)  {\n+        return gamma.cumulativeProbability(x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code 0} when {@code p == 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) {\n+        if (p == 0) {\n+            return 0d;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return Double.MIN_VALUE * gamma.getBeta();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < .5) {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        } else {\n+            // use max\n+            ret = Double.MAX_VALUE;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > 0.5\n+\n+        double ret;\n+\n+        if (p < 0.5) {\n+            // use 1/2 mean\n+            ret = getDegreesOfFreedom() * 0.5;\n+        } else {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the\n+     * degrees of freedom.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n+     * degrees of freedom.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code k} degrees of freedom, the mean is {@code k}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getDegreesOfFreedom();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For {@code k} degrees of freedom, the variance is {@code 2 * k}.\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        return 2*getDegreesOfFreedom();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.BetaDistribution;\n import org.apache.commons.math.distribution.BinomialDistribution;\n import org.apache.commons.math.distribution.CauchyDistribution;\n-import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n+import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ContinuousDistribution;\n import org.apache.commons.math.distribution.FDistributionImpl;\n import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n     }\n \n     /**\n-     * Generates a random value from the {@link ChiSquaredDistributionImpl ChiSquare Distribution}.\n+     * Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public double nextChiSquare(double df) {\n-        return nextInversionDeviate(new ChiSquaredDistributionImpl(df));\n+        return nextInversionDeviate(new ChiSquaredDistribution(df));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n-import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n     public double chiSquareTest(double[] expected, long[] observed)\n         throws MathException {\n         ChiSquaredDistribution distribution =\n-            new ChiSquaredDistributionImpl(expected.length - 1.0);\n+            new ChiSquaredDistribution(expected.length - 1.0);\n         return 1.0 - distribution.cumulativeProbability(\n             chiSquare(expected, observed));\n     }\n     throws MathException {\n         checkArray(counts);\n         double df = ((double) counts.length -1) * ((double) counts[0].length - 1);\n-        ChiSquaredDistribution distribution = new ChiSquaredDistributionImpl(df);\n+        ChiSquaredDistribution distribution;\n+        distribution = new ChiSquaredDistribution(df);\n         return 1 - distribution.cumulativeProbability(chiSquare(counts));\n     }\n \n      */\n     public double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)\n         throws MathException {\n-        ChiSquaredDistribution distribution =\n-            new ChiSquaredDistributionImpl((double) observed1.length - 1);\n+        ChiSquaredDistribution distribution;\n+        distribution = new ChiSquaredDistribution((double) observed1.length - 1);\n         return 1 - distribution.cumulativeProbability(\n                 chiSquareDataSetsComparison(observed1, observed2));\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ChiSquaredDistribution makeDistribution() {\n-        return new ChiSquaredDistributionImpl(5.0);\n+        return new ChiSquaredDistribution(5.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n \n     @Test\n     public void testSmallDf() throws Exception {\n-        setDistribution(new ChiSquaredDistributionImpl(0.1d));\n+        setDistribution(new ChiSquaredDistribution(0.1d));\n         setTolerance(1E-4);\n         // quantiles computed using R version 1.8.1 (linux version)\n         setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32,\n     }\n \n     private void checkDensity(double df, double[] x, double[] expected) {\n-        ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);\n+        ChiSquaredDistribution d = new ChiSquaredDistribution(df);\n         for (int i = 0; i < x.length; i++) {\n             Assert.assertEquals(expected[i], d.density(x[i]), 1e-5);\n         }\n     public void testMoments() {\n         final double tol = 1e-9;\n         ChiSquaredDistribution dist;\n-        \n-        dist = new ChiSquaredDistributionImpl(1500);\n+\n+        dist = new ChiSquaredDistribution(1500);\n         Assert.assertEquals(dist.getNumericalMean(), 1500, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 3000, tol); \n-        \n-        dist = new ChiSquaredDistributionImpl(1.12);\n+        Assert.assertEquals(dist.getNumericalVariance(), 3000, tol);\n+\n+        dist = new ChiSquaredDistribution(1.12);\n         Assert.assertEquals(dist.getNumericalMean(), 1.12, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 2.24, tol);\n     }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.BinomialDistribution;\n import org.apache.commons.math.distribution.BinomialDistributionTest;\n import org.apache.commons.math.distribution.CauchyDistribution;\n-import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n+import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ExponentialDistributionImpl;\n import org.apache.commons.math.distribution.FDistributionImpl;\n import org.apache.commons.math.distribution.GammaDistributionImpl;\n \n     @Test\n     public void testNextChiSquare() throws Exception {\n-        double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistributionImpl(12));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistribution(12));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {", "timestamp": 1322198216, "metainfo": ""}