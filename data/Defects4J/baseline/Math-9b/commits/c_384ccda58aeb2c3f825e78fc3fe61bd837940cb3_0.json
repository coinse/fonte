{"sha": "384ccda58aeb2c3f825e78fc3fe61bd837940cb3", "log": "Improved Dormand-Prince 8(5,3) step interpolator accuracy at step start.  The previous step is preserved and if interpolation time is in the first half ot the step, then interpolation is based on step start, otherwise is it based on step end. Previously, interpolation was always performed with respect to step end.  If this trick proves useful, it will be extended to other Runge-Kutta type step interpolators.  JIRA: MATH-705  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n     extends RungeKuttaStepInterpolator {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** Simple constructor.\n      * This constructor builds an instance that is not usable yet, the\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n     private static final double D6 =      69997945.0 /     29380423.0;\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** First vector for interpolation. */\n     private double[] v1;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n   extends RungeKuttaStepInterpolator {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** Propagation weights, element 1. */\n     private static final double B_01 =         104257.0 / 1920240.0;\n     final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n     final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n \n-    for (int i = 0; i < interpolatedState.length; ++i) {\n-      interpolatedState[i] = currentState[i] -\n-                             oneMinusThetaH * (v[0][i] -\n-                                               theta * (v[1][i] +\n-                                                        theta * (v[2][i] +\n-                                                                 eta * (v[3][i] +\n-                                                                        theta * (v[4][i] +\n-                                                                                 eta * (v[5][i] +\n-                                                                                        theta * (v[6][i])))))));\n-      interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n-                                    dot3 * v[3][i] + dot4 * v[4][i] +\n-                                    dot5 * v[5][i] + dot6 * v[6][i];\n+    if ((previousState != null) && (theta <= 0.5)) {\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            interpolatedState[i] = previousState[i] +\n+                    theta * h * (v[0][i] +\n+                            eta * (v[1][i] +\n+                                    theta * (v[2][i] +\n+                                            eta * (v[3][i] +\n+                                                    theta * (v[4][i] +\n+                                                            eta * (v[5][i] +\n+                                                                    theta * (v[6][i])))))));\n+            interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n+                    dot3 * v[3][i] + dot4 * v[4][i] +\n+                    dot5 * v[5][i] + dot6 * v[6][i];\n+        }\n+    } else {\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            interpolatedState[i] = currentState[i] -\n+                    oneMinusThetaH * (v[0][i] -\n+                            theta * (v[1][i] +\n+                                    theta * (v[2][i] +\n+                                            eta * (v[3][i] +\n+                                                    theta * (v[4][i] +\n+                                                            eta * (v[5][i] +\n+                                                                    theta * (v[6][i])))))));\n+            interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n+                    dot3 * v[3][i] + dot4 * v[4][i] +\n+                    dot5 * v[5][i] + dot6 * v[6][i];\n+        }\n     }\n \n   }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n     final double[] y = y0.clone();\n     final int stages = c.length + 1;\n     final double[][] yDotK = new double[stages][y.length];\n-    final double[] yTmp    = new double[y.length];\n+    final double[] yTmp    = y0.clone();\n     final double[] yDotTmp = new double[y.length];\n \n     // set up an interpolator sharing the integrator arrays\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n       stepStart = acceptStep(interpolator, y, yDotTmp, t);\n+      System.arraycopy(y, 0, yTmp, 0, y.length);\n \n       if (!isLastStep) {\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n     private static final double TWO_PLUS_SQRT_2 = 2 + FastMath.sqrt(2.0);\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n     for (int i = 0; i < stages; ++i) {\n       yDotK [i] = new double[y0.length];\n     }\n-    final double[] yTmp    = new double[y0.length];\n+    final double[] yTmp    = y0.clone();\n     final double[] yDotTmp = new double[y0.length];\n \n     // set up an interpolator sharing the integrator arrays\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n \n abstract class RungeKuttaStepInterpolator\n   extends AbstractStepInterpolator {\n+\n+    /** Previous state. */\n+    protected double[] previousState;\n \n     /** Slopes at the intermediate points */\n     protected double[][] yDotK;\n    * uninitialized model and latter initializing the copy.\n    */\n   protected RungeKuttaStepInterpolator() {\n-    super();\n-    yDotK      = null;\n-    integrator = null;\n+    previousState = null;\n+    yDotK         = null;\n+    integrator    = null;\n   }\n \n   /** Copy constructor.\n     super(interpolator);\n \n     if (interpolator.currentState != null) {\n-      final int dimension = currentState.length;\n+\n+      previousState = interpolator.previousState.clone();\n \n       yDotK = new double[interpolator.yDotK.length][];\n       for (int k = 0; k < interpolator.yDotK.length; ++k) {\n-        yDotK[k] = new double[dimension];\n-        System.arraycopy(interpolator.yDotK[k], 0,\n-                         yDotK[k], 0, dimension);\n+        yDotK[k] = interpolator.yDotK[k].clone();\n       }\n \n     } else {\n+      previousState = null;\n       yDotK = null;\n     }\n \n                            final EquationsMapper primaryMapper,\n                            final EquationsMapper[] secondaryMappers) {\n     reinitialize(y, forward, primaryMapper, secondaryMappers);\n+    this.previousState = null;\n     this.yDotK = yDotArray;\n     this.integrator = rkIntegrator;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void shift() {\n+    previousState = currentState.clone();\n+    super.shift();\n   }\n \n   /** {@inheritDoc} */\n \n     // save the local attributes\n     final int n = (currentState == null) ? -1 : currentState.length;\n+    for (int i = 0; i < n; ++i) {\n+      out.writeDouble(previousState[i]);\n+    }\n+\n     final int kMax = (yDotK == null) ? -1 : yDotK.length;\n     out.writeInt(kMax);\n     for (int k = 0; k < kMax; ++k) {\n \n     // read the local attributes\n     final int n = (currentState == null) ? -1 : currentState.length;\n+    if (n < 0) {\n+      previousState = null;\n+    } else {\n+      previousState = new double[n];\n+      for (int i = 0; i < n; ++i) {\n+        previousState[i] = in.readDouble();\n+      }\n+    }\n+\n     final int kMax = in.readInt();\n     yDotK = (kMax < 0) ? null : new double[kMax][];\n     for (int k = 0; k < kMax; ++k) {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/events/ReappearingEventTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode.events;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.analysis.solvers.PegasusSolver;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n+import org.junit.Test;\n+\n+public class ReappearingEventTest {\n+    @Test\n+    public void testDormandPrince() {\n+        double tEnd = test(1);\n+        assertEquals(10.0, tEnd, 1e-7);\n+    }\n+\n+    @Test\n+    public void testGragg() {\n+        double tEnd = test(2);\n+        assertEquals(10.0, tEnd, 1e-7);\n+    }\n+\n+    public double test(int integratorType) {\n+        double e = 1e-15;\n+        FirstOrderIntegrator integrator;\n+        integrator = (integratorType == 1)\n+                     ? new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7)\n+                     : new GraggBulirschStoerIntegrator(e, 100.0, 1e-7, 1e-7);\n+        PegasusSolver rootSolver = new PegasusSolver(e, e);\n+        integrator.addEventHandler(new Event(), 0.1, e, 1000, rootSolver);\n+        double t0 = 6.0;\n+        double tEnd = 10.0;\n+        double[] y = {2.0, 2.0, 2.0, 4.0, 2.0, 7.0, 15.0};\n+        return integrator.integrate(new Ode(), t0, y, tEnd, y);\n+    }\n+\n+    private static class Ode implements FirstOrderDifferentialEquations {\n+        public int getDimension() {\n+            return 7;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            Arrays.fill(yDot, 1.0);\n+        }\n+    }\n+\n+    /** State events for this unit test. */\n+    protected static class Event implements EventHandler {\n+        public double g(double t, double[] y) {\n+            return y[6] - 15.0;\n+        }\n+\n+        public Action eventOccurred(double t, double[] y, boolean increasing) {\n+            return Action.STOP;\n+        }\n+\n+        public void resetState(double t, double[] y) {\n+            // Never called.\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    Assert.assertTrue(bos.size () > 750000);\n-    Assert.assertTrue(bos.size () < 800000);\n+    Assert.assertTrue(bos.size () > 880000);\n+    Assert.assertTrue(bos.size () < 900000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    Assert.assertTrue(bos.size () > 125000);\n-    Assert.assertTrue(bos.size () < 130000);\n+    Assert.assertTrue(bos.size () > 135000);\n+    Assert.assertTrue(bos.size () < 145000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    Assert.assertTrue(bos.size () > 85000);\n-    Assert.assertTrue(bos.size () < 95000);\n+    Assert.assertTrue(bos.size () > 90000);\n+    Assert.assertTrue(bos.size () < 100000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    Assert.assertTrue(bos.size () > 750000);\n-    Assert.assertTrue(bos.size () < 800000);\n+    Assert.assertTrue(bos.size () > 880000);\n+    Assert.assertTrue(bos.size () < 900000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    Assert.assertTrue(bos.size () > 170000);\n-    Assert.assertTrue(bos.size () < 175000);\n+    Assert.assertTrue(bos.size () > 185000);\n+    Assert.assertTrue(bos.size () < 195000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    Assert.assertTrue(bos.size () > 120000);\n-    Assert.assertTrue(bos.size () < 125000);\n+    Assert.assertTrue(bos.size () > 135000);\n+    Assert.assertTrue(bos.size () < 145000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n         oos.writeObject(handler);\n     }\n \n-    Assert.assertTrue(bos.size () > 750000);\n-    Assert.assertTrue(bos.size () < 800000);\n+    Assert.assertTrue(bos.size () > 880000);\n+    Assert.assertTrue(bos.size () < 900000);\n \n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);", "timestamp": 1321825306, "metainfo": ""}