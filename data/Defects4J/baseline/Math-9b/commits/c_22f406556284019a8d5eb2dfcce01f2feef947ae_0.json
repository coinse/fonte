{"sha": "22f406556284019a8d5eb2dfcce01f2feef947ae", "log": "renamed Dense{Real/Field}Matrix into Block{Real/Field}Matrix as suggested by Phil in http://markmail.org/message/iibgiz4bsv6hjjvh  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n       \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la multiplication matricielle\" },\n \n-    // org.apache.commons.math.linear.DenseRealMatrix\n+    // org.apache.commons.math.linear.BlockRealMatrix\n     { \"wrong array shape (block length = {0}, expected {1})\",\n       \"forme de tableau erron\\u00e9e (bloc de longueur {0} au lieu des {1} attendus)\" },\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Cache-friendly implementation of FieldMatrix using a flat arrays to store\n+ * square blocks of the matrix.\n+ * <p>\n+ * This implementation is specially designed to be cache-friendly. Square blocks are\n+ * stored as small arrays and allow efficient traversal of data both in row major direction\n+ * and columns major direction, one block at a time. This greatly increases performances\n+ * for algorithms that use crossed directions loops like multiplication or transposition.\n+ * </p>\n+ * <p>\n+ * The size of square blocks is a static parameter. It may be tuned according to the cache\n+ * size of the target computer processor. As a rule of thumbs, it should be the largest\n+ * value that allows three blocks to be simultaneously cached (this is necessary for example\n+ * for matrix multiplication). The default value is to use 36x36 blocks.\n+ * </p>\n+ * <p>\n+ * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks\n+ * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square\n+ * blocks are flattened in row major order in single dimension arrays which are therefore\n+ * {@link #BLOCK_SIZE}<sup>2</sup> elements long for regular blocks. The blocks are themselves\n+ * organized in row major order.\n+ * </p>\n+ * <p>\n+ * As an example, for a block size of 36x36, a 100x60 matrix would be stored in 6 blocks.\n+ * Block 0 would be a Field[1296] array holding the upper left 36x36 square, block 1 would be\n+ * a Field[1296] array holding the upper center 36x36 square, block 2 would be a Field[1008]\n+ * array holding the upper right 36x28 rectangle, block 3 would be a Field[864] array holding\n+ * the lower left 24x36 rectangle, block 4 would be a Field[864] array holding the lower center\n+ * 24x36 rectangle and block 5 would be a Field[672] array holding the lower right 24x28\n+ * rectangle.\n+ * </p>\n+ * <p>\n+ * The layout complexity overhead versus simple mapping of matrices to java\n+ * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads\n+ * to up to 3-fold improvements for matrices of moderate to large size.\n+ * </p>\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BlockFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -4602336630143123183L;\n+\n+    /** Block size. */\n+    public static final int BLOCK_SIZE = 36;\n+\n+    /** Blocks of matrix entries. */\n+    private final T blocks[][];\n+\n+    /** Number of rows of the matrix. */\n+    private final int rows;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columns;\n+\n+    /** Number of block rows of the matrix. */\n+    private final int blockRows;\n+\n+    /** Number of block columns of the matrix. */\n+    private final int blockColumns;\n+\n+    /**\n+     * Create a new matrix with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public BlockFieldMatrix(final Field<T> field, final int rows, final int columns)\n+        throws IllegalArgumentException {\n+\n+        super(field, rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // allocate storage blocks, taking care of smaller ones at right and bottom\n+        blocks = createBlocksLayout(field, rows, columns);\n+\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from raw layout data.\n+     * <p>The input array <em>must</em> already be in raw layout.</p>\n+     * <p>Calling this constructor is equivalent to call:\n+     * <pre>matrix = new BlockFieldMatrix<T>(getField(), rawData.length, rawData[0].length,\n+     *                                   toBlocksLayout(rawData), false);</pre>\n+     * </p>\n+     * @param rawData data for new matrix, in raw layout\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n+     */\n+    public BlockFieldMatrix(final T[][] rawData)\n+        throws IllegalArgumentException {\n+        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from block layout data.\n+     * <p>The input array <em>must</em> already be in blocks layout.</p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @param blockData data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #createBlocksLayout(Field, int, int)\n+     * @see #toBlocksLayout(FieldElement[][])\n+     * @see #BlockFieldMatrix(FieldElement[][])\n+     */\n+    public BlockFieldMatrix(final int rows, final int columns,\n+                            final T[][] blockData, final boolean copyArray)\n+        throws IllegalArgumentException {\n+\n+        super(extractField(blockData), rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        if (copyArray) {\n+            // allocate storage blocks, taking care of smaller ones at right and bottom\n+            blocks = buildArray(getField(), blockRows * blockColumns, -1);\n+        } else {\n+            // reference existing array\n+            blocks = blockData;\n+        }\n+\n+        int index = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n+                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"wrong array shape (block length = {0}, expected {1})\",\n+                            blockData[index].length, iHeight * blockWidth(jBlock));\n+                }\n+                if (copyArray) {\n+                    blocks[index] = blockData[index].clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a data array from raw layout to blocks layout.\n+     * <p>\n+     * Raw layout is the straightforward layout where element at row i and\n+     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n+     * is the layout used in {@link BlockFieldMatrix} instances, where the matrix\n+     * is split in square blocks (except at right and bottom side where blocks may\n+     * be rectangular to fit matrix size) and each block is stored in a flattened\n+     * one-dimensional array.\n+     * </p>\n+     * <p>\n+     * This method creates an array in blocks layout from an input array in raw layout.\n+     * It can be used to provide the array argument of the {@link\n+     * BlockFieldMatrix#DenseFieldMatrix(int, int, FieldElement[][], boolean)}\n+     * constructor.\n+     * </p>\n+     * @param <T> the type of the field elements\n+     * @param rawData data array in raw layout\n+     * @return a new data array containing the same entries but in blocks layout\n+     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n+     *  (not all rows have the same length)\n+     * @see #createBlocksLayout(Field, int, int)\n+     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n+     */\n+    public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData)\n+        throws IllegalArgumentException {\n+\n+        final int rows         = rawData.length;\n+        final int columns      = rawData[0].length;\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // safety checks\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int length = rawData[i].length;\n+            if (length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        columns, length); \n+            }\n+        }\n+\n+        // convert array\n+        final Field<T> field = extractField(rawData);\n+        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+\n+                // allocate new block\n+                final T[] block = buildArray(field, iHeight * jWidth);\n+                blocks[blockIndex] = block;\n+\n+                // copy data\n+                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n+                }\n+\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /**\n+     * Create a data array in blocks layout.\n+     * <p>\n+     * This method can be used to create the array argument of the {@link\n+     * BlockFieldMatrix#DenseFieldMatrix(int, int, FieldElement[][], boolean)}\n+     * constructor.\n+     * </p>\n+     * @param <T> the type of the field elements\n+     * @param field field to which the elements belong\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @return a new data array in blocks layout\n+     * @see #toBlocksLayout(FieldElement[][])\n+     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n+     */\n+    public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field,\n+                                                                       final int rows, final int columns) {\n+\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+                blocks[blockIndex] = buildArray(field, iHeight * jWidth);\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new BlockFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+\n+        // create an empty matrix\n+        BlockFieldMatrix<T> copied = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // copy the blocks\n+        for (int i = 0; i < blocks.length; ++i) {\n+            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n+        }\n+\n+        return copied;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> add(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((BlockFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkAdditionCompatible(m);\n+\n+            final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+            // perform addition block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform addition on the current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+                    final T[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k].add(m.getEntry(p, q));\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockFieldMatrix<T> add(final BlockFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform addition block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            final T[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].add(mBlock[k]);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((BlockFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkSubtractionCompatible(m);\n+\n+            final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+            // perform subtraction block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform subtraction on the current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+                    final T[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k].subtract(m.getEntry(p, q));\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockFieldMatrix<T> subtract(final BlockFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            final T[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].subtract(mBlock[k]);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarAdd(final T d)\n+        throws IllegalArgumentException {\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].add(d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarMultiply(final T d)\n+        throws IllegalArgumentException {\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].multiply(d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((BlockFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkMultiplicationCompatible(m);\n+\n+            final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, m.getColumnDimension());\n+            final T zero = getField().getZero();\n+\n+            // perform multiplication block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+\n+                    // select current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+\n+                    // perform multiplication on current block\n+                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                        final int kWidth      = blockWidth(kBlock);\n+                        final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                        final int rStart      = kBlock * BLOCK_SIZE;\n+                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                            final int lStart = (p - pStart) * kWidth;\n+                            final int lEnd   = lStart + kWidth;\n+                            for (int q = qStart; q < qEnd; ++q) {\n+                                T sum = zero;\n+                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                    sum = sum.add(tBlock[l].multiply(m.getEntry(r, q)));\n+                                }\n+                                outBlock[k] = outBlock[k].add(sum);\n+                                ++k;\n+                            }\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BlockFieldMatrix<T> multiply(BlockFieldMatrix<T> m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, m.columns);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+                final int jWidth2 = jWidth  + jWidth;\n+                final int jWidth3 = jWidth2 + jWidth;\n+                final int jWidth4 = jWidth3 + jWidth;\n+\n+                // select current block\n+                final T[] outBlock = out.blocks[blockIndex];\n+\n+                // perform multiplication on current block\n+                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                    final int kWidth = blockWidth(kBlock);\n+                    final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                    final T[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        final int lStart = (p - pStart) * kWidth;\n+                        final int lEnd   = lStart + kWidth;\n+                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n+                            T sum = zero;\n+                            int l = lStart;\n+                            int n = nStart;\n+                            while (l < lEnd - 3) {\n+                                sum = sum.\n+                                      add(tBlock[l].multiply(mBlock[n])).\n+                                      add(tBlock[l + 1].multiply(mBlock[n + jWidth])).\n+                                      add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).\n+                                      add(tBlock[l + 3].multiply(mBlock[n + jWidth3]));\n+                                l += 4;\n+                                n += jWidth4;\n+                            }\n+                            while (l < lEnd) {\n+                                sum = sum.add(tBlock[l++].multiply(mBlock[n]));\n+                                n += jWidth;\n+                            }\n+                            outBlock[k] = outBlock[k].add(sum);\n+                            ++k;\n+                        }\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[][] getData() {\n+\n+        final T[][] data = buildArray(getField(), getRowDimension(), getColumnDimension());\n+        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n+\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            int regularPos   = 0;\n+            int lastPos      = 0;\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final T[] dataP = data[p];\n+                int blockIndex = iBlock * blockColumns;\n+                int dataPos    = 0;\n+                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n+                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n+                    dataPos += BLOCK_SIZE;\n+                }\n+                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n+                regularPos += BLOCK_SIZE;\n+                lastPos    += lastColumns;\n+            }\n+        }\n+\n+        return data;\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+\n+        // create the output matrix\n+        final BlockFieldMatrix<T> out =\n+            new BlockFieldMatrix<T>(getField(), endRow - startRow + 1, endColumn - startColumn + 1);\n+\n+        // compute blocks shifts\n+        final int blockStartRow    = startRow    / BLOCK_SIZE;\n+        final int rowsShift        = startRow    % BLOCK_SIZE;\n+        final int blockStartColumn = startColumn / BLOCK_SIZE;\n+        final int columnsShift     = startColumn % BLOCK_SIZE;\n+\n+        // perform extraction block-wise, to ensure good cache behavior\n+        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+            final int iHeight = out.blockHeight(iBlock);\n+            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+\n+                // handle one block of the output matrix\n+                final int      outIndex = iBlock * out.blockColumns + jBlock;\n+                final T[] outBlock = out.blocks[outIndex];\n+                final int      index    = pBlock * blockColumns + qBlock;\n+                final int      width    = blockWidth(qBlock);\n+\n+                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n+                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;\n+                if (heightExcess > 0) {\n+                    // the submatrix block spans on two blocks rows from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n+                                      0, heightExcess,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                    }\n+                } else {\n+                    // the submatrix block spans on one block row from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                    }\n+               }\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /**\n+     * Copy a part of a block into another one\n+     * <p>This method can be called only when the specified part fits in both\n+     * blocks, no verification is done here.</p>\n+     * @param srcBlock source block\n+     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param srcStartRow start row in the source block\n+     * @param srcEndRow end row (exclusive) in the source block\n+     * @param srcStartColumn start column in the source block\n+     * @param srcEndColumn end column (exclusive) in the source block\n+     * @param dstBlock destination block\n+     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param dstStartRow start row in the destination block\n+     * @param dstStartColumn start column in the destination block\n+     */\n+    private void copyBlockPart(final T[] srcBlock, final int srcWidth,\n+                               final int srcStartRow, final int srcEndRow,\n+                               final int srcStartColumn, final int srcEndColumn,\n+                               final T[] dstBlock, final int dstWidth,\n+                               final int dstStartRow, final int dstStartColumn) {\n+        final int length = srcEndColumn - srcStartColumn;\n+        int srcPos = srcStartRow * srcWidth + srcStartColumn;\n+        int dstPos = dstStartRow * dstWidth + dstStartColumn;\n+        for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {\n+            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n+            srcPos += srcWidth;\n+            dstPos += dstWidth;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        final int refLength = subMatrix[0].length;\n+        if (refLength < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n+        }\n+        final int endRow    = row + subMatrix.length - 1;\n+        final int endColumn = column + refLength - 1;\n+        checkSubMatrixIndex(row, endRow, column, endColumn);\n+        for (final T[] subRow : subMatrix) {\n+            if (subRow.length != refLength) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        refLength, subRow.length); \n+            }\n+        }\n+\n+        // compute blocks bounds\n+        final int blockStartRow    = row / BLOCK_SIZE;\n+        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockStartColumn = column / BLOCK_SIZE;\n+        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n+            final int iHeight  = blockHeight(iBlock);\n+            final int firstRow = iBlock * BLOCK_SIZE;\n+            final int iStart   = Math.max(row,    firstRow);\n+            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+\n+            for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n+                final int jWidth      = blockWidth(jBlock);\n+                final int firstColumn = jBlock * BLOCK_SIZE;\n+                final int jStart      = Math.max(column,    firstColumn);\n+                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jLength     = jEnd - jStart;\n+\n+                // handle one block, row by row\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int i = iStart; i < iEnd; ++i) {\n+                    System.arraycopy(subMatrix[i - row], jStart - column,\n+                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n+                                     jLength);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), 1, columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        T[] outBlock = out.blocks[outBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = outBlock.length - outIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n+                outBlock = out.blocks[++outBlockIndex];\n+                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n+                outIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n+                outIndex += jWidth;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRowMatrix(row, (BlockFieldMatrix<T>) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setRowMatrix(row, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param matrix row matrix (must have one row and the same number of columns\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance row\n+     */\n+    public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow   = row - iBlock * BLOCK_SIZE;\n+        int mBlockIndex  = 0;\n+        int mIndex       = 0;\n+        T[] mBlock  = matrix.blocks[mBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = mBlock.length - mIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n+                mBlock = matrix.blocks[++mBlockIndex];\n+                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n+                mIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n+                mIndex += jWidth;\n+           }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, 1);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        T[] outBlock = out.blocks[outBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (outIndex >= outBlock.length) {\n+                    outBlock = out.blocks[++outBlockIndex];\n+                    outIndex = 0;\n+                }\n+                outBlock[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumnMatrix(column, (BlockFieldMatrix<T>) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setColumnMatrix(column, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param matrix column matrix (must have one column and the same number of rows\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance column\n+     */\n+    void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int mBlockIndex = 0;\n+        int mIndex      = 0;\n+        T[] mBlock = matrix.blocks[mBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (mIndex >= mBlock.length) {\n+                    mBlock = matrix.blocks[++mBlockIndex];\n+                    mIndex = 0;\n+                }\n+                block[i * jWidth + jColumn] = mBlock[mIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldVector<T> getRowVector(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final T[] outData = buildArray(getField(), columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return new FieldVectorImpl<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowVector(final int row, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRow(row, ((FieldVectorImpl<T>) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setRowVector(row, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldVector<T> getColumnVector(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final T[] outData = buildArray(getField(), rows);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                outData[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return new FieldVectorImpl<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnVector(final int column, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumn(column, ((FieldVectorImpl<T>) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setColumnVector(column, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final T[] out = buildArray(getField(), columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRow(final int row, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final T[] out = buildArray(getField(), rows);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                out[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumn(final int column, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                block[i * jWidth + jColumn] = array[outIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            return blocks[iBlock * blockColumns + jBlock][k];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+            blockIJ[k] = blockIJ[k].add(increment);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+            blockIJ[k] = blockIJ[k].multiply(factor);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n+\n+        // perform transpose block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n+            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n+\n+                // transpose current block\n+                final T[] outBlock = out.blocks[blockIndex];\n+                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n+                final int      pStart   = iBlock * BLOCK_SIZE;\n+                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      qStart   = jBlock * BLOCK_SIZE;\n+                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    final int lInc = pEnd - pStart;\n+                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n+                        outBlock[k++] = tBlock[l];\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rows;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columns;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != columns) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, columns);\n+        }\n+        final T[] out = buildArray(getField(), rows);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                final T[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      qStart = jBlock * BLOCK_SIZE;\n+                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    T sum = zero;\n+                    int q = qStart;\n+                    while (q < qEnd - 3) {\n+                        sum = sum.\n+                              add(block[k].multiply(v[q])).\n+                              add(block[k + 1].multiply(v[q + 1])).\n+                              add(block[k + 2].multiply(v[q + 2])).\n+                              add(block[k + 3].multiply(v[q + 3]));\n+                        k += 4;\n+                        q += 4;\n+                    }\n+                    while (q < qEnd) {\n+                        sum = sum.add(block[k++].multiply(v[q++]));\n+                    }\n+                    out[p] = out[p].add(sum);\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != rows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, rows);\n+        }\n+        final T[] out = buildArray(getField(), columns);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth  = blockWidth(jBlock);\n+            final int jWidth2 = jWidth  + jWidth;\n+            final int jWidth3 = jWidth2 + jWidth;\n+            final int jWidth4 = jWidth3 + jWidth;\n+            final int qStart = jBlock * BLOCK_SIZE;\n+            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final T[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      pStart = iBlock * BLOCK_SIZE;\n+                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                for (int q = qStart; q < qEnd; ++q) {\n+                    int k = q - qStart;\n+                    T sum = zero;\n+                    int p = pStart;\n+                    while (p < pEnd - 3) {\n+                        sum = sum.\n+                              add(block[k].multiply(v[p])).\n+                              add(block[k + jWidth].multiply(v[p + 1])).\n+                              add(block[k + jWidth2].multiply(v[p + 2])).\n+                              add(block[k + jWidth3].multiply(v[p + 3]));\n+                        k += jWidth4;\n+                        p += 4;\n+                    }\n+                    while (p < pEnd) {\n+                        sum = sum.add(block[k].multiply(v[p++]));\n+                        k += jWidth;\n+                    }\n+                    out[q] = out[q].add(sum);\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final T[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final T[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Get the height of a block.\n+     * @param blockRow row index (in block sense) of the block\n+     * @return height (number of rows) of the block\n+     */\n+    private int blockHeight(final int blockRow) {\n+        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+    /**\n+     * Get the width of a block.\n+     * @param blockColumn column index (in block sense) of the block\n+     * @return width (number of columns) of the block\n+     */\n+    private int blockWidth(final int blockColumn) {\n+        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Cache-friendly implementation of RealMatrix using a flat arrays to store\n+ * square blocks of the matrix.\n+ * <p>\n+ * This implementation is specially designed to be cache-friendly. Square blocks are\n+ * stored as small arrays and allow efficient traversal of data both in row major direction\n+ * and columns major direction, one block at a time. This greatly increases performances\n+ * for algorithms that use crossed directions loops like multiplication or transposition.\n+ * </p>\n+ * <p>\n+ * The size of square blocks is a static parameter. It may be tuned according to the cache\n+ * size of the target computer processor. As a rule of thumbs, it should be the largest\n+ * value that allows three blocks to be simultaneously cached (this is necessary for example\n+ * for matrix multiplication). The default value is to use 52x52 blocks which is well suited\n+ * for processors with 64k L1 cache (one block holds 2704 values or 21632 bytes). This value\n+ * could be lowered to 36x36 for processors with 32k L1 cache.\n+ * </p>\n+ * <p>\n+ * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks\n+ * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square\n+ * blocks are flattened in row major order in single dimension arrays which are therefore\n+ * {@link #BLOCK_SIZE}<sup>2</sup> elements long for regular blocks. The blocks are themselves\n+ * organized in row major order.\n+ * </p>\n+ * <p>\n+ * As an example, for a block size of 52x52, a 100x60 matrix would be stored in 4 blocks.\n+ * Block 0 would be a double[2704] array holding the upper left 52x52 square, block 1 would be\n+ * a double[416] array holding the upper right 52x8 rectangle, block 2 would be a double[2496]\n+ * array holding the lower left 48x52 rectangle and block 3 would be a double[384] array\n+ * holding the lower right 48x8 rectangle.\n+ * </p>\n+ * <p>\n+ * The layout complexity overhead versus simple mapping of matrices to java\n+ * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads\n+ * to up to 3-fold improvements for matrices of moderate to large size.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BlockRealMatrix extends AbstractRealMatrix implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4991895511313664478L;\n+\n+    /** Block size. */\n+    public static final int BLOCK_SIZE = 52;\n+\n+    /** Blocks of matrix entries. */\n+    private final double blocks[][];\n+\n+    /** Number of rows of the matrix. */\n+    private final int rows;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columns;\n+\n+    /** Number of block rows of the matrix. */\n+    private final int blockRows;\n+\n+    /** Number of block columns of the matrix. */\n+    private final int blockColumns;\n+\n+    /**\n+     * Create a new matrix with the supplied row and column dimensions.\n+     *\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public BlockRealMatrix(final int rows, final int columns)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // allocate storage blocks, taking care of smaller ones at right and bottom\n+        blocks = createBlocksLayout(rows, columns);\n+\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from raw layout data.\n+     * <p>The input array <em>must</em> already be in raw layout.</p>\n+     * <p>Calling this constructor is equivalent to call:\n+     * <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,\n+     *                                   toBlocksLayout(rawData), false);</pre>\n+     * </p>\n+     * @param rawData data for new matrix, in raw layout\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #BlockRealMatrix(int, int, double[][], boolean)\n+     */\n+    public BlockRealMatrix(final double[][] rawData)\n+        throws IllegalArgumentException {\n+        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from block layout data.\n+     * <p>The input array <em>must</em> already be in blocks layout.</p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @param blockData data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #createBlocksLayout(int, int)\n+     * @see #toBlocksLayout(double[][])\n+     * @see #BlockRealMatrix(double[][])\n+     */\n+    public BlockRealMatrix(final int rows, final int columns,\n+                           final double[][] blockData, final boolean copyArray)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        if (copyArray) {\n+            // allocate storage blocks, taking care of smaller ones at right and bottom\n+            blocks = new double[blockRows * blockColumns][];\n+        } else {\n+            // reference existing array\n+            blocks = blockData;\n+        }\n+\n+        int index = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n+                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"wrong array shape (block length = {0}, expected {1})\",\n+                            blockData[index].length, iHeight * blockWidth(jBlock));\n+                }\n+                if (copyArray) {\n+                    blocks[index] = blockData[index].clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a data array from raw layout to blocks layout.\n+     * <p>\n+     * Raw layout is the straightforward layout where element at row i and\n+     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n+     * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n+     * is split in square blocks (except at right and bottom side where blocks may\n+     * be rectangular to fit matrix size) and each block is stored in a flattened\n+     * one-dimensional array.\n+     * </p>\n+     * <p>\n+     * This method creates an array in blocks layout from an input array in raw layout.\n+     * It can be used to provide the array argument of the {@link\n+     * BlockRealMatrix#DenseRealMatrix(int, int, double[][], boolean)} constructor.\n+     * </p>\n+     * @param rawData data array in raw layout\n+     * @return a new data array containing the same entries but in blocks layout\n+     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n+     *  (not all rows have the same length)\n+     * @see #createBlocksLayout(int, int)\n+     * @see #BlockRealMatrix(int, int, double[][], boolean)\n+     */\n+    public static double[][] toBlocksLayout(final double[][] rawData)\n+        throws IllegalArgumentException {\n+\n+        final int rows         = rawData.length;\n+        final int columns      = rawData[0].length;\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // safety checks\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int length = rawData[i].length;\n+            if (length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        columns, length); \n+            }\n+        }\n+\n+        // convert array\n+        final double[][] blocks = new double[blockRows * blockColumns][];\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+\n+                // allocate new block\n+                final double[] block = new double[iHeight * jWidth];\n+                blocks[blockIndex] = block;\n+\n+                // copy data\n+                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n+                }\n+\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /**\n+     * Create a data array in blocks layout.\n+     * <p>\n+     * This method can be used to create the array argument of the {@link\n+     * BlockRealMatrix#DenseRealMatrix(int, int, double[][], boolean)} constructor.\n+     * </p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @return a new data array in blocks layout\n+     * @see #toBlocksLayout(double[][])\n+     * @see #BlockRealMatrix(int, int, double[][], boolean)\n+     */\n+    public static double[][] createBlocksLayout(final int rows, final int columns) {\n+\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        final double[][] blocks = new double[blockRows * blockColumns][];\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+                blocks[blockIndex] = new double[iHeight * jWidth];\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new BlockRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix copy() {\n+\n+        // create an empty matrix\n+        BlockRealMatrix copied = new BlockRealMatrix(rows, columns);\n+\n+        // copy the blocks\n+        for (int i = 0; i < blocks.length; ++i) {\n+            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n+        }\n+\n+        return copied;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((BlockRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkAdditionCompatible(this, m);\n+\n+            final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+            // perform addition block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform addition on the current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+                    final double[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k] + m.getEntry(p, q);\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockRealMatrix add(final BlockRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform addition block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            final double[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] + mBlock[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((BlockRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+            final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+            // perform subtraction block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform subtraction on the current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+                    final double[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k] - m.getEntry(p, q);\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockRealMatrix subtract(final BlockRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            final double[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] - mBlock[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix scalarAdd(final double d)\n+        throws IllegalArgumentException {\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] + d;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix scalarMultiply(final double d)\n+        throws IllegalArgumentException {\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] * d;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((BlockRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n+\n+            // perform multiplication block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+\n+                    // select current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+\n+                    // perform multiplication on current block\n+                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                        final int kWidth      = blockWidth(kBlock);\n+                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                        final int rStart      = kBlock * BLOCK_SIZE;\n+                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                            final int lStart = (p - pStart) * kWidth;\n+                            final int lEnd   = lStart + kWidth;\n+                            for (int q = qStart; q < qEnd; ++q) {\n+                                double sum = 0;\n+                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                    sum += tBlock[l] * m.getEntry(r, q);\n+                                }\n+                                outBlock[k++] += sum;\n+                            }\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BlockRealMatrix multiply(BlockRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, m.columns);\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+                final int jWidth2 = jWidth  + jWidth;\n+                final int jWidth3 = jWidth2 + jWidth;\n+                final int jWidth4 = jWidth3 + jWidth;\n+\n+                // select current block\n+                final double[] outBlock = out.blocks[blockIndex];\n+\n+                // perform multiplication on current block\n+                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                    final int kWidth = blockWidth(kBlock);\n+                    final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                    final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        final int lStart = (p - pStart) * kWidth;\n+                        final int lEnd   = lStart + kWidth;\n+                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n+                            double sum = 0;\n+                            int l = lStart;\n+                            int n = nStart;\n+                            while (l < lEnd - 3) {\n+                                sum += tBlock[l] * mBlock[n] +\n+                                       tBlock[l + 1] * mBlock[n + jWidth] +\n+                                       tBlock[l + 2] * mBlock[n + jWidth2] +\n+                                       tBlock[l + 3] * mBlock[n + jWidth3];\n+                                l += 4;\n+                                n += jWidth4;\n+                            }\n+                            while (l < lEnd) {\n+                                sum += tBlock[l++] * mBlock[n];\n+                                n += jWidth;\n+                            }\n+                            outBlock[k++] += sum;\n+                        }\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[][] getData() {\n+\n+        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n+        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n+\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            int regularPos   = 0;\n+            int lastPos      = 0;\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final double[] dataP = data[p];\n+                int blockIndex = iBlock * blockColumns;\n+                int dataPos    = 0;\n+                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n+                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n+                    dataPos += BLOCK_SIZE;\n+                }\n+                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n+                regularPos += BLOCK_SIZE;\n+                lastPos    += lastColumns;\n+            }\n+        }\n+\n+        return data;\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getNorm() {\n+        final double[] colSums = new double[BLOCK_SIZE];\n+        double maxColSum = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; jBlock++) {\n+            final int jWidth = blockWidth(jBlock);\n+            Arrays.fill(colSums, 0, jWidth, 0.0);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final int iHeight = blockHeight(iBlock);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int j = 0; j < jWidth; ++j) {\n+                    double sum = 0;\n+                    for (int i = 0; i < iHeight; ++i) {\n+                        sum += Math.abs(block[i * jWidth + j]);\n+                    }\n+                    colSums[j] += sum;\n+                }\n+            }\n+            for (int j = 0; j < jWidth; ++j) {\n+                maxColSum = Math.max(maxColSum, colSums[j]);\n+            }\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public double getFrobeniusNorm() {\n+        double sum2 = 0;\n+        for (int blockIndex = 0; blockIndex < blocks.length; ++blockIndex) {\n+            for (final double entry : blocks[blockIndex]) {\n+                sum2 += entry * entry;\n+            }\n+        }\n+        return Math.sqrt(sum2);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+\n+        // create the output matrix\n+        final BlockRealMatrix out =\n+            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+\n+        // compute blocks shifts\n+        final int blockStartRow    = startRow    / BLOCK_SIZE;\n+        final int rowsShift        = startRow    % BLOCK_SIZE;\n+        final int blockStartColumn = startColumn / BLOCK_SIZE;\n+        final int columnsShift     = startColumn % BLOCK_SIZE;\n+\n+        // perform extraction block-wise, to ensure good cache behavior\n+        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+            final int iHeight = out.blockHeight(iBlock);\n+            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+\n+                // handle one block of the output matrix\n+                final int      outIndex = iBlock * out.blockColumns + jBlock;\n+                final double[] outBlock = out.blocks[outIndex];\n+                final int      index    = pBlock * blockColumns + qBlock;\n+                final int      width    = blockWidth(qBlock);\n+\n+                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n+                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;\n+                if (heightExcess > 0) {\n+                    // the submatrix block spans on two blocks rows from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n+                                      0, heightExcess,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                    }\n+                } else {\n+                    // the submatrix block spans on one block row from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                    }\n+               }\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /**\n+     * Copy a part of a block into another one\n+     * <p>This method can be called only when the specified part fits in both\n+     * blocks, no verification is done here.</p>\n+     * @param srcBlock source block\n+     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param srcStartRow start row in the source block\n+     * @param srcEndRow end row (exclusive) in the source block\n+     * @param srcStartColumn start column in the source block\n+     * @param srcEndColumn end column (exclusive) in the source block\n+     * @param dstBlock destination block\n+     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param dstStartRow start row in the destination block\n+     * @param dstStartColumn start column in the destination block\n+     */\n+    private void copyBlockPart(final double[] srcBlock, final int srcWidth,\n+                               final int srcStartRow, final int srcEndRow,\n+                               final int srcStartColumn, final int srcEndColumn,\n+                               final double[] dstBlock, final int dstWidth,\n+                               final int dstStartRow, final int dstStartColumn) {\n+        final int length = srcEndColumn - srcStartColumn;\n+        int srcPos = srcStartRow * srcWidth + srcStartColumn;\n+        int dstPos = dstStartRow * dstWidth + dstStartColumn;\n+        for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {\n+            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n+            srcPos += srcWidth;\n+            dstPos += dstWidth;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        final int refLength = subMatrix[0].length;\n+        if (refLength < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n+        }\n+        final int endRow    = row + subMatrix.length - 1;\n+        final int endColumn = column + refLength - 1;\n+        MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);\n+        for (final double[] subRow : subMatrix) {\n+            if (subRow.length != refLength) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        refLength, subRow.length); \n+            }\n+        }\n+\n+        // compute blocks bounds\n+        final int blockStartRow    = row / BLOCK_SIZE;\n+        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockStartColumn = column / BLOCK_SIZE;\n+        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n+            final int iHeight  = blockHeight(iBlock);\n+            final int firstRow = iBlock * BLOCK_SIZE;\n+            final int iStart   = Math.max(row,    firstRow);\n+            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+\n+            for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n+                final int jWidth      = blockWidth(jBlock);\n+                final int firstColumn = jBlock * BLOCK_SIZE;\n+                final int jStart      = Math.max(column,    firstColumn);\n+                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jLength     = jEnd - jStart;\n+\n+                // handle one block, row by row\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int i = iStart; i < iEnd; ++i) {\n+                    System.arraycopy(subMatrix[i - row], jStart - column,\n+                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n+                                     jLength);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final BlockRealMatrix out = new BlockRealMatrix(1, columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        double[] outBlock = out.blocks[outBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = outBlock.length - outIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n+                outBlock = out.blocks[++outBlockIndex];\n+                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n+                outIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n+                outIndex += jWidth;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowMatrix(final int row, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRowMatrix(row, (BlockRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setRowMatrix(row, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param matrix row matrix (must have one row and the same number of columns\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance row\n+     */\n+    public void setRowMatrix(final int row, final BlockRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow   = row - iBlock * BLOCK_SIZE;\n+        int mBlockIndex  = 0;\n+        int mIndex       = 0;\n+        double[] mBlock  = matrix.blocks[mBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = mBlock.length - mIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n+                mBlock = matrix.blocks[++mBlockIndex];\n+                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n+                mIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n+                mIndex += jWidth;\n+           }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, 1);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        double[] outBlock = out.blocks[outBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (outIndex >= outBlock.length) {\n+                    outBlock = out.blocks[++outBlockIndex];\n+                    outIndex = 0;\n+                }\n+                outBlock[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnMatrix(final int column, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumnMatrix(column, (BlockRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setColumnMatrix(column, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param matrix column matrix (must have one column and the same number of rows\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance column\n+     */\n+    void setColumnMatrix(final int column, final BlockRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int mBlockIndex = 0;\n+        int mIndex      = 0;\n+        double[] mBlock = matrix.blocks[mBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (mIndex >= mBlock.length) {\n+                    mBlock = matrix.blocks[++mBlockIndex];\n+                    mIndex = 0;\n+                }\n+                block[i * jWidth + jColumn] = mBlock[mIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector getRowVector(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final double[] outData = new double[columns];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return new RealVectorImpl(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowVector(final int row, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRow(row, ((RealVectorImpl) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setRowVector(row, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector getColumnVector(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final double[] outData = new double[rows];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                outData[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return new RealVectorImpl(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnVector(final int column, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumn(column, ((RealVectorImpl) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setColumnVector(column, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final double[] out = new double[columns];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRow(final int row, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final double[] out = new double[rows];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                out[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumn(final int column, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                block[i * jWidth + jColumn] = array[outIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            return blocks[iBlock * blockColumns + jBlock][k];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] += increment;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] *= factor;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);\n+\n+        // perform transpose block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n+            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n+\n+                // transpose current block\n+                final double[] outBlock = out.blocks[blockIndex];\n+                final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n+                final int      pStart   = iBlock * BLOCK_SIZE;\n+                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      qStart   = jBlock * BLOCK_SIZE;\n+                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    final int lInc = pEnd - pStart;\n+                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n+                        outBlock[k++] = tBlock[l];\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rows;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columns;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != columns) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, columns);\n+        }\n+        final double[] out = new double[rows];\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      qStart = jBlock * BLOCK_SIZE;\n+                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    double sum = 0;\n+                    int q = qStart;\n+                    while (q < qEnd - 3) {\n+                        sum += block[k]     * v[q]     +\n+                               block[k + 1] * v[q + 1] +\n+                               block[k + 2] * v[q + 2] +\n+                               block[k + 3] * v[q + 3];\n+                        k += 4;\n+                        q += 4;\n+                    }\n+                    while (q < qEnd) {\n+                        sum += block[k++] * v[q++];\n+                    }\n+                    out[p] += sum;\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != rows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, rows);\n+        }\n+        final double[] out = new double[columns];\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth  = blockWidth(jBlock);\n+            final int jWidth2 = jWidth  + jWidth;\n+            final int jWidth3 = jWidth2 + jWidth;\n+            final int jWidth4 = jWidth3 + jWidth;\n+            final int qStart = jBlock * BLOCK_SIZE;\n+            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      pStart = iBlock * BLOCK_SIZE;\n+                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                for (int q = qStart; q < qEnd; ++q) {\n+                    int k = q - qStart;\n+                    double sum = 0;\n+                    int p = pStart;\n+                    while (p < pEnd - 3) {\n+                        sum += block[k]           * v[p]     +\n+                               block[k + jWidth]  * v[p + 1] +\n+                               block[k + jWidth2] * v[p + 2] +\n+                               block[k + jWidth3] * v[p + 3];\n+                        k += jWidth4;\n+                        p += 4;\n+                    }\n+                    while (p < pEnd) {\n+                        sum += block[k] * v[p++];\n+                        k += jWidth;\n+                    }\n+                    out[q] += sum;\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final double[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final double[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Get the height of a block.\n+     * @param blockRow row index (in block sense) of the block\n+     * @return height (number of rows) of the block\n+     */\n+    private int blockHeight(final int blockRow) {\n+        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+    /**\n+     * Get the width of a block.\n+     * @param blockColumn column index (in block sense) of the block\n+     * @return width (number of columns) of the block\n+     */\n+    private int blockWidth(final int blockColumn) {\n+        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n             MatrixUtils.checkMultiplicationCompatible(this, m);\n \n             final int outCols = m.getColumnDimension();\n-            final DenseRealMatrix out = new DenseRealMatrix(rowDimension, outCols);\n+            final BlockRealMatrix out = new BlockRealMatrix(rowDimension, outCols);\n             for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n                 iterator.advance();\n                 final double value = iterator.value();\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n             }\n \n             final int columns        = b.getColumnDimension();\n-            final int blockSize      = DenseRealMatrix.BLOCK_SIZE;\n+            final int blockSize      = BlockRealMatrix.BLOCK_SIZE;\n             final int cBlocks        = (columns + blockSize - 1) / blockSize;\n-            final double[][] xBlocks = DenseRealMatrix.createBlocksLayout(n, columns);\n+            final double[][] xBlocks = BlockRealMatrix.createBlocksLayout(n, columns);\n             final double[][] y       = new double[b.getRowDimension()][blockSize];\n             final double[]   alpha   = new double[blockSize];\n \n \n             }\n \n-            return new DenseRealMatrix(n, columns, xBlocks, false);\n+            return new BlockRealMatrix(n, columns, xBlocks, false);\n \n         }\n \n--- a/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.linear.DecompositionSolver;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n             try {\n \n                 // solve the linearized least squares problem\n-                RealMatrix mA = new DenseRealMatrix(a);\n+                RealMatrix mA = new BlockRealMatrix(a);\n                 DecompositionSolver solver = useLU ?\n                         new LUDecompositionImpl(mA).getSolver() :\n                         new QRDecompositionImpl(mA).getSolver();\n--- a/src/java/org/apache/commons/math/stat/correlation/Covariance.java\n+++ b/src/java/org/apache/commons/math/stat/correlation/Covariance.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.stat.descriptive.moment.Variance;\n \n      * rectangular with at least two rows and two columns.\n      */\n     public Covariance(double[][] data, boolean biasCorrected) {\n-        this(new DenseRealMatrix(data), biasCorrected);\n+        this(new BlockRealMatrix(data), biasCorrected);\n     }\n     \n     /**\n     protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) {\n         int dimension = matrix.getColumnDimension();\n         Variance variance = new Variance(biasCorrected);\n-        RealMatrix outMatrix = new DenseRealMatrix(dimension, dimension);\n+        RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n         for (int i = 0; i < dimension; i++) {\n             for (int j = 0; j < i; j++) {\n               double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n      * @return covariance matrix\n      */\n     protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) {\n-        return computeCovarianceMatrix(new DenseRealMatrix(data), biasCorrected);\n+        return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.stat.regression.SimpleRegression;\n \n /**\n      * rectangular with at least two rows and two columns.\n      */\n     public PearsonsCorrelation(double[][] data) {\n-        this(new DenseRealMatrix(data));\n+        this(new BlockRealMatrix(data));\n     }\n     \n     /**\n                 out[i][j] = Math.sqrt((1 - r * r) /(nObs - 2));\n             }\n         }\n-        return new DenseRealMatrix(out);\n+        return new BlockRealMatrix(out);\n     }\n \n     /**\n                 }\n             }\n         }\n-        return new DenseRealMatrix(out);\n+        return new BlockRealMatrix(out);\n     }\n     \n     \n      */\n     public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n         int nVars = matrix.getColumnDimension();\n-        RealMatrix outMatrix = new DenseRealMatrix(nVars, nVars);\n+        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n         for (int i = 0; i < nVars; i++) {\n             for (int j = 0; j < i; j++) {\n               double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n      * @return correlation matrix\n      */\n     public RealMatrix computeCorrelationMatrix(double[][] data) {\n-       return computeCorrelationMatrix(new DenseRealMatrix(data));\n+       return computeCorrelationMatrix(new BlockRealMatrix(data));\n     }\n     \n     /**\n      */\n     public RealMatrix covarianceToCorrelation(RealMatrix covarianceMatrix) {\n         int nVars = covarianceMatrix.getColumnDimension();\n-        RealMatrix outMatrix = new DenseRealMatrix(nVars, nVars);\n+        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n         for (int i = 0; i < nVars; i++) {\n             double sigma = Math.sqrt(covarianceMatrix.getEntry(i, i));\n             outMatrix.setEntry(i, i, 1d);\n--- a/src/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n+++ b/src/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n package org.apache.commons.math.stat.correlation;\n \n import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.ranking.NaturalRanking;\n import org.apache.commons.math.stat.ranking.RankingAlgorithm;\n      * @return correlation matrix\n      */\n     public RealMatrix computeCorrelationMatrix(double[][] data) {\n-       return computeCorrelationMatrix(new DenseRealMatrix(data));\n+       return computeCorrelationMatrix(new BlockRealMatrix(data));\n     }\n     \n     /**\n--- a/src/test/org/apache/commons/math/linear/DenseFieldMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/DenseFieldMatrixTest.java\n import org.apache.commons.math.fraction.FractionField;\n \n /**\n- * Test cases for the {@link DenseFieldMatrix} class.\n+ * Test cases for the {@link BlockFieldMatrix} class.\n  *\n  * @version $Revision$ $Date$\n  */\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite(DenseFieldMatrixTest.class);\n-        suite.setName(\"DenseFieldMatrix<Fraction> Tests\");\n+        suite.setName(\"BlockFieldMatrix<Fraction> Tests\");\n         return suite;\n     }\n     \n     /** test dimensions */\n     public void testDimensions() {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testData2);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n         assertEquals(\"testData row dimension\",3,m.getRowDimension());\n         assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n         assertTrue(\"testData is square\",m.isSquare());\n     /** test copy functions */\n     public void testCopyFunctions() {\n         Random r = new Random(66636328996002l);\n-        DenseFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);\n-        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(m1.getData());\n+        BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData());\n         assertEquals(m1, m2);\n-        DenseFieldMatrix<Fraction> m3 = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> m4 = new DenseFieldMatrix<Fraction>(m3.getData());\n+        BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());\n         assertEquals(m3, m4);\n     }           \n     \n     /** test add */\n     public void testAdd() {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> mInv = new DenseFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n         FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n         Fraction[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n     \n     /** test add failure */\n     public void testAddFail() {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testData2);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n         try {\n             m.add(m2);\n             fail(\"IllegalArgumentException expected\");\n     \n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);\n         TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));        \n         try {\n-            m.subtract(new DenseFieldMatrix<Fraction>(testData2));\n+            m.subtract(new BlockFieldMatrix<Fraction>(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n    \n     /** test multiply */\n      public void testMultiply() {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> mInv = new DenseFieldMatrix<Fraction>(testDataInv);\n-        DenseFieldMatrix<Fraction> identity = new DenseFieldMatrix<Fraction>(id);\n-        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testData2);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n+        BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2);\n         TestUtils.assertEquals(m.multiply(mInv), identity);\n         TestUtils.assertEquals(mInv.multiply(m), identity);\n         TestUtils.assertEquals(m.multiply(identity), m);\n         TestUtils.assertEquals(identity.multiply(mInv), mInv);\n         TestUtils.assertEquals(m2.multiply(identity), m2); \n         try {\n-            m.multiply(new DenseFieldMatrix<Fraction>(bigSingular));\n+            m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n     public void testSeveralBlocks() {\n \n         FieldMatrix<Fraction> m =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);\n         for (int i = 0; i < m.getRowDimension(); ++i) {\n             for (int j = 0; j < m.getColumnDimension(); ++j) {\n                 m.setEntry(i, j, new Fraction(i * 11 + j, 11));\n \n     }\n \n-    //Additional Test for DenseFieldMatrix<Fraction>Test.testMultiply\n+    //Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply\n \n     private Fraction[][] d3 = new Fraction[][] {\n             {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},\n     private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n      \n     public void testMultiply2() { \n-       FieldMatrix<Fraction> m3 = new DenseFieldMatrix<Fraction>(d3);   \n-       FieldMatrix<Fraction> m4 = new DenseFieldMatrix<Fraction>(d4);\n-       FieldMatrix<Fraction> m5 = new DenseFieldMatrix<Fraction>(d5);\n+       FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+       FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n+       FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n        TestUtils.assertEquals(m3.multiply(m4), m5);\n    }  \n         \n     /** test trace */\n     public void testTrace() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(id);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n         assertEquals(new Fraction(3),m.getTrace());\n-        m = new DenseFieldMatrix<Fraction>(testData2);\n+        m = new BlockFieldMatrix<Fraction>(testData2);\n         try {\n             m.getTrace();\n             fail(\"Expecting NonSquareMatrixException\");\n     \n     /** test scalarAdd */\n     public void testScalarAdd() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        TestUtils.assertEquals(new DenseFieldMatrix<Fraction>(testDataPlus2),\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),\n                                m.scalarAdd(new Fraction(2)));\n     }\n                     \n     /** test operate */\n     public void testOperate() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(id);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n         TestUtils.assertEquals(testVector, m.operate(testVector));\n         TestUtils.assertEquals(testVector, m.operate(new FieldVectorImpl<Fraction>(testVector)).getData());\n-        m = new DenseFieldMatrix<Fraction>(bigSingular);\n+        m = new BlockFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n     }\n \n     public void testOperateLarge() {\n-        int p = (11 * DenseFieldMatrix.BLOCK_SIZE) / 10;\n-        int q = (11 * DenseFieldMatrix.BLOCK_SIZE) / 10;\n-        int r =  DenseFieldMatrix.BLOCK_SIZE / 2;\n+        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;\n         Random random = new Random(111007463902334l);\n         FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n         FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n     }\n \n     public void testOperatePremultiplyLarge() {\n-        int p = (11 * DenseFieldMatrix.BLOCK_SIZE) / 10;\n-        int q = (11 * DenseFieldMatrix.BLOCK_SIZE) / 10;\n-        int r =  DenseFieldMatrix.BLOCK_SIZE / 2;\n+        int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10;\n+        int r =  BlockFieldMatrix.BLOCK_SIZE / 2;\n         Random random = new Random(111007463902334l);\n         FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n         FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n \n     /** test issue MATH-209 */\n     public void testMath209() {\n-        FieldMatrix<Fraction> a = new DenseFieldMatrix<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] {\n                 { new Fraction(1), new Fraction(2) },\n                 { new Fraction(3), new Fraction(4) },\n                 { new Fraction(5), new Fraction(6) }\n     \n     /** test transpose */\n     public void testTranspose() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData); \n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); \n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n         FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(mIT, mTI);\n-        m = new DenseFieldMatrix<Fraction>(testData2);\n-        FieldMatrix<Fraction> mt = new DenseFieldMatrix<Fraction>(testData2T);\n+        m = new BlockFieldMatrix<Fraction>(testData2);\n+        FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);\n         TestUtils.assertEquals(mt, m.transpose());\n     }\n     \n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n         TestUtils.assertEquals(m.preMultiply(new FieldVectorImpl<Fraction>(testVector).getData()),\n                                preMultTest);\n-        m = new DenseFieldMatrix<Fraction>(bigSingular);\n+        m = new BlockFieldMatrix<Fraction>(bigSingular);\n         try {\n             m.preMultiply(testVector);\n             fail(\"expecting IllegalArgumentException\");\n     }\n     \n     public void testPremultiply() {\n-        FieldMatrix<Fraction> m3 = new DenseFieldMatrix<Fraction>(d3);   \n-        FieldMatrix<Fraction> m4 = new DenseFieldMatrix<Fraction>(d4);\n-        FieldMatrix<Fraction> m5 = new DenseFieldMatrix<Fraction>(d5);\n+        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n+        FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n         TestUtils.assertEquals(m4.preMultiply(m3), m5);\n         \n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> mInv = new DenseFieldMatrix<Fraction>(testDataInv);\n-        DenseFieldMatrix<Fraction> identity = new DenseFieldMatrix<Fraction>(id);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n+        BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n         TestUtils.assertEquals(m.preMultiply(mInv), identity);\n         TestUtils.assertEquals(mInv.preMultiply(m), identity);\n         TestUtils.assertEquals(m.preMultiply(identity), m);\n         TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n         try {\n-            m.preMultiply(new DenseFieldMatrix<Fraction>(bigSingular));\n+            m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n     }\n     \n     public void testGetVectors() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.getRow(0), testDataRow1);\n         TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n         try {\n     }\n     \n     public void testGetEntry() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         assertEquals(m.getEntry(0,1),new Fraction(2));\n         try {\n             m.getEntry(10, 4);\n                 {new Fraction(1),new Fraction(2),new Fraction(3)},\n                 {new Fraction(2),new Fraction(5),new Fraction(3)}\n         };\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(matrixData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData);\n         // One more with three rows, two columns\n         Fraction[][] matrixData2 = {\n                 {new Fraction(1),new Fraction(2)},\n                 {new Fraction(2),new Fraction(5)},\n                 {new Fraction(1), new Fraction(7)}\n         };\n-        FieldMatrix<Fraction> n = new DenseFieldMatrix<Fraction>(matrixData2);\n+        FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2);\n         // Now multiply m by n\n         FieldMatrix<Fraction> p = m.multiply(n);\n         assertEquals(2, p.getRowDimension());\n                 {new Fraction(-1), new Fraction(7), new Fraction(6)},\n                 {new Fraction(4), new Fraction(-3), new Fraction(-5)}\n         };\n-        FieldMatrix<Fraction> coefficients = new DenseFieldMatrix<Fraction>(coefficientsData);\n+        FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData);\n         Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n         Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n         assertEquals(new Fraction(2).multiply(solution[0]).\n     \n     // test submatrix accessors\n     public void testGetSubMatrix() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n         checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n                                    boolean mustFail) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n-            assertEquals(new DenseFieldMatrix<Fraction>(reference), sub);\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n                                    boolean mustFail) {\n         try {\n             FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n-            assertEquals(new DenseFieldMatrix<Fraction>(reference), sub);\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n     }\n \n     public void testGetSetMatrixLarge() {\n-        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         FieldMatrix<Fraction> sub =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));\n \n         m.setSubMatrix(sub.getData(), 2, 2);\n         for (int i = 0; i < n; ++i) {\n     }\n \n     public void testCopySubMatrix() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n         checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n                              new Fraction[1][1] :\n                              new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n-            assertEquals(new DenseFieldMatrix<Fraction>(reference), new DenseFieldMatrix<Fraction>(sub));\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n                     new Fraction[1][1] :\n                     new Fraction[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n-            assertEquals(new DenseFieldMatrix<Fraction>(reference), new DenseFieldMatrix<Fraction>(sub));\n+            assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n     }\n \n     public void testGetRowMatrix() {\n-        FieldMatrix<Fraction> m     = new DenseFieldMatrix<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mRow0 = new DenseFieldMatrix<Fraction>(subRow0);\n-        FieldMatrix<Fraction> mRow3 = new DenseFieldMatrix<Fraction>(subRow3);\n+        FieldMatrix<Fraction> m     = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0);\n+        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n         assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n         assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n     }\n \n     public void testSetRowMatrix() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mRow3 = new DenseFieldMatrix<Fraction>(subRow3);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3);\n         assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowMatrix(0, mRow3);\n         assertEquals(mRow3, m.getRowMatrix(0));\n     }\n     \n     public void testGetSetRowMatrixLarge() {\n-        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         FieldMatrix<Fraction> sub =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));\n \n         m.setRowMatrix(2, sub);\n         for (int i = 0; i < n; ++i) {\n     }\n     \n     public void testGetColumnMatrix() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mColumn1 = new DenseFieldMatrix<Fraction>(subColumn1);\n-        FieldMatrix<Fraction> mColumn3 = new DenseFieldMatrix<Fraction>(subColumn3);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n         assertEquals(mColumn1, m.getColumnMatrix(1));\n         assertEquals(mColumn3, m.getColumnMatrix(3));\n         try {\n     }\n \n     public void testSetColumnMatrix() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n-        FieldMatrix<Fraction> mColumn3 = new DenseFieldMatrix<Fraction>(subColumn3);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3);\n         assertNotSame(mColumn3, m.getColumnMatrix(1));\n         m.setColumnMatrix(1, mColumn3);\n         assertEquals(mColumn3, m.getColumnMatrix(1));\n     }\n \n     public void testGetSetColumnMatrixLarge() {\n-        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         FieldMatrix<Fraction> sub =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));\n \n         m.setColumnMatrix(2, sub);\n         for (int i = 0; i < n; ++i) {\n     }\n     \n     public void testGetRowVector() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mRow0 = new FieldVectorImpl<Fraction>(subRow0[0]);\n         FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n         assertEquals(mRow0, m.getRowVector(0));\n     }\n \n     public void testSetRowVector() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n         assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n     }\n \n     public void testGetSetRowVectorLarge() {\n-        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         FieldVector<Fraction> sub = new FieldVectorImpl<Fraction>(n, new Fraction(1));\n \n         m.setRowVector(2, sub);\n     }\n     \n     public void testGetColumnVector() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n         assertEquals(mColumn1, m.getColumnVector(1));\n     }\n \n     public void testSetColumnVector() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n         assertNotSame(mColumn3, m.getColumnVector(1));\n         m.setColumnVector(1, mColumn3);\n     }\n \n     public void testGetSetColumnVectorLarge() {\n-        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         FieldVector<Fraction> sub = new FieldVectorImpl<Fraction>(n, new Fraction(1));\n \n         m.setColumnVector(2, sub);\n     }\n \n     public void testGetRow() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkArrays(subRow0[0], m.getRow(0));\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n     }\n \n     public void testSetRow() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n         m.setRow(0, subRow3[0]);\n         checkArrays(subRow3[0], m.getRow(0));\n     }\n \n     public void testGetSetRowLarge() {\n-        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         Fraction[] sub = new Fraction[n];\n         Arrays.fill(sub, new Fraction(1));\n \n     }\n     \n     public void testGetColumn() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn1 = columnToArray(subColumn1);\n         Fraction[] mColumn3 = columnToArray(subColumn3);\n         checkArrays(mColumn1, m.getColumn(1));\n     }\n \n     public void testSetColumn() {\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn3 = columnToArray(subColumn3);\n         assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n         m.setColumn(1, mColumn3);\n     }\n \n     public void testGetSetColumnLarge() {\n-        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n         Fraction[] sub = new Fraction[n];\n         Arrays.fill(sub, new Fraction(1));\n \n     }\n     \n     public void testEqualsAndHashCode() {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        DenseFieldMatrix<Fraction> m1 = (DenseFieldMatrix<Fraction>) m.copy();\n-        DenseFieldMatrix<Fraction> mt = (DenseFieldMatrix<Fraction>) m.transpose();\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();\n+        BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose();\n         assertTrue(m.hashCode() != mt.hashCode());\n         assertEquals(m.hashCode(), m1.hashCode());\n         assertEquals(m, m);\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new DenseFieldMatrix<Fraction>(bigSingular))); \n+        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular))); \n     }\n     \n     public void testToString() {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n-        assertEquals(\"DenseFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n+        assertEquals(\"BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n     }\n     \n     public void testSetSubMatrix() throws Exception {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         m.setSubMatrix(detData2,1,1);\n-        FieldMatrix<Fraction> expected = new DenseFieldMatrix<Fraction>\n+        FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n         assertEquals(expected, m);  \n         \n         m.setSubMatrix(detData2,0,0);\n-        expected = new DenseFieldMatrix<Fraction>\n+        expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n         assertEquals(expected, m);  \n         \n         m.setSubMatrix(testDataPlus2,0,0);      \n-        expected = new DenseFieldMatrix<Fraction>\n+        expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});\n         assertEquals(expected, m);   \n         \n         // javadoc example\n-        DenseFieldMatrix<Fraction> matrix =\n-            new DenseFieldMatrix<Fraction>(new Fraction[][] {\n+        BlockFieldMatrix<Fraction> matrix =\n+            new BlockFieldMatrix<Fraction>(new Fraction[][] {\n                     {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n                     {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)},\n                     {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)}\n                 {new Fraction(5), new Fraction(6)}\n         }, 1, 1);\n         expected =\n-            new DenseFieldMatrix<Fraction>(new Fraction[][] {\n+            new BlockFieldMatrix<Fraction>(new Fraction[][] {\n                     {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)},\n                     {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},\n                     {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}\n         int rows    = 150;\n         int columns = 75;\n \n-        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n-        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n-        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n-        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n     }\n \n     public void testSerial()  {\n-        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n         }\n     }\n \n-    private DenseFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {\n-        DenseFieldMatrix<Fraction> m =\n-            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+    private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {\n+        BlockFieldMatrix<Fraction> m =\n+            new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n         for (int i = 0; i < rows; ++i) {\n             for (int j = 0; j < columns; ++j) {\n                 int p = r.nextInt(20) - 10;\n--- a/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/DenseRealMatrixTest.java\n import org.apache.commons.math.TestUtils;\n \n /**\n- * Test cases for the {@link DenseRealMatrix} class.\n+ * Test cases for the {@link BlockRealMatrix} class.\n  *\n  * @version $Revision$ $Date$\n  */\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite(DenseRealMatrixTest.class);\n-        suite.setName(\"DenseRealMatrix Tests\");\n+        suite.setName(\"BlockRealMatrix Tests\");\n         return suite;\n     }\n     \n     /** test dimensions */\n     public void testDimensions() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n         assertEquals(\"testData row dimension\",3,m.getRowDimension());\n         assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n         assertTrue(\"testData is square\",m.isSquare());\n     /** test copy functions */\n     public void testCopyFunctions() {\n         Random r = new Random(66636328996002l);\n-        DenseRealMatrix m1 = createRandomMatrix(r, 47, 83);\n-        DenseRealMatrix m2 = new DenseRealMatrix(m1.getData());\n+        BlockRealMatrix m1 = createRandomMatrix(r, 47, 83);\n+        BlockRealMatrix m2 = new BlockRealMatrix(m1.getData());\n         assertEquals(m1, m2);\n-        DenseRealMatrix m3 = new DenseRealMatrix(testData);\n-        DenseRealMatrix m4 = new DenseRealMatrix(m3.getData());\n+        BlockRealMatrix m3 = new BlockRealMatrix(testData);\n+        BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());\n         assertEquals(m3, m4);\n     }           \n     \n     /** test add */\n     public void testAdd() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix mInv = new DenseRealMatrix(testDataInv);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n         RealMatrix mPlusMInv = m.add(mInv);\n         double[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n     \n     /** test add failure */\n     public void testAddFail() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n         try {\n             m.add(m2);\n             fail(\"IllegalArgumentException expected\");\n     \n     /** test norm */\n     public void testNorm() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n         assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n         assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n     }\n     \n     /** test Frobenius norm */\n     public void testFrobeniusNorm() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n         assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n         assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n     \n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix m2 = new DenseRealMatrix(testDataInv);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);\n         assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        \n         try {\n-            m.subtract(new DenseRealMatrix(testData2));\n+            m.subtract(new BlockRealMatrix(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n    \n     /** test multiply */\n      public void testMultiply() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix mInv = new DenseRealMatrix(testDataInv);\n-        DenseRealMatrix identity = new DenseRealMatrix(id);\n-        DenseRealMatrix m2 = new DenseRealMatrix(testData2);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        BlockRealMatrix identity = new BlockRealMatrix(id);\n+        BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n         assertClose(m.multiply(mInv), identity, entryTolerance);\n         assertClose(mInv.multiply(m), identity, entryTolerance);\n         assertClose(m.multiply(identity), m, entryTolerance);\n         assertClose(identity.multiply(mInv), mInv, entryTolerance);\n         assertClose(m2.multiply(identity), m2, entryTolerance); \n         try {\n-            m.multiply(new DenseRealMatrix(bigSingular));\n+            m.multiply(new BlockRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n \n     public void testSeveralBlocks() {\n \n-        RealMatrix m = new DenseRealMatrix(35, 71);\n+        RealMatrix m = new BlockRealMatrix(35, 71);\n         for (int i = 0; i < m.getRowDimension(); ++i) {\n             for (int j = 0; j < m.getColumnDimension(); ++j) {\n                 m.setEntry(i, j, i + j / 1024.0);\n     private double[][] d5 = new double[][] {{30},{70}};\n      \n     public void testMultiply2() { \n-       RealMatrix m3 = new DenseRealMatrix(d3);   \n-       RealMatrix m4 = new DenseRealMatrix(d4);\n-       RealMatrix m5 = new DenseRealMatrix(d5);\n+       RealMatrix m3 = new BlockRealMatrix(d3);   \n+       RealMatrix m4 = new BlockRealMatrix(d4);\n+       RealMatrix m5 = new BlockRealMatrix(d5);\n        assertClose(m3.multiply(m4), m5, entryTolerance);\n    }  \n         \n     /** test trace */\n     public void testTrace() {\n-        RealMatrix m = new DenseRealMatrix(id);\n+        RealMatrix m = new BlockRealMatrix(id);\n         assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n-        m = new DenseRealMatrix(testData2);\n+        m = new BlockRealMatrix(testData2);\n         try {\n             m.getTrace();\n             fail(\"Expecting NonSquareMatrixException\");\n     \n     /** test scalarAdd */\n     public void testScalarAdd() {\n-        RealMatrix m = new DenseRealMatrix(testData);\n-        assertClose(new DenseRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n+        RealMatrix m = new BlockRealMatrix(testData);\n+        assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n     }\n                     \n     /** test operate */\n     public void testOperate() {\n-        RealMatrix m = new DenseRealMatrix(id);\n+        RealMatrix m = new BlockRealMatrix(id);\n         assertClose(testVector, m.operate(testVector), entryTolerance);\n         assertClose(testVector, m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);\n-        m = new DenseRealMatrix(bigSingular);\n+        m = new BlockRealMatrix(bigSingular);\n         try {\n             m.operate(testVector);\n             fail(\"Expecting illegalArgumentException\");\n     }\n \n     public void testOperateLarge() {\n-        int p = (7 * DenseRealMatrix.BLOCK_SIZE) / 2;\n-        int q = (5 * DenseRealMatrix.BLOCK_SIZE) / 2;\n-        int r =  3 * DenseRealMatrix.BLOCK_SIZE;\n+        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * BlockRealMatrix.BLOCK_SIZE;\n         Random random = new Random(111007463902334l);\n         RealMatrix m1 = createRandomMatrix(random, p, q);\n         RealMatrix m2 = createRandomMatrix(random, q, r);\n     }\n \n     public void testOperatePremultiplyLarge() {\n-        int p = (7 * DenseRealMatrix.BLOCK_SIZE) / 2;\n-        int q = (5 * DenseRealMatrix.BLOCK_SIZE) / 2;\n-        int r =  3 * DenseRealMatrix.BLOCK_SIZE;\n+        int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2;\n+        int r =  3 * BlockRealMatrix.BLOCK_SIZE;\n         Random random = new Random(111007463902334l);\n         RealMatrix m1 = createRandomMatrix(random, p, q);\n         RealMatrix m2 = createRandomMatrix(random, q, r);\n \n     /** test issue MATH-209 */\n     public void testMath209() {\n-        RealMatrix a = new DenseRealMatrix(new double[][] {\n+        RealMatrix a = new BlockRealMatrix(new double[][] {\n                 { 1, 2 }, { 3, 4 }, { 5, 6 }\n         });\n         double[] b = a.operate(new double[] { 1, 1 });\n     \n     /** test transpose */\n     public void testTranspose() {\n-        RealMatrix m = new DenseRealMatrix(testData); \n+        RealMatrix m = new BlockRealMatrix(testData); \n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n         RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n         assertClose(mIT, mTI, normTolerance);\n-        m = new DenseRealMatrix(testData2);\n-        RealMatrix mt = new DenseRealMatrix(testData2T);\n+        m = new BlockRealMatrix(testData2);\n+        RealMatrix mt = new BlockRealMatrix(testData2T);\n         assertClose(mt, m.transpose(), normTolerance);\n     }\n     \n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n-        RealMatrix m = new DenseRealMatrix(testData);\n+        RealMatrix m = new BlockRealMatrix(testData);\n         assertClose(m.preMultiply(testVector), preMultTest, normTolerance);\n         assertClose(m.preMultiply(new RealVectorImpl(testVector).getData()),\n                     preMultTest, normTolerance);\n-        m = new DenseRealMatrix(bigSingular);\n+        m = new BlockRealMatrix(bigSingular);\n         try {\n             m.preMultiply(testVector);\n             fail(\"expecting IllegalArgumentException\");\n     }\n     \n     public void testPremultiply() {\n-        RealMatrix m3 = new DenseRealMatrix(d3);   \n-        RealMatrix m4 = new DenseRealMatrix(d4);\n-        RealMatrix m5 = new DenseRealMatrix(d5);\n+        RealMatrix m3 = new BlockRealMatrix(d3);   \n+        RealMatrix m4 = new BlockRealMatrix(d4);\n+        RealMatrix m5 = new BlockRealMatrix(d5);\n         assertClose(m4.preMultiply(m3), m5, entryTolerance);\n         \n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix mInv = new DenseRealMatrix(testDataInv);\n-        DenseRealMatrix identity = new DenseRealMatrix(id);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n+        BlockRealMatrix identity = new BlockRealMatrix(id);\n         assertClose(m.preMultiply(mInv), identity, entryTolerance);\n         assertClose(mInv.preMultiply(m), identity, entryTolerance);\n         assertClose(m.preMultiply(identity), m, entryTolerance);\n         assertClose(identity.preMultiply(mInv), mInv, entryTolerance);\n         try {\n-            m.preMultiply(new DenseRealMatrix(bigSingular));\n+            m.preMultiply(new BlockRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n     }\n     \n     public void testGetVectors() {\n-        RealMatrix m = new DenseRealMatrix(testData);\n+        RealMatrix m = new BlockRealMatrix(testData);\n         assertClose(m.getRow(0), testDataRow1, entryTolerance);\n         assertClose(m.getColumn(2), testDataCol3, entryTolerance);\n         try {\n     }\n     \n     public void testGetEntry() {\n-        RealMatrix m = new DenseRealMatrix(testData);\n+        RealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n         try {\n             m.getEntry(10, 4);\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};\n-        RealMatrix m = new DenseRealMatrix(matrixData);\n+        RealMatrix m = new BlockRealMatrix(matrixData);\n         // One more with three rows, two columns\n         double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n-        RealMatrix n = new DenseRealMatrix(matrixData2);\n+        RealMatrix n = new BlockRealMatrix(matrixData2);\n         // Now multiply m by n\n         RealMatrix p = m.multiply(n);\n         assertEquals(2, p.getRowDimension());\n         \n         // Solve example\n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n-        RealMatrix coefficients = new DenseRealMatrix(coefficientsData);\n+        RealMatrix coefficients = new BlockRealMatrix(coefficientsData);\n         double[] constants = {1, -2, 1};\n         double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n     \n     // test submatrix accessors\n     public void testGetSubMatrix() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n         checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n                                    boolean mustFail) {\n         try {\n             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n-            assertEquals(new DenseRealMatrix(reference), sub);\n+            assertEquals(new BlockRealMatrix(reference), sub);\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n                                    boolean mustFail) {\n         try {\n             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n-            assertEquals(new DenseRealMatrix(reference), sub);\n+            assertEquals(new BlockRealMatrix(reference), sub);\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n     }\n \n     public void testGetSetMatrixLarge() {\n-        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n-        RealMatrix m = new DenseRealMatrix(n, n);\n-        RealMatrix sub = new DenseRealMatrix(n - 4, n - 4).scalarAdd(1);\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1);\n \n         m.setSubMatrix(sub.getData(), 2, 2);\n         for (int i = 0; i < n; ++i) {\n     }\n \n     public void testCopySubMatrix() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n         checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n                              new double[1][1] :\n                              new double[reference.length][reference[0].length];\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n-            assertEquals(new DenseRealMatrix(reference), new DenseRealMatrix(sub));\n+            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n                     new double[1][1] :\n                     new double[reference.length][reference[0].length];\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n-            assertEquals(new DenseRealMatrix(reference), new DenseRealMatrix(sub));\n+            assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             if (mustFail) {\n                 fail(\"Expecting MatrixIndexException\");\n             }\n     }\n \n     public void testGetRowMatrix() {\n-        RealMatrix m     = new DenseRealMatrix(subTestData);\n-        RealMatrix mRow0 = new DenseRealMatrix(subRow0);\n-        RealMatrix mRow3 = new DenseRealMatrix(subRow3);\n+        RealMatrix m     = new BlockRealMatrix(subTestData);\n+        RealMatrix mRow0 = new BlockRealMatrix(subRow0);\n+        RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n         assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n         assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n     }\n \n     public void testSetRowMatrix() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n-        RealMatrix mRow3 = new DenseRealMatrix(subRow3);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mRow3 = new BlockRealMatrix(subRow3);\n         assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowMatrix(0, mRow3);\n         assertEquals(mRow3, m.getRowMatrix(0));\n     }\n     \n     public void testGetSetRowMatrixLarge() {\n-        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n-        RealMatrix m = new DenseRealMatrix(n, n);\n-        RealMatrix sub = new DenseRealMatrix(1, n).scalarAdd(1);\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1);\n \n         m.setRowMatrix(2, sub);\n         for (int i = 0; i < n; ++i) {\n     }\n     \n     public void testGetColumnMatrix() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n-        RealMatrix mColumn1 = new DenseRealMatrix(subColumn1);\n-        RealMatrix mColumn3 = new DenseRealMatrix(subColumn3);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);\n+        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n         assertEquals(mColumn1, m.getColumnMatrix(1));\n         assertEquals(mColumn3, m.getColumnMatrix(3));\n         try {\n     }\n \n     public void testSetColumnMatrix() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n-        RealMatrix mColumn3 = new DenseRealMatrix(subColumn3);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n+        RealMatrix mColumn3 = new BlockRealMatrix(subColumn3);\n         assertNotSame(mColumn3, m.getColumnMatrix(1));\n         m.setColumnMatrix(1, mColumn3);\n         assertEquals(mColumn3, m.getColumnMatrix(1));\n     }\n \n     public void testGetSetColumnMatrixLarge() {\n-        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n-        RealMatrix m = new DenseRealMatrix(n, n);\n-        RealMatrix sub = new DenseRealMatrix(n, 1).scalarAdd(1);\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n+        RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1);\n \n         m.setColumnMatrix(2, sub);\n         for (int i = 0; i < n; ++i) {\n     }\n     \n     public void testGetRowVector() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n         RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n         assertEquals(mRow0, m.getRowVector(0));\n     }\n \n     public void testSetRowVector() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n         assertNotSame(mRow3, m.getRowMatrix(0));\n         m.setRowVector(0, mRow3);\n     }\n \n     public void testGetSetRowVectorLarge() {\n-        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n-        RealMatrix m = new DenseRealMatrix(n, n);\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n         RealVector sub = new RealVectorImpl(n, 1.0);\n \n         m.setRowVector(2, sub);\n     }\n     \n     public void testGetColumnVector() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mColumn1 = columnToVector(subColumn1);\n         RealVector mColumn3 = columnToVector(subColumn3);\n         assertEquals(mColumn1, m.getColumnVector(1));\n     }\n \n     public void testSetColumnVector() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mColumn3 = columnToVector(subColumn3);\n         assertNotSame(mColumn3, m.getColumnVector(1));\n         m.setColumnVector(1, mColumn3);\n     }\n \n     public void testGetSetColumnVectorLarge() {\n-        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n-        RealMatrix m = new DenseRealMatrix(n, n);\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n         RealVector sub = new RealVectorImpl(n, 1.0);\n \n         m.setColumnVector(2, sub);\n     }\n \n     public void testGetRow() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         checkArrays(subRow0[0], m.getRow(0));\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n     }\n \n     public void testSetRow() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n         m.setRow(0, subRow3[0]);\n         checkArrays(subRow3[0], m.getRow(0));\n     }\n \n     public void testGetSetRowLarge() {\n-        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n-        RealMatrix m = new DenseRealMatrix(n, n);\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n         double[] sub = new double[n];\n         Arrays.fill(sub, 1.0);\n \n     }\n     \n     public void testGetColumn() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         double[] mColumn1 = columnToArray(subColumn1);\n         double[] mColumn3 = columnToArray(subColumn3);\n         checkArrays(mColumn1, m.getColumn(1));\n     }\n \n     public void testSetColumn() {\n-        RealMatrix m = new DenseRealMatrix(subTestData);\n+        RealMatrix m = new BlockRealMatrix(subTestData);\n         double[] mColumn3 = columnToArray(subColumn3);\n         assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n         m.setColumn(1, mColumn3);\n     }\n \n     public void testGetSetColumnLarge() {\n-        int n = 3 * DenseRealMatrix.BLOCK_SIZE;\n-        RealMatrix m = new DenseRealMatrix(n, n);\n+        int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n+        RealMatrix m = new BlockRealMatrix(n, n);\n         double[] sub = new double[n];\n         Arrays.fill(sub, 1.0);\n \n     }\n     \n     public void testEqualsAndHashCode() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        DenseRealMatrix m1 = (DenseRealMatrix) m.copy();\n-        DenseRealMatrix mt = (DenseRealMatrix) m.transpose();\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        BlockRealMatrix m1 = (BlockRealMatrix) m.copy();\n+        BlockRealMatrix mt = (BlockRealMatrix) m.transpose();\n         assertTrue(m.hashCode() != mt.hashCode());\n         assertEquals(m.hashCode(), m1.hashCode());\n         assertEquals(m, m);\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new DenseRealMatrix(bigSingular))); \n+        assertFalse(m.equals(new BlockRealMatrix(bigSingular))); \n     }\n     \n     public void testToString() {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n-        assertEquals(\"DenseRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n+        assertEquals(\"BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n                 m.toString());\n     }\n     \n     public void testSetSubMatrix() throws Exception {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n         m.setSubMatrix(detData2,1,1);\n-        RealMatrix expected = new DenseRealMatrix\n+        RealMatrix expected = new BlockRealMatrix\n             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n         assertEquals(expected, m);  \n         \n         m.setSubMatrix(detData2,0,0);\n-        expected = new DenseRealMatrix\n+        expected = new BlockRealMatrix\n             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n         assertEquals(expected, m);  \n         \n         m.setSubMatrix(testDataPlus2,0,0);      \n-        expected = new DenseRealMatrix\n+        expected = new BlockRealMatrix\n             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n         assertEquals(expected, m);   \n         \n         // javadoc example\n-        DenseRealMatrix matrix = new DenseRealMatrix\n+        BlockRealMatrix matrix = new BlockRealMatrix\n             (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n         matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n-        expected = new DenseRealMatrix\n+        expected = new BlockRealMatrix\n             (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n         assertEquals(expected, matrix);   \n \n         int rows    = 150;\n         int columns = 75;\n \n-        RealMatrix m = new DenseRealMatrix(rows, columns);\n+        RealMatrix m = new BlockRealMatrix(rows, columns);\n         m.walkInRowOrder(new SetVisitor());\n         GetVisitor getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseRealMatrix(rows, columns);\n+        m = new BlockRealMatrix(rows, columns);\n         m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n-        m = new DenseRealMatrix(rows, columns);\n+        m = new BlockRealMatrix(rows, columns);\n         m.walkInColumnOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseRealMatrix(rows, columns);\n+        m = new BlockRealMatrix(rows, columns);\n         m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n-        m = new DenseRealMatrix(rows, columns);\n+        m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseRealMatrix(rows, columns);\n+        m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n-        m = new DenseRealMatrix(rows, columns);\n+        m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor());\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor);\n         assertEquals(rows * columns, getVisitor.getCount());\n \n-        m = new DenseRealMatrix(rows, columns);\n+        m = new BlockRealMatrix(rows, columns);\n         m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n         getVisitor = new GetVisitor();\n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n     }\n     \n     public void testSerial()  {\n-        DenseRealMatrix m = new DenseRealMatrix(testData);\n+        BlockRealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n         }\n     }\n \n-    private DenseRealMatrix createRandomMatrix(Random r, int rows, int columns) {\n-        DenseRealMatrix m = new DenseRealMatrix(rows, columns);\n+    private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) {\n+        BlockRealMatrix m = new BlockRealMatrix(rows, columns);\n         for (int i = 0; i < rows; ++i) {\n             for (int j = 0; j < columns; ++j) {\n                 m.setEntry(i, j, 200 * r.nextDouble() - 100);\n--- a/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n     }\n     \n     public void testCreateRealMatrix() {\n-        assertEquals(new DenseRealMatrix(testData), \n+        assertEquals(new BlockRealMatrix(testData), \n                 MatrixUtils.createRealMatrix(testData));\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n         \n     public void testCreateRowRealMatrix() {\n         assertEquals(MatrixUtils.createRowRealMatrix(row),\n-                     new DenseRealMatrix(rowMatrix));\n+                     new BlockRealMatrix(rowMatrix));\n         try {\n             MatrixUtils.createRowRealMatrix(new double[] {});  // empty\n             fail(\"Expecting IllegalArgumentException\");\n \n     public void testCreateColumnRealMatrix() {\n         assertEquals(MatrixUtils.createColumnRealMatrix(col),\n-                     new DenseRealMatrix(colMatrix));\n+                     new BlockRealMatrix(colMatrix));\n         try {\n             MatrixUtils.createColumnRealMatrix(new double[] {});  // empty\n             fail(\"Expecting IllegalArgumentException\");\n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n import org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.MatrixVisitorException;\n import org.apache.commons.math.linear.QRDecomposition;\n         checkDimension(MatrixUtils.createRealMatrix(testData3x4));\n \n         Random r = new Random(643895747384642l);\n-        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n-        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         checkDimension(createTestMatrix(r, p, q));\n         checkDimension(createTestMatrix(r, q, p));\n \n         checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));\n \n         Random r = new Random(643895747384642l);\n-        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n-        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         checkAEqualQR(createTestMatrix(r, p, q));\n \n         checkAEqualQR(createTestMatrix(r, q, p));\n         checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));\n \n         Random r = new Random(643895747384642l);\n-        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n-        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         checkQOrthogonal(createTestMatrix(r, p, q));\n \n         checkQOrthogonal(createTestMatrix(r, q, p));\n         checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n \n         Random r = new Random(643895747384642l);\n-        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n-        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         matrix = createTestMatrix(r, p, q);\n         checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n \n         checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n \n         Random r = new Random(643895747384642l);\n-        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n-        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         matrix = createTestMatrix(r, p, q);\n         checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n \n--- a/src/test/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRSolverTest.java\n \n import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.MatrixVisitorException;\n \n     public void testOverdetermined() {\n         final Random r    = new Random(5559252868205245l);\n-        int          p    = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n-        int          q    = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         RealMatrix   a    = createTestMatrix(r, p, q);\n-        RealMatrix   xRef = createTestMatrix(r, q, DenseRealMatrix.BLOCK_SIZE + 3);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n \n         // build a perturbed system: A.X + noise = B\n         RealMatrix b = a.multiply(xRef);\n \n     public void testUnderdetermined() {\n         final Random r    = new Random(42185006424567123l);\n-        int          p    = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n-        int          q    = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n         RealMatrix   a    = createTestMatrix(r, p, q);\n-        RealMatrix   xRef = createTestMatrix(r, q, DenseRealMatrix.BLOCK_SIZE + 3);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n         RealMatrix   b    = a.multiply(xRef);\n         RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);\n \n--- a/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealMatrixTest.java\n         OpenMapRealMatrix m2 = createSparseMatrix(testData2);\n         assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n                 entryTolerance);\n-        assertClose(\"inverse multiply\", m.multiply(new DenseRealMatrix(testDataInv)), identity,\n+        assertClose(\"inverse multiply\", m.multiply(new BlockRealMatrix(testDataInv)), identity,\n                     entryTolerance);\n         assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n                 entryTolerance);\n--- a/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n         final RealMatrix factors;\n         final double[] target;\n         public LinearProblem(double[][] factors, double[] target) {\n-            this.factors = new DenseRealMatrix(factors);\n+            this.factors = new BlockRealMatrix(factors);\n             this.target  = target;\n         }\n \n--- a/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n         final RealMatrix factors;\n         final double[] target;\n         public LinearProblem(double[][] factors, double[] target) {\n-            this.factors = new DenseRealMatrix(factors);\n+            this.factors = new BlockRealMatrix(factors);\n             this.target  = target;\n         }\n \n--- a/src/test/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.OptimizationException;\n         final RealMatrix factors;\n         final double[] target;\n         public LinearProblem(double[][] factors, double[] target) {\n-            this.factors = new DenseRealMatrix(factors);\n+            this.factors = new BlockRealMatrix(factors);\n             this.target  = target;\n         }\n \n--- a/src/test/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n+++ b/src/test/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n \n import junit.framework.TestCase;\n \n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n-        RealMatrix matrix = new DenseRealMatrix(new double[][] {{0},{1}});\n+        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});\n         try {\n             new PearsonsCorrelation(matrix);\n             fail(\"Expecting IllegalArgumentException\");\n             System.arraycopy(data, ptr, matrixData[i], 0, nCols);\n             ptr += nCols;\n         }\n-        return new DenseRealMatrix(matrixData); \n+        return new BlockRealMatrix(matrixData); \n     }\n     \n     protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) {\n         int ptr = 0;\n-        RealMatrix result = new DenseRealMatrix(dimension, dimension);\n+        RealMatrix result = new BlockRealMatrix(dimension, dimension);\n         for (int i = 1; i < dimension; i++) {\n             for (int j = 0; j < i; j++) {\n                 result.setEntry(i, j, data[ptr]);\n--- a/src/test/org/apache/commons/math/stat/correlation/SpearmansRankCorrelationTest.java\n+++ b/src/test/org/apache/commons/math/stat/correlation/SpearmansRankCorrelationTest.java\n package org.apache.commons.math.stat.correlation;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n \n /**\n         } catch (IllegalArgumentException ex) {\n             // Expected\n         }\n-        RealMatrix matrix = new DenseRealMatrix(new double[][] {{0},{1}});\n+        RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}});\n         try {\n             new SpearmansCorrelation(matrix);\n             fail(\"Expecting IllegalArgumentException\");", "timestamp": 1244707524, "metainfo": ""}