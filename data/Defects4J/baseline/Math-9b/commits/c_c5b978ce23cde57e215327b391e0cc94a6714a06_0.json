{"sha": "c5b978ce23cde57e215327b391e0cc94a6714a06", "log": "From Phil Steitz patch submission for Issue #20175  The attached patch includes the following improvements to Univariate and UnivariateImpl:  * Improved efficiency of min, max and product maintenance when windowSize is   limited by incorporating suggestion posted to commons-dev by Brend Worden   (added author credit).  Thanks, Brent!  * Added javadoc specifying NaN contracts for all statistics, definitions for   geometric and arithmetic means.  * Made some slight modifications to UnivariateImpl to make it consistent with   NaN contracts  * All interface documentation moved to Univariate. The interface specification   includes the NaN semantics and a first attempt at clealy defining exactly   what \"rolling\" means and how this effects what statistics are defined when.  * Added test cases to verify that min, max, product are correctly maintained   when \"rolling\" and to verify that NaN contracts are satisfied.   ", "commit": "\n--- a/src/java/org/apache/commons/math/Univariate.java\n+++ b/src/java/org/apache/commons/math/Univariate.java\n /**\n  *\n  * Accumulates univariate statistics for values fed in \n- * through the addValue() method.   This interface defines the LCD interface\n- * which all Univariate implementations must implement.\n+ * through the addValue() method. This interface defines the LCD interface\n+ * which all Univariate implementations must implement. <p>\n+ * A \"rolling\" capability is supported by all implementations with the following\n+ * contract: <p>\n+ * <i> Setting the windowSize property limits the domain of all statistics to\n+ * the last <code>windowSize</code> values added.</i><p>\n+ * We use the term <i>available values</i> throughout the API documentation\n+ * to refer to these values when the windowSize is set. For example, if the\n+ * windowSize is set to 3 and the values {1,2,3,4,5} have been added <strong>\n+ * in that order</strong> then the <i>available values</i> are {3,4,5} and all\n+ * reported statistics will be based on these values<p>\n+ * The default windowSize is \"infinite\" -- i.e., all values added are included\n+ * in all computations.\n  *\n  * @author Phil Steitz\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  * @author Mark Diggory\n- * @version $Revision: 1.5 $ $Date: 2003/05/21 17:59:19 $\n+ * @version $Revision: 1.6 $ $Date: 2003/05/23 17:33:18 $\n  * \n */\n public interface Univariate {\n      * Adds the value to the set of numbers\n      * @param v the value to be added \n      */\n-    public abstract void addValue(double v);\n+    abstract void addValue(double v);\n \n     /** \n-     * Returns the mean of the values that have been added\n+     * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n+     * arithmetic mean </a> of the available values <p>\n+     *\n+     * Will return Double.NaN if no values have been added when\n+     * this method is invoked.\n+     *\n      * @return mean value\n      */\n-    public abstract double getMean();\n+    abstract double getMean();\n \n     /** \n-     * Returns the geometric mean of the values that have been added\n+     * Returns the <a href=http://www.xycoon.com/geometric_mean.htm>\n+     * geometric mean </a> of the available values <p>\n+     *\n+     * Will return Double.NaN if no values have been added or the product\n+     * of the available values is less than or equal to 0.\n+     *\n      * @return mean value\n      */\n-    public abstract double getGeometricMean();\n+    abstract double getGeometricMean();\n \n     /** \n-     * Returns the product of all values that have been added\n+     * Returns the product of the available values <p>\n+     * Will return Double.NaN if no values have been added.\n+     *\n      * @return product of all values\n      */\n-    public abstract double getProduct();\n+    abstract double getProduct();\n \n     /** \n-     * Returns the variance of the values that have been added\n-     * @return variance value\n+     * Returns the variance of the available values. <p>\n+     * Double.NaN is returned for an empty set of values and 0.0 is \n+     * returned for a single value set. \n+     *\n+     * @return The variance of a set of values.  \n      */\n-    public abstract double getVariance();\n+    abstract double getVariance();\n \n     /** \n-     * Returns the standard deviation of the values that have been added\n+     * Returns the variance of the available values. <p>\n+     * Double.NaN is returned for an empty set of values and 0.0 is \n+     * returned for a single value set. \n+     *\n      * @return standard deviation value\n      */\n-    public abstract double getStandardDeviation();\n+    abstract double getStandardDeviation();\n \n-    /** Getter for property max.\n+    /** \n+     * Returns the maximum of the available values <p>\n+     * Double.NaN is returned in no values have been added\n+     *\n      * @return Value of property max.\n      */\n-    public abstract double getMax();\n+    abstract double getMax();\n \n-    /** Getter for property min.\n+     /** \n+     * Returns the minimum of the available values <p>\n+     * Double.NaN is returned in no values have been added\n+     *\n      * @return Value of property min.\n      */\n-    public abstract double getMin();\n+    abstract double getMin();\n \n-    /** Getter for property n.\n-     * @return Value of property n.\n+    /** \n+     * Returns the number of available values\n+     * @return the number of available values\n      */\n-    public abstract int getN();\n+    abstract int getN();\n \n-    /** Getter for property sum.\n-     * @return Value of property sum.\n+    /**\n+     * Returns the sum of the available values <p>\n+     * Returns 0 if no values have been added.\n+     *\n+     * @return the sum of the available values\n      */\n-    public abstract double getSum();\n+    abstract double getSum();\n \n-    /** Getter for property sumsq.\n-     * @return Value of property sumsq.\n+    /**\n+     * Returns the sum of the squares of the available values.\n+     * Returns 0 if no values have been added.\n+     *\n+     * @return the sum of the squares of the available values.\n      */\n-    public abstract double getSumsq();\n+    abstract double getSumsq();\n \n-    /** Resets all sums to 0, resets min and max */\n-    public abstract void clear();\n+    /** Resets all statistics */\n+    abstract void clear();\n \n     /**\n      * This constant signals that a Univariate implementation\n      * elements.  In other words, if getWindow returns this\n      * constant, there is, in effect, no \"window\".\n      */\n-    public static final int INIFINTE_WINDOW = -1;\n+    static final int INIFINTE_WINDOW = -1;\n \n     /**\n      * Univariate has the ability to return only measures for the\n      * last N elements added to the set of values.  This function returns\n      */\n-    public abstract int getWindowSize();\n+    abstract int getWindowSize();\n \n     /**\n      * Sets the window.  windowSize controls the number of value\n      * For example, a window value of 10 means that getMean()\n      * will return the mean of the last 10 values added.\n      */\n-    public abstract void setWindowSize(int windowSize);\n+    abstract void setWindowSize(int windowSize);\n }\n--- a/src/java/org/apache/commons/math/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/UnivariateImpl.java\n  *\n  * Accumulates univariate statistics for values fed in \n  * through the addValue() method.  Does not store raw data values.\n- * All data (including n) are represented internally as doubles.\n+ * All data are represented internally as doubles.\n  * Integers, floats and longs can be added, but will be converted\n  * to doubles by addValue().  \n  *\n  * @author Phil Steitz\n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  * @author Mark Diggory\n- * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @version $Revision: 1.6 $ $Date: 2003/05/21 17:59:19 $\n+ * @author Brent Worden\n+ * @version $Revision: 1.7 $ $Date: 2003/05/23 17:33:18 $\n  * \n */\n public class UnivariateImpl implements Univariate, Serializable {\n     /** max of values that have been added */\n     private double max = Double.MIN_VALUE;\n \n-    /** produce of values that have been added */\n+    /** product of values that have been added */\n     private double product = Double.NaN;\n \n     /** Creates new univariate */\n         doubleArray = new FixedDoubleArray( window );\n     }\n \n-    /**\n-     * Adds the value, updating running sums.\n-     * @param v the value to be added \n-     */\n+     \n     public void addValue(double v) {\n \n         insertValue(v);\n     }\n \n-    /** \n-     * Returns the mean of the values that have been added\n-     * @return mean value\n-     */\n+    \n     public double getMean() {\n-        // FIXME: throw something meaningful if n = 0\n-        return (sum / (double) n );\n+        if (n == 0) {\n+            return Double.NaN;\n+        } else {\n+            return (sum / (double) n );\n+        }\n      }\n \n-    /** \n-     * Returns the geometric mean of the values that have been added\n-     * @return geometric mean value\n-     */\n+     \n     public double getGeometricMean() {\n-        return Math.pow(product,( 1.0/n ) );\n-    }\n-\n-    /** \n-     * Returns the product of all values add to this Univariate\n-     * @return product value\n-     */\n+        if ((product <= 0.0) || (n == 0)) {\n+            return Double.NaN; \n+        } else {\n+            return Math.pow(product,( 1.0/(double)n ) );\n+        }\n+    }\n+\n+    \n     public double getProduct() {\n         return product;\n     }\n \n-    /** \n-     * Returns the variance of the values that have been added. \n-     * @return The variance of a set of values.  Double.NaN is returned for\n-     *         an empty set of values and 0.0 is returned for a single value set.\n-     */\n+     \n     public double getVariance() {\n         double variance = Double.NaN;\n \n         return variance;\n     }\n \n-    /** \n-     * Returns the standard deviation of the values that have been added\n-     * @return The standard deviation of a set of values.  Double.NaN is \n-     *         returned for an empty set of values and 0.0 is returned for \n-     *         a single value set.\n-     */\n+    \n     public double getStandardDeviation() {\n-        return (new Double(Math.sqrt\n-            ((new Double(getVariance())).doubleValue()))).doubleValue();\n-    }\n-\n-    /**\n-     * Adds the value, updating running sums.\n-     * @param v the value to be added \n-     */\n+        double variance = getVariance();\n+        if ((variance == 0.0) || (variance == Double.NaN)) {\n+            return variance;\n+        } else {\n+            return Math.sqrt(variance);\n+        }\n+    }\n+   \n     private void insertValue(double v) {\n \n         // The default value of product is NaN, if you\n                 sum -= discarded;\n                 sumsq -= discarded * discarded;\n \n-                // Include the influence of the new\n-                // TODO: The next two lines seems rather expensive, but\n-                // I don't see many alternatives.\t\t\t \n-                min = doubleArray.getMin();\n-                max = doubleArray.getMax();\n+                if(discarded == min) {\n+                    min = doubleArray.getMin();\n+                } else {\n+                    if(discarded == max){\n+                    max = doubleArray.getMax();\n+                    }\n+                } \n+                \n                 sum += v;\n                 sumsq += v*v;\n \n-                // Note that the product CANNOT be discarded\n-                // properly because one cannot discount the effect\n-                // of a zero value.  For this reason, the product\n-                // of the altered array must be calculated from the\n-                // current array elements.  Product must be recalculated\n-                // everytime the array is \"rolled\"\n-                product = 1.0;\n-                double[] elements = doubleArray.getElements();\n-                for( int i = 0; i < elements.length; i++ ) {\n+                if(product != 0.0){\n+                    // can safely remove discarded value\n+                    product *= v/discarded;\n+                } else if(discarded == 0.0){\n+                    // need to recompute product\n+                    product = 1.0;\n+                    double[] elements = doubleArray.getElements();\n+                    for( int i = 0; i < elements.length; i++ ) {\n                     product *= elements[i];\n-                }\n+                    }\n+                } // else product = 0 and will still be 0 after discard\n \n             } else {\n                 doubleArray.addElement( v );        \t\n      * @return Value of property max.\n      */\n     public double getMax() {\n-        return max;\n-    }\n-\n-    /** Setter for property max.\n-     * @param max New value of property max.\n-     */\n-    public void setMax(double max) {\n-        this.max = max;\n+        if (n == 0) { \n+            return Double.NaN;\n+        } else {\n+            return max;\n+        }\n     }\n \n     /** Getter for property min.\n      * @return Value of property min.\n      */\n     public double getMin() {\n-        return min;\n+        if (n == 0) { \n+            return Double.NaN;\n+        } else {\n+            return min;\n+        }\n     }\n \n     /** Getter for property n.\n         this.n = 0;\n         this.min = Double.MAX_VALUE;\n         this.max = Double.MIN_VALUE;\n+        this.product = Double.NaN;\n     }\n \n     /* (non-Javadoc)\n--- a/src/test/org/apache/commons/math/UnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/UnivariateImplTest.java\n /**\n  * Test cases for the {@link Univariate} class.\n  *\n- * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n- * @version $Revision: 1.2 $ $Date: 2003/05/21 17:59:20 $\n+ * @author Phil Steitz\n+ * @author Tim Obrien\n+ * @version $Revision: 1.3 $ $Date: 2003/05/23 17:33:18 $\n  */\n \n public final class UnivariateImplTest extends TestCase {\n     \n     public void testN0andN1Conditions() throws Exception {\n     \tUnivariateImpl u = new UnivariateImpl();\n-    \t    \t\n-\t\tassertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n-\t\tassertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n-\t\tassertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n-\n-\t\tu.addValue(one);\n-\n-\t\tassertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n-\t\tassertTrue( \"Mean of n = 1 set should be zero\", u.getStandardDeviation() == 0);\n-\t\tassertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);\t\n+        assertTrue(\"Mean of n = 0 set should be NaN\", \n+            Double.isNaN( u.getMean() ) );\n+\tassertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+            Double.isNaN( u.getStandardDeviation() ) );\n+\tassertTrue(\"Variance of n = 0 set should be NaN\", \n+            Double.isNaN(u.getVariance() ) );\n+\t\n+        u.addValue(one);\n+\n+\tassertTrue( \"Mean of n = 1 set should be value of single item n1\", \n+            u.getMean() == one);\n+\tassertTrue( \"Mean of n = 1 set should be zero\", \n+            u.getStandardDeviation() == 0);\n+\tassertTrue( \"Variance of n = 1 set should be zero\",\n+            u.getVariance() == 0);\t\n     }\n \n     public void testProductAndGeometricMean() throws Exception {\n         u.addValue( 3.0 );\n         u.addValue( 4.0 );\n \n-        assertEquals( \"Product not expected\", 24.0, u.getProduct(), Double.MIN_VALUE );\n-        assertEquals( \"Geometric mean not expected\", 2.213364, u.getGeometricMean(), 0.00001 );\n+        assertEquals( \"Product not expected\", 24.0, u.getProduct(),\n+            Double.MIN_VALUE );\n+        assertEquals( \"Geometric mean not expected\", 2.213364, \n+            u.getGeometricMean(), 0.00001 );\n \n         // Now test rolling - UnivariateImpl should discount the contribution\n         // of a discarded element\n         }\n         // Values should be (2,3,4,5,6,7,8,9,10,11)\n         \n-        assertEquals( \"Product not expected\", 39916800.0, u.getProduct(), 0.00001 );\n-        assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n-\n-\n-    }\n+        assertEquals( \"Product not expected\", 39916800.0, \n+            u.getProduct(), 0.00001 );\n+        assertEquals( \"Geometric mean not expected\", 5.755931, \n+            u.getGeometricMean(), 0.00001 );\n+    }\n+    \n+    public void testRollingMinMax() {\n+        UnivariateImpl u = new UnivariateImpl(3);\n+        u.addValue( 1.0 );\n+        u.addValue( 5.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 ); // discarding min\n+        assertEquals( \"min not expected\", 3.0, \n+            u.getMin(), Double.MIN_VALUE);\n+        u.addValue(1.0);  // discarding max\n+        assertEquals( \"max not expected\", 4.0, \n+            u.getMax(), Double.MIN_VALUE);\n+    }\n+    \n+    public void testNaNContracts() {\n+        UnivariateImpl u = new UnivariateImpl();\n+        double nan = Double.NaN;\n+        assertTrue(\"mean not NaN\",Double.isNaN(u.getMean())); \n+        assertTrue(\"min not NaN\",Double.isNaN(u.getMin())); \n+        assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation())); \n+        assertTrue(\"var not NaN\",Double.isNaN(u.getVariance())); \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        \n+        u.addValue(1.0);\n+        \n+        assertEquals( \"mean not expected\", 1.0, \n+            u.getMean(), Double.MIN_VALUE);\n+        assertEquals( \"variance not expected\", 0.0, \n+            u.getVariance(), Double.MIN_VALUE);\n+        assertEquals( \"geometric mean not expected\", 1.0, \n+            u.getGeometricMean(), Double.MIN_VALUE);\n+        \n+        u.addValue(-1.0);\n+        \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        \n+        u.addValue(0.0);\n+        \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        \n+        //FiXME: test all other NaN contract specs\n+    }\n+        \n+        \n+        \n \n }\n ", "timestamp": 1053711198, "metainfo": ""}