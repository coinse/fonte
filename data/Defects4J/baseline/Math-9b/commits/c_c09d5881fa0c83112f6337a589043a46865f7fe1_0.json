{"sha": "c09d5881fa0c83112f6337a589043a46865f7fe1", "log": "Fixed FindBugs warning.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n  * @since 2.0 (changed to concrete class in 3.0)\n  */\n public class EigenDecomposition {\n+    /** Internally used epsilon criteria. */\n+    private static final double EPSILON = 1e-12;\n     /** Maximum number of iterations accepted in the implicit QL transformation */\n     private byte maxIter = 30;\n     /** Main diagonal of the tridiagonal matrix. */\n     /** Cached value of Vt. */\n     private RealMatrix cachedVt;\n \n-    /** Internally used epsilon criteria. */\n-    private final double epsilon = 1e-12;\n-\n     /**\n      * Calculates the eigen decomposition of the given real matrix.\n      * <p>\n             cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n \n             for (int i = 0; i < imagEigenvalues.length; i++) {\n-                if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) > 0) {\n+                if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n                     cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n-                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) < 0) {\n+                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n                     cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n                 }\n             }\n      */\n     public boolean hasComplexEigenvalues() {\n         for (int i = 0; i < imagEigenvalues.length; i++) {\n-            if (!Precision.equals(imagEigenvalues[i], 0.0, epsilon)) {\n+            if (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\n                 return true;\n             }\n         }\n \n         for (int i = 0; i < realEigenvalues.length; i++) {\n             if (i == (realEigenvalues.length - 1) ||\n-                Precision.equals(matT[i + 1][i], 0.0, epsilon)) {\n+                Precision.equals(matT[i + 1][i], 0.0, EPSILON)) {\n                 realEigenvalues[i] = matT[i][i];\n             } else {\n                 final double x = matT[i + 1][i + 1];\n         }\n \n         // we can not handle a matrix with zero norm\n-        if (Precision.equals(norm, 0.0, epsilon)) {\n+        if (Precision.equals(norm, 0.0, EPSILON)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n \n                     for (int j = l; j <= idx; j++) {\n                         r = r + matrixT[i][j] * matrixT[j][idx];\n                     }\n-                    if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) < 0.0) {\n+                    if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0.0) {\n                         z = w;\n                         s = r;\n                     } else {\n                     }\n                     double w = matrixT[i][i] - p;\n \n-                    if (Precision.compareTo(imagEigenvalues[i], 0.0, epsilon) < 0.0) {\n+                    if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0.0) {\n                         z = w;\n                         r = ra;\n                         s = sa;", "timestamp": 1344981726, "metainfo": ""}