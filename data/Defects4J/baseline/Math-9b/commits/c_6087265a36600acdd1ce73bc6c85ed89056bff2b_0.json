{"sha": "6087265a36600acdd1ce73bc6c85ed89056bff2b", "log": "[MATH-777] added NPointCrossover policy, thanks to Reid Hochstedler.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/genetics/NPointCrossover.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+\n+/**\n+ * N-point crossover policy. For each iteration a random crossover point is\n+ * selected and the first part from each parent is copied to the corresponding\n+ * child, and the second parts are copied crosswise.\n+ *\n+ * Example (2-point crossover):\n+ * <pre>\n+ * -C- denotes a crossover point\n+ *           -C-       -C-                         -C-        -C-\n+ * p1 = (1 0  | 1 0 0 1 | 0 1 1)    X    p2 = (0 1  | 1 0 1 0  | 1 1 1)\n+ *      \\----/ \\-------/ \\-----/              \\----/ \\--------/ \\-----/\n+ *        ||      (*)       ||                  ||      (**)       ||\n+ *        VV      (**)      VV                  VV      (*)        VV\n+ *      /----\\ /--------\\ /-----\\             /----\\ /--------\\ /-----\\\n+ * c1 = (1 0  | 1 0 1 0  | 0 1 1)    X   c2 = (0 1  | 1 0 0 1  | 0 1 1)\n+ * </pre>\n+ *\n+ * This policy works only on {@link AbstractListChromosome}, and therefore it\n+ * is parameterized by T. Moreover, the chromosomes must have same lengths.\n+ *\n+ * @param <T> generic type of the {@link AbstractListChromosome}s for crossover\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class NPointCrossover<T> implements CrossoverPolicy {\n+\n+    /** The number of crossover points. */\n+    private final int crossoverPoints;\n+\n+    /**\n+     * Creates a new {@link NPointCrossover} policy using the given number of points.\n+     *\n+     * <p><b>Note</b>: the number of crossover points must be &lt; <code>chromosome length - 1</code>.\n+     * This condition can only be checked at runtime, as the chromosome length is not known in advance.\n+     * </p>\n+     *\n+     * @param crossoverPoints the number of crossover points\n+     * @throws NotStrictlyPositiveException if the number of {@code crossoverPoints} is not\n+     * strictly positive\n+     */\n+    public NPointCrossover(final int crossoverPoints) {\n+        if (crossoverPoints <= 0) {\n+            throw new NotStrictlyPositiveException(crossoverPoints);\n+        }\n+        this.crossoverPoints = crossoverPoints;\n+    }\n+\n+    /**\n+     * Returns the number of crossover points used by this {@link CrossoverPolicy}.\n+     *\n+     * @return the number of crossover points\n+     */\n+    public int getCrossoverPoints() {\n+        return crossoverPoints;\n+    }\n+\n+    /**\n+     * Performs a N-point crossover. N random crossover points are selected and are used\n+     * to divide the parent chromosomes into segments. The segments are copied in alternate\n+     * order from the two parents to the corresponding child chromosomes.\n+     *\n+     * Example (2-point crossover):\n+     * <pre>\n+     * -C- denotes a crossover point\n+     *           -C-       -C-                         -C-        -C-\n+     * p1 = (1 0  | 1 0 0 1 | 0 1 1)    X    p2 = (0 1  | 1 0 1 0  | 1 1 1)\n+     *      \\----/ \\-------/ \\-----/              \\----/ \\--------/ \\-----/\n+     *        ||      (*)       ||                  ||      (**)       ||\n+     *        VV      (**)      VV                  VV      (*)        VV\n+     *      /----\\ /--------\\ /-----\\             /----\\ /--------\\ /-----\\\n+     * c1 = (1 0  | 1 0 1 0  | 0 1 1)    X   c2 = (0 1  | 1 0 0 1  | 0 1 1)\n+     * </pre>\n+     *\n+     * @param first first parent (p1)\n+     * @param second second parent (p2)\n+     * @return pair of two children (c1,c2)\n+     * @throws MathIllegalArgumentException iff one of the chromosomes is\n+     *         not an instance of {@link AbstractListChromosome}\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n+     */\n+    @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n+    public ChromosomePair crossover(final Chromosome first, final Chromosome second) {\n+        if (!(first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_FIXED_LENGTH_CHROMOSOME);\n+        }\n+        return mate((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n+    }\n+\n+    /**\n+     * Helper for {@link #crossover(Chromosome, Chromosome)}. Performs the actual crossover.\n+     *\n+     * @param first the first chromosome\n+     * @param second the second chromosome\n+     * @return the pair of new chromosomes that resulted from the crossover\n+     * @throws DimensionMismatchException if the length of the two chromosomes is different\n+     * @throws NumberIsTooLargeException if the number of crossoverPoints is too large for the\n+     * actual chromosomes\n+     */\n+    private ChromosomePair mate(final AbstractListChromosome<T> first,\n+                                final AbstractListChromosome<T> second) {\n+        final int length = first.getLength();\n+        if (length != second.getLength()) {\n+            throw new DimensionMismatchException(second.getLength(), length);\n+        }\n+        if (crossoverPoints >= length) {\n+            throw new NumberIsTooLargeException(crossoverPoints, length, false);\n+        }\n+\n+        // array representations of the parents\n+        final List<T> parent1Rep = first.getRepresentation();\n+        final List<T> parent2Rep = second.getRepresentation();\n+        // and of the children\n+        final ArrayList<T> child1Rep = new ArrayList<T>(first.getLength());\n+        final ArrayList<T> child2Rep = new ArrayList<T>(second.getLength());\n+\n+        final RandomGenerator random = GeneticAlgorithm.getRandomGenerator();\n+\n+        ArrayList<T> c1 = child1Rep;\n+        ArrayList<T> c2 = child2Rep;\n+\n+        int remainingPoints = crossoverPoints;\n+        int lastIndex = 0;\n+        for (int i = 0; i < crossoverPoints; i++, remainingPoints--) {\n+            // select the next crossover point at random\n+            final int crossoverIndex = 1 + lastIndex + random.nextInt(length - lastIndex - remainingPoints);\n+\n+            // copy the current segment\n+            for (int j = lastIndex; j < crossoverIndex; j++) {\n+                c1.add(parent1Rep.get(j));\n+                c2.add(parent2Rep.get(j));\n+            }\n+\n+            // swap the children for the next segment\n+            ArrayList<T> tmp = c1;\n+            c1 = c2;\n+            c2 = tmp;\n+\n+            lastIndex = crossoverIndex;\n+        }\n+\n+        // copy the last segment\n+        for (int j = lastIndex; j < length; j++) {\n+            c1.add(parent1Rep.get(j));\n+            c2.add(parent2Rep.get(j));\n+        }\n+\n+        return new ChromosomePair(first.newFixedLengthChromosome(child1Rep),\n+                                  second.newFixedLengthChromosome(child2Rep));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/genetics/NPointCrossoverTest.java\n+package org.apache.commons.math3.genetics;\n+\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class NPointCrossoverTest {\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testCrossoverDimensionMismatchException() {\n+        final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        final Integer[] p2 = new Integer[] {0,1,1,0,1};\n+\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+\n+        final CrossoverPolicy cp = new NPointCrossover<Integer>(1);\n+        cp.crossover(p1c,p2c);\n+    }\n+    \n+    @Test(expected = NumberIsTooLargeException.class)\n+    public void testNumberIsTooLargeException() {\n+        final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        final Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};\n+\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+\n+        final CrossoverPolicy cp = new NPointCrossover<Integer>(15);\n+        cp.crossover(p1c,p2c);\n+    }\n+    \n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeFirst() {\n+        final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        final BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        final Chromosome p2c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new NPointCrossover<Integer>(1);\n+        cp.crossover(p1c,p2c);\n+    }\n+    \n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testCrossoverInvalidFixedLengthChromosomeSecond() {\n+        final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n+        final BinaryChromosome p2c = new DummyBinaryChromosome(p1);\n+        final Chromosome p1c = new Chromosome() {\n+            public double fitness() {\n+                // Not important\n+                return 0;\n+            }\n+        };\n+\n+        final CrossoverPolicy cp = new NPointCrossover<Integer>(1);\n+        cp.crossover(p1c,p2c);\n+    }\n+    \n+    @Test\n+    public void testCrossover() {\n+        Integer[] p1 = new Integer[] {1,0,1,0,1,0,1,0,1};\n+        Integer[] p2 = new Integer[] {0,1,0,1,0,1,0,1,0};\n+\n+        BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n+        BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n+\n+        final int order = 3;\n+        NPointCrossover<Integer> npc = new NPointCrossover<Integer>(order);\n+\n+        // the two parent chromosomes are different at each position, so it is easy to detect\n+        // the number of crossovers that happened for each child\n+        for (int i=0; i<20; i++) {\n+            ChromosomePair pair = npc.crossover(p1c,p2c);\n+\n+            Integer[] c1 = new Integer[p1.length];\n+            Integer[] c2 = new Integer[p2.length];\n+\n+            c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);\n+            c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);\n+\n+            Assert.assertEquals(order, detectCrossoverPoints(p1c, p2c, (BinaryChromosome) pair.getFirst()));\n+            Assert.assertEquals(order, detectCrossoverPoints(p2c, p1c, (BinaryChromosome) pair.getSecond()));            \n+        }\n+    }\n+    \n+    private int detectCrossoverPoints(BinaryChromosome p1, BinaryChromosome p2, BinaryChromosome c) {\n+        int crossovers = 0;\n+        final int length = p1.getLength();\n+\n+        final List<Integer> p1Rep = p1.getRepresentation();\n+        final List<Integer> p2Rep = p2.getRepresentation();\n+        final List<Integer> cRep = c.getRepresentation();\n+        \n+        List<Integer> rep = p1Rep;\n+        for (int i = 0; i < length; i++) {\n+            if (rep.get(i) != cRep.get(i)) {\n+                crossovers++;\n+                rep = rep == p1Rep ? p2Rep : p1Rep;\n+            }\n+        }\n+        \n+        return crossovers;\n+    }\n+\n+}", "timestamp": 1338330264, "metainfo": ""}