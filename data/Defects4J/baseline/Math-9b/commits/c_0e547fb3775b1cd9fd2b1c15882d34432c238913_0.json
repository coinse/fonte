{"sha": "0e547fb3775b1cd9fd2b1c15882d34432c238913", "log": "Replaced internal LU-decomposition by the external class. Deprecated the direct call to these methods as users should really be able to choose the type of solver they want. LU-decomposition is only one possibility among others like QR-decomposition.  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n      *\n      * @return inverse matrix\n      * @throws InvalidMatrixException if  this is not invertible\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#getInverse()}\n+     */\n+    @Deprecated\n     RealMatrix inverse() throws InvalidMatrixException;\n \n     /**\n      * Returns the determinant of this matrix.\n      *\n      * @return determinant\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link LUDecomposition#getDeterminant()}\n+     */\n+    @Deprecated\n     double getDeterminant();\n \n     /**\n     /**\n      * Is this a singular matrix?\n      * @return true if the matrix is singular\n-     */\n+     * @deprecated as of release 2.0, replaced by the boolean negation of\n+     * {@link DecompositionSolver#isNonSingular()}\n+     */\n+    @Deprecated\n     boolean isSingular();\n \n     /**\n      * @return vector of solution values to AX = b, where A is *this\n      * @throws IllegalArgumentException if this.rowDimension != b.length\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(double[])}\n+     */\n+    @Deprecated\n     double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;\n-\n-    /**\n-     * Returns the solution vector for a linear system with coefficient\n-     * matrix = this and constant vector = <code>b</code>.\n-     *\n-     * @param b  constant vector\n-     * @return vector of solution values to AX = b, where A is *this\n-     * @throws IllegalArgumentException if this.rowDimension != b.length\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n-    RealVector solve(RealVector b) throws IllegalArgumentException, InvalidMatrixException;\n \n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * @return matrix of solution vectors\n      * @throws IllegalArgumentException if this.rowDimension != row dimension\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(RealMatrix)}\n+     */\n+    @Deprecated\n     RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n \n }\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n     private static final long serialVersionUID = 4970229902484487012L;\n \n     /** Entries of the matrix */\n-    protected double data[][] = null;\n-\n-    /** Entries of cached LU decomposition.\n-     *  All updates to data (other than luDecompose()) *must* set this to null\n-     */\n-    protected double lu[][] = null;\n-\n-    /** Permutation associated with LU decomposition */\n-    protected int[] permutation = null;\n-\n-    /** Parity of the permutation associated with the LU decomposition */\n-    protected int parity = 1;\n-\n-    /** Bound to determine effective singularity in LU decomposition */\n-    private static final double TOO_SMALL = 10E-12;\n+    protected double data[][];\n+\n+    /** Cached LU decomposition.\n+     * @deprecated as of release 2.0, since all methods using this are deprecated\n+     */\n+    private LUDecomposition lu;\n \n     /**\n      * Creates a matrix with no data\n         }\n     }\n \n-    /**\n-     * Create a new RealMatrix which is a copy of this.\n-     *\n-     * @return  the cloned matrix\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix copy() {\n         return new RealMatrixImpl(copyOut(), false);\n     }\n \n-    /**\n-     * Compute the sum of this and <code>m</code>.\n-     *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n         try {\n             return add((RealMatrixImpl) m);\n         return new RealMatrixImpl(outData, false);\n     }\n \n-    /**\n-     * Compute  this minus <code>m</code>.\n-     *\n-     * @param m    matrix to be subtracted\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n         try {\n             return subtract((RealMatrixImpl) m);\n         return new RealMatrixImpl(outData, false);\n     }\n \n-    /**\n-     * Returns the result of adding d to each entry of this.\n-     *\n-     * @param d    value to be added to each entry\n-     * @return     d + this\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix scalarAdd(double d) {\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         return new RealMatrixImpl(outData, false);\n     }\n \n-    /**\n-     * Returns the result of multiplying each entry of this by <code>d</code>\n-     * @param d  value to multiply all entries by\n-     * @return d * this\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix scalarMultiply(double d) {\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         return new RealMatrixImpl(outData, false);\n     }\n \n-    /**\n-     * Returns the result of postmultiplying this by <code>m</code>.\n-     * @param m    matrix to postmultiply by\n-     * @return     this*m\n-     * @throws     IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n         try {\n             return multiply((RealMatrixImpl) m);\n         return new RealMatrixImpl(outData, false);\n     }\n \n-    /**\n-     * Returns the result of premultiplying this by <code>m</code>.\n-     * @param m    matrix to premultiply by\n-     * @return     m * this\n-     * @throws     IllegalArgumentException\n-     *             if rowDimension(this) != columnDimension(m)\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {\n         return m.multiply(this);\n     }\n \n-    /**\n-     * Returns matrix entries as a two-dimensional array.\n-     * <p>\n-     * Makes a fresh copy of the underlying data.</p>\n-     *\n-     * @return    2-dimensional array of entries\n-     */\n+    /** {@inheritDoc} */\n     public double[][] getData() {\n         return copyOut();\n     }\n     /**\n      * Returns a reference to the underlying data array.\n      * <p>\n-     * Does not make a fresh copy of the underlying data.</p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n      *\n      * @return 2-dimensional array of entries\n      */\n         return data;\n     }\n \n-    /**\n-     *\n-     * @return norm\n-     */\n+    /** {@inheritDoc} */\n     public double getNorm() {\n         double maxColSum = 0;\n         for (int col = 0; col < this.getColumnDimension(); col++) {\n         return maxColSum;\n     }\n     \n-    /**\n-     * Gets a submatrix. Rows and columns are indicated\n-     * counting from 0 to n-1.\n-     *\n-     * @param startRow Initial row index\n-     * @param endRow Final row index\n-     * @param startColumn Initial column index\n-     * @param endColumn Final column index\n-     * @return The subMatrix containing the data of the\n-     *         specified rows and columns\n-     * @exception MatrixIndexException if row or column selections are not valid\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix getSubMatrix(int startRow, int endRow,\n                                    int startColumn, int endColumn)\n         throws MatrixIndexException {\n         return new RealMatrixImpl(subMatrixData, false);\n     }\n     \n-    /**\n-     * Gets a submatrix. Rows and columns are indicated\n-     * counting from 0 to n-1.\n-     *\n-     * @param selectedRows Array of row indices must be non-empty\n-     * @param selectedColumns Array of column indices must be non-empty\n-     * @return The subMatrix containing the data in the\n-     *     specified rows and columns\n-     * @exception MatrixIndexException  if supplied row or column index arrays\n-     *     are not valid\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n         throws MatrixIndexException {\n         if (selectedRows.length * selectedColumns.length == 0) {\n         } \n         lu = null;\n     }\n-    \n-    /**\n-     * Returns the entries in row number <code>row</code> as a row matrix.\n-     * Row indices start at 0.\n-     * \n-     * @param row  the row to be fetched\n-     * @return row matrix\n-     * @throws MatrixIndexException if the specified row index is invalid\n-     */\n+\n+    /** {@inheritDoc} */\n     public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n         if ( !isValidCoordinate( row, 0)) {\n             throw new MatrixIndexException(\"illegal row argument\");\n         return new RealMatrixImpl(out, false);\n     }\n     \n-    /**\n-     * Returns the entries in column number <code>column</code>\n-     * as a column matrix.  Column indices start at 0.\n-     *\n-     * @param column the column to be fetched\n-     * @return column matrix\n-     * @throws MatrixIndexException if the specified column index is invalid\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {\n         if ( !isValidCoordinate( 0, column)) {\n             throw new MatrixIndexException(\"illegal column argument\");\n         return new RealVectorImpl(getRow(row), false);\n     }\n \n-    /**\n-     * Returns the entries in row number <code>row</code> as an array.\n-     * <p>\n-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= row < rowDimension.</code></p>\n-     *\n-     * @param row the row to be fetched\n-     * @return array of entries in the row\n-     * @throws MatrixIndexException if the specified row index is not valid\n-     */\n+    /** {@inheritDoc} */\n     public double[] getRow(int row) throws MatrixIndexException {\n         if ( !isValidCoordinate( row, 0 ) ) {\n             throw new MatrixIndexException(\"illegal row argument\");\n         return out;\n     }\n \n-    /**\n-     * Returns the entries in column number <code>col</code> as an array.\n-     * <p>\n-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= column < columnDimension.</code></p>\n-     *\n-     * @param col the column to be fetched\n-     * @return array of entries in the column\n-     * @throws MatrixIndexException if the specified column index is not valid\n-     */\n+    /** {@inheritDoc} */\n     public double[] getColumn(int col) throws MatrixIndexException {\n         if ( !isValidCoordinate(0, col) ) {\n             throw new MatrixIndexException(\"illegal column argument\");\n         return out;\n     }\n \n-    /**\n-     * Returns the entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy \n-     * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n-     * @param row  row location of entry to be fetched\n-     * @param column  column location of entry to be fetched\n-     * @return matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n-     */\n+    /** {@inheritDoc} */\n     public double getEntry(int row, int column)\n         throws MatrixIndexException {\n         try {\n         }\n     }\n \n-    /**\n-     * Returns the transpose matrix.\n-     *\n-     * @return transpose matrix\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix transpose() {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         return new RealMatrixImpl(outData, false);\n     }\n \n-    /**\n-     * Returns the inverse matrix if this matrix is invertible.\n-     *\n-     * @return inverse matrix\n-     * @throws InvalidMatrixException if this is not invertible\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix inverse() throws InvalidMatrixException {\n-        return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension()));\n-    }\n-\n-    /**\n-     * @return determinant\n-     * @throws InvalidMatrixException if matrix is not square\n-     */\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.getInverse();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public double getDeterminant() throws InvalidMatrixException {\n-        if (!isSquare()) {\n-            throw new InvalidMatrixException(\"matrix is not square\");\n-        }\n-        if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n-            return 0d;\n-        } else {\n-            double det = parity;\n-            for (int i = 0; i < this.getRowDimension(); i++) {\n-                det *= lu[i][i];\n-            }\n-            return det;\n-        }\n-    }\n-\n-    /**\n-     * @return true if the matrix is square (rowDimension = columnDimension)\n-     */\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.getDeterminant();\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isSquare() {\n         return (this.getColumnDimension() == this.getRowDimension());\n     }\n \n-    /**\n-     * @return true if the matrix is singular\n-     */\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public boolean isSingular() {\n         if (lu == null) {\n-            try {\n-                luDecompose();\n-                return false;\n-            } catch (InvalidMatrixException ex) {\n-                return true;\n-            }\n-        } else { // LU decomp must have been successfully performed\n-            return false; // so the matrix is not singular\n-        }\n-    }\n-\n-    /**\n-     * @return rowDimension\n-     */\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return !lu.isNonSingular();\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getRowDimension() {\n         return data.length;\n     }\n \n-    /**\n-     * @return columnDimension\n-     */\n+    /** {@inheritDoc} */\n     public int getColumnDimension() {\n         return data[0].length;\n     }\n \n-    /**\n-     * @return trace\n-     * @throws IllegalArgumentException if the matrix is not square\n-     */\n+    /** {@inheritDoc} */\n     public double getTrace() throws IllegalArgumentException {\n         if (!isSquare()) {\n             throw new IllegalArgumentException(\"matrix is not square\");\n         return trace;\n     }\n \n-    /**\n-     * @param v vector to operate on\n-     * @throws IllegalArgumentException if columnDimension != v.length\n-     * @return resulting vector\n-     */\n+    /** {@inheritDoc} */\n     public double[] operate(double[] v) throws IllegalArgumentException {\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         return new RealVectorImpl(operate(v.getDataRef()), false);\n     }\n \n-    /**\n-     * @param v vector to premultiply by\n-     * @throws IllegalArgumentException if rowDimension != v.length\n-     * @return resulting matrix\n-     */\n+    /** {@inheritDoc} */\n     public double[] preMultiply(double[] v) throws IllegalArgumentException {\n         final int nRows = this.getRowDimension();\n         if (v.length != nRows) {\n         return new RealVectorImpl(preMultiply(v.getDataRef()), false);\n     }\n \n-    /**\n-     * Returns a matrix of (column) solution vectors for linear systems with\n-     * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>.\n-     *\n-     * @param b  array of constant forming RHS of linear systems to\n-     * to solve\n-     * @return solution array\n-     * @throws IllegalArgumentException if this.rowDimension != row dimension\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final int nRows = this.getRowDimension();\n-        final int nCol  = this.getColumnDimension();\n-\n-        if (b.length != nRows) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-        if (!isSquare()) {\n-            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n-        }\n-        if (isSingular()) { // side effect: compute LU decomp\n-            throw new InvalidMatrixException(\"Matrix is singular.\");\n-        }\n-\n-        final double[] bp = new double[nRows];\n-\n-        // Apply permutations to b\n-        for (int row = 0; row < nRows; row++) {\n-            bp[row] = b[permutation[row]];\n-        }\n-\n-        // Solve LY = b\n-        for (int col = 0; col < nCol; col++) {\n-            for (int i = col + 1; i < nCol; i++) {\n-                bp[i] -= bp[col] * lu[i][col];\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        for (int col = nCol - 1; col >= 0; col--) {\n-            bp[col] /= lu[col][col];\n-            for (int i = 0; i < col; i++) {\n-                bp[i] -= bp[col] * lu[i][col];\n-            }\n-        }\n-\n-        return bp;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector solve(RealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        try {\n-            return solve((RealVectorImpl) b);\n-        } catch (ClassCastException cce) {\n-\n-            final int nRows = this.getRowDimension();\n-            final int nCol  = this.getColumnDimension();\n-\n-            if (b.getDimension() != nRows) {\n-                throw new IllegalArgumentException(\"constant vector has wrong length\");\n-            }\n-            if (!isSquare()) {\n-                throw new InvalidMatrixException(\"coefficient matrix is not square\");\n-            }\n-            if (isSingular()) { // side effect: compute LU decomp\n-                throw new InvalidMatrixException(\"Matrix is singular.\");\n-            }\n-\n-            final double[] bp = new double[nRows];\n-\n-            // Apply permutations to b\n-            for (int row = 0; row < nRows; row++) {\n-                bp[row] = b.getEntry(permutation[row]);\n-            }\n-\n-            // Solve LY = b\n-            for (int col = 0; col < nCol; col++) {\n-                for (int i = col + 1; i < nCol; i++) {\n-                    bp[i] -= bp[col] * lu[i][col];\n-                }\n-            }\n-\n-            // Solve UX = Y\n-            for (int col = nCol - 1; col >= 0; col--) {\n-                bp[col] /= lu[col][col];\n-                for (int i = 0; i < col; i++) {\n-                    bp[i] -= bp[col] * lu[i][col];\n-                }\n-            }\n-\n-            return new RealVectorImpl(bp, false);\n-\n-        }\n-    }\n-\n-    /**\n-     * Returns the solution vector for a linear system with coefficient\n-     * matrix = this and constant vector = <code>b</code>.\n-     *\n-     * @param b  constant vector\n-     * @return vector of solution values to AX = b, where A is *this\n-     * @throws IllegalArgumentException if this.rowDimension != b.length\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n-    RealVectorImpl solve(RealVectorImpl b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        return new RealVectorImpl(solve(b.getDataRef()), false);\n-    }\n-\n-    /**\n-     * Returns a matrix of (column) solution vectors for linear systems with\n-     * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>.\n-     *\n-     * @param b  matrix of constant vectors forming RHS of linear systems to\n-     * to solve\n-     * @return matrix of solution vectors\n-     * @throws IllegalArgumentException if this.rowDimension != row dimension\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.solve(b);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n-        if (b.getRowDimension() != this.getRowDimension()) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (!this.isSquare()) {\n-            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n-        }\n-        if (this.isSingular()) { // side effect: compute LU decomp\n-            throw new InvalidMatrixException(\"Matrix is singular.\");\n-        }\n-\n-        final int nCol  = this.getColumnDimension();\n-        final int nColB = b.getColumnDimension();\n-        final int nRowB = b.getRowDimension();\n-\n-        // Apply permutations to b\n-        final double[][] bp = new double[nRowB][nColB];\n-        for (int row = 0; row < nRowB; row++) {\n-            final double[] bpRow = bp[row];\n-            final int pRow = permutation[row];\n-            for (int col = 0; col < nColB; col++) {\n-                bpRow[col] = b.getEntry(pRow, col);\n-            }\n-        }\n-\n-        // Solve LY = b\n-        for (int col = 0; col < nCol; col++) {\n-            final double[] bpCol = bp[col];\n-            for (int i = col + 1; i < nCol; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = lu[i][col];\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        for (int col = nCol - 1; col >= 0; col--) {\n-            final double[] bpCol = bp[col];\n-            final double luDiag = lu[col][col];\n-            for (int j = 0; j < nColB; j++) {\n-                bpCol[j] /= luDiag;\n-            }\n-            for (int i = 0; i < col; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = lu[i][col];\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        return new RealMatrixImpl(bp, false);\n-\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.solve(b);\n     }\n \n     /**\n      * automatically.</p>\n      *\n      * @throws InvalidMatrixException if the matrix is non-square or singular.\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link LUDecomposition}\n+     */\n+    @Deprecated\n     public void luDecompose() throws InvalidMatrixException {\n-\n-        final int nRows = this.getRowDimension();\n-        final int nCols = this.getColumnDimension();\n-        if (nRows != nCols) {\n-            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n-        }\n-        lu = getData();\n-\n-        // Initialize permutation array and parity\n-        permutation = new int[nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            permutation[row] = row;\n-        }\n-        parity = 1;\n-\n-        // Loop over columns\n-        for (int col = 0; col < nCols; col++) {\n-\n-            double sum = 0;\n-\n-            // upper\n-            for (int row = 0; row < col; row++) {\n-                final double[] luRow = lu[row];\n-                sum = luRow[col];\n-                for (int i = 0; i < row; i++) {\n-                    sum -= luRow[i] * lu[i][col];\n-                }\n-                luRow[col] = sum;\n-            }\n-\n-            // lower\n-            int max = col; // permutation row\n-            double largest = 0d;\n-            for (int row = col; row < nRows; row++) {\n-                final double[] luRow = lu[row];\n-                sum = luRow[col];\n-                for (int i = 0; i < col; i++) {\n-                    sum -= luRow[i] * lu[i][col];\n-                }\n-                luRow[col] = sum;\n-\n-                // maintain best permutation choice\n-                if (Math.abs(sum) > largest) {\n-                    largest = Math.abs(sum);\n-                    max = row;\n-                }\n-            }\n-\n-            // Singularity check\n-            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n-                lu = null;\n-                throw new InvalidMatrixException(\"matrix is singular\");\n-            }\n-\n-            // Pivot if necessary\n-            if (max != col) {\n-                double tmp = 0;\n-                for (int i = 0; i < nCols; i++) {\n-                    tmp = lu[max][i];\n-                    lu[max][i] = lu[col][i];\n-                    lu[col][i] = tmp;\n-                }\n-                int temp = permutation[max];\n-                permutation[max] = permutation[col];\n-                permutation[col] = temp;\n-                parity = -parity;\n-            }\n-\n-            // Divide the lower elements by the \"winning\" diagonal elt.\n-            final double luDiag = lu[col][col];\n-            for (int row = col + 1; row < nRows; row++) {\n-                lu[row][col] /= luDiag;\n-            }\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n         }\n     }\n \n         return ret;\n     }\n \n-    //------------------------ Protected methods\n-\n-    /**\n-     *  Returns the LU decomposition as a RealMatrix.\n-     *  Returns a fresh copy of the cached LU matrix if this has been computed;\n-     *  otherwise the composition is computed and cached for use by other methods.\n-     *  Since a copy is returned in either case, changes to the returned matrix do not\n-     *  affect the LU decomposition property.\n-     * <p>\n-     * The matrix returned is a compact representation of the LU decomposition.\n-     * Elements below the main diagonal correspond to entries of the \"L\" matrix;\n-     * elements on and above the main diagonal correspond to entries of the \"U\"\n-     * matrix.</p>\n-     * <p>\n-     * Example: <pre>\n-     *\n-     *     Returned matrix                L                  U\n-     *         2  3  1                   1  0  0            2  3  1\n-     *         5  4  6                   5  1  0            0  4  6\n-     *         1  7  8                   1  7  1            0  0  8\n-     * </pre>\n-     *\n-     * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n-     *  where permuteRows reorders the rows of the matrix to follow the order determined\n-     *  by the <a href=#getPermutation()>permutation</a> property.</p>\n-     *\n-     * @return LU decomposition matrix\n-     * @throws InvalidMatrixException if the matrix is non-square or singular.\n-     */\n-    protected RealMatrix getLUMatrix() throws InvalidMatrixException {\n-        if (lu == null) {\n-            luDecompose();\n-        }\n-        return new RealMatrixImpl(lu);\n-    }\n-\n-    /**\n-     * Returns the permutation associated with the lu decomposition.\n-     * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n-     * <p>\n-     * Example:\n-     * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n-     * and current first row is last.</p>\n-     * <p>\n-     * Returns a fresh copy of the array.</p>\n-     *\n-     * @return the permutation\n-     */\n-    protected int[] getPermutation() {\n-        final int[] out = new int[permutation.length];\n-        System.arraycopy(permutation, 0, out, 0, permutation.length);\n-        return out;\n-    }\n-\n     //------------------------ Private methods\n \n     /**\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n        assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n    }  \n         \n-    /** test isSingular */\n-    public void testIsSingular() {\n-        RealMatrixImpl m = new RealMatrixImpl(singular);\n-        assertTrue(\"singular\",m.isSingular());\n-        m = new RealMatrixImpl(bigSingular);\n-        assertTrue(\"big singular\",m.isSingular());\n-        m = new RealMatrixImpl(id);\n-        assertTrue(\"identity nonsingular\",!m.isSingular());\n-        m = new RealMatrixImpl(testData);\n-        assertTrue(\"testData nonsingular\",!m.isSingular());\n-    }\n-        \n-    /** test inverse */\n-    public void testInverse() {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n-        assertClose(\"inverse\",mInv,m.inverse(),normTolerance);\n-        assertClose(\"inverse^2\",m,m.inverse().inverse(),10E-12);\n-        \n-        // Not square\n-        m = new RealMatrixImpl(testData2);\n-        try {\n-            m.inverse();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-        \n-        // Singular\n-        m = new RealMatrixImpl(singular);\n-        try {\n-            m.inverse();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-    }\n-    \n-    /** test solve */\n-    public void testSolve() {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n-        // being a bit slothful here -- actually testing that X = A^-1 * B\n-        assertClose(\"inverse-operate\", mInv.operate(testVector),\n-                    m.solve(testVector), normTolerance);\n-        assertClose(\"inverse-operate\", mInv.operate(testVector),\n-                    m.solve(new RealVectorImpl(testVector)).getData(), normTolerance);\n-        try {\n-            m.solve(testVector2);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            ;\n-        }       \n-        RealMatrix bs = new RealMatrixImpl(bigSingular);\n-        try {\n-            bs.solve(bs);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            ;\n-        }\n-        try {\n-            m.solve(bs);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            ;\n-        }\n-        try {\n-            new RealMatrixImpl(testData2).solve(bs);\n-            fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            ;\n-        } \n-        try {\n-            (new RealMatrixImpl(testData2)).luDecompose();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            ;\n-        }  \n-    }\n-    \n-    /** test determinant */\n-    public void testDeterminant() {       \n-        RealMatrix m = new RealMatrixImpl(bigSingular);\n-        assertEquals(\"singular determinant\",0,m.getDeterminant(),0);\n-        m = new RealMatrixImpl(detData);\n-        assertEquals(\"nonsingular test\",-3d,m.getDeterminant(),normTolerance);\n-        \n-        // Examples verified against R (version 1.8.1, Red Hat Linux 9)\n-        m = new RealMatrixImpl(detData2);\n-        assertEquals(\"nonsingular R test 1\",-2d,m.getDeterminant(),normTolerance);\n-        m = new RealMatrixImpl(testData);\n-        assertEquals(\"nonsingular  R test 2\",-1d,m.getDeterminant(),normTolerance);\n-\n-        try {\n-            new RealMatrixImpl(testData2).getDeterminant();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            ;\n-        }      \n-    }\n-    \n     /** test trace */\n     public void testTrace() {\n         RealMatrix m = new RealMatrixImpl(id);\n     /** test transpose */\n     public void testTranspose() {\n         RealMatrix m = new RealMatrixImpl(testData); \n-        assertClose(\"inverse-transpose\",m.inverse().transpose(),\n-            m.transpose().inverse(),normTolerance);\n+        RealMatrix mIT = new LUDecompositionImpl(m).getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getInverse();\n+        assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         m = new RealMatrixImpl(testData2);\n         RealMatrix mt = new RealMatrixImpl(testData2T);\n         assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n         }\n     }\n         \n-    public void testLUDecomposition() throws Exception {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrix lu = m.getLUMatrix();\n-        assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);\n-        verifyDecomposition(m, lu);\n-        // access LU decomposition on same object to verify caching.\n-        lu = m.getLUMatrix();\n-        assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);\n-        verifyDecomposition(m, lu);\n-\n-        m = new RealMatrixImpl(luData);\n-        lu = m.getLUMatrix();\n-        assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(luDataLUDecomposition), normTolerance);\n-        verifyDecomposition(m, lu);\n-        m = new RealMatrixImpl(testDataMinus);\n-        lu = m.getLUMatrix();\n-        verifyDecomposition(m, lu);\n-        m = new RealMatrixImpl(id);\n-        lu = m.getLUMatrix();\n-        verifyDecomposition(m, lu);\n-        try {\n-            m = new RealMatrixImpl(bigSingular); // singular\n-            lu = m.getLUMatrix();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-        try {\n-            m = new RealMatrixImpl(testData2);  // not square\n-            lu = m.getLUMatrix();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-    }\n-    \n     /** test examples in user guide */\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = p.inverse(); \n+        RealMatrix pInverse = new LUDecompositionImpl(p).getInverse(); \n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n         \n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new RealMatrixImpl(coefficientsData);\n         double[] constants = {1, -2, 1};\n-        double[] solution = coefficients.solve(constants);\n+        double[] solution = new LUDecompositionImpl(coefficients).solve(constants);\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n         assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n         assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n         return new RealMatrixImpl(out);\n     }\n     \n-    /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */\n-    protected void verifyDecomposition(RealMatrix matrix, RealMatrix lu) throws Exception{\n-        int n = matrix.getRowDimension();\n-        double[][] lowerData = new double[n][n];\n-        double[][] upperData = new double[n][n];\n-        splitLU(lu, lowerData, upperData);\n-        RealMatrix lower =new RealMatrixImpl(lowerData);\n-        RealMatrix upper = new RealMatrixImpl(upperData);\n-        int[] permutation = ((RealMatrixImpl) matrix).getPermutation();\n-        RealMatrix permuted = permuteRows(matrix, permutation);\n-        assertClose(\"lu decomposition does not work\", permuted, lower.multiply(upper), normTolerance);\n-    }\n-      \n-    \n //    /** Useful for debugging */\n //    private void dumpMatrix(RealMatrix m) {\n //          for (int i = 0; i < m.getRowDimension(); i++) {", "timestamp": 1222617315, "metainfo": ""}