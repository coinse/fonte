{"sha": "9732372dcb90859520da9d9077cfa5dd65bfa623", "log": "Adding sparse field implememtations  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.util.OpenIntToFieldHashMap;\n+\n+/**\n+* Sparse matrix implementation based on an open addressed map.\n+* \n+* @version $Revision: 762117 $ $Date: 2009-04-05 09:53:35 -0700 (Sun, 05 Apr 2009) $\n+* @since 2.0\n+*/\n+public class SparseFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> {\n+    /**\n+     *  Serial id\n+     */\n+    private static final long serialVersionUID = 9078068119297757342L;\n+    /** Storage for (sparse) matrix elements. */\n+    private final OpenIntToFieldHashMap<T> entries;\n+    /**\n+     * row dimension\n+     */\n+    private final int rowDimension;\n+    /**\n+     * column dimension\n+     */\n+    private final int columnDimension;\n+    \n+\n+    /**\n+     * Creates a matrix with no data\n+     * @param field field to which the elements belong\n+     */\n+    public SparseFieldMatrix(final Field<T> field) {\n+        super(field);\n+        rowDimension = 0;\n+        columnDimension= 0;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+    }\n+\n+    /**\n+     * Create a new SparseFieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     */\n+    public SparseFieldMatrix(final Field<T> field,\n+                                  final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(field, rowDimension, columnDimension);\n+        this.rowDimension = rowDimension;\n+        this.columnDimension = columnDimension;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+    }\n+    \n+    /**\n+     * Copy construtor.\n+     * @param other The instance to copy\n+     */\n+    public SparseFieldMatrix(SparseFieldMatrix<T> other){\n+        super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n+        rowDimension = other.getRowDimension();\n+        columnDimension = other.getColumnDimension();\n+        entries = new OpenIntToFieldHashMap<T>(other.entries);\n+    }\n+\n+    /**\n+     * Generic copy construtor.\n+     * @param other The instance to copy\n+     */\n+    public SparseFieldMatrix(FieldMatrix<T> other){\n+        super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n+        rowDimension = other.getRowDimension();\n+        columnDimension = other.getColumnDimension();\n+        entries = new OpenIntToFieldHashMap<T>(getField());\n+        for(int i=0; i < rowDimension; i++){\n+            for(int j=0; j < columnDimension; j++){\n+                setEntry(i, j, other.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(int row, int column, T increment)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        final int key = computeKey(row, column);\n+        final T value = entries.get(key).add(increment);\n+        if (getField().getZero().equals(value)) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+       \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+        return new SparseFieldMatrix<T>(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(int rowDimension, int columnDimension)\n+            throws IllegalArgumentException {\n+        return new SparseFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columnDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(int row, int column) throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        return entries.get(computeKey(row, column));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rowDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(int row, int column, T factor)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        final int key = computeKey(row, column);\n+        final T value = entries.get(key).multiply(factor);\n+        if (getField().getZero().equals(value)) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(int row, int column, T value)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        if (getField().getZero().equals(value)) {\n+            entries.remove(computeKey(row, column));\n+        } else {\n+            entries.put(computeKey(row, column), value);\n+        }\n+        \n+    }\n+    /**\n+     * Compute the key to access a matrix element\n+     * @param row row index of the matrix element\n+     * @param column column index of the matrix element\n+     * @return key within the map to access the matrix element\n+     */\n+    private int computeKey(int row, int column) {\n+        return row * columnDimension + column;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SparseFieldVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.OpenIntToFieldHashMap;\n+\n+/**\n+ * This class implements the {@link FieldVector} interface with a {@link OpenIntToFieldHashMap} backing store.\n+ * @version $Revision: 728186 $ $Date: 2009-04-25 12:39:38 -0700 (Sat, 25 Apr 2009) $\n+ * @since 2.0\n+*/\n+public class SparseFieldVector<T extends FieldElement<T>> implements FieldVector<T> {\n+    \n+    /**\n+     *  Serial version id\n+     */\n+    private static final long serialVersionUID = 7841233292190413362L;\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+    /** Entries of the vector. */\n+    private final OpenIntToFieldHashMap<T> entries;\n+    /** Dimension of the vector. */\n+    private final int virtualSize;\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #SparseFieldVector(SparseFieldVector<T>, int)} constructor\n+     * or one of the <code>append</code> method ({@link #append(Field<T>)}, {@link\n+     * #append(Field<T>[])}, {@link #append(FieldVector)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public SparseFieldVector(Field<T> field) {\n+        this(field, 0);\n+    }\n+\n+    \n+    /**\n+     * Construct a (dimension)-length vector of zeros.\n+     * @param dimension Size of the vector\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public SparseFieldVector(Field<T> field, int dimension) {\n+        this.field = field;\n+        virtualSize = dimension;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+    }\n+\n+    /**\n+     * Build a resized vector, for use with append.\n+     * @param v The original vector\n+     * @param resize The amount to resize it\n+     */\n+    protected SparseFieldVector(SparseFieldVector<T> v, int resize) {\n+        field = v.field;\n+        virtualSize = v.getDimension() + resize;\n+        entries = new OpenIntToFieldHashMap<T>(v.entries);\n+    }\n+\n+    \n+    /**\n+     * Build a vector with known the sparseness (for advanced use only).\n+     * @param dimension The size of the vector\n+     * @param expectedSize The expected number of non-zero entries\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public SparseFieldVector(Field<T> field, int dimension, int expectedSize) {\n+        this.field = field;\n+        virtualSize = dimension;\n+        entries = new OpenIntToFieldHashMap<T> (field,expectedSize);\n+    }\n+\n+    \n+    /**\n+     * Create from a Field array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public SparseFieldVector(Field<T> field, T[] values) {\n+        this.field = field;\n+        virtualSize = values.length;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+        for (int key = 0; key < values.length; key++) {\n+            T value = values[key];\n+            entries.put(key, value);\n+        }\n+    }\n+\n+     \n+\n+    /**\n+     * Copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public SparseFieldVector(SparseFieldVector<T> v) {\n+        field = v.field;\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToFieldHashMap<T>(v.getEntries());\n+    }\n+\n+    /**\n+     * Get the entries of this instance.\n+     * @return entries of this instance\n+     */\n+    private OpenIntToFieldHashMap<T> getEntries() {\n+        return entries;\n+    }\n+    \n+    /**\n+     * Optimzed method to add sparse vectors\n+     * @return The sum of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+*/\n+    public FieldVector<T> add(SparseFieldVector<T> v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n+        OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            T value = iter.value();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key).add(value));\n+            } else {\n+                res.setEntry(key, value);\n+            }\n+        }\n+        return res;\n+\n+    }\n+\n+    \n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(field,getDimension());\n+        for (int i = 0; i < v.length; i++) {\n+            res.setEntry(i, v[i].add(getEntry(i)));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(SparseFieldVector<T> v) {\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this, v.getDimension());\n+        OpenIntToFieldHashMap<T>.Iterator iter = v.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key() + virtualSize, iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(FieldVector<T> v) {\n+        if(v instanceof SparseFieldVector)\n+            return append((SparseFieldVector<T>)v);\n+        else\n+            return append(v.toArray());\n+            \n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T d) {\n+        FieldVector<T> res = new SparseFieldVector<T>(this, 1);\n+        res.setEntry(virtualSize, d);\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T[] a) {\n+        FieldVector<T> res = new SparseFieldVector<T>(this, a.length);\n+        for (int i = 0; i < a.length; i++) {\n+            res.setEntry(i + virtualSize, a[i]);\n+        }\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> copy() {\n+        return new SparseFieldVector<T>(this);\n+   }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        T res = field.getZero();\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res = res.add(v.getEntry(iter.key()).multiply(iter.value()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T res = field.getZero();\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            int idx = iter.key();\n+            T value = field.getZero();\n+            if (idx < v.length) {\n+                value = v[idx];\n+            }\n+            res = res.add(value.multiply(iter.value()));\n+        }\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+            throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().divide(v.getEntry(iter.key())));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().divide(v[iter.key()]));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().multiply(v.getEntry(iter.key())));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+     public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().multiply(v[iter.key()]));\n+        }\n+        return res;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public T[] getData() {\n+        T[] res = buildArray(virtualSize);\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res[iter.key()] = iter.value();\n+        }\n+        return res;\n+     }\n+\n+     /** {@inheritDoc} */\n+     public int getDimension() {\n+        return virtualSize;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public T getEntry(int index) throws MatrixIndexException {\n+        checkIndex(index);\n+        return entries.get(index);\n+   }\n+\n+     /** {@inheritDoc} */\n+     public Field<T> getField() {\n+        return field;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> getSubVector(int index, int n)\n+            throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + n - 1);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(field,n);\n+        int end = index + n;\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (key >= index && key < end) {\n+                res.setEntry(key - index, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapAdd(T d) {\n+        return copy().mapAddToSelf(d);\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapAddToSelf(T d) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, getEntry(i).add(d));\n+        }\n+        return this;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapDivide(T d) {\n+        return copy().mapDivideToSelf(d);\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapDivideToSelf(T d) {\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value().divide(d));\n+        }\n+        return this;\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapInv() {\n+        return copy().mapInvToSelf();\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapInvToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, field.getOne().divide(getEntry(i)));\n+        }\n+        return this;\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapMultiply(T d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapMultiplyToSelf(T d) {\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value().multiply(d));\n+        }\n+        return this;\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapSubtract(T d) {\n+        return copy().mapSubtractToSelf(d);\n+    }    \n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapSubtractToSelf(T d) {\n+        return mapAddToSelf(field.getZero().subtract(d));\n+    }\n+\n+     /**\n+      * Optimized method to compute outer product when both vectors are sparse\n+      * @param v vector with which outer product should be computed\n+      * @return the square matrix outer product between instance and v\n+      * @throws IllegalArgumentException if v is not the same size as {@code this}\n+      */\n+    public FieldMatrix<T> outerProduct(SparseFieldVector<T> v)\n+            throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            OpenIntToFieldHashMap<T>.Iterator iter2 = v.entries.iterator();\n+            while (iter2.hasNext()) {\n+                iter2.advance();\n+                res.setEntry(iter.key(), iter2.key(), iter.value().multiply(iter2.value()));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        FieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int row = iter.key();\n+            FieldElement<T>value = iter.value();\n+            for (int col = 0; col < virtualSize; col++) {\n+                res.setEntry(row, col, value.multiply(v[col]));\n+            }\n+        }\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(FieldVector<T> v)\n+    throws IllegalArgumentException {\n+        if(v instanceof SparseFieldVector)\n+            return outerProduct((SparseFieldVector<T>)v);\n+        else\n+            return outerProduct(v.toArray());\n+    }\n+\n+    public FieldVector<T> projection(FieldVector<T> v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        return projection(new SparseFieldVector<T>(field,v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(T value) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, T value) throws MatrixIndexException {\n+        checkIndex(index);\n+        entries.put(index, value);\n+   }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, FieldVector<T> v)\n+            throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.getDimension() - 1);\n+        setSubVector(index, v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, T[] v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.length - 1);\n+        for (int i = 0; i < v.length; i++) {\n+            setEntry(i + index, v[i]);\n+        }\n+        \n+    }\n+\n+    /**\n+     * Optimized method to subtract SparseRealVectors.\n+     * @param v The vector to subtract from <code>this</code>\n+     * @return The difference of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public SparseFieldVector<T> subtract(SparseFieldVector<T> v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n+        OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key).subtract(iter.value()));\n+            } else {\n+                res.setEntry(key, field.getZero().subtract(iter.value()));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(FieldVector<T> v)\n+           throws IllegalArgumentException {\n+        if(v instanceof SparseFieldVector)\n+            return subtract((SparseFieldVector<T>)v);\n+        else\n+            return subtract(v.toArray());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        for (int i = 0; i < v.length; i++) {\n+            if (entries.containsKey(i)) {\n+                res.setEntry(i, entries.get(i).subtract(v[i]));\n+            } else {\n+                res.setEntry(i, field.getZero().subtract(v[i]));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] toArray() {\n+        return getData();\n+    }\n+    \n+    /**\n+     * Check if an index is valid.\n+     *\n+     * @param index\n+     *            index to check\n+     * @exception MatrixIndexException\n+     *                if index is not valid\n+     */\n+    private void checkIndex(final int index) throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     *\n+     * @param n\n+     *            expected dimension.\n+     * @exception IllegalArgumentException\n+     *                if the dimension is inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n+        if (getDimension() != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    getDimension(), n);\n+        }\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+        if(v instanceof SparseFieldVector)\n+            return add((SparseFieldVector<T>)v);\n+        else\n+            return add(v.toArray());\n+    }\n+\n+    /** Build an array of elements.\n+     * @param length size of the array to build\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+    }\n+\n+\n+    \n+}\n--- a/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n     private final int columnDimension;\n \n     /** Storage for (sparse) matrix elements. */\n-    private OpenIntToDoubleHashMap entries;\n+    private final OpenIntToDoubleHashMap entries;\n \n     /**\n      * Build a sparse matrix with the supplied row and column dimensions.\n--- a/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n         }\n-        return null;\n+        return res;\n     }\n \n     /** {@inheritDoc} */", "timestamp": 1241389645, "metainfo": ""}