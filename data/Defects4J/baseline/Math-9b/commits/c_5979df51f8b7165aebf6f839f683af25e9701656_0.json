{"sha": "5979df51f8b7165aebf6f839f683af25e9701656", "log": "allow eigen decomposition of a matrix already in symmetric tridiagonal form  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n  * <p>The eigen decomposition of symmetric matrix A is a set of two matrices:\n  * V and D such that A = V D V<sup>T</sup>. A, V and D are all m &times; m\n  * matrices.</p>\n- * <p>This implementation only uses the upper part of the matrix, the part below the\n- * diagonal is not accessed at all.</p>\n+ * <p>When called with a {@link RealMatrix} argument, this implementation only uses\n+ * the upper part of the matrix, the part below the diagonal is not accessed at all.</p>\n  * <p>Eigenvalues are computed as soon as the matrix is decomposed, but eigenvectors\n  * are computed only when required, i.e. only when one of the {@link #getEigenvector(int)},\n  * {@link #getV()}, {@link #getVT()}, {@link #getInverse()}, {@link #solve(double[])},\n     }\n \n     /**\n+     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(double[], double[])}.</p>\n+     * @param main the main diagonal of the matrix\n+     * @param secondary the secondary diagonal of the matrix\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public EigenDecompositionImpl(final double[] main, double[] secondary)\n+        throws InvalidMatrixException {\n+        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n+        decompose(main, secondary);\n+    }\n+\n+    /**\n      * Set split tolerance based on absolute off-diagonal elements.\n      * @param tolerance tolerance to set\n      */\n      */\n     public void decompose(final RealMatrix matrix)\n         throws InvalidMatrixException {\n+        transformToTridiagonal(matrix);\n+        decompose();\n+    }\n+\n+    /**\n+     * Decompose a tridiagonal symmetric matrix. \n+     * @param main the main diagonal of the matrix\n+     * @param secondary the secondary diagonal of the matrix\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public void decompose(final double[] main, final double[] secondary) {\n+\n+        this.main      = main;\n+        this.secondary = secondary;\n+        orthoTridiag   = null;\n+\n+        // pre-compute some elements\n+        squaredSecondary = new double[secondary.length];\n+        for (int i = 0; i < squaredSecondary.length; ++i) {\n+            final double s = secondary[i];\n+            squaredSecondary[i] = s * s;\n+        }\n+\n+        decompose();\n+\n+    }\n+\n+    /**\n+     * Decompose a tridiagonal symmetric matrix. \n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    private void decompose() {\n \n         cachedV  = null;\n         cachedD  = null;\n         cachedVt = null;\n-        work     = new double[6 * matrix.getRowDimension()];\n-\n-        // compute tridiagonal representation of the initial matrix\n-        transformToTridiagonal(matrix);\n+        work     = new double[6 * main.length];\n+\n+        // compute the Gershgorin circles\n         computeGershgorinCircles();\n \n         // find all the eigenvalues\n             eigenvector[i] *= inv;\n         }\n \n-        return new RealVectorImpl(orthoTridiag.operate(eigenvector), true);\n+        return (orthoTridiag == null) ?\n+               new RealVectorImpl(eigenvector, false) :\n+               new RealVectorImpl(orthoTridiag.operate(eigenvector), false);\n \n     }\n \n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n         assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n         assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n         assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n+    }\n+\n+    /** test a matrix already in tridiagonal form. */\n+    public void testTridiagonal() {\n+        Random r = new Random(4366663527842l);\n+        double[] ref = new double[30];\n+        for (int i = 0; i < ref.length; ++i) {\n+            if (i < 5) {\n+                ref[i] = 2 * r.nextDouble() - 1;\n+            } else {\n+                ref[i] = 0.0001 * r.nextDouble() + 6;                \n+            }\n+        }\n+        Arrays.sort(ref);\n+        TriDiagonalTransformer t =\n+            new TriDiagonalTransformer(createTestMatrix(r, ref));\n+        EigenDecomposition ed =\n+            new EigenDecompositionImpl(t.getMainDiagonalRef(),\n+                                       t.getSecondaryDiagonalRef());\n+        double[] eigenValues = ed.getEigenvalues();\n+        assertEquals(ref.length, eigenValues.length);\n+        for (int i = 0; i < ref.length; ++i) {\n+            assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);\n+        }\n+        \n     }\n \n     /** test dimensions */", "timestamp": 1228228740, "metainfo": ""}