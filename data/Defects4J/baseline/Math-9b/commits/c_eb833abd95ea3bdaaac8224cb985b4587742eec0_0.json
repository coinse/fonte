{"sha": "eb833abd95ea3bdaaac8224cb985b4587742eec0", "log": "The EmpiricalDistributionImpl that submitted yesterday assumed the \"old\" Univariate interface, in which getN() returned a double.  The attached patch inserts the necessary casts to avoid the rounding/truncation errors that were causing the EmpiricalDistribution and ValueServer unit tests to fail.  The patch also adds a RandomData member variable so that getNext() does not instantiate a new RandomData instance for each activation  PR: Bugzilla #20149 Obtained from: Issue Patch Submitted by: Phil Steitz Reviewed by: Tim O'Brien   ", "commit": "\n--- a/src/java/org/apache/commons/math/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/EmpiricalDistributionImpl.java\n  * </ol></p>\n  *\n  * @author  Phil Steitz\n- * @version $Revision: 1.1 $\n+ * @version $Revision: 1.2 $\n  */\n public class EmpiricalDistributionImpl implements Serializable,EmpiricalDistribution {\n \n     \n     /** upper bounds of subintervals in (0,1) \"belonging\" to the bins */\n     private double[] upperBounds = null;\n+    \n+    /** RandomData instance to use in repeated calls to getNext() */\n+    private RandomData randomData = new RandomDataImpl();\n     \n     /** \n      * Creates a new EmpiricalDistribution  with the default bin count\n          // Assign upperBounds based on bin counts\n          upperBounds = new double[binCount];\n          upperBounds[0] = \n-            (((Univariate)binStats.get(0)).getN())/sampleStats.getN();\n+            ((double)((Univariate)binStats.get(0)).getN())/\n+                (double)sampleStats.getN();\n          for (int i = 1; i < binCount-1; i++) {\n              upperBounds[i] = upperBounds[i-1] +\n-               (((Univariate)binStats.get(i)).getN())/sampleStats.getN();\n+             ((double)((Univariate)binStats.get(i)).getN())/\n+                (double)sampleStats.getN();\n          }\n          upperBounds[binCount-1] = 1.0d;   \n          \n         double x = Math.random();\n        \n         // Use this to select the bin and generate a Gaussian within the bin\n-        RandomData rd = new RandomDataImpl();\n         for (int i = 0; i < binCount; i++) {\n            if (x <= upperBounds[i]) {\n                Univariate stats = (Univariate)binStats.get(i);\n-               if (stats.getN() > 0.5) { // really mean > 0, but avoid fp error\n+               if (stats.getN() > 0) { \n                    if (stats.getStandardDeviation() > 0) {  // more than one obs \n-                        return rd.nextGaussian\n+                        return randomData.nextGaussian\n                             (stats.getMean(),stats.getStandardDeviation());\n                    } else {\n                        return stats.getMean(); // only one obs in bin", "timestamp": 1053616772, "metainfo": ""}