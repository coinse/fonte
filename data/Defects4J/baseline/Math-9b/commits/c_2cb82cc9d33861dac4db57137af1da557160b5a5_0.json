{"sha": "2cb82cc9d33861dac4db57137af1da557160b5a5", "log": "Simplified tangent higher derivatives computation.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n                     final double[] result, final int resultOffset) {\n \n         // create the function value and derivatives\n-        double[] function = new double[1 + order];\n-        final double z = operand[operandOffset];\n-        final double t = FastMath.tan(z);\n+        final double[] function = new double[1 + order];\n+        final double t = FastMath.tan(operand[operandOffset]);\n         function[0] = t;\n+\n         if (order > 0) {\n-            final double secant2 = 1 + t * t;\n-            function[1] = secant2;\n-            for (int n = 2; n <= order; ++n) {\n-                final int signN4 = ((n & 0x02) == 0) ? 1 : -1;\n-                double outerSum = 0;\n-                int sign = 1;\n-                double secant2Kp2 = secant2;\n-                for (int k = 0; k < n; ++k) {\n-                    double innerSum = 0;\n-                    for (int j = 0; j < k; ++j) {\n-                        final double alpha = 2 * (k - j) * z;\n-                        final double sc  = ((n & 0x01) == 0) ? FastMath.sin(alpha) : FastMath.cos(alpha);\n-                         innerSum += sc * signN4 * ArithmeticUtils.pow(k - j, n - 1) *\n-                                    ArithmeticUtils.binomialCoefficient(2 * k, j);\n+\n+            // the nth order derivative of tan has the form:\n+            // dn(tan(x)/dxn = P_n(tan(x))\n+            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n+            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(x) = 2 t (1 + t^2) ...\n+            // the general recurrence relation for P_n is:\n+            // P_n(x) = (1+t^2) P_(n-1)'(t)\n+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n+            final double[] p = new double[order + 2];\n+            p[1] = 1;\n+            final double t2 = t * t;\n+            for (int n = 1; n <= order; ++n) {\n+\n+                // update and evaluate polynomial P_n(t)\n+                double v = 0;\n+                p[n + 1] = n * p[n];\n+                for (int k = n + 1; k >= 0; k -= 2) {\n+                    v = v * t2 + p[k];\n+                    if (k > 2) {\n+                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\n+                    } else if (k == 2) {\n+                        p[0] = p[1];\n                     }\n-                    double twoNm2K = (n >= 2 * k) ? (1 << (n - 2 * k)) : (1.0 / (1 << (2 * k - n)));\n-                    outerSum  += sign * innerSum * ArithmeticUtils.binomialCoefficient(n - 1, k) *\n-                                 twoNm2K * secant2Kp2 / (k + 1);\n-                    sign       = -sign;\n-                    secant2Kp2 *= secant2;\n-                }\n-                function[n] = n * outerSum;\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= t;\n+                }\n+\n+                function[n] = v;\n+\n             }\n         }\n ", "timestamp": 1344937536, "metainfo": ""}