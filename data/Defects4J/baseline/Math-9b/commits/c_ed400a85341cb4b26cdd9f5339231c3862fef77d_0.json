{"sha": "ed400a85341cb4b26cdd9f5339231c3862fef77d", "log": "MATH-653 Renamed \"AbstracRealVector\" to \"RealVector\" (getting rid of the \"interface\"). Changed \"SparseRealVector\" from \"interface\" to \"abstract\" class. Modified subclasses (\"extends\" instead of \"implements\") and unit test name (\"RealVectorTest\" instead of \"AbstractRealVectorTest\") accordingly. Slightly modified \"UnmodifiableRealVectorAbstractTest\" to exclude methods that are now inherited from \"Object\". Changed unmodifiable vector view from a static inner class to an anonymous class.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n  * @version $Id$\n  * @since 2.0\n  */\n-public class ArrayRealVector extends AbstractRealVector implements Serializable {\n+public class ArrayRealVector extends RealVector implements Serializable {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1097961340710804027L;\n     /** Default format. */\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n  * @version $Id$\n  * @since 2.0\n */\n-public class OpenMapRealVector extends AbstractRealVector\n-    implements SparseRealVector, Serializable {\n+public class OpenMapRealVector extends SparseRealVector\n+    implements Serializable {\n     /** Default Tolerance for having a value considered zero. */\n     public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n     /** Serializable version identifier. */\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.math.linear;\n \n import java.util.Iterator;\n-\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.math.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.analysis.FunctionUtils;\n+import org.apache.commons.math.analysis.function.Add;\n+import org.apache.commons.math.analysis.function.Multiply;\n+import org.apache.commons.math.analysis.function.Divide;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n- * Interface defining a real-valued vector with basic algebraic operations.\n+ * Class defining a real-valued vector with basic algebraic operations.\n  * <p>\n  * vector element indexing is 0-based -- e.g., {@code getEntry(0)}\n  * returns the first element of the vector.\n  * </pre>\n  *\n  * @version $Id$\n- * @since 2.0\n+ * @since 2.1\n  */\n-public interface RealVector {\n+public abstract class RealVector {\n+    /**\n+     * Returns the size of the vector.\n+     *\n+     * @return size\n+     */\n+    public abstract int getDimension();\n+\n+    /**\n+     * Returns the entry in the specified index.\n+     *\n+     * @param index Index location of entry to be fetched.\n+     * @return the vector entry at {@code index}.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n+     * @see #setEntry(int, double)\n+     */\n+    public abstract double getEntry(int index);\n+\n+    /**\n+     * Set a single element.\n+     * @param index element index.\n+     * @param value new value for the element.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n+     * @see #getEntry(int)\n+     */\n+    public abstract void setEntry(int index, double value);\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     *\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public abstract RealVector append(RealVector v);\n+\n+    /**\n+     * Construct a vector by appending a double to this vector.\n+     *\n+     * @param d double to append.\n+     * @return a new vector\n+     */\n+    public abstract RealVector append(double d);\n+\n+    /**\n+     * Construct a vector by appending a double array to this vector.\n+     *\n+     * @param a double array to append.\n+     * @return a new vector\n+     */\n+    public abstract RealVector append(double[] a);\n+\n+    /**\n+     * Get a subvector from consecutive elements.\n+     *\n+     * @param index index of first element.\n+     * @param n number of elements to be retrieved.\n+     * @return a vector containing n elements.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n+     */\n+    public abstract RealVector getSubVector(int index, int n);\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     *\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n+     * @see #setSubVector(int, double[])\n+     */\n+    public abstract void setSubVector(int index, RealVector v);\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     *\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n+     * @see #setSubVector(int, RealVector)\n+     */\n+    public abstract void setSubVector(int index, double[] v);\n+\n+    /**\n+     * Check whether any coordinate of this vector is {@code NaN}.\n+     *\n+     * @return {@code true} if any coordinate of this vector is {@code NaN},\n+     * {@code false} otherwise.\n+     */\n+    public abstract boolean isNaN();\n+\n+    /**\n+     * Check whether any coordinate of this vector is infinite and none are {@code NaN}.\n+     *\n+     * @return {@code true} if any coordinate of this vector is infinite and\n+     * none are {@code NaN}, {@code false} otherwise.\n+     */\n+    public abstract boolean isInfinite();\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     *\n+     * @param v Vector to compare instance with.\n+     * @throws DimensionMismatchException if the vectors do not\n+     * have the same dimension.\n+     */\n+    protected void checkVectorDimensions(RealVector v) {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     *\n+     * @param n Expected dimension.\n+     * @throws DimensionMismatchException if the dimension is\n+     * inconsistent with the vector size.\n+     */\n+    protected void checkVectorDimensions(int n) {\n+        int d = getDimension();\n+        if (d != n) {\n+            throw new DimensionMismatchException(d, n);\n+        }\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     *\n+     * @param index Index to check.\n+     * @exception OutOfRangeException if {@code index} is not valid.\n+     */\n+    protected void checkIndex(final int index) {\n+        if (index < 0 ||\n+            index >= getDimension()) {\n+            throw new OutOfRangeException(LocalizedFormats.INDEX,\n+                                          index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this vector and {@code v}.\n+     *\n+     * @param v Vector to be added.\n+     * @return {@code this} + {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public RealVector add(double[] v) {\n+        double[] result = v.clone();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            result[e.getIndex()] += e.getValue();\n+        }\n+        return new ArrayRealVector(result, false);\n+    }\n+\n+    /**\n+     * Compute the sum of this vector and {@code v}.\n+     *\n+     * @param v Vector to be added.\n+     * @return {@code this} + {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public RealVector add(RealVector v) {\n+        if (v instanceof ArrayRealVector) {\n+            double[] values = ((ArrayRealVector)v).getDataRef();\n+            return add(values);\n+        }\n+        RealVector result = v.copy();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final int index = e.getIndex();\n+            result.setEntry(index, e.getValue() + result.getEntry(index));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Subtract {@code v} from this vector.\n+     *\n+     * @param v Vector to be subtracted.\n+     * @return {@code this} - {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public RealVector subtract(double[] v) {\n+        double[] result = v.clone();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final int index = e.getIndex();\n+            result[index] = e.getValue() - result[index];\n+        }\n+        return new ArrayRealVector(result, false);\n+    }\n+\n+    /**\n+     * Subtract {@code v} from this vector.\n+     *\n+     * @param v Vector to be subtracted.\n+     * @return {@code this} - {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public RealVector subtract(RealVector v) {\n+        if (v instanceof ArrayRealVector) {\n+            double[] values = ((ArrayRealVector)v).getDataRef();\n+            return add(values);\n+        }\n+        RealVector result = v.copy();\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final int index = e.getIndex();\n+            v.setEntry(index, e.getValue() - result.getEntry(index));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Add a value to each entry.\n+     *\n+     * @param d Value to be added to each entry.\n+     * @return {@code this} + {@code d}.\n+     */\n+    public RealVector mapAdd(double d) {\n+        return copy().mapAddToSelf(d);\n+    }\n+\n+    /**\n+     * Add a value to each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Value to be added to each entry.\n+     * @return {@code this}.\n+     */\n+    public RealVector mapAddToSelf(double d) {\n+        if (d != 0) {\n+            return mapToSelf(FunctionUtils.fix2ndArgument(new Add(), d));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns a (deep) copy of this vector.\n+     *\n+     * @return a vector copy.\n+     */\n+    public abstract RealVector copy();\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public double dotProduct(double[] v) {\n+        return dotProduct(new ArrayRealVector(v, false));\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public double dotProduct(RealVector v) {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d += e.getValue() * v.getEntry(e.getIndex());\n+        }\n+        return d;\n+    }\n+\n+    /**\n+     * Computes the cosine of the angle between this vector and the\n+     * argument.\n+     *\n+     * @param v Vector.\n+     * @return the cosine of the angle between this vector and {@code v}.\n+     */\n+    public double cosine(RealVector v) {\n+        final double norm = getNorm();\n+        final double vNorm = v.getNorm();\n+\n+        if (norm == 0 ||\n+            vNorm == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+        return dotProduct(v) / (norm * vNorm);\n+    }\n+\n+    /**\n+     * Computes the cosine of the angle between this vector and the\n+     * vector whose components are given as argument.\n+     *\n+     * @param v Components of a vector.\n+     * @return the cosine of the angle between this vector and {@code v}.\n+     */\n+    public double cosine(double[] v) {\n+        return cosine(new ArrayRealVector(v, false));\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     *\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public abstract RealVector ebeDivide(RealVector v);\n+\n+    /**\n+     * Element-by-element division.\n+     *\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public RealVector ebeDivide(double[] v) {\n+        return ebeDivide(new ArrayRealVector(v, false));\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     *\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public abstract RealVector ebeMultiply(RealVector v);\n+\n+    /**\n+     * Element-by-element multiplication.\n+     *\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public RealVector ebeMultiply(double[] v) {\n+        return ebeMultiply(new ArrayRealVector(v, false));\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfDistance(RealVector)\n+     * @see #getNorm()\n+     */\n+    public double getDistance(RealVector v) {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final double diff = e.getValue() - v.getEntry(e.getIndex());\n+            d += diff * diff;\n+        }\n+        return FastMath.sqrt(d);\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getNorm()\n+     */\n+    public double getDistance(double[] v) {\n+        return getDistance(new ArrayRealVector(v,false));\n+    }\n+\n+    /**\n+     * Returns the L<sub>2</sub> norm of the vector.\n+     * <p>The L<sub>2</sub> norm is the root of the sum of\n+     * the squared elements.</p>\n+     * @return norm\n+     * @see #getL1Norm()\n+     * @see #getLInfNorm()\n+     * @see #getDistance(RealVector)\n+     */\n+    public double getNorm() {\n+        double sum = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final double value = e.getValue();\n+            sum += value * value;\n+        }\n+        return FastMath.sqrt(sum);\n+    }\n+\n+    /**\n+     * Returns the L<sub>1</sub> norm of the vector.\n+     * <p>The L<sub>1</sub> norm is the sum of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getLInfNorm()\n+     * @see #getL1Distance(RealVector)\n+     */\n+    public double getL1Norm() {\n+        double norm = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            norm += FastMath.abs(e.getValue());\n+        }\n+        return norm;\n+    }\n+\n+    /**\n+     * Returns the L<sub>&infin;</sub> norm of the vector.\n+     * <p>The L<sub>&infin;</sub> norm is the max of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getL1Norm()\n+     * @see #getLInfDistance(RealVector)\n+     */\n+    public double getLInfNorm() {\n+        double norm = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            norm = FastMath.max(norm, FastMath.abs(e.getValue()));\n+        }\n+        return norm;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     * @see #getDistance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getL1Norm()\n+     */\n+    public double getL1Distance(RealVector v) {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d += FastMath.abs(e.getValue() - v.getEntry(e.getIndex()));\n+        }\n+        return d;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     * @see #getDistance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getL1Norm()\n+     */\n+    public double getL1Distance(double[] v) {\n+        checkVectorDimensions(v.length);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d += FastMath.abs(e.getValue() - v[e.getIndex()]);\n+        }\n+        return d;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfNorm()\n+     */\n+    public double getLInfDistance(RealVector v) {\n+        checkVectorDimensions(v);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d = FastMath.max(FastMath.abs(e.getValue() - v.getEntry(e.getIndex())), d);\n+        }\n+        return d;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     * @see #getDistance(double[])\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfNorm()\n+     */\n+    public double getLInfDistance(double[] v) {\n+        checkVectorDimensions(v.length);\n+        double d = 0;\n+        Iterator<Entry> it = iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            d = FastMath.max(FastMath.abs(e.getValue() - v[e.getIndex()]), d);\n+        }\n+        return d;\n+    }\n+\n+    /** Get the index of the minimum entry.\n+     * @return index of the minimum entry or -1 if vector length is 0\n+     * or all entries are NaN\n+     */\n+    public int getMinIndex() {\n+        int minIndex    = -1;\n+        double minValue = Double.POSITIVE_INFINITY;\n+        Iterator<Entry> iterator = iterator();\n+        while (iterator.hasNext()) {\n+            final Entry entry = iterator.next();\n+            if (entry.getValue() <= minValue) {\n+                minIndex = entry.getIndex();\n+                minValue = entry.getValue();\n+            }\n+        }\n+        return minIndex;\n+    }\n+\n+    /** Get the value of the minimum entry.\n+     * @return value of the minimum entry or NaN if all entries are NaN\n+     */\n+    public double getMinValue() {\n+        final int minIndex = getMinIndex();\n+        return minIndex < 0 ? Double.NaN : getEntry(minIndex);\n+    }\n+\n+    /** Get the index of the maximum entry.\n+     * @return index of the maximum entry or -1 if vector length is 0\n+     * or all entries are NaN\n+     */\n+    public int getMaxIndex() {\n+        int maxIndex    = -1;\n+        double maxValue = Double.NEGATIVE_INFINITY;\n+        Iterator<Entry> iterator = iterator();\n+        while (iterator.hasNext()) {\n+            final Entry entry = iterator.next();\n+            if (entry.getValue() >= maxValue) {\n+                maxIndex = entry.getIndex();\n+                maxValue = entry.getValue();\n+            }\n+        }\n+        return maxIndex;\n+    }\n+\n+    /** Get the value of the maximum entry.\n+     * @return value of the maximum entry or NaN if all entries are NaN\n+     */\n+    public double getMaxValue() {\n+        final int maxIndex = getMaxIndex();\n+        return maxIndex < 0 ? Double.NaN : getEntry(maxIndex);\n+    }\n+\n+\n+    /**\n+     * Multiply each entry.\n+     *\n+     * @param d Multiplication factor.\n+     * @return {@code this} * {@code d}.\n+     */\n+    public RealVector mapMultiply(double d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+    /**\n+     * Multiply each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Multiplication factor.\n+     * @return {@code this}.\n+     */\n+    public RealVector mapMultiplyToSelf(double d){\n+        return mapToSelf(FunctionUtils.fix2ndArgument(new Multiply(), d));\n+    }\n+\n+    /**\n+     * Subtract a value from each entry.\n+     *\n+     * @param d Value to be subtracted.\n+     * @return {@code this} - {@code d}.\n+     */\n+    public RealVector mapSubtract(double d) {\n+        return copy().mapSubtractToSelf(d);\n+    }\n+\n+    /**\n+     * Subtract a value from each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Value to be subtracted.\n+     * @return {@code this}.\n+     */\n+    public RealVector mapSubtractToSelf(double d){\n+        return mapAddToSelf(-d);\n+    }\n+\n+    /**\n+     * Divide each entry.\n+     *\n+     * @param d Value to divide by.\n+     * @return {@code this} / {@code d}.\n+     */\n+    public RealVector mapDivide(double d) {\n+        return copy().mapDivideToSelf(d);\n+    }\n+\n+    /**\n+     * Divide each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Value to divide by.\n+     * @return {@code this}.\n+     */\n+    public RealVector mapDivideToSelf(double d){\n+        return mapToSelf(FunctionUtils.fix2ndArgument(new Divide(), d));\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the matrix outer product between instance and v\n+     */\n+    public RealMatrix outerProduct(RealVector v) {\n+        RealMatrix product;\n+        if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n+            product = new OpenMapRealMatrix(this.getDimension(),\n+                                            v.getDimension());\n+        } else {\n+            product = new Array2DRowRealMatrix(this.getDimension(),\n+                                               v.getDimension());\n+        }\n+        Iterator<Entry> thisIt = sparseIterator();\n+        Entry thisE = null;\n+        while (thisIt.hasNext() && (thisE = thisIt.next()) != null) {\n+            Iterator<Entry> otherIt = v.sparseIterator();\n+            Entry otherE = null;\n+            while (otherIt.hasNext() && (otherE = otherIt.next()) != null) {\n+                product.setEntry(thisE.getIndex(), otherE.getIndex(),\n+                                 thisE.getValue() * otherE.getValue());\n+            }\n+        }\n+\n+        return product;\n+\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the matrix outer product between instance and v\n+     */\n+    public RealMatrix outerProduct(double[] v) {\n+        return outerProduct(new ArrayRealVector(v, false));\n+    }\n+\n+    /**\n+     * Find the orthogonal projection of this vector onto another vector.\n+     *\n+     * @param v vector onto which instance must be projected.\n+     * @return projection of the instance onto {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public abstract RealVector projection(RealVector v);\n+\n+    /**\n+     * Find the orthogonal projection of this vector onto another vector.\n+     *\n+     * @param v vector onto which instance must be projected.\n+     * @return projection of the instance onto v.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    public RealVector projection(double[] v) {\n+        return projection(new ArrayRealVector(v, false));\n+    }\n+\n+    /**\n+     * Set all elements to a single value.\n+     * @param value single value to set for all elements\n+     */\n+    public void set(double value) {\n+        Iterator<Entry> it = iterator();\n+        Entry e = null;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            e.setValue(value);\n+        }\n+    }\n+\n+    /**\n+     * Convert the vector to a double array.\n+     * <p>The array is independent from vector data, it's elements\n+     * are copied.</p>\n+     * @return array containing a copy of vector elements\n+     */\n+    public double[] toArray() {\n+        int dim = getDimension();\n+        double[] values = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            values[i] = getEntry(i);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Returns vector entries as a double array.\n+     *\n+     * @return double array of entries.\n+     */\n+    public double[] getData() {\n+        return toArray();\n+    }\n+\n+    /**\n+     * Creates a unit vector pointing in the direction of this vector.\n+     * The instance is not changed by this method.\n+     *\n+     * @return a unit vector pointing in direction of this vector\n+     * @exception ArithmeticException if the norm is null\n+     */\n+    public RealVector unitVector() {\n+        RealVector copy = copy();\n+        copy.unitize();\n+        return copy;\n+    }\n+\n+    /**\n+     * Converts this vector into a unit vector.\n+     * The instance itself is changed by this method.\n+     *\n+     * @throws org.apache.commons.math.exception.MathArithmeticException\n+     * if the norm is zero.\n+     */\n+    public void unitize() {\n+        mapDivideToSelf(getNorm());\n+    }\n+\n+    /**\n+     * Specialized implementations may choose to not iterate over all\n+     * dimensions, either because those values are unset, or are equal\n+     * to defaultValue(), or are small enough to be ignored for the\n+     * purposes of iteration.\n+     * No guarantees are made about order of iteration.\n+     * In dense implementations, this method will often delegate to\n+     * {@link #iterator()}.\n+     *\n+     * @return a sparse iterator.\n+     */\n+    public Iterator<Entry> sparseIterator() {\n+        return new SparseEntryIterator();\n+    }\n+\n+    /**\n+     * Generic dense iterator.\n+     * It iterates in increasing order of the vector index.\n+     *\n+     * @return a dense iterator.\n+     */\n+    public Iterator<Entry> iterator() {\n+        final int dim = getDimension();\n+        return new Iterator<Entry>() {\n+\n+            /** Current index. */\n+            private int i = 0;\n+\n+            /** Current entry. */\n+            private Entry e = new Entry();\n+\n+            /** {@inheritDoc} */\n+            public boolean hasNext() {\n+                return i < dim;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public Entry next() {\n+                e.setIndex(i++);\n+                return e;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void remove() {\n+                throw new MathUnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Acts as if implemented as:\n+     * <pre>\n+     *  return copy().mapToSelf(function);\n+     * </pre>\n+     *\n+     * @param function Function to apply to each entry.\n+     * @return a new vector.\n+     * @throws org.apache.commons.math.exception.MathUserException\n+     * if the function throws it.\n+     */\n+    public RealVector map(UnivariateRealFunction function) {\n+        return copy().mapToSelf(function);\n+    }\n+\n     /**\n      * Acts as if it is implemented as:\n      * <pre>\n      * @throws org.apache.commons.math.exception.MathUserException\n      * if the function throws it.\n      */\n-    RealVector mapToSelf(UnivariateRealFunction function);\n-\n-    /**\n-     * Acts as if implemented as:\n-     * <pre>\n-     *  return copy().map(function);\n-     * </pre>\n-     *\n-     * @param function Function to apply to each entry.\n-     * @return a new vector.\n-     * @throws org.apache.commons.math.exception.MathUserException\n-     * if the function throws it.\n-     */\n-    RealVector map(UnivariateRealFunction function);\n-\n-    /** Class representing a modifiable entry in the vector. */\n-    public abstract class Entry {\n-        /** Index of the entry. */\n+    public RealVector mapToSelf(UnivariateRealFunction function) {\n+        Iterator<Entry> it = (function.value(0) == 0) ? sparseIterator() : iterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            e.setValue(function.value(e.getValue()));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the linear combination of {@code this} and {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n+     * {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    public RealVector combine(double a, double b, double[] y) {\n+        return copy().combineToSelf(a, b, y);\n+    }\n+\n+    /**\n+     * Returns the linear combination of {@code this} and {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n+     * {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    public RealVector combine(double a, double b, RealVector y) {\n+        return copy().combineToSelf(a, b, y);\n+    }\n+\n+    /**\n+     * Updates {@code this} with the linear combination of {@code this} and\n+     * {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return {@code this}, with components equal to\n+     * {@code a * this[i] + b * y[i]} for all {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    public RealVector combineToSelf(double a, double b, double[] y) {\n+        return combineToSelf(a, b, new ArrayRealVector(y, false));\n+    }\n+\n+    /**\n+     * Updates {@code this} with the linear combination of {@code this} and\n+     * {@code y}.\n+     *\n+     * @param a Weight of {@code this}.\n+     * @param b Weight of {@code y}.\n+     * @param y Vector with which {@code this} is linearly combined.\n+     * @return {@code this}, with components equal to\n+     * {@code a * this[i] + b * y[i]} for all {@code i}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code y} is not the same size as this vector.\n+     */\n+    public RealVector combineToSelf(double a, double b, RealVector y) {\n+        checkVectorDimensions(y);\n+        for (int i = 0; i < getDimension(); i++) {\n+            final double xi = getEntry(i);\n+            final double yi = y.getEntry(i);\n+            setEntry(i, a * xi + b * yi);\n+        }\n+        return this;\n+    }\n+\n+    /** An entry in the vector. */\n+    protected class Entry {\n+        /** Index of this entry. */\n         private int index;\n+\n+        /** Simple constructor. */\n+        public Entry() {\n+            setIndex(0);\n+        }\n \n         /**\n          * Get the value of the entry.\n          *\n          * @return the value of the entry.\n          */\n-        public abstract double getValue();\n+        public double getValue() {\n+            return getEntry(getIndex());\n+        }\n+\n         /**\n          * Set the value of the entry.\n          *\n          * @param value New value for the entry.\n          */\n-        public abstract void setValue(double value);\n+        public void setValue(double value) {\n+            setEntry(getIndex(), value);\n+        }\n+\n         /**\n          * Get the index of the entry.\n          *\n         public int getIndex() {\n             return index;\n         }\n+\n         /**\n          * Set the index of the entry.\n          *\n     }\n \n     /**\n-     * Generic dense iterator.\n-     * It iterates in increasing order of the vector index.\n-     *\n-     * @return a dense iterator\n-     */\n-    Iterator<Entry> iterator();\n-\n-    /**\n-     * Specialized implementations may choose to not iterate over all\n-     * dimensions, either because those values are unset, or are equal\n-     * to defaultValue(), or are small enough to be ignored for the\n-     * purposes of iteration.\n-     * No guarantees are made about order of iteration.\n-     * In dense implementations, this method will often delegate to\n-     * {@link #iterator()}.\n-     *\n-     * @return a sparse iterator\n-     */\n-    Iterator<Entry> sparseIterator();\n-\n-    /**\n-     * Returns a (deep) copy of this vector.\n-     *\n-     * @return a vector copy.\n-     */\n-    RealVector copy();\n-\n-    /**\n-     * Compute the sum of this vector and {@code v}.\n-     *\n-     * @param v Vector to be added.\n-     * @return {@code this} + {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector add(RealVector v);\n-\n-    /**\n-     * Compute the sum of this vector and {@code v}.\n-     *\n-     * @param v Vector to be added.\n-     * @return {@code this} + {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector add(double[] v);\n-\n-\n-    /**\n-     * Subtract {@code v} from this vector.\n-     *\n-     * @param v Vector to be subtracted.\n-     * @return {@code this} - {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector subtract(RealVector v);\n-\n-    /**\n-     * Subtract {@code v} from this vector.\n-     *\n-     * @param v Vector to be subtracted.\n-     * @return {@code this} - {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector subtract(double[] v);\n-\n-    /**\n-     * Add a value to each entry.\n-     *\n-     * @param d Value to be added to each entry.\n-     * @return {@code this} + {@code d}.\n-     */\n-    RealVector mapAdd(double d);\n-\n-    /**\n-     * Add a value to each entry.\n-     * The instance is changed in-place.\n-     *\n-     * @param d Value to be added to each entry.\n-     * @return {@code this}.\n-     */\n-    RealVector mapAddToSelf(double d);\n-\n-    /**\n-     * Subtract a value from each entry.\n-     *\n-     * @param d Value to be subtracted.\n-     * @return {@code this} - {@code d}.\n-     */\n-    RealVector mapSubtract(double d);\n-\n-    /**\n-     * Subtract a value from each entry.\n-     * The instance is changed in-place.\n-     *\n-     * @param d Value to be subtracted.\n-     * @return {@code this}.\n-     */\n-    RealVector mapSubtractToSelf(double d);\n-\n-    /**\n-     * Multiply each entry.\n-     *\n-     * @param d Multiplication factor.\n-     * @return {@code this} * {@code d}.\n-     */\n-    RealVector mapMultiply(double d);\n-\n-    /**\n-     * Multiply each entry.\n-     * The instance is changed in-place.\n-     *\n-     * @param d Multiplication factor.\n-     * @return {@code this}.\n-     */\n-    RealVector mapMultiplyToSelf(double d);\n-\n-    /**\n-     * Divide each entry.\n-     *\n-     * @param d Value to divide by.\n-     * @return {@code this} / {@code d}.\n-     */\n-    RealVector mapDivide(double d);\n-\n-    /**\n-     * Divide each entry.\n-     * The instance is changed in-place.\n-     *\n-     * @param d Value to divide by.\n-     * @return {@code this}.\n-     */\n-    RealVector mapDivideToSelf(double d);\n-\n-    /**\n-     * Element-by-element multiplication.\n-     * @param v vector by which instance elements must be multiplied\n-     * @return a vector containing this[i] * v[i] for all i\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector ebeMultiply(RealVector v);\n-\n-    /**\n-     * Element-by-element multiplication.\n-     * @param v vector by which instance elements must be multiplied\n-     * @return a vector containing this[i] * v[i] for all i\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector ebeMultiply(double[] v);\n-\n-    /**\n-     * Element-by-element division.\n-     * @param v vector by which instance elements must be divided\n-     * @return a vector containing this[i] / v[i] for all i\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector ebeDivide(RealVector v);\n-\n-    /**\n-     * Element-by-element division.\n-     * @param v vector by which instance elements must be divided\n-     * @return a vector containing this[i] / v[i] for all i\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector ebeDivide(double[] v);\n-\n-    /**\n-     * Returns vector entries as a double array.\n-     * @return double array of entries\n-     */\n-     double[] getData();\n-\n-    /**\n-     * Compute the dot product.\n-     * @param v vector with which dot product should be computed\n-     * @return the scalar dot product between instance and v\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    double dotProduct(RealVector v);\n-\n-    /**\n-     * Compute the dot product.\n-     * @param v vector with which dot product should be computed\n-     * @return the scalar dot product between instance and v\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    double dotProduct(double[] v);\n-\n-    /**\n-     * Computes the cosine of the angle between this vector and the\n-     * argument.\n-     *\n-     * @param v Vector.\n-     * @return the cosine of the angle between this vector and {@code v}.\n-     */\n-    double cosine(RealVector v);\n-\n-    /**\n-     * Computes the cosine of the angle between this vector and the\n-     * vector whose components are given as argument.\n-     *\n-     * @param v Components of a vector.\n-     * @return the cosine of the angle between this vector and {@code v}.\n-     */\n-    double cosine(double[] v);\n-\n-    /**\n-     * Returns the L<sub>2</sub> norm of the vector.\n-     * <p>The L<sub>2</sub> norm is the root of the sum of\n-     * the squared elements.</p>\n-     * @return norm\n-     * @see #getL1Norm()\n-     * @see #getLInfNorm()\n-     * @see #getDistance(RealVector)\n-     */\n-    double getNorm();\n-\n-    /**\n-     * Returns the L<sub>1</sub> norm of the vector.\n-     * <p>The L<sub>1</sub> norm is the sum of the absolute\n-     * values of elements.</p>\n-     * @return norm\n-     * @see #getNorm()\n-     * @see #getLInfNorm()\n-     * @see #getL1Distance(RealVector)\n-     */\n-    double getL1Norm();\n-\n-    /**\n-     * Returns the L<sub>&infin;</sub> norm of the vector.\n-     * <p>The L<sub>&infin;</sub> norm is the max of the absolute\n-     * values of elements.</p>\n-     * @return norm\n-     * @see #getNorm()\n-     * @see #getL1Norm()\n-     * @see #getLInfDistance(RealVector)\n-     */\n-    double getLInfNorm();\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with the\n-     * L<sub>2</sub> norm, i.e. the square root of the sum of\n-     * elements differences, or euclidian distance.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getL1Distance(RealVector)\n-     * @see #getLInfDistance(RealVector)\n-     * @see #getNorm()\n-     */\n-    double getDistance(RealVector v);\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with the\n-     * L<sub>2</sub> norm, i.e. the square root of the sum of\n-     * elements differences, or euclidian distance.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getL1Distance(double[])\n-     * @see #getLInfDistance(double[])\n-     * @see #getNorm()\n-     */\n-    double getDistance(double[] v);\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n-     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n-     * elements differences.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getDistance(RealVector)\n-     * @see #getLInfDistance(RealVector)\n-     * @see #getL1Norm()\n-     */\n-    double getL1Distance(RealVector v);\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n-     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n-     * elements differences.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getDistance(double[])\n-     * @see #getLInfDistance(double[])\n-     * @see #getL1Norm()\n-     */\n-    double getL1Distance(double[] v);\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n-     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n-     * elements differences.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getDistance(RealVector)\n-     * @see #getL1Distance(RealVector)\n-     * @see #getLInfNorm()\n-     */\n-    double getLInfDistance(RealVector v);\n-\n-    /**\n-     * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n-     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n-     * elements differences.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     * @see #getDistance(double[])\n-     * @see #getL1Distance(double[])\n-     * @see #getLInfNorm()\n-     */\n-    double getLInfDistance(double[] v);\n-\n-    /** Creates a unit vector pointing in the direction of this vector.\n-     * <p>The instance is not changed by this method.</p>\n-     * @return a unit vector pointing in direction of this vector\n-     * @exception ArithmeticException if the norm is null\n-     */\n-    RealVector unitVector();\n-\n-    /** Converts this vector into a unit vector.\n-     * <p>The instance itself is changed by this method.</p>\n-     * @throws  org.apache.commons.math.exception.MathArithmeticException\n-     * if the norm is zero.\n-     */\n-    void unitize();\n-\n-    /** Find the orthogonal projection of this vector onto another vector.\n-     * @param v vector onto which instance must be projected\n-     * @return projection of the instance onto v\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector projection(RealVector v);\n-\n-    /** Find the orthogonal projection of this vector onto another vector.\n-     * @param v vector onto which instance must be projected\n-     * @return projection of the instance onto v\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    RealVector projection(double[] v);\n-\n-    /**\n-     * Compute the outer product.\n-     * @param v vector with which outer product should be computed\n-     * @return the matrix outer product between instance and v\n-     */\n-    RealMatrix outerProduct(RealVector v);\n-\n-    /**\n-     * Compute the outer product.\n-     * @param v vector with which outer product should be computed\n-     * @return the matrix outer product between instance and v\n-     */\n-    RealMatrix outerProduct(double[] v);\n-\n-    /**\n-     * Returns the entry in the specified index.\n-     *\n-     * @param index Index location of entry to be fetched.\n-     * @return the vector entry at {@code index}.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is not valid.\n-     * @see #setEntry(int, double)\n-     */\n-    double getEntry(int index);\n-\n-    /**\n-     * Set a single element.\n-     * @param index element index.\n-     * @param value new value for the element.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is not valid.\n-     * @see #getEntry(int)\n-     */\n-    void setEntry(int index, double value);\n-\n-    /**\n-     * Returns the size of the vector.\n-     * @return size\n-     */\n-    int getDimension();\n-\n-    /**\n-     * Construct a vector by appending a vector to this vector.\n-     * @param v vector to append to this one.\n-     * @return a new vector\n-     */\n-    RealVector append(RealVector v);\n-\n-    /**\n-     * Construct a vector by appending a double to this vector.\n-     * @param d double to append.\n-     * @return a new vector\n-     */\n-    RealVector append(double d);\n-\n-    /**\n-     * Construct a vector by appending a double array to this vector.\n-     * @param a double array to append.\n-     * @return a new vector\n-     */\n-    RealVector append(double[] a);\n-\n-    /**\n-     * Get a subvector from consecutive elements.\n-     * @param index index of first element.\n-     * @param n number of elements to be retrieved.\n-     * @return a vector containing n elements.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is not valid.\n-     */\n-    RealVector getSubVector(int index, int n);\n-\n-    /**\n-     * Set a set of consecutive elements.\n-     * @param index index of first element to be set.\n-     * @param v vector containing the values to set.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is not valid.\n-     * @see #setSubVector(int, double[])\n-     */\n-    void setSubVector(int index, RealVector v);\n-\n-    /**\n-     * Set a set of consecutive elements.\n-     * @param index index of first element to be set.\n-     * @param v vector containing the values to set.\n-     * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is not valid.\n-     * @see #setSubVector(int, RealVector)\n-     */\n-    void setSubVector(int index, double[] v);\n-\n-    /**\n-     * Set all elements to a single value.\n-     * @param value single value to set for all elements\n-     */\n-    void set(double value);\n-\n-    /**\n-     * Convert the vector to a double array.\n-     * <p>The array is independent from vector data, it's elements\n-     * are copied.</p>\n-     * @return array containing a copy of vector elements\n-     */\n-    double[] toArray();\n-\n-    /**\n-     * Check whether any coordinate of this vector is {@code NaN}.\n-     * @return {@code true} if any coordinate of this vector is {@code NaN},\n-     * {@code false} otherwise.\n-     */\n-    boolean isNaN();\n-\n-    /**\n-     * Check whether any coordinate of this vector is infinite and none are {@code NaN}.\n-     *\n-     * @return {@code true} if any coordinate of this vector is infinite and\n-     * none are {@code NaN}, {@code false} otherwise.\n-     */\n-    boolean isInfinite();\n-\n-    /**\n-     * Returns the linear combination of {@code this} and {@code y}.\n-     *\n-     * @param a Weight of {@code this}.\n-     * @param b Weight of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n-     * {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    RealVector combine(double a, double b, double[] y);\n-\n-    /**\n-     * Returns the linear combination of {@code this} and {@code y}.\n-     *\n-     * @param a Weight of {@code this}.\n-     * @param b Weight of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return a vector containing {@code a * this[i] + b * y[i]} for all\n-     * {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    RealVector combine(double a, double b, RealVector y);\n-\n-    /**\n-     * Updates {@code this} with the linear combination of {@code this} and\n-     * {@code y}.\n-     *\n-     * @param a Weight of {@code this}.\n-     * @param b Weight of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return {@code this}, with components equal to\n-     * {@code a * this[i] + b * y[i]} for all {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    RealVector combineToSelf(double a, double b, double[] y);\n-\n-    /**\n-     * Updates {@code this} with the linear combination of {@code this} and\n-     * {@code y}.\n-     *\n-     * @param a Weight of {@code this}.\n-     * @param b Weight of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return {@code this}, with components equal to\n-     * {@code a * this[i] + b * y[i]} for all {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    RealVector combineToSelf(double a, double b, RealVector y);\n+     * This class should rare be used, but is here to provide\n+     * a default implementation of sparseIterator(), which is implemented\n+     * by walking over the entries, skipping those whose values are the default one.\n+     *\n+     * Concrete subclasses which are SparseVector implementations should\n+     * make their own sparse iterator, not use this one.\n+     *\n+     * This implementation might be useful for ArrayRealVector, when expensive\n+     * operations which preserve the default value are to be done on the entries,\n+     * and the fraction of non-default values is small (i.e. someone took a\n+     * SparseVector, and passed it into the copy-constructor of ArrayRealVector)\n+     */\n+    protected class SparseEntryIterator implements Iterator<Entry> {\n+        /** Dimension of the vector. */\n+        private final int dim;\n+        /** Last entry returned by {@link #next()}. */\n+        private Entry current;\n+        /** Next entry for {@link #next()} to return. */\n+        private Entry next;\n+\n+        /** Simple constructor. */\n+        protected SparseEntryIterator() {\n+            dim = getDimension();\n+            current = new Entry();\n+            next = new Entry();\n+            if (next.getValue() == 0) {\n+                advance(next);\n+            }\n+        }\n+\n+        /**\n+         * Advance an entry up to the next nonzero one.\n+         *\n+         * @param e entry to advance.\n+         */\n+        protected void advance(Entry e) {\n+            if (e == null) {\n+                return;\n+            }\n+            do {\n+                e.setIndex(e.getIndex() + 1);\n+            } while (e.getIndex() < dim && e.getValue() == 0);\n+            if (e.getIndex() >= dim) {\n+                e.setIndex(-1);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean hasNext() {\n+            return next.getIndex() >= 0;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Entry next() {\n+            int index = next.getIndex();\n+            if (index < 0) {\n+                throw new NoSuchElementException();\n+            }\n+            current.setIndex(index);\n+            advance(next);\n+            return current;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void remove() {\n+            throw new MathUnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the specified vector.\n+     * The returned vector has read-only access. An attempt to modify it will\n+     * result in a {@link MathUnsupportedOperationException}. However, the\n+     * returned vector is <em>not</em> immutable, since any modification of\n+     * {@code v} will also change the returned view.\n+     * For example, in the following piece of code\n+     * <pre>\n+     *     RealVector v = new ArrayRealVector(2);\n+     *     RealVector w = RealVector.unmodifiableRealVector(v);\n+     *     v.setEntry(0, 1.2);\n+     *     v.setEntry(1, -3.4);\n+     * </pre>\n+     * the changes will be seen in the {@code w} view of {@code v}.\n+     *\n+     * @param v Vector for which an unmodifiable view is to be returned.\n+     * @return an unmodifiable view of {@code v}.\n+     */\n+    public static RealVector unmodifiableRealVector(final RealVector v) {\n+        /**\n+         * This anonymous class is an implementation of {@link RealVector}\n+         * with read-only access.\n+         * It wraps any {@link RealVector}, and exposes all methods which\n+         * do not modify it. Invoking methods which should normally result\n+         * in the modification of the calling {@link RealVector} results in\n+         * a {@link MathUnsupportedOperationException}. It should be noted\n+         * that {@link UnmodifiableVector} is <em>not</em> immutable.\n+         */\n+        return new RealVector() {\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapToSelf(UnivariateRealFunction function) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector map(UnivariateRealFunction function) {\n+                return v.map(function);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public Iterator<Entry> iterator() {\n+                final Iterator<Entry> i = v.iterator();\n+                return new Iterator<Entry>() {\n+                    /** The current entry. */\n+                    private final UnmodifiableEntry e = new UnmodifiableEntry();\n+\n+                    /** {@inheritDoc} */\n+                    @Override\n+                    public boolean hasNext() {\n+                        return i.hasNext();\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override\n+                    public Entry next() {\n+                        e.setIndex(i.next().getIndex());\n+                        return e;\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override\n+                    public void remove() {\n+                        throw new MathUnsupportedOperationException();\n+                    }\n+                };\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public Iterator<Entry> sparseIterator() {\n+                final Iterator<Entry> i = v.sparseIterator();\n+\n+                return new Iterator<Entry>() {\n+                    /** The current entry. */\n+                    private final UnmodifiableEntry e = new UnmodifiableEntry();\n+\n+                    /** {@inheritDoc} */\n+                    @Override\n+                    public boolean hasNext() {\n+                        return i.hasNext();\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override\n+                    public Entry next() {\n+                        e.setIndex(i.next().getIndex());\n+                        return e;\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override\n+                    public void remove() {\n+                        throw new MathUnsupportedOperationException();\n+                    }\n+                };\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector copy() {\n+                return v.copy();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector add(RealVector w) {\n+                return v.add(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector add(double[] w) {\n+                return v.add(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector subtract(RealVector w) {\n+                return v.subtract(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector subtract(double[] w) {\n+                return v.subtract(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapAdd(double d) {\n+                return v.mapAdd(d);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapAddToSelf(double d) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapSubtract(double d) {\n+                return v.mapSubtract(d);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapSubtractToSelf(double d) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapMultiply(double d) {\n+                return v.mapMultiply(d);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapMultiplyToSelf(double d) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapDivide(double d) {\n+                return v.mapDivide(d);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector mapDivideToSelf(double d) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector ebeMultiply(RealVector w) {\n+                return v.ebeMultiply(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector ebeMultiply(double[] w) {\n+                return v.ebeMultiply(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector ebeDivide(RealVector w) {\n+                return v.ebeDivide(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector ebeDivide(double[] w) {\n+                return v.ebeDivide(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double[] getData() {\n+                // TODO It is not specified in the javadoc that getData should\n+                // return a\n+                // deep copy\n+                return v.getData();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double dotProduct(RealVector w) {\n+                return v.dotProduct(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double dotProduct(double[] w) {\n+                return v.dotProduct(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double cosine(RealVector w) {\n+                return v.cosine(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double cosine(double[] w) {\n+                return v.cosine(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getNorm() {\n+                return v.getNorm();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getL1Norm() {\n+                return v.getL1Norm();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getLInfNorm() {\n+                return v.getLInfNorm();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getDistance(RealVector w) {\n+                return v.getDistance(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getDistance(double[] w) {\n+                return v.getDistance(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getL1Distance(RealVector w) {\n+                return v.getL1Distance(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getL1Distance(double[] w) {\n+                return v.getL1Distance(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getLInfDistance(RealVector w) {\n+                return v.getLInfDistance(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getLInfDistance(double[] w) {\n+                return v.getLInfDistance(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector unitVector() {\n+                return v.unitVector();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void unitize() {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector projection(RealVector w) {\n+                return v.projection(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector projection(double[] w) {\n+                return v.projection(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealMatrix outerProduct(RealVector w) {\n+                return v.outerProduct(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealMatrix outerProduct(double[] w) {\n+                return v.outerProduct(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getEntry(int index) {\n+                return v.getEntry(index);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void setEntry(int index, double value) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public int getDimension() {\n+                return v.getDimension();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector append(RealVector w) {\n+                return v.append(w);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector append(double d) {\n+                return v.append(d);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector append(double[] a) {\n+                return v.append(a);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector getSubVector(int index, int n) {\n+                return v.getSubVector(index, n);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void setSubVector(int index, RealVector w) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void setSubVector(int index, double[] w) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void set(double value) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double[] toArray() {\n+                return v.toArray();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public boolean isNaN() {\n+                return v.isNaN();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public boolean isInfinite() {\n+                return v.isInfinite();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector combine(double a, double b, double[] y) {\n+                return v.combine(a, b, y);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector combine(double a, double b, RealVector y) {\n+                return v.combine(a, b, y);\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector combineToSelf(double a, double b, double[] y) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public RealVector combineToSelf(double a, double b, RealVector y) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+\n+            /** An entry in the vector. */\n+            class UnmodifiableEntry extends Entry {\n+                /** {@inheritDoc} */\n+                @Override\n+                    public double getValue() {\n+                    return v.getEntry(getIndex());\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override\n+                    public void setValue(double value) {\n+                    throw new MathUnsupportedOperationException();\n+                }\n+            }\n+        };\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseRealVector.java\n package org.apache.commons.math.linear;\n \n /**\n- * Marker interface for RealVectors that require sparse backing storage\n+ * Marker class for RealVectors that require sparse backing storage\n  * @version $Id$\n  * @since 2.0\n  *\n  */\n-public interface SparseRealVector extends RealVector {\n-\n-}\n+public abstract class SparseRealVector extends RealVector {}\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n \n     // Testclass to test the RealVector interface\n     // only with enough content to support the test\n-    public static class RealVectorTestImpl implements RealVector, Serializable {\n+    public static class RealVectorTestImpl extends RealVector\n+        implements Serializable {\n \n         /** Serializable version identifier. */\n         private static final long serialVersionUID = 4715341047369582908L;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealVector.Entry;\n+import java.util.Iterator;\n+import java.util.Random;\n+\n+/**\n+ * Tests for {@link RealVector}.\n+ */\n+public class RealVectorTest {\n+    private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };\n+    private double[] vec2 = { -3d, 0d, 0d, 2d, 1d };\n+\n+    private static class TestVectorImpl extends RealVector {\n+        private double[] values;\n+\n+        TestVectorImpl(double[] values) {\n+            this.values = values;\n+        }\n+\n+        @Override\n+        public double[] getData() { return values; }\n+\n+        @Override\n+        public RealVector copy() {\n+            return new TestVectorImpl(values.clone());\n+        }\n+\n+        UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Test implementation only supports methods necessary for testing\");\n+        }\n+\n+        @Override\n+        public RealVector add(RealVector v) {\n+            RealVector result = new ArrayRealVector(v);\n+            return result.add(this);\n+        }\n+\n+        @Override\n+        public RealVector subtract(RealVector v) {\n+            RealVector result = new ArrayRealVector(v);\n+            return result.subtract(this).mapMultiplyToSelf(-1);\n+        }\n+\n+        @Override\n+        public RealVector mapAddToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] += d;\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public RealVector mapSubtractToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] -= d;\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public RealVector mapMultiplyToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] *= d;\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public RealVector mapDivideToSelf(double d) {\n+            for(int i=0; i<values.length; i++) {\n+                values[i] /= d;\n+            }\n+            return this;\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public double dotProduct(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        @Override\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) {\n+            return values[index];\n+        }\n+\n+        public void setEntry(int index, double value) {\n+            values[index] = value;\n+        }\n+\n+        public int getDimension() {\n+            return values.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector getSubVector(int index, int n) {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, double[] v) {\n+            throw unsupported();\n+        }\n+        public void setSubVector(int index, RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+    }\n+\n+    @Test\n+    public void testMap() throws Exception {\n+        double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };\n+        RealVector v = new TestVectorImpl(vec1.clone());\n+        RealVector w = v.map(new UnivariateRealFunction() { public double value(double x) { return x * x; } });\n+        double[] d2 = w.getData();\n+        Assert.assertEquals(vec1Squared.length, d2.length);\n+        for(int i=0; i<vec1Squared.length; i++) {\n+            Assert.assertEquals(vec1Squared[i], d2[i], 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testIterator() throws Exception {\n+        RealVector v = new TestVectorImpl(vec2.clone());\n+        Entry e;\n+        int i = 0;\n+        for(Iterator<Entry> it = v.iterator(); it.hasNext() && (e = it.next()) != null; i++) {\n+            Assert.assertEquals(vec2[i], e.getValue(), 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testSparseIterator() throws Exception {\n+        RealVector v = new TestVectorImpl(vec2.clone());\n+        Entry e;\n+        int i = 0;\n+        double[] nonDefaultV2 = { -3d, 2d, 1d };\n+        for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; i++) {\n+            Assert.assertEquals(nonDefaultV2[i], e.getValue(), 0);\n+        }\n+        double [] onlyOne = {0d, 1.0, 0d};\n+        v = new TestVectorImpl(onlyOne);\n+        for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; ) {\n+            Assert.assertEquals(onlyOne[1], e.getValue(), 0);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testClone() throws Exception {\n+        double[] d = new double[1000000];\n+        Random r = new Random(1234);\n+        for(int i=0;i<d.length; i++) d[i] = r.nextDouble();\n+        Assert.assertTrue(new ArrayRealVector(d).getNorm() > 0);\n+        double[] c = d.clone();\n+        c[0] = 1;\n+        Assert.assertNotSame(c[0], d[0]);\n+        d[0] = 1;\n+        Assert.assertEquals(new ArrayRealVector(d).getNorm(), new ArrayRealVector(c).getNorm(), 0);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombinePrecondition() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final TestVectorImpl x = new TestVectorImpl(aux);\n+        aux = new double[] { 6d, 7d };\n+        final TestVectorImpl y = new TestVectorImpl(aux);\n+        x.combine(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombine() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new TestVectorImpl(new double[dim]);\n+        final RealVector y = new TestVectorImpl(new double[dim]);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        final RealVector z = x.combine(a, b, y);\n+        Assert.assertTrue(z != x);\n+        final double[] actual = z.getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\", expected[i],\n+                                actual[i], delta);\n+        }\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCombineToSelfPrecondition() {\n+        final double a = 1d;\n+        final double b = 2d;\n+        double[] aux = new double[] { 3d, 4d, 5d };\n+        final TestVectorImpl x = new TestVectorImpl(aux);\n+        aux = new double[] { 6d, 7d };\n+        final TestVectorImpl y = new TestVectorImpl(aux);\n+        x.combineToSelf(a, b, y);\n+    }\n+\n+    @Test\n+    public void testCombineToSelf() {\n+        final Random random = new Random(20110726);\n+        final int dim = 10;\n+        final double a = (2 * random.nextDouble() - 1);\n+        final double b = (2 * random.nextDouble() - 1);\n+        final RealVector x = new TestVectorImpl(new double[dim]);\n+        final RealVector y = new TestVectorImpl(new double[dim]);\n+        final double[] expected = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            final double xi = 2 * random.nextDouble() - 1;\n+            final double yi = 2 * random.nextDouble() - 1;\n+            x.setEntry(i, xi);\n+            y.setEntry(i, yi);\n+            expected[i] = a * xi + b * yi;\n+        }\n+        Assert.assertSame(x, x.combineToSelf(a, b, y));\n+        final double[] actual = x.getData();\n+        for (int i = 0; i < dim; i++) {\n+            final double delta;\n+            if (expected[i] == 0d) {\n+                delta = Math.ulp(1d);\n+            } else {\n+                delta = Math.ulp(expected[i]);\n+            }\n+            Assert.assertEquals(\"elements [\" + i + \"] differ\", expected[i],\n+                                actual[i], delta);\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n \n     // Testclass to test the RealVector interface\n     // only with enough content to support the test\n-    public static class SparseRealVectorTestImpl extends AbstractRealVector implements Serializable {\n+    public static class SparseRealVectorTestImpl extends RealVector implements Serializable {\n \n         private static final long serialVersionUID = -6251371752518113791L;\n         /** Entries of the vector. */\n         }\n \n         @Override\n-        public AbstractRealVector copy() {\n+        public RealVector copy() {\n             return new SparseRealVectorTestImpl(data);\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/UnmodifiableRealVectorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/UnmodifiableRealVectorAbstractTest.java\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n-import java.util.ArrayList;\n+import java.util.Set;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Random;\n \n import org.junit.Test;\n \n /**\n- * This is an abstract test of the {@link AbstractRealVector.UnmodifiableVector}\n+ * This is an abstract test of the {@link\n+ * RealVector#unmodifiableRealVector(RealVector) unmodifiable vector}\n  * implementation. These unmodifiable vectors decorate a (modifiable)\n- * {@link RealVector}; therefore, a new implementation of this abstract test\n- * should be considered for each implementation of {@link RealVector}.\n+ * {@link RealVector}; therefore, a new implementation of this abstract\n+ * test should be considered for each implementation of\n+ * {@link RealVector}.\n  *\n  * @version $Id$\n  *\n      * The list of methods which are excluded from the general test\n      * {@link #testAllButExcluded()}.\n      */\n-    protected static final ArrayList<String> EXCLUDE;\n+    protected static final Set<String> EXCLUDE = new HashSet<String>();\n     /** The random number generator (always initialized with the same seed. */\n     protected static final Random RANDOM;\n \n     static {\n-        EXCLUDE = new ArrayList<String>();\n         EXCLUDE.add(\"getEntry\");\n         EXCLUDE.add(\"setEntry\");\n         EXCLUDE.add(\"getSubVector\");\n         EXCLUDE.add(\"setSubVector\");\n         EXCLUDE.add(\"iterator\");\n         EXCLUDE.add(\"sparseIterator\");\n+\n+        // Excluded because they are inherited from \"Object\".\n+        for (Method m : Object.class.getMethods()) {\n+            EXCLUDE.add(m.getName());\n+        }\n         RANDOM = new Random(20110813);\n     }\n \n \n     /**\n      * Creates a new random vector of a specified type. This vector is then to\n-     * be wrapped in a {@link AbstractRealVector.UnmodifiableVector}.\n+     * be wrapped in an unmodifiable vector.\n      *\n      * @return a new random vector.\n      */\n     /**\n      * Creates a new random object of the specified type.\n      *\n-     * @param c\n-     *            the class of the object to be created.\n+     * @param c Class of the object to be created.\n      * @return a new random object.\n-     * @throws IllegalArgumentException\n-     *             if the specified class is not recognized by this method.\n+     * @throws IllegalArgumentException if the specified class is not\n+     * recognized by this method.\n      */\n     public Object createParameter(final Class<?> c) {\n         if (c == Integer.TYPE) {\n     }\n \n     /**\n-     * This is the general test of most methods in\n-     * {@link AbstractRealVector.UnmodifiableVector}. It works as follows.\n+     * This is the general test of most methods in the\n+     * {@link RealVector#unmodifiableRealVector(RealVector) unmodifiable vector}.\n+     * It works as follows.\n      * First, an unmodifiable view of a copy of the specified random vector\n      * {@code u} is created: this defines {@code v}. Then the <em>same</em>\n      * method {@code m} is invoked on {@code u} and {@code v}, with randomly\n      *constructed.\n      * @param args Arguments to be passed to method {@code m}.\n      */\n-    private void callMethod(final Method m, final RealVector u,\n-            final Object... args) throws IllegalAccessException,\n-            IllegalArgumentException, InvocationTargetException {\n+    private void callMethod(final Method m,\n+                            final RealVector u,\n+                            final Object... args)\n+        throws IllegalAccessException,\n+               IllegalArgumentException,\n+               InvocationTargetException {\n         final RealVector uu = u.copy();\n-        final RealVector v = AbstractRealVector\n-                .unmodifiableRealVector(u.copy());\n+        final RealVector v = RealVector.unmodifiableRealVector(u.copy());\n         Object exp = m.invoke(u, args);\n         if (equals(uu, u)) {\n             Object act = m.invoke(v, args);\n-            Assert.assertTrue(m.toGenericString()\n-                    + \", unmodifiable vector has changed\", equals(uu, v));\n+            Assert.assertTrue(m.toGenericString() + \", unmodifiable vector has changed\",\n+                              equals(uu, v));\n             Assert.assertTrue(m.toGenericString() + \", wrong result\",\n-                    equals(exp, act));\n+                              equals(exp, act));\n \n         } else {\n             boolean flag = false;\n      * {@link #EXCLUDE}), they must be handled by separate tests.\n      */\n     @Test\n-    public void testAllButExcluded() throws IllegalAccessException,\n-            IllegalArgumentException, InvocationTargetException {\n+    public void testAllButExcluded()\n+        throws IllegalAccessException,\n+               IllegalArgumentException,\n+               InvocationTargetException {\n         Method[] method = RealVector.class.getMethods();\n         for (int i = 0; i < method.length; i++) {\n             Method m = method[i];\n     @Test\n     public void testGetEntry() {\n         RealVector u = createVector();\n-        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        RealVector v = RealVector.unmodifiableRealVector(u);\n         for (int i = 0; i < DIM; i++) {\n             Assert.assertTrue(equals(u.getEntry(i), v.getEntry(i)));\n         }\n     @Test(expected = MathUnsupportedOperationException.class)\n     public void testSetEntry() {\n         RealVector u = createVector();\n-        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        RealVector v = RealVector.unmodifiableRealVector(u);\n         for (int i = 0; i < DIM; i++) {\n             v.setEntry(i, 0d);\n         }\n     @Test\n     public void testGetSubVector() {\n         RealVector u = createVector();\n-        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        RealVector v = RealVector.unmodifiableRealVector(u);\n         for (int i = 0; i < DIM; i++) {\n             for (int n = 1; n < DIM - i; n++) {\n                 RealVector exp = u.getSubVector(i, n);\n     @Test(expected = MathUnsupportedOperationException.class)\n     public void testSetSubVector() {\n         RealVector u = createVector();\n-        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        RealVector v = RealVector.unmodifiableRealVector(u);\n         v.setSubVector(0, new ArrayRealVector());\n     }\n \n     public void testIterator() {\n         RealVector u = createVector();\n         Iterator<Entry> i = u.iterator();\n-        RealVector v = AbstractRealVector.unmodifiableRealVector(u.copy());\n+        RealVector v = RealVector.unmodifiableRealVector(u.copy());\n         Iterator<Entry> j = v.iterator();\n         boolean flag;\n         while (i.hasNext()) {\n     public void testSparseIterator() {\n         RealVector u = createVector();\n         Iterator<Entry> i = u.sparseIterator();\n-        RealVector v = AbstractRealVector.unmodifiableRealVector(u.copy());\n+        RealVector v = RealVector.unmodifiableRealVector(u.copy());\n         Iterator<Entry> j = v.sparseIterator();\n         boolean flag;\n         while (i.hasNext()) {", "timestamp": 1314536337, "metainfo": ""}