{"sha": "0646ef73314c526f792a667a1d951facf0e6d7d5", "log": "added a PolynomialsUtils class providing factory methods for Chebyshev, Hermite, Laguerre and Legendre polynomials the code was extracted from mantissa and modified  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+\n+/**\n+ * A collection of static methods that operate on or return polynomials.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class PolynomialsUtils {\n+\n+    /** Coefficients for Chebyshev polynomials. */\n+    private static final ArrayList<Fraction> CHEBYSHEV_COEFFICIENTS;\n+\n+    /** Coefficients for Hermite polynomials. */\n+    private static final ArrayList<Fraction> HERMITE_COEFFICIENTS;\n+\n+    /** Coefficients for Laguerre polynomials. */\n+    private static final ArrayList<Fraction> LAGUERRE_COEFFICIENTS;\n+\n+    /** Coefficients for Legendre polynomials. */\n+    private static final ArrayList<Fraction> LEGENDRE_COEFFICIENTS;\n+\n+    static {\n+\n+        // initialize recurrence for Chebyshev polynomials\n+        // T0(X) = 1, T1(X) = 0 + 1 * X\n+        CHEBYSHEV_COEFFICIENTS = new ArrayList<Fraction>();\n+        CHEBYSHEV_COEFFICIENTS.add(Fraction.ONE);\n+        CHEBYSHEV_COEFFICIENTS.add(Fraction.ZERO);\n+        CHEBYSHEV_COEFFICIENTS.add(Fraction.ONE);\n+\n+        // initialize recurrence for Hermite polynomials\n+        // H0(X) = 1, H1(X) = 0 + 2 * X\n+        HERMITE_COEFFICIENTS = new ArrayList<Fraction>();\n+        HERMITE_COEFFICIENTS.add(Fraction.ONE);\n+        HERMITE_COEFFICIENTS.add(Fraction.ZERO);\n+        HERMITE_COEFFICIENTS.add(Fraction.TWO);\n+\n+        // initialize recurrence for Laguerre polynomials\n+        // L0(X) = 1, L1(X) = 1 - 1 * X\n+        LAGUERRE_COEFFICIENTS = new ArrayList<Fraction>();\n+        LAGUERRE_COEFFICIENTS.add(Fraction.ONE);\n+        LAGUERRE_COEFFICIENTS.add(Fraction.ONE);\n+        LAGUERRE_COEFFICIENTS.add(Fraction.MINUS_ONE);\n+\n+        // initialize recurrence for Legendre polynomials\n+        // P0(X) = 1, P1(X) = 0 + 1 * X\n+        LEGENDRE_COEFFICIENTS = new ArrayList<Fraction>();\n+        LEGENDRE_COEFFICIENTS.add(Fraction.ONE);\n+        LEGENDRE_COEFFICIENTS.add(Fraction.ZERO);\n+        LEGENDRE_COEFFICIENTS.add(Fraction.ONE);\n+\n+    }\n+\n+    /**\n+     * Private constructor, to prevent instantiation.\n+     */\n+    private PolynomialsUtils() {\n+    }\n+\n+    /**\n+     * Create a Chebyshev polynomial of the first kind.\n+     * <p><a href=\"http://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html\">Chebyshev\n+     * polynomials of the first kind</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *  T<sub>0</sub>(X)   = 1\n+     *  T<sub>1</sub>(X)   = X\n+     *  T<sub>k+1</sub>(X) = 2X T<sub>k</sub>(X) - T<sub>k-1</sub>(X)\n+     * </pre></p>\n+     * @param degree degree of the polynomial\n+     * @return Chebyshev polynomial of specified degree\n+     */\n+    public static PolynomialFunction createChebyshevPolynomial(final int degree) {\n+        return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS,\n+                new RecurrenceCoefficientsGenerator() {\n+            private final Fraction[] coeffs = { Fraction.ZERO, Fraction.TWO, Fraction.ONE};\n+            /** {@inheritDoc} */\n+            public Fraction[] generate(int k) {\n+                return coeffs;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create a Hermite polynomial.\n+     * <p><a href=\"http://mathworld.wolfram.com/HermitePolynomial.html\">Hermite\n+     * polynomials</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *  H<sub>0</sub>(X)   = 1\n+     *  H<sub>1</sub>(X)   = 2X\n+     *  H<sub>k+1</sub>(X) = 2X H<sub>k</sub>(X) - 2k H<sub>k-1</sub>(X)\n+     * </pre></p>\n+\n+     * @param degree degree of the polynomial\n+     * @return Hermite polynomial of specified degree\n+     */\n+    public static PolynomialFunction createHermitePolynomial(final int degree) {\n+        return buildPolynomial(degree, HERMITE_COEFFICIENTS,\n+                new RecurrenceCoefficientsGenerator() {\n+            /** {@inheritDoc} */\n+            public Fraction[] generate(int k) {\n+                return new Fraction[] {\n+                        Fraction.ZERO,\n+                        Fraction.TWO,\n+                        new Fraction(2 * k, 1)};\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create a Laguerre polynomial.\n+     * <p><a href=\"http://mathworld.wolfram.com/LaguerrePolynomial.html\">Laguerre\n+     * polynomials</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *        L<sub>0</sub>(X)   = 1\n+     *        L<sub>1</sub>(X)   = 1 - X\n+     *  (k+1) L<sub>k+1</sub>(X) = (2k + 1 - X) L<sub>k</sub>(X) - k L<sub>k-1</sub>(X)\n+     * </pre></p>\n+     * @param degree degree of the polynomial\n+     * @return Laguerre polynomial of specified degree\n+     */\n+    public static PolynomialFunction createLaguerrePolynomial(final int degree) {\n+        return buildPolynomial(degree, LAGUERRE_COEFFICIENTS,\n+                new RecurrenceCoefficientsGenerator() {\n+            /** {@inheritDoc} */\n+            public Fraction[] generate(int k) {\n+                final int kP1 = k + 1;\n+                return new Fraction[] {\n+                        new Fraction(2 * k + 1, kP1),\n+                        new Fraction(-1, kP1),\n+                        new Fraction(k, kP1)};\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create a Legendre polynomial.\n+     * <p><a href=\"http://mathworld.wolfram.com/LegendrePolynomial.html\">Legendre\n+     * polynomials</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *        P<sub>0</sub>(X)   = 1\n+     *        P<sub>1</sub>(X)   = X\n+     *  (k+1) P<sub>k+1</sub>(X) = (2k+1) X P<sub>k</sub>(X) - k P<sub>k-1</sub>(X)\n+     * </pre></p>\n+     * @param degree degree of the polynomial\n+     * @return Legendre polynomial of specified degree\n+     */\n+    public static PolynomialFunction createLegendrePolynomial(final int degree) {\n+        return buildPolynomial(degree, LEGENDRE_COEFFICIENTS,\n+                               new RecurrenceCoefficientsGenerator() {\n+            /** {@inheritDoc} */\n+            public Fraction[] generate(int k) {\n+                final int kP1 = k + 1;\n+                return new Fraction[] {\n+                        Fraction.ZERO,\n+                        new Fraction(k + kP1, kP1),\n+                        new Fraction(k, kP1)};\n+            }\n+        });\n+    }\n+\n+    /** Get the coefficients array for a given degree.\n+     * @param degree degree of the polynomial\n+     * @param coefficients list where the computed coefficients are stored\n+     * @param generator recurrence coefficients generator\n+     * @return coefficients array\n+     */\n+    private static PolynomialFunction buildPolynomial(final int degree,\n+                                                      final ArrayList<Fraction> coefficients,\n+                                                      final RecurrenceCoefficientsGenerator generator) {\n+\n+        final int maxDegree = (int) Math.floor(Math.sqrt(2 * coefficients.size())) - 1;\n+        synchronized (PolynomialsUtils.class) {\n+            if (degree > maxDegree) {\n+                computeUpToDegree(degree, maxDegree, generator, coefficients);\n+            }\n+        }\n+\n+        // coefficient  for polynomial 0 is  l [0]\n+        // coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)\n+        // coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)\n+        // coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)\n+        // coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)\n+        // coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)\n+        // coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)\n+        // ...\n+        final int start = degree * (degree + 1) / 2;\n+\n+        final double[] a = new double[degree + 1];\n+        for (int i = 0; i <= degree; ++i) {\n+            a[i] = coefficients.get(start + i).doubleValue();\n+        }\n+\n+        // build the polynomial\n+        return new PolynomialFunction(a);\n+\n+    }\n+    \n+    /** Compute polynomial coefficients up to a given degree.\n+     * @param degree maximal degree\n+     * @param maxDegree current maximal degree\n+     * @param generator recurrence coefficients generator\n+     * @param coefficients list where the computed coefficients should be appended\n+     */\n+    private static void computeUpToDegree(final int degree, final int maxDegree,\n+                                          final RecurrenceCoefficientsGenerator generator,\n+                                          final ArrayList<Fraction> coefficients) {\n+\n+        int startK = (maxDegree - 1) * maxDegree / 2;\n+        for (int k = maxDegree; k < degree; ++k) {\n+\n+            // start indices of two previous polynomials Pk(X) and Pk-1(X)\n+            int startKm1 = startK;\n+            startK += k;\n+\n+            // Pk+1(X) = (a[0] + a[1] X) Pk(X) - a[2] Pk-1(X)\n+            Fraction[] ai = generator.generate(k);\n+\n+            Fraction ck     = coefficients.get(startK);\n+            Fraction ckm1   = coefficients.get(startKm1);\n+\n+            // degree 0 coefficient\n+            coefficients.add(ck.multiply(ai[0]).subtract(ckm1.multiply(ai[2])));\n+\n+            // degree 1 to degree k-1 coefficients\n+            for (int i = 1; i < k; ++i) {\n+                final Fraction ckPrev = ck;\n+                ck     = coefficients.get(startK + i);\n+                ckm1   = coefficients.get(startKm1 + i);\n+                coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])).subtract(ckm1.multiply(ai[2])));\n+            }\n+\n+            // degree k coefficient\n+            final Fraction ckPrev = ck;\n+            ck = coefficients.get(startK + k);\n+            coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])));\n+\n+            // degree k+1 coefficient\n+            coefficients.add(ck.multiply(ai[1]));\n+\n+        }\n+\n+    }\n+\n+    /** Interface for recurrence coefficients generation. */\n+    private static interface RecurrenceCoefficientsGenerator {\n+        /**\n+         * Generate recurrence coefficients.\n+         * @param k highest degree of the polynomials used in the recurrence\n+         * @return an array of three coefficients such that\n+         * P<sub>k+1</sub>(X) = (a[0] + a[1] X) P<sub>k</sub>(X) - a[2] P<sub>k-1</sub>(X)\n+         */\n+        Fraction[] generate(int k);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n  */\n public class Fraction extends Number implements Comparable<Fraction> {\n \n+    /** A fraction representing \"2 / 1\". */\n+    public static final Fraction TWO = new Fraction(2, 1);\n+\n     /** A fraction representing \"1 / 1\". */\n     public static final Fraction ONE = new Fraction(1, 1);\n \n     /** A fraction representing \"0 / 1\". */\n     public static final Fraction ZERO = new Fraction(0, 1);\n \n+    /** A fraction representing \"-1 / 1\". */\n+    public static final Fraction MINUS_ONE = new Fraction(-1, 1);\n+\n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -5731055832688548463L;\n-    \n+    private static final long serialVersionUID = 3071409609509774764L;\n+\n     /** The denominator. */\n     private final int denominator;\n     \n             return;\n         }\n \n-       long p0 = 1;\n+        long p0 = 1;\n         long q0 = 0;\n         long p1 = a0;\n         long q1 = 1;\n      * reduced to lowest terms.\n      * @param num the numerator.\n      * @param den the denominator.\n-     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n      */\n     public Fraction(int num, int den) {\n         super();\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/AllTests.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/AllTests.java\n     suite.addTest(RationalNumberTest.suite());\n     suite.addTest(PolynomialRationalTest.suite());\n     suite.addTest(PolynomialDoubleTest.suite());\n-    suite.addTest(ChebyshevTest.suite());\n-    suite.addTest(HermiteTest.suite());\n-    suite.addTest(LegendreTest.suite());\n-    suite.addTest(LaguerreTest.suite());\n     suite.addTest(PolynomialFractionTest.suite());\n \n     return suite; \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the PolynomialsUtils class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialsUtilsTest extends TestCase {\n+\n+    public void testFirstChebyshevPolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3), \"-3.0 x + 4.0 x^3\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2), \"-1.0 + 2.0 x^2\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1), \"x\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0), \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7), \"-7.0 x + 56.0 x^3 - 112.0 x^5 + 64.0 x^7\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6), \"-1.0 + 18.0 x^2 - 48.0 x^4 + 32.0 x^6\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5), \"5.0 x - 20.0 x^3 + 16.0 x^5\");\n+        checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4), \"1.0 - 8.0 x^2 + 8.0 x^4\");\n+\n+    }\n+\n+    public void testChebyshevBounds() {\n+        for (int k = 0; k < 12; ++k) {\n+            PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k);\n+            for (double x = -1.0; x <= 1.0; x += 0.02) {\n+                assertTrue(k + \" \" + Tk.value(x), Math.abs(Tk.value(x)) < (1.0 + 1.0e-12));\n+            }\n+        }\n+    }\n+\n+    public void testChebyshevDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Tk0 = PolynomialsUtils.createChebyshevPolynomial(k);\n+            PolynomialFunction Tk1 = Tk0.polynomialDerivative();\n+            PolynomialFunction Tk2 = Tk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * k });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -1});\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });\n+\n+            PolynomialFunction Tk0g0 = Tk0.multiply(g0);\n+            PolynomialFunction Tk1g1 = Tk1.multiply(g1);\n+            PolynomialFunction Tk2g2 = Tk2.multiply(g2);\n+\n+            checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2)));\n+\n+        }\n+    }\n+\n+    public void testFirstHermitePolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(3), \"-12.0 x + 8.0 x^3\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(2), \"-2.0 + 4.0 x^2\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(1), \"2.0 x\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(0), \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(7), \"-1680.0 x + 3360.0 x^3 - 1344.0 x^5 + 128.0 x^7\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(6), \"-120.0 + 720.0 x^2 - 480.0 x^4 + 64.0 x^6\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(5), \"120.0 x - 160.0 x^3 + 32.0 x^5\");\n+        checkPolynomial(PolynomialsUtils.createHermitePolynomial(4), \"12.0 - 48.0 x^2 + 16.0 x^4\");\n+\n+    }\n+\n+    public void testHermiteDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Hk0 = PolynomialsUtils.createHermitePolynomial(k);\n+            PolynomialFunction Hk1 = Hk0.polynomialDerivative();\n+            PolynomialFunction Hk2 = Hk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { 2 * k });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1 });\n+\n+            PolynomialFunction Hk0g0 = Hk0.multiply(g0);\n+            PolynomialFunction Hk1g1 = Hk1.multiply(g1);\n+            PolynomialFunction Hk2g2 = Hk2.multiply(g2);\n+\n+            checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2)));\n+\n+        }\n+    }\n+\n+    public void testFirstLaguerrePolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3), 6l, \"6.0 - 18.0 x + 9.0 x^2 - x^3\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2), 2l, \"2.0 - 4.0 x + x^2\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1), 1l, \"1.0 - x\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0), 1l, \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7), 5040l,\n+                \"5040.0 - 35280.0 x + 52920.0 x^2 - 29400.0 x^3\"\n+                + \" + 7350.0 x^4 - 882.0 x^5 + 49.0 x^6 - x^7\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6),  720l,\n+                \"720.0 - 4320.0 x + 5400.0 x^2 - 2400.0 x^3 + 450.0 x^4\"\n+                + \" - 36.0 x^5 + x^6\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5),  120l,\n+        \"120.0 - 600.0 x + 600.0 x^2 - 200.0 x^3 + 25.0 x^4 - x^5\");\n+        checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4),   24l,\n+        \"24.0 - 96.0 x + 72.0 x^2 - 16.0 x^3 + x^4\");\n+\n+    }\n+\n+    public void testLaguerreDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Lk0 = PolynomialsUtils.createLaguerrePolynomial(k);\n+            PolynomialFunction Lk1 = Lk0.polynomialDerivative();\n+            PolynomialFunction Lk2 = Lk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { k });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 1, -1 });\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 0, 1 });\n+\n+            PolynomialFunction Lk0g0 = Lk0.multiply(g0);\n+            PolynomialFunction Lk1g1 = Lk1.multiply(g1);\n+            PolynomialFunction Lk2g2 = Lk2.multiply(g2);\n+\n+            checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2)));\n+\n+        }\n+    }\n+\n+    public void testFirstLegendrePolynomials() {\n+\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3),  2l, \"-3.0 x + 5.0 x^3\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2),  2l, \"-1.0 + 3.0 x^2\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1),  1l, \"x\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0),  1l, \"1.0\");\n+\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7), 16l, \"-35.0 x + 315.0 x^3 - 693.0 x^5 + 429.0 x^7\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6), 16l, \"-5.0 + 105.0 x^2 - 315.0 x^4 + 231.0 x^6\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5),  8l, \"15.0 x - 70.0 x^3 + 63.0 x^5\");\n+        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4),  8l, \"3.0 - 30.0 x^2 + 35.0 x^4\");\n+\n+    }\n+\n+    public void testLegendreDifferentials() {\n+        for (int k = 0; k < 12; ++k) {\n+\n+            PolynomialFunction Pk0 = PolynomialsUtils.createLegendrePolynomial(k);\n+            PolynomialFunction Pk1 = Pk0.polynomialDerivative();\n+            PolynomialFunction Pk2 = Pk1.polynomialDerivative();\n+\n+            PolynomialFunction g0 = new PolynomialFunction(new double[] { k * (k + 1) });\n+            PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 });\n+            PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 });\n+\n+            PolynomialFunction Pk0g0 = Pk0.multiply(g0);\n+            PolynomialFunction Pk1g1 = Pk1.multiply(g1);\n+            PolynomialFunction Pk2g2 = Pk2.multiply(g2);\n+\n+            checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2)));\n+\n+        }\n+    }\n+\n+    public void testHighDegreeLegendre() {\n+        try {\n+            PolynomialsUtils.createLegendrePolynomial(40);\n+            fail(\"an exception should have been thrown\");\n+        } catch (ArithmeticException ae) {\n+            // expected\n+        }\n+//        checkPolynomial(PolynomialsUtils.createLegendrePolynomial(40), 274877906944l,\n+//                        \"34461632205.0\"\n+//                      + \" - 28258538408100.0 x^2\"\n+//                      + \" + 3847870979902950.0 x^4\"\n+//                      + \" - 207785032914759300.0 x^6\"\n+//                      + \" + 5929294332103310025.0 x^8\"\n+//                      + \" - 103301483474866556880.0 x^10\"\n+//                      + \" + 1197358103913226000200.0 x^12\"\n+//                      + \" - 9763073770369381232400.0 x^14\"\n+//                      + \" + 58171647881784229843050.0 x^16\"\n+//                      + \" - 260061484647976556945400.0 x^18\"\n+//                      + \" + 888315281771246239250340.0 x^20\"\n+//                      + \" - 2345767627188139419665400.0 x^22\"\n+//                      + \" + 4819022625419112503443050.0 x^24\"\n+//                      + \" - 7710436200670580005508880.0 x^26\"\n+//                      + \" + 9566652323054238154983240.0 x^28\"\n+//                      + \" - 9104813935044723209570256.0 x^30\"\n+//                      + \" + 6516550296251767619752905.0 x^32\"\n+//                      + \" - 3391858621221953912598660.0 x^34\"\n+//                      + \" + 1211378079007840683070950.0 x^36\"\n+//                      + \" - 265365894974690562152100.0 x^38\"\n+//                      + \" + 26876802183334044115405.0 x^40\");\n+    }\n+\n+    private void checkPolynomial(PolynomialFunction p, long denominator, String reference) {\n+        PolynomialFunction q = new PolynomialFunction(new double[] { denominator});\n+        assertEquals(reference, p.multiply(q).toString());\n+    }\n+\n+    private void checkPolynomial(PolynomialFunction p, String reference) {\n+        assertEquals(reference, p.toString());\n+    }\n+\n+    private void checkNullPolynomial(PolynomialFunction p) {\n+        for (double coefficient : p.getCoefficients()) {\n+            assertEquals(0.0, coefficient, 1.0e-13);\n+        }\n+    }\n+\n+}", "timestamp": 1233522835, "metainfo": ""}