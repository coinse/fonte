{"sha": "ba97018855851acc627871d5660054a3d1bba8c0", "log": "fixed wrong results in Loess interpolator also added a way to set weights for smoothing JIRA: MATH-296  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n       \"toutes les abscisses doivent \\u00eatre des nombres r\\u00e9els finis, mais l''abscisse {0} vaut {1}\" },\n     { \"all ordinatae must be finite real numbers, but {0}-th is {1}\",\n       \"toutes les ordonn\\u00e9es doivent \\u00eatre des nombres r\\u00e9els finis, mais l''ordonn\\u00e9e {0} vaut {1}\" },\n+    { \"all weights must be finite real numbers, but {0}-th is {1}\",\n+      \"tous les poids doivent \\u00eatre des nombres r\\u00e9els finis, mais le poids {0} vaut {1}\" },\n     { \"the abscissae array must be sorted in a strictly increasing order, \" +\n       \"but the {0}-th element is {1} whereas {2}-th is {3}\",\n       \"les abscisses doivent \\u00eatre en ordre strictement croissant, \" +\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n     /** Default value of the number of robustness iterations. */\n     public static final int DEFAULT_ROBUSTNESS_ITERS = 2;\n \n+    /** Default value for accuracy. */\n+    public static final double DEFAULT_ACCURACY = 1e-12;\n+\n     /** serializable version identifier. */\n     private static final long serialVersionUID = 5204927143605193821L;\n \n     private final int robustnessIters;\n \n     /**\n+     * If the median residual at a certain robustness iteration\n+     * is less than this amount, no more iterations are done.\n+     */\n+    private final double accuracy;\n+\n+    /**\n      * Constructs a new {@link LoessInterpolator}\n-     * with a bandwidth of {@link #DEFAULT_BANDWIDTH} and\n-     * {@link #DEFAULT_ROBUSTNESS_ITERS} robustness iterations.\n-     * See {@link #LoessInterpolator(double, int)} for an explanation of\n+     * with a bandwidth of {@link #DEFAULT_BANDWIDTH},\n+     * {@link #DEFAULT_ROBUSTNESS_ITERS} robustness iterations\n+     * and an accuracy of {#link #DEFAULT_ACCURACY}.\n+     * See {@link #LoessInterpolator(double, int, double)} for an explanation of\n      * the parameters.\n      */\n     public LoessInterpolator() {\n         this.bandwidth = DEFAULT_BANDWIDTH;\n         this.robustnessIters = DEFAULT_ROBUSTNESS_ITERS;\n+        this.accuracy = DEFAULT_ACCURACY;\n     }\n \n     /**\n      * Constructs a new {@link LoessInterpolator}\n      * with given bandwidth and number of robustness iterations.\n+     * <p>\n+     * Calling this constructor is equivalent to calling {link {@link\n+     * #LoessInterpolator(double, int, double) LoessInterpolator(bandwidth,\n+     * robustnessIters, LoessInterpolator.DEFAULT_ACCURACY)}\n+     * </p>\n      *\n      * @param bandwidth  when computing the loess fit at\n      * a particular point, this fraction of source points closest\n      * {@link #DEFAULT_ROBUSTNESS_ITERS}.\n      * @throws MathException if bandwidth does not lie in the interval [0,1]\n      * or if robustnessIters is negative.\n+     * @see #LoessInterpolator(double, int, double)\n      */\n     public LoessInterpolator(double bandwidth, int robustnessIters) throws MathException {\n+        this(bandwidth, robustnessIters, DEFAULT_ACCURACY);\n+    }\n+\n+    /**\n+     * Constructs a new {@link LoessInterpolator}\n+     * with given bandwidth, number of robustness iterations and accuracy.\n+     *\n+     * @param bandwidth  when computing the loess fit at\n+     * a particular point, this fraction of source points closest\n+     * to the current point is taken into account for computing\n+     * a least-squares regression.</br>\n+     * A sensible value is usually 0.25 to 0.5, the default value is\n+     * {@link #DEFAULT_BANDWIDTH}.\n+     * @param robustnessIters This many robustness iterations are done.</br>\n+     * A sensible value is usually 0 (just the initial fit without any\n+     * robustness iterations) to 4, the default value is\n+     * {@link #DEFAULT_ROBUSTNESS_ITERS}.\n+     * @param accuracy If the median residual at a certain robustness iteration\n+     * is less than this amount, no more iterations are done.\n+     * @throws MathException if bandwidth does not lie in the interval [0,1]\n+     * or if robustnessIters is negative.\n+     * @see #LoessInterpolator(double, int)\n+     * @since 2.1\n+     */\n+    public LoessInterpolator(double bandwidth, int robustnessIters, double accuracy) throws MathException {\n         if (bandwidth < 0 || bandwidth > 1) {\n             throw new MathException(\"bandwidth must be in the interval [0,1], but got {0}\",\n                                     bandwidth);\n                                     robustnessIters);\n         }\n         this.robustnessIters = robustnessIters;\n+        this.accuracy = accuracy;\n     }\n \n     /**\n     }\n \n     /**\n-     * Compute a loess fit on the data at the original abscissae.\n+     * Compute a weighted loess fit on the data at the original abscissae.\n      *\n      * @param xval the arguments for the interpolation points\n      * @param yval the values for the interpolation points\n+     * @param weights point weights: coefficients by which the robustness weight of a point is multiplied\n      * @return values of the loess fit at corresponding original abscissae\n      * @throws MathException if some of the following conditions are false:\n      * <ul>\n      * <li> The arguments are in a strictly increasing order</li>\n      * <li> All arguments and values are finite real numbers</li>\n      * </ul>\n-     */\n-    public final double[] smooth(final double[] xval, final double[] yval)\n+     * @since 2.1\n+     */\n+    public final double[] smooth(final double[] xval, final double[] yval, final double[] weights)\n             throws MathException {\n         if (xval.length != yval.length) {\n             throw new MathException(\n             throw new MathException(\"Loess expects at least 1 point\");\n         }\n \n-        checkAllFiniteReal(xval, true);\n-        checkAllFiniteReal(yval, false);\n+        checkAllFiniteReal(xval, \"all abscissae must be finite real numbers, but {0}-th is {1}\");\n+        checkAllFiniteReal(yval, \"all ordinatae must be finite real numbers, but {0}-th is {1}\");\n+        checkAllFiniteReal(weights, \"all weights must be finite real numbers, but {0}-th is {1}\");\n \n         checkStrictlyIncreasing(xval);\n \n                     final double xk   = xval[k];\n                     final double yk   = yval[k];\n                     final double dist = (k < i) ? x - xk : xk - x;\n-                    final double w    = tricube(dist * denom) * robustnessWeights[k];\n+                    final double w    = tricube(dist * denom) * robustnessWeights[k] * weights[k];\n                     final double xkw  = xk * w;\n                     sumWeights += w;\n                     sumX += xkw;\n                 final double meanXSquared = sumXSquared / sumWeights;\n \n                 final double beta;\n-                if (meanXSquared == meanX * meanX) {\n+                if (Math.sqrt(Math.abs(meanXSquared - meanX * meanX)) < accuracy) {\n                     beta = 0;\n                 } else {\n                     beta = (meanXY - meanX * meanY) / (meanXSquared - meanX * meanX);\n             Arrays.sort(sortedResiduals);\n             final double medianResidual = sortedResiduals[n / 2];\n \n-            if (medianResidual == 0) {\n+            if (Math.abs(medianResidual) < accuracy) {\n                 break;\n             }\n \n             for (int i = 0; i < n; ++i) {\n                 final double arg = residuals[i] / (6 * medianResidual);\n-                robustnessWeights[i] = (arg >= 1) ? 0 : Math.pow(1 - arg * arg, 2);\n+                if (arg >= 1) {\n+                    robustnessWeights[i] = 0;\n+                } else {\n+                    final double w = 1 - arg * arg;\n+                    robustnessWeights[i] = w * w;\n+                }\n             }\n         }\n \n         return res;\n     }\n+\n+    /**\n+     * Compute a loess fit on the data at the original abscissae.\n+     *\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return values of the loess fit at corresponding original abscissae\n+     * @throws MathException if some of the following conditions are false:\n+     * <ul>\n+     * <li> Arguments and values are of the same size that is greater than zero</li>\n+     * <li> The arguments are in a strictly increasing order</li>\n+     * <li> All arguments and values are finite real numbers</li>\n+     * </ul>\n+     */\n+    public final double[] smooth(final double[] xval, final double[] yval)\n+            throws MathException {\n+\n+        final double[] unitWeights = new double[xval.length];\n+        Arrays.fill(unitWeights, 1.0);\n+\n+        return smooth(xval, yval, unitWeights);\n+\n+    }\n+\n \n     /**\n      * Given an index interval into xval that embraces a certain number of\n      * Check that all elements of an array are finite real numbers.\n      *\n      * @param values the values array\n-     * @param isAbscissae if true, elements are abscissae otherwise they are ordinatae\n-     * @throws MathException if one of the values is not\n-     *         a finite real number\n-     */\n-    private static void checkAllFiniteReal(final double[] values, final boolean isAbscissae)\n+     * @param pattern pattern of the error message\n+     * @throws MathException if one of the values is not a finite real number\n+     */\n+    private static void checkAllFiniteReal(final double[] values, final String pattern)\n         throws MathException {\n         for (int i = 0; i < values.length; i++) {\n             final double x = values[i];\n             if (Double.isInfinite(x) || Double.isNaN(x)) {\n-                final String pattern = isAbscissae ?\n-                        \"all abscissae must be finite real numbers, but {0}-th is {1}\" :\n-                        \"all ordinatae must be finite real numbers, but {0}-th is {1}\";\n                 throw new MathException(pattern, i, x);\n             }\n         }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n         new LoessInterpolator(1.1, 3);\n     }\n \n+    @Test\n+    public void testMath296withoutWeights() throws MathException {\n+        double[] xval = {\n+                0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n+                 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0};\n+        double[] yval = {\n+                0.47, 0.48, 0.55, 0.56, -0.08, -0.04, -0.07, -0.07,\n+                -0.56, -0.46, -0.56, -0.52, -3.03, -3.08, -3.09,\n+                -3.04, 3.54, 3.46, 3.36, 3.35};\n+        // Output from R, rounded to .001\n+        double[] yref = {\n+                0.461, 0.499, 0.541, 0.308, 0.175, -0.042, -0.072,\n+                -0.196, -0.311, -0.446, -0.557, -1.497, -2.133,\n+                -3.08, -3.09, -0.621, 0.982, 3.449, 3.389, 3.336\n+        };\n+        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);\n+        double[] res = li.smooth(xval, yval);\n+        Assert.assertEquals(xval.length, res.length);\n+        for(int i = 0; i < res.length; ++i) {\n+            Assert.assertEquals(yref[i], res[i], 0.02);\n+        }\n+    }\n+\n+    @Test\n+    public void testMath296withWeights() throws MathException {\n+        double[] xval = {\n+                0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n+                 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0};\n+        double[] yval = {\n+                0.47, 0.48, 0.55, 0.56, -0.08, -0.04, -0.07, -0.07,\n+                -0.56, -0.46, -0.56, -0.52, -3.03, -3.08, -3.09,\n+                -3.04, 3.54, 3.46, 3.36, 3.35};\n+        double[] weights = {\n+                1,1,1,1,1,1,1,1,1,1,\n+                1,1,0,0,1,1,0,0,1,1};\n+        // Output from R, rounded to .001\n+        double[] yref = {\n+                0.478, 0.492, 0.484, 0.320, 0.179, -0.003, -0.088, -0.209,\n+                -0.327, -0.455, -0.518, -0.537, -1.492, -2.115, -3.09, -3.04,\n+                -3.0, 0.155, 1.752, 3.35};\n+        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);\n+        double[] res = li.smooth(xval, yval,weights);\n+        Assert.assertEquals(xval.length, res.length);\n+        for(int i = 0; i < res.length; ++i) {\n+            Assert.assertEquals(yref[i], res[i], 0.05);\n+        }\n+    }\n+\n     private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {\n         double dx = 2 * Math.PI / xval.length;\n         double x = 0;", "timestamp": 1253903614, "metainfo": ""}