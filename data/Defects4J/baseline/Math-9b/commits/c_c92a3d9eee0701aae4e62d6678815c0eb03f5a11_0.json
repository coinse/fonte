{"sha": "c92a3d9eee0701aae4e62d6678815c0eb03f5a11", "log": "added protection against infinite loops by setting a maximal number of evaluations (some classes were forgotten in the first pass to fix this problem)  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n      */\n     int getIterations();\n \n+    /** Set the maximal number of functions evaluations.\n+     * @param maxEvaluations maximal number of function evaluations\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    int getMaxEvaluations();\n+\n     /** Get the number of evaluations of the objective function.\n      * <p>\n      * The number of evaluations corresponds to the last call to the\n--- a/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n      * @return number of iterations\n     */\n    int getIterations();\n+\n+   /** Set the maximal number of functions evaluations.\n+    * @param maxEvaluations maximal number of function evaluations\n+    */\n+   void setMaxEvaluations(int maxEvaluations);\n+\n+   /** Get the maximal number of functions evaluations.\n+    * @return maximal number of functions evaluations\n+    */\n+   int getMaxEvaluations();\n \n     /** Get the number of evaluations of the objective function.\n      * <p>\n--- a/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n     /** Number of iterations already performed for all starts. */\n     private int totalIterations;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n     /** Number of evaluations already performed for all starts. */\n     private int totalEvaluations;\n \n                                                              final int starts,\n                                                              final RandomVectorGenerator generator) {\n         this.optimizer                = optimizer;\n-        this.maxIterations            = Integer.MAX_VALUE;\n         this.totalIterations          = 0;\n         this.totalEvaluations         = 0;\n         this.totalGradientEvaluations = 0;\n         this.starts                   = starts;\n         this.generator                = generator;\n         this.optima                   = null;\n+        setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** Get all the optima found during the last call to {@link\n     }\n \n     /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getEvaluations() {\n         return totalEvaluations;\n     }\n \n             try {\n                 optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                 optima[i] = optimizer.optimize(f, goalType,\n                                                (i == 0) ? startPoint : generator.nextVector());\n             } catch (FunctionEvaluationException fee) {\n--- a/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n     /** Number of iterations already performed for all starts. */\n     private int totalIterations;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n     /** Number of evaluations already performed for all starts. */\n     private int totalEvaluations;\n \n                 final int starts,\n                 final RandomVectorGenerator generator) {\n         this.optimizer                = optimizer;\n-        this.maxIterations            = Integer.MAX_VALUE;\n         this.totalIterations          = 0;\n         this.totalEvaluations         = 0;\n         this.totalJacobianEvaluations = 0;\n         this.starts                   = starts;\n         this.generator                = generator;\n         this.optima                   = null;\n+        setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** Get all the optima found during the last call to {@link\n     }\n \n     /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getEvaluations() {\n         return totalEvaluations;\n     }\n \n             try {\n                 optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                 optima[i] = optimizer.optimize(f, target, weights,\n                                                (i == 0) ? startPoint : generator.nextVector());\n             } catch (FunctionEvaluationException fee) {\n--- a/src/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n                                                final int starts,\n                                                final RandomVectorGenerator generator) {\n         this.optimizer        = optimizer;\n-        this.maxIterations    = Integer.MAX_VALUE;\n         this.totalIterations  = 0;\n         this.totalEvaluations = 0;\n         this.starts           = starts;\n         this.generator        = generator;\n         this.optima           = null;\n+        setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** Get all the optima found during the last call to {@link\n--- a/src/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n     /** Maximal number of iterations allowed. */\n     private int maxIterations;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n     /** Number of iterations already performed for all starts. */\n     private int totalIterations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n \n     /** Number of starts to go. */\n     private int starts;\n                                              final int starts,\n                                              final RandomGenerator generator) {\n         this.optimizer        = optimizer;\n-        this.maxIterations    = Integer.MAX_VALUE;\n         this.totalIterations  = 0;\n         this.starts           = starts;\n         this.generator        = generator;\n         this.optima           = null;\n+        setMaximalIterationCount(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n     public double getRelativeAccuracy() {\n         return optimizer.getRelativeAccuracy();\n     }\n     /** {@inheritDoc} */\n     public void setMaximalIterationCount(int count) {\n         this.maxIterations = count;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n     }\n \n     /** {@inheritDoc} */\n                            final double min, final double max, final double startValue)\n             throws ConvergenceException, FunctionEvaluationException {\n \n-        optima          = new double[starts];\n-        totalIterations = 0;\n+        optima           = new double[starts];\n+        totalIterations  = 0;\n+        totalEvaluations = 0;\n \n         // multi-start loop\n         for (int i = 0; i < starts; ++i) {\n \n             try {\n                 optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                 optima[i] = optimizer.optimize(f, goalType, min, max,\n                                                (i == 0) ? startValue : generator.nextDouble() * (max - min));\n             } catch (FunctionEvaluationException fee) {\n             }\n \n             totalIterations  += optimizer.getIterationCount();\n+            totalEvaluations += optimizer.getEvaluations();\n \n         }\n \n--- a/src/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n  * @since 2.0\n  */\n public interface UnivariateRealOptimizer extends ConvergingAlgorithm {\n+\n+    /** Set the maximal number of functions evaluations.\n+     * @param maxEvaluations maximal number of function evaluations\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n \n     /**\n      * Find an optimum in the given interval.\n--- a/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n     /** Maximal number of iterations allowed. */\n     private int maxIterations;\n \n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n     /** Maximal number of evaluations allowed. */\n     private int maxEvaluations;\n-\n-    /** Number of iterations already performed. */\n-    private int iterations;\n \n     /** Number of evaluations already performed. */\n     private int evaluations;\n      * function evaluations</p>\n      * @param x point on which the objective function should be evaluated\n      * @return objective function value at the given point\n-     * @exception FunctionEvaluationException if no value can be computed for the parameters\n+     * @exception FunctionEvaluationException if no value can be computed for the\n+     * parameters or if the maximal number of evaluations is exceeded\n      * @exception IllegalArgumentException if the start point dimension is wrong\n-     * @exception OptimizationException if the maximal number of evaluations is exceeded\n      */\n     protected double evaluate(final double[] x)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException, IllegalArgumentException {\n         if (++evaluations > maxEvaluations) {\n-            throw new OptimizationException(new MaxEvaluationsExceededException(maxEvaluations));\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  x);\n         }\n         return f.value(x);\n     }\n         if (n != startConfiguration.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"dimension mismatch {0} != {1}\",\n-                    n, simplex.length);\n+                    n, startConfiguration.length);\n         }\n \n         // set first vertex\n--- a/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n     /** Number of iterations already performed. */\n     private int iterations;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n     /** Number of evaluations already performed. */\n     private int objectiveEvaluations;\n \n     protected AbstractLeastSquaresOptimizer() {\n         setConvergenceChecker(new SimpleVectorialValueChecker());\n         setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public int getIterations() {\n         return iterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n     }\n \n     /** {@inheritDoc} */\n     protected void incrementIterationsCounter()\n         throws OptimizationException {\n         if (++iterations > maxIterations) {\n-            if (++iterations > maxIterations) {\n-                throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n-            }\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n         }\n     }\n \n     /** \n      * Update the residuals array and cost function value.\n      * @exception FunctionEvaluationException if the function cannot be evaluated\n-     * or its dimension doesn't match problem dimension\n+     * or its dimension doesn't match problem dimension or maximal number of\n+     * of evaluations is exceeded\n      */\n     protected void updateResidualsAndCost()\n         throws FunctionEvaluationException {\n \n-        ++objectiveEvaluations;\n+        if (++objectiveEvaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  point);\n+        }\n         objective = f.value(point);\n         if (objective.length != rows) {\n             throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n--- a/src/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n  * @since 2.0\n  */\n public abstract class AbstractScalarDifferentiableOptimizer\n-    implements DifferentiableMultivariateRealOptimizer{\n+    implements DifferentiableMultivariateRealOptimizer {\n \n     /** Default maximal number of iterations allowed. */\n     public static final int DEFAULT_MAX_ITERATIONS = 100;\n \n     /** Number of iterations already performed. */\n     private int iterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n \n     /** Number of evaluations already performed. */\n     private int evaluations;\n     protected AbstractScalarDifferentiableOptimizer() {\n         setConvergenceChecker(new SimpleScalarValueChecker());\n         setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public int getIterations() {\n         return iterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n     }\n \n     /** {@inheritDoc} */\n     protected void incrementIterationsCounter()\n         throws OptimizationException {\n         if (++iterations > maxIterations) {\n-            if (++iterations > maxIterations) {\n-                throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n-            }\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n         }\n     }\n \n      * @param point point at which the objective function must be evaluated\n      * @return objective function value at specified point\n      * @exception FunctionEvaluationException if the function cannot be evaluated\n-     * or its dimension doesn't match problem dimension\n+     * or its dimension doesn't match problem dimension or the maximal number\n+     * of iterations is exceeded\n      */\n     protected double computeObjectiveValue(final double[] point)\n         throws FunctionEvaluationException {\n-        ++evaluations;\n+        if (++evaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  point);\n+        }\n         return f.value(point);\n     }\n \n--- a/src/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n     protected void incrementIterationsCounter()\n         throws OptimizationException {\n         if (++iterations > maxIterations) {\n-            if (++iterations > maxIterations) {\n-                throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n-            }\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n         }\n     }\n \n         this.goalType              = goalType;\n         this.restrictToNonNegative = restrictToNonNegative;\n \n-        iterations = 0;\n+        iterations  = 0;\n \n         // solve the problem\n         return doOptimize();\n--- a/src/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.ConvergingAlgorithmImpl;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n \n /**\n     /** Value of the function at the last computed result. */\n     protected double functionValue;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n     /**\n      * Construct a solver with given iteration count and accuracy.\n-     * \n+     * FunctionEvaluationExceptionFunctionEvaluationException\n      * @param defaultAbsoluteAccuracy maximum absolute error\n      * @param defaultMaximalIterationCount maximum number of iterations\n      * @throws IllegalArgumentException if f is null or the \n                                               final double defaultAbsoluteAccuracy) {\n         super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n         resultComputed = false;\n+        setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** Check if a result has been computed.\n         this.resultComputed = false;\n     }\n \n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /** \n+     * Compute the objective function value.\n+     * @param point point at which the objective function must be evaluated\n+     * @return objective function value at specified point\n+     * @exception FunctionEvaluationException if the function cannot be evaluated\n+     * or the maximal number of iterations is exceeded\n+     */\n+    protected double computeObjectiveValue(final UnivariateRealFunction f,\n+                                           final double point)\n+        throws FunctionEvaluationException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  point);\n+        }\n+        return f.value(point);\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n         double v = x;\n         double w = x;\n         double e = 0;\n-        double fx = f.value(x);\n+        double fx = computeObjectiveValue(f, x);\n         if (goalType == GoalType.MAXIMIZE) {\n             fx = -fx;\n         }\n \n                 // f must not be evaluated too close to a or b.\n                 u = x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));\n-                double fu = f.value(u);\n+                double fu = computeObjectiveValue(f, u);\n                 if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                 }\n--- a/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n           optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1.0, 1.0e-3));\n           optimizer.setMaxEvaluations(20);\n           optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3.0, -1.0, 0.0, 1.0 });\n-      } catch (OptimizationException oe) {\n-          if (oe.getCause() instanceof ConvergenceException) {\n-              throw (ConvergenceException) oe.getCause();\n+      } catch (FunctionEvaluationException fee) {\n+          if (fee.getCause() instanceof ConvergenceException) {\n+              throw (ConvergenceException) fee.getCause();\n           }\n-          throw oe;\n+          throw fee;\n       }\n   }\n ", "timestamp": 1245412994, "metainfo": ""}