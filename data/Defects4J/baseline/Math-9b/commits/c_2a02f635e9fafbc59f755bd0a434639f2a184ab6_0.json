{"sha": "2a02f635e9fafbc59f755bd0a434639f2a184ab6", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=21313 Submitted by:\tbrent@worden.org   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Provide the bisection algorithm for solving for zeros of real univariate\n+ * functions.  It will only search for one zero in the given interval.  The\n+ * function is supposed to be continuous but not necessarily smooth.\n+ *  \n+ * @author Brent Worden\n+ */\n+public class BisectionSolver extends UnivariateRealSolverImpl {\n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     */\n+    public BisectionSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Solve for a zero in the given interval.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param initial the start value to use (ignored).\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max, double initial)\n+        throws MathException {\n+            \n+        return solve(min, max);\n+    }\n+    \n+    /**\n+     * Solve for a zero root in the given interval.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max) throws MathException {\n+        clearResult();\n+\n+        double m;\n+        double fm;\n+        double fmin;\n+        \n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            m = midpoint(min, max);\n+            fmin = f.value(min);\n+            fm = f.value(m);\n+\n+            if (fm * fmin > 0.0) {\n+                // max and m bracket the root.\n+                min = m;\n+                fmin = fm;\n+            } else {\n+                // min and m bracket the root.\n+                max = m;\n+            }\n+\n+            if (Math.abs(max - min) <= absoluteAccuracy) {\n+                m = midpoint(min, max);\n+                setResult(m, i);\n+                return m;\n+            }\n+            ++i;\n+        }\n+        \n+        throw new MathException(\"Maximal iteration number exceeded\");\n+    }\n+\n+    /**\n+     * Compute the midpoint of two values.\n+     * @param a first value.\n+     * @param b second value.\n+     * @return the midpoint. \n+     */\n+    public static double midpoint(double a, double b) {\n+        return (a + b) * .5;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n  * @author pietsch at apache.org\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n-\n-    private UnivariateRealFunction f;\n-\n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     */\n     public BrentSolver(UnivariateRealFunction f) {\n-        super(100, 1E-6);\n-        this.f = f;\n+        super(f, 100, 1E-6);\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double)\n+    /**\n+     * Solve for a zero in the given interval.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param initial the start value to use (ignored).\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max, double initial)\n+        throws MathException {\n+            \n+        return solve(min, max);\n+    }\n+    \n+    /**\n+     * Solve for a zero root in the given interval.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n      */\n     public double solve(double min, double max) throws MathException {\n         clearResult();\n                 setResult(x1, i);\n                 return result;\n             }\n-//          System.out.println(\n-//              \" x0=\"\n-//                  + x0\n-//                  + \" y0=\"\n-//                  + y0\n-//                  + \" x1=\"\n-//                  + x1\n-//                  + \" y1=\"\n-//                  + y1\n-//                  + \" x2=\"\n-//                  + x2+\" y2=\"+y2);\n-//            System.out.println(\" dx=\"+dx+\"   delta: \"+delta+\"   olddelta: \"+oldDelta);\n             if (Math.abs(oldDelta) < tolerance\n                 || Math.abs(y0) <= Math.abs(y1)) {\n-//                    System.out.println(\"bisection\");\n                 // Force bisection.\n                 delta = 0.5 * dx;\n                 oldDelta = delta;\n                 double p1;\n                 if (x0 == x2) {\n                     // Linear interpolation.\n-//                    System.out.println(\"linear\");\n                     p = dx * r3;\n                     p1 = 1.0 - r3;\n                 } else {\n                     // Inverse quadratic interpolation.\n-//                    System.out.println(\"invers quad\");\n                     double r1 = y0 / y2;\n                     double r2 = y1 / y2;\n                     p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                 } else {\n                     p = -p;\n                 }\n-//                System.out.println(\"  p=\"+p+\" p1=\"+p1+\" qq: \"+(1.5 * dx * p1 - Math.abs(tolerance * p1)));\n-//                System.out.println(\"  p=\"+p+\" q: \"+p1+\" ad=\"+Math.abs(0.5 * oldDelta * p1));\n                 if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1)\n                     || p >= Math.abs(0.5 * oldDelta * p1)) {\n                     // Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n-//                    System.out.println(\"bisection fallback\");\n                     delta = 0.5 * dx;\n                     oldDelta = delta;\n                 } else {\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n-                x1 = x1 + 0.5*tolerance;\n+                x1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5*tolerance;\n+                x1 = x1 - 0.5 * tolerance;\n             }\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n         }\n         throw new MathException(\"Maximal iteration number exceeded.\");\n     }\n-\n }\n--- a/src/java/org/apache/commons/math/analysis/RootFinding.java\n+++ b/src/java/org/apache/commons/math/analysis/RootFinding.java\n  */\n package org.apache.commons.math.analysis;\n \n+import org.apache.commons.math.MathException;\n+\n /**\n  * Utility class comprised of root finding techniques.\n  *\n      * @param function the function\n      * @param initial midpoint of the returned range.\n      * @param lowerBound for numerical safety, a never is less than this value.\n-     * @param upperBound for numerical safety, b never is greater than this value.\n+     * @param upperBound for numerical safety, b never is greater than this\n+     *                   value.\n      * @return a two element array holding {a, b}.\n+     * @throws MathException if a root can not be bracketted.\n      */\n-    public static double[] bracket(UnivariateFunction function,\n+    public static double[] bracket(UnivariateRealFunction function,\n                                    double initial,\n                                    double lowerBound,\n-                                   double upperBound) {\n-        return bracket( function, initial, lowerBound, upperBound, Integer.MAX_VALUE ) ;\n+                                   double upperBound) throws MathException {\n+        return bracket( function, initial, lowerBound, upperBound,\n+            Integer.MAX_VALUE ) ;\n     }\n \n     /**\n      * @param function the function\n      * @param initial midpoint of the returned range.\n      * @param lowerBound for numerical safety, a never is less than this value.\n-     * @param upperBound for numerical safety, b never is greater than this value.\n-     * @param maximumIterations to guard against infinite looping, maximum number of iterations to perform\n+     * @param upperBound for numerical safety, b never is greater than this\n+     *                   value.\n+     * @param maximumIterations to guard against infinite looping, maximum\n+     *                          number of iterations to perform\n      * @return a two element array holding {a, b}.\n+     * @throws MathException if a root can not be bracketted.\n      */\n-    public static double[] bracket(UnivariateFunction function,\n+    public static double[] bracket(UnivariateRealFunction function,\n                                    double initial,\n                                    double lowerBound,\n                                    double upperBound,\n-                                   int maximumIterations) {\n+                                   int maximumIterations) throws MathException {\n         double a = initial;\n         double b = initial;\n         double fa;\n         do {\n             a = Math.max(a - 1.0, lowerBound);\n             b = Math.min(b + 1.0, upperBound);\n-            fa = function.evaluate(a);\n-            fb = function.evaluate(b);\n+            fa = function.value(a);\n+            fb = function.value(b);\n             numIterations += 1 ;\n         } while ( (fa * fb > 0.0) && ( numIterations < maximumIterations ) );\n \n         return new double[]{a, b};\n     }\n-\n-    /**\n-     * For a function, f, this method returns a root c that lies between a and\n-     * b, and satisfies f(c) = 0.\n-     *\n-     * @param function the function\n-     * @param a lower (or upper) bound of a root\n-     * @param b upper (or lower) bound of a root\n-     * @return a root of f\n-     */\n-    public static double bisection(UnivariateFunction function,\n-                                   double a,\n-                                   double b) {\n-        double m;\n-        double fm;\n-        double fa;\n-\n-        if ( b < a ) {\n-            double xtemp = a ;\n-            a = b ;\n-            b = xtemp ;\n-        }\n-\n-        fa = function.evaluate(a);\n-\n-        while(Math.abs(a - b) > EPSILON) {\n-            m = (a + b) * 0.5;  // midpoint\n-            fm = function.evaluate(m);\n-\n-            if(fm * fa > 0.0) {\n-                // b and m bracket the root.\n-                a = m;\n-                fa = fm;\n-            } else {\n-                // a and m bracket the root.\n-                b = m;\n-            }\n-        }\n-\n-        return (a + b) * 0.5;\n-    }\n }\n--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n  * @author pietsch at apache.org\n  */\n public class SecantSolver extends UnivariateRealSolverImpl {\n-\n-    private UnivariateRealFunction f;\n-\n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     */\n     public SecantSolver(UnivariateRealFunction f) {\n-        super(100, 1E-6);\n-        this.f = f;\n+        super(f, 100, 1E-6);\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double)\n+    /**\n+     * Solve for a zero in the given interval.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param initial the start value to use (ignored).\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max, double initial)\n+        throws MathException {\n+            \n+        return solve(min, max);\n+    }\n+    \n+    /**\n+     * Solve for a zero root in the given interval.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n      */\n     public double solve(double min, double max) throws MathException {\n         clearResult();\n         double x1 = max;\n         double y0 = f.value(x0);\n         double y1 = f.value(x1);\n-        if ((y0>0)== (y1>0)) {\n+        if ((y0 > 0) == (y1 > 0)) {\n             throw new MathException(\"Interval doesn't bracket a zero.\");\n         }\n         double x2 = x0;\n             if (Math.abs(y1) > Math.abs(y0)) {\n                 // Function value increased in last iteration. Force bisection.\n                 delta = 0.5 * oldDelta;\n-//                System.out.println(\"Forced Bisection\");\n             } else {\n                 delta = (x0 - x1) / (1 - y0 / y1);\n-                // System.out.println(\"delta=\" + delta + \" olddelta=\" + oldDelta);\n                 if (delta / oldDelta > 1) {\n-                    // New approximation falls outside bracket. Fall back to bisection.\n+                    // New approximation falls outside bracket.\n+                    // Fall back to bisection.\n                     delta = 0.5 * oldDelta;\n-//                    System.out.println(\"Fallback Bisection\");\n                 }\n             }\n             x0 = x1;\n             y0 = y1;\n             x1 = x1 + delta;\n             y1 = f.value(x1);\n-            if ((y1>0) == (y2>0)) {\n+            if ((y1 > 0) == (y2 > 0)) {\n                 // New bracket is (x0,x1).                    \n                 x2 = x0;\n                 y2 = y0;\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n \n     /**\n      * Set the upper limit for the number of iterations.\n+     * \n      * Usually a high iteration count indicates convergence problems. However,\n      * the \"reasonable value\" varies widely for different solvers, users are\n-     * advised to use the default value supplied by the solver. \n+     * advised to use the default value supplied by the solver.\n+     *  \n      * An exception will be thrown if the number is exceeded.\n      *  \n-     * @param count\n+     * @param count maximum number of iterations\n      */\n     public void setMaximalIterationCount(int count);\n \n     /**\n      * Get the upper limit for the number of iterations.\n+     * \n      * @return the actual upper limit\n      */\n     public int getMaximalIterationCount();\n \n     /**\n      * Reset the upper limit for the number of iterations to the default.\n+     * \n      * The default value is supplied by the solver implementation.\n      * \n      * @see #setMaximalIterationCount(int)\n \n     /**\n      * Set the absolute accuracy.\n+     * \n      * The default is usually choosen so taht roots in the interval\n-     * -10..-0.1 and +0.1..+10 can be found wit a reasonable accuracy. If the expected\n-     * absolute value of your roots is of much smaller magnitude, set this to a smaller\n-     * value.\n-     * Solvers are advised to do a plausibility check with the relative accuracy, but\n-     * clients should not rely on this. \n+     * -10..-0.1 and +0.1..+10 can be found wit a reasonable accuracy. If the\n+     * expected absolute value of your roots is of much smaller magnitude, set\n+     * this to a smaller value.\n+     * \n+     * Solvers are advised to do a plausibility check with the relative\n+     * accuracy, but clients should not rely on this.\n+     *  \n      * @param accuracy the accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or is\n-     * otherwise deemed unreasonable. \n+     * @throws MathException if the accuracy can't be achieved by the solver or\n+     *         is otherwise deemed unreasonable. \n      */\n     public void setAbsoluteAccuracy(double accuracy) throws MathException;\n \n     /**\n      * Get the actual absolute accuracy.\n+     * \n      * @return the accuracy\n      */\n     public double getAbsoluteAccuracy();\n \n     /**\n      * Reset the absolute accuracy to the default.\n+     * \n      * The default value is provided by the solver implementation.\n      */\n     public void resetAbsoluteAccuracy();\n \n     /**\n      * Set the relative accuracy.\n-     * This is used to stop iterations if the absolute accuracy can't be achieved\n-     * due to large values or short mantissa length.\n-     * If this should be the primary criterium for convergence rather then a safety\n-     * measure, set the absolute accuracy to a ridiculously small value, like 1E-1000.\n+     * \n+     * This is used to stop iterations if the absolute accuracy can't be\n+     * achieved due to large values or short mantissa length.\n+     * \n+     * If this should be the primary criterium for convergence rather then a\n+     * safety measure, set the absolute accuracy to a ridiculously small value,\n+     * like 1E-1000.\n+     * \n      * @param accuracy the relative accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or is\n-     * otherwise deemed unreasonable. \n-     */\n-    public void setRelativeAccuracy(double Accuracy) throws MathException;\n+     * @throws MathException if the accuracy can't be achieved by the solver or\n+     *         is otherwise deemed unreasonable. \n+     */\n+    public void setRelativeAccuracy(double accuracy) throws MathException;\n \n     /**\n      * Get the actual relative accuracy.\n \n     /**\n      * Set the function value accuracy.\n+     * \n      * This is used to determine whan an evaluated function value or some other\n      * value which is used as divisor is zero.\n-     * This is a safety guard and it shouldn't be necesary to change this in general.\n+     * \n+     * This is a safety guard and it shouldn't be necesary to change this in\n+     * general.\n+     * \n      * @param accuracy the accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or is\n-     * otherwise deemed unreasonable. \n-     */\n-    public void setFunctionValueAccuracy(double Accuracy) throws MathException;\n+     * @throws MathException if the accuracy can't be achieved by the solver or\n+     *         is otherwise deemed unreasonable. \n+     */\n+    public void setFunctionValueAccuracy(double accuracy) throws MathException;\n \n     /**\n      * Get the actual function value accuracy.\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n public abstract class UnivariateRealSolverImpl\n     implements UnivariateRealSolver {\n \n+    /** Maximum absolute error. */\n     protected double absoluteAccuracy;\n+\n+    /** Maximum relative error. */\n     protected double relativeAccuracy;\n+\n+    /** Maximum error of function. */\n     protected double functionValueAccuracy;\n+\n+    /** Maximum number of iterations. */\n     protected int maximalIterationCount;\n \n+    /** Default maximum absolute error. */\n     protected double defaultAbsoluteAccuracy;\n+\n+    /** Default maximum relative error. */\n     protected double defaultRelativeAccuracy;\n+\n+    /** Default maximum error of function. */\n     protected double defaultFunctionValueAccuracy;\n+\n+    /** Default maximum number of iterations. */\n     protected int defaultMaximalIterationCount;\n \n+    /** Indicates where a root has been computed. */\n     protected boolean resultComputed = false;\n+\n+    /** The last computed root. */\n     protected double result;\n+\n     // Mainly for test framework.\n+    /** The last iteration count. */\n     protected int iterationCount;\n \n+    /** The function to solve. */\n+    protected UnivariateRealFunction f;\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * @param f the function to solve.\n+     * @param defaultAbsoluteAccuracy maximum absolue error.\n+     * @param defaultMaximalIterationCount maximum number of iterations.\n+     */\n     protected UnivariateRealSolverImpl(\n+        UnivariateRealFunction f,\n         int defaultMaximalIterationCount,\n         double defaultAbsoluteAccuracy) {\n+        \n+        super();\n+        \n+        this.f = f;\n         this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n         this.defaultRelativeAccuracy = 1E-14;\n         this.defaultFunctionValueAccuracy = 1E-15;\n         this.maximalIterationCount = defaultMaximalIterationCount;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double)\n-     */\n-    public double solve(double min, double max) throws MathException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double, double)\n-     */\n-    public double solve(double min, double max, double startValue)\n-        throws MathException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /*\n-     * Get result of last solver run.\n-     * @see org.apache.commons.math.UnivariateRealSolver#getResult()\n+    /**\n+     * Access the last computed root.\n+     * @return the last computed root.\n+     * @throws MathException if no root has been computed.\n      */\n     public double getResult() throws MathException {\n         if (resultComputed) {\n             return result;\n         } else {\n+            // TODO: could this be an IllegalStateException instead?\n             throw new MathException(\"No result available\");\n         }\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#getIterationCount()\n+    /**\n+     * Access the last iteration count.\n+     * @return the last iteration count.\n+     * @throws MathException if no root has been computed.\n+     *  \n      */\n     public int getIterationCount() throws MathException {\n         if (resultComputed) {\n             return iterationCount;\n         } else {\n+            // TODO: could this be an IllegalStateException instead?\n             throw new MathException(\"No result available\");\n         }\n     }\n \n-    /*\n+    /**\n      * Convenience function for implementations.\n      * @param result the result to set\n-     * @param iteratinCount the iteration count to set\n+     * @param iterationCount the iteration count to set\n      */\n     protected final void setResult(double result, int iterationCount) {\n         this.result = result;\n         this.resultComputed = true;\n     }\n \n-    /*\n+    /**\n      * Convenience function for implementations.\n      */\n     protected final void clearResult() {\n         this.resultComputed = false;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#setAccuracy(double)\n+    /**\n+     * Set the absolute accuracy.\n+     * \n+     * @param accuracy the accuracy.\n+     * @throws MathException if the accuracy can't be achieved by the solver or\n+     *         is otherwise deemed unreasonable. \n      */\n     public void setAbsoluteAccuracy(double accuracy)\n         throws MathException {\n         absoluteAccuracy = accuracy;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#getAccuracy()\n+    /**\n+     * Get the actual absolute accuracy.\n+     * \n+     * @return the accuracy\n      */\n     public double getAbsoluteAccuracy() {\n         return absoluteAccuracy;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#resetAbsoluteAccuracy()\n+    /**\n+     * Reset the absolute accuracy to the default.\n      */\n     public void resetAbsoluteAccuracy() {\n         absoluteAccuracy = defaultAbsoluteAccuracy;\n     }\n \n-    /* Set maximum iteration count.\n-     * @see org.apache.commons.math.UnivariateRealSolver#setMaximalIterationCount(int)\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * \n+     * @param count maximum number of iterations\n      */\n     public void setMaximalIterationCount(int count) {\n         maximalIterationCount = count;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#getMaximalIterationCount()\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n      */\n     public int getMaximalIterationCount() {\n         return maximalIterationCount;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#resetMaximalIterationCount()\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n      */\n     public void resetMaximalIterationCount() {\n         maximalIterationCount = defaultMaximalIterationCount;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#setRelativeAccuracy(double)\n+    /**\n+     * Set the relative accuracy.\n+     * \n+     * @param accuracy the relative accuracy.\n+     * @throws MathException if the accuracy can't be achieved by the solver or\n+     *         is otherwise deemed unreasonable. \n      */\n     public void setRelativeAccuracy(double accuracy) throws MathException {\n         relativeAccuracy = accuracy;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#getRelativeAccuracy()\n+    /**\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n      */\n     public double getRelativeAccuracy() {\n         return relativeAccuracy;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#resetRelativeAccuracy()\n+    /**\n+     * Reset the relative accuracy to the default.\n      */\n     public void resetRelativeAccuracy() {\n         relativeAccuracy = defaultRelativeAccuracy;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#setFunctionValueAccuracy(double)\n+    /**\n+     * Set the function value accuracy.\n+     * \n+     * @param accuracy the accuracy.\n+     * @throws MathException if the accuracy can't be achieved by the solver or\n+     *         is otherwise deemed unreasonable. \n      */\n     public void setFunctionValueAccuracy(double accuracy)\n         throws MathException {\n         functionValueAccuracy = accuracy;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#getFunctionValueAccuracy()\n+    /**\n+     * Get the actual function value accuracy.\n+     * @return the accuracy\n      */\n     public double getFunctionValueAccuracy() {\n         return functionValueAccuracy;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.math.UnivariateRealSolver#resetFunctionValueAccuracy()\n+    /**\n+     * Reset the actual function accuracy to the default.\n      */\n     public void resetFunctionValueAccuracy() {\n         functionValueAccuracy = defaultFunctionValueAccuracy;\n     }\n-\n }\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n  */\n package org.apache.commons.math.stat.distribution;\n \n+import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.RootFinding;\n-import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealSolverFactory;\n \n /**\n  * Base class for various continuous distributions.  It provides default\n         \n         // by default, do simple root finding using bracketing and bisection.\n         // subclasses can overide if there is a better method.\n-        UnivariateFunction rootFindingFunction = new UnivariateFunction() {\n-            public double evaluate(double x) {\n+        UnivariateRealFunction rootFindingFunction =\n+            new UnivariateRealFunction() {\n+                \n+            public double value(double x) throws MathException {\n                 return cummulativeProbability(x) - p;\n+            }\n+\n+            public double firstDerivative(double x) throws MathException {\n+                return 0;\n+            }\n+\n+            public double secondDerivative(double x) throws MathException {\n+                return 0;\n             }\n         };\n         \n-        // bracket root\n-        double[] bracket = RootFinding.bracket(rootFindingFunction,\n-            getInitialDomain(p), getDomainLowerBound(p),\n-            getDomainUpperBound(p));\n+        try {\n+            // bracket root\n+            double[] bracket = RootFinding.bracket(rootFindingFunction,\n+                getInitialDomain(p), getDomainLowerBound(p),\n+                getDomainUpperBound(p));\n+            \n+            // find root\n+            double root = UnivariateRealSolverFactory.solve(\n+                rootFindingFunction, bracket[0], bracket[1]);\n         \n-        // find root\n-        double root = RootFinding.bisection(rootFindingFunction, bracket[0],\n-            bracket[1]);\n-        \n-        return root;\n+            return root;\n+        } catch (MathException ex) {\n+            // this should never happen.\n+            return Double.NaN;\n+        }\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/BisectionSolverTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ *\n+ */\n+public final class BisectionSolverTest extends TestCase {\n+    /**\n+     *\n+     */\n+    public BisectionSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     *\n+     */\n+    public void testSinZero() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        result = solver.solve(3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+\n+    /**\n+     *\n+     */\n+    public void testQuinticZero() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+\n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        result = solver.solve(-0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(-0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(-0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+    }\n+}", "timestamp": 1057428331, "metainfo": ""}