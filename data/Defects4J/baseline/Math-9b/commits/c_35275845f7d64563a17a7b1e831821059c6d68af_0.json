{"sha": "35275845f7d64563a17a7b1e831821059c6d68af", "log": "This is a multifile commit, it covers checkstyle errors in javadoc etc. PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20936 Submitted by:\tbrent@worden.org   ", "commit": "\n--- a/src/java/org/apache/commons/math/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/ContinuedFraction.java\n package org.apache.commons.math;\n \n /**\n- * <p>\n  * Provides a generic means to evaluate continued fractions.  Subclasses simply\n  * provided the a and b coefficients to evaluate the continued fraction.\n- * </p>\n  * \n- * <p>\n- * Reference:<br/>\n- * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n- * Continued Fraction</a>\n- * </p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+ * Continued Fraction</a></li>\n+ * </ul>\n  * \n  * @author Brent Worden\n  */\n     }    \n     \n     /**\n-     * <p>\n-     * Evaluates the continued fraction at the value x.\n-     * </p>\n+     * Evaluates the continued fraction at the value x.\n      * \n-     * <p>\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>O. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n      * Fast Computation of Continued Fractions</a>, Computers Math. Applic.,\n      * 21(2--3), 1991, 167--169.</li>\n      * </ul>\n-     * </p>\n      * \n      * @param x the evaluation point.\n      * @param epsilon maximum error allowed.\n         f[1][1] = (a[1][0] * an[0][1]) + (a[1][1] * an[1][1]);\n         \n         // determine if we're close enough\n-        if(Math.abs((f[0][0] * f[1][1]) - (f[1][0] * f[0][1])) <\n-                Math.abs(epsilon * f[1][0] * f[1][1])){\n+        if (Math.abs((f[0][0] * f[1][1]) - (f[1][0] * f[0][1])) <\n+                Math.abs(epsilon * f[1][0] * f[1][1])) {\n             ret = f[0][0] / f[1][0];\n         } else {\n-            if(n >= maxIterations){\n+            if (n >= maxIterations) {\n                 throw new ConvergenceException(\n                     \"Continued fraction convergents failed to converge.\");\n             }\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n     public double inverseCummulativeProbability(final double p) {\n-        if (p < 0.0 || p > 1.0){\n+        if (p < 0.0 || p > 1.0) {\n             throw new IllegalArgumentException(\n                 \"p must be between 0.0 and 1.0, inclusive.\");\n         }\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n package org.apache.commons.math.stat.distribution;\n \n /**\n- * <p>\n- * The Chi-Squared Distribution\n- * </p>\n+ * The Chi-Squared Distribution.\n  * \n- * <p>\n  * Instances of ChiSquaredDistribution objects should be created using\n- * {@link DistributionFactory#createChiSquareDistribution(double)}\n- * </p>\n+ * {@link DistributionFactory#createChiSquareDistribution(double)}.\n  * \n- * <p>\n  * References:\n  * <ul>\n  * <li><a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n  * Chi-Squared Distribution</a></li>\n- * </p>\n+ * </ul>\n  * \n  * @author Brent Worden\n  */\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n package org.apache.commons.math.stat.distribution;\n \n /**\n- * <p>\n  * This factory provids the means to create common statistical distributions.\n  * The following distributions are supported:\n  * <ul>\n  * <li>Gamma</li>\n  * <li>Student's t</li>\n  * </ul>\n- * </p>\n  * \n- * <p>\n  * Common usage:<pre>\n  * DistributionFactory factory = DistributionFactory.newInstance();\n  * \n  * // create a Chi-Square distribution with 5 degrees of freedom.\n  * ChiSquaredDistribution chi = factory.createChiSquareDistribution(5.0);\n  * </pre>\n- * </p>\n  * \n  * @author Brent Worden\n  */\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n package org.apache.commons.math.stat.distribution;\n \n /**\n- * <p>\n- * The Exponential Distribution\n- * </p>\n+ * The Exponential Distribution.\n  * \n- * <p>\n  * Instances of ExponentialDistribution objects should be created using\n- * {@link DistributionFactory#createExponentialDistribution(double)}\n- * </p>\n+ * {@link DistributionFactory#createExponentialDistribution(double)}.\n  * \n- * <p>\n  * References:\n  * <ul>\n  * <li><a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n  * Exponential Distribution</a></li>\n- * </p>\n  * \n  * @author Brent Worden\n  */\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n package org.apache.commons.math.stat.distribution;\n \n /**\n  * @author Brent Worden\n  */\n public class ExponentialDistributionImpl\n-\timplements ExponentialDistribution {\n+    implements ExponentialDistribution {\n \n     /** The mean of this distribution. */\n     private double mean;\n     \n     /**\n      * Create a exponential distribution with the given mean.\n-     * @param degreesOfFreedom degrees of freedom.\n+     * @param mean mean of this distribution.\n      */\n-\tpublic ExponentialDistributionImpl(double mean) {\n-\t\tsuper();\n+    public ExponentialDistributionImpl(double mean) {\n+        super();\n         setMean(mean);\n-\t}\n+    }\n \n     /**\n      * Modify the mean.\n      * @param mean the new mean.\n      */\n-\tpublic void setMean(double mean) {\n-        if(mean <= 0.0){\n+    public void setMean(double mean) {\n+        if (mean <= 0.0) {\n             throw new IllegalArgumentException(\"mean must be positive.\");\n         }\n         this.mean = mean;\n-\t}\n+    }\n \n     /**\n      * Access the mean.\n      * @return the mean.\n      */\n-\tpublic double getMean() {\n-\t\treturn mean;\n-\t}\n+    public double getMean() {\n+        return mean;\n+    }\n \n     /**\n-     * <p>\n      * For this disbution, X, this method returns P(X &lt; x).\n-     * </p>\n      * \n-     * <p>\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n      * Exponential Distribution</a>, equation (1).</li>\n      * </ul>\n-     * </p>\n      * \n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n      */\n-\tpublic double cummulativeProbability(double x) {\n+    public double cummulativeProbability(double x) {\n         double ret;\n-\t\tif(x <= 0.0){\n+        if (x <= 0.0) {\n             ret = 0.0;\n-\t\t} else {\n+        } else {\n             ret = 1.0 - Math.exp(-x / getMean());\n-\t\t}\n+        }\n         return ret;\n-\t}\n+    }\n     \n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n-    public double inverseCummulativeProbability(double p){\n+    public double inverseCummulativeProbability(double p) {\n         double ret;\n         \n-        if(p < 0.0 || p > 1.0){\n+        if (p < 0.0 || p > 1.0) {\n             ret = Double.NaN;\n-        } else if(p == 1.0){\n+        } else if (p == 1.0) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n             ret = -getMean() * Math.log(1.0 - p);\n--- a/src/java/org/apache/commons/math/distribution/FDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistribution.java\n package org.apache.commons.math.stat.distribution;\n \n /**\n- * <p>\n  * F-Distribution.\n- * </p>\n  * \n- * <p>\n  * Instances of FDistribution objects should be created using\n- * {@link DistributionFactory#createFDistribution(double,double)}\n- * </p>\n+ * {@link DistributionFactory#createFDistribution(double,double)}.\n  * \n- * <p>\n- * Reference:<br/>\n- * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n- * F-Distribution</a>\n- * </p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n+ * F-Distribution</a></li>\n+ * </ul>\n  * \n  * @author Brent Worden\n  */\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n \n /**\n  * Default implementation of\n- * {@link org.apache.commons.math.stat.distribution.TDistribution}.\n+ * {@link org.apache.commons.math.stat.distribution.FDistribution}.\n  * \n  * @author Brent Worden\n  */\n     \n     /**\n      * Create a F distribution using the given degrees of freedom.\n-     * @param numeratorDegreesOfFreedom the degrees of freedom.\n-     * @param denominatorDegreesOfFreedom\n+     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n      */\n     public FDistributionImpl(double numeratorDegreesOfFreedom,\n-            double denominatorDegreesOfFreedom){\n+            double denominatorDegreesOfFreedom) {\n         super();\n         setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n         setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n     }\n     \n     /**\n-     * <p>\n      * For this disbution, X, this method returns P(X &lt; x).\n-     * </p>\n      * \n-     * <p>\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n      * F-Distribution</a>, equation (4).</li>\n-     * </p>\n+     * </ul>\n      * \n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n     public double cummulativeProbability(double x) {\n         double ret;\n-        if(x <= 0.0){\n+        if (x <= 0.0) {\n             ret = 0.0;\n         } else {\n             double n = getNumeratorDegreesOfFreedom();\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n-    protected double getDomainLowerBound(double p){\n+    protected double getDomainLowerBound(double p) {\n         return 0.0;\n     }\n \n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n-    protected double getDomainUpperBound(double p){\n+    protected double getDomainUpperBound(double p) {\n         return Double.MAX_VALUE;\n     }\n \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n-    protected double getInitialDomain(double p){\n-        return getDenominatorDegreesOfFreedom() / (getDenominatorDegreesOfFreedom() - 2.0);\n+    protected double getInitialDomain(double p) {\n+        return getDenominatorDegreesOfFreedom() /\n+            (getDenominatorDegreesOfFreedom() - 2.0);\n     }\n     \n     /**\n      * Modify the numerator degrees of freedom.\n      * @param degreesOfFreedom the new numerator degrees of freedom.\n      */\n-    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom){\n-        if(degreesOfFreedom <= 0.0){\n+    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n+        if (degreesOfFreedom <= 0.0) {\n             throw new IllegalArgumentException(\n                 \"degrees of freedom must be positive.\");\n         }\n      * Access the numerator degrees of freedom.\n      * @return the numerator degrees of freedom.\n      */\n-    public double getNumeratorDegreesOfFreedom(){\n+    public double getNumeratorDegreesOfFreedom() {\n         return numeratorDegreesOfFreedom;\n     }\n     \n      * Modify the denominator degrees of freedom.\n      * @param degreesOfFreedom the new denominator degrees of freedom.\n      */\n-    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom){\n-        if(degreesOfFreedom <= 0.0){\n+    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n+        if (degreesOfFreedom <= 0.0) {\n             throw new IllegalArgumentException(\n                 \"degrees of freedom must be positive.\");\n         }\n      * Access the denominator degrees of freedom.\n      * @return the denominator degrees of freedom.\n      */\n-    public double getDenominatorDegreesOfFreedom(){\n+    public double getDenominatorDegreesOfFreedom() {\n         return denominatorDegreesOfFreedom;\n     }\n }\n--- a/src/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistribution.java\n package org.apache.commons.math.stat.distribution;\n \n /**\n- * <p>\n- * The Gamma Distribution\n- * </p>\n+ * The Gamma Distribution.\n  * \n- * <p>\n  * Instances of GammaDistribution objects should be created using\n- * {@link DistributionFactory#createGammaDistribution(double,double)}\n- * </p>\n+ * {@link DistributionFactory#createGammaDistribution(double,double)}.\n  * \n- * <p>\n  * References:\n  * <ul>\n  * <li><a href=\"http://mathworld.wolfram.com/GammaDistribution.html\">\n  * Gamma Distribution</a></li>\n- * </p>\n+ * </ul>\n  *  \n  * @author Brent Worden\n  */\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n     }\n     \n     /**\n-     * <p>\n      * For this disbution, X, this method returns P(X &lt; x).\n-     * </p>\n-     * \n-     * <p>\n+     * \n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.\n      * Belmont, CA: Duxbury Press.</li>\n      * </ul>\n-     * </p>\n      * \n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n \n         double ret;\n \n-        if(p < .5){\n+        if (p < .5) {\n             // use mean\n             ret = getAlpha() * getBeta();\n         } else {\n \n         double ret;\n \n-        if(p < .5){\n+        if (p < .5) {\n             // use 1/2 mean\n             ret = getAlpha() * getBeta() * .5;\n         } else {\n--- a/src/java/org/apache/commons/math/distribution/TDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistribution.java\n package org.apache.commons.math.stat.distribution;\n \n /**\n- * <p>\n  * Student's t-Distribution.\n- * </p>\n  * \n- * <p>\n  * Instances of TDistribution objects should be created using\n  * {@link DistributionFactory#createTDistribution(double)}\n- * </p>\n  * \n- * <p>\n- * Reference:<br/>\n- * <a href=\"http://mathworld.wolfram.com/Studentst-Distribution.html\">\n- * Student's t-Distribution</a>\n- * </p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/Studentst-Distribution.html\">\n+ * Student's t-Distribution</a></li>\n+ * </ul>\n  * \n  * @author Brent Worden\n  */\n--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n      * Create a t distribution using the given degrees of freedom.\n      * @param degreesOfFreedom the degrees of freedom.\n      */\n-    public TDistributionImpl(double degreesOfFreedom){\n+    public TDistributionImpl(double degreesOfFreedom) {\n         super();\n         setDegreesOfFreedom(degreesOfFreedom);\n     }\n      * @param degreesOfFreedom the new degrees of freedom.\n      */\n     public void setDegreesOfFreedom(double degreesOfFreedom) {\n-        if(degreesOfFreedom <= 0.0){\n+        if (degreesOfFreedom <= 0.0) {\n             throw new IllegalArgumentException(\n                 \"degrees of freedom must be positive.\");\n         }\n      */\n     public double cummulativeProbability(double x) {\n         double ret;\n-        if(x == 0.0){\n+        if (x == 0.0) {\n             ret = 0.5;\n         } else {\n             double t = Beta.regularizedBeta(\n                 getDegreesOfFreedom() / (getDegreesOfFreedom() + (x * x)),\n                 0.5 * getDegreesOfFreedom(), 0.5);\n                 \n-            if(x < 0.0){\n+            if (x < 0.0) {\n                 ret = 0.5 * t;\n             } else {\n                 ret = 1.0 - 0.5 * t;\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n      */\n-    protected double getDomainLowerBound(double p){\n+    protected double getDomainLowerBound(double p) {\n         return -Double.MAX_VALUE;\n     }\n \n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n      */\n-    protected double getDomainUpperBound(double p){\n+    protected double getDomainUpperBound(double p) {\n         return Double.MAX_VALUE;\n     }\n \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n-    protected double getInitialDomain(double p){\n+    protected double getInitialDomain(double p) {\n         return 0.0;\n     }\n }\n--- a/src/java/org/apache/commons/math/special/Beta.java\n+++ b/src/java/org/apache/commons/math/special/Beta.java\n     }\n \n     /**\n-     * <p>\n-     * Returns the regularized beta function I(x, a, b).\n-     * </p>\n+     * Returns the regularized beta function I(x, a, b).\n      * \n      * @param x ???\n      * @param a ???\n     }\n \n     /**\n-     * <p>\n-     * Returns the regularized beta function I(x, a, b).\n-     * </p>\n-     * \n-     * @param x ???\n-     * @param a ???\n-     * @param b ???\n-     * @return the regularized beta function I(x, a, b)\n-     */\n-    public static double regularizedBeta(double x, double a, double b, double epsilon) {\n+     * Returns the regularized beta function I(x, a, b).\n+     * \n+     * @param x ???\n+     * @param a ???\n+     * @param b ???\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @return the regularized beta function I(x, a, b)\n+     */\n+    public static double regularizedBeta(double x, double a, double b,\n+        double epsilon) {\n+            \n         return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n     }\n \n     /**\n-     * <p>\n-     * Returns the regularized beta function I(x, a, b).\n-     * </p>\n-     * \n-     * @param x ???\n-     * @param a ???\n-     * @param b ???\n-     * @return the regularized beta function I(x, a, b)\n-     */\n-    public static double regularizedBeta(double x, double a, double b, int maxIterations) {\n+     * Returns the regularized beta function I(x, a, b).\n+     * \n+     * @param x ???\n+     * @param a ???\n+     * @param b ???\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized beta function I(x, a, b)\n+     */\n+    public static double regularizedBeta(double x, double a, double b,\n+        int maxIterations) {\n+            \n         return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n     }\n     \n     /**\n-     * <p>\n-     * Returns the regularized beta function I(x, a, b).\n-     * </p>\n-     * \n-     * <p>\n+     * Returns the regularized beta function I(x, a, b).\n+     * \n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n      * Regularized Beta Function</a>.</li>\n      * </ul>\n-     * </p>\n-     * \n-     * @param x ???\n-     * @param a ???\n-     * @param b ???\n-     * @return the regularized beta function I(x, a, b)\n-     */\n-    public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n+     * \n+     * @param x ???\n+     * @param a ???\n+     * @param b ???\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized beta function I(x, a, b)\n+     */\n+    public static double regularizedBeta(double x, final double a,\n+        final double b, double epsilon, int maxIterations) {\n+            \n         double ret;\n \n         if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0)\n                             if (n % 2 == 0) { // even\n                                 m = (n - 2.0) / 2.0;\n                                 ret =\n-                                    - ((a + m) * (a + b + m) * x)\n-                                        / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n+                                    -((a + m) * (a + b + m) * x)\n+                                        / ((a + (2 * m))\n+                                        * (a + (2 * m) + 1.0));\n                             } else {\n                                 m = (n - 1.0) / 2.0;\n                                 ret =\n                     }\n                     return ret;\n                 }\n-\t\t\t};\n-            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) - Math.log(a) - logBeta(a, b, epsilon, maxIterations)) * fraction.evaluate(x, epsilon, maxIterations);\n+            };\n+            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x))\n+                - Math.log(a) - logBeta(a, b, epsilon, maxIterations))\n+                * fraction.evaluate(x, epsilon, maxIterations);\n         }\n \n         return ret;\n     }\n \n     /**\n-     * <p>\n      * Returns the natural logarithm of the beta function B(a, b).\n-     * </p>\n      * \n      * @param a ???\n      * @param b ???\n     }\n     \n     /**\n-     * <p>\n      * Returns the natural logarithm of the beta function B(a, b).\n-     * </p>\n      *\n-     * <p> \n      * The implementation of this method is based on:\n      * <ul>\n      * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n      * Beta Function</a>, equation (1).</li>\n      * </ul>\n-     * </p>\n-     * \n-     * @param a ???\n-     * @param b ???\n+     * \n+     * @param a ???\n+     * @param b ???\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n      * @return log(B(a, b))\n      */\n-    public static double logBeta(double a, double b, double epsilon, int maxIterations) {\n+    public static double logBeta(double a, double b, double epsilon,\n+        int maxIterations) {\n+            \n         double ret;\n \n         if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n     }\n \n     /**\n-     * <p>\n      * Returns the regularized gamma function P(a, x).\n-     * </p>\n      * \n      * @param a ???\n      * @param x ???\n     }\n     \n     /**\n-     * <p>\n      * Returns the regularized gamma function P(a, x).\n-     * </p>\n-     * \n-     * <p>\n+     * \n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n      * </li>\n      * </ul>\n-     * </p>\n      * \n      * @param a ???\n      * @param x ???\n     }\n \n     /**\n-     * <p>\n      * Returns the natural logarithm of the gamma function &#915;(x).\n-     * </p>\n      *\n-     * <p> \n      * The implementation of this method is based on:\n      * <ul>\n      * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">\n      * the computation of the convergent Lanczos complex Gamma approximation\n      * </a></li>\n      * </ul>\n-     * </p>\n      * \n      * @param x ???\n      * @return log(&#915;(x))", "timestamp": 1056162109, "metainfo": ""}