{"sha": "bc31e531edcdcab235585086ced5eb1dec33e1d6", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=22954 Submitted by:\tBrent Worden Reviewed by:\tMark Diggory   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/RootFinding.java\n+++ b/src/java/org/apache/commons/math/analysis/RootFinding.java\n /**\n  * Utility class comprised of root finding techniques.\n  *\n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:02:43 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class RootFinding {\n-    /** Maximum allowed numerical error. */\n-    private static final double EPSILON = 10e-9;\n-\n     /**\n      * Default constructor. Prohibit construction.\n      */\n--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n /**\n  * Computes a natural spline interpolation for the data set.\n  *\n- * @version $Revision: 1.3 $ $Date: 2003/07/30 21:58:10 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n  *\n  */\n public class SplineInterpolator implements UnivariateRealInterpolator {\n+    /** the natural spline coefficients. */\n     private double[][] c = null;\n \n     /**\n      * @param xval the arguments for the interpolation points\n      * @param yval the values for the interpolation points\n      * @return a function which interpolates the data set\n-     * @throws MathException if arguments violate assumptions made by the\n-     *         interpolationg algorithm\n      */\n     public UnivariateRealFunction interpolate(double[] xval, double[] yval) {\n         if (xval.length != yval.length) {\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n  * (this may be controversial, because the configuration data\n  * may also be used for the default solver used by the static\n  * solve() method). \n- * @version $Revision: 1.4 $ $Date: 2003/07/30 21:58:10 $\n+ * @version $Revision: 1.5 $ $Date: 2003/09/07 03:12:56 $\n  */\n public abstract class UnivariateRealSolverFactory {\n     /**\n     }\n \n     /**\n+     * Create a new factory.\n      * @return a new factory.\n-     * @todo add comment\n      * @todo for now, return the only concrete factory.  Later, allow for a\n      *       plugable implementation, possibly using SPI and commons-discovery.\n      */\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtil.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtil.java\n import org.apache.commons.math.MathException;\n \n /**\n- * @version $Revision: 1.1 $ $Date: 2003/07/30 22:06:37 $\n- * @todo add comment\n+ * Utility routines for {@link UnivariateRealSolver} objects.\n+ * @version $Revision: 1.2 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class UnivariateRealSolverUtil {\n     /**\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n  * build grouped frequnecy histograms representing the input data or to\n  * generate random values \"like\" those in the input file -- i.e., the values\n  * generated will follow the distribution of the values in the file.\n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:02:59 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n  */\n public interface EmpiricalDistribution {\n     \n      * Generates a random value from this distribution<p>\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @return the random value.\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n     double getNextValue() throws IllegalStateException;  \n      * <p>Returns a Univariate describing this distribution</p>\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @return the sample statistics\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n-    Univariate getSampleStats();\n+    Univariate getSampleStats() throws IllegalStateException;\n     \n     /** \n      * Loads a saved distribution from a file.\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n  *    entry per line.</li>\n  * </ol></p>\n  *\n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:02:59 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class EmpiricalDistributionImpl implements Serializable,EmpiricalDistribution {\n \n          loaded = true;\n     }\n     \n-    /** Generates a random value from this distribution */\n+    /**\n+     * Generates a random value from this distribution\n+     * @return the random value.\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n     public double getNextValue() throws IllegalStateException {    \n         \n         if (!loaded) {\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n  * (so secure sequences started with calls to reseedSecure(long) won't be \n  * identical).</li></ul>\n  * \n- * @version $Revision: 1.2 $ $Date: 2003/07/07 23:19:21 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class RandomDataImpl implements RandomData {\n     \n      * len/2+1 binary bytes are generated using the underlying Random</li>\n      * <li>\n      * Each binary byte is translated into 2 hex digits</li></ol>\n+     * @param len the desired string length.\n+     * @return the random string.\n      */\n     public String nextHexString(int len) {\n         if (len <= 0) {\n         }\n         return outBuffer.toString().substring(0, len);\n     }\n-       \n+\n+    /**\n+     * Generate a random int value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return the random integer.\n+     */       \n     public int nextInt(int lower, int upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n         return lower + (int) (rand.nextDouble() * (upper - lower + 1));\n     }\n     \n+    /**\n+     * Generate a random long value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return the random integer.\n+     */       \n     public long nextLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n      * <p>\n      * TODO: find external reference or provide justification for the claim \n      * that this yields a cryptographically secure sequence of hex strings.\n+     * @param len the desired string length.\n+     * @return the random string.\n      */\n     public String nextSecureHexString(int len) {\n         if (len <= 0) {\n         return outBuffer.toString().substring(0, len);\n     }\n      \n+    /**\n+     * Generate a random int value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n+     * using a secure random number generator for its engine.\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return the random integer.\n+     */       \n     public int nextSecureInt(int lower, int upper) {\n           if (lower >= upper) {\n               throw new IllegalArgumentException\n           return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n     }\n      \n+    /**\n+     * Generate a random long value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n+     * using a secure random number generator for its engine.\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return the random integer.\n+     */       \n     public long nextSecureLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n      * described \n      * <a href =\"http://dmawww.epfl.ch/benarous/Pmmi/interactive/rng7.htm\">\n      * here</a>\n-     *\n+     * @param mean mean of the Poisson distribution.\n+     * @return the random Poisson value.\n      */\n     public long nextPoisson(double mean) {\n+        if (mean <= 0) {\n+            throw new IllegalArgumentException(\"Poisson mean must be > 0\");\n+        }\n         double p = Math.exp(-mean);\n         long n = 0;\n         double r = 1.0d;\n         Random rand = getRan();\n-        if (mean <= 0) {\n-            throw new IllegalArgumentException(\"Poisson mean must be > 0\");\n-        }\n         while (true) {\n             double rnd = rand.nextDouble();\n             r = r * rnd;\n         }\n     }\n     \n+    /**\n+     * Generate a random value from a Normal distribution.  This algorithm \n+     * generates random values for the general Normal distribution with the\n+     * given mean, <code>mu</code> and the given standard deviation,\n+     * <code>sigma</code>.\n+     * @param mu the mean of the distribution.\n+     * @param sigma the standard deviation of the distribution.\n+     * @return the random Normal value.\n+     */\n     public double nextGaussian(double mu, double sigma) {\n         if (sigma <= 0) {\n             throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n      * <strong>Algorithm Description</strong>:  Uses the \n      * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> \n      * Inversion Method</a> to generate exponential from uniform deviates.\n+     * @param mean the mean of the distribution.\n+     * @return the random Exponential value.\n      */\n     public double nextExponential(double mean)  {\n         if (mean < 0.0)  {\n      * random double if Random.nextDouble() returns 0). \n      * This is necessary to provide a symmetric output interval \n      * (both endpoints excluded).\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return the random value.\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n             (\"lower bound must be <= upper bound\");\n         }\n         Random rand = getRan();\n-        double result = lower + rand.nextDouble() * (upper - lower);\n-        while (result == lower) {\n-              result = lower + rand.nextDouble() * (upper - lower);\n-        }\n-        return result;   \n+        \n+        // insure nextDouble() isn't 0.0\n+        double u = rand.nextDouble();\n+        while(u <= 0.0){\n+            u = rand.nextDouble();\n+        }\n+        \n+        return lower + u * (upper - lower);\n     }\n     \n     /** \n      * Uses a 2-cycle permutation shuffle, as described\n      * <a href=http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html>\n      * here</a>\n-     *  \n+     * @param n the population size.\n+     * @param k the number to choose.\n+     * @return the random permutation.\n      */\n     public int[] nextPermutation(int n, int k) {\n         if (k > n) {\n      * This technique is described, and proven to generate random samples, \n      * <a href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>\n+     * @param c Collection to sample from.\n+     * @param k sample size.\n+     * @return the random sample.\n      */ \n     public Object[] nextSample(Collection c, int k) {\n         int len = c.size();\n--- a/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n  * univariate statistics for a List of Java Beans by property.  This \n  * implementation uses beanutils' PropertyUtils to get a simple, nested,\n  * indexed, mapped, or combined property from an element of a List.\n- * @version $Revision: 1.4 $ $Date: 2003/08/09 04:03:41 $\n+ * @version $Revision: 1.5 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class BeanListUnivariateImpl extends ListUnivariateImpl {\n \n       */\n     public void addValue(double v) {\n         String msg =\n-            \"The BeanListUnivariateImpl does not accept values \"\n-                + \"through the addValue method.  Because elements of this list \"\n-                + \"are JavaBeans, one must be sure to set the 'propertyName' \"\n-                + \"property and add new Beans to the underlying list via the \"\n-                + \"addBean(Object bean) method\";\n+            \"The BeanListUnivariateImpl does not accept values \" +\n+            \"through the addValue method.  Because elements of this list \" +\n+            \"are JavaBeans, one must be sure to set the 'propertyName' \" +\n+            \"property and add new Beans to the underlying list via the \" +\n+            \"addBean(Object bean) method\";\n         throw new UnsupportedOperationException(msg);\n     }\n \n--- a/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n import org.apache.commons.math.util.NumberTransformer;\n \n /**\n- * @version $Revision: 1.4 $ $Date: 2003/07/15 03:45:10 $\n+ * @version $Revision: 1.5 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class ListUnivariateImpl\n     extends AbstractStoreUnivariate\n     /**\n      * Construct a ListUnivariate with a specific List.\n      * @param list The list that will back this Univariate\n+     * @param transformer the number transformer used to convert the list items.\n      */\n     public ListUnivariateImpl(List list, NumberTransformer transformer) {\n         super();\n         // take into account only the last n elements of the list\n         // as definied by windowSize\n \n-        if (windowSize != Univariate.INFINITE_WINDOW\n-            && windowSize < list.size()) {\n+        if (windowSize != Univariate.INFINITE_WINDOW &&\n+            windowSize < list.size())\n+        {\n             length = list.size() - Math.max(0, list.size() - windowSize);\n         }\n \n \n         int calcIndex = index;\n \n-        if (windowSize != Univariate.INFINITE_WINDOW\n-            && windowSize < list.size()) {\n+        if (windowSize != Univariate.INFINITE_WINDOW &&\n+            windowSize < list.size())\n+        {\n             calcIndex = (list.size() - windowSize) + index;\n         }\n \n     }\n     \n     /**\n-     * @return\n+     * Access the number transformer.\n+     * @return the number transformer.\n      */\n     public NumberTransformer getTransformer() {\n         return transformer;\n     }\n \n     /**\n-     * @param transformer\n+     * Modify the number transformer.\n+     * @param transformer the new number transformer.\n      */\n     public void setTransformer(NumberTransformer transformer) {\n         this.transformer = transformer;\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  * StatUtils provides easy static implementations of common double[] based\n  * statistical methods. These return a single result value or in some cases, as\n  * identified in the javadoc for each method, Double.NaN.\n- * @version $Revision: 1.15 $ $Date: 2003/08/09 04:03:41 $\n+ * @version $Revision: 1.16 $ $Date: 2003/09/07 03:12:56 $\n  */\n public final class StatUtils {\n \n                 accum2 += (values[i] - mean);\n             }\n             variance =\n-                (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                    / (double) (length - 1);\n+                (accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                (double) (length - 1);\n         }\n         return variance;\n     }\n--- a/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n import org.apache.commons.math.util.ContractableDoubleArray;\n \n /**\n- * @version $Revision: 1.5 $ $Date: 2003/07/15 03:45:10 $\n+ * @version $Revision: 1.6 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class StoreUnivariateImpl extends AbstractStoreUnivariate {\n \n                 eDA.addElement(v);\n             } else {\n                 String msg =\n-                    \"A window Univariate had more element than \"\n-                        + \"the windowSize.  This is an inconsistent state.\";\n+                    \"A window Univariate had more element than \" +\n+                    \"the windowSize.  This is an inconsistent state.\";\n                 throw new RuntimeException(msg);\n             }\n         } else {\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/FourthMoment.java\n  * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n  * recursive strategy\n  * </a>. Both incremental and evaluation strategies currently use this approach.\n- * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n+ * @version $Revision: 1.8 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class FourthMoment extends ThirdMoment {\n \n \n         n3 = (double) (n - 3);\n \n-        m4 =\n-            m4\n-                - (4.0 * v * prevM3)\n-                + (6.0 * v2 * prevM2)\n-                + ((n0 * n0) - 3 * n1) * (v2 * v2 * n1 * n0);\n+        m4 = m4 - (4.0 * v * prevM3) + (6.0 * v2 * prevM2) +\n+            ((n0 * n0) - 3 * n1) * (v2 * v2 * n1 * n0);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Kurtosis.java\n     .AbstractStorelessUnivariateStatistic;\n \n /**\n- * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n+ * @version $Revision: 1.8 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class Kurtosis extends AbstractStorelessUnivariateStatistic {\n \n                 kurtosis = 0.0;\n             } else {\n                 kurtosis =\n-                    (moment.n0 * (moment.n0 + 1) * moment.m4\n-                        - 3 * moment.m2 * moment.m2 * moment.n1)\n-                        / (moment.n1\n-                            * moment.n2\n-                            * moment.n3\n-                            * variance\n-                            * variance);\n+                    (moment.n0 * (moment.n0 + 1) * moment.m4 -\n+                    3 * moment.m2 * moment.m2 * moment.n1) /\n+                    (moment.n1 * moment.n2 * moment.n3 * variance * variance);\n             }\n             n = moment.n;\n         }\n \n                 double stdDev =\n                     Math.sqrt(\n-                        (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                            / (double) (length - 1));\n+                        (accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                        (double) (length - 1));\n \n                 // Sum the ^4 of the distance from the mean divided by the\n                 // standard deviation\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Skewness.java\n \n /**\n  *\n- * @version $Revision: 1.7 $ $Date: 2003/08/09 04:03:40 $\n+ * @version $Revision: 1.8 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class Skewness extends AbstractStorelessUnivariateStatistic {\n \n             if (moment.n <= 2 || variance < 10E-20) {\n                 skewness = 0.0;\n             } else {\n-                skewness =\n-                    (moment.n0 * moment.m3)\n-                        / (moment.n1\n-                            * moment.n2\n-                            * Math.sqrt(variance)\n-                            * variance);\n+                skewness = (moment.n0 * moment.m3) /\n+                    (moment.n1 * moment.n2 * Math.sqrt(variance) * variance);\n             }\n             n = moment.n;\n         }\n                 }\n                 double stdDev =\n                     Math.sqrt(\n-                        (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                            / (double) (length - 1));\n+                        (accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                            (double) (length - 1));\n \n                 // Calculate the skew as the sum the cubes of the distance\n                 // from the mean divided by the standard deviation.\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/Variance.java\n \n /**\n  *\n- * @version $Revision: 1.8 $ $Date: 2003/08/09 04:03:40 $\n+ * @version $Revision: 1.9 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class Variance extends AbstractStorelessUnivariateStatistic {\n \n                     accum += Math.pow((values[i] - m), 2.0);\n                     accum2 += (values[i] - m);\n                 }\n-                var =\n-                    (accum - (Math.pow(accum2, 2) / ((double) length)))\n-                        / (double) (length - 1);\n+                var = (accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                    (double) (length - 1);\n             }\n         }\n         return var;\n--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n  * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n  * Continued Fraction</a></li>\n  * </ul>\n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n  */\n public abstract class ContinuedFraction {\n     /** Maximum allowed numerical error. */\n         f[1][1] = (a[1][0] * an[0][1]) + (a[1][1] * an[1][1]);\n \n         // determine if we're close enough\n-        if (Math.abs((f[0][0] * f[1][1]) - (f[1][0] * f[0][1]))\n-            < Math.abs(epsilon * f[1][0] * f[1][1])) {\n+        if (Math.abs((f[0][0] * f[1][1]) - (f[1][0] * f[0][1])) <\n+            Math.abs(epsilon * f[1][0] * f[1][1]))\n+        {\n             ret = f[0][0] / f[1][0];\n         } else {\n             if (n >= maxIterations) {\n--- a/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n  * internal storage array is swapped.\n  * </p>\n  * \n- * @version $Revision: 1.3 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class ContractableDoubleArray\n     extends ExpandableDoubleArray\n \n         if (contractionCritera < expansionFactor) {\n             String msg =\n-                \"Contraction criteria can never be smaller than \"\n-                    + \"the expansion factor.  This would lead to a never \"\n-                    + \"ending loop of expansion and contraction as a newly \"\n-                    + \"expanded internal storage array would immediately \"\n-                    + \"satisfy the criteria for contraction\";\n+                \"Contraction criteria can never be smaller than \" +\n+                \"the expansion factor.  This would lead to a never \" +\n+                \"ending loop of expansion and contraction as a newly \" +\n+                \"expanded internal storage array would immediately \" +\n+                \"satisfy the criteria for contraction\";\n             throw new IllegalArgumentException(msg);\n         }\n \n         if (contractionCriteria <= 1.0) {\n             String msg =\n-                \"The contraction criteria must be a number larger \"\n-                    + \"than one.  If the contractionCriteria is less than or \"\n-                    + \"equal to one an endless loop of contraction and \"\n-                    + \"expansion would ensue as an internalArray.length \"\n-                    + \"== numElements would satisfy the contraction criteria\";\n+                \"The contraction criteria must be a number larger \" +\n+                \"than one.  If the contractionCriteria is less than or \" +\n+                \"equal to one an endless loop of contraction and \" +\n+                \"expansion would ensue as an internalArray.length \" +\n+                \"== numElements would satisfy the contraction criteria\";\n             throw new IllegalArgumentException(msg);\n         }\n \n         if (expansionFactor < 1.0) {\n             String msg =\n-                \"The expansion factor must be a number greater \" + \"than 1.0\";\n+                \"The expansion factor must be a number greater than 1.0\";\n             throw new IllegalArgumentException(msg);\n         }\n     }\n--- a/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n  * expand the array 10 times - first from 2 -> 4. then 4 -> 8, 8 -> 16,\n  * and so on until we reach 4096 which is sufficient to hold 3546 elements.\n  * </p>\n- * @version $Revision: 1.4 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.5 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class ExpandableDoubleArray implements Serializable, DoubleArray {\n \n             this.initialCapacity = initialCapacity;\n         } else {\n             String msg =\n-                \"The initial capacity supplied: \"\n-                    + initialCapacity\n-                    + \"must be a positive integer\";\n+                \"The initial capacity supplied: \" + initialCapacity +\n+                \"must be a positive integer\";\n             throw new IllegalArgumentException(msg);\n         }\n     }\n         double value = Double.NaN;\n         if (index >= numElements) {\n             String msg =\n-                \"The index specified: \"\n-                    + index\n-                    + \" is larger than the current number of elements\";\n+                \"The index specified: \" + index +\n+                \" is larger than the current number of elements\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         } else if (index >= 0) {\n             value = internalArray[startIndex + index];\n         } else {\n             String msg =\n-                \"Elements cannot be retrieved from a negative \" + \"array index\";\n+                \"Elements cannot be retrieved from a negative array index\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         }\n         return value;\n     public synchronized void discardFrontElements(int i) {\n \n         if (i > numElements) {\n-            String msg =\n-                \"Cannot discard more elements than are\"\n-                    + \"contained in this array.\";\n+            String msg = \"Cannot discard more elements than are\" +\n+                \"contained in this array.\";\n             throw new IllegalArgumentException(msg);\n         } else if (i < 0) {\n             String msg = \"Cannot discard a negative number of elements.\";\n--- a/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n  * \"fixed\" in memory, this implementation will never allocate, or copy\n  * the internal storage array to a new array instance.\n  * </p>\n- * @version $Revision: 1.5 $ $Date: 2003/07/09 20:04:12 $\n+ * @version $Revision: 1.6 $ $Date: 2003/09/07 03:12:56 $\n  */\n public class FixedDoubleArray implements DoubleArray {\n \n     public double getElement(int index) {\n         if (index > (size - 1)) {\n             String msg =\n-                \"Attempted to retrieve an element outside of \"\n-                    + \"the element array\";\n+                \"Attempted to retrieve an element outside of \" +\n+                \"the element array\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         } else {\n             // Return the element requested, if the index supplied\n             // is trying to add an element beyond the boundaries of the\n             // fixed array.\n             String msg =\n-                \"Attempted to add a value to an array of fixed \"\n-                    + \"size, please use addElementRolling \"\n-                    + \"to avoid this exception\";\n+                \"Attempted to add a value to an array of fixed \" +\n+                \"size, please use addElementRolling \" +\n+                \"to avoid this exception\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         }\n     }\n--- a/src/test/org/apache/commons/math/analysis/InterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/analysis/InterpolatorTest.java\n         try {\n             double xval[] = { 0.0, 1.0 };\n             double yval[] = { 0.0, 1.0, 2.0 };\n-            UnivariateRealFunction f = i.interpolate(xval, yval);\n+            i.interpolate(xval, yval);\n             fail(\"Failed to detect data set array with different sizes.\");\n         } catch (IllegalArgumentException iae) {\n         }\n         try {\n             double xval[] = { 0.0, 1.0, 0.5 };\n             double yval[] = { 0.0, 1.0, 2.0 };\n-            UnivariateRealFunction f = i.interpolate(xval, yval);\n+            i.interpolate(xval, yval);\n             fail(\"Failed to detect unsorted arguments.\");\n         } catch (IllegalArgumentException iae) {\n         }", "timestamp": 1062904376, "metainfo": ""}