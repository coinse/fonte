{"sha": "fa2d87f2e46c0e6f136b48f27e644ad00b3263ff", "log": "added getSolver() into LUDecomposition  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n \n package org.apache.commons.math.linear;\n \n-\n /**\n  * Calculates the LUP-decomposition of a square matrix.\n  * <p>The LUP-decomposition of a matrix A consists of three matrices\n public class LUDecompositionImpl implements LUDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 3446121671437672843L;\n+    private static final long serialVersionUID = 1954692554563387537L;\n \n     /** Entries of LU decomposition. */\n     private double lu[][];\n \n     /**\n      * Calculates the LU-decomposition of the given matrix. \n-     * <p>Calling this constructor is equivalent to first call the no-arguments\n-     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n      * @param matrix The matrix to decompose.\n      * @exception InvalidMatrixException if matrix is not square\n      */\n     public LUDecompositionImpl(RealMatrix matrix)\n         throws InvalidMatrixException {\n-        decompose(matrix);\n+        this(matrix, DEFAULT_TOO_SMALL);\n     }\n \n     /**\n      * Calculates the LU-decomposition of the given matrix. \n-     * <p>Calling this constructor is equivalent to first call the no-arguments\n-     * constructor and then call {@link #decompose(RealMatrix, double)}.</p>\n      * @param matrix The matrix to decompose.\n      * @param singularityThreshold threshold (based on partial row norm)\n      * under which a matrix is considered singular\n      */\n     public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\n         throws InvalidMatrixException {\n-        decompose(matrix, singularityThreshold);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void decompose(RealMatrix matrix)\n-        throws InvalidMatrixException {\n-        decompose(matrix, DEFAULT_TOO_SMALL);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void decompose(RealMatrix matrix, double singularityThreshold)\n-        throws InvalidMatrixException {\n+\n         if (!matrix.isSquare()) {\n             throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n         }\n+\n         final int m = matrix.getColumnDimension();\n         lu = matrix.getData();\n         pivot = new int[m];\n     /** {@inheritDoc} */\n     public int[] getPivot()\n         throws IllegalStateException {\n-        return pivot;\n+        return pivot.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant() {\n+        if (singular) {\n+            return 0;\n+        } else {\n+            final int m = pivot.length;\n+            double determinant = even ? 1 : -1;\n+            for (int i = 0; i < m; i++) {\n+                determinant *= lu[i][i];\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSingular() {\n+        return singular;\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public boolean isSingular()\n-        throws IllegalStateException {\n-        return singular;\n+    public DecompositionSolver getSolver() {\n+        return new Solver(lu, pivot, singular);\n+    }\n+\n+    private static class Solver implements DecompositionSolver {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -6353105415121373022L;\n+\n+        /** Entries of LU decomposition. */\n+        private final double lu[][];\n+\n+        /** Pivot permutation associated with LU decomposition. */\n+        private final int[] pivot;\n+\n+        /** Singularity indicator. */\n+        private final boolean singular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param lu entries of LU decomposition\n+         * @param pivot pivot permutation associated with LU decomposition\n+         * @param singular singularity indicator\n+         */\n+        private Solver(final double[][] lu, final int[] pivot, final boolean singular) {\n+            this.lu       = lu;\n+            this.pivot    = pivot;\n+            this.singular = singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            return !singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] solve(double[] b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.length != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] bp = new double[m];\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b[pivot[row]];\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] /= lu[col][col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            return bp;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((RealVectorImpl) b);\n+            } catch (ClassCastException cce) {\n+\n+                final int m = pivot.length;\n+                if (b.getDimension() != m) {\n+                    throw new IllegalArgumentException(\"constant vector has wrong length\");\n+                }\n+                if (singular) {\n+                    throw new SingularMatrixException();\n+                }\n+\n+                final double[] bp = new double[m];\n+\n+                // Apply permutations to b\n+                for (int row = 0; row < m; row++) {\n+                    bp[row] = b.getEntry(pivot[row]);\n+                }\n+\n+                // Solve LY = b\n+                for (int col = 0; col < m; col++) {\n+                    for (int i = col + 1; i < m; i++) {\n+                        bp[i] -= bp[col] * lu[i][col];\n+                    }\n+                }\n+\n+                // Solve UX = Y\n+                for (int col = m - 1; col >= 0; col--) {\n+                    bp[col] /= lu[col][col];\n+                    for (int i = 0; i < col; i++) {\n+                        bp[i] -= bp[col] * lu[i][col];\n+                    }\n+                }\n+\n+                return new RealVectorImpl(bp, false);\n+\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X such that A &times; X = B\n+         * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+         * has not been called\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealVectorImpl solve(RealVectorImpl b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+            return new RealVectorImpl(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.getRowDimension() != m) {\n+                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+\n+            // Apply permutations to b\n+            final double[][] bp = new double[m][nColB];\n+            for (int row = 0; row < m; row++) {\n+                final double[] bpRow = bp[row];\n+                final int pRow = pivot[row];\n+                for (int col = 0; col < nColB; col++) {\n+                    bpRow[col] = b.getEntry(pRow, col);\n+                }\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final double[] bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    final double[] bpI = bp[i];\n+                    final double luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] -= bpCol[j] * luICol;\n+                    }\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                final double[] bpCol = bp[col];\n+                final double luDiag = lu[col][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpCol[j] /= luDiag;\n+                }\n+                for (int i = 0; i < col; i++) {\n+                    final double[] bpI = bp[i];\n+                    final double luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] -= bpCol[j] * luICol;\n+                    }\n+                }\n+            }\n+\n+            return new RealMatrixImpl(bp, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException {\n+            return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n+        }\n+\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/LUSolver.java\n+++ b/src/java/org/apache/commons/math/linear/LUSolver.java\n public class LUSolver implements DecompositionSolver {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -8775006035077527661L;\n+    private static final long serialVersionUID = -369589527412301256L;\n \n-    /** Underlying decomposition. */\n-    private final LUDecomposition decomposition;\n+    /** Underlying solver. */\n+    private final DecompositionSolver solver;\n+\n+    /** Determinant. */\n+    private final double determinant;\n \n     /**\n      * Simple constructor.\n      * @param decomposition decomposition to use\n      */\n     public LUSolver(final LUDecomposition decomposition) {\n-        this.decomposition = decomposition;\n+        this.solver      = decomposition.getSolver();\n+        this.determinant = decomposition.getDeterminant();\n     }\n \n     /** Solve the linear equation A &times; X = B for square matrices A.\n      */\n     public double[] solve(final double[] b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final int[] pivot = decomposition.getPivot();\n-        final int m = pivot.length;\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-        if (decomposition.isSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] bp = new double[m];\n-\n-        // Apply permutations to b\n-        for (int row = 0; row < m; row++) {\n-            bp[row] = b[pivot[row]];\n-        }\n-\n-        // Solve LY = b\n-        final RealMatrix l = decomposition.getL();\n-        for (int col = 0; col < m; col++) {\n-            for (int i = col + 1; i < m; i++) {\n-                bp[i] -= bp[col] * l.getEntry(i, col);\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        final RealMatrix u = decomposition.getU();\n-        for (int col = m - 1; col >= 0; col--) {\n-            bp[col] /= u.getEntry(col, col);\n-            for (int i = 0; i < col; i++) {\n-                bp[i] -= bp[col] * u.getEntry(i, col);\n-            }\n-        }\n-\n-        return bp;\n-\n+        return solver.solve(b);\n     }\n \n \n      */\n     public RealVector solve(final RealVector b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final int[] pivot = decomposition.getPivot();\n-        final int m = pivot.length;\n-        if (b.getDimension() != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-        if (decomposition.isSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] bp = new double[m];\n-\n-        // Apply permutations to b\n-        for (int row = 0; row < m; row++) {\n-            bp[row] = b.getEntry(pivot[row]);\n-        }\n-\n-        // Solve LY = b\n-        final RealMatrix l = decomposition.getL();\n-        for (int col = 0; col < m; col++) {\n-            for (int i = col + 1; i < m; i++) {\n-                bp[i] -= bp[col] * l.getEntry(i, col);\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        final RealMatrix u = decomposition.getU();\n-        for (int col = m - 1; col >= 0; col--) {\n-            bp[col] /= u.getEntry(col, col);\n-            for (int i = 0; i < col; i++) {\n-                bp[i] -= bp[col] * u.getEntry(i, col);\n-            }\n-        }\n-\n-        return new RealVectorImpl(bp, false);\n-  \n+        return solver.solve(b);\n     }\n \n     /** Solve the linear equation A &times; X = B for square matrices A.\n      */\n     public RealMatrix solve(final RealMatrix b)\n         throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final int[] pivot = decomposition.getPivot();\n-        final int m = pivot.length;\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (decomposition.isSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final int nColB = b.getColumnDimension();\n-\n-        // Apply permutations to b\n-        final double[][] bp = new double[m][nColB];\n-        for (int row = 0; row < m; row++) {\n-            final double[] bpRow = bp[row];\n-            final int pRow = pivot[row];\n-            for (int col = 0; col < nColB; col++) {\n-                bpRow[col] = b.getEntry(pRow, col);\n-            }\n-        }\n-\n-        // Solve LY = b\n-        final RealMatrix l = decomposition.getL();\n-        for (int col = 0; col < m; col++) {\n-            final double[] bpCol = bp[col];\n-            for (int i = col + 1; i < m; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = l.getEntry(i, col);\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        final RealMatrix u = decomposition.getU();\n-        for (int col = m - 1; col >= 0; col--) {\n-            final double[] bpCol = bp[col];\n-            final double luDiag = u.getEntry(col, col);\n-            for (int j = 0; j < nColB; j++) {\n-                bpCol[j] /= luDiag;\n-            }\n-            for (int i = 0; i < col; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = u.getEntry(i, col);\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        return MatrixUtils.createRealMatrix(bp);\n-\n-    }\n-\n-    /**\n-     * Return the determinant of the matrix\n-     * @return determinant of the matrix\n-     * @see #isNonSingular()\n-     */\n-    public double getDeterminant() {\n-        if (decomposition.isSingular()) {\n-            return 0;\n-        } else {\n-            final int m = decomposition.getPivot().length;\n-            final RealMatrix u = decomposition.getU();\n-            double determinant = decomposition.evenPermutation() ? 1 : -1;\n-            for (int i = 0; i < m; i++) {\n-                determinant *= u.getEntry(i, i);\n-            }\n-            return determinant;\n-        }\n+        return solver.solve(b);\n     }\n \n     /**\n      * @return true if the decomposed matrix is non-singular\n      */\n     public boolean isNonSingular() {\n-        return !decomposition.isSingular();\n+        return solver.isNonSingular();\n     }\n \n     /** Get the inverse of the decomposed matrix.\n      */\n     public RealMatrix getInverse()\n         throws InvalidMatrixException {\n-        final int m = decomposition.getPivot().length;\n-        return solve(MatrixUtils.createRealIdentityMatrix(m));\n+        return solver.getInverse();\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    public double getDeterminant() {\n+        return determinant;\n     }\n \n }", "timestamp": 1229897106, "metainfo": ""}