{"sha": "e9877e5b89b4393a29ed50f6d5273ccd10d8db1c", "log": "Use Jonathan and Peter Borwein quartic formula to compute PI, it is MUCH faster than the previous one especially for large numbers of digits and allows quicker loading of the class. It was tested to compute about 10000 decimal digits, just for the fun  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/dfp/DfpField.java\n+++ b/src/main/java/org/apache/commons/math/dfp/DfpField.java\n         }\n     }\n \n-    /** Compute &pi; by atan(1/&radic;(3)) = &pi;/6.\n+    /** Compute &pi; using Jonathan and Peter Borwein quartic formula.\n      * @param one constant with value 1 at desired precision\n      * @param two constant with value 2 at desired precision\n      * @param three constant with value 3 at desired precision\n      */\n     private static Dfp computePi(final Dfp one, final Dfp two, final Dfp three) {\n \n-        Dfp x = three;\n-        x = x.sqrt();\n-        x = one.divide(x);\n-\n-        Dfp denom = one;\n-\n-        Dfp py = new Dfp(x);\n-        Dfp y  = new Dfp(x);\n-\n-        for (int i = 1; i < 10000; i++) {\n-            x = x.divide(three);\n-            denom = denom.add(two);\n-            if ((i&1) != 0) {\n-                y = y.subtract(x.divide(denom));\n-            } else {\n-                y = y.add(x.divide(denom));\n-            }\n-            if (y.equals(py)) {\n+        Dfp sqrt2   = two.sqrt();\n+        Dfp yk      = sqrt2.subtract(one);\n+        Dfp four    = two.add(two);\n+        Dfp two2kp3 = two;\n+        Dfp ak      = two.multiply(three.subtract(two.multiply(sqrt2)));\n+\n+        // The formula converges quartically. This means the number of correct\n+        // digits is multiplied by 4 at each iteration! Five iterations are\n+        // sufficient for about 160 digits, eight iterations give about\n+        // 10000 digits (this has been checked) and 20 iterations more than\n+        // 160 billions of digits (this has NOT been checked).\n+        // So the limit here is considered sufficient for most purposes ...\n+        for (int i = 1; i < 20; i++) {\n+            final Dfp ykM1 = yk;\n+\n+            final Dfp y2         = yk.multiply(yk);\n+            final Dfp oneMinusY4 = one.subtract(y2.multiply(y2));\n+            final Dfp s          = oneMinusY4.sqrt().sqrt();\n+            yk = one.subtract(s).divide(one.add(s));\n+\n+            two2kp3 = two2kp3.multiply(four);\n+\n+            final Dfp p = one.add(yk);\n+            final Dfp p2 = p.multiply(p);\n+            ak = ak.multiply(p2.multiply(p2)).subtract(two2kp3.multiply(yk).multiply(one.add(yk).add(yk.multiply(yk))));\n+\n+            if (yk.equals(ykM1)) {\n                 break;\n             }\n-            py = new Dfp(y);\n-        }\n-\n-        return y.multiply(new Dfp(one.getField(), 6));\n+        }\n+\n+        return one.divide(ak);\n \n     }\n ", "timestamp": 1284154199, "metainfo": ""}