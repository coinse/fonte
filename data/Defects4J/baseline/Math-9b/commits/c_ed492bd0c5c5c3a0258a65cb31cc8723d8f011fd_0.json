{"sha": "ed492bd0c5c5c3a0258a65cb31cc8723d8f011fd", "log": "ported all changes from trunk between r6152100 (branch 2.0 creation) and r670469 (today) These changes contain fixes for MATH-204 and MATH-205   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n  * <p>\n  * The function should be continuous but not necessarily smooth.</p>\n  *  \n- * @version $Revision$ $Date$\n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n     \n         clearResult();\n         verifyInterval(min, max);\n         \n+        double ret = Double.NaN;\n+        \n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n-        if (yMin * yMax >= 0) {\n-            throw new IllegalArgumentException\n-            (\"Function values at endpoints do not have different signs.\" +\n-                    \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");       \n-        }\n-\n-        // solve using only the first endpoint as initial guess\n-        return solve(min, yMin, max, yMax, min, yMin);\n-\n+        double sign = yMin * yMax;\n+        if (sign > 0) {\n+            // check if either value is close to a zero\n+            if (Math.abs(yMin) <= functionValueAccuracy) {\n+                setResult(min, 0);\n+                ret = min;\n+            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n+                setResult(max, 0);\n+                ret = max;\n+            } else {\n+                // neither value is close to zero and min and max do not bracket root.\n+                throw new IllegalArgumentException\n+                (\"Function values at endpoints do not have different signs.\" +\n+                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n+                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+            }\n+        } else if (sign < 0){\n+            // solve using only the first endpoint as initial guess\n+            ret = solve(min, yMin, max, yMax, min, yMin);\n+        } else {\n+            // either min or max is a root\n+            if (yMin == 0.0) {\n+                ret = min;\n+            } else {\n+                ret = max;\n+            }\n+        }\n+\n+        return ret;\n     }\n         \n     /**\n--- a/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  * power of 2 plus one. Users should especially pay attention to the\n  * function transformation on how this affects the sampling.</p>\n  *\n- * @version $Revision$ $Date$\n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  * @since 1.2\n  */\n public class FastCosineTransformer implements Serializable {\n      * Transform the given real data set.\n      * <p>\n      * The formula is $ F_n = (1/2) [f_0 + (-1)^n f_N] +\n-     *                        \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *                        \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n      * </p>\n      * \n      * @param f the real data array to be transformed\n      * Transform the given real function, sampled on the given interval.\n      * <p>\n      * The formula is $ F_n = (1/2) [f_0 + (-1)^n f_N] +\n-     *                        \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *                        \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n      * </p>\n      * \n      * @param f the function to be sampled and transformed\n      * Transform the given real data set.\n      * <p>\n      * The formula is $ F_n = \\sqrt{1/2N} [f_0 + (-1)^n f_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *                        \\sqrt{2/N} \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n      * </p>\n      * \n      * @param f the real data array to be transformed\n      * Transform the given real function, sampled on the given interval.\n      * <p>\n      * The formula is $ F_n = \\sqrt{1/2N} [f_0 + (-1)^n f_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{k=0}^{N-1} f_k \\cos(\\pi nk/N) $\n+     *                        \\sqrt{2/N} \\Sigma_{k=1}^{N-1} f_k \\cos(\\pi nk/N) $\n      *\n      * </p>\n      * \n      * Inversely transform the given real data set.\n      * <p>\n      * The formula is $ f_k = (1/N) [F_0 + (-1)^k F_N] +\n-     *                        (2/N) \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *                        (2/N) \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n      * </p>\n      * \n      * @param f the real data array to be inversely transformed\n      * Inversely transform the given real function, sampled on the given interval.\n      * <p>\n      * The formula is $ f_k = (1/N) [F_0 + (-1)^k F_N] +\n-     *                        (2/N) \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *                        (2/N) \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n      * </p>\n      * \n      * @param f the function to be sampled and inversely transformed\n      * Inversely transform the given real data set.\n      * <p>\n      * The formula is $ f_k = \\sqrt{1/2N} [F_0 + (-1)^k F_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *                        \\sqrt{2/N} \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n      * </p>\n      * \n      * @param f the real data array to be inversely transformed\n      * Inversely transform the given real function, sampled on the given interval.\n      * <p>\n      * The formula is $ f_k = \\sqrt{1/2N} [F_0 + (-1)^k F_N] +\n-     *                        \\sqrt{2/N} \\Sigma_{n=0}^{N-1} F_n \\cos(\\pi nk/N) $\n+     *                        \\sqrt{2/N} \\Sigma_{n=1}^{N-1} F_n \\cos(\\pi nk/N) $\n      * </p>\n      * \n      * @param f the function to be sampled and inversely transformed\n--- a/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n  * default absolute accuracy of 10E-8 for sinus and the quintic function around\n  * zero, and 5..10 iterations for the other zeros.\n  * \n- * @version $Revision$ $Date$ \n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $ \n  */\n public final class BrentSolverTest extends TestCase {\n \n         assertEquals(result, 1.0, 1E-6);\n         result = UnivariateRealSolverUtils.solve(f, 0.85, 5);\n         assertEquals(result, 1.0, 1E-6);\n+    }\n+    \n+    public void testRootEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        \n+        // endpoint is root\n+        double result = solver.solve(Math.PI, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(3, Math.PI);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n     }\n     \n     public void testBadEndpoints() throws Exception {", "timestamp": 1214228806, "metainfo": ""}