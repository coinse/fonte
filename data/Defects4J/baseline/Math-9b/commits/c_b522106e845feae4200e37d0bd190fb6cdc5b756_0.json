{"sha": "b522106e845feae4200e37d0bd190fb6cdc5b756", "log": "MATH-577 Various enhancements to the \"Complex\" class, namely operators (add, subtract, ...) taking a \"double\" argument, improved consistency in the use of \"NAN\" and \"INF\" fields, updated Javadoc. Mainly due to Arne Pl\u00f6se.    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n import java.util.List;\n \n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n- * Representation of a Complex number - a number which has both a\n+ * Representation of a Complex number, i.e. a number which has both a\n  * real and imaginary part.\n- * <p>\n- * Implementations of arithmetic operations handle <code>NaN</code> and\n+ * Implementations of arithmetic operations handle {@code NaN} and\n  * infinite values according to the rules for {@link java.lang.Double}\n- * arithmetic, applying definitional formulas and returning <code>NaN</code> or\n+ * arithmetic, applying definitional formulas and returning {@code NaN} or\n  * infinite values in real or imaginary parts as these arise in computation.\n- * See individual method javadocs for details.</p>\n- * <p>\n- * {@link #equals} identifies all values with <code>NaN</code> in either real\n- * or imaginary part - e.g., <pre>\n- * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre></p>\n+ * See individual method javadocs for details.\n+ * <br/>\n+ * {@link #equals} identifies all values with {@code NaN} in either real\n+ * or imaginary part, e.g.\n+ * <pre>\n+ *  {@code 1 + NaNi  == NaN + i == NaN + NaNi.}\n+ * </pre>\n  *\n- * implements Serializable since 2.0\n+ * Implements Serializable since 2.0\n  *\n  * @version $Id$\n  */\n public class Complex implements FieldElement<Complex>, Serializable  {\n-\n     /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n     public static final Complex I = new Complex(0.0, 1.0);\n-\n     // CHECKSTYLE: stop ConstantName\n     /** A complex number representing \"NaN + NaNi\" */\n     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n     // CHECKSTYLE: resume ConstantName\n-\n     /** A complex number representing \"+INF + INFi\" */\n     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n-\n     /** A complex number representing \"1.0 + 0.0i\" */\n     public static final Complex ONE = new Complex(1.0, 0.0);\n-\n     /** A complex number representing \"0.0 + 0.0i\" */\n     public static final Complex ZERO = new Complex(0.0, 0.0);\n \n \n     /** The imaginary part. */\n     private final double imaginary;\n-\n     /** The real part. */\n     private final double real;\n-\n     /** Record whether this complex number is equal to NaN. */\n     private final transient boolean isNaN;\n-\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n \n     /**\n+     * Create a complex number given only the real part.\n+     *\n+     * @param real Real part.\n+     */\n+    public Complex(double real) {\n+        this(real, 0.0);\n+    }\n+\n+    /**\n      * Create a complex number given the real and imaginary parts.\n      *\n-     * @param real the real part\n-     * @param imaginary the imaginary part\n+     * @param real Real part.\n+     * @param imaginary Imaginary part.\n      */\n     public Complex(double real, double imaginary) {\n-        super();\n         this.real = real;\n         this.imaginary = imaginary;\n \n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n-        (Double.isInfinite(real) || Double.isInfinite(imaginary));\n+            (Double.isInfinite(real) || Double.isInfinite(imaginary));\n     }\n \n     /**\n      * Return the absolute value of this complex number.\n-     * <p>\n-     * Returns <code>NaN</code> if either real or imaginary part is\n-     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n-     * neither part is <code>NaN</code>, but at least one part takes an infinite\n-     * value.</p>\n-     *\n-     * @return the absolute value\n+     * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n+     * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n+     * but at least one part is infinite.\n+     *\n+     * @return the absolute value.\n      */\n     public double abs() {\n         if (isNaN) {\n             return Double.NaN;\n         }\n-\n         if (isInfinite()) {\n             return Double.POSITIVE_INFINITY;\n         }\n-\n         if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n             if (imaginary == 0.0) {\n                 return FastMath.abs(real);\n     }\n \n     /**\n-     * Return the sum of this complex number and the given complex number.\n-     * <p>\n+     * Returns a {@code Complex} whose value is\n+     * {@code (this + addend)}.\n      * Uses the definitional formula\n      * <pre>\n-     * (a + bi) + (c + di) = (a+c) + (b+d)i\n-     * </pre></p>\n-     * <p>\n-     * If either this or <code>rhs</code> has a NaN value in either part,\n-     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n-     * returned in the parts of the result according to the rules for\n-     * {@link java.lang.Double} arithmetic.</p>\n-     *\n-     * @param rhs the other complex number\n-     * @return the complex number sum\n-     * @throws NullArgumentException if <code>rhs</code> is null\n-     */\n-    public Complex add(Complex rhs)\n-        throws NullArgumentException {\n-        MathUtils.checkNotNull(rhs);\n-        if (isNaN || rhs.isNaN) {\n-            return NaN;\n-        }\n-        return createComplex(real + rhs.getReal(),\n-            imaginary + rhs.getImaginary());\n-    }\n-\n-    /**\n-     * Return the conjugate of this complex number. The conjugate of\n-     * \"A + Bi\" is \"A - Bi\".\n-     * <p>\n+     *  <code>\n+     *   (a + bi) + (c + di) = (a+c) + (b+d)i\n+     *  </code>\n+     * </pre>\n+     * <br/>\n+     * If either {@code this} or {@code addend} has a {@code NaN} value in\n+     * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n+     * and {@code NaN} values are returned in the parts of the result\n+     * according to the rules for {@link java.lang.Double} arithmetic.\n+     *\n+     * @param  addend Value to be added to this {@code Complex}.\n+     * @return {@code this + addend}.\n+     * @throws NullArgumentException if {@code factor} is {@code null}.\n+     */\n+    @Override\n+    public Complex add(Complex addend) throws NullArgumentException {\n+        MathUtils.checkNotNull(addend);\n+        if (isNaN || addend.isNaN) {\n+            return NaN;\n+        }\n+\n+        return createComplex(real + addend.getReal(),\n+                             imaginary + addend.getImaginary());\n+    }\n+\n+    /**\n+     * Returns a {@code Complex} whose value is\n+     * {@code (this + addend)}.\n+     *\n+     * @param addend Value to be added to this {@code Complex}.\n+     * @return {@code this + addend}.\n+     * @see #add(Complex)\n+     */\n+    public Complex add(double addend) {\n+        if (isNaN || Double.isNaN(addend)) {\n+            return NaN;\n+        }\n+\n+        return createComplex(real + addend, imaginary);\n+    }\n+\n+     /**\n+     * Return the conjugate of this complex number.\n+     * The conjugate of {@code a + bi} is {@code a - bi}.\n+     * <br/>\n      * {@link #NaN} is returned if either the real or imaginary\n-     * part of this Complex number equals <code>Double.NaN</code>.</p>\n-     * <p>\n-     * If the imaginary part is infinite, and the real part is not NaN,\n-     * the returned value has infinite imaginary part of the opposite\n-     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n-     * is <code>1 - NEGATIVE_INFINITY i</code></p>\n-     *\n-     * @return the conjugate of this Complex object\n+     * part of this Complex number equals {@code Double.NaN}.\n+     * <br/>\n+     * If the imaginary part is infinite, and the real part is not\n+     * {@code NaN}, the returned value has infinite imaginary part\n+     * of the opposite sign, e.g. the conjugate of\n+     * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\n+     *\n+     * @return the conjugate of this Complex object.\n      */\n     public Complex conjugate() {\n         if (isNaN) {\n             return NaN;\n         }\n+\n         return createComplex(real, -imaginary);\n     }\n \n     /**\n-     * Return the quotient of this complex number and the given complex number.\n-     * <p>\n+     * Returns a {@code Complex} whose value is\n+     * {@code (this / divisor)}.\n      * Implements the definitional formula\n-     * <pre><code>\n+     * <pre>\n+     *  <code>\n      *    a + bi          ac + bd + (bc - ad)i\n      *    ----------- = -------------------------\n      *    c + di         c<sup>2</sup> + d<sup>2</sup>\n-     * </code></pre>\n+     *  </code>\n+     * </pre>\n      * but uses\n      * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n      * prescaling of operands</a> to limit the effects of overflows and\n-     * underflows in the computation.</p>\n-     * <p>\n-     * Infinite and NaN values are handled / returned according to the\n+     * underflows in the computation.\n+     * <br/>\n+     * {@code Infinite} and {@code NaN} values are handled according to the\n      * following rules, applied in the order presented:\n      * <ul>\n-     * <li>If either this or <code>rhs</code> has a NaN value in either part,\n-     *  {@link #NaN} is returned.</li>\n-     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.\n-     * </li>\n-     * <li>If this and <code>rhs</code> are both infinite,\n-     * {@link #NaN} is returned.</li>\n-     * <li>If this is finite (i.e., has no infinite or NaN parts) and\n-     *  <code>rhs</code> is infinite (one or both parts infinite),\n-     * {@link #ZERO} is returned.</li>\n-     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n-     * returned in the parts of the result if the {@link java.lang.Double}\n-     * rules applied to the definitional formula force NaN results.</li>\n-     * </ul></p>\n-     *\n-     * @param rhs the other complex number\n-     * @return the complex number quotient\n-     * @throws NullArgumentException if <code>rhs</code> is null\n-     */\n-    public Complex divide(Complex rhs)\n+     *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n+     *   in either part, {@link #NaN} is returned.\n+     *  </li>\n+     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n+     *  </li>\n+     *  <li>If {@code this} and {@code divisor} are both infinite,\n+     *   {@link #NaN} is returned.\n+     *  </li>\n+     *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n+     *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n+     *   infinite), {@link #ZERO} is returned.\n+     *  </li>\n+     *  <li>If {@code this} is infinite and {@code divisor} is finite,\n+     *   {@code NaN} values are returned in the parts of the result if the\n+     *   {@link java.lang.Double} rules applied to the definitional formula\n+     *   force {@code NaN} results.\n+     *  </li>\n+     * </ul>\n+     *\n+     * @param divisor Value by which this {@code Complex} is to be divided.\n+     * @return {@code this / divisor}.\n+     * @throws NullArgumentException if {@code divisor} is {@code null}.\n+     */\n+    @Override\n+    public Complex divide(Complex divisor)\n         throws NullArgumentException {\n-        MathUtils.checkNotNull(rhs);\n-        if (isNaN || rhs.isNaN) {\n-            return NaN;\n-        }\n-\n-        double c = rhs.getReal();\n-        double d = rhs.getImaginary();\n+        MathUtils.checkNotNull(divisor);\n+        if (isNaN || divisor.isNaN) {\n+            return NaN;\n+        }\n+\n+        final double c = divisor.getReal();\n+        final double d = divisor.getImaginary();\n         if (c == 0.0 && d == 0.0) {\n             return NaN;\n         }\n \n-        if (rhs.isInfinite() && !isInfinite()) {\n+        if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n \n     }\n \n     /**\n+     * Returns a {@code Complex} whose value is\n+     * {@code (this / divisor)}.\n+     *\n+     * @param  divisor Value by which this {@code Complex} is to be divided.\n+     * @return {@code this / divisor}.\n+     * @see #divide(Complex)\n+     */\n+    public Complex divide(double divisor) {\n+        if (isNaN || Double.isNaN(divisor)) {\n+            return NaN;\n+        }\n+        if (divisor == 0.0) {\n+            return NaN;\n+        }\n+        if (Double.isInfinite(divisor) && !isInfinite()) {\n+            return ZERO;\n+        }\n+\n+        return createComplex(real / divisor,\n+                             imaginary  / divisor);\n+    }\n+\n+    /**\n      * Test for the equality of two Complex objects.\n-     * <p>\n-     * If both the real and imaginary parts of two Complex numbers\n-     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n-     * Complex objects are considered to be equal.</p>\n-     * <p>\n-     * All <code>NaN</code> values are considered to be equal - i.e, if either\n+     * If both the real and imaginary parts of two complex numbers\n+     * are exactly the same, and neither is {@code Double.NaN}, the two\n+     * Complex objects are considered to be equal.\n+     * All {@code NaN} values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal\n-     * to <code>Double.NaN</code>, the complex number is equal to\n-     * <code>Complex.NaN</code>.</p>\n+     * to {@code Double.NaN}, the complex number is equal to\n+     * {@code NaN}.\n      *\n      * @param other Object to test for equality to this\n-     * @return true if two Complex objects are equal, false if\n-     *         object is null, not an instance of Complex, or\n-     *         not equal to this Complex instance\n-     *\n+     * @return true if two Complex objects are equal, false if object is\n+     * {@code null}, not an instance of Complex, or not equal to this Complex\n+     * instance.\n      */\n     @Override\n     public boolean equals(Object other) {\n             return true;\n         }\n         if (other instanceof Complex){\n-            Complex rhs = (Complex)other;\n-            if (rhs.isNaN) {\n+            Complex c = (Complex)other;\n+            if (c.isNaN) {\n                 return isNaN;\n             } else {\n-                return (real == rhs.real) && (imaginary == rhs.imaginary);\n+                return (real == c.real) && (imaginary == c.imaginary);\n             }\n         }\n         return false;\n \n     /**\n      * Get a hashCode for the complex number.\n-     * <p>\n-     * All NaN values have the same hash code.</p>\n-     *\n-     * @return a hash code value for this object\n+     * Any {@code Double.NaN} value in real or imaginary part produces\n+     * the same hash code {@code 7}.\n+     *\n+     * @return a hash code value for this object.\n      */\n     @Override\n     public int hashCode() {\n     /**\n      * Access the imaginary part.\n      *\n-     * @return the imaginary part\n+     * @return the imaginary part.\n      */\n     public double getImaginary() {\n         return imaginary;\n     /**\n      * Access the real part.\n      *\n-     * @return the real part\n+     * @return the real part.\n      */\n     public double getReal() {\n         return real;\n     }\n \n     /**\n-     * Returns true if either or both parts of this complex number is NaN;\n-     * false otherwise\n-     *\n-     * @return  true if either or both parts of this complex number is NaN;\n-     * false otherwise\n+     * Checks whether either or both parts of this complex number is\n+     * {@code NaN}.\n+     *\n+     * @return true if either or both parts of this complex number is\n+     * {@code NaN}; false otherwise.\n      */\n     public boolean isNaN() {\n         return isNaN;\n     }\n \n     /**\n-     * Returns true if either the real or imaginary part of this complex number\n-     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or\n-     * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n-     * is <code>NaN</code>.\n+     * Checks whether either the real or imaginary part of this complex number\n+     * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or\n+     * {@code Double.NEGATIVE_INFINITY}) and neither part\n+     * is {@code NaN}.\n      *\n      * @return true if one or both parts of this complex number are infinite\n-     * and neither part is <code>NaN</code>\n+     * and neither part is {@code NaN}.\n      */\n     public boolean isInfinite() {\n         return isInfinite;\n     }\n \n     /**\n-     * Return the product of this complex number and the given complex number.\n-     * <p>\n-     * Implements preliminary checks for NaN and infinity followed by\n+     * Returns a {@code Complex} whose value is {@code this * factor}.\n+     * Implements preliminary checks for {@code NaN} and infinity followed by\n      * the definitional formula:\n-     * <pre><code>\n-     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n-     * </code></pre>\n-     * </p>\n-     * <p>\n-     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n-     * NaN parts.\n-     * </p>\n-     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n-     * NaN parts and if either this or <code>rhs</code> has one or more\n-     * infinite parts (same result is returned regardless of the sign of the\n-     * components).\n-     * </p>\n-     * <p>\n-     * Returns finite values in components of the result per the\n-     * definitional formula in all remaining cases.\n-     *  </p>\n-     *\n-     * @param rhs the other complex number\n-     * @return the complex number product\n-     * @throws NullArgumentException if <code>rhs</code> is null\n-     */\n-    public Complex multiply(Complex rhs)\n+     * <pre>\n+     *  <code>\n+     *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n+     *  </code>\n+     * </pre>\n+     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n+     * more {@code NaN} parts.\n+     * <br/>\n+     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n+     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n+     * has one or more infinite parts (same result is returned regardless of\n+     * the sign of the components).\n+     * <br/>\n+     * Returns finite values in components of the result per the definitional\n+     * formula in all remaining cases.\n+     *\n+     * @param  factor value to be multiplied by this {@code Complex}.\n+     * @return {@code this * factor}.\n+     * @throws NullArgumentException if {@code factor} is {@code null}.\n+     */\n+    @Override\n+    public Complex multiply(Complex factor)\n         throws NullArgumentException {\n-        MathUtils.checkNotNull(rhs);\n-        if (isNaN || rhs.isNaN) {\n-            return NaN;\n-        }\n-        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n-            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n-            // we don't use Complex.isInfinite() to avoid testing for NaN again\n+        MathUtils.checkNotNull(factor);\n+        if (isNaN || factor.isNaN) {\n+            return NaN;\n+        }\n+        if (Double.isInfinite(real) ||\n+            Double.isInfinite(imaginary) ||\n+            Double.isInfinite(factor.real) ||\n+            Double.isInfinite(factor.imaginary)) {\n+            // we don't use isInfinite() to avoid testing for NaN again\n             return INF;\n         }\n-        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n-                real * rhs.imaginary + imaginary * rhs.real);\n-    }\n-\n-    /**\n-     * Return the product of this complex number and the given scalar number.\n-     * <p>\n-     * Implements preliminary checks for NaN and infinity followed by\n-     * the definitional formula:\n-     * <pre><code>\n-     * c(a + bi) = (ca) + (cb)i\n-     * </code></pre>\n-     * </p>\n-     * <p>\n-     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n-     * NaN parts.\n-     * </p>\n-     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n-     * NaN parts and if either this or <code>rhs</code> has one or more\n-     * infinite parts (same result is returned regardless of the sign of the\n-     * components).\n-     * </p>\n-     * <p>\n-     * Returns finite values in components of the result per the\n-     * definitional formula in all remaining cases.\n-     *  </p>\n-     *\n-     * @param rhs the scalar number\n-     * @return the complex number product\n-     */\n-    public Complex multiply(double rhs) {\n-        if (isNaN || Double.isNaN(rhs)) {\n-            return NaN;\n-        }\n-        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n-            Double.isInfinite(rhs)) {\n-            // we don't use Complex.isInfinite() to avoid testing for NaN again\n+        return createComplex(real * factor.real - imaginary * factor.imaginary,\n+                             real * factor.imaginary + imaginary * factor.real);\n+    }\n+\n+    /**\n+     * Returns a {@code Complex} whose value is {@code this * factor}.\n+     *\n+     * @param  factor value to be multiplied by this {@code Complex}.\n+     * @return {@code this * factor}.\n+     * @see #multiply(Complex)\n+     */\n+    public Complex multiply(double factor) {\n+        if (isNaN || Double.isNaN(factor)) {\n+            return NaN;\n+        }\n+        if (Double.isInfinite(real) ||\n+            Double.isInfinite(imaginary) ||\n+            Double.isInfinite(factor)) {\n+            // we don't use isInfinite() to avoid testing for NaN again\n             return INF;\n         }\n-        return createComplex(real * rhs, imaginary * rhs);\n-    }\n-\n-    /**\n-     * Return the additive inverse of this complex number.\n-     * <p>\n-     * Returns <code>Complex.NaN</code> if either real or imaginary\n-     * part of this Complex number equals <code>Double.NaN</code>.</p>\n-     *\n-     * @return the negation of this complex number\n+        return createComplex(real * factor, imaginary * factor);\n+    }\n+\n+    /**\n+     * Returns a {@code Complex} whose value is {@code (-this)}.\n+     * Returns {@code NaN} if either real or imaginary\n+     * part of this Complex number equals {@code Double.NaN}.\n+     *\n+     * @return {@code -this}.\n      */\n     public Complex negate() {\n         if (isNaN) {\n     }\n \n     /**\n-     * Return the difference between this complex number and the given complex\n-     * number.\n-      * <p>\n+     * Returns a {@code Complex} whose value is\n+     * {@code (this - subtrahend)}.\n      * Uses the definitional formula\n      * <pre>\n-     * (a + bi) - (c + di) = (a-c) + (b-d)i\n-     * </pre></p>\n-     * <p>\n-     * If either this or <code>rhs</code> has a NaN value in either part,\n-     * {@link #NaN} is returned; otherwise infinite and NaN values are\n+     *  <code>\n+     *   (a + bi) - (c + di) = (a-c) + (b-d)i\n+     *  </code>\n+     * </pre>\n+     * If either {@code this} or {@code subtrahend} has a {@code NaN]}value in either part,\n+     * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are\n      * returned in the parts of the result according to the rules for\n-     * {@link java.lang.Double} arithmetic. </p>\n-     *\n-     * @param rhs the other complex number\n-     * @return the complex number difference\n-     * @throws NullArgumentException if <code>rhs</code> is null\n-     */\n-    public Complex subtract(Complex rhs)\n+     * {@link java.lang.Double} arithmetic.\n+     *\n+     * @param  subtrahend value to be subtracted from this {@code Complex}.\n+     * @return {@code this - subtrahend}.\n+     * @throws NullArgumentException if {@code factor} is {@code null}.\n+     */\n+    @Override\n+    public Complex subtract(Complex subtrahend)\n         throws NullArgumentException {\n-        MathUtils.checkNotNull(rhs);\n-        if (isNaN || rhs.isNaN) {\n-            return NaN;\n-        }\n-\n-        return createComplex(real - rhs.getReal(),\n-            imaginary - rhs.getImaginary());\n+        MathUtils.checkNotNull(subtrahend);\n+        if (isNaN || subtrahend.isNaN) {\n+            return NaN;\n+        }\n+\n+        return createComplex(real - subtrahend.getReal(),\n+                             imaginary - subtrahend.getImaginary());\n+    }\n+\n+    /**\n+     * Returns a {@code Complex} whose value is\n+     * {@code (this - subtrahend)}.\n+     *\n+     * @param  subtrahend value to be subtracted from this {@code Complex}.\n+     * @return {@code this - subtrahend}.\n+     * @see #subtract(Complex)\n+     */\n+    public Complex subtract(double subtrahend) {\n+        if (isNaN || Double.isNaN(subtrahend)) {\n+            return NaN;\n+        }\n+        return createComplex(real - subtrahend, imaginary);\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n      * inverse cosine</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code> or infinite.</p>\n-     *\n-     * @return the inverse cosine of this complex number\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))\n+     *  </code>\n+     * </pre>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN} or infinite.\n+     *\n+     * @return the inverse cosine of this complex number.\n      * @since 1.2\n      */\n     public Complex acos() {\n             return NaN;\n         }\n \n-        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n-              .multiply(Complex.I.negate());\n+        return this.add(this.sqrt1z().multiply(I)).log()\n+            .multiply(I.negate());\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n      * inverse sine</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code> or infinite.</p>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))\n+     *  </code>\n+     * </pre>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN} or infinite.\n      *\n      * @return the inverse sine of this complex number.\n      * @since 1.2\n             return NaN;\n         }\n \n-        return sqrt1z().add(this.multiply(Complex.I)).log()\n-              .multiply(Complex.I.negate());\n+        return sqrt1z().add(this.multiply(I)).log()\n+            .multiply(I.negate());\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n      * inverse tangent</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code> or infinite.</p>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   atan(z) = (i/2) log((i + z)/(i - z))\n+     *  </code>\n+     * </pre>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN} or infinite.\n      *\n      * @return the inverse tangent of this complex number\n      * @since 1.2\n             return NaN;\n         }\n \n-        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n-            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n+        return this.add(I).divide(I.subtract(this)).log()\n+            .multiply(I.divide(createComplex(2.0, 0.0)));\n     }\n \n     /**\n      * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n      * cosine</a>\n      * of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i\n+     *  </code>\n+     * </pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n-     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n-     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     *\n-     * @return the cosine of this complex number\n+     * infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n+     *   cos(&plusmn;INFINITY + i) = NaN + NaN i\n+     *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     *  </code>\n+     * </pre>\n+     *\n+     * @return the cosine of this complex number.\n      * @since 1.2\n      */\n     public Complex cos() {\n         }\n \n         return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n-            -FastMath.sin(real) * MathUtils.sinh(imaginary));\n+                             -FastMath.sin(real) * MathUtils.sinh(imaginary));\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n      * hyperbolic cosine</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i}\n+     *  </code>\n+     * </pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n-     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n+     * infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n+     *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     *  </code>\n+     * </pre>\n      *\n      * @return the hyperbolic cosine of this complex number.\n      * @since 1.2\n         }\n \n         return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n-            MathUtils.sinh(real) * FastMath.sin(imaginary));\n+                             MathUtils.sinh(real) * FastMath.sin(imaginary));\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n      * exponential function</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n+     *  </code>\n+     * </pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n-     * {@link java.lang.Math#sin}.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@link java.lang.Math#sin}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * exp(INFINITY + i) = INFINITY + INFINITY i\n-     * exp(-INFINITY + i) = 0 + 0i\n-     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     *\n-     * @return <i>e</i><sup><code>this</code></sup>\n+     * infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\n+     *   exp(INFINITY + i) = INFINITY + INFINITY i\n+     *   exp(-INFINITY + i) = 0 + 0i\n+     *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     *  </code>\n+     * </pre>\n+     *\n+     * @return <code><i>e</i><sup>this</sup></code>.\n      * @since 1.2\n      */\n     public Complex exp() {\n         }\n \n         double expReal = FastMath.exp(real);\n-        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n+        return createComplex(expReal *  FastMath.cos(imaginary),\n+                             expReal * FastMath.sin(imaginary));\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n      * natural logarithm</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\n+     *  </code>\n+     * </pre>\n      * where ln on the right hand side is {@link java.lang.Math#log},\n-     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n-     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@code |a + bi|} is the modulus, {@link Complex#abs},  and\n+     * {@code arg(a + bi) = {@link java.lang.Math#atan2}(b, a)}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite (or critical) values in real or imaginary parts of the input may\n-     * result in infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n-     * log(INFINITY + i) = INFINITY + 0i\n-     * log(-INFINITY + i) = INFINITY + &pi;i\n-     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n-     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n-     * log(0 + 0i) = -INFINITY + 0i\n-     * </code></pre></p>\n-     *\n-     * @return ln of this complex number.\n+     * result in infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n+     *   log(INFINITY + i) = INFINITY + 0i\n+     *   log(-INFINITY + i) = INFINITY + &pi;i\n+     *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n+     *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n+     *   log(0 + 0i) = -INFINITY + 0i\n+     *  </code>\n+     * </pre>\n+     *\n+     * @return the value <code>ln &nbsp; this</code>, the natural logarithm\n+     * of {@code this}.\n      * @since 1.2\n      */\n     public Complex log() {\n         }\n \n         return createComplex(FastMath.log(abs()),\n-            FastMath.atan2(imaginary, real));\n-    }\n-\n-    /**\n-     * Returns of value of this complex number raised to the power of <code>x</code>.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>\n-     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n-     * {@link #log}, respectively.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n-     * equals {@link Complex#ZERO}.</p>\n-     *\n-     * @param x the exponent.\n-     * @return <code>this</code><sup><code>x</code></sup>\n-     * @throws NullArgumentException if x is null\n+                             FastMath.atan2(imaginary, real));\n+    }\n+\n+    /**\n+     * Returns of value of this complex number raised to the power of {@code x}.\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   y<sup>x</sup> = exp(x&middot;log(y))\n+     *  </code>\n+     * </pre>\n+     * where {@code exp} and {@code log} are {@link #exp} and\n+     * {@link #log}, respectively.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN} or infinite, or if {@code y}\n+     * equals {@link Complex#ZERO}.\n+     *\n+     * @param  x exponent to which this {@code Complex} is to be raised.\n+     * @return <code> this<sup>{@code x}</sup></code>.\n+     * @throws NullArgumentException if x is {@code null}.\n      * @since 1.2\n      */\n     public Complex pow(Complex x)\n     }\n \n     /**\n+     * Returns of value of this complex number raised to the power of {@code x}.\n+     *\n+     * @param  x exponent to which this {@code Complex} is to be raised.\n+     * @return <code>this<sup>x</sup></code>.\n+     * @see #pow(Complex)\n+     */\n+     public Complex pow(double x) {\n+        return this.log().multiply(x).exp();\n+    }\n+\n+    /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n      * sine</a>\n      * of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i\n+     *  </code>\n+     * </pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n-     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n-     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n+     * infinite or {@code NaN} values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n+     *   sin(&plusmn;INFINITY + i) = NaN + NaN i\n+     *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     *  </code>\n+     * </pre>\n      *\n      * @return the sine of this complex number.\n      * @since 1.2\n         }\n \n         return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n-            FastMath.cos(real) * MathUtils.sinh(imaginary));\n+                             FastMath.cos(real) * MathUtils.sinh(imaginary));\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n      * hyperbolic sine</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\n+     *  </code>\n+     * </pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n-     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     *\n-     * @return the hyperbolic sine of this complex number\n+     * infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n+     *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     *  </code>\n+     * </pre>\n+     *\n+     * @return the hyperbolic sine of {@code this}.\n      * @since 1.2\n      */\n     public Complex sinh() {\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n      * square root</a> of this complex number.\n-     * <p>\n-     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:\n-     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n-     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n-     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n+     * Implements the following algorithm to compute {@code sqrt(a + bi)}:\n+     * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\n+     * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}\n+     *  else return {@code |b|/2t + sign(b)t i }</pre></li>\n      * </ol>\n      * where <ul>\n-     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n-     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n-     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n-     * </ul></p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * <li>{@code |a| = {@link Math#abs}(a)}</li>\n+     * <li>{@code |a + bi| = {@link Complex#abs}(a + bi) }</li>\n+     * <li>{@code sign(b) =  {@link MathUtils#indicator}(b) }\n+     * </ul>\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n-     * sqrt(INFINITY + i) = INFINITY + 0i\n-     * sqrt(-INFINITY + i) = 0 + INFINITY i\n-     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n-     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n-     * </code></pre></p>\n-     *\n-     * @return the square root of this complex number\n+     * infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n+     *   sqrt(INFINITY + i) = INFINITY + 0i\n+     *   sqrt(-INFINITY + i) = 0 + INFINITY i\n+     *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n+     *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n+     *  </code>\n+     * </pre>\n+     *\n+     * @return the square root of {@code this}.\n      * @since 1.2\n      */\n     public Complex sqrt() {\n             return createComplex(t, imaginary / (2.0 * t));\n         } else {\n             return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n-                MathUtils.indicator(imaginary) * t);\n+                                 MathUtils.indicator(imaginary) * t);\n         }\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n-     * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex\n+     * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\n      * number.\n-     * <p>\n      * Computes the result directly as\n-     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@code sqrt(ONE.subtract(z.multiply(z)))}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.</p>\n-     *\n-     * @return the square root of 1 - <code>this</code><sup>2</sup>\n+     * infinite or NaN values returned in parts of the result.\n+     *\n+     * @return the square root of <code>1 - this<sup>2</sup></code>.\n      * @since 1.2\n      */\n     public Complex sqrt1z() {\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n      * tangent</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n+     *  </code>\n+     * </pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite (or critical) values in real or imaginary parts of the input may\n-     * result in infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n-     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n-     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n-     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>\n-     *\n-     * @return the tangent of this complex number\n+     * result in infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\n+     *   tan(&plusmn;INFINITY + i) = NaN + NaN i\n+     *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n+     *  </code>\n+     * </pre>\n+     *\n+     * @return the tangent of {@code this}.\n      * @since 1.2\n      */\n     public Complex tan() {\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);\n \n-        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n+        return createComplex(FastMath.sin(real2) / d,\n+                             MathUtils.sinh(imaginary2) / d);\n     }\n \n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n      * hyperbolic tangent</a> of this complex number.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n+     * Implements the formula:\n+     * <pre>\n+     *  <code>\n+     *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n+     *  </code>\n+     * </pre>\n      * where the (real) functions on the right-hand side are\n      * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the\n-     * input argument is <code>NaN</code>.</p>\n-     * <p>\n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n+     * <br/>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n+     * input argument is {@code NaN}.\n+     * <br/>\n      * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples:\n-     * <code>\n-     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n-     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n-     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>\n-     *\n-     * @return the hyperbolic tangent of this complex number\n+     * infinite or NaN values returned in parts of the result.\n+     * <pre>\n+     *  Examples:\n+     *  <code>\n+     *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     *   tanh(&plusmn;INFINITY + i) = NaN + 0 i\n+     *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n+     *  </code>\n+     * </pre>\n+     *\n+     * @return the hyperbolic tangent of {@code this}.\n      * @since 1.2\n      */\n     public Complex tanh() {\n         double imaginary2 = 2.0 * imaginary;\n         double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);\n \n-        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n-    }\n-\n-\n-\n-    /**\n-     * <p>Compute the argument of this complex number.\n-     * </p>\n-     * <p>The argument is the angle phi between the positive real axis and the point\n-     * representing this number in the complex plane. The value returned is between -PI (not inclusive)\n-     * and PI (inclusive), with negative values returned for numbers with negative imaginary parts.\n-     * </p>\n-     * <p>If either real or imaginary part (or both) is NaN, NaN is returned.  Infinite parts are handled\n-     * as java.Math.atan2 handles them, essentially treating finite parts as zero in the presence of\n-     * an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite\n-     * parts.  See the javadoc for java.Math.atan2 for full details.</p>\n-     *\n-     * @return the argument of this complex number\n+        return createComplex(MathUtils.sinh(real2) / d,\n+                             FastMath.sin(imaginary2) / d);\n+    }\n+\n+\n+\n+    /**\n+     * Compute the argument of this complex number.\n+     * The argument is the angle phi between the positive real axis and\n+     * the point representing this number in the complex plane.\n+     * The value returned is between -PI (not inclusive)\n+     * and PI (inclusive), with negative values returned for numbers with\n+     * negative imaginary parts.\n+     * <br/>\n+     * If either real or imaginary part (or both) is NaN, NaN is returned.\n+     * Infinite parts are handled as {@code Math.atan2} handles them,\n+     * essentially treating finite parts as zero in the presence of an\n+     * infinite coordinate and returning a multiple of pi/4 depending on\n+     * the signs of the infinite parts.\n+     * See the javadoc for {@code Math.atan2} for full details.\n+     *\n+     * @return the argument of {@code this}.\n      */\n     public double getArgument() {\n         return FastMath.atan2(getImaginary(), getReal());\n     }\n \n     /**\n-     * <p>Computes the n-th roots of this complex number.\n-     * </p>\n-     * <p>The nth roots are defined by the formula: <pre>\n-     * <code> z<sub>k</sub> = abs<sup> 1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))</code></pre>\n-     * for <i><code>k=0, 1, ..., n-1</code></i>, where <code>abs</code> and <code>phi</code> are\n-     * respectively the {@link #abs() modulus} and {@link #getArgument() argument} of this complex number.\n-     * </p>\n-     * <p>If one or both parts of this complex number is NaN, a list with just one element,\n-     *  {@link #NaN} is returned.</p>\n-     * <p>if neither part is NaN, but at least one part is infinite, the result is a one-element\n-     * list containing {@link #INF}.</p>\n-     *\n-     * @param n degree of root\n-     * @return List<Complex> all nth roots of this complex number\n-     * @throws IllegalArgumentException if parameter n is less than or equal to 0\n+     * Computes the n-th roots of this complex number.\n+     * The nth roots are defined by the formula:\n+     * <pre>\n+     *  <code>\n+     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n+     *  </code>\n+     * </pre>\n+     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n+     * are respectively the {@link #abs() modulus} and\n+     * {@link #getArgument() argument} of this complex number.\n+     * <br/>\n+     * If one or both parts of this complex number is NaN, a list with just\n+     * one element, {@link #NaN} is returned.\n+     * if neither part is NaN, but at least one part is infinite, the result\n+     * is a one-element list containing {@link #INF}.\n+     *\n+     * @param n Degree of root.\n+     * @return a List<Complex> of all {@code n}-th roots of {@code this}.\n+     * @throws NotPositiveException if {@code n <= 0}.\n      * @since 2.0\n      */\n-    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n+    public List<Complex> nthRoot(int n) {\n \n         if (n <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n-                    n);\n-        }\n-\n-        List<Complex> result = new ArrayList<Complex>();\n+            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n+                                           n);\n+        }\n+\n+        final List<Complex> result = new ArrayList<Complex>();\n \n         if (isNaN) {\n             result.add(NaN);\n             return result;\n         }\n-\n         if (isInfinite()) {\n             result.add(INF);\n             return result;\n         final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n \n         // Compute nth roots of complex number with k = 0, 1, ... n-1\n-        final double nthPhi = getArgument()/n;\n+        final double nthPhi = getArgument() / n;\n         final double slice = 2 * FastMath.PI / n;\n         double innerPart = nthPhi;\n         for (int k = 0; k < n ; k++) {\n             // inner part\n-            final double realPart      = nthRootOfAbs *  FastMath.cos(innerPart);\n+            final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n             final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n             result.add(createComplex(realPart, imaginaryPart));\n             innerPart += slice;\n     /**\n      * Create a complex number given the real and imaginary parts.\n      *\n-     * @param realPart the real part\n-     * @param imaginaryPart the imaginary part\n-     * @return a new complex number instance\n-     * @since 1.2\n-     */\n-    protected Complex createComplex(double realPart, double imaginaryPart) {\n+     * @param realPart Real part.\n+     * @param imaginaryPart Imaginary part.\n+     * @return a new complex number instance.\n+     * @since 1.2\n+     * @see #valueOf(double, double)\n+     */\n+    protected Complex createComplex(double realPart,\n+                                    double imaginaryPart) {\n         return new Complex(realPart, imaginaryPart);\n     }\n \n     /**\n-     * <p>Resolve the transient fields in a deserialized Complex Object.</p>\n-     * <p>Subclasses will need to override {@link #createComplex} to deserialize properly</p>\n+     * Create a complex number given the real and imaginary parts.\n+     *\n+     * @param realPart Real part.\n+     * @param imaginaryPart Imaginary part.\n+     * @return a Complex instance.\n+     */\n+    public static Complex valueOf(double realPart,\n+                                  double imaginaryPart) {\n+        if (Double.isNaN(realPart) ||\n+            Double.isNaN(imaginaryPart)) {\n+            return NaN;\n+        }\n+        return new Complex(realPart, imaginaryPart);\n+    }\n+\n+    /**\n+     * Create a complex number given only the real part.\n+     *\n+     * @param realPart Real part.\n+     * @return a Complex instance.\n+     */\n+    public static Complex valueOf(double realPart) {\n+        if (Double.isNaN(realPart)) {\n+            return NaN;\n+        }\n+        return new Complex(realPart);\n+    }\n+\n+    /**\n+     * Resolve the transient fields in a deserialized Complex Object.\n+     * Subclasses will need to override {@link #createComplex} to\n+     * deserialize properly.\n+     *\n      * @return A Complex instance with all fields resolved.\n      * @since 2.0\n      */\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public ComplexField getField() {\n         return ComplexField.getInstance();\n     }\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n     public void testAddNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.add(Complex.NaN);\n-        Assert.assertTrue(z.isNaN());\n+        Assert.assertSame(Complex.NaN, z);\n         z = new Complex(1, nan);\n         Complex w = x.add(z);\n-        Assert.assertTrue(Double.isNaN(w.getReal()));\n-        Assert.assertTrue(Double.isNaN(w.getImaginary()));\n-    }\n-\n-    @Test\n-    public void testAddInfinite() {\n+        Assert.assertSame(Complex.NaN, w);\n+    }\n+\n+    @Test\n+    public void testAddInf() {\n         Complex x = new Complex(1, 1);\n         Complex z = new Complex(inf, 0);\n         Complex w = x.add(z);\n         Assert.assertTrue(Double.isNaN(x.add(z).getReal()));\n     }\n \n+    \n+    @Test\n+    public void testScalarAdd() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double yDouble = 2.0;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.add(yComplex), x.add(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarAddNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double yDouble = Double.NaN;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.add(yComplex), x.add(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarAddInf() {\n+        Complex x = new Complex(1, 1);\n+        double yDouble = Double.POSITIVE_INFINITY;\n+        \n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.add(yComplex), x.add(yDouble));\n+\n+        x = new Complex(neginf, 0);\n+        Assert.assertEquals(x.add(yComplex), x.add(yDouble));\n+    }\n+\n     @Test\n     public void testConjugate() {\n         Complex x = new Complex(3.0, 4.0);\n     }\n \n     @Test\n-    public void testDivideInfinite() {\n+    public void testDivideInf() {\n         Complex x = new Complex(3, 4);\n         Complex w = new Complex(neginf, inf);\n         Assert.assertTrue(x.divide(w).equals(Complex.ZERO));\n     }\n \n     @Test\n+    public void testScalarDivide() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double yDouble = 2.0;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.divide(yComplex), x.divide(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarDivideNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double yDouble = Double.NaN;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.divide(yComplex), x.divide(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarDivideInf() {\n+        Complex x = new Complex(1,1);\n+        double yDouble = Double.POSITIVE_INFINITY;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.divide(yComplex), x.divide(yDouble));\n+\n+        yDouble = Double.NEGATIVE_INFINITY;\n+        yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.divide(yComplex), x.divide(yDouble));\n+    }\n+\n+    @Test\n     public void testMultiply() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n     public void testMultiplyNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.multiply(Complex.NaN);\n-        Assert.assertTrue(z.isNaN());\n+        Assert.assertSame(Complex.NaN, z);\n     }\n \n     @Test\n         w = negInfNegInf.multiply(oneNaN);\n         Assert.assertTrue(Double.isNaN(w.getReal()));\n         Assert.assertTrue(Double.isNaN(w.getImaginary()));\n+        \n+        z = new Complex(1, neginf);\n+        Assert.assertSame(Complex.INF, z.multiply(z));\n     }\n \n     @Test\n     public void testScalarMultiply() {\n         Complex x = new Complex(3.0, 4.0);\n-        double y = 2.0;\n-        Complex z = x.multiply(y);\n-        Assert.assertEquals(6.0, z.getReal(), 1.0e-5);\n-        Assert.assertEquals(8.0, z.getImaginary(), 1.0e-5);\n+        double yDouble = 2.0;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n     }\n \n     @Test\n     public void testScalarMultiplyNaN() {\n         Complex x = new Complex(3.0, 4.0);\n-        Complex z = x.multiply(Double.NaN);\n-        Assert.assertTrue(z.isNaN());\n+        double yDouble = Double.NaN;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n     }\n \n     @Test\n     public void testScalarMultiplyInf() {\n-        Complex z = new Complex(1,1);\n-        Complex w = z.multiply(Double.POSITIVE_INFINITY);\n-        Assert.assertEquals(w.getReal(), inf, 0);\n-        Assert.assertEquals(w.getImaginary(), inf, 0);\n-\n-        w = z.multiply(Double.NEGATIVE_INFINITY);\n-        Assert.assertEquals(w.getReal(), inf, 0);\n-        Assert.assertEquals(w.getImaginary(), inf, 0);\n+        Complex x = new Complex(1,1);\n+        double yDouble = Double.POSITIVE_INFINITY;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n+        \n+        yDouble = Double.NEGATIVE_INFINITY;\n+         yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble));\n     }\n \n     @Test\n     public void testSubtractNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.subtract(Complex.NaN);\n-        Assert.assertTrue(z.isNaN());\n-    }\n-\n+        Assert.assertSame(Complex.NaN, z);\n+        z = new Complex(1, nan);\n+        Complex w = x.subtract(z);\n+        Assert.assertSame(Complex.NaN, w);\n+    }\n+\n+    @Test\n+    public void testSubtractInf() {\n+        Complex x = new Complex(1, 1);\n+        Complex z = new Complex(neginf, 0);\n+        Complex w = x.subtract(z);\n+        Assert.assertEquals(w.getImaginary(), 1, 0);\n+        Assert.assertEquals(inf, w.getReal(), 0);\n+\n+        x = new Complex(neginf, 0);\n+        Assert.assertTrue(Double.isNaN(x.subtract(z).getReal()));\n+    }\n+    \n+    @Test\n+    public void testScalarSubtract() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double yDouble = 2.0;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarSubtractNaN() {\n+        Complex x = new Complex(3.0, 4.0);\n+        double yDouble = Double.NaN;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarSubtractInf() {\n+        Complex x = new Complex(1, 1);\n+        double yDouble = Double.POSITIVE_INFINITY;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));\n+\n+        x = new Complex(neginf, 0);\n+        Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble));\n+    }\n+\n+    \n     @Test\n     public void testEqualsNull() {\n         Complex x = new Complex(3.0, 4.0);\n         Assert.assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n         Assert.assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n     }\n-\n+    \n     @Test\n     public void testAcos() {\n         Complex z = new Complex(3, 4);\n                new Complex(-1, 3).pow(Complex.ZERO), 10e-12);\n    }\n \n+    @Test\n+    public void testScalarPow() {\n+        Complex x = new Complex(3, 4);\n+        double yDouble = 5.0;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.pow(yComplex), x.pow(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarPowNaNBase() {\n+        Complex x = Complex.NaN;\n+        double yDouble = 5.0;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.pow(yComplex), x.pow(yDouble));\n+    }\n+\n+    @Test\n+    public void testScalarPowNaNExponent() {\n+        Complex x = new Complex(3, 4);\n+        double yDouble = Double.NaN;\n+        Complex yComplex = new Complex(yDouble);\n+        Assert.assertEquals(x.pow(yComplex), x.pow(yDouble));\n+    }\n+\n+   @Test\n+   public void testScalarPowInf() {\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.POSITIVE_INFINITY));\n+       TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.NEGATIVE_INFINITY));\n+       TestUtils.assertSame(Complex.NaN,infOne.pow(1.0));\n+       TestUtils.assertSame(Complex.NaN,negInfOne.pow(1.0));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(1.0));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(1.0));\n+       TestUtils.assertSame(Complex.NaN,negInfInf.pow(10));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(1.0));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY));\n+       TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(Double.POSITIVE_INFINITY));\n+       TestUtils.assertSame(Complex.NaN,infInf.pow(Double.NEGATIVE_INFINITY));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.NEGATIVE_INFINITY));\n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.POSITIVE_INFINITY));\n+   }\n+\n+   @Test\n+   public void testScalarPowZero() {\n+       TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(1.0));\n+       TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(0.0));\n+       TestUtils.assertEquals(Complex.ONE, Complex.ONE.pow(0.0), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE, Complex.I.pow(0.0), 10e-12);\n+       TestUtils.assertEquals(Complex.ONE, new Complex(-1, 3).pow(0.0), 10e-12);\n+   }\n+\n     @Test(expected=NullArgumentException.class)\n     public void testpowNull() {\n         Complex.ONE.pow(null);", "timestamp": 1311506515, "metainfo": ""}