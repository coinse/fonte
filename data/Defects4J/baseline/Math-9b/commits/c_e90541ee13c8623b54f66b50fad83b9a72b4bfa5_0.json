{"sha": "e90541ee13c8623b54f66b50fad83b9a72b4bfa5", "log": "added new simple convergence checkers implementations  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/RealConvergenceChecker.java\n+++ b/src/java/org/apache/commons/math/optimization/RealConvergenceChecker.java\n  * user should provide a class implementing this interface to allow the optimization\n  * algorithm to stop its search according to the problem at hand.</p>\n  * <p>For convenience, two implementations that fit simple needs are already provided:\n- * {@link SimpleScalarValueChecker} and {@link SimpleScalarPointChecker}. The first\n+ * {@link SimpleScalarValueChecker} and {@link SimpleRealPointChecker}. The first\n  * one considers convergence is reached when the objective function value does not\n  * change much anymore, it does not use the point set at all. The second one\n  * considers convergence is reached when the input point set does not change\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link RealConvergenceChecker} interface using\n+ * only point coordinates.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between each point coordinate are smaller than a threshold\n+ * or if either the absolute difference between the point coordinates are\n+ * smaller than another threshold.\n+ * </p>\n+ * @version $Revision: 757180 $ $Date: 2009-03-22 13:54:45 +0100 (dim., 22 mars 2009) $\n+ * @since 2.0\n+ */\n+public class SimpleRealPointChecker implements RealConvergenceChecker {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 2490271385513842607L;\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleRealPointChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleRealPointChecker(final double relativeThreshold,\n+                                 final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final RealPointValuePair previous,\n+                             final RealPointValuePair current) {\n+        final double[] p        = previous.getPoint();\n+        final double[] c        = current.getPoint();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double difference = Math.abs(p[i] - c[i]);\n+            final double size       = Math.max(Math.abs(p[i]), Math.abs(c[i]));\n+            if ((difference > (size * relativeThreshold)) && (difference > absoluteThreshold)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n+ * only point coordinates.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between each point coordinate are smaller than a threshold\n+ * or if either the absolute difference between the point coordinates are\n+ * smaller than another threshold.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimpleVectorialPointChecker implements VectorialConvergenceChecker {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 6571098732056285089L;\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleVectorialPointChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleVectorialPointChecker(final double relativeThreshold,\n+                                       final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final VectorialPointValuePair previous,\n+                             final VectorialPointValuePair current) {\n+        final double[] p = previous.getPointRef();\n+        final double[] c = current.getPointRef();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double pi         = p[i];\n+            final double ci         = c[i];\n+            final double difference = Math.abs(pi - ci);\n+            final double size       = Math.max(Math.abs(pi), Math.abs(ci));\n+            if ((difference > (size * relativeThreshold)) &&\n+                (difference > absoluteThreshold)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}", "timestamp": 1237932752, "metainfo": ""}