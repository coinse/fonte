{"sha": "6c2bc82c1bb4ca83535ee0b2694dcbcdf7da1340", "log": "In o.a.c.m.transform.FastFourierTransformer   - created enum Normalization{STANDARD, UNITARY}   - removed factory methods create() and createUnitary(), and made constructor public   - added parameter type to static method transformInPlace(double[][], Normalization, boolean) See MATH-732  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.transform.FastFourierTransformer.Normalization;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n             x[n - i] = a + b;\n             t1 += c;\n         }\n-        FastFourierTransformer transformer = FastFourierTransformer.create();\n+        FastFourierTransformer transformer;\n+        transformer = new FastFourierTransformer(Normalization.STANDARD);\n         Complex[] y = transformer.transform(x);\n \n         // reconstruct the FCT result for the original array\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n  */\n public class FastFourierTransformer implements Serializable {\n \n+    /** The various types of normalizations that can be applied. */\n+    public static enum Normalization {\n+        /** Standard DFT. */\n+        STANDARD,\n+\n+        /** Unitary DFT. */\n+        UNITARY;\n+    }\n+\n     /** Serializable version identifier. */\n-    static final long serialVersionUID = 20120802L;\n+    static final long serialVersionUID = 20120902L;\n \n     /**\n      * {@code W_SUB_N_R[i]} is the real part of\n             , -0x1.921fb54442d18p-58, -0x1.921fb54442d18p-59, -0x1.921fb54442d18p-60 };\n \n     /**\n-     * {@code true} if the unitary version of the DFT should be used.\n-     *\n-     * @see #create()\n-     * @see #createUnitary()\n-     */\n-    private final boolean unitary;\n+     * The type of DFT to be performed.\n+     */\n+    private final Normalization type;\n \n     /**\n      * Creates a new instance of this class, with various normalization\n      * conventions.\n      *\n-     * @param unitary {@code false} if the DFT is <em>not</em> to be scaled,\n-     * {@code true} if it is to be scaled so as to make the transform unitary.\n-     * @see #create()\n-     * @see #createUnitary()\n-     */\n-    private FastFourierTransformer(final boolean unitary) {\n-        this.unitary = unitary;\n-    }\n-\n-\n-    /**\n-     * <p>\n-     * Returns a new instance of this class. The returned transformer uses the\n-     * <a href=\"#standard\">standard normalizing conventions</a>.\n-     * </p>\n-     *\n-     * @return a new DFT transformer, with standard normalizing conventions\n-     */\n-    public static FastFourierTransformer create() {\n-        return new FastFourierTransformer(false);\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns a new instance of this class. The returned transformer uses the\n-     * <a href=\"#unitary\">unitary normalizing conventions</a>.\n-     * </p>\n-     *\n-     * @return a new DFT transformer, with unitary normalizing conventions\n-     */\n-    public static FastFourierTransformer createUnitary() {\n-        return new FastFourierTransformer(true);\n-    }\n-\n-    public static void bitReversalShuffle2(double[] a, double[] b) {\n+     * @param type the type of transform to be computed\n+     */\n+    public FastFourierTransformer(final Normalization type) {\n+        this.type = type;\n+    }\n+\n+    /**\n+     * Performs identical index bit reversal shuffles on two arrays of identical\n+     * size. Each element in the array is swapped with another element based on\n+     * the bit-reversal of the index. For example, in an array with length 16,\n+     * item at binary index 0011 (decimal 3) would be swapped with the item at\n+     * binary index 1100 (decimal 12).\n+     *\n+     * @param a the first array to be shuffled\n+     * @param b the second array to be shuffled\n+     */\n+    private static void bitReversalShuffle2(double[] a, double[] b) {\n         final int n = a.length;\n-        assert(b.length == n);\n+        assert b.length == n;\n         final int halfOfN = n >> 1;\n \n         int j = 0;\n                 k >>= 1;\n             }\n             j += k;\n+        }\n+    }\n+\n+    /**\n+     * Applies the proper normalization to the specified transformed data.\n+     *\n+     * @param dataRI the unscaled transformed data\n+     * @param type the type of transform\n+     * @param inverse {@code true} if normalization should be performed for the\n+     * inverse transform\n+     */\n+    private static void normalizeTransformedData(final double[][] dataRI,\n+        final Normalization type, final boolean inverse) {\n+\n+        final double[] dataR = dataRI[0];\n+        final double[] dataI = dataRI[1];\n+        final int n = dataR.length;\n+        assert dataI.length == n;\n+\n+        switch (type) {\n+            case STANDARD:\n+                if (inverse) {\n+                    final double scaleFactor = 1.0 / ((double) n);\n+                    for (int i = 0; i < n; i++) {\n+                        dataR[i] *= scaleFactor;\n+                        dataI[i] *= scaleFactor;\n+                    }\n+                }\n+                break;\n+            case UNITARY:\n+                final double scaleFactor = 1.0 / FastMath.sqrt(n);\n+                for (int i = 0; i < n; i++) {\n+                    dataR[i] *= scaleFactor;\n+                    dataI[i] *= scaleFactor;\n+                }\n+                break;\n+            default:\n+                /*\n+                 * This should never occur in normal conditions. However this\n+                 * clause has been added as a safeguard if other types of\n+                 * normalizations are ever implemented, and the corresponding\n+                 * test is forgotten in the present switch.\n+                 */\n+                throw new MathIllegalStateException();\n         }\n     }\n \n      *\n      * @param dataRI the two dimensional array of real and imaginary parts of\n      * the data\n+     * @param type the type of normalization to be applied to the transformed\n+     * data\n      * @param inverse {@code true} if the inverse standard transform must be\n      * performed\n      * @throws DimensionMismatchException if the number of rows of the specified\n      * a power of two\n      */\n     public static void transformInPlace(final double[][] dataRI,\n-        boolean inverse) throws\n+        final Normalization type, final boolean inverse) throws\n         DimensionMismatchException, MathIllegalArgumentException {\n \n         if (dataRI.length != 2) {\n             dataR[1] = srcR0 - srcR1;\n             dataI[1] = srcI0 - srcI1;\n \n-            if (inverse) {\n-                dataR[0] /= 2;\n-                dataI[0] /= 2;\n-                dataR[1] /= 2;\n-                dataI[1] /= 2;\n-            }\n+            normalizeTransformedData(dataRI, type, inverse);\n             return;\n         }\n \n             lastLogN0 = logN0;\n         }\n \n-        if (inverse) {\n-            final double scaleFactor = 1.0 / ((double) n);\n-            for (int i = 0; i < n; i++) {\n-                dataR[i] *= scaleFactor;\n-                dataI[i] *= scaleFactor;\n-            }\n-        }\n+        normalizeTransformedData(dataRI, type, inverse);\n     }\n \n     /**\n             MathArrays.copyOf(f, f.length), new double[f.length]\n         };\n \n-        transformInPlace(dataRI, false);\n-\n-        if (unitary) {\n-            final double s = 1.0 / FastMath.sqrt(f.length);\n-            TransformUtils.scaleArray(dataRI[0], s);\n-            TransformUtils.scaleArray(dataRI[1], s);\n-        }\n+        transformInPlace(dataRI, type, false);\n+\n+//        if (unitary) {\n+//            final double s = 1.0 / FastMath.sqrt(f.length);\n+//            TransformUtils.scaleArray(dataRI[0], s);\n+//            TransformUtils.scaleArray(dataRI[1], s);\n+//        }\n \n         return TransformUtils.createComplexArray(dataRI);\n     }\n     public Complex[] transform(Complex[] f) {\n         final double[][] dataRI = TransformUtils.createRealImaginaryArray(f);\n \n-        transformInPlace(dataRI, false);\n-\n-        if (unitary) {\n-            final double s = 1.0 / FastMath.sqrt(f.length);\n-            TransformUtils.scaleArray(dataRI[0], s);\n-            TransformUtils.scaleArray(dataRI[1], s);\n-        }\n+        transformInPlace(dataRI, type, false);\n+        // if (unitary) {\n+        // final double s = 1.0 / FastMath.sqrt(f.length);\n+        // TransformUtils.scaleArray(dataRI[0], s);\n+        // TransformUtils.scaleArray(dataRI[1], s);\n+        // }\n \n         return TransformUtils.createComplexArray(dataRI);\n     }\n             MathArrays.copyOf(f, f.length), new double[f.length]\n         };\n \n-        transformInPlace(dataRI, true);\n-\n-        if (unitary) {\n-            final double s = FastMath.sqrt(f.length);\n-            TransformUtils.scaleArray(dataRI[0], s);\n-            TransformUtils.scaleArray(dataRI[1], s);\n-        }\n+        transformInPlace(dataRI, type, true);\n+        // if (unitary) {\n+        // final double s = FastMath.sqrt(f.length);\n+        // TransformUtils.scaleArray(dataRI[0], s);\n+        // TransformUtils.scaleArray(dataRI[1], s);\n+        // }\n \n         return TransformUtils.createComplexArray(dataRI);\n     }\n         final double[] dataR = dataRI[0];\n         final double[] dataI = dataRI[1];\n \n-        transformInPlace(dataRI, true);\n-\n-        if (unitary) {\n-            final double s = FastMath.sqrt(f.length);\n-            TransformUtils.scaleArray(dataR, s);\n-            TransformUtils.scaleArray(dataI, s);\n-        }\n+        transformInPlace(dataRI, type, true);\n+//        if (unitary) {\n+//            final double s = FastMath.sqrt(f.length);\n+//            TransformUtils.scaleArray(dataR, s);\n+//            TransformUtils.scaleArray(dataI, s);\n+//        }\n \n         return TransformUtils.createComplexArray(dataRI);\n     }\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n import org.apache.commons.math.exception.NonMonotonicSequenceException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.transform.FastFourierTransformer.Normalization;\n import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n             x[i]     = a + b;\n             x[n - i] = a - b;\n         }\n-        FastFourierTransformer transformer = FastFourierTransformer.create();\n+        FastFourierTransformer transformer;\n+        transformer = new FastFourierTransformer(Normalization.STANDARD);\n         Complex[] y = transformer.transform(x);\n \n         // reconstruct the FST result for the original array\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.transform.FastFourierTransformer.Normalization;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n     public void testStandardTransformComplexSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.transform(x);\n     }\n \n     public void testStandardTransformRealSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final double[] x = createRealData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.transform(x);\n     }\n \n     public void testStandardTransformFunctionSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.transform(f, 0.0, Math.PI, n);\n     }\n \n     public void testStandardTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n         final int n = -128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.transform(f, 0.0, Math.PI, n);\n     }\n \n     public void testStandardTransformFunctionInvalidBounds() {\n         final int n = 128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.transform(f, Math.PI, 0.0, n);\n     }\n \n     public void testStandardInverseTransformComplexSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.inverseTransform(x);\n     }\n \n     public void testStandardInverseTransformRealSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final double[] x = createRealData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.inverseTransform(x);\n     }\n \n     public void testStandardInverseTransformFunctionSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.inverseTransform(f, 0.0, Math.PI, n);\n     }\n \n     public void testStandardInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n         final int n = -128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.inverseTransform(f, 0.0, Math.PI, n);\n     }\n \n     public void testStandardInverseTransformFunctionInvalidBounds() {\n         final int n = 128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.STANDARD);\n         fft.transform(f, Math.PI, 0.0, n);\n     }\n \n     public void testUnitaryTransformComplexSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.transform(x);\n     }\n \n     public void testUnitaryTransformRealSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final double[] x = createRealData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.transform(x);\n     }\n \n     public void testUnitaryTransformFunctionSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.transform(f, 0.0, Math.PI, n);\n     }\n \n     public void testUnitaryTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n         final int n = -128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.transform(f, 0.0, Math.PI, n);\n     }\n \n     public void testUnitaryTransformFunctionInvalidBounds() {\n         final int n = 128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.transform(f, Math.PI, 0.0, n);\n     }\n \n     public void testUnitaryInverseTransformComplexSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final Complex[] x = createComplexData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.inverseTransform(x);\n     }\n \n     public void testUnitaryInverseTransformRealSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final double[] x = createRealData(n);\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.inverseTransform(x);\n     }\n \n     public void testUnitaryInverseTransformFunctionSizeNotAPowerOfTwo() {\n         final int n = 127;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.inverseTransform(f, 0.0, Math.PI, n);\n     }\n \n     public void testUnitaryInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n         final int n = -128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.inverseTransform(f, 0.0, Math.PI, n);\n     }\n \n     public void testUnitaryInverseTransformFunctionInvalidBounds() {\n         final int n = 128;\n         final UnivariateFunction f = new Sin();\n-        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        final FastFourierTransformer fft;\n+        fft = new FastFourierTransformer(Normalization.UNITARY);\n         fft.transform(f, Math.PI, 0.0, n);\n     }\n \n         final boolean forward, final boolean standard) {\n         final FastFourierTransformer fft;\n         if (standard) {\n-            fft = FastFourierTransformer.create();\n+            fft = new FastFourierTransformer(Normalization.STANDARD);\n         } else {\n-            fft = FastFourierTransformer.createUnitary();\n+            fft = new FastFourierTransformer(Normalization.UNITARY);\n         }\n         final Complex[] x = createComplexData(n);\n         final Complex[] expected;\n         final boolean forward, final boolean standard) {\n         final FastFourierTransformer fft;\n         if (standard) {\n-            fft = FastFourierTransformer.create();\n+            fft = new FastFourierTransformer(Normalization.STANDARD);\n         } else {\n-            fft = FastFourierTransformer.createUnitary();\n+            fft = new FastFourierTransformer(Normalization.UNITARY);\n         }\n         final double[] x = createRealData(n);\n         final Complex[] xc = new Complex[n];\n         final boolean forward, final boolean standard) {\n         final FastFourierTransformer fft;\n         if (standard) {\n-            fft = FastFourierTransformer.create();\n+            fft = new FastFourierTransformer(Normalization.STANDARD);\n         } else {\n-            fft = FastFourierTransformer.createUnitary();\n+            fft = new FastFourierTransformer(Normalization.UNITARY);\n         }\n         final Complex[] x = new Complex[n];\n         for (int i = 0; i < n; i++) {\n      */\n     @Test\n     public void testAdHocData() {\n-        FastFourierTransformer transformer = FastFourierTransformer.create();\n+        FastFourierTransformer transformer;\n+        transformer = new FastFourierTransformer(Normalization.STANDARD);\n         Complex result[]; double tolerance = 1E-12;\n \n         double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7};\n         TransformUtils.scaleArray(x2, 1.0 / FastMath.sqrt(x2.length));\n         Complex y2[] = y;\n \n-        transformer = FastFourierTransformer.createUnitary();\n+        transformer = new FastFourierTransformer(Normalization.UNITARY);\n         result = transformer.transform(y2);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x2[i], result[i].getReal(), tolerance);\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        FastFourierTransformer transformer = FastFourierTransformer.create();\n+        FastFourierTransformer transformer;\n+        transformer = new FastFourierTransformer(Normalization.STANDARD);\n         Complex result[]; int N = 1 << 8;\n         double min, max, tolerance = 1E-12;\n \n \n     @Test\n     public void test2DData() {\n-        FastFourierTransformer transformer = FastFourierTransformer.create();\n+        FastFourierTransformer transformer;\n+        transformer = new FastFourierTransformer(Normalization.STANDARD);\n+\n         double tolerance = 1E-12;\n         Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),\n                                                             new Complex(2, 0)},\n \n     @Test\n     public void test2DDataUnitary() {\n-        FastFourierTransformer transformer = FastFourierTransformer.createUnitary();\n+        FastFourierTransformer transformer;\n+        transformer = new FastFourierTransformer(Normalization.UNITARY);\n         double tolerance = 1E-12;\n         Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0),\n                                                             new Complex(2, 0)},", "timestamp": 1328773043, "metainfo": ""}