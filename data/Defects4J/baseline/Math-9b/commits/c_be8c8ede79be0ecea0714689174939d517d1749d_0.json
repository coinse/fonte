{"sha": "be8c8ede79be0ecea0714689174939d517d1749d", "log": "Replaced temporary matrices / entry mutators with double[][] arrays to speed computation in loops.  JIRA: MATH-612.  Reported and patched by Christopher Nix.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n+++ b/src/main/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n             final int p = main.length;\n             final int diagOffset    = (m >= n) ? 0 : 1;\n             final double[] diagonal = (m >= n) ? main : secondary;\n-            cachedU = MatrixUtils.createRealMatrix(m, m);\n+            double[][] ua = new double[m][m];\n \n             // fill up the part of the matrix not affected by Householder transforms\n             for (int k = m - 1; k >= p; --k) {\n-                cachedU.setEntry(k, k, 1);\n+                ua[k][k] = 1;\n             }\n \n             // build up first part of the matrix by applying Householder transforms\n             for (int k = p - 1; k >= diagOffset; --k) {\n                 final double[] hK = householderVectors[k];\n-                cachedU.setEntry(k, k, 1);\n+                ua[k][k] = 1;\n                 if (hK[k - diagOffset] != 0.0) {\n                     for (int j = k; j < m; ++j) {\n                         double alpha = 0;\n                         for (int i = k; i < m; ++i) {\n-                            alpha -= cachedU.getEntry(i, j) * householderVectors[i][k - diagOffset];\n+                            alpha -= ua[i][j] * householderVectors[i][k - diagOffset];\n                         }\n                         alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];\n \n                         for (int i = k; i < m; ++i) {\n-                            cachedU.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);\n+                            ua[i][j] += -alpha * householderVectors[i][k - diagOffset];\n                         }\n                     }\n                 }\n             }\n             if (diagOffset > 0) {\n-                cachedU.setEntry(0, 0, 1);\n-            }\n-\n+                ua[0][0] = 1;\n+            }\n+            cachedU = MatrixUtils.createRealMatrix(ua);\n         }\n \n         // return the cached matrix\n \n             final int m = householderVectors.length;\n             final int n = householderVectors[0].length;\n-            cachedB = MatrixUtils.createRealMatrix(m, n);\n+            double[][] ba = new double[m][n];\n             for (int i = 0; i < main.length; ++i) {\n-                cachedB.setEntry(i, i, main[i]);\n+                ba[i][i] = main[i];\n                 if (m < n) {\n                     if (i > 0) {\n-                        cachedB.setEntry(i, i - 1, secondary[i - 1]);\n+                        ba[i][i-1] = secondary[i - 1];\n                     }\n                 } else {\n                     if (i < main.length - 1) {\n-                        cachedB.setEntry(i, i + 1, secondary[i]);\n-                    }\n-                }\n-            }\n-\n+                        ba[i][i+1] = secondary[i];\n+                    }\n+                }\n+            }\n+            cachedB = MatrixUtils.createRealMatrix(ba);\n         }\n \n         // return the cached matrix\n             final int p = main.length;\n             final int diagOffset    = (m >= n) ? 1 : 0;\n             final double[] diagonal = (m >= n) ? secondary : main;\n-            cachedV = MatrixUtils.createRealMatrix(n, n);\n+            double[][] va = new double[n][n];\n \n             // fill up the part of the matrix not affected by Householder transforms\n             for (int k = n - 1; k >= p; --k) {\n-                cachedV.setEntry(k, k, 1);\n+                va[k][k] = 1;\n             }\n \n             // build up first part of the matrix by applying Householder transforms\n             for (int k = p - 1; k >= diagOffset; --k) {\n                 final double[] hK = householderVectors[k - diagOffset];\n-                cachedV.setEntry(k, k, 1);\n+                va[k][k] = 1;\n                 if (hK[k] != 0.0) {\n                     for (int j = k; j < n; ++j) {\n                         double beta = 0;\n                         for (int i = k; i < n; ++i) {\n-                            beta -= cachedV.getEntry(i, j) * hK[i];\n+                            beta -= va[i][j] * hK[i];\n                         }\n                         beta /= diagonal[k - diagOffset] * hK[k];\n \n                         for (int i = k; i < n; ++i) {\n-                            cachedV.addToEntry(i, j, -beta * hK[i]);\n+                            va[i][j] += -beta * hK[i];\n                         }\n                     }\n                 }\n             }\n             if (diagOffset > 0) {\n-                cachedV.setEntry(0, 0, 1);\n-            }\n-\n+                va[0][0] = 1;\n+            }\n+            cachedV = MatrixUtils.createRealMatrix(va);\n         }\n \n         // return the cached matrix", "timestamp": 1318627320, "metainfo": ""}