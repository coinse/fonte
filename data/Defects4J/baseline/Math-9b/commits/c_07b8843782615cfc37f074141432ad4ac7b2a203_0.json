{"sha": "07b8843782615cfc37f074141432ad4ac7b2a203", "log": "MATH-798 Added overridden \"fit\" method where one can specify the maximum number of function evaluations.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java\n      *\n      * @param guess First guess for the coefficients. They must be sorted in\n      * increasing order of the polynomial's degree.\n+     * @param maxEval Maximum number of evaluations of the polynomial.\n+     * @return the coefficients of the polynomial that best fits the observed points.\n+     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n+     * the number of evaluations exceeds {@code maxEval}.\n+     * @throws org.apache.commons.math3.exception.ConvergenceException\n+     * if the algorithm failed to converge.\n+     */\n+    public double[] fit(int maxEval, double[] guess) {\n+        return fit(maxEval, new PolynomialFunction.Parametric(), guess);\n+    }\n+\n+    /**\n+     * Get the coefficients of the polynomial fitting the weighted data points.\n+     * The degree of the fitting polynomial is {@code guess.length - 1}.\n+     *\n+     * @param guess First guess for the coefficients. They must be sorted in\n+     * increasing order of the polynomial's degree.\n      * @return the coefficients of the polynomial that best fits the observed points.\n      * @throws org.apache.commons.math3.exception.ConvergenceException\n      * if the algorithm failed to converge.\n--- a/src/test/java/org/apache/commons/math3/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/CurveFitterTest.java\n \n     }\n \n-    @Test\n-    public void testMath798() {\n-        final double tol = 1e-14;\n-        final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol);\n-        final double[] init = new double[] { 0, 0 };\n-        final int maxEval = 3;\n-\n-        final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init);\n-        final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init);\n-\n-        for (int i = 0; i <= 1; i++) {\n-            Assert.assertEquals(lm[i], gn[i], tol);\n-        }\n-    }\n-\n-    /**\n-     * @param optimizer Optimizer.\n-     * @param maxEval Maximum number of function evaluations.\n-     * @param init First guess.\n-     * @return the solution found by the given optimizer.\n-     */\n-    private double[] doMath798(DifferentiableMultivariateVectorOptimizer optimizer,\n-                               int maxEval,\n-                               double[] init) {\n-        final CurveFitter fitter = new CurveFitter(optimizer);\n-\n-        fitter.addObservedPoint(-0.2, -7.12442E-13);\n-        fitter.addObservedPoint(-0.199, -4.33397E-13);\n-        fitter.addObservedPoint(-0.198, -2.823E-13);\n-        fitter.addObservedPoint(-0.197, -1.40405E-13);\n-        fitter.addObservedPoint(-0.196, -7.80821E-15);\n-        fitter.addObservedPoint(-0.195, 6.20484E-14);\n-        fitter.addObservedPoint(-0.194, 7.24673E-14);\n-        fitter.addObservedPoint(-0.193, 1.47152E-13);\n-        fitter.addObservedPoint(-0.192, 1.9629E-13);\n-        fitter.addObservedPoint(-0.191, 2.12038E-13);\n-        fitter.addObservedPoint(-0.19, 2.46906E-13);\n-        fitter.addObservedPoint(-0.189, 2.77495E-13);\n-        fitter.addObservedPoint(-0.188, 2.51281E-13);\n-        fitter.addObservedPoint(-0.187, 2.64001E-13);\n-        fitter.addObservedPoint(-0.186, 2.8882E-13);\n-        fitter.addObservedPoint(-0.185, 3.13604E-13);\n-        fitter.addObservedPoint(-0.184, 3.14248E-13);\n-        fitter.addObservedPoint(-0.183, 3.1172E-13);\n-        fitter.addObservedPoint(-0.182, 3.12912E-13);\n-        fitter.addObservedPoint(-0.181, 3.06761E-13);\n-        fitter.addObservedPoint(-0.18, 2.8559E-13);\n-        fitter.addObservedPoint(-0.179, 2.86806E-13);\n-        fitter.addObservedPoint(-0.178, 2.985E-13);\n-        fitter.addObservedPoint(-0.177, 2.67148E-13);\n-        fitter.addObservedPoint(-0.176, 2.94173E-13);\n-        fitter.addObservedPoint(-0.175, 3.27528E-13);\n-        fitter.addObservedPoint(-0.174, 3.33858E-13);\n-        fitter.addObservedPoint(-0.173, 2.97511E-13);\n-        fitter.addObservedPoint(-0.172, 2.8615E-13);\n-        fitter.addObservedPoint(-0.171, 2.84624E-13);\n-\n-        final double[] coeff = fitter.fit(maxEval,\n-                                          new PolynomialFunction.Parametric(),\n-                                          init);\n-        return coeff;\n-    }\n-\n     private static class SimpleInverseFunction implements ParametricUnivariateFunction {\n \n         public double value(double x, double ... parameters) {\n--- a/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n \n import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\n import org.apache.commons.math3.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer;\n     }\n \n     @Test\n+    public void testMath798() {\n+        final double tol = 1e-14;\n+        final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol);\n+        final double[] init = new double[] { 0, 0 };\n+        final int maxEval = 3;\n+\n+        final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init);\n+        final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init);\n+\n+        for (int i = 0; i <= 1; i++) {\n+            Assert.assertEquals(lm[i], gn[i], tol);\n+        }\n+    }\n+\n+    /**\n+     * This test shows that the user can set the maximum number of iterations\n+     * to avoid running for too long.\n+     * But in the test case, the real problem is that the tolerance is way too\n+     * stringent.\n+     */\n+    @Test(expected=TooManyEvaluationsException.class)\n+    public void testMath798WithToleranceTooLow() {\n+        final double tol = 1e-100;\n+        final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol);\n+        final double[] init = new double[] { 0, 0 };\n+        final int maxEval = 10000; // Trying hard to fit.\n+\n+        final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init);\n+        final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init);\n+\n+        for (int i = 0; i <= 1; i++) {\n+            Assert.assertEquals(lm[i], gn[i], tol);\n+        }\n+    }\n+\n+    /**\n+     * @param optimizer Optimizer.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @param init First guess.\n+     * @return the solution found by the given optimizer.\n+     */\n+    private double[] doMath798(DifferentiableMultivariateVectorOptimizer optimizer,\n+                               int maxEval,\n+                               double[] init) {\n+        final CurveFitter fitter = new CurveFitter(optimizer);\n+\n+        fitter.addObservedPoint(-0.2, -7.12442E-13);\n+        fitter.addObservedPoint(-0.199, -4.33397E-13);\n+        fitter.addObservedPoint(-0.198, -2.823E-13);\n+        fitter.addObservedPoint(-0.197, -1.40405E-13);\n+        fitter.addObservedPoint(-0.196, -7.80821E-15);\n+        fitter.addObservedPoint(-0.195, 6.20484E-14);\n+        fitter.addObservedPoint(-0.194, 7.24673E-14);\n+        fitter.addObservedPoint(-0.193, 1.47152E-13);\n+        fitter.addObservedPoint(-0.192, 1.9629E-13);\n+        fitter.addObservedPoint(-0.191, 2.12038E-13);\n+        fitter.addObservedPoint(-0.19, 2.46906E-13);\n+        fitter.addObservedPoint(-0.189, 2.77495E-13);\n+        fitter.addObservedPoint(-0.188, 2.51281E-13);\n+        fitter.addObservedPoint(-0.187, 2.64001E-13);\n+        fitter.addObservedPoint(-0.186, 2.8882E-13);\n+        fitter.addObservedPoint(-0.185, 3.13604E-13);\n+        fitter.addObservedPoint(-0.184, 3.14248E-13);\n+        fitter.addObservedPoint(-0.183, 3.1172E-13);\n+        fitter.addObservedPoint(-0.182, 3.12912E-13);\n+        fitter.addObservedPoint(-0.181, 3.06761E-13);\n+        fitter.addObservedPoint(-0.18, 2.8559E-13);\n+        fitter.addObservedPoint(-0.179, 2.86806E-13);\n+        fitter.addObservedPoint(-0.178, 2.985E-13);\n+        fitter.addObservedPoint(-0.177, 2.67148E-13);\n+        fitter.addObservedPoint(-0.176, 2.94173E-13);\n+        fitter.addObservedPoint(-0.175, 3.27528E-13);\n+        fitter.addObservedPoint(-0.174, 3.33858E-13);\n+        fitter.addObservedPoint(-0.173, 2.97511E-13);\n+        fitter.addObservedPoint(-0.172, 2.8615E-13);\n+        fitter.addObservedPoint(-0.171, 2.84624E-13);\n+\n+        final double[] coeff = fitter.fit(maxEval,\n+                                          new PolynomialFunction.Parametric(),\n+                                          init);\n+        return coeff;\n+    }\n+\n+    @Test\n     public void testRedundantSolvable() {\n         // Levenberg-Marquardt should handle redundant information gracefully\n         checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true);", "timestamp": 1341424802, "metainfo": ""}