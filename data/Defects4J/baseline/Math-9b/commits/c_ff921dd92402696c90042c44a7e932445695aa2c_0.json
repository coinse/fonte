{"sha": "ff921dd92402696c90042c44a7e932445695aa2c", "log": "MATH-514 Added a \"Parametric\" inner class.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/function/Gaussian.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Gaussian.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n \n     /** {@inheritDoc} */\n     public double value(double x) {\n-        final double diff = x - mean;\n-        return norm * FastMath.exp(-diff * diff * i2s2);\n+        return value(x - mean, norm, i2s2);\n     }\n \n     /** {@inheritDoc} */\n             /** {@inheritDoc} */\n             public double value(double x) {\n                 final double diff = x - mean;\n-                final double g = Gaussian.this.value(x);\n+                final double g = Gaussian.value(diff, norm, i2s2);\n \n                 if (g == 0) {\n                     // Avoid returning NaN in case of overflow.\n             }\n         };\n     }\n+\n+    /**\n+     * Parametric function where the input array contains the parameters of\n+     * the Gaussian, ordered as follows:\n+     * <ul>\n+     *  <li>Norm</li>\n+     *  <li>Mean</li>\n+     *  <li>Standard deviation</li>\n+     * </ul>\n+     */\n+    public static class Parametric implements ParametricUnivariateRealFunction {\n+        /**\n+         * Computes the value of the Gaussian at {@code x}.\n+         *\n+         * @param x Value for which the function must be computed.\n+         * @param param Values of norm, mean and standard deviation.\n+         * @return the value of the function.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 3.\n+         * @throws NotStrictlyPositiveException if {@code param[2]} is negative.\n+         */\n+        public double value(double x,\n+                            double[] param) {\n+            validateParameters(param);\n+\n+            final double diff = x - param[1];\n+            final double i2s2 = 1 / (2 * param[2] * param[2]);\n+            return Gaussian.value(diff, param[0], i2s2);\n+        }\n+\n+        /**\n+         * Computes the value of the gradient at {@code x}.\n+         * The components of the gradient vector are the partial\n+         * derivatives of the function with respect to each of the\n+         * <em>parameters</em> (norm, mean and standard deviation).\n+         *\n+         * @param x Value at which the gradient must be computed.\n+         * @param param Values of norm, mean and standard deviation.\n+         * @return the gradient vector at {@code x}.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 3.\n+         * @throws NotStrictlyPositiveException if {@code param[2]} is negative.\n+         */\n+        public double[] gradient(double x, double[] param) {\n+            validateParameters(param);\n+\n+            final double norm = param[0];\n+            final double diff = x - param[1];\n+            final double sigma = param[2];\n+            final double i2s2 = 1 / (2 * sigma * sigma);\n+\n+            final double n = Gaussian.value(diff, 1, i2s2);\n+            final double m = norm * n * 2 * i2s2 * diff;\n+            final double s = m * diff / sigma;\n+\n+            return new double[] { n, m, s };\n+        }\n+\n+        /**\n+         * Validates parameters to ensure they are appropriate for the evaluation of\n+         * the {@link #value(double,double[])} and {@link #gradient(double,double[])}\n+         * methods.\n+         *\n+         * @param param Values of norm, mean and standard deviation.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 3.\n+         * @throws NotStrictlyPositiveException if {@code param[2]} is negative.\n+         */\n+        private void validateParameters(double[] param) {\n+            if (param == null) {\n+                throw new NullArgumentException();\n+            }\n+            if (param.length != 3) {\n+                throw new DimensionMismatchException(param.length, 3);\n+            }\n+            if (param[2] <= 0) {\n+                throw new NotStrictlyPositiveException(param[2]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param xMinusMean {@code x - mean}.\n+     * @param norm Normalization factor.\n+     * @param i2s2 Inverse of twice the square of the standard deviation.\n+     * @return the value of the Gaussian at {@code x}.\n+     */\n+    private static double value(double xMinusMean,\n+                                double norm,\n+                                double i2s2) {\n+        return norm * FastMath.exp(-xMinusMean * xMinusMean * i2s2);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/function/GaussianTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/function/GaussianTest.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n \n import org.junit.Assert;\n \n         Assert.assertTrue(Double.isNaN(dfdx.value(Double.NaN)));\n     }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage1() {\n+        final Gaussian.Parametric g = new Gaussian.Parametric();\n+        g.value(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage2() {\n+        final Gaussian.Parametric g = new Gaussian.Parametric();\n+        g.value(0, new double[] {0});\n+    }\n+\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testParametricUsage3() {\n+        final Gaussian.Parametric g = new Gaussian.Parametric();\n+        g.value(0, new double[] {0, 1, 0});\n+    }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage4() {\n+        final Gaussian.Parametric g = new Gaussian.Parametric();\n+        g.gradient(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage5() {\n+        final Gaussian.Parametric g = new Gaussian.Parametric();\n+        g.gradient(0, new double[] {0});\n+    }\n+\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testParametricUsage6() {\n+        final Gaussian.Parametric g = new Gaussian.Parametric();\n+        g.gradient(0, new double[] {0, 1, 0});\n+    }\n+\n+    @Test\n+    public void testParametricValue() {\n+        final double norm = 2;\n+        final double mean = 3;\n+        final double sigma = 4;\n+        final Gaussian f = new Gaussian(norm, mean, sigma);\n+\n+        final Gaussian.Parametric g = new Gaussian.Parametric();\n+        Assert.assertEquals(f.value(-1), g.value(-1, new double[] {norm, mean, sigma}), 0);\n+        Assert.assertEquals(f.value(0), g.value(0, new double[] {norm, mean, sigma}), 0);\n+        Assert.assertEquals(f.value(2), g.value(2, new double[] {norm, mean, sigma}), 0);\n+    }\n+\n+    @Test\n+    public void testParametricGradient() {\n+        final double norm = 2;\n+        final double mean = 3;\n+        final double sigma = 4;\n+        final Gaussian.Parametric f = new Gaussian.Parametric();\n+\n+        final double x = 1;\n+        final double[] grad = f.gradient(1, new double[] {norm, mean, sigma});\n+        final double diff = x - mean;\n+        final double n = FastMath.exp(-diff * diff / (2 * sigma * sigma));\n+        Assert.assertEquals(n, grad[0], EPS);\n+        final double m = norm * n * diff / (sigma * sigma);\n+        Assert.assertEquals(m, grad[1], EPS);\n+        final double s = m * diff / sigma;\n+        Assert.assertEquals(s, grad[2], EPS);\n+    }\n }", "timestamp": 1297896523, "metainfo": ""}