{"sha": "893f858e5c48d471b145439e719496596650473f", "log": "Finalized fix for MATH-880.  This version should be much more robust on polygons computation than the earlier ones. Note that the hyperplaneThickness parameter is a key tuning parameter in difficult cases like the one involved in the issue. As shown in the corresponding unit test, the value had to be raised to 1.0e-8 in order for the test to pass correctly.  JIRA: MATH-880  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n      * constructor} using {@link SubHyperplane subhyperplanes}.</p>\n      * <p>If the list is empty, the region will represent the whole\n      * space.</p>\n+     * <p>\n+     * Polygons with thin pikes or dents are inherently difficult to handle because\n+     * they involve lines with almost opposite directions at some vertices. Polygons\n+     * whose vertices come from some physical measurement with noise are also\n+     * difficult because an edge that should be straight may be broken in lots of\n+     * different pieces with almost equal directions. In both cases, computing the\n+     * lines intersections is not numerically robust due to the almost 0 or almost\n+     * &pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}\n+     * parameter. A too small value would often lead to completely wrong polygons\n+     * with large area wrongly identified as inside or outside. Large values are\n+     * often much safer. As a rule of thumb, a value slightly below the size of the\n+     * most accurate detail needed is a good value for the {@code hyperplaneThickness}\n+     * parameter.\n+     * </p>\n      * @param hyperplaneThickness tolerance below which points are considered to\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param vertices vertices of the simple loop boundary\n     private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness,\n                                                        final Vector2D ... vertices) {\n \n-        if (vertices.length == 0) {\n+        final int n = vertices.length;\n+        if (n == 0) {\n             // the tree represents the whole space\n             return new BSPTree<Euclidean2D>(Boolean.TRUE);\n         }\n \n-        // at start, none of the edges have been processed\n+        // build the vertices\n+        final Vertex[] vArray = new Vertex[n];\n+        for (int i = 0; i < n; ++i) {\n+            vArray[i] = new Vertex(vertices[i]);\n+        }\n+\n+        // build the edges\n+        List<Edge> edges = new ArrayList<Edge>();\n+        for (int i = 0; i < n; ++i) {\n+\n+            // get the endpoints of the edge\n+            final Vertex start = vArray[i];\n+            final Vertex end   = vArray[(i + 1) % n];\n+\n+            // get the line supporting the edge, taking care not to recreate it\n+            // if it was already created earlier due to another edge being aligned\n+            // with the current one\n+            Line line = start.sharedLineWith(end);\n+            if (line == null) {\n+                line = new Line(start.getLocation(), end.getLocation());\n+            }\n+\n+            // create the edge and store it\n+            edges.add(new Edge(start, end, line));\n+\n+            // check if another vertex also happens to be on this line\n+            for (final Vertex vertex : vArray) {\n+                if (vertex != start && vertex != end &&\n+                    FastMath.abs(line.getOffset(vertex.getLocation())) <= hyperplaneThickness) {\n+                    vertex.bindWith(line);\n+                }\n+            }\n+\n+        }\n+\n+        // build the tree top-down\n         final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n-        List<Vertex> list = new ArrayList<PolygonsSet.Vertex>(vertices.length);\n-        for (final Vector2D vertex : vertices) {\n-            list.add(new Vertex(vertex));\n-        }\n-\n-        // build the tree top-down\n-        insertVertices(hyperplaneThickness, tree, list);\n+        insertEdges(hyperplaneThickness, tree, edges);\n \n         return tree;\n \n      * belong to the hyperplane (which is therefore more a slab)\n      * @param node current tree node (it is a leaf node at the beginning\n      * of the call)\n-     * @param vertices list of vertices belonging to the boundary of the\n-     * cell defined by the node\n-     */\n-    private static void insertVertices(final double hyperplaneThickness,\n-                                       final BSPTree<Euclidean2D> node,\n-                                       final List<Vertex> vertices) {\n-\n-        Vertex current = vertices.get(vertices.size() - 1);\n+     * @param edges list of edges to insert in the cell defined by this node\n+     * (excluding edges not belonging to the cell defined by this node)\n+     */\n+    private static void insertEdges(final double hyperplaneThickness,\n+                                    final BSPTree<Euclidean2D> node,\n+                                    final List<Edge> edges) {\n+\n+        // find an edge with an hyperplane that can be inserted in the node\n         int index = 0;\n-        Line inserted = null;\n-        while (inserted == null && index < vertices.size()) {\n-            final Vertex previous = current;\n-            current = vertices.get(index++);\n-            if (previous.outgoingNeedsProcessing() && current.incomingNeedsProcessing()) {\n-\n-                if (previous.shareNodeWith(current)) {\n-                    // both vertices are already handled by an existing node,\n-                    // closer to the tree root, they were probably created\n-                    // when split points were introduced\n+        Edge inserted =null;\n+        while (inserted == null && index < edges.size()) {\n+            inserted = edges.get(index++);\n+            if (inserted.getNode() == null) {\n+                if (node.insertCut(inserted.getLine())) {\n+                    inserted.setNode(node);\n+                } else {\n                     inserted = null;\n-                } else {\n-\n-                    inserted = new Line(previous.getLocation(), current.getLocation());\n-\n-                    if (node.insertCut(inserted)) {\n-                        previous.addNode(node);\n-                        previous.outgoingProcessed();\n-                        current.addNode(node);\n-                        current.incomingProcessed();\n-                    } else {\n-                        inserted = null;\n-                    }\n-\n                 }\n-\n-            }\n-        }\n-\n-        if (node.getCut() == null) {\n+            } else {\n+                inserted = null;\n+            }\n+        }\n+\n+        if (inserted == null) {\n+            // no suitable edge was found, the node remains a leaf node\n+            // we need to set its inside/outside boolean indicator\n             final BSPTree<Euclidean2D> parent = node.getParent();\n             if (parent == null || node == parent.getMinus()) {\n                 node.setAttribute(Boolean.TRUE);\n             return;\n         }\n \n-        // distribute the remaining vertices in the two sub-trees\n-        Side currentSide = Side.HYPER;\n-        final List<Vertex> plusList  = new ArrayList<Vertex>();\n-        plusList.add(current);\n-        int plusCount = 0;\n-        final List<Vertex> minusList = new ArrayList<Vertex>();\n-        minusList.add(current);\n-        int minusCount = 0;\n-        while (index < vertices.size()) {\n-            final Vertex previous = current;\n-            final Side previousSide = currentSide;\n-            current = vertices.get(index++);\n-            final double currentOffset = inserted.getOffset(current.getLocation());\n-            currentSide = (FastMath.abs(currentOffset) <= hyperplaneThickness) ?\n-                           Side.HYPER :\n-                           ((currentOffset < 0) ? Side.MINUS : Side.PLUS);\n-            switch (currentSide) {\n-            case PLUS:\n-                if (previousSide == Side.MINUS) {\n-                    // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n+        // we have split the node by inserted an edge as a cut sub-hyperplane\n+        // distribute the remaining edges in the two sub-trees\n+        final List<Edge> plusList  = new ArrayList<Edge>();\n+        final List<Edge> minusList = new ArrayList<Edge>();\n+        for (final Edge edge : edges) {\n+            if (edge != inserted) {\n+                final double startOffset = inserted.getLine().getOffset(edge.getStart().getLocation());\n+                final double endOffset   = inserted.getLine().getOffset(edge.getEnd().getLocation());\n+                Side startSide = (FastMath.abs(startOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((startOffset < 0) ? Side.MINUS : Side.PLUS);\n+                Side endSide   = (FastMath.abs(endOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((endOffset < 0) ? Side.MINUS : Side.PLUS);\n+                switch (startSide) {\n+                    case PLUS:\n+                        if (endSide == Side.MINUS) {\n+                            // we need to insert a split point on the hyperplane\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getOutgoing());\n+                            plusList.add(splitPoint.getIncoming());\n+                        } else {\n+                            plusList.add(edge);\n+                        }\n+                        break;\n+                    case MINUS:\n+                        if (endSide == Side.PLUS) {\n+                            // we need to insert a split point on the hyperplane\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getIncoming());\n+                            plusList.add(splitPoint.getOutgoing());\n+                        } else {\n+                            minusList.add(edge);\n+                        }\n+                        break;\n+                    default:\n+                        if (endSide == Side.PLUS) {\n+                            plusList.add(edge);\n+                        } else if (endSide == Side.MINUS) {\n+                            minusList.add(edge);\n+                        }\n+                        break;\n                 }\n-                plusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++plusCount;\n-                }\n-                break;\n-            case MINUS:\n-                if (previousSide == Side.PLUS) {\n-                    // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n-                }\n-                minusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++minusCount;\n-                }\n-                break;\n-            default:\n-                current.addNode(node);\n-                plusList.add(current);\n-                minusList.add(current);\n-                break;\n             }\n         }\n \n         // recurse through lower levels\n-        if (plusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getPlus(),  plusList);\n+        if (!plusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getPlus(),  plusList);\n         } else {\n             node.getPlus().setAttribute(Boolean.FALSE);\n         }\n-        if (minusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getMinus(), minusList);\n+        if (!minusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getMinus(), minusList);\n         } else {\n             node.getMinus().setAttribute(Boolean.TRUE);\n         }\n         /** Vertex location. */\n         private final Vector2D location;\n \n-        /** Nodes associated with the hyperplane containing this vertex. */\n-        private final List<BSPTree<Euclidean2D>> nodes;\n-\n-        /** Indicator for incoming edges that still need processing. */\n-        private boolean incomingNeedsProcessing;\n-\n-        /** Indicator for outgoing edges that still need processing. */\n-        private boolean outgoingNeedsProcessing;\n+        /** Incoming edge. */\n+        private Edge incoming;\n+\n+        /** Outgoing edge. */\n+        private Edge outgoing;\n+\n+        /** Lines bound with this vertex. */\n+        private final List<Line> lines;\n \n         /** Build a non-processed vertex not owned by any node yet.\n          * @param location vertex location\n          */\n         public Vertex(final Vector2D location) {\n-            this.location                = location;\n-            this.nodes                   = new ArrayList<BSPTree<Euclidean2D>>();\n-            this.incomingNeedsProcessing = true;\n-            this.outgoingNeedsProcessing = true;\n+            this.location = location;\n+            this.incoming = null;\n+            this.outgoing = null;\n+            this.lines    = new ArrayList<Line>();\n         }\n \n         /** Get Vertex location.\n             return location;\n         }\n \n-        /** Check if the instance and another vertex share a node.\n+        /** Bind a line considered to contain this vertex.\n+         * @param line line to bind with this vertex\n+         */\n+        public void bindWith(final Line line) {\n+            lines.add(line);\n+        }\n+\n+        /** Get the common line bound with both the instance and another vertex, if any.\n          * <p>\n-         * When two vertices share a node, this means they are already handled\n-         * by the hyperplane of this node, so there is no need to create a cut\n-         * hyperplane for them.\n+         * When two vertices are both bound to the same line, this means they are\n+         * already handled by node associated with this line, so there is no need\n+         * to create a cut hyperplane for them.\n          * </p>\n          * @param vertex other vertex to check instance against\n-         * @return true if the instance and another vertex share a node\n-         */\n-        public boolean shareNodeWith(final Vertex vertex) {\n-            for (final BSPTree<Euclidean2D> node1 : nodes) {\n-                for (final BSPTree<Euclidean2D> node2 : vertex.nodes) {\n-                    if (node1 == node2) {\n-                        return true;\n+         * @return line bound with both the instance and another vertex, or null if the\n+         * two vertices do not share a line yet\n+         */\n+        public Line sharedLineWith(final Vertex vertex) {\n+            for (final Line line1 : lines) {\n+                for (final Line line2 : vertex.lines) {\n+                    if (line1 == line2) {\n+                        return line1;\n                     }\n                 }\n             }\n-            return false;\n-        }\n-\n-        /** Add a node whose hyperplane contains this vertex.\n-         * @param node node whose hyperplane contains this vertex\n-         */\n-        public void addNode(final BSPTree<Euclidean2D> node) {\n-            nodes.add(node);\n-        }\n-\n-        /** Check incoming edge processed indicator.\n-         * @return true if incoming edge needs processing\n-         */\n-        public boolean incomingNeedsProcessing() {\n-            return incomingNeedsProcessing;\n-        }\n-\n-        /** Check outgoing edge processed indicator.\n-         * @return true if outgoing edge needs processing\n-         */\n-        public boolean outgoingNeedsProcessing() {\n-            return outgoingNeedsProcessing;\n-        }\n-\n-        /** Mark the incoming edge as processed.\n-         */\n-        public void incomingProcessed() {\n-            incomingNeedsProcessing = false;\n-        }\n-\n-        /** Mark the outgoing edge as processed.\n-         */\n-        public void outgoingProcessed() {\n-            outgoingNeedsProcessing = false;\n+            return null;\n+        }\n+\n+        /** Set incoming edge.\n+         * <p>\n+         * The line supporting the incoming edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming incoming edge\n+         */\n+        public void setIncoming(final Edge incoming) {\n+            this.incoming = incoming;\n+            bindWith(incoming.getLine());\n+        }\n+\n+        /** Get incoming edge.\n+         * @return incoming edge\n+         */\n+        public Edge getIncoming() {\n+            return incoming;\n+        }\n+\n+        /** Set outgoing edge.\n+         * <p>\n+         * The line supporting the outgoing edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming outgoing edge\n+         */\n+        public void setOutgoing(final Edge outgoing) {\n+            this.outgoing = outgoing;\n+            bindWith(outgoing.getLine());\n+        }\n+\n+        /** Get outgoing edge.\n+         * @return outgoing edge\n+         */\n+        public Edge getOutgoing() {\n+            return outgoing;\n+        }\n+\n+    }\n+\n+    /** Internal class for holding edges while they are processed to build a BSP tree. */\n+    private static class Edge {\n+\n+        /** Start vertex. */\n+        private final Vertex start;\n+\n+        /** End vertex. */\n+        private final Vertex end;\n+\n+        /** Line supporting the edge. */\n+        private final Line line;\n+\n+        /** Node whose cut hyperplane contains this edge. */\n+        private BSPTree<Euclidean2D> node;\n+\n+        /** Build an edge not contained in any node yet.\n+         * @param start start vertex\n+         * @param end end vertex\n+         * @param line line supporting the edge\n+         */\n+        public Edge(final Vertex start, final Vertex end, final Line line) {\n+\n+            this.start = start;\n+            this.end   = end;\n+            this.line  = line;\n+            this.node  = null;\n+\n+            // connect the vertices back to the edge\n+            start.setOutgoing(this);\n+            end.setIncoming(this);\n+\n+        }\n+\n+        /** Get start vertex.\n+         * @return start vertex\n+         */\n+        public Vertex getStart() {\n+            return start;\n+        }\n+\n+        /** Get end vertex.\n+         * @return end vertex\n+         */\n+        public Vertex getEnd() {\n+            return end;\n+        }\n+\n+        /** Get the line supporting this edge.\n+         * @return line supporting this edge\n+         */\n+        public Line getLine() {\n+            return line;\n+        }\n+\n+        /** Set the node whose cut hyperplane contains this edge.\n+         * @param node node whose cut hyperplane contains this edge\n+         */\n+        public void setNode(final BSPTree<Euclidean2D> node) {\n+            this.node = node;\n+        }\n+\n+        /** Get the node whose cut hyperplane contains this edge.\n+         * @return node whose cut hyperplane contains this edge\n+         * (null if edge has not yet been inserted into the BSP tree)\n+         */\n+        public BSPTree<Euclidean2D> getNode() {\n+            return node;\n+        }\n+\n+        /** Split the edge.\n+         * <p>\n+         * Once split, this edge is not referenced anymore by the vertices,\n+         * it is replaced by the two half-edges and an intermediate splitting\n+         * vertex is introduced to connect these two halves.\n+         * </p>\n+         * @param splitLine line splitting the edge in two halves\n+         * @return split vertex (its incoming and outgoing edges are the two halves)\n+         */\n+        public Vertex split(final Line splitLine) {\n+            final Vertex splitVertex = new Vertex(line.intersection(splitLine));\n+            splitVertex.bindWith(splitLine);\n+            final Edge startHalf = new Edge(start, splitVertex, line);\n+            final Edge endHalf   = new Edge(splitVertex, end, line);\n+            startHalf.node = node;\n+            endHalf.node   = node;\n+            return splitVertex;\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSetTest.java\n+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSetTest.java\n  */\n package org.apache.commons.math3.geometry.euclidean.twod;\n \n-import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n \n     }\n \n     @Test\n+    public void testSqueezedHexa() {\n+        PolygonsSet set = new PolygonsSet(1.0e-10,\n+                                          new Vector2D(-6, -4), new Vector2D(-8, -8), new Vector2D(  8, -8),\n+                                          new Vector2D( 6, -4), new Vector2D(10,  4), new Vector2D(-10,  4));\n+        Assert.assertEquals(Location.OUTSIDE, set.checkPoint(new Vector2D(0, 6)));\n+    }\n+\n+    @Test\n     public void testIssue880Simplified() {\n \n         Vector2D[] vertices1 = new Vector2D[] {\n     }\n \n     @Test\n-    public void testIssue880Complete() throws FileNotFoundException {\n+    public void testIssue880Complete() throws IOException {\n         Vector2D[] vertices1 = new Vector2D[] {\n                 new Vector2D( 90.08714908223715,  38.370299337260235),\n                 new Vector2D( 90.08709517675004,  38.3702895991413),\n                 new Vector2D( 90.09081227075944,  38.37526295920463),\n                 new Vector2D( 90.09081378927135,  38.375193883266434)\n         };\n-        PolygonsSet set1 = new PolygonsSet(1.0e-10, vertices1);\n-        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0905, 38.3755)));\n+        PolygonsSet set1 = new PolygonsSet(1.0e-8, vertices1);\n+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0905,  38.3755)));\n         Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Vector2D(90.09084, 38.3755)));\n-        // TODO: the following assertion fails and should not\n-        // this is due to a small spurious triangle being included in the polygon\n-        // Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0913, 38.3755)));\n+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0913,  38.3755)));\n+        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Vector2D(90.1042,  38.3739)));\n+        Assert.assertEquals(Location.INSIDE,  set1.checkPoint(new Vector2D(90.1111,  38.3673)));\n+        Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0959,  38.3457)));\n \n         Vector2D[] vertices2 = new Vector2D[] {\n                 new Vector2D( 90.13067558880044,  38.36977255037573),\n                 new Vector2D( 90.16746107640665,  38.40902614307544),\n                 new Vector2D( 90.16122795307462,  38.39773101873203)\n         };\n-        PolygonsSet set2 = new PolygonsSet(1.0e-10, vertices2);\n+        PolygonsSet set2 = new PolygonsSet(1.0e-8, vertices2);\n         PolygonsSet set  = (PolygonsSet) new\n                 RegionFactory<Euclidean2D>().difference(set1.copySelf(),\n                                                         set2.copySelf());\n \n-        Vector2D[][] vertices = set.getVertices();\n-        Assert.assertTrue(vertices[0][0] != null);\n-        // TODO: the resulting polygon has two boundaries but should have only one\n-        // this is because for an unknown reason the boundary has two infinitely close\n-        // parallel paths near the top left of the polygon\n-        Assert.assertEquals(2, vertices.length);\n+        Vector2D[][] verticies = set.getVertices();\n+        Assert.assertTrue(verticies[0][0] != null);\n+        Assert.assertEquals(1, verticies.length);\n     }\n \n     private PolygonsSet buildSet(Vector2D[][] vertices) {", "timestamp": 1350933696, "metainfo": ""}