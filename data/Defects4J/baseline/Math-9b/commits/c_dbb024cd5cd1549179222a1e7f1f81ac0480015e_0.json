{"sha": "dbb024cd5cd1549179222a1e7f1f81ac0480015e", "log": "Renamed RealSolverTest to BrentSolverTest.   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Testcase for UnivariateRealSolver.\n+ * Because Brent-Dekker is guaranteed to converge in less than the default\n+ * maximum iteration count due to bisection fallback, it is quite hard to\n+ * debug. I include measured iteration counts plus one in order to detect\n+ * regressions. On average Brent-Dekker should use 4..5 iterations for the\n+ * default absolute accuracy of 10E-8 for sinus and the quintic function around\n+ * zero, and 5..10 iterations for the other zeros.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/07/17 19:49:02 $ \n+ */\n+public final class BrentSolverTest extends TestCase {\n+\n+    public BrentSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BrentSolverTest.class);\n+        suite.setName(\"UnivariateRealSolver Tests\");\n+        return suite;\n+    }\n+\n+    public void testSinZero() throws MathException {\n+        // The sinus function is behaved well around the root at #pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically. \n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        // Somewhat benign interval. The function is monotone.\n+        result = solver.solve(3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        // Larger and somewhat less benign interval. The function is grows first.\n+        result = solver.solve(1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        solver = new SecantSolver(f);\n+        result = solver.solve(3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        result = solver.solve(1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        assertEquals(result, solver.getResult(), 0);\n+    }\n+\n+    public void testQuinticZero() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second derivative\n+        // of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1, because\n+        // the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        // intervals containing these values are harder for the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        // Brent-Dekker solver.\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        // Symmetric bracket around 0. Test whether solvers can handle hitting\n+        // the root in the first iteration.\n+        result = solver.solve(-0.2, 0.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertTrue(solver.getIterationCount() <= 2);\n+        // 1 iterations on i586 JDK 1.4.1.\n+        // Asymmetric bracket around 0, just for fun. Contains extremum.\n+        result = solver.solve(-0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        // Large bracket around 0. Contains two extrema.\n+        result = solver.solve(-0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Benign bracket around 0.5, function is monotonous.\n+        result = solver.solve(0.3, 0.7);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Less benign bracket around 0.5, contains one extremum.\n+        result = solver.solve(0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Large, less benign bracket around 0.5, contains both extrema.\n+        result = solver.solve(0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1\n+        // is still a problem.\n+        result = solver.solve(0.85, 1.25);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Less benign bracket around 1 with extremum.\n+        result = solver.solve(0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Large bracket around 1. Monotonous.\n+        result = solver.solve(0.85, 1.75);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        // Large bracket around 1. Interval contains extremum.\n+        result = solver.solve(0.55, 1.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        // Very large bracket around 1 for testing fast growth behaviour.\n+        result = solver.solve(0.85, 5);\n+        //System.out.println(\n+       //     \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 12 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 13);\n+        // Secant solver.\n+        solver = new SecantSolver(f);\n+        result = solver.solve(-0.2, 0.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 1 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 2);\n+        result = solver.solve(-0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        result = solver.solve(-0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(0.3, 0.7);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(0.85, 1.25);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        result = solver.solve(0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(0.85, 1.75);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // The followig is especially slow because the solver first has to reduce\n+        // the bracket to exclude the extremum. After that, convergence is rapide.\n+        result = solver.solve(0.55, 1.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(0.85, 5);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // Static solve method\n+        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, 1E-8);\n+        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, 1E-6);\n+    }\n+}", "timestamp": 1090093742, "metainfo": ""}