{"sha": "0b144c231967ee5f992930d5b47d2a00f16e129f", "log": "Widened the scope of tests for transform.FastFourierTransformer (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.NonMonotonicSequenceException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public Complex[] transform(double[] f)\n-            throws MathIllegalArgumentException {\n-\n+    public Complex[] transform(double[] f) {\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(f.length);\n             return TransformUtils.scaleArray(fft(f, false), s);\n      * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex transformed array\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points\n-     * {@code n} is negative\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n+     * if the lower bound is greater than, or equal to the upper bound\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the number of sample points {@code n} is negative\n      * @throws MathIllegalArgumentException if the number of sample points\n      * {@code n} is not a power of two\n      */\n     public Complex[] transform(UnivariateFunction f,\n-            double min, double max, int n) throws\n-            NonMonotonicSequenceException,\n-            NotStrictlyPositiveException,\n-            MathIllegalArgumentException {\n+            double min, double max, int n) {\n \n         final double[] data = FunctionUtils.sample(f, min, max, n);\n         if (unitary) {\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public Complex[] transform(Complex[] f)\n-            throws MathIllegalArgumentException {\n-\n+    public Complex[] transform(Complex[] f) {\n         // TODO Is this necessary?\n         roots.computeOmega(f.length);\n         if (unitary) {\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public Complex[] inverseTransform(double[] f)\n-            throws MathIllegalArgumentException {\n-\n+    public Complex[] inverseTransform(double[] f) {\n         final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n         return TransformUtils.scaleArray(fft(f, true), s);\n     }\n      * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex inversely transformed array\n-     * @throws NonMonotonicSequenceException if the lower bound is greater\n-     * than, or equal to the upper bound\n-     * @throws NotStrictlyPositiveException if the number of sample points\n-     * {@code n} is negative\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n+     * if the lower bound is greater than, or equal to the upper bound\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the number of sample points {@code n} is negative\n      * @throws MathIllegalArgumentException if the number of sample points\n      * {@code n} is not a power of two\n      */\n     public Complex[] inverseTransform(UnivariateFunction f,\n-            double min, double max, int n) throws\n-            NonMonotonicSequenceException,\n-            NotStrictlyPositiveException,\n-            MathIllegalArgumentException {\n-\n+            double min, double max, int n) {\n         final double[] data = FunctionUtils.sample(f, min, max, n);\n         final double s = 1.0 / (unitary ? FastMath.sqrt(n) : n);\n         return TransformUtils.scaleArray(fft(data, true), s);\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    public Complex[] inverseTransform(Complex[] f)\n-            throws MathIllegalArgumentException {\n-\n+    public Complex[] inverseTransform(Complex[] f) {\n         roots.computeOmega(-f.length);    // pass negative argument\n         final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n         return TransformUtils.scaleArray(fft(f), s);\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    protected Complex[] fft(double[] f, boolean isInverse)\n-            throws MathIllegalArgumentException {\n+    protected Complex[] fft(double[] f, boolean isInverse) {\n \n         if (!ArithmeticUtils.isPowerOfTwo(f.length)) {\n             throw new MathIllegalArgumentException(\n      * @throws MathIllegalArgumentException if the length of the data array is\n      * not a power of two\n      */\n-    protected Complex[] fft(Complex[] data)\n-            throws MathIllegalArgumentException {\n+    protected Complex[] fft(Complex[] data) {\n \n         if (!ArithmeticUtils.isPowerOfTwo(data.length)) {\n             throw new MathIllegalArgumentException(\n      * id est {@code Complex[][][][]}\n      * @throws IllegalArgumentException if any dimension is not a power of two\n      */\n-    public Object mdfft(Object mdca, boolean forward)\n-        throws IllegalArgumentException {\n-\n+    public Object mdfft(Object mdca, boolean forward) {\n         MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix)\n                 new MultiDimensionalComplexMatrix(mdca).clone();\n         int[] dimensionSize = mdcm.getDimensionSizes();\n      * @throws IllegalArgumentException if any dimension is not a power of two\n      */\n     private void mdfft(MultiDimensionalComplexMatrix mdcm,\n-            boolean forward, int d, int[] subVector) throws\n-            IllegalArgumentException {\n+            boolean forward, int d, int[] subVector) {\n \n         int[] dimensionSize = mdcm.getDimensionSizes();\n         //if done\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n \n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.function.Sin;\n import org.apache.commons.math.analysis.function.Sinc;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n  * @version $Id$\n  */\n public final class FastFourierTransformerTest {\n-    /**\n-     * The common (for repeatability) seed of all random number generators used\n-     * in this test.\n-     */\n+    /** The common seed of all random number generators used in this test. */\n     private final static long SEED = 20110111L;\n+\n+    /*\n+     * Precondition checks for standard transform.\n+     */\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testStandardTransformComplexSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final Complex[] x = createComplexData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.transform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testStandardTransformRealSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final double[] x = createRealData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.transform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testStandardTransformFunctionSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.transform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testStandardTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final int n = -128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.transform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NumberIsTooLargeException.class)\n+    public void testStandardTransformFunctionInvalidBounds() {\n+        final int n = 128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.transform(f, Math.PI, 0.0, n);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testStandardInverseTransformComplexSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final Complex[] x = createComplexData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.inverseTransform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testStandardInverseTransformRealSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final double[] x = createRealData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.inverseTransform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testStandardInverseTransformFunctionSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.inverseTransform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testStandardInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final int n = -128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.inverseTransform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NumberIsTooLargeException.class)\n+    public void testStandardInverseTransformFunctionInvalidBounds() {\n+        final int n = 128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.create();\n+        fft.transform(f, Math.PI, 0.0, n);\n+    }\n+\n+    /*\n+     * Precondition checks for unitary transform.\n+     */\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testUnitaryTransformComplexSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final Complex[] x = createComplexData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.transform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testUnitaryTransformRealSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final double[] x = createRealData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.transform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testUnitaryTransformFunctionSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.transform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testUnitaryTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final int n = -128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.transform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NumberIsTooLargeException.class)\n+    public void testUnitaryTransformFunctionInvalidBounds() {\n+        final int n = 128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.transform(f, Math.PI, 0.0, n);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testUnitaryInverseTransformComplexSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final Complex[] x = createComplexData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.inverseTransform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testUnitaryInverseTransformRealSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final double[] x = createRealData(n);\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.inverseTransform(x);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testUnitaryInverseTransformFunctionSizeNotAPowerOfTwo() {\n+        final int n = 127;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.inverseTransform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testUnitaryInverseTransformFunctionNotStrictlyPositiveNumberOfSamples() {\n+        final int n = -128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.inverseTransform(f, 0.0, Math.PI, n);\n+    }\n+\n+    @Test(expected = NumberIsTooLargeException.class)\n+    public void testUnitaryInverseTransformFunctionInvalidBounds() {\n+        final int n = 128;\n+        final UnivariateFunction f = new Sin();\n+        final FastFourierTransformer fft = FastFourierTransformer.createUnitary();\n+        fft.transform(f, Math.PI, 0.0, n);\n+    }\n+\n+    /*\n+     * Utility methods for checking (successful) transforms.\n+     */\n+\n+    private static Complex[] createComplexData(final int n) {\n+        final Random random = new Random(SEED);\n+        final Complex[] data = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            final double re = 2.0 * random.nextDouble() - 1.0;\n+            final double im = 2.0 * random.nextDouble() - 1.0;\n+            data[i] = new Complex(re, im);\n+        }\n+        return data;\n+    }\n+\n+    private static double[] createRealData(final int n) {\n+        final Random random = new Random(SEED);\n+        final double[] data = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            data[i] = 2.0 * random.nextDouble() - 1.0;\n+        }\n+        return data;\n+    }\n+\n+    /** Naive implementation of DFT, for reference. */\n+    private static Complex[] dft(final Complex[] x, final int sgn) {\n+        final int n = x.length;\n+        final double[] cos = new double[n];\n+        final double[] sin = new double[n];\n+        final Complex[] y = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            final double arg = 2.0 * FastMath.PI * i / n;\n+            cos[i] = FastMath.cos(arg);\n+            sin[i] = FastMath.sin(arg);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            double yr = 0.0;\n+            double yi = 0.0;\n+            for (int j = 0; j < n; j++) {\n+                final int index = (i * j) % n;\n+                final double c = cos[index];\n+                final double s = sin[index];\n+                final double xr = x[j].getReal();\n+                final double xi = x[j].getImaginary();\n+                yr += c * xr - sgn * s * xi;\n+                yi += sgn * s * xr + c * xi;\n+            }\n+            y[i] = new Complex(yr, yi);\n+        }\n+        return y;\n+    }\n+\n+    private static void doTestTransformComplex(final int n, final double tol,\n+        final boolean forward, final boolean standard) {\n+        final FastFourierTransformer fft;\n+        if (standard) {\n+            fft = FastFourierTransformer.create();\n+        } else {\n+            fft = FastFourierTransformer.createUnitary();\n+        }\n+        final Complex[] x = createComplexData(n);\n+        final Complex[] expected;\n+        final Complex[] actual;\n+        final double s;\n+        if (forward) {\n+            expected = dft(x, -1);\n+            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n+            actual = fft.transform(x);\n+        } else {\n+            expected = dft(x, 1);\n+            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n+            actual = fft.inverseTransform(x);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n+\n+    private static void doTestTransformReal(final int n, final double tol,\n+        final boolean forward, final boolean standard) {\n+        final FastFourierTransformer fft;\n+        if (standard) {\n+            fft = FastFourierTransformer.create();\n+        } else {\n+            fft = FastFourierTransformer.createUnitary();\n+        }\n+        final double[] x = createRealData(n);\n+        final Complex[] xc = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            xc[i] = new Complex(x[i], 0.0);\n+        }\n+        final Complex[] expected;\n+        final Complex[] actual;\n+        final double s;\n+        if (forward) {\n+            expected = dft(xc, -1);\n+            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n+            actual = fft.transform(x);\n+        } else {\n+            expected = dft(xc, 1);\n+            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n+            actual = fft.inverseTransform(x);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n+\n+    private static void doTestTransformFunction(final UnivariateFunction f,\n+        final double min, final double max, int n, final double tol,\n+        final boolean forward, final boolean standard) {\n+        final FastFourierTransformer fft;\n+        if (standard) {\n+            fft = FastFourierTransformer.create();\n+        } else {\n+            fft = FastFourierTransformer.createUnitary();\n+        }\n+        final Complex[] x = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            final double t = min + i * (max - min) / n;\n+            x[i] = new Complex(f.value(t));\n+        }\n+        final Complex[] expected;\n+        final Complex[] actual;\n+        final double s;\n+        if (forward) {\n+            expected = dft(x, -1);\n+            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n+            actual = fft.transform(f, min, max, n);\n+        } else {\n+            expected = dft(x, 1);\n+            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n+            actual = fft.inverseTransform(f, min, max, n);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n+\n+    /*\n+     * Tests of standard transform (when data is valid).\n+     */\n+\n+    @Test\n+    public void testStandardTransformComplex() {\n+        final boolean forward = true;\n+        final boolean standard = true;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-13, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardTransformReal() {\n+        final boolean forward = true;\n+        final boolean standard = true;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-13, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = true;\n+        final boolean standard = true;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardInverseTransformComplex() {\n+        final boolean forward = false;\n+        final boolean standard = true;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-12, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardInverseTransformReal() {\n+        final boolean forward = false;\n+        final boolean standard = true;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-12, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardInverseTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = false;\n+        final boolean standard = true;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    /*\n+     * Tests of unitary transform (when data is valid).\n+     */\n+\n+    @Test\n+    public void testUnitaryTransformComplex() {\n+        final boolean forward = true;\n+        final boolean standard = false;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-13, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryTransformReal() {\n+        final boolean forward = true;\n+        final boolean standard = false;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-13, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = true;\n+        final boolean standard = false;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryInverseTransformComplex() {\n+        final boolean forward = false;\n+        final boolean standard = false;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-12, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryInverseTransformReal() {\n+        final boolean forward = false;\n+        final boolean standard = false;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-12, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryInverseTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = false;\n+        final boolean standard = false;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    /*\n+     * Additional tests for 1D data.\n+     */\n \n     /**\n      * Test of transformer for the ad hoc data taken from Mathematica.\n             Assert.assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n         }\n     }\n+\n+    /**\n+     * Test of transformer for the sine function.\n+     */\n+    @Test\n+    public void testSinFunction() {\n+        UnivariateFunction f = new SinFunction();\n+        FastFourierTransformer transformer = FastFourierTransformer.create();\n+        Complex result[]; int N = 1 << 8;\n+        double min, max, tolerance = 1E-12;\n+\n+        min = 0.0; max = 2.0 * FastMath.PI;\n+        result = transformer.transform(f, min, max, N);\n+        Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n+        Assert.assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n+        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        Assert.assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);\n+        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n+            Assert.assertEquals(0.0, result[i].getReal(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+\n+        min = -FastMath.PI; max = FastMath.PI;\n+        result = transformer.inverseTransform(f, min, max, N);\n+        Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n+        Assert.assertEquals(-0.5, result[1].getImaginary(), tolerance);\n+        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n+        Assert.assertEquals(0.5, result[N-1].getImaginary(), tolerance);\n+        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n+            Assert.assertEquals(0.0, result[i].getReal(), tolerance);\n+            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n+        }\n+    }\n+\n+    /*\n+     * Additional tests for 2D data.\n+     */\n \n     @Test\n     public void test2DData() {\n         }\n     }\n \n-    /**\n-     * Test of transformer for the sine function.\n-     */\n-    @Test\n-    public void testSinFunction() {\n-        UnivariateFunction f = new SinFunction();\n-        FastFourierTransformer transformer = FastFourierTransformer.create();\n-        Complex result[]; int N = 1 << 8;\n-        double min, max, tolerance = 1E-12;\n-\n-        min = 0.0; max = 2.0 * FastMath.PI;\n-        result = transformer.transform(f, min, max, N);\n-        Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n-        Assert.assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n-        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n-        Assert.assertEquals(N >> 1, result[N-1].getImaginary(), tolerance);\n-        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n-            Assert.assertEquals(0.0, result[i].getReal(), tolerance);\n-            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n-        }\n-\n-        min = -FastMath.PI; max = FastMath.PI;\n-        result = transformer.inverseTransform(f, min, max, N);\n-        Assert.assertEquals(0.0, result[1].getReal(), tolerance);\n-        Assert.assertEquals(-0.5, result[1].getImaginary(), tolerance);\n-        Assert.assertEquals(0.0, result[N-1].getReal(), tolerance);\n-        Assert.assertEquals(0.5, result[N-1].getImaginary(), tolerance);\n-        for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) {\n-            Assert.assertEquals(0.0, result[i].getReal(), tolerance);\n-            Assert.assertEquals(0.0, result[i].getImaginary(), tolerance);\n-        }\n-    }\n-\n-    /**\n-     * Test of parameters for the transformer.\n-     */\n-    @Test\n-    public void testParameters() throws Exception {\n-        UnivariateFunction f = new SinFunction();\n-        FastFourierTransformer transformer = FastFourierTransformer.create();\n-\n-        try {\n-            // bad interval\n-            transformer.transform(f, 1, -1, 64);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad samples number\n-            transformer.transform(f, -1, 1, 0);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad samples number\n-            transformer.transform(f, -1, 1, 100);\n-            Assert.fail(\"Expecting IllegalArgumentException - bad samples number\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** Naive implementation of DFT, for reference. */\n-    private static Complex[] dft(final Complex[] x, final int sgn) {\n-        final int n = x.length;\n-        final double[] cos = new double[n];\n-        final double[] sin = new double[n];\n-        final Complex[] y = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            final double arg = 2.0 * FastMath.PI * i / n;\n-            cos[i] = FastMath.cos(arg);\n-            sin[i] = FastMath.sin(arg);\n-        }\n-        for (int i = 0; i < n; i++) {\n-            double yr = 0.0;\n-            double yi = 0.0;\n-            for (int j = 0; j < n; j++) {\n-                final int index = (i * j) % n;\n-                final double c = cos[index];\n-                final double s = sin[index];\n-                final double xr = x[j].getReal();\n-                final double xi = x[j].getImaginary();\n-                yr += c * xr - sgn * s * xi;\n-                yi += sgn * s * xr + c * xi;\n-            }\n-            y[i] = new Complex(yr, yi);\n-        }\n-        return y;\n-    }\n-    \n-    @Test\n-    public void testStandardTransformComplex() {\n-        final boolean forward = true;\n-        final boolean standard = true;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-13, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryTransformComplex() {\n-        final boolean forward = true;\n-        final boolean standard = false;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-13, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardInverseTransformComplex() {\n-        final boolean forward = false;\n-        final boolean standard = true;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-12, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryInverseTransformComplex() {\n-        final boolean forward = false;\n-        final boolean standard = false;\n-        doTestTransformComplex(2, 1.0E-15, forward, standard);\n-        doTestTransformComplex(4, 1.0E-14, forward, standard);\n-        doTestTransformComplex(8, 1.0E-14, forward, standard);\n-        doTestTransformComplex(16, 1.0E-13, forward, standard);\n-        doTestTransformComplex(32, 1.0E-13, forward, standard);\n-        doTestTransformComplex(64, 1.0E-12, forward, standard);\n-        doTestTransformComplex(128, 1.0E-12, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardTransformReal() {\n-        final boolean forward = true;\n-        final boolean standard = true;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-13, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryTransformReal() {\n-        final boolean forward = true;\n-        final boolean standard = false;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-13, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardInverseTransformReal() {\n-        final boolean forward = false;\n-        final boolean standard = true;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-12, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryInverseTransformReal() {\n-        final boolean forward = false;\n-        final boolean standard = false;\n-        doTestTransformReal(2, 1.0E-15, forward, standard);\n-        doTestTransformReal(4, 1.0E-14, forward, standard);\n-        doTestTransformReal(8, 1.0E-14, forward, standard);\n-        doTestTransformReal(16, 1.0E-13, forward, standard);\n-        doTestTransformReal(32, 1.0E-13, forward, standard);\n-        doTestTransformReal(64, 1.0E-12, forward, standard);\n-        doTestTransformReal(128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardTransformFunction() {\n-        final UnivariateFunction f = new Sinc();\n-        final double min = -FastMath.PI;\n-        final double max = FastMath.PI;\n-        final boolean forward = true;\n-        final boolean standard = true;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryTransformFunction() {\n-        final UnivariateFunction f = new Sinc();\n-        final double min = -FastMath.PI;\n-        final double max = FastMath.PI;\n-        final boolean forward = true;\n-        final boolean standard = false;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testStandardInverseTransformFunction() {\n-        final UnivariateFunction f = new Sinc();\n-        final double min = -FastMath.PI;\n-        final double max = FastMath.PI;\n-        final boolean forward = false;\n-        final boolean standard = true;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n-    }\n-\n-    @Test\n-    public void testUnitaryInverseTransformFunction() {\n-        final UnivariateFunction f = new Sinc();\n-        final double min = -FastMath.PI;\n-        final double max = FastMath.PI;\n-        final boolean forward = false;\n-        final boolean standard = false;\n-        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n-        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n-        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n-        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n-        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n-    }\n-\n-    private static Complex[] createComplexData(final int n) {\n-        final Random random = new Random(SEED);\n-        final Complex[] data = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            final double re = 2.0 * random.nextDouble() - 1.0;\n-            final double im = 2.0 * random.nextDouble() - 1.0;\n-            data[i] = new Complex(re, im);\n-        }\n-        return data;\n-    }\n-\n-    private static double[] createRealData(final int n) {\n-        final Random random = new Random(SEED);\n-        final double[] data = new double[n];\n-        for (int i = 0; i < n; i++) {\n-            data[i] = 2.0 * random.nextDouble() - 1.0;\n-        }\n-        return data;\n-    }\n-\n-    private static void doTestTransformComplex(final int n, final double tol,\n-        final boolean forward, final boolean standard) {\n-        final FastFourierTransformer fft;\n-        if (standard) {\n-            fft = FastFourierTransformer.create();\n-        } else {\n-            fft = FastFourierTransformer.createUnitary();\n-        }\n-        final Complex[] x = createComplexData(n);\n-        final Complex[] expected;\n-        final Complex[] actual;\n-        final double s;\n-        if (forward) {\n-            expected = dft(x, -1);\n-            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n-            actual = fft.transform(x);\n-        } else {\n-            expected = dft(x, 1);\n-            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n-            actual = fft.inverseTransform(x);\n-        }\n-        for (int i = 0; i < n; i++) {\n-            final String msg = String.format(\"%d, %d\", n, i);\n-            final double re = s * expected[i].getReal();\n-            Assert.assertEquals(msg, re, actual[i].getReal(),\n-                tol * FastMath.abs(re));\n-            final double im = s * expected[i].getImaginary();\n-            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n-                FastMath.abs(re));\n-        }\n-    }\n-\n-    private static void doTestTransformReal(final int n, final double tol,\n-        final boolean forward, final boolean standard) {\n-        final FastFourierTransformer fft;\n-        if (standard) {\n-            fft = FastFourierTransformer.create();\n-        } else {\n-            fft = FastFourierTransformer.createUnitary();\n-        }\n-        final double[] x = createRealData(n);\n-        final Complex[] xc = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            xc[i] = new Complex(x[i], 0.0);\n-        }\n-        final Complex[] expected;\n-        final Complex[] actual;\n-        final double s;\n-        if (forward) {\n-            expected = dft(xc, -1);\n-            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n-            actual = fft.transform(x);\n-        } else {\n-            expected = dft(xc, 1);\n-            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n-            actual = fft.inverseTransform(x);\n-        }\n-        for (int i = 0; i < n; i++) {\n-            final String msg = String.format(\"%d, %d\", n, i);\n-            final double re = s * expected[i].getReal();\n-            Assert.assertEquals(msg, re, actual[i].getReal(),\n-                tol * FastMath.abs(re));\n-            final double im = s * expected[i].getImaginary();\n-            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n-                FastMath.abs(re));\n-        }\n-    }\n-\n-    private static void doTestTransformFunction(final UnivariateFunction f,\n-        final double min, final double max, int n, final double tol,\n-        final boolean forward, final boolean standard) {\n-        final FastFourierTransformer fft;\n-        if (standard) {\n-            fft = FastFourierTransformer.create();\n-        } else {\n-            fft = FastFourierTransformer.createUnitary();\n-        }\n-        final Complex[] x = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            final double t = min + i * (max - min) / n;\n-            x[i] = new Complex(f.value(t));\n-        }\n-        final Complex[] expected;\n-        final Complex[] actual;\n-        final double s;\n-        if (forward) {\n-            expected = dft(x, -1);\n-            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n-            actual = fft.transform(f, min, max, n);\n-        } else {\n-            expected = dft(x, 1);\n-            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n-            actual = fft.inverseTransform(f, min, max, n);\n-        }\n-        for (int i = 0; i < n; i++) {\n-            final String msg = String.format(\"%d, %d\", n, i);\n-            final double re = s * expected[i].getReal();\n-            Assert.assertEquals(msg, re, actual[i].getReal(),\n-                tol * FastMath.abs(re));\n-            final double im = s * expected[i].getImaginary();\n-            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n-                FastMath.abs(re));\n-        }\n-    }\n }", "timestamp": 1326871068, "metainfo": ""}