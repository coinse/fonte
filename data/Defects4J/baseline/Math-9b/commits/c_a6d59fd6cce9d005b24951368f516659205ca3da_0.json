{"sha": "a6d59fd6cce9d005b24951368f516659205ca3da", "log": "Added solve methods using double[][] to linear algebra decomposition solvers.  JIRA: MATH-564  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n-        /** {@inheritDoc} */\n-        public RealMatrix solve(RealMatrix b) {\n+        /** Solve the linear equation A &times; X = B for matrices A.\n+         * <p>The A matrix is implicit, it is provided by the underlying\n+         * decomposition algorithm.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @param reUseB if true, the b array will be reused and returned,\n+         * instead of being copied\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         * @throws SingularMatrixException\n+         * if the decomposed matrix is singular.\n+         */\n+        private double[][] solve(double[][] b, boolean reUseB) {\n             final int m = lTData.length;\n-            if (b.getRowDimension() != m) {\n-                throw new DimensionMismatchException(b.getRowDimension(), m);\n-            }\n-\n-            final int nColB = b.getColumnDimension();\n-            double[][] x = b.getData();\n+            if (b.length != m) {\n+                throw new DimensionMismatchException(b.length, m);\n+            }\n+\n+            final int nColB = b[0].length;\n+            final double[][] x;\n+            if (reUseB) {\n+                x = b;\n+            } else {\n+                x = new double[b.length][nColB];\n+                for (int i = 0; i < b.length; ++i) {\n+                    System.arraycopy(b[i], 0, x[i], 0, nColB);\n+                }\n+            }\n \n             // Solve LY = b\n             for (int j = 0; j < m; j++) {\n                 }\n             }\n \n-            return new Array2DRowRealMatrix(x, false);\n-\n+            return x;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[][] solve(double[][] b) {\n+            return solve(b, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            return new Array2DRowRealMatrix(solve(b.getData(), true), false);\n         }\n \n         /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n      * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n+    double[][] solve(final double[][] b);\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the matrices dimensions do not match.\n+     * @throws SingularMatrixException\n+     * if the decomposed matrix is singular.\n+     */\n     RealMatrix solve(final RealMatrix b);\n \n     /**\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n             return new ArrayRealVector(bp, false);\n         }\n \n-        /**\n-         * Solve the linear equation A &times; X = B for symmetric matrices A.\n-         * <p>\n-         * This method only find exact linear solutions, i.e. solutions for\n-         * which ||A &times; X - B|| is exactly 0.\n-         * </p>\n-         * @param b Right-hand side of the equation A &times; X = B\n-         * @return a Matrix X that minimizes the two norm of A &times; X - B\n-         * @throws DimensionMismatchException if the matrices dimensions do not match.\n-         * @throws SingularMatrixException if the decomposed matrix is singular.\n+        /** Solve the linear equation A &times; X = B for matrices A.\n+         * <p>The A matrix is implicit, it is provided by the underlying\n+         * decomposition algorithm.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @param reUseB if true, the b array will be reused and returned,\n+         * instead of being copied\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         * @throws SingularMatrixException\n+         * if the decomposed matrix is singular.\n          */\n-        public RealMatrix solve(final RealMatrix b) {\n+        private double[][] solve(double[][] b, boolean reUseB) {\n \n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n             }\n \n             final int m = realEigenvalues.length;\n-            if (b.getRowDimension() != m) {\n-                throw new DimensionMismatchException(b.getRowDimension(), m);\n-            }\n-\n-            final int nColB = b.getColumnDimension();\n-            final double[][] bp = new double[m][nColB];\n+            if (b.length != m) {\n+                throw new DimensionMismatchException(b.length, m);\n+            }\n+\n+            final int nColB = b[0].length;\n+            final double[][] bp;\n+            if (reUseB) {\n+                bp = b;\n+            } else {\n+                bp = new double[m][nColB];\n+            }\n+            final double[] tmpCol = new double[m];\n             for (int k = 0; k < nColB; ++k) {\n+                for (int i = 0; i < m; ++i) {\n+                    tmpCol[i] = b[i][k];\n+                    bp[i][k]  = 0;\n+                }\n                 for (int i = 0; i < m; ++i) {\n                     final ArrayRealVector v = eigenvectors[i];\n                     final double[] vData = v.getDataRef();\n                     double s = 0;\n                     for (int j = 0; j < m; ++j) {\n-                        s += v.getEntry(j) * b.getEntry(j, k);\n+                        s += v.getEntry(j) * tmpCol[j];\n                     }\n                     s /= realEigenvalues[i];\n                     for (int j = 0; j < m; ++j) {\n                 }\n             }\n \n-            return MatrixUtils.createRealMatrix(bp);\n-\n+            return bp;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[][] solve(double[][] b) {\n+            return solve(b, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            return new Array2DRowRealMatrix(solve(b.getData(), true), false);\n         }\n \n         /**\n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n         }\n \n         /** {@inheritDoc} */\n-        public RealMatrix solve(RealMatrix b) {\n-\n-            final int m = pivot.length;\n-            if (b.getRowDimension() != m) {\n-                throw new DimensionMismatchException(b.getRowDimension(), m);\n+        public double[][] solve(double[][] b) {\n+\n+            final int m = pivot.length;\n+            if (b.length != m) {\n+                throw new DimensionMismatchException(b.length, m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n             }\n \n-            final int nColB = b.getColumnDimension();\n+            final int nColB = b[0].length;\n \n             // Apply permutations to b\n             final double[][] bp = new double[m][nColB];\n                 final double[] bpRow = bp[row];\n                 final int pRow = pivot[row];\n                 for (int col = 0; col < nColB; col++) {\n-                    bpRow[col] = b.getEntry(pRow, col);\n+                    bpRow[col] = b[pRow][col];\n                 }\n             }\n \n                 }\n             }\n \n-            return new Array2DRowRealMatrix(bp, false);\n+            return bp;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            return new Array2DRowRealMatrix(solve(b.getData()), false);\n         }\n \n         /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n         }\n \n         /** {@inheritDoc} */\n+        public double[][] solve(double[][] b) {\n+            return solve(new BlockRealMatrix(b)).getData();\n+        }\n+\n+        /** {@inheritDoc} */\n         public RealMatrix solve(RealMatrix b) {\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n          * @throws org.apache.commons.math.exception.DimensionMismatchException\n          * if the matrices dimensions do not match.\n          */\n+        public double[][] solve(final double[][] b) {\n+            return pseudoInverse.multiply(MatrixUtils.createRealMatrix(b)).getData();\n+        }\n+\n+        /**\n+         * Solve the linear equation A &times; X = B in least square sense.\n+         * <p>\n+         * The m&times;n matrix A may not be square, the solution X is such that\n+         * ||A &times; X - B|| is minimal.\n+         * </p>\n+         *\n+         * @param b Right-hand side of the equation A &times; X = B\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         */\n         public RealMatrix solve(final RealMatrix b) {\n             return pseudoInverse.multiply(b);\n         }\n--- a/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskySolverTest.java\n         // using RealMatrix\n         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n \n+        // using double[][]\n+        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), 1.0e-13);\n+\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             Assert.assertEquals(0,\n--- a/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n         RealMatrix solution=es.solve(b);\n         Assert.assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);\n \n+        // using double[][]\n+        solution = MatrixUtils.createRealMatrix(es.solve(b.getData()));\n+        Assert.assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12);\n+\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             Assert.assertEquals(0,\n--- a/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n         // using RealMatrix\n         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n \n+        // using double[][]\n+        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), 1.0e-13);\n+\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             Assert.assertEquals(0,\n--- a/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n         // using RealMatrix\n         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());\n \n+        // using double[][]\n+        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());\n+\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             final double[] x = solver.solve(b.getColumn(i));\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n         // using RealMatrix\n         Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);\n \n+        // using double[][]\n+        Assert.assertEquals(0, MatrixUtils.createRealMatrix(solver.solve(b.getData())).subtract(xRef).getNorm(), normTolerance);\n+\n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             Assert.assertEquals(0,", "timestamp": 1304066918, "metainfo": ""}