{"sha": "2088737d6d6165548dfd8cd7970db961a75a7486", "log": "MATH 650 FastMath has static code which slows the first access to FastMath Enclose each large data table in nested static class so it's only loaded on first access   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n \n     private static final int EXP_INT_TABLE_MAX_INDEX = 750;\n     private static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n+\n+    // Enclose large data table in nested static class so it's only loaded on first access\n+  private static class ExpInitTable {\n \n     /** Exponential evaluated at integer values,\n      * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].\n         Double.NaN,\n         Double.NaN,\n     };\n+  }\n \n     private static final int TWO_POWER_10 = 1024;\n     private static final int EXP_FRAC_TABLE_LEN = TWO_POWER_10 + 1; // 0, 1/1024, ... 1024/1024\n+\n+    // Enclose large data table in nested static class so it's only loaded on first access\n+  private static class ExpFracTable {\n \n     /** Exponential over the range of 0 - 1 in increments of 2^-10\n      * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n         -7.184550924856607E-8d,\n         +8.254840070367875E-8d,\n     };\n+  }\n \n     private static final int FACT_LEN = 20;\n \n             \n \n     private static final int LN_MANT_LEN = 1024; // MAGIC NUMBER\n+\n+    // Enclose large data table in nested static class so it's only loaded on first access\n+  private static class lnMant {\n \n     /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n     private static final double LN_MANT[][] =     { \n         {+0.6921701431274414d,    -2.2153227096187463E-9d, }, // 1022\n         {+0.6926587820053101d,    -1.943473623641502E-9d,  }, // 1023\n     };\n+  }\n \n \n     /** log(2) (high bits). */\n         // Populate expIntTable\n         for (i = 0; i < EXP_INT_TABLE_MAX_INDEX; i++) {\n             expint(i, tmp);\n-            EXP_INT_TABLE_A[i+EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n-            EXP_INT_TABLE_B[i+EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n+            ExpInitTable.EXP_INT_TABLE_A[i+EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n+            ExpInitTable.EXP_INT_TABLE_B[i+EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n \n             if (i != 0) {\n                 // Negative integer powers\n                 splitReciprocal(tmp, recip);\n-                EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-i] = recip[0];\n-                EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-i] = recip[1];\n+                ExpInitTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-i] = recip[0];\n+                ExpInitTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-i] = recip[1];\n             }\n         }\n \n         // Populate expFracTable\n-        for (i = 0; i < EXP_FRAC_TABLE_A.length; i++) {\n+        for (i = 0; i < ExpFracTable.EXP_FRAC_TABLE_A.length; i++) {\n             slowexp(i/1024.0, tmp); // TWO_POWER_10\n-            EXP_FRAC_TABLE_A[i] = tmp[0];\n-            EXP_FRAC_TABLE_B[i] = tmp[1];\n+            ExpFracTable.EXP_FRAC_TABLE_A[i] = tmp[0];\n+            ExpFracTable.EXP_FRAC_TABLE_B[i] = tmp[1];\n         }\n \n         // Populate lnMant table\n-        for (i = 0; i < LN_MANT.length; i++) {\n+        for (i = 0; i < lnMant.LN_MANT.length; i++) {\n             double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n-            LN_MANT[i] = slowLog(d);\n+            lnMant.LN_MANT[i] = slowLog(d);\n         }\n \n         // Build the sine and cosine tables\n \n     public static void main(String[] a){\n         printarray(\"FACT\", FACT_LEN, FACT);\n-        printarray(\"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, EXP_INT_TABLE_A);\n-        printarray(\"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, EXP_INT_TABLE_B);\n-        printarray(\"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, EXP_FRAC_TABLE_A);\n-        printarray(\"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, EXP_FRAC_TABLE_B);\n-        printarray(\"LN_MANT\",LN_MANT_LEN, LN_MANT);\n+        printarray(\"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpInitTable.EXP_INT_TABLE_A);\n+        printarray(\"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpInitTable.EXP_INT_TABLE_B);\n+        printarray(\"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n+        printarray(\"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n+        printarray(\"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n         printarray(\"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n         printarray(\"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n         printarray(\"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n \n             intVal++;\n \n-            intPartA = EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n-            intPartB = EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n+            intPartA = ExpInitTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n+            intPartB = ExpInitTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n \n             intVal = -intVal;\n         } else {\n                 return Double.POSITIVE_INFINITY;\n             }\n \n-            intPartA = EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n-            intPartB = EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n+            intPartA = ExpInitTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n+            intPartB = ExpInitTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n         }\n \n         /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n          * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n          */\n         final int intFrac = (int) ((x - intVal) * 1024.0);\n-        final double fracPartA = EXP_FRAC_TABLE_A[intFrac];\n-        final double fracPartB = EXP_FRAC_TABLE_B[intFrac];\n+        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n+        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n \n         /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n          * has a value in the range 0 <= epsilon < 2^-10.\n \n         {\n             int intFrac = (int) (x * 1024.0);\n-            double tempA = EXP_FRAC_TABLE_A[intFrac] - 1.0;\n-            double tempB = EXP_FRAC_TABLE_B[intFrac];\n+            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\n+            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n \n             double temp = tempA + tempB;\n             tempB = -(temp - tempA - tempB);\n         }\n \n         // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n-        double lnm[] = LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n+        double lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n \n         /*\n     double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);", "timestamp": 1315433106, "metainfo": ""}