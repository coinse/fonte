{"sha": "463e936fe247ae397b75758a87d682d8babc7e12", "log": "MATH-797 Added unit test.   ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactoryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+/**\n+ * Test for {@link BaseRuleFactory}.\n+ *\n+ * @version $Id$\n+ */\n+public class BaseRuleFactoryTest {\n+    /**\n+     * Tests that a given rule rule will be computed and added once to the cache\n+     * whatever the number of times this rule is called concurrently.\n+     */\n+    @Test\n+    public void testConcurrentCreation() throws InterruptedException {\n+        // Number of times the same rule will be called.\n+        final int numTasks = 20;\n+\n+        final ThreadPoolExecutor exec\n+            = new ThreadPoolExecutor(3, numTasks, 1, TimeUnit.SECONDS,\n+                                     new ArrayBlockingQueue<Runnable>(2));\n+\n+        final List<RuleBuilder> tasks = new ArrayList<RuleBuilder>();\n+        for (int i = 0; i < numTasks; i++) {\n+            tasks.add(new RuleBuilder());\n+        }\n+\n+        List<Future<Pair<double[], double[]>>> results = exec.invokeAll(tasks);\n+\n+        // Assertion would fail if \"getRuleInternal\" were not \"synchronized\".\n+        final int n = RuleBuilder.getNumberOfCalls();\n+        Assert.assertEquals(\"Rule computation was called \" + n + \" times\", 1, n);\n+    }\n+}\n+\n+class RuleBuilder implements Callable<Pair<double[], double[]>> {\n+    private static final DummyRuleFactory factory = new DummyRuleFactory();\n+\n+    public Pair<double[], double[]> call() {\n+        final int dummy = 2; // Always request the same rule.\n+        return factory.getRule(dummy);\n+    }\n+\n+    public static int getNumberOfCalls() {\n+        return factory.getNumberOfCalls();\n+    }\n+}\n+\n+class DummyRuleFactory extends BaseRuleFactory<Double> {\n+    /** Rule computations counter. */\n+    private static AtomicInteger nCalls = new AtomicInteger();\n+\n+    @Override\n+    protected Pair<Double[], Double[]> computeRule(int order) {\n+        // Tracks whether this computation has been called more than once.\n+        nCalls.getAndIncrement();\n+\n+        try {\n+            // Sleep to simulate computation time.\n+            Thread.sleep(20);\n+        } catch (InterruptedException e) {\n+            Assert.fail(\"Unexpected interruption\");\n+        }\n+\n+         // Dummy rule (but contents must exist).\n+        return new Pair<Double[], Double[]>(new Double[order],\n+                                            new Double[order]);\n+    }\n+\n+    public int getNumberOfCalls() {\n+        return nCalls.get();\n+    }\n+}", "timestamp": 1342874824, "metainfo": ""}