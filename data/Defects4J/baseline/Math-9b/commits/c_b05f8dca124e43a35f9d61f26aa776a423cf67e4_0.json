{"sha": "b05f8dca124e43a35f9d61f26aa776a423cf67e4", "log": "applied Benjamin's patch from 2009-09-08 warning: I had to update the expected matrix in SimplexTableauTest.testdiscardArtificialVariables  JIRA: MATH-286  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n             new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n \n         solvePhase1(tableau);\n-        tableau.discardArtificialVariables();\n+        tableau.dropPhase1Objective();\n \n         while (!tableau.isOptimal()) {\n             doIteration(tableau);\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n                                       getConstraintTypeCounts(Relationship.GEQ);\n         this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                       getConstraintTypeCounts(Relationship.GEQ);\n-        this.tableau = new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));\n-        initialize();\n+        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n     }\n \n     /**\n      * @param maximize if true, goal is to maximize the objective function\n      * @return created tableau\n      */\n-    protected double[][] createTableau(final boolean maximize) {\n+    protected RealMatrix createTableau(final boolean maximize) {\n \n         // create a matrix of the correct size\n         int width = numDecisionVariables + numSlackVariables +\n         numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n         int height = constraints.size() + getNumObjectiveFunctions();\n-        double[][] matrix = new double[height][width];\n+        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n \n         // initialize the objective function rows\n         if (getNumObjectiveFunctions() == 2) {\n-            matrix[0][0] = -1;\n+            matrix.setEntry(0, 0, -1);\n         }\n         int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n-        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n+        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n         RealVector objectiveCoefficients =\n             maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n-        copyArray(objectiveCoefficients.getData(), matrix[zIndex]);\n-        matrix[zIndex][width - 1] =\n-            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n+        copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);\n+        matrix.setEntry(zIndex, width - 1,\n+            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n \n         if (!restrictToNonNegative) {\n-            matrix[zIndex][getSlackVariableOffset() - 1] =\n-                getInvertedCoeffiecientSum(objectiveCoefficients);\n+            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n+                getInvertedCoeffiecientSum(objectiveCoefficients));\n         }\n \n         // initialize the constraint rows\n             int row = getNumObjectiveFunctions() + i;\n \n             // decision variable coefficients\n-            copyArray(constraint.getCoefficients().getData(), matrix[row]);\n+            copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);\n \n             // x-\n             if (!restrictToNonNegative) {\n-                matrix[row][getSlackVariableOffset() - 1] =\n-                    getInvertedCoeffiecientSum(constraint.getCoefficients());\n+                matrix.setEntry(row, getSlackVariableOffset() - 1,\n+                    getInvertedCoeffiecientSum(constraint.getCoefficients()));\n             }\n \n             // RHS\n-            matrix[row][width - 1] = constraint.getValue();\n+            matrix.setEntry(row, width - 1, constraint.getValue());\n \n             // slack variables\n             if (constraint.getRelationship() == Relationship.LEQ) {\n-                matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack\n+                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n             } else if (constraint.getRelationship() == Relationship.GEQ) {\n-                matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess\n+                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n             }\n \n             // artificial variables\n             if ((constraint.getRelationship() == Relationship.EQ) ||\n                     (constraint.getRelationship() == Relationship.GEQ)) {\n-                matrix[0][getArtificialVariableOffset() + artificialVar] = 1;\n-                matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;\n+                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n+                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n+                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n             }\n         }\n \n         return matrix;\n-\n     }\n \n     /**\n     }\n \n     /**\n-     * Puts the tableau in proper form by zeroing out the artificial variables\n-     * in the objective function via elementary row operations.\n-     */\n-    private void initialize() {\n-        for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n-            int row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n-            subtractRow(0, row, 1.0);\n-        }\n-    }\n-\n-    /**\n      * Get the -1 times the sum of all coefficients in the given array.\n      * @param coefficients coefficients to sum\n      * @return the -1 times the sum of all coefficients in the given array.\n      * @param col index of the column to check\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n-    Integer getBasicRow(final int col) {\n-        return getBasicRow(col, true);\n-    }\n-\n-    /**\n-     * Checks whether the given column is basic.\n-     * @param col index of the column to check\n-     * @return the row that the variable is basic in.  null if the column is not basic\n-     */\n-    private Integer getBasicRowForSolution(final int col) {\n-        return getBasicRow(col, false);\n-    }\n-\n-    /**\n-     * Checks whether the given column is basic.\n-     * @param col index of the column to check\n-     * @param ignoreObjectiveRows if true ignore the first rows which correspond\n-     * to objective functions\n-     * @return the row that the variable is basic in.  null if the column is not basic\n-     */\n-    private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n+    protected Integer getBasicRow(final int col) {\n         Integer row = null;\n-        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n-        for (int i = start; i < getHeight(); i++) {\n+        for (int i = 0; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n     }\n \n     /**\n-     * Removes the phase 1 objective function and artificial variables from this tableau.\n-     */\n-    protected void discardArtificialVariables() {\n-        if (numArtificialVariables == 0) {\n+     * Removes the phase 1 objective function, positive cost non-artificial variables,\n+     * and the non-basic artificial variables from this tableau.\n+     */\n+    protected void dropPhase1Objective() {\n+        if (getNumObjectiveFunctions() == 1) {\n             return;\n         }\n-        int width = getWidth() - numArtificialVariables - 1;\n-        int height = getHeight() - 1;\n-        double[][] matrix = new double[height][width];\n-        for (int i = 0; i < height; i++) {\n-            for (int j = 0; j < width - 1; j++) {\n-                matrix[i][j] = getEntry(i + 1, j + 1);\n-            }\n-            matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());\n-        }\n+\n+        List<Integer> columnsToDrop = new ArrayList<Integer>();\n+        columnsToDrop.add(0);\n+\n+        // positive cost non-artificial variables\n+        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n+          if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\n+            columnsToDrop.add(i);\n+          }\n+        }\n+\n+        // non-basic artificial variables\n+        for (int i = 0; i < getNumArtificialVariables(); i++) {\n+          int col = i + getArtificialVariableOffset();\n+          if (getBasicRow(col) == null) {\n+            columnsToDrop.add(col);\n+          }\n+        }\n+\n+        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n+        for (int i = 1; i < getHeight(); i++) {\n+          int col = 0;\n+          for (int j = 0; j < getWidth(); j++) {\n+            if (!columnsToDrop.contains(j)) {\n+              matrix[i - 1][col++] = tableau.getEntry(i, j);\n+            }\n+          }\n+        }\n+\n         this.tableau = new Array2DRowRealMatrix(matrix);\n         this.numArtificialVariables = 0;\n     }\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n+      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n-          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n+          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n      */\n     protected void subtractRow(final int minuendRow, final int subtrahendRow,\n                                final double multiple) {\n-        for (int j = 0; j < getWidth(); j++) {\n-            tableau.setEntry(minuendRow, j, tableau.getEntry(minuendRow, j) -\n-                             multiple * tableau.getEntry(subtrahendRow, j));\n-        }\n+        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow)\n+            .subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n \n     @Test\n     public void testMath286() throws OptimizationException {\n-        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.2, 0.3 }, 0 );\n-        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n-        constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 23.0));\n+        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 );\n+        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+        constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0));\n+        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0));\n+        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0));\n+        constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0));\n+        constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0));\n \n         SimplexSolver solver = new SimplexSolver();\n         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n-        Assert.assertEquals(6.9, solution.getValue(), .0000001);\n+        Assert.assertEquals(25.8, solution.getValue(), .0000001);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexTableauTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexTableauTest.java\n         SimplexTableau tableau =\n             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);\n         double[][] expectedTableau = {\n-                                      { 1, -15, -10, 25, 0, 0, 0},\n-                                      { 0,   1,   0, -1, 1, 0, 2},\n-                                      { 0,   0,   1, -1, 0, 1, 3},\n-                                      { 0,   1,   1, -2, 0, 0, 4}\n+                                      { 1, -15, -10, 0, 0, 0, 0},\n+                                      { 0,   1,   0, 1, 0, 0, 2},\n+                                      { 0,   0,   1, 0, 1, 0, 3},\n+                                      { 0,   1,   1, 0, 0, 1, 4}\n         };\n-        tableau.discardArtificialVariables();\n+        tableau.dropPhase1Objective();\n         assertMatrixEquals(expectedTableau, tableau.getData());\n     }\n ", "timestamp": 1252486083, "metainfo": ""}