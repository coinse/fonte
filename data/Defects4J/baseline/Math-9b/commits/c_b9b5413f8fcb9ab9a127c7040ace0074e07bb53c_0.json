{"sha": "b9b5413f8fcb9ab9a127c7040ace0074e07bb53c", "log": "MATH-425 Removed redundant exception \"throws\" clauses. Javadoc cleanup. Throwing \"NoDataException\" instead of \"ZeroException\" when row or column data is missing.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n  * <p>All the methods implemented here use {@link #getEntry(int, int)} to access\n  * matrix elements. Derived class can provide faster implementations. </p>\n  *\n- * @param <T> the type of the field elements\n+ * @param <T> Type of the field elements.\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public abstract class AbstractFieldMatrix<T extends FieldElement<T>> implements FieldMatrix<T> {\n+public abstract class AbstractFieldMatrix<T extends FieldElement<T>>\n+    implements FieldMatrix<T> {\n     /** Field to which the elements belong. */\n     private final Field<T> field;\n \n     }\n \n     /** {@inheritDoc} */\n-    public abstract FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException;\n+    public abstract FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension);\n \n     /** {@inheritDoc} */\n     public abstract FieldMatrix<T> copy();\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> add(FieldMatrix<T> m) throws IllegalArgumentException {\n-\n+    public FieldMatrix<T> add(FieldMatrix<T> m) {\n         // safety check\n         checkAdditionCompatible(m);\n \n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldMatrix<T> subtract(final FieldMatrix<T> m) throws IllegalArgumentException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m) {\n         // safety check\n         checkSubtractionCompatible(m);\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> scalarMultiply(final T d) {\n-\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m) {\n         // safety check\n         checkMultiplicationCompatible(m);\n \n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldMatrix<T> preMultiply(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> preMultiply(final FieldMatrix<T> m) {\n         return m.multiply(this);\n     }\n \n     /** {@inheritDoc} */\n     public T[][] getData() {\n-\n         final T[][] data = buildArray(field, getRowDimension(), getColumnDimension());\n \n         for (int i = 0; i < data.length; ++i) {\n         }\n \n         return data;\n-\n     }\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn) {\n-\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n \n         final FieldMatrix<T> subMatrix =\n     }\n \n     /** {@inheritDoc} */\n-    public T[] operate(final T[] v)\n-        throws IllegalArgumentException {\n+    public T[] operate(final T[] v) {\n \n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> operate(final FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public FieldVector<T> operate(final FieldVector<T> v) {\n         try {\n             return new ArrayFieldVector<T>(operate(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public T[] preMultiply(final T[] v)\n-        throws IllegalArgumentException {\n+    public T[] preMultiply(final T[] v) {\n \n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> preMultiply(final FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public FieldVector<T> preMultiply(final FieldVector<T> v) {\n         try {\n             return new ArrayFieldVector<T>(preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n-\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nRows) {\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     }\n \n     /** {@inheritDoc} */\n-    public abstract RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException;\n+    public abstract RealMatrix createMatrix(final int rowDimension, final int columnDimension);\n \n     /** {@inheritDoc} */\n     public abstract RealMatrix copy();\n     public void copySubMatrix(final int startRow, final int endRow,\n                               final int startColumn, final int endColumn,\n                               final double[][] destination) {\n-\n         // safety checks\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         final int rowsCount    = endRow + 1 - startRow;\n \n     /** {@inheritDoc} */\n     public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) {\n-\n         // safety checks\n         MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n         if ((destination.length < selectedRows.length) ||\n     }\n \n     /** {@inheritDoc} */\n-    public double[] operate(final double[] v)\n-        throws IllegalArgumentException {\n-\n+    public double[] operate(final double[] v) {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nCols) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector operate(final RealVector v)\n-        throws IllegalArgumentException {\n+    public RealVector operate(final RealVector v) {\n         try {\n             return new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public double[] preMultiply(final double[] v)\n-        throws IllegalArgumentException {\n+    public double[] preMultiply(final double[] v) {\n \n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector preMultiply(final RealVector v)\n-        throws IllegalArgumentException {\n+    public RealVector preMultiply(final RealVector v) {\n         try {\n             return new ArrayRealVector(preMultiply(((ArrayRealVector) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n \n     /**\n      * Check if instance and specified vectors have the same dimension.\n-     * @param v vector to compare instance with\n-     * @exception IllegalArgumentException if the vectors do not\n-     * have the same dimension\n+     *\n+     * @param v Vector to compare instance with.\n+     * @throws DimensionMismatchException if the vectors do not\n+     * have the same dimension.\n      */\n     protected void checkVectorDimensions(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n     /**\n      * Check if instance dimension is equal to some expected value.\n      *\n-     * @param n expected dimension.\n+     * @param n Expected dimension.\n      * @throws DimensionMismatchException if the dimension is\n-     * inconsistent with vector size\n+     * inconsistent with the vector size.\n      */\n-    protected void checkVectorDimensions(int n)\n-        throws DimensionMismatchException {\n+    protected void checkVectorDimensions(int n) {\n         int d = getDimension();\n         if (d != n) {\n             throw new DimensionMismatchException(d, n);\n             throw new MathUnsupportedOperationException();\n         }\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  */\n-public class Array2DRowFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n-\n+public class Array2DRowFieldMatrix<T extends FieldElement<T>>\n+    extends AbstractFieldMatrix<T>\n+    implements Serializable {\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7260756672015356458L;\n-\n     /** Entries of the matrix */\n     protected T[][] data;\n \n     }\n \n     /**\n-     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n-     *\n-     * @param field field to which the elements belong\n-     * @param rowDimension  the number of rows in the new matrix\n-     * @param columnDimension  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not\n-     *  positive\n+     * Create a new {@code FieldMatrix<T>} with the supplied row and column dimensions.\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param rowDimension Number of rows in the new matrix.\n+     * @param columnDimension Number of columns in the new matrix.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if row or column dimension is not positive.\n      */\n     public Array2DRowFieldMatrix(final Field<T> field,\n-                           final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n+                                 final int rowDimension,\n+                                 final int columnDimension) {\n         super(field, rowDimension, columnDimension);\n         data = buildArray(field, rowDimension, columnDimension);\n     }\n \n     /**\n-     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * Create a new {@code FieldMatrix<T>} using the input array as the underlying\n      * data array.\n      * <p>The input array is copied, not referenced. This constructor has\n      * the same effect as calling {@link #Array2DRowFieldMatrix(FieldElement[][], boolean)}\n-     * with the second argument set to <code>true</code>.</p>\n-     *\n-     * @param d data for new matrix\n-     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if <code>d</code> is null\n+     * with the second argument set to {@code true}.</p>\n+     *\n+     * @param d Data for the new matrix.\n+     * @throws DimensionMismatchException if {@code d} is not rectangular.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * {@code d} is {@code null}.\n+     * @throws NoDataException if there are not at least one row and one column.\n      * @see #Array2DRowFieldMatrix(FieldElement[][], boolean)\n      */\n-    public Array2DRowFieldMatrix(final T[][] d)\n-        throws IllegalArgumentException, NullPointerException {\n+    public Array2DRowFieldMatrix(final T[][] d) {\n         super(extractField(d));\n         copyIn(d);\n     }\n \n     /**\n-     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * Create a new {@code FieldMatrix<T>} using the input array as the underlying\n      * data array.\n      * <p>If an array is built specially in order to be embedded in a\n-     * FieldMatrix<T> and not used directly, the <code>copyArray</code> may be\n-     * set to <code>false</code. This will prevent the copying and improve\n+     * {@code FieldMatrix<T>} and not used directly, the {@code copyArray} may be\n+     * set to {@code false}. This will prevent the copying and improve\n      * performance as no new array will be built and no data will be copied.</p>\n-     * @param d data for new matrix\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n-     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if <code>d</code> is null\n+     *\n+     * @param d Data for the new matrix.\n+     * @param copyArray Whether to copy or reference the input array.\n+     * @throws DimensionMismatchException if {@code d} is not rectangular.\n+     * @throws NoDataException if there are not at least one row and one column.\n+     * @throws org.apache.commons.math.exception.NullArgumentException\n+     * if {@code d} is {@code null}.\n      * @see #Array2DRowFieldMatrix(FieldElement[][])\n      */\n-    public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray)\n-        throws IllegalArgumentException, NullPointerException {\n+    public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray) {\n         super(extractField(d));\n         if (copyArray) {\n             copyIn(d);\n             }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_ROW);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, d[r].length);\n+                    throw new DimensionMismatchException(nCols, d[r].length);\n                 }\n             }\n             data = d;\n     }\n \n     /**\n-     * Create a new (column) FieldMatrix<T> using <code>v</code> as the\n-     * data for the unique column of the <code>v.length x 1</code> matrix\n-     * created.\n-     * <p>The input array is copied, not referenced.</p>\n-     *\n-     * @param v column vector holding data for new matrix\n+     * Create a new (column) {@code FieldMatrix<T>} using {@code v} as the\n+     * data for the unique column of the created matrix.\n+     * The input array is copied.\n+     *\n+     * @param v Column vector holding data for new matrix.\n      */\n     public Array2DRowFieldMatrix(final T[] v) {\n         super(extractField(v));\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension) {\n         return new Array2DRowFieldMatrix<T>(getField(), rowDimension, columnDimension);\n     }\n \n         return new Array2DRowFieldMatrix<T>(copyOut(), false);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> add(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-        try {\n-            return add((Array2DRowFieldMatrix<T>) m);\n-        } catch (ClassCastException cce) {\n-            return super.add(m);\n-        }\n-    }\n-\n-    /**\n-     * Compute the sum of this and <code>m</code>.\n-     *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n-    public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-\n+    /**\n+     * Add {@code m} to this matrix.\n+     *\n+     * @param m Matrix to be added.\n+     * @return {@code this} + m.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n+     */\n+    public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m) {\n         // safety check\n         checkAdditionCompatible(m);\n \n         }\n \n         return new Array2DRowFieldMatrix<T>(outData, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-        try {\n-            return subtract((Array2DRowFieldMatrix<T>) m);\n-        } catch (ClassCastException cce) {\n-            return super.subtract(m);\n-        }\n-    }\n-\n-    /**\n-     * Compute  this minus <code>m</code>.\n-     *\n-     * @param m    matrix to be subtracted\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n-    public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-\n+    }\n+\n+    /**\n+     * Subtract {@code m} from this matrix.\n+     *\n+     * @param m Matrix to be subtracted.\n+     * @return {@code this} + m.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n+     */\n+    public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m) {\n         // safety check\n         checkSubtractionCompatible(m);\n \n \n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-        try {\n-            return multiply((Array2DRowFieldMatrix<T>) m);\n-        } catch (ClassCastException cce) {\n-            return super.multiply(m);\n-        }\n-    }\n-\n-    /**\n-     * Returns the result of postmultiplying this by <code>m</code>.\n-     * @param m    matrix to postmultiply by\n-     * @return     this*m\n-     * @throws     IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n-     */\n-    public Array2DRowFieldMatrix<T> multiply(final Array2DRowFieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-\n+    /**\n+     * Postmultiplying this matrix by {@code m}.\n+     *\n+     * @param m Matrix to postmultiply by.\n+     * @return {@code this} * m.\n+     * @throws DimensionMismatchException if the number of columns of this\n+     * matrix is not equal to the number of rows of {@code m}.\n+     */\n+    public Array2DRowFieldMatrix<T> multiply(final Array2DRowFieldMatrix<T> m) {\n         // safety check\n         checkMultiplicationCompatible(m);\n \n     }\n \n     /**\n-     * Returns a reference to the underlying data array.\n-     * <p>\n-     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n-     *\n-     * @return 2-dimensional array of entries\n+     * Get a reference to the underlying data array.\n+     * This methods returns internal data, <strong>not</strong> fresh copy of it.\n+     *\n+     * @return the 2-dimensional array of entries.\n      */\n     public T[][] getDataRef() {\n         return data;\n     public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n         if (data == null) {\n             if (row > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\n-                      LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n+                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n             }\n             if (column > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\n-                      LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n+                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_ROW);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             data = buildArray(getField(), subMatrix.length, nCols);\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, subMatrix[i].length);\n+                    throw new DimensionMismatchException(nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] operate(final T[] v)\n-        throws IllegalArgumentException {\n+    public T[] operate(final T[] v) {\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nCols);\n+            throw new DimensionMismatchException(v.length, nCols);\n         }\n         final T[] out = buildArray(getField(), nRows);\n         for (int row = 0; row < nRows; row++) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] preMultiply(final T[] v)\n-        throws IllegalArgumentException {\n-\n+    public T[] preMultiply(final T[] v) {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nRows);\n+            throw new DimensionMismatchException(v.length, nRows);\n         }\n \n         final T[] out = buildArray(getField(), nCols);\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /**\n-     * Returns a fresh copy of the underlying data array.\n+     * Get a fresh copy of the underlying data array.\n      *\n      * @return a copy of the underlying data array.\n      */\n     }\n \n     /**\n-     * Replaces data with a fresh copy of the input array.\n-     * <p>\n-     * Verifies that the input array is rectangular and non-empty.</p>\n-     *\n-     * @param in data to copy in\n-     * @throws IllegalArgumentException if input array is empty or not\n-     *    rectangular\n-     * @throws NullPointerException if input array is null\n+     * Replace data with a fresh copy of the input array.\n+     *\n+     * @param in Data to copy.\n+     * @throws NoDataException if the input array is empty.\n+     * @throws DimensionMismatchException if the input array is not rectangular.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * the input array is {@code null}.\n      */\n     private void copyIn(final T[][] in) {\n         setSubMatrix(in, 0, 0);\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n     /**\n      * Create a new RealMatrix with the supplied row and column dimensions.\n      *\n-     * @param rowDimension  the number of rows in the new matrix\n-     * @param columnDimension  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not\n-     *  positive\n-     */\n-    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n+     * @param rowDimension Number of rows in the new matrix.\n+     * @param columnDimension Number of columns in the new matrix.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if the row or column dimension is not positive.\n+     */\n+    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension) {\n         super(rowDimension, columnDimension);\n         data = new double[rowDimension][columnDimension];\n     }\n \n     /**\n-     * Create a new RealMatrix using the input array as the underlying\n+     * Create a new {@code RealMatrix} using the input array as the underlying\n      * data array.\n      * <p>The input array is copied, not referenced. This constructor has\n      * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n-     * with the second argument set to <code>true</code>.</p>\n-     *\n-     * @param d data for new matrix\n-     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if <code>d</code> is null\n+     * with the second argument set to {@code true}.</p>\n+     *\n+     * @param d Data for the new matrix.\n+     * @throws DimensionMismatchException if {@code d} is not rectangular.\n+     * @throws NoDataException if {@code d} row or colum dimension is zero.\n+     * @throws NullPointerException if {@code d} is {@code null}.\n      * @see #Array2DRowRealMatrix(double[][], boolean)\n      */\n-    public Array2DRowRealMatrix(final double[][] d)\n-        throws IllegalArgumentException, NullPointerException {\n+    public Array2DRowRealMatrix(final double[][] d) {\n         copyIn(d);\n     }\n \n      * @throws DimensionMismatchException if {@code d} is not rectangular\n      * (not all rows have the same length) or empty.\n      * @throws NullArgumentException if {@code d} is {@code null}.\n-     * @throws ZeroException if there are not at least one row and one column.\n+     * @throws NoDataException if there are not at least one row and one column.\n      * @see #Array2DRowRealMatrix(double[][])\n      */\n     public Array2DRowRealMatrix(final double[][] d, final boolean copyArray) {\n             }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_ROW);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n \n     /**\n      * Create a new (column) RealMatrix using {@code v} as the\n-     * data for the unique column of the {@code v.length x 1} matrix\n-     * created.\n-     * The input array is copied, not referenced.\n+     * data for the unique column of the created matrix.\n+     * The input array is copied.\n      *\n      * @param v Column vector holding data for new matrix.\n      */\n     }\n \n     /**\n-     * Returns the result of postmultiplying this matrix with {@code m}.\n+     * Postmultiplying this matrix by {@code m}.\n      *\n      * @param m Matrix to postmultiply by.\n      * @return {@code this} * m.\n-     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n-     * if the column dimension of this matrix is different from the row\n-     * dimension of {@code m}.\n+     * @throws DimensionMismatchException if the number of columns of this\n+     * matrix is not equal to the number of rows of {@code m}.\n      */\n     public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m) {\n         // Safety check.\n     }\n \n     /**\n-     * Return a reference to the underlying data array.\n+     * Get a reference to the underlying data array.\n      *\n      * @return 2-dimensional array of entries.\n      */\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_ROW);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n     }\n \n     /**\n-     * Returns a fresh copy of the underlying data array.\n+     * Get a fresh copy of the underlying data array.\n      *\n      * @return a copy of the underlying data array.\n      */\n     }\n \n     /**\n-     * Replaces data with a fresh copy of the input array.\n-     * <p>\n-     * Verifies that the input array is rectangular and non-empty.</p>\n-     *\n-     * @param in data to copy in\n-     * @throws IllegalArgumentException if input array is empty or not\n-     *    rectangular\n-     * @throws NullPointerException if input array is null\n+     * Replace data with a fresh copy of the input array.\n+     *\n+     * @param in Data to copy.\n+     * @throws NoDataException if the input array is empty.\n+     * @throws DimensionMismatchException if the input array is not rectangular.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * the input array is {@code null}.\n      */\n     private void copyIn(final double[][] in) {\n         setSubMatrix(in, 0, 0);\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n      */\n     public ArrayRealVector(ArrayRealVector v1, ArrayRealVector v2) {\n         data = new double[v1.data.length + v2.data.length];\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n      */\n     public ArrayRealVector(ArrayRealVector v1, RealVector v2) {\n         final int l1 = v1.data.length;\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n      */\n     public ArrayRealVector(RealVector v1, ArrayRealVector v2) {\n         final int l1 = v1.getDimension();\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n      */\n     public ArrayRealVector(ArrayRealVector v1, double[] v2) {\n         final int l1 = v1.getDimension();\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n      */\n     public ArrayRealVector(double[] v1, ArrayRealVector v2) {\n         final int l1 = v1.length;\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector add(RealVector v)\n-        throws IllegalArgumentException {\n+    public RealVector add(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return add((ArrayRealVector) v);\n         } else {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector add(double[] v)\n-        throws IllegalArgumentException {\n+    public RealVector add(double[] v) {\n         checkVectorDimensions(v.length);\n         double[] out = data.clone();\n         for (int i = 0; i < data.length; i++) {\n     }\n \n     /**\n-     * Compute the sum of this and v.\n-     * @param v vector to be added\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayRealVector add(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+     * Add {@code v} to this vector.\n+     *\n+     * @param v Vector to be added\n+     * @return {@code this} + v.\n+     * @throws DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n+    public ArrayRealVector add(ArrayRealVector v) {\n         return (ArrayRealVector) add(v.data);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector subtract(RealVector v)\n-        throws IllegalArgumentException {\n+    public RealVector subtract(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return subtract((ArrayRealVector) v);\n         } else {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector subtract(double[] v)\n-        throws IllegalArgumentException {\n+    public RealVector subtract(double[] v) {\n         checkVectorDimensions(v.length);\n         double[] out = data.clone();\n         for (int i = 0; i < data.length; i++) {\n     }\n \n     /**\n-     * Compute this minus v.\n-     * @param v vector to be subtracted\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayRealVector subtract(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+     * Subtract {@code v} from this vector.\n+     *\n+     * @param v Vector to be subtracted.\n+     * @return {@code this} - v.\n+     * @throws DimensionMismatchException if {@code v} is not the\n+     * same size as this vector.\n+     */\n+    public ArrayRealVector subtract(ArrayRealVector v) {\n         return (ArrayRealVector) subtract(v.data);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeMultiply(RealVector v)\n-        throws IllegalArgumentException {\n+    public RealVector ebeMultiply(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return ebeMultiply((ArrayRealVector) v);\n         } else {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector ebeMultiply(double[] v)\n-        throws IllegalArgumentException {\n+    public RealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         double[] out = data.clone();\n         for (int i = 0; i < data.length; i++) {\n \n     /**\n      * Element-by-element multiplication.\n-     * @param v vector by which instance elements must be multiplied\n-     * @return a vector containing this[i] * v[i] for all i\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayRealVector ebeMultiply(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+     * @param v Vector by which instance elements must be multiplied.\n+     * @return a Vector containing {@code this[i] * v[i]} for all {@code i}.\n+     * @exception DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n+    public ArrayRealVector ebeMultiply(ArrayRealVector v) {\n         return (ArrayRealVector) ebeMultiply(v.data);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeDivide(RealVector v)\n-        throws IllegalArgumentException {\n+    public RealVector ebeDivide(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return ebeDivide((ArrayRealVector) v);\n         } else {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector ebeDivide(double[] v)\n-        throws IllegalArgumentException {\n+    public RealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         double[] out = data.clone();\n         for (int i = 0; i < data.length; i++) {\n \n     /**\n      * Element-by-element division.\n-     * @param v vector by which instance elements must be divided\n-     * @return a vector containing this[i] / v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    public ArrayRealVector ebeDivide(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+     *\n+     * @param v Vector by which instance elements must be divided.\n+     * @return a vector containing {@code this[i] / v[i]} for all {@code i}.\n+     * @exception DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n+    public ArrayRealVector ebeDivide(ArrayRealVector v) {\n         return (ArrayRealVector) ebeDivide(v.data);\n     }\n \n     }\n \n     /**\n-     * Returns a reference to the underlying data array.\n-     * <p>Does not make a fresh copy of the underlying data.</p>\n-     * @return array of entries\n+     * Get a reference to the underlying data array.\n+     * This method does not make a fresh copy of the underlying data.\n+     *\n+     * @return the array of entries.\n      */\n     public double[] getDataRef() {\n         return data;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double dotProduct(RealVector v)\n-        throws IllegalArgumentException {\n+    public double dotProduct(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return dotProduct((ArrayRealVector) v);\n         } else {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double dotProduct(double[] v)\n-        throws IllegalArgumentException {\n+    public double dotProduct(double[] v) {\n         checkVectorDimensions(v.length);\n         double dot = 0;\n         for (int i = 0; i < data.length; i++) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getDistance(RealVector v)\n-        throws IllegalArgumentException {\n+    public double getDistance(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return getDistance((ArrayRealVector) v);\n         } else {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getDistance(double[] v)\n-        throws IllegalArgumentException {\n+    public double getDistance(double[] v) {\n         checkVectorDimensions(v.length);\n         double sum = 0;\n         for (int i = 0; i < data.length; ++i) {\n      * L<sub>2</sub> norm, i.e. the square root of the sum of\n      * elements differences, or euclidian distance.\n      *\n-     * @param v vector to which distance is requested\n+     * @param v Vector to which distance is requested.\n      * @return the distance between two vectors.\n      * @throws DimensionMismatchException if {@code v} is not the same size as\n      * this vector.\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getL1Distance(double[] v)\n-        throws IllegalArgumentException {\n+    public double getL1Distance(double[] v) {\n         checkVectorDimensions(v.length);\n         double sum = 0;\n         for (int i = 0; i < data.length; ++i) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getLInfDistance(double[] v)\n-        throws IllegalArgumentException {\n+    public double getLInfDistance(double[] v) {\n         checkVectorDimensions(v.length);\n         double max = 0;\n         for (int i = 0; i < data.length; ++i) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix outerProduct(RealVector v)\n-        throws IllegalArgumentException {\n+    public RealMatrix outerProduct(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return outerProduct((ArrayRealVector) v);\n         } else {\n \n     /**\n      * Compute the outer product.\n-     * @param v vector with which outer product should be computed\n-     * @return the square matrix outer product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    public RealMatrix outerProduct(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+     * @param v Vector with which outer product should be computed.\n+     * @return the square matrix outer product between this instance and {@code v}.\n+     * @throws DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n+    public RealMatrix outerProduct(ArrayRealVector v) {\n         return outerProduct(v.data);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix outerProduct(double[] v)\n-        throws IllegalArgumentException {\n+    public RealMatrix outerProduct(double[] v) {\n         checkVectorDimensions(v.length);\n         final int m = data.length;\n         final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n                 set(index, (ArrayRealVector) v);\n             } catch (ClassCastException cce) {\n                 for (int i = index; i < index + v.getDimension(); ++i) {\n-                    data[i] = v.getEntry(i-index);\n+                    data[i] = v.getEntry(i - index);\n                 }\n             }\n         } catch (IndexOutOfBoundsException e) {\n      * @param index Index of first element to be set.\n      * @param v Vector containing the values to set.\n      * @throws org.apache.commons.math.exception.OutOfRangeException\n-     * if the index is inconsistent with vector size.\n+     * if the index is inconsistent with the vector size.\n      */\n     public void set(int index, ArrayRealVector v) {\n         setSubVector(index, v.data);\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m) {\n         try {\n             return subtract((BlockFieldMatrix<T>) m);\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] operate(final T[] v)\n-        throws IllegalArgumentException {\n-\n+    public T[] operate(final T[] v) {\n         if (v.length != columns) {\n             throw new DimensionMismatchException(v.length, columns);\n         }\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] preMultiply(final T[] v)\n-        throws IllegalArgumentException {\n+    public T[] preMultiply(final T[] v) {\n \n         if (v.length != rows) {\n             throw new DimensionMismatchException(v.length, rows);\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n      *\n      * @param rows  the number of rows in the new matrix\n      * @param columns  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not\n-     * positive.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if row or column dimension is not positive.\n      */\n     public BlockRealMatrix(final int rows, final int columns) {\n         super(rows, columns);\n      * <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,\n      *                                   toBlocksLayout(rawData), false);</pre>\n      * </p>\n+     *\n      * @param rawData data for new matrix, in raw layout\n-     *\n-     * @exception IllegalArgumentException if <code>blockData</code> shape is\n-     * inconsistent with block layout\n+     * @throws DimensionMismatchException if the shape of {@code blockData} is\n+     * inconsistent with block layout.\n      * @see #BlockRealMatrix(int, int, double[][], boolean)\n      */\n-    public BlockRealMatrix(final double[][] rawData)\n-        throws IllegalArgumentException {\n+    public BlockRealMatrix(final double[][] rawData) {\n         this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n     }\n \n     /**\n      * Create a new dense matrix copying entries from block layout data.\n      * <p>The input array <em>must</em> already be in blocks layout.</p>\n-     * @param rows  the number of rows in the new matrix\n-     * @param columns  the number of columns in the new matrix\n+     *\n+     * @param rows Number of rows in the new matrix.\n+     * @param columns Number of columns in the new matrix.\n      * @param blockData data for new matrix\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n-     *\n-     * @exception IllegalArgumentException if <code>blockData</code> shape is\n-     * inconsistent with block layout\n+     * @param copyArray Whether the input array will be copied or referenced.\n+     * @throws DimensionMismatchException if the shape of {@code blockData} is\n+     * inconsistent with block layout.\n      * @see #createBlocksLayout(int, int)\n      * @see #toBlocksLayout(double[][])\n      * @see #BlockRealMatrix(double[][])\n      * It can be used to provide the array argument of the {@link\n      * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n      * </p>\n-     * @param rawData data array in raw layout\n-     * @return a new data array containing the same entries but in blocks layout\n-     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n-     *  (not all rows have the same length)\n+     * @param rawData Data array in raw layout.\n+     * @return a new data array containing the same entries but in blocks layout.\n+     * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n      * @see #createBlocksLayout(int, int)\n      * @see #BlockRealMatrix(int, int, double[][], boolean)\n      */\n      * This method can be used to create the array argument of the {@link\n      * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n      * </p>\n-     * @param rows  the number of rows in the new matrix\n-     * @param columns  the number of columns in the new matrix\n-     * @return a new data array in blocks layout\n+     * @param rows Number of rows in the new matrix.\n+     * @param columns Number of columns in the new matrix.\n+     * @return a new data array in blocks layout.\n      * @see #toBlocksLayout(double[][])\n      * @see #BlockRealMatrix(int, int, double[][], boolean)\n      */\n--- a/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Default implementation of the {@link FieldMatrixChangingVisitor} interface.\n  */\n public class DefaultFieldMatrixChangingVisitor<T extends FieldElement<T>>\n     implements FieldMatrixChangingVisitor<T> {\n-\n     /** Zero element of the field. */\n     private final T zero;\n \n     public T end() {\n         return zero;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Default implementation of the {@link FieldMatrixPreservingVisitor} interface.\n  */\n public class DefaultFieldMatrixPreservingVisitor<T extends FieldElement<T>>\n     implements FieldMatrixPreservingVisitor<T> {\n-\n     /** Zero element of the field. */\n     private final T zero;\n \n     public T end() {\n         return zero;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixChangingVisitor.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * Default implementation of the {@link RealMatrixChangingVisitor} interface.\n  * <p>\n  * @since 2.0\n  */\n public class DefaultRealMatrixChangingVisitor implements RealMatrixChangingVisitor {\n-\n     /** {@inheritDoc} */\n     public void start(int rows, int columns,\n                       int startRow, int endRow, int startColumn, int endColumn) {\n     public double end() {\n         return 0;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * Default implementation of the {@link RealMatrixPreservingVisitor} interface.\n  * <p>\n  * @since 2.0\n  */\n public class DefaultRealMatrixPreservingVisitor implements RealMatrixPreservingVisitor {\n-\n     /** {@inheritDoc} */\n     public void start(int rows, int columns,\n                       int startRow, int endRow, int startColumn, int endColumn) {\n     public double end() {\n         return 0;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining field-valued matrix with basic algebraic operations.\n  * @version $Revision$ $Date$\n  */\n public interface FieldMatrix<T extends FieldElement<T>> extends AnyMatrix {\n-\n     /**\n      * Get the type of field elements of the matrix.\n      *\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining a visitor for matrix entries.\n  * @since 2.0\n  */\n public interface FieldMatrixChangingVisitor<T extends FieldElement<?>> {\n-\n     /**\n      * Start visiting a matrix.\n      * <p>This method is called once before any entry of the matrix is visited.</p>\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * Interface defining a visitor for matrix entries.\n  * @since 2.0\n  */\n public interface FieldMatrixPreservingVisitor<T extends FieldElement<?>> {\n-\n     /**\n      * Start visiting a matrix.\n      * <p>This method is called once before any entry of the matrix is visited.</p>\n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.fraction.Fraction;\n      * @return  RealMatrix containing the values of the array\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if {@code data} is not rectangular (not all rows have the same length).\n-     * @throws ZeroException if a row or column is empty.\n+     * @throws NoDataException if a row or column is empty.\n      * @throws NullArgumentException if either {@code data} or {@code data[0]}\n      * is {@code null}.\n      * @see #createRealMatrix(int, int)\n      * @return a matrix containing the values of the array.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if {@code data} is not rectangular (not all rows have the same length).\n-     * @throws ZeroException if a row or column is empty.\n+     * @throws NoDataException if a row or column is empty.\n      * @throws NullArgumentException if either {@code data} or {@code data[0]}\n      * is {@code null}.\n      * @see #createFieldMatrix(Field, int, int)\n      *\n      * @param data the input data\n      * @return a data.length RealVector\n-     * @throws ZeroException if {@code data} is empty.\n+     * @throws NoDataException if {@code data} is empty.\n      * @throws NullArgumentException if {@code data} is {@code null}.\n      */\n     public static RealVector createRealVector(double[] data) {\n      * @param <T> the type of the field elements\n      * @param data the input data\n      * @return a data.length FieldVector\n-     * @throws ZeroException if {@code data} is empty.\n+     * @throws NoDataException if {@code data} is empty.\n      * @throws NullArgumentException if {@code data} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n      *\n      * @param rowData the input row data\n      * @return a 1 x rowData.length RealMatrix\n-     * @throws ZeroException if {@code rowData} is empty.\n+     * @throws NoDataException if {@code rowData} is empty.\n      * @throws NullArgumentException if {@code rowData} is {@code null}.\n      */\n     public static RealMatrix createRowRealMatrix(double[] rowData) {\n      * @param <T> the type of the field elements\n      * @param rowData the input row data\n      * @return a 1 x rowData.length FieldMatrix\n-     * @throws ZeroException if {@code rowData} is empty.\n+     * @throws NoDataException if {@code rowData} is empty.\n      * @throws NullArgumentException if {@code rowData} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T>\n         }\n         final int nCols = rowData.length;\n         if (nCols == 0) {\n-            throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n         for (int i = 0; i < nCols; ++i) {\n      *\n      * @param columnData  the input column data\n      * @return a columnData x 1 RealMatrix\n-     * @throws ZeroException if {@code columnData} is empty.\n+     * @throws NoDataException if {@code columnData} is empty.\n      * @throws NullArgumentException if {@code columnData} is {@code null}.\n      */\n     public static RealMatrix createColumnRealMatrix(double[] columnData) {\n      * @param <T> the type of the field elements\n      * @param columnData  the input column data\n      * @return a columnData x 1 FieldMatrix\n-     * @throws ZeroException if {@code data} is empty.\n+     * @throws NoDataException if {@code data} is empty.\n      * @throws NullArgumentException if {@code columnData} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T>\n         }\n         final int nRows = columnData.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n         final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n         for (int i = 0; i < nRows; ++i) {\n      * @param selectedColumns Array of column indices.\n      * @throws NullArgumentException if {@code selectedRows} or\n      * {@code selectedColumns} are {@code null}.\n-     * @throws ZeroException if the row or column selections are empty (zero\n+     * @throws NoDataException if the row or column selections are empty (zero\n      * length).\n      * @throws OutOfRangeException if row or column selections are not valid.\n      */\n             throw new NullArgumentException();\n         }\n         if (selectedRows.length == 0) {\n-            throw new ZeroException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n+            throw new NoDataException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n         }\n         if (selectedColumns.length == 0) {\n-            throw new ZeroException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n+            throw new NoDataException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n         }\n \n         for (final int row : selectedRows) {\n     }\n \n     /**\n-     * Check if matrices are addition compatible\n-     * @param left left hand side matrix\n-     * @param right right hand side matrix\n-     * @exception IllegalArgumentException if matrices are not addition compatible\n-     */\n-    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n-        throws IllegalArgumentException {\n+     * Check if matrices are addition compatible.\n+     *\n+     * @param left Left hand side matrix.\n+     * @param right Right hand side matrix.\n+     * @throws MatrixDimensionMismatchException if the matrices are not addition compatible.\n+     */\n+    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right) {\n         if ((left.getRowDimension()    != right.getRowDimension()) ||\n             (left.getColumnDimension() != right.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_ADDITION_COMPATIBLE_MATRICES,\n-                    left.getRowDimension(), left.getColumnDimension(),\n-                    right.getRowDimension(), right.getColumnDimension());\n+            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n+                                                       right.getRowDimension(), right.getColumnDimension());\n         }\n     }\n \n     /**\n      * Check if matrices are subtraction compatible\n-     * @param left left hand side matrix\n-     * @param right right hand side matrix\n-     * @exception IllegalArgumentException if matrices are not subtraction compatible\n-     */\n-    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n-        throws IllegalArgumentException {\n+     *\n+     * @param left Left hand side matrix.\n+     * @param right Right hand side matrix.\n+     * @throws MatrixDimensionMismatchException if the matrices are not addition compatible.\n+     */\n+    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right) {\n         if ((left.getRowDimension()    != right.getRowDimension()) ||\n             (left.getColumnDimension() != right.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_SUBTRACTION_COMPATIBLE_MATRICES,\n-                    left.getRowDimension(), left.getColumnDimension(),\n-                    right.getRowDimension(), right.getColumnDimension());\n+            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n+                                                       right.getRowDimension(), right.getColumnDimension());\n         }\n     }\n \n     /**\n      * Check if matrices are multiplication compatible\n-     * @param left left hand side matrix\n-     * @param right right hand side matrix\n-     * @exception IllegalArgumentException if matrices are not multiplication compatible\n-     */\n-    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n-        throws IllegalArgumentException {\n+     *\n+     * @param left Left hand side matrix.\n+     * @param right Right hand side matrix.\n+     * @throws DimensionMismatchException if matrices are not multiplication compatible.\n+     */\n+    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right) {\n         if (left.getColumnDimension() != right.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_MULTIPLICATION_COMPATIBLE_MATRICES,\n-                    left.getRowDimension(), left.getColumnDimension(),\n-                    right.getRowDimension(), right.getColumnDimension());\n+            throw new DimensionMismatchException(left.getColumnDimension(),\n+                                                 right.getRowDimension());\n         }\n     }\n \n     /**\n      * Convert a {@link FieldMatrix}/{@link Fraction} matrix to a {@link RealMatrix}.\n-     * @param m matrix to convert\n-     * @return converted matrix\n+     * @param m Matrix to convert.\n+     * @return the converted matrix.\n      */\n     public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m) {\n         final FractionMatrixConverter converter = new FractionMatrixConverter();\n \n     /** Converter for {@link FieldMatrix}/{@link Fraction}. */\n     private static class FractionMatrixConverter extends DefaultFieldMatrixPreservingVisitor<Fraction> {\n-\n         /** Converted array. */\n         private double[][] data;\n-\n         /** Simple constructor. */\n         public FractionMatrixConverter() {\n             super(Fraction.ZERO);\n             data[row][column] = value.doubleValue();\n         }\n \n-        /** Get the converted matrix.\n-         * @return converted matrix\n+        /**\n+         * Get the converted matrix.\n+         *\n+         * @return the converted matrix.\n          */\n         Array2DRowRealMatrix getConvertedMatrix() {\n             return new Array2DRowRealMatrix(data, false);\n \n     /**\n      * Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.\n-     * @param m matrix to convert\n-     * @return converted matrix\n+     *\n+     * @param m Matrix to convert.\n+     * @return the converted matrix.\n      */\n     public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n         final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n \n     /** Converter for {@link FieldMatrix}/{@link BigFraction}. */\n     private static class BigFractionMatrixConverter extends DefaultFieldMatrixPreservingVisitor<BigFraction> {\n-\n         /** Converted array. */\n         private double[][] data;\n-\n         /** Simple constructor. */\n         public BigFractionMatrixConverter() {\n             super(BigFraction.ZERO);\n             data[row][column] = value.doubleValue();\n         }\n \n-        /** Get the converted matrix.\n-         * @return converted matrix\n+        /**\n+         * Get the converted matrix.\n+         *\n+         * @return the converted matrix.\n          */\n         Array2DRowRealMatrix getConvertedMatrix() {\n             return new Array2DRowRealMatrix(data, false);\n         }\n-\n     }\n \n     /** Serialize a {@link RealVector}.\n             ioe.initCause(iae);\n             throw ioe;\n         }\n-\n-    }\n-\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealMatrix subtract(final RealMatrix m)\n-        throws IllegalArgumentException {\n+    public OpenMapRealMatrix subtract(final RealMatrix m) {\n         try {\n             return subtract((OpenMapRealMatrix) m);\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix multiply(final RealMatrix m)\n-        throws IllegalArgumentException {\n+    public RealMatrix multiply(final RealMatrix m) {\n         try {\n             return multiply((OpenMapRealMatrix) m);\n         } catch (ClassCastException cce) {\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n-\n /**\n  * Interface defining a real-valued matrix with basic algebraic operations.\n  * <p>\n  * @version $Revision$ $Date$\n  */\n public interface RealMatrix extends AnyMatrix {\n-\n     /**\n      * Create a new RealMatrix of the same type as the instance with the supplied\n      * row and column dimensions.\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * Interface defining a visitor for matrix entries.\n  *\n  * @since 2.0\n  */\n public interface RealMatrixChangingVisitor {\n-\n     /**\n      * Start visiting a matrix.\n      * <p>This method is called once before any entry of the matrix is visited.</p>\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.exception.MathUserException;\n-\n /**\n  * Interface defining a visitor for matrix entries.\n  *\n  * @since 2.0\n  */\n public interface RealMatrixPreservingVisitor {\n-\n     /**\n      * Start visiting a matrix.\n      * <p>This method is called once before any entry of the matrix is visited.</p>\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n      * @exception IllegalArgumentException if minSingularValue is larger than\n      * the largest singular value, meaning all singular values are ignored\n      */\n-    RealMatrix getCovariance(double minSingularValue) throws IllegalArgumentException;\n+    RealMatrix getCovariance(double minSingularValue);\n \n     /**\n      * Returns the L<sub>2</sub> norm of the matrix.\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class SingularValueDecompositionImpl implements\n-        SingularValueDecomposition {\n-\n+public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n     /** Number of rows of the initial matrix. */\n     private int m;\n-\n     /** Number of columns of the initial matrix. */\n     private int n;\n-\n     /** Eigen decomposition of the tridiagonal matrix. */\n     private EigenDecomposition eigenDecomposition;\n-\n     /** Singular values. */\n     private double[] singularValues;\n-\n     /** Cached value of U. */\n     private RealMatrix cachedU;\n-\n     /** Cached value of U<sup>T</sup>. */\n     private RealMatrix cachedUt;\n-\n     /** Cached value of S. */\n     private RealMatrix cachedS;\n-\n     /** Cached value of V. */\n     private RealMatrix cachedV;\n-\n     /** Cached value of V<sup>T</sup>. */\n     private RealMatrix cachedVt;\n \n     /**\n      * Calculates the compact Singular Value Decomposition of the given matrix.\n+     *\n      * @param matrix Matrix to decompose.\n      */\n     public SingularValueDecompositionImpl(final RealMatrix matrix) {\n                 for (int k = 0; k < m; k++) {\n                     matATA[i][j] += localcopy[k][i] * localcopy[k][j];\n                 }\n-                matATA[j][i]=matATA[i][j];\n+                matATA[j][i] = matATA[i][j];\n             }\n         }\n \n                 for (int k = 0; k < n; k++) {\n                     matAAT[i][j] += localcopy[i][k] * localcopy[j][k];\n                 }\n-                 matAAT[j][i]=matAAT[i][j];\n+                 matAAT[j][i] = matAAT[i][j];\n             }\n         }\n         int p;\n-        if (m>=n) {\n-            p=n;\n+        if (m >= n) {\n+            p = n;\n             // compute eigen decomposition of A^T*A\n-            eigenDecomposition = new EigenDecompositionImpl(\n-                    new Array2DRowRealMatrix(matATA),1.0);\n+            eigenDecomposition\n+                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n             singularValues = eigenDecomposition.getRealEigenvalues();\n             cachedV = eigenDecomposition.getV();\n             // compute eigen decomposition of A*A^T\n-            eigenDecomposition = new EigenDecompositionImpl(\n-                    new Array2DRowRealMatrix(matAAT),1.0);\n+            eigenDecomposition\n+                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n             cachedU = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n         } else {\n-            p=m;\n+            p = m;\n             // compute eigen decomposition of A*A^T\n-            eigenDecomposition = new EigenDecompositionImpl(\n-                    new Array2DRowRealMatrix(matAAT),1.0);\n+            eigenDecomposition\n+                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n             singularValues = eigenDecomposition.getRealEigenvalues();\n             cachedU = eigenDecomposition.getV();\n \n             // compute eigen decomposition of A^T*A\n-            eigenDecomposition = new EigenDecompositionImpl(\n-                    new Array2DRowRealMatrix(matATA),1.0);\n-            cachedV = eigenDecomposition.getV().getSubMatrix(0,n-1,0,p-1);\n+            eigenDecomposition\n+                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n+            cachedV = eigenDecomposition.getV().getSubMatrix(0, n - 1 , 0, p - 1);\n         }\n         for (int i = 0; i < p; i++) {\n             singularValues[i] = FastMath.sqrt(FastMath.abs(singularValues[i]));\n         // The sign is set such that A.V_i=sigma_i.U_i (i<=p)\n         // The right sign corresponds to a positive dot product of A.V_i and U_i\n         for (int i = 0; i < p; i++) {\n-          RealVector tmp = cachedU.getColumnVector(i);\n-          double product=matrix.operate(cachedV.getColumnVector(i)).dotProduct(tmp);\n-          if (product<0) {\n-            cachedU.setColumnVector(i, tmp.mapMultiply(-1.0));\n-          }\n+            RealVector tmp = cachedU.getColumnVector(i);\n+            double product=matrix.operate(cachedV.getColumnVector(i)).dotProduct(tmp);\n+            if (product < 0) {\n+                cachedU.setColumnVector(i, tmp.mapMultiply(-1));\n+            }\n         }\n     }\n \n \n     /** {@inheritDoc} */\n     public RealMatrix getUT() {\n-\n         if (cachedUt == null) {\n             cachedUt = getU().transpose();\n         }\n-\n         // return the cached matrix\n         return cachedUt;\n-\n     }\n \n     /** {@inheritDoc} */\n     public RealMatrix getS() {\n-\n         if (cachedS == null) {\n-\n             // cache the matrix for subsequent calls\n             cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n-\n         }\n         return cachedS;\n     }\n     public RealMatrix getV() {\n         // return the cached matrix\n         return cachedV;\n-\n     }\n \n     /** {@inheritDoc} */\n     public RealMatrix getVT() {\n-\n         if (cachedVt == null) {\n             cachedVt = getV().transpose();\n         }\n-\n         // return the cached matrix\n         return cachedVt;\n-\n     }\n \n     /** {@inheritDoc} */\n     public RealMatrix getCovariance(final double minSingularValue) {\n-\n         // get the number of singular values to consider\n         final int p = singularValues.length;\n         int dimension = 0;\n \n         RealMatrix jv = new Array2DRowRealMatrix(data, false);\n         return jv.transpose().multiply(jv);\n-\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public int getRank() throws IllegalStateException {\n-\n+    public int getRank() {\n         final double threshold = FastMath.max(m, n) * FastMath.ulp(singularValues[0]);\n \n         for (int i = singularValues.length - 1; i >= 0; --i) {\n             }\n         }\n         return 0;\n-\n     }\n \n     /** {@inheritDoc} */\n     public DecompositionSolver getSolver() {\n-        return new Solver(singularValues, getUT(), getV(), getRank() == Math\n-                .max(m, n));\n+        return new Solver(singularValues, getUT(), getV(), getRank() == Math.max(m, n));\n     }\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-\n         /** Pseudo-inverse of the initial matrix. */\n         private final RealMatrix pseudoInverse;\n-\n         /** Singularity indicator. */\n         private boolean nonSingular;\n \n         /**\n          * Build a solver from decomposed matrix.\n-         * @param singularValues\n-         *            singularValues\n-         * @param uT\n-         *            U<sup>T</sup> matrix of the decomposition\n-         * @param v\n-         *            V matrix of the decomposition\n-         * @param nonSingular\n-         *            singularity indicator\n+         *\n+         * @param singularValues Singular values.\n+         * @param uT U<sup>T</sup> matrix of the decomposition.\n+         * @param v V matrix of the decomposition.\n+         * @param nonSingular Singularity indicator.\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT,\n-                final RealMatrix v, final boolean nonSingular) {\n+                       final RealMatrix v, final boolean nonSingular) {\n             double[][] suT = uT.getData();\n             for (int i = 0; i < singularValues.length; ++i) {\n                 final double a;\n-                if (singularValues[i]>0) {\n-                 a=1.0 / singularValues[i];\n+                if (singularValues[i] > 0) {\n+                 a = 1 / singularValues[i];\n                 } else {\n-                 a=0.0;\n+                 a = 0;\n                 }\n                 final double[] suTi = suT[i];\n                 for (int j = 0; j < suTi.length; ++j) {\n          * The m&times;n matrix A may not be square, the solution X is such that\n          * ||A &times; X - B|| is minimal.\n          * </p>\n-         * @param b\n-         *            right-hand side of the equation A &times; X = B\n+         * @param b Right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n-         * @exception IllegalArgumentException\n-         *                if matrices dimensions don't match\n-         */\n-        public double[] solve(final double[] b) throws IllegalArgumentException {\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         */\n+        public double[] solve(final double[] b) {\n             return pseudoInverse.operate(b);\n         }\n \n          * The m&times;n matrix A may not be square, the solution X is such that\n          * ||A &times; X - B|| is minimal.\n          * </p>\n-         * @param b\n-         *            right-hand side of the equation A &times; X = B\n+         * @param b Right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n-         * @exception IllegalArgumentException\n-         *                if matrices dimensions don't match\n-         */\n-        public RealVector solve(final RealVector b)\n-                throws IllegalArgumentException {\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         */\n+        public RealVector solve(final RealVector b) {\n             return pseudoInverse.operate(b);\n         }\n \n          * The m&times;n matrix A may not be square, the solution X is such that\n          * ||A &times; X - B|| is minimal.\n          * </p>\n-         * @param b\n-         *            right-hand side of the equation A &times; X = B\n+         *\n+         * @param b Right-hand side of the equation A &times; X = B\n          * @return a matrix X that minimizes the two norm of A &times; X - B\n-         * @exception IllegalArgumentException\n-         *                if matrices dimensions don't match\n-         */\n-        public RealMatrix solve(final RealMatrix b)\n-                throws IllegalArgumentException {\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         */\n+        public RealMatrix solve(final RealMatrix b) {\n             return pseudoInverse.multiply(b);\n         }\n \n         /**\n          * Check if the decomposed matrix is non-singular.\n-         * @return true if the decomposed matrix is non-singular\n+         *\n+         * @return {@code true} if the decomposed matrix is non-singular.\n          */\n         public boolean isNonSingular() {\n             return nonSingular;\n \n         /**\n          * Get the pseudo-inverse of the decomposed matrix.\n-         * @return inverse matrix\n+         *\n+         * @return the inverse matrix.\n          */\n         public RealMatrix getInverse() {\n             return pseudoInverse;\n         }\n-\n-    }\n-\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n \n             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n             assertEquals(new Array2DRowRealMatrix(reference), sub);\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n             if (!mustFail) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n             assertEquals(new Array2DRowRealMatrix(reference), sub);\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n             if (!mustFail) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n             if (!mustFail) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n             if (mustFail) {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (!mustFail) {\n             if (!mustFail) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n \n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n             if (reference != null) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallExceptiono r ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallExceptiono r NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n             if (reference != null) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n             if (reference != null) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n             }\n         } catch (OutOfRangeException e) {\n             if (reference != null) {\n             if (reference != null) {\n                 throw e;\n             }\n-        } catch (ZeroException e) {\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.OutOfRangeException;\n-import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NonSquareMatrixException;\n \n         }\n         try {\n             m.getSubMatrix(new int[] {}, new int[] { 0 });\n-            fail(\"Expecting ZeroException\");\n-        } catch (ZeroException ex) {\n+            fail(\"Expecting NoDataException\");\n+        } catch (NoDataException ex) {\n             // expected\n         }\n         try {", "timestamp": 1290559332, "metainfo": ""}