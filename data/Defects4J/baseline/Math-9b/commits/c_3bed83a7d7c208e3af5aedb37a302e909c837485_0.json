{"sha": "3bed83a7d7c208e3af5aedb37a302e909c837485", "log": "Changed o.a.c.m3.linear.SymmLQ according to MATH-771.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n  * <p>\n  * Preconditioning may reduce the number of iterations required. The solver may\n  * be provided with a positive definite preconditioner\n- * M = C &middot; C<sup>T</sup>\n+ * M = P<sup>T</sup> &middot; P\n  * that is known to approximate\n- * (A - shift &middot; I) in some sense, where systems of the form\n- * M &middot; y = x\n- * can be solved efficiently. Then SYMMLQ will implicitly solve the system of\n- * equations\n+ * (A - shift &middot; I)<sup>-1</sup> in some sense, where matrix-vector\n+ * products of the form M &middot; y = x can be computed efficiently. Then\n+ * SYMMLQ will implicitly solve the system of equations\n  * P &middot; (A - shift &middot; I) &middot; P<sup>T</sup> &middot;\n  * x<sub>hat</sub> = P &middot; b, i.e.\n  * A<sub>hat</sub> &middot; x<sub>hat</sub> = b<sub>hat</sub>,\n- * where P = C<sup>-1</sup>,\n+ * where\n  * A<sub>hat</sub> = P &middot; (A - shift &middot; I) &middot; P<sup>T</sup>,\n  * b<sub>hat</sub> = P &middot; b,\n  * and return the solution\n  * </p>\n  * <p>\n  * In the case of preconditioning, the {@link IterativeLinearSolverEvent}s that\n- * this solver throws are such that\n+ * this solver fires are such that\n  * {@link IterativeLinearSolverEvent#getNormOfResidual()} returns the norm of\n  * the <em>preconditioned</em>, updated residual, ||P &middot; r||, not the norm\n  * of the <em>true</em> residual ||r||.\n      *                      = P * (A - shift * I) * P' * v[k] - alpha[k] * v[k]\n      *                        - beta[k] * v[k-1]\n      * Multiplying both sides by P', we get\n-     *   beta[k+1] * (P' * v)[k+1] = M^(-1) * (A - shift * I) * (P' * v)[k]\n+     *   beta[k+1] * (P' * v)[k+1] = M * (A - shift * I) * (P' * v)[k]\n      *                               - alpha[k] * (P' * v)[k]\n      *                               - beta[k] * (P' * v[k-1]),\n      * and\n      * In other words, the Lanczos iterations are unchanged, except for the fact\n      * that we really compute (P' * v) instead of v. It can easily be checked\n      * that all other formulas are unchanged. It must be noted that P is never\n-     * explicitly used, only matrix-vector products involving M^(-1) are\n-     * invoked.\n+     * explicitly used, only matrix-vector products involving are invoked.\n      *\n      * 2. Accounting for the shift parameter\n      *    ----------------------------------\n         /** The estimate of the norm of P * rL[k-1]. */\n         private double lqnorm;\n \n-        /** Reference to the inverse of the preconditioner, M<sup>-1</sup>. */\n-        private final RealLinearOperator minv;\n+        /** Reference to the preconditioner, M. */\n+        private final RealLinearOperator m;\n \n         /**\n          * The value of (-eps[k+1] * zeta[k-1]). Was called {@code rhs2} in the\n          */\n         private double minusEpsZeta;\n \n-        /** The value of M^(-1) * b. */\n-        private final RealVector minvb;\n+        /** The value of M * b. */\n+        private final RealVector mb;\n \n         /** The value of beta[k]. */\n         private double oldb;\n \n-        /** The value of beta[k] * M * P' * v[k]. */\n+        /** The value of beta[k] * M^(-1) * P' * v[k]. */\n         private RealVector r1;\n \n-        /** The value of beta[k+1] * M * P' * v[k+1]. */\n+        /** The value of beta[k+1] * M^(-1) * P' * v[k+1]. */\n         private RealVector r2;\n \n         /**\n          * Creates and inits to k = 1 a new instance of this class.\n          *\n          * @param a the linear operator A of the system\n-         * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n-         * (can be {@code null})\n+         * @param m the preconditioner, M (can be {@code null})\n          * @param b the right-hand side vector\n          * @param goodb usually {@code false}, except if {@code x} is expected\n          * to contain a large multiple of {@code b}\n          * preconditioner should be checked\n          */\n         public State(final RealLinearOperator a,\n-            final RealLinearOperator minv,\n+            final RealLinearOperator m,\n             final RealVector b,\n             final boolean goodb,\n             final double shift,\n             final double delta,\n             final boolean check) {\n             this.a = a;\n-            this.minv = minv;\n+            this.m = m;\n             this.b = b;\n             this.xL = new ArrayRealVector(b.getDimension());\n             this.goodb = goodb;\n             this.shift = shift;\n-            this.minvb = minv == null ? b : minv.operate(b);\n+            this.mb = m == null ? b : m.operate(b);\n             this.hasConverged = false;\n             this.check = check;\n             this.delta = delta;\n                 } else {\n                     final double step = bstep / beta1;\n                     for (int i = 0; i < n; i++) {\n-                        final double bi = minvb.getEntry(i);\n+                        final double bi = mb.getEntry(i);\n                         final double xi = this.xL.getEntry(i);\n                         x.setEntry(i, xi + step * bi);\n                     }\n                     for (int i = 0; i < n; i++) {\n                         final double xi = this.xL.getEntry(i);\n                         final double wi = wbar.getEntry(i);\n-                        final double bi = minvb.getEntry(i);\n+                        final double bi = mb.getEntry(i);\n                         x.setEntry(i, xi + zbar * wi + step * bi);\n                     }\n                 }\n              * if b = 0.\n              */\n             this.r1 = this.b.copy();\n-            this.y = this.minv == null ? this.b.copy() : this.minv.operate(this.r1);\n-            if ((this.minv != null) && this.check) {\n-                checkSymmetry(this.minv, this.r1, this.y, this.minv.operate(this.y));\n+            this.y = this.m == null ? this.b.copy() : this.m.operate(this.r1);\n+            if ((this.m != null) && this.check) {\n+                checkSymmetry(this.m, this.r1, this.y, this.m.operate(this.y));\n             }\n \n             this.beta1 = this.r1.dotProduct(this.y);\n             if (this.beta1 < 0.) {\n-                throwNPDLOException(this.minv, this.y);\n+                throwNPDLOException(this.m, this.y);\n             }\n             if (this.beta1 == 0.) {\n                 /* If b = 0 exactly, stop with x = 0. */\n             this.beta1 = FastMath.sqrt(this.beta1);\n             /* At this point\n              *   r1 = b,\n-             *   y = M^(-1) * b,\n+             *   y = M * b,\n              *   beta1 = beta[1].\n              */\n             final RealVector v = this.y.mapMultiply(1. / this.beta1);\n             /*\n              * At this point\n              *   alpha = alpha[1]\n-             *   y     = beta[2] * M * P' * v[2]\n+             *   y     = beta[2] * M^(-1) * P' * v[2]\n              */\n             /* Make sure r2 will be orthogonal to the first v. */\n             final double vty = v.dotProduct(this.y);\n             final double vtv = v.dotProduct(v);\n             daxpy(-vty / vtv, v, this.y);\n             this.r2 = this.y.copy();\n-            if (this.minv != null) {\n-                this.y = this.minv.operate(this.r2);\n+            if (this.m != null) {\n+                this.y = this.m.operate(this.r2);\n             }\n             this.oldb = this.beta1;\n             this.beta = this.r2.dotProduct(this.y);\n             if (this.beta < 0.) {\n-                throwNPDLOException(this.minv, this.y);\n+                throwNPDLOException(this.m, this.y);\n             }\n             this.beta = FastMath.sqrt(this.beta);\n             /*\n              *   oldb = beta[1]\n              *   beta = beta[2]\n              *   y  = beta[2] * P' * v[2]\n-             *   r2 = beta[2] * M * P' * v[2]\n+             *   r2 = beta[2] * M^(-1) * P' * v[2]\n              */\n             this.cgnorm = this.beta1;\n             this.gbar = alpha;\n             /*\n              * At this point\n              *   v     = P' * v[k],\n-             *   y     = (A - shift * I) * P' * v[k] - beta[k] * M * P' * v[k-1],\n+             *   y     = (A - shift * I) * P' * v[k] - beta[k] * M^(-1) * P' * v[k-1],\n              *   alpha = v'[k] * P * (A - shift * I) * P' * v[k]\n-             *           - beta[k] * v[k]' * P * M * P' * v[k-1]\n+             *           - beta[k] * v[k]' * P * M^(-1) * P' * v[k-1]\n              *         = v'[k] * P * (A - shift * I) * P' * v[k]\n              *           - beta[k] * v[k]' * v[k-1]\n              *         = alpha[k].\n             daxpy(-alpha / beta, r2, y);\n             /*\n              * At this point\n-             *   y = (A - shift * I) * P' * v[k] - alpha[k] * M * P' * v[k]\n-             *       - beta[k] * M * P' * v[k-1]\n-             *     = M * P' * (P * (A - shift * I) * P' * v[k] -alpha[k] * v[k]\n+             *   y = (A - shift * I) * P' * v[k] - alpha[k] * M^(-1) * P' * v[k]\n+             *       - beta[k] * M^(-1) * P' * v[k-1]\n+             *     = M^(-1) * P' * (P * (A - shift * I) * P' * v[k] -alpha[k] * v[k]\n              *       - beta[k] * v[k-1])\n-             *     = beta[k+1] * M * P' * v[k+1],\n+             *     = beta[k+1] * M^(-1) * P' * v[k+1],\n              * from Paige and Saunders (1975), equation (3.2).\n              *\n-             * WATCH-IT: the two following line work only because y is no longer\n+             * WATCH-IT: the two following lines work only because y is no longer\n              * updated up to the end of the present iteration, and is\n              * reinitialized at the beginning of the next iteration.\n              */\n             r1 = r2;\n             r2 = y;\n-            if (minv != null) {\n-                y = minv.operate(r2);\n+            if (m != null) {\n+                y = m.operate(r2);\n             }\n             oldb = beta;\n             beta = r2.dotProduct(y);\n             if (beta < 0.) {\n-                throwNPDLOException(minv, y);\n+                throwNPDLOException(m, y);\n             }\n             beta = FastMath.sqrt(beta);\n             /*\n              * At this point\n-             *   r1 = beta[k] * M * P' * v[k],\n-             *   r2 = beta[k+1] * M * P' * v[k+1],\n+             *   r1 = beta[k] * M^(-1) * P' * v[k],\n+             *   r2 = beta[k+1] * M^(-1) * P' * v[k+1],\n              *   y  = beta[k+1] * P' * v[k+1],\n              *   oldb = beta[k],\n              *   beta = beta[k+1].\n      * {@inheritDoc}\n      *\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n-     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not\n      * positive definite\n      * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n      * </p>\n      *\n      * @param a the linear operator A of the system\n-     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n-     * (can be {@code null})\n+     * @param m the preconditioner, M (can be {@code null})\n      * @param b the right-hand side vector\n      * @param goodb usually {@code false}, except if {@code x} is expected to\n      * contain a large multiple of {@code b}\n      * @param shift the amount to be subtracted to all diagonal elements of A\n      * @return a reference to {@code x} (shallow copy)\n      * @throws NullArgumentException if one of the parameters is {@code null}\n-     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n-     * square\n-     * @throws DimensionMismatchException if {@code minv} or {@code b} have\n-     * dimensions inconsistent with {@code a}\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not square\n+     * @throws DimensionMismatchException if {@code m} or {@code b} have dimensions\n+     * inconsistent with {@code a}\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n      * unless a custom\n      * {@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\n      * has been set at construction\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n-     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not\n      * positive definite\n      * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     public RealVector solve(final RealLinearOperator a,\n-        final RealLinearOperator minv, final RealVector b, final boolean goodb,\n+        final RealLinearOperator m, final RealVector b, final boolean goodb,\n         final double shift) throws NullArgumentException,\n         NonSquareOperatorException, DimensionMismatchException,\n         MaxCountExceededException, NonSelfAdjointOperatorException,\n         NonPositiveDefiniteOperatorException, IllConditionedOperatorException {\n         MathUtils.checkNotNull(a);\n         final RealVector x = new ArrayRealVector(a.getColumnDimension());\n-        return solveInPlace(a, minv, b, x, goodb, shift);\n+        return solveInPlace(a, m, b, x, goodb, shift);\n     }\n \n     /**\n      * @param x not meaningful in this implementation; should not be considered\n      * as an initial guess (<a href=\"#initguess\">more</a>)\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n-     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n-     * positive definite\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n+     * definite\n      * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solve(final RealLinearOperator a,\n-        final RealLinearOperator minv, final RealVector b, final RealVector x)\n+        final RealLinearOperator m, final RealVector b, final RealVector x)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, NonSelfAdjointOperatorException,\n         NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n         MaxCountExceededException {\n         MathUtils.checkNotNull(x);\n-        return solveInPlace(a, minv, b, x.copy(), false, 0.);\n+        return solveInPlace(a, m, b, x.copy(), false, 0.);\n     }\n \n     /**\n      * @param x the vector to be updated with the solution; {@code x} should\n      * not be considered as an initial guess (<a href=\"#initguess\">more</a>)\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n-     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not\n      * positive definite\n      * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solveInPlace(final RealLinearOperator a,\n-        final RealLinearOperator minv, final RealVector b, final RealVector x)\n+        final RealLinearOperator m, final RealVector b, final RealVector x)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, NonSelfAdjointOperatorException,\n         NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n         MaxCountExceededException {\n-        return solveInPlace(a, minv, b, x, false, 0.);\n+        return solveInPlace(a, m, b, x, false, 0.);\n     }\n \n     /**\n      * </p>\n      *\n      * @param a the linear operator A of the system\n-     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n-     * (can be {@code null})\n+     * @param m the preconditioner, M (can be {@code null})\n      * @param b the right-hand side vector\n      * @param x the vector to be updated with the solution; {@code x} should\n      * not be considered as an initial guess (<a href=\"#initguess\">more</a>)\n      * @param shift the amount to be subtracted to all diagonal elements of A\n      * @return a reference to {@code x} (shallow copy).\n      * @throws NullArgumentException if one of the parameters is {@code null}\n-     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n-     * square\n-     * @throws DimensionMismatchException if {@code minv}, {@code b} or\n-     * {@code x} have dimensions inconsistent with {@code a}.\n+     * @throws NonSquareOperatorException if {@code a} or {@code m} is not square\n+     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n+     * have dimensions inconsistent with {@code a}.\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n      * unless a custom\n      * {@link org.apache.commons.math3.util.Incrementor.MaxCountExceededCallback callback}\n      * has been set at construction\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n-     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n-     * positive definite\n+     * {@code true}, and {@code a} or {@code m} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n+     * definite\n      * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     public RealVector solveInPlace(final RealLinearOperator a,\n-        final RealLinearOperator minv, final RealVector b,\n+        final RealLinearOperator m, final RealVector b,\n         final RealVector x, final boolean goodb, final double shift)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, NonSelfAdjointOperatorException,\n         NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n         MaxCountExceededException {\n-        checkParameters(a, minv, b, x);\n+        checkParameters(a, m, b, x);\n \n         final IterationManager manager = getIterationManager();\n         /* Initialization counts as an iteration. */\n         manager.incrementIterationCount();\n \n         final State state;\n-        state = new State(a, minv, b, goodb, shift, delta, check);\n+        state = new State(a, m, b, goodb, shift, delta, check);\n         state.init();\n         state.refineSolution(x);\n         IterativeLinearSolverEvent event;", "timestamp": 1332904773, "metainfo": ""}