{"sha": "290af7e332cae0d450b54130127345df2cc32b0a", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20442 Submitted by:\tPhil Steitz   ", "commit": "\n--- a/src/java/org/apache/commons/math/RandomData.java\n+++ b/src/java/org/apache/commons/math/RandomData.java\n /**\n  * Random data generation utilities\n  * @author Phil Steitz\n- * @version $Revision: 1.2 $ $Date: 2003/05/29 19:45:35 $\n+ * @version $Revision: 1.3 $ $Date: 2003/06/04 02:45:49 $\n  */\n public interface RandomData {      \n     /**\n      * Generates a random string of hex characters of length\n-     * <code>len</code>.<br>\n+     * <code>len</code>.\n+     * <p>\n      * The generated string will be random, but not cryptographically \n      * secure. To generate cryptographically secure strings, use \n      * <code>nextSecureHexString</code>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     * \n      * @param len the length of the string to be generated\n-     * @throws IllegalArgumentException if <code>len</code> is not positive.\n-     */\n-    public String nextHexString(int len);  \n+     * @return random string of hex characters of length <code>len</code>  \n+     */\n+    String nextHexString(int len);  \n     \n     /**\n      * Generates a uniformly distributed random integer between \n-     * <code>lower</code> and <code>upper</code> (endpoints included).<br>\n+     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * <p>\n      * The generated integer will be random, but not cryptographically secure.\n      * To generate cryptographically secure integer sequences, use \n      * <code>nextSecureInt</code>.\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n-     * @exception IllegalArgumentException thrown if\n-     * <code>lower</code> is not strictly less than <code>upper</code>.\n      * @return a random integer greater than or equal to <code>lower</code> \n      * and less than or equal to <code>upper</code>.\n      */\n-    public int nextInt(int lower, int upper);  \n-    \n-    /**\n-     * Generates a uniformly distributed random long integer between <\n-     * code>lower</code> and <code>upper</code> (endpoints included).\n+    int nextInt(int lower, int upper);  \n+    \n+    /**\n+     * Generates a uniformly distributed random long integer between\n+     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * <p>\n      * The generated long integer values will be random, but not \n-     * cryptographically secure.<br> \n+     * cryptographically secure.\n      * To generate cryptographically secure sequences of longs, use \n      * <code>nextSecureLong</code>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n-     * @exception IllegalArgumentException Thrown if lower > upper\n      * @return a random integer greater than or equal to <code>lower</code>\n      * and less than or equal to <code>upper</code>.\n      */\n-    public long nextLong(long lower, long upper);  \n-    \n-    /**\n-     * Generates a random string of hex characters from a secure random sequence.\n+    long nextLong(long lower, long upper);  \n+    \n+    /**\n+     * Generates a random string of hex characters from a secure random \n+     * sequence.\n+     * <p>\n      * If cryptographic security is not required, \n      * use <code>nextHexString()</code>.\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n      * @param len length of return string\n-     * @exception IllegalArgumentException thrown if len <= 0 \n      * @return the random hex string\n      */\n-    public String nextSecureHexString(int len);  \n+    String nextSecureHexString(int len);  \n     \n     /**\n      * Generates a uniformly distributed random integer between \n      * <code>lower</code> and <code>upper</code> (endpoints included) \n-     * from a secure random sequence.<br>\n-     * The generated sequence will be cryptographically secure.<br>\n-     * If cryptographic security is not required, <code>nextInt</code>\n-     * should be used.<br>\n-     * <strong>Definition</strong>(secure random sequence):\n-     * http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator<br>\n+     * from a secure random sequence.\n+     * <p>\n+     * Sequences of integers generated using this method will be \n+     * cryptographically secure. If cryptographic security is not required, \n+     * <code>nextInt</code> should be used instead of this method. \n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://www.wikipedia.org/wiki/\n+     * Cryptographically_secure_pseudo-random_number_generator\">\n+     * Secure Random Sequence</a>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n-     * @exception IllegalArgumentException thrown if\n-     * <code>lower</code> is not strictly less than <code>upper</code>.\n      * @return a random integer greater than or equal to <code>lower</code>\n      * and less than or equal to <code>upper</code>.\n      */\n-    public int nextSecureInt(int lower, int upper);  \n+    int nextSecureInt(int lower, int upper);  \n     \n     /**\n      * Generates a random long integer between <code>lower</code>\n-     * and <code>upper</code> (endpoints included).<br>\n-     * The generated long sequence will be cryptographically secure.<br>\n-     * If cryptographic security is not required,\n-     * use <code>nextLong</code><br>\n+     * and <code>upper</code> (endpoints included).<p>\n+     * Sequences of long values generated using this method will be \n+     * cryptographically secure. If cryptographic security is not required,\n+     * <code>nextLong</code> should be used instead of this method.\n+     * <p>\n      * <strong>Definition</strong>:\n-     * <a href=http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator>\n+     * <a href=\"http://www.wikipedia.org/wiki/\n+     * Cryptographically_secure_pseudo-random_number_generator\">\n      * Secure Random Sequence</a>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n      * @param lower lower bound for generated integer\n      * @param upper upper bound for generated integer\n-     * @exception IllegalArgumentException thrown if\n-     * <code>lower</code> is not strictly less than <code>upper</code>.\n      * @return a long integer greater than or equal to <code>lower</code>\n      * and less than or equal to <code>upper</code>.\n      */\n-    public long nextSecureLong(long lower, long upper);  \n+    long nextSecureLong(long lower, long upper);  \n     \n     /** \n      * Generates a random value from the Poisson distribution with \n-     * the given mean.<br>\n+     * the given mean.\n+     * <p>\n      * <strong>Definition</strong>: \n-     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm>\n-     * Poisson Distribution</a><br>\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda366j.htm\">\n+     * Poisson Distribution</a>\n+     * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>The specified mean <i>must</i> be positive </li>\n+     * <li>The specified mean <i>must</i> be positive (otherwise an \n+     *     IllegalArgumentException is thrown.)</li>\n      * </ul>\n      * @param mean Mean of the distribution\n-     * @returns long\n-     * @throws IllegalArgumentException if mean <= 0\n-     */\n-    public long nextPoisson(double mean);  \n+     * @return poisson deviate with the specified mean\n+     */\n+    long nextPoisson(double mean);  \n     \n     /** \n      * Generates a random value from the\n-     * Normal (a.k.a. Gaussian) distribution with the given mean\n-     * and standard deviation.<br>\n+     * Normal (or Gaussian) distribution with the given mean\n+     * and standard deviation.\n+     * <p>\n      * <strong>Definition</strong>: \n-     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3661.htm>\n-     * Normal Distribution</a><br>\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda3661.htm\">\n+     * Normal Distribution</a>\n+     * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>The specified standard deviation <i>must</i> be positive </li>\n+     * <li><code>sigma > 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n      * </ul>\n      * @param mu Mean of the distribution\n      * @param sigma Standard deviation of the distribution\n      * @return random value from Gaussian distribution with mean = mu,\n      * standard deviation = sigma\n-     * @throws IllegalArgumentExcption if sigma <= 0\n-     */\n-    public double nextGaussian(double mu,double sigma);  \n+     */\n+    double nextGaussian(double mu, double sigma);  \n     \n     /**\n      * Generates a random value from the exponential distribution\n-     * with expected value = <code>mean</code><br>\n+     * with expected value = <code>mean</code>.\n+     * <p>\n      * <strong>Definition</strong>: \n-     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm>\n-     * Exponential Distribution</a><br>\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda3667.htm\">\n+     * Exponential Distribution</a>\n+     * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>The specified mean <i>must</i> be non-negative</li>\n-     * </ul>\n-     * @param mu Mean of the distribution\n+     * <li><code>mu >= 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     * @param mean Mean of the distribution\n      * @return random value from exponential distribution\n      */\n-    public double nextExponential(double mean);   \n+    double nextExponential(double mean);   \n     \n     /**\n      * Generates a uniformly distributed random value from the open interval\n-     * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded)\n+     * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded).\n+     * <p>\n      * <strong>Definition</strong>: \n-     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm>\n-     * Uniform Distribution</a> <code>lower</code> and <code>upper - lower</code>\n-     * are the \n-     * <a href = http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm>\n-     * location and scale parameters</a>, respectively<br>\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda3662.htm\">\n+     * Uniform Distribution</a> <code>lower</code> and \n+     * <code>upper - lower</code> are the \n+     * <a href = \"http://www.itl.nist.gov/div898/handbook/eda/\n+     * section3/eda364.htm\">\n+     * location and scale parameters</a>, respectively.\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n      * @param lower lower endpoint of the interval of support\n      * @param upper upper endpoint of the interval of support\n      * @return uniformly distributed random value between lower\n      * and upper (exclusive)\n-     * @exception IllegalArgumentException thrown if\n-     * <code>lower</code> is not strictly less than <code>upper</code>.\n-     */\n-    public double nextUniform(double lower, double upper);\n+     */\n+    double nextUniform(double lower, double upper);\n     \n     /**\n      * Generates an integer array of length <code>k</code> whose entries\n-     * are selected randomly, without repetition, from the integers\n-     * {0, ... , n-1} -- i.e., generated arrays represent permutations\n-     * of <code>n</code> taken <code>k</code> at a time. <p>\n-     *\n+     * are selected randomly, without repetition, from the integers <code>\n+     * 0 through n-1</code> (inclusive). \n+     * <p>\n+     * Generated arrays represent permutations\n+     * of <code>n</code> taken <code>k</code> at a time. \n+     * <p>\n      * <strong>Preconditions:</strong><ul>\n-     * <li> k must be less than or equal to n </li>\n-     * <li> n must be positive (i.e. greater than 0) </li>\n-     * </ul>\n+     * <li> <code>k <= n</code></li>\n+     * <li> <code>n > 0</code> </li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is\n+     * thrown.\n      * \n      * @param n domain of the permutation\n      * @param k size of the permutation\n      * @return random k-permutation of n \n      */\n-    public int[] nextPermutation(int n, int k);\n+    int[] nextPermutation(int n, int k);\n     \n     /**\n      * Returns an array of <code>k</code> objects selected randomly\n-     * from the Collection <code>c</code>. Sampling from <code>c</code>\n+     * from the Collection <code>c</code>. \n+     * <p>\n+     * Sampling from <code>c</code>\n      * is without replacement; but if <code>c</code> contains identical\n      * objects, the sample may include repeats.  If all elements of <code>\n      * c</code> are distinct, the resulting object array represents a \n-     * <a href=http://rkb.home.cern.ch/rkb/AN16pp/node250.html#SECTION0002500000000000000000>\n+     * <a href=\"http://rkb.home.cern.ch/rkb/AN16pp/\n+     * node250.html#SECTION0002500000000000000000\">\n      * Simple Random Sample</a> of size\n-     * <code>k</code> from the elements of <code>c</code>.<p>   \n-     *\n+     * <code>k</code> from the elements of <code>c</code>.\n+     * <p>   \n      * <strong>Preconditions:</strong><ul>\n      * <li> k must be less than or equal to the size of c </li>\n      * <li> c must not be empty </li>\n      * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is\n+     * thrown.\n      * \n      * @param c collection to be sampled\n      * @param k size of the sample\n      * @return random sample of k elements from c \n      */\n-    public Object[] nextSample(Collection c, int k);\n+    Object[] nextSample(Collection c, int k);\n }\n--- a/src/java/org/apache/commons/math/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/RandomDataImpl.java\n /**\n  * Implements the <code>RandomData</code> interface using \n  * <code>java.util.Random</code> and \n- * <code>java.util.Random.SecureRandom</code> instances to generate data.\n+ * <code>java.util.Random.SecureRandom</code> instances to generate data. \n+ * <p>\n  * Supports reseeding the underlying \n- * <a href=http://www.wikipedia.org/wiki/Pseudo-random_number_generator>PRNG</a>. \n- * The <code>SecurityProvider</code> and <code>Algorithm</code>\n- * used by the <code>SecureRandom</code> instance can also be reset.<p>\n+ * <a href=\"http://www.wikipedia.org/wiki/Pseudo-random_number_generator\">\n+ * PRNG</a>. The <code>SecurityProvider</code> and <code>Algorithm</code>\n+ * used by the <code>SecureRandom</code> instance can also be reset.\n+ * <p>\n  * For details on the PRNGs, see the JDK documentation for \n  * <code>java.util.Random</code> and \n- * <code>java.util.Random.SecureRandom</code></p><p>\n+ * <code>java.util.Random.SecureRandom</code>\n+ * <p>\n  * <strong>Usage Notes</strong>: <ul>\n- * <li>Instance variables are used to maintain <code>Random</code> and \n+ * <li>\n+ * Instance variables are used to maintain <code>Random</code> and \n  * <code>SecureRandom</code> instances used in data generation. Therefore,\n  * to generate a random sequence of values or strings, you should use just\n  * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n- * <li>The \"secure\" methods are *much* slower.  These should be used only when\n- * a <a href=http://www.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator>\n- * Secure Random Sequence</a> is required.</li>\n- *<li>When a new <code>RandomDataImpl</code> is created, the underlying random\n+ * <li>\n+ * The \"secure\" methods are *much* slower.  These should be used only when\n+ * a <a href=\"http://www.wikipedia.org/wiki/\n+ * Cryptographically_secure_pseudo-random_number_generator\"> Secure Random \n+ * Sequence</a> is required.</li>\n+ * <li>\n+ * When a new <code>RandomDataImpl</code> is created, the underlying random\n  * number generators are <strong>not</strong> intialized.  The first call to a\n  * data generation method, or to a <code>reSeed()</code> method instantiates\n  * the appropriate generator.  If you do not explicitly seed the generator, it\n  * is by default seeded with the current time in milliseconds</li>\n- * <li>The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate to\n- * the corresponding methods on the underlying <code>Random</code> and <code>\n- * SecureRandom</code> instances.  Therefore, the contracts of these methods\n- * are as defined in the JDK documentation.  In particular, <code>reSeed(long)\n- * </code> fully resets the initial state of the non-secure random number \n- * generator (so that reseeding with a specific value always results in the\n- * same subsequent random sequence); whereas reSeedSecure(long) does <strong> not \n- * </strong> reinitialize the secure random number generator (so secure sequences\n- * started with calls to reseedSecure(long) won't be identical).</li></ul>\n- *</p>\n+ * <li>\n+ * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate \n+ * to the corresponding methods on the underlying <code>Random</code> and \n+ * <code>SecureRandom</code> instances.  Therefore, the contracts of these \n+ * methods are as defined in the JDK documentation.  In particular, \n+ * <code>reSeed(long)</code> fully resets the initial state of the non-secure \n+ * random number generator (so that reseeding with a specific value always \n+ * results in the same subsequent random sequence); whereas reSeedSecure(long)\n+ * does <strong>not</strong> reinitialize the secure random number generator \n+ * (so secure sequences started with calls to reseedSecure(long) won't be \n+ * identical).</li></ul>\n  * \n  * @author Phil Steitz\n- * @version $Revision: 1.2 $ $Date: 2003/05/29 19:45:35 $\n+ * @version $Revision: 1.3 $ $Date: 2003/06/04 02:45:49 $\n  */\n-public class RandomDataImpl implements RandomData{\n+public class RandomDataImpl implements RandomData {\n     \n     /** underlying random number generator */\n     private Random rand = null;\n     /** underlying secure random number generator */\n     private SecureRandom secRand = null;\n     \n-    public RandomDataImpl(){\n+    /**\n+     * Construct a RandomDataImpl.\n+     */\n+    public RandomDataImpl() {\n     }\n           \n     /**\n-     * Generates a random string of hex characters\n-     * If cryptographic security is required, use \n-     * <code>nextSecureHexString()</code>.<br>\n      * <strong>Algorithm Description:</strong> hex strings are generated \n      * using a 2-step process. <ol>\n-     * <li>len/2+1 binary bytes are generated using the underlying Random</li>\n-     * <li>Each binary byte is translated into 2 hex digits</li></ol>\n-     * @param len length of return string\n-     * @exception IllegalArgumentException thrown if len <= 0 \n-     * @return the random hex string\n+     * <li>\n+     * len/2+1 binary bytes are generated using the underlying Random</li>\n+     * <li>\n+     * Each binary byte is translated into 2 hex digits</li></ol>\n      */\n     public String nextHexString(int len) {\n         if (len <= 0) {\n              * This guarantees <= 2 hex digits from toHexString()\n              * toHexString would otherwise add 2^32 to negative arguments.\n              */\n-             String hex = Integer.toHexString(c.intValue()+128);\n+             String hex = Integer.toHexString(c.intValue() + 128);\n                 \n              // Make sure we add 2 hex digits for each byte\n-             if (hex.length() == 1) hex = \"0\" + hex;\n+             if (hex.length() == 1)  {\n+                 hex = \"0\" + hex;\n+             }\n              outBuffer.append(hex);\n         }\n         return outBuffer.toString().substring(0, len);\n     }\n-    \n-     \n+       \n     public int nextInt(int lower, int upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n                 (\"upper bound must be > lower bound\");\n         }\n         Random rand = getRan();\n-        return lower + (int)(Math.random() * (upper-lower+1));\n+        return lower + (int) (Math.random() * (upper - lower + 1));\n     }\n     \n     public long nextLong(long lower, long upper) {\n                 (\"upper bound must be > lower bound\");\n         }\n         Random rand = getRan();\n-        return lower + (long)(rand.nextDouble() * (upper-lower+1));\n+        return lower + (long) (rand.nextDouble() * (upper - lower + 1));\n     }\n     \n      /**\n-     * Generates a random string of hex characters from a secure random sequence.\n-     * If cryptographic security is not required, \n-     * use <code>nextHexString()</code>.<br>\n-     * <strong>Algorithm Description:</strong> hex strings are generated in 40-byte\n-     * segments using a 3-step process. <ol>\n-     * <li>20 random bytes are generated using the underlying SecureRandom</li>\n-     * <li>SHA-1 hash is applied to yield a 20-byte binary digest</li>\n-     * <li>Each byte of the binary digest is converted to 2 hex digits</li></ol><p>\n-     * TODO: find external reference or provide justification for the claim that this\n-     * yields a cryptographically secure sequence of hex strings.</p>\n-     * @param len length of return string\n-     * @exception IllegalArgumentException thrown if len <= 0 \n-     * @return the random hex string\n+     * <strong>Algorithm Description:</strong> hex strings are generated in \n+     * 40-byte segments using a 3-step process. <ol>\n+     * <li>\n+     * 20 random bytes are generated using the underlying \n+     * <code>SecureRandom</code>.</li>\n+     * <li>\n+     * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n+     * <li>\n+     * Each byte of the binary digest is converted to 2 hex digits</li></ol>\n+     * <p>\n+     * TODO: find external reference or provide justification for the claim \n+     * that this yields a cryptographically secure sequence of hex strings.\n      */\n     public String nextSecureHexString(int len) {\n         if (len <= 0) {\n        try {\n             alg = MessageDigest.getInstance(\"SHA-1\");\n        } catch (NoSuchAlgorithmException ex) {\n-           return null; // gulp FIXME? -- this *should* never fail. OK to swallow????\n+           return null; // gulp FIXME? -- this *should* never fail.\n        }\n        alg.reset(); \n        \n                  * toHexString would otherwise add 2^32 to negative \n                  * arguments\n                  */\n-                String hex = Integer.toHexString(c.intValue()+128);\n+                String hex = Integer.toHexString(c.intValue() + 128);\n                     \n                //Keep strings uniform length -- guarantees 40 bytes\n-               if (hex.length() == 1) hex = \"0\" + hex;\n+                if (hex.length() == 1) {\n+                    hex = \"0\" + hex;\n+                }\n                outBuffer.append(hex);\n             }\n         }\n         return outBuffer.toString().substring(0, len);\n     }\n-    \n+     \n     public int nextSecureInt(int lower, int upper) {\n           if (lower >= upper) {\n               throw new IllegalArgumentException\n                 (\"lower bound must be < upper bound\");\n           }\n           SecureRandom sec = getSecRan();\n-          return lower + (int)(sec.nextDouble() * (upper-lower+1));\n-    }\n-    \n-    \n+          return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+    }\n+     \n     public long nextSecureLong(long lower, long upper) {\n         if (lower >= upper) {\n             throw new IllegalArgumentException\n             (\"lower bound must be < upper bound\");\n         }\n         SecureRandom sec = getSecRan();\n-        return lower + (long)(sec.nextDouble() * (upper-lower+1));\n+        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n     }\n     \n     /** \n-     * Generates a random value from the Poisson distribution with \n-     * the given mean.<br>\n-     * <strong>Definition</strong>: \n-     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm>\n-     * Poisson Distribution</a><br>\n      * <strong>Algorithm Description</strong>:\n-     * Uses simulation of a Poisson process using Uniform deviates, as described \n-     * <a href = http://dmawww.epfl.ch/benarous/Pmmi/interactive/rng7.htm>\n+     * Uses simulation of a Poisson process using Uniform deviates, as \n+     * described \n+     * <a href =\"http://dmawww.epfl.ch/benarous/Pmmi/interactive/rng7.htm\">\n      * here</a>\n-     * @param mean Mean of the distribution\n-     * @returns long\n-     * @throws IllegalArgumentException if mean <= 0\n+     *\n      */\n     public long nextPoisson(double mean) {\n         double p = Math.exp(-mean);\n         }\n     }\n     \n-    public double nextGaussian(double mu,double sigma) {\n+    public double nextGaussian(double mu, double sigma) {\n         if (sigma <= 0) {\n             throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n         }\n         Random rand = getRan();\n-        return sigma*rand.nextGaussian() + mu;\n-    }\n-    \n-    /**\n-     * Generates a random value from the exponential distribution\n-     * with expected value = <code>mean</code><br>\n-     * <strong>Definition</strong>: \n-     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm>\n-     * Exponential Distribution</a><br>\n-     * <strong>Preconditions</strong>: <ul>\n-     * <li>The specified mean <i>must</i> be non-negative</li>\n-     * </ul>\n+        return sigma * rand.nextGaussian() + mu;\n+    }\n+    \n+    /**\n      * <strong>Algorithm Description</strong>:  Uses the \n-     * <a href=http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html> \n+     * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> \n      * Inversion Method</a> to generate exponential from uniform deviates.\n-     * @param mu Mean of the distribution\n-     * @return random value from exponential distribution\n      */\n     public double nextExponential(double mean)  {\n-        if (mean < 0.0) throw new IllegalArgumentException\n-            (\"Exponential mean must be >= 0\");\n+        if (mean < 0.0)  {\n+            throw new IllegalArgumentException\n+                (\"Exponential mean must be >= 0\");\n+        }\n         Random rand = getRan();\n         double unif = rand.nextDouble();\n         while (unif == 0.0d) {\n             unif = rand.nextDouble();\n         }\n-        return -mean*Math.log(unif);\n-    }\n-    \n-    /**\n-     * Generates a uniformly distributed random value from the open interval\n-     * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded)\n-     * <strong>Definition</strong>: \n-     * <a href=http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm>\n-     * Uniform Distribution</a> <code>lower</code> and <code>upper - lower</code>\n-     * are the \n-     * <a href = http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm>\n-     * location and scale parameters</a>, respectively<br>\n+        return -mean * Math.log(unif);\n+    }\n+    \n+    /**\n      * <strong>Algorithm Description</strong>: scales the output of \n      * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n-     * random double if Random.nextDouble() returns 0).  This is necessary to\n-     * provide a symmetric output interval (both endpoints excluded).\n-     * @param lower lower endpoint of the interval of support\n-     * @param upper upper endpoint of the interval of support\n-     * @return uniformly distributed random value between lower\n-     * and upper (exclusive)\n-     * @exception IllegalArgumentException thrown if\n-     * <code>lower</code> is not strictly less than <code>upper</code>.\n+     * random double if Random.nextDouble() returns 0). \n+     * This is necessary to provide a symmetric output interval \n+     * (both endpoints excluded).\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n             (\"lower bound must be <= upper bound\");\n         }\n         Random rand = getRan();\n-        double result = lower + rand.nextDouble()*(upper-lower);\n+        double result = lower + rand.nextDouble() * (upper - lower);\n         while (result == lower) {\n-              result = lower + rand.nextDouble()*(upper-lower);\n+              result = lower + rand.nextDouble() * (upper - lower);\n         }\n         return result;   \n     }\n     \n     /** \n-     * Returns the static Random used to generate random data.<br>\n-     * Creates and initializes if null\n+     * Returns the static Random used to generate random data.\n+     * <p>\n+     * Creates and initializes if null.\n+     * \n      * @return the static Random used to generate random data\n      */\n     private Random getRan() {\n     }\n     \n     /** \n-     * Returns the static SecureRandom used to generate secure random data.<br>\n+     * Returns the static SecureRandom used to generate secure random data.\n+     * <p>\n      * Creates and initializes if null.\n+     *\n      * @return the static SecureRandom used to generate secure random data\n      */\n     private SecureRandom getSecRan() {\n     }\n     \n     /**\n-     * Reseeds the random number generator with the supplied seed.  Will\n-     * create and initialize if null.\n+     * Reseeds the random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     *\n      * @param seed the seed value to use\n      */\n     public void reSeed(long seed) {\n     \n     /**\n      * Reseeds the secure random number generator with the current time\n-     * in milliseconds.  Will create and initialize if null.\n+     * in milliseconds. \n+     * <p> \n+     * Will create and initialize if null.\n      */\n     public void reSeedSecure() {\n-        if (rand == null) {\n-            rand = new Random();\n-        }\n-        rand.setSeed(System.currentTimeMillis());\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(System.currentTimeMillis());\n     }\n     \n     /**\n      * Reseeds the secure random number generator with the supplied seed.\n+     * <p>\n      * Will create and initialize if null.\n+     *\n      * @param seed the seed value to use\n      */\n     public void reSeedSecure(long seed) {\n     \n     /**\n      * Reseeds the random number generator with the current time\n-     * in milliseconds\n+     * in milliseconds.\n      */\n     public void reSeed() {\n         if (rand == null) {\n     /**\n      * Sets the PRNG algorithm for the underlying SecureRandom instance\n      * using the Security Provider API, as defined in \n-     * <a href=http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA>\n-     * Java Cryptography Architecture API Specification & Reference</a><p>\n-     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i> overhead\n-     * and may take several seconds to execute.</p>\n+     * <a href=\"http://java.sun.com/j2se/1.3/docs/guide/security/\n+     * CryptoSpec.html#AppA\">\n+     * Java Cryptography Architecture API Specification & Reference.</a>\n+     * <p>\n+     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i> \n+     * overhead and may take several seconds to execute.\n+     *\n      * @param algorithm the name of the PRNG algorithm\n      * @param provider the name of the provider \n-     * @throws NoSuchAlgorithmException if the specified algorithm is not available\n-     * @throws NoSuchProviderException if the specified provider is not installed\n+     * @throws NoSuchAlgorithmException if the specified algorithm \n+     * is not available\n+     * @throws NoSuchProviderException if the specified provider \n+     * is not installed\n      */\n     public void setSecureAlgorithm(String algorithm, String provider) \n-        throws NoSuchAlgorithmException,NoSuchProviderException {\n-        secRand = SecureRandom.getInstance(algorithm,provider);\n+        throws NoSuchAlgorithmException, NoSuchProviderException {\n+        secRand = SecureRandom.getInstance(algorithm, provider);\n     }\n     \n     /**\n         }\n         \n         int[] index = getNatural(n);\n-        shuffle(index,n-k);\n+        shuffle(index, n - k);\n         int[] result = new int[k];\n         for (int i = 0; i < k; i++) {\n-            result[i] = index[n-i-1];\n+            result[i] = index[n - i - 1];\n         }\n   \n         return result;\n     }\n     \n     /**\n-     * Uses a 2-cycle permutation shuffle to generate a random\n-     * permutation of <code>c.size()</code> and then returns the\n-     * elements whose indexes correspond to the elements of the\n-     * generated permutation.  This technique is described, and \n-     * proven to generate random samples, \n-     * <a href=http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html>\n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation \n+     * shuffle to generate a random permutation of <code>c.size()</code> and \n+     * then returns the elements whose indexes correspond to the elements of \n+     * the generated permutation.  \n+     * This technique is described, and proven to generate random samples, \n+     * <a href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>\n      */ \n     public Object[] nextSample(Collection c, int k) {\n         }\n             \n        Object[] objects = c.toArray();\n-       int[] index = nextPermutation(len,k);\n+       int[] index = nextPermutation(len, k);\n        Object[] result = new Object[k];\n-       for (int i = 0; i < k; i ++) {\n+       for (int i = 0; i < k; i++) {\n            result[i] = objects[index[i]];\n        }  \n        return result;\n     //------------------------Private methods----------------------------------\n     \n     /** \n-     * Uses a 2-cycle permutation shuffle to randomly re-order the last\n-     * end elements of list\n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation \n+     * shuffle to randomly re-order the last <code>end</code> elements of list.\n      * \n      * @param list list to be shuffled\n      * @end element past which shuffling begins\n      */\n     private void shuffle(int[] list, int end) {\n         int target = 0;\n-        for (int i = list.length-1 ; i >= end; i--) {\n+        for (int i = list.length - 1 ; i >= end; i--) {\n             if (i == 0) {\n                 target = 0; \n             } else {\n-                target = nextInt(0,i);\n+                target = nextInt(0, i);\n             }\n             int temp = list[target];\n             list[target] = list[i];\n     }\n     \n     /**\n-     * Returns an array representing n\n+     * Returns an array representing n.\n      *\n      * @param n the natural number to represent\n      * @return array with entries = elements of n\n--- a/src/test/org/apache/commons/math/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/RandomDataTest.java\n  * Test cases for the RandomData class.\n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.4 $ $Date: 2003/05/29 20:35:45 $\n+ * @version $Revision: 1.5 $ $Date: 2003/06/04 02:45:49 $\n  */\n \n public final class RandomDataTest extends TestCase {\n         assertTrue(\"same seeds\",\n             !hex.equals(randomData.nextSecureHexString(40))); \n         \n-        /* TODO: probably should remove this test as the package grows,\n-         * since it takes about 4 seconds\n-         */\n+        /* remove this test back soon,\n+         * since it takes about 4 seconds */\n+         \n         randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\");\n         assertTrue(\"different seeds\",\n             !hex.equals(randomData.nextSecureHexString(40)));\n             fail(\"expecting NoSuchProviderException\");\n         } catch (NoSuchProviderException ex) {\n             ;\n-        }      \n+        } \n+        \n+        // test reseeding without first using the generators\n+        RandomDataImpl rd = new RandomDataImpl();\n+        rd.reSeed(100);\n+        double ret = rd.nextLong(1,2);\n+        RandomDataImpl rd2 = new RandomDataImpl();\n+        rd2.reSeedSecure(2000);\n+        ret = rd2.nextSecureLong(1,2);\n+        rd = new RandomDataImpl();\n+        rd.reSeed();\n+        ret = rd.nextLong(1,2);\n+        rd2 = new RandomDataImpl();\n+        rd2.reSeedSecure();\n+        ret = rd2.nextSecureLong(1,2);\n     }\n     \n     /** tests for nextSample() sampling from Collection */", "timestamp": 1054694749, "metainfo": ""}