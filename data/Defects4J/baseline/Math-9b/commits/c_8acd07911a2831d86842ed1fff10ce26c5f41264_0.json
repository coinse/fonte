{"sha": "8acd07911a2831d86842ed1fff10ce26c5f41264", "log": "added Eugene Kirpichov's patch to ignore zero weights in Loess interpolation JIRA: MATH-296  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"the number of robustness iterations must be non-negative, but got {0}\",\n       \"le nombre d''it\\u00e9rations robuste ne peut \\u00eatre n\\u00e9gatif, alors qu''il est de {0}\" },\n     { \"Loess expects the abscissa and ordinate arrays to be of the same size, \" +\n-      \"but got {0} abscisssae and {1} ordinatae\",\n+      \"but got {0} abscissae and {1} ordinatae\",\n       \"la r\\u00e9gression Loess n\\u00e9cessite autant d''abscisses que d''ordonn\\u00e9es, \" +\n       \"mais {0} abscisses et {1} ordonn\\u00e9es ont \\u00e9t\\u00e9 fournies\" },\n     { \"Loess expects at least 1 point\",\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n             throw new MathException(\n                     \"Loess expects the abscissa and ordinate arrays \" +\n                     \"to be of the same size, \" +\n-                    \"but got {0} abscisssae and {1} ordinatae\",\n+                    \"but got {0} abscissae and {1} ordinatae\",\n                     xval.length, yval.length);\n         }\n \n                 // Find out the interval of source points on which\n                 // a regression is to be made.\n                 if (i > 0) {\n-                    updateBandwidthInterval(xval, i, bandwidthInterval);\n+                    updateBandwidthInterval(xval, weights, i, bandwidthInterval);\n                 }\n \n                 final int ileft = bandwidthInterval[0];\n      */\n     public final double[] smooth(final double[] xval, final double[] yval)\n             throws MathException {\n+        if (xval.length != yval.length) {\n+            throw new MathException(\n+                    \"Loess expects the abscissa and ordinate arrays \" +\n+                    \"to be of the same size, \" +\n+                    \"but got {0} abscissae and {1} ordinatae\",\n+                    xval.length, yval.length);\n+        }\n \n         final double[] unitWeights = new double[xval.length];\n         Arrays.fill(unitWeights, 1.0);\n \n         return smooth(xval, yval, unitWeights);\n-\n-    }\n-\n+    }\n \n     /**\n      * Given an index interval into xval that embraces a certain number of\n      * points closest to xval[i-1], update the interval so that it embraces\n-     * the same number of points closest to xval[i]\n+     * the same number of points closest to xval[i], ignoring zero weights.\n      *\n      * @param xval arguments array\n+     * @param xval weights array\n      * @param i the index around which the new interval should be computed\n      * @param bandwidthInterval a two-element array {left, right} such that: <p/>\n      * <tt>(left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])</tt>\n      * <tt>(right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])</tt>.\n      * The array will be updated.\n      */\n-    private static void updateBandwidthInterval(final double[] xval, final int i,\n+    private static void updateBandwidthInterval(final double[] xval, final double[] weights,\n+                                                final int i,\n                                                 final int[] bandwidthInterval) {\n         final int left = bandwidthInterval[0];\n         final int right = bandwidthInterval[1];\n \n         // The right edge should be adjusted if the next point to the right\n         // is closer to xval[i] than the leftmost point of the current interval\n-        if (right < xval.length - 1 &&\n-           xval[right+1] - xval[i] < xval[i] - xval[left]) {\n-            bandwidthInterval[0]++;\n-            bandwidthInterval[1]++;\n-        }\n+        int nextRight = nextNonzero(weights, right);\n+        if (nextRight < xval.length && xval[nextRight] - xval[i] < xval[i] - xval[left]) {\n+            int nextLeft = nextNonzero(weights, bandwidthInterval[0]);\n+            bandwidthInterval[0] = nextLeft;\n+            bandwidthInterval[1] = nextRight;\n+        }\n+    }\n+\n+    /**\n+     * Returns the smallest index j such that j > i && (j==weights.length || weights[j] != 0)\n+     * @param weights weights array\n+     * @param i the index from which to start search; must be < weights.length\n+     * @return the smallest index j such that j > i && (j==weights.length || weights[j] != 0) \n+     */\n+    private static int nextNonzero(final double[] weights, final int i) {\n+        int j = i + 1;\n+        while(j < weights.length && weights[j] == 0) {\n+            j++;\n+        }\n+        return j;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n import org.junit.Assert;\n \n import org.apache.commons.math.MathException;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n     public void testOnStraightLine() throws MathException {\n         double[] xval = {1,2,3,4,5};\n         double[] yval = {2,4,6,8,10};\n-        LoessInterpolator li = new LoessInterpolator(0.6, 2);\n+        LoessInterpolator li = new LoessInterpolator(0.6, 2, 1e-12);\n         double[] res = li.smooth(xval, yval);\n         Assert.assertEquals(5, res.length);\n         for(int i = 0; i < 5; ++i) {\n \n         generateSineData(xval, yval, xnoise, ynoise);\n \n-        LoessInterpolator li = new LoessInterpolator(0.3, 4);\n+        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);\n \n         double[] res = li.smooth(xval, yval);\n \n         for (int i = 0; i < bandwidths.length; i++) {\n             double bw = bandwidths[i];\n \n-            LoessInterpolator li = new LoessInterpolator(bw, 4);\n+            LoessInterpolator li = new LoessInterpolator(bw, 4, 1e-12);\n \n             double[] res = li.smooth(xval, yval);\n \n \n         double[] variances = new double[4];\n         for (int i = 0; i < 4; i++) {\n-            LoessInterpolator li = new LoessInterpolator(0.3, i);\n+            LoessInterpolator li = new LoessInterpolator(0.3, i, 1e-12);\n \n             double[] res = li.smooth(xval, yval);\n \n \n     @Test(expected=MathException.class)\n     public void testInsufficientBandwidth() throws MathException {\n-        LoessInterpolator li = new LoessInterpolator(0.1, 3);\n+        LoessInterpolator li = new LoessInterpolator(0.1, 3, 1e-12);\n         li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12});\n     }\n \n     @Test(expected=MathException.class)\n     public void testCompletelyIncorrectBandwidth1() throws MathException {\n-        new LoessInterpolator(-0.2, 3);\n+        new LoessInterpolator(-0.2, 3, 1e-12);\n     }\n \n     @Test(expected=MathException.class)\n     public void testCompletelyIncorrectBandwidth2() throws MathException {\n-        new LoessInterpolator(1.1, 3);\n+        new LoessInterpolator(1.1, 3, 1e-12);\n     }\n \n     @Test\n         }\n     }\n \n-    @Test\n-    public void testMath296withWeights() throws MathException {\n-        double[] xval = {\n-                0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n-                 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0};\n-        double[] yval = {\n-                0.47, 0.48, 0.55, 0.56, -0.08, -0.04, -0.07, -0.07,\n-                -0.56, -0.46, -0.56, -0.52, -3.03, -3.08, -3.09,\n-                -3.04, 3.54, 3.46, 3.36, 3.35};\n-        double[] weights = {\n-                1,1,1,1,1,1,1,1,1,1,\n-                1,1,0,0,1,1,0,0,1,1};\n-        // Output from R, rounded to .001\n-        double[] yref = {\n-                0.478, 0.492, 0.484, 0.320, 0.179, -0.003, -0.088, -0.209,\n-                -0.327, -0.455, -0.518, -0.537, -1.492, -2.115, -3.09, -3.04,\n-                -3.0, 0.155, 1.752, 3.35};\n-        LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12);\n-        double[] res = li.smooth(xval, yval,weights);\n-        Assert.assertEquals(xval.length, res.length);\n-        for(int i = 0; i < res.length; ++i) {\n-            Assert.assertEquals(yref[i], res[i], 0.05);\n-        }\n-    }\n-\n     private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {\n         double dx = 2 * Math.PI / xval.length;\n         double x = 0;", "timestamp": 1264542839, "metainfo": ""}