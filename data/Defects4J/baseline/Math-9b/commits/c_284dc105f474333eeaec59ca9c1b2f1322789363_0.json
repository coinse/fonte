{"sha": "284dc105f474333eeaec59ca9c1b2f1322789363", "log": "applied Bill's patch adding sinh, cosh and tanh functions to FastMath JIRA: MATH-375  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n     }\n \n     /** Compute the hyperbolic cosine of a number.\n-     * @param a number on which evaluation is done\n-     * @return hyperbolic cosine of a\n-     */\n-    public static double cosh(final double a) {\n-        return 0.5 * (FastMath.exp(a) + FastMath.exp(-a));\n+     * @param x number on which evaluation is done\n+     * @return hyperbolic cosine of x\n+     */\n+    public static double cosh(double x) {\n+      if (x != x) {\n+          return x;\n+      }\n+\n+      if (x > 20.0) {\n+          return exp(x)/2.0;\n+      }\n+\n+      if (x < -20) {\n+          return exp(-x)/2.0;\n+      }\n+\n+      double hiPrec[] = new double[2];\n+      if (x < 0.0) {\n+          x = -x;\n+      }\n+      exp(x, 0.0, hiPrec);\n+\n+      double ya = hiPrec[0] + hiPrec[1];\n+      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n+\n+      double temp = ya * 1073741824.0;\n+      double yaa = ya + temp - temp;\n+      double yab = ya - yaa;\n+\n+      // recip = 1/y\n+      double recip = 1.0/ya;\n+      temp = recip * 1073741824.0;\n+      double recipa = recip + temp - temp;\n+      double recipb = recip - recipa;\n+\n+      // Correct for rounding in division\n+      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n+      // Account for yb\n+      recipb += -yb * recip * recip;\n+\n+      // y = y + 1/y\n+      temp = ya + recipa;\n+      yb += -(temp - ya - recipa);\n+      ya = temp;\n+      temp = ya + recipb;\n+      yb += -(temp - ya - recipb);\n+      ya = temp;\n+\n+      double result = ya + yb;\n+      result *= 0.5;\n+      return result;\n     }\n \n     /** Compute the hyperbolic sine of a number.\n-     * @param a number on which evaluation is done\n-     * @return hyperbolic sine of a\n-     */\n-    public static double sinh(double a) {\n-\n-        boolean negative = false;\n-        if (a < 0) {\n-            negative = true;\n-            a = -a;\n-        }\n-\n-        double absSinh;\n-        if (a > 0.3) {\n-            absSinh = 0.5 * (FastMath.exp(a) - FastMath.exp(-a));\n-        } else {\n-            final double a2 = a * a;\n-            if (a > 0.05) {\n-                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 * (1 + a2 * (1 + a2 / 110) / 72) / 42) / 20) / 6);\n-            } else {\n-                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 / 42) / 20) / 6);\n-            }\n-        }\n-\n-        return negative ? -absSinh : absSinh;\n-\n+     * @param x number on which evaluation is done\n+     * @return hyperbolic sine of x\n+     */\n+    public static double sinh(double x) {\n+      boolean negate = false;\n+      if (x != x) {\n+          return x;\n+      }\n+\n+      if (x > 20.0) {\n+          return exp(x)/2.0;\n+      }\n+\n+      if (x < -20) {\n+          return -exp(-x)/2.0;\n+      }\n+\n+      if (x == 0) {\n+          return x;\n+      }\n+\n+      if (x < 0.0) {\n+          x = -x;\n+          negate = true;\n+      }\n+\n+      double result;\n+\n+      if (x > 0.25) {\n+          double hiPrec[] = new double[2];\n+          exp(x, 0.0, hiPrec);\n+\n+          double ya = hiPrec[0] + hiPrec[1];\n+          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n+\n+          double temp = ya * 1073741824.0;\n+          double yaa = ya + temp - temp;\n+          double yab = ya - yaa;\n+\n+          // recip = 1/y\n+          double recip = 1.0/ya;\n+          temp = recip * 1073741824.0;\n+          double recipa = recip + temp - temp;\n+          double recipb = recip - recipa;\n+\n+          // Correct for rounding in division\n+          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n+          // Account for yb\n+          recipb += -yb * recip * recip;\n+\n+          recipa = -recipa;\n+          recipb = -recipb;\n+\n+          // y = y + 1/y\n+          temp = ya + recipa;\n+          yb += -(temp - ya - recipa);\n+          ya = temp;\n+          temp = ya + recipb;\n+          yb += -(temp - ya - recipb);\n+          ya = temp;\n+\n+          result = ya + yb;\n+          result *= 0.5;\n+      }\n+      else {\n+          double hiPrec[] = new double[2];\n+          expm1(x, hiPrec);\n+\n+          double ya = hiPrec[0] + hiPrec[1];\n+          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n+\n+          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n+          double denom = 1.0+ya;\n+          double denomr = 1.0/denom;\n+          double denomb = -(denom - 1.0 - ya) + yb;\n+          double ratio = ya*denomr;\n+          double ra, rb;\n+          double temp = ratio * 1073741824.0;\n+          ra = ratio + temp - temp;\n+          rb = ratio - ra;\n+\n+          temp = denom * 1073741824.0;\n+          double za = denom + temp - temp;\n+          double zb = denom - za;\n+\n+          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n+\n+          // Adjust for yb\n+          rb += yb*denomr;                        // numerator\n+          rb += -ya * denomb * denomr * denomr;   // denominator\n+\n+          // y = y - 1/y\n+          temp = ya + ra;\n+          yb += -(temp - ya - ra);\n+          ya = temp;\n+          temp = ya + rb;\n+          yb += -(temp - ya - rb);\n+          ya = temp;\n+\n+          result = ya + yb;\n+          result *= 0.5;\n+      }\n+\n+      if (negate) {\n+          result = -result;\n+      }\n+\n+      return result;\n     }\n \n     /** Compute the hyperbolic tangent of a number.\n-     * @param a number on which evaluation is done\n-     * @return hyperbolic tangent of a\n-     */\n-    public static double tanh(double a) {\n-\n-        boolean negative = false;\n-        if (a < 0) {\n-            negative = true;\n-            a = -a;\n-        }\n-\n-        double absTanh;\n-        if (a > 0.074) {\n-            final double twoA = 2 * a;\n-            absTanh = FastMath.expm1(twoA) / (FastMath.exp(twoA) + 1);\n-        } else {\n-            final double a2 = a * a;\n-            if (a > 0.016) {\n-                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * (17 - a2 * (62 - a2 * 1382 / 55 ) / 9) / 21) / 5) / 3);\n-            } else {\n-                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * 17 / 21) / 5) / 3);\n-            }\n-        }\n-\n-        return negative ? -absTanh : absTanh;\n-\n+     * @param x number on which evaluation is done\n+     * @return hyperbolic tangent of x\n+     */\n+    public static double tanh(double x) {\n+      boolean negate = false;\n+\n+      if (x != x) {\n+          return x;\n+      }\n+\n+      if (x > 20.0) {\n+          return 1.0;\n+      }\n+\n+      if (x < -20) {\n+          return -1.0;\n+      }\n+\n+      if (x == 0) {\n+          return x;\n+      }\n+\n+      if (x < 0.0) {\n+          x = -x;\n+          negate = true;\n+      }\n+\n+      double result;\n+      if (x >= 0.5) {\n+          double hiPrec[] = new double[2];\n+          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n+          exp(x*2.0, 0.0, hiPrec);\n+\n+          double ya = hiPrec[0] + hiPrec[1];\n+          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n+\n+          /* Numerator */\n+          double na = -1.0 + ya;\n+          double nb = -(na + 1.0 - ya);\n+          double temp = na + yb;\n+          nb += -(temp - na - yb);\n+          na = temp;\n+\n+          /* Denominator */\n+          double da = 1.0 + ya;\n+          double db = -(da - 1.0 - ya);\n+          temp = da + yb;\n+          db += -(temp - da - yb);\n+          da = temp;\n+\n+          temp = da * 1073741824.0;\n+          double daa = da + temp - temp;\n+          double dab = da - daa;\n+\n+          // ratio = na/da\n+          double ratio = na/da;\n+          temp = ratio * 1073741824.0;\n+          double ratioa = ratio + temp - temp;\n+          double ratiob = ratio - ratioa;\n+\n+          // Correct for rounding in division\n+          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n+\n+          // Account for nb\n+          ratiob += nb / da;\n+          // Account for db\n+          ratiob += -db * na / da / da;\n+\n+          result = ratioa + ratiob;\n+      }\n+      else {\n+          double hiPrec[] = new double[2];\n+          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n+          expm1(x*2.0, hiPrec);\n+\n+          double ya = hiPrec[0] + hiPrec[1];\n+          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n+\n+          /* Numerator */\n+          double na = ya;\n+          double nb = yb;\n+\n+          /* Denominator */\n+          double da = 2.0 + ya;\n+          double db = -(da - 2.0 - ya);\n+          double temp = da + yb;\n+          db += -(temp - da - yb);\n+          da = temp;\n+\n+          temp = da * 1073741824.0;\n+          double daa = da + temp - temp;\n+          double dab = da - daa;\n+\n+          // ratio = na/da\n+          double ratio = na/da;\n+          temp = ratio * 1073741824.0;\n+          double ratioa = ratio + temp - temp;\n+          double ratiob = ratio - ratioa;\n+\n+          // Correct for rounding in division\n+          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n+\n+          // Account for nb\n+          ratiob += nb / da;\n+          // Account for db\n+          ratiob += -db * na / da / da;\n+\n+          result = ratioa + ratiob;\n+      }\n+      \n+      if (negate) {\n+          result = -result;\n+      }\n+\n+      return result;\n     }\n \n     /** Compute the inverse hyperbolic cosine of a number.\n      * @return exp(x) - 1\n      */\n     public static double expm1(double x) {\n+      return expm1(x, null);\n+    }\n+\n+    /** Internal helper method for expm1\n+     * @param x number to compute shifted exponential\n+     * @param hiPrecOut[] receive high precision result for -1.0 < x < 1.0\n+     * @return exp(x) - 1\n+     */\n+    private static double expm1(double x, double hiPrecOut[]) {\n         if (x != x || x == 0.0) { // NaN or zero\n             return x;\n         }\n             ya = -ra;\n             yb = -rb;\n         }\n+\n+\tif (hiPrecOut != null) {\n+\t  hiPrecOut[0] = ya;\n+\t  hiPrecOut[1] = yb;\n+\t}\n \n         return ya + yb;\n     }\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n         Assert.assertTrue(\"acos() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n     }\n \n+    private Dfp cosh(Dfp x) {\n+      return DfpMath.exp(x).add(DfpMath.exp(x.negate())).divide(2);\n+    }\n+\n+    private Dfp sinh(Dfp x) {\n+      return DfpMath.exp(x).subtract(DfpMath.exp(x.negate())).divide(2);\n+    }\n+\n+    private Dfp tanh(Dfp x) {\n+      return sinh(x).divide(cosh(x));\n+    }\n+\n+    @Test\n+    public void testSinhAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i=0; i<10000; i++) {\n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); \n+\n+            double tst = FastMath.sinh(x);\n+            double ref = sinh(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"sinh() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testCoshAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i=0; i<10000; i++) {\n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); \n+\n+            double tst = FastMath.cosh(x);\n+            double ref = cosh(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"cosh() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testTanhAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i=0; i<10000; i++) {\n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); \n+\n+            double tst = FastMath.tanh(x);\n+            double ref = tanh(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"tanh() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n     @Test\n     public void testCbrtAccuracy() {\n         double maxerrulp = 0.0;\n             time = System.currentTimeMillis() - time;\n             System.out.println(\"FastMath.cbrt \" + time + \"\\t\" + x);\n \n-           x = 0;\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.cosh(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.cosh \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.cosh(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.cosh \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.sinh(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.sinh \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.sinh(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.sinh \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.tanh(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.tanh \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.tanh(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.tanh \" + time + \"\\t\" + x);\n+\n+            x = 0;\n             time = System.currentTimeMillis();\n             for (int i = 0; i < numberOfRuns; i++)\n                 x += StrictMath.expm1(-i / 100000.0);", "timestamp": 1286139074, "metainfo": ""}