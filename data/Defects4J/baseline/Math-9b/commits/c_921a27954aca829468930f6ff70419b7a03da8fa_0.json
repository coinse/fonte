{"sha": "921a27954aca829468930f6ff70419b7a03da8fa", "log": "added the ode package from Mantissa  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/AbstractStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/** This abstract class represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects extending this class\n+ * to the step handlers. The handlers can use these objects to\n+ * retrieve the state vector at intermediate times between the\n+ * previous and the current grid points (dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ *\n+ * @version $Id: AbstractStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public abstract class AbstractStepInterpolator\n+  implements StepInterpolator, Cloneable {\n+\n+  /** previous time */\n+  protected double previousTime;\n+\n+  /** current time */\n+  protected double currentTime;\n+\n+  /** current time step */\n+  protected double h;\n+\n+  /** current state */\n+  protected double[] currentState;\n+\n+  /** interpolated time */\n+  protected double interpolatedTime;\n+\n+  /** interpolated state */\n+  protected double[] interpolatedState;\n+\n+  /** indicate if the step has been finalized or not. */\n+  private boolean finalized;\n+\n+  /** integration direction. */\n+  private boolean forward;\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. As an example, the {@link\n+   * RungeKuttaFehlbergIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  protected AbstractStepInterpolator() {\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+    currentState      = null;\n+    interpolatedState = null;\n+    finalized         = false;\n+    this.forward      = true;\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected AbstractStepInterpolator(double[] y, boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState      = y;\n+    interpolatedState = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** Copy constructor.\n+\n+   * <p>The copied interpolator should have been finalized before the\n+   * copy, otherwise the copy will not be able to perform correctly\n+   * any derivative computation and will throw a {@link\n+   * NullPointerException} later. Since we don't want this constructor\n+   * to throw the exceptions finalization may involve and since we\n+   * don't want this method to modify the state of the copied\n+   * interpolator, finalization is <strong>not</strong> done\n+   * automatically, it remains under user control.</p>\n+\n+   * <p>The copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance.</p>\n+\n+   * @param interpolator interpolator to copy from.\n+\n+   */\n+  protected AbstractStepInterpolator(AbstractStepInterpolator interpolator) {\n+\n+    previousTime      = interpolator.previousTime;\n+    currentTime       = interpolator.currentTime;\n+    h                 = interpolator.h;\n+    interpolatedTime  = interpolator.interpolatedTime;\n+\n+    if (interpolator.currentState != null) {\n+      currentState      = (double[]) interpolator.currentState.clone();\n+      interpolatedState = (double[]) interpolator.interpolatedState.clone();\n+    } else {\n+      currentState      = null;\n+      interpolatedState = null;\n+    }\n+\n+    finalized = interpolator.finalized;\n+    forward   = interpolator.forward;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected void reinitialize(double[] y, boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState      = y;\n+    interpolatedState = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** Copy the instance.\n+\n+  * <p>The copied interpolator should have been finalized before the\n+  * copy, otherwise the copy will not be able to perform correctly any\n+  * interpolation and will throw a {@link NullPointerException}\n+  * later. Since we don't want this constructor to throw the\n+  * exceptions finalization may involve and since we don't want this\n+  * method to modify the state of the copied interpolator,\n+  * finalization is <strong>not</strong> done automatically, it\n+  * remains under user control.</p>\n+\n+  * <p>The copy is a deep copy: its arrays are separated from the\n+  * original arrays of the instance.</p>\n+\n+  * <p>This method has been redeclared as public instead of protected.</p>\n+\n+  * @return a copy of the instance.\n+\n+  */\n+  public Object clone() {\n+    try {\n+      return super.clone();\n+    } catch (CloneNotSupportedException cnse) {\n+      // should never happen\n+      return null;\n+    }\n+  }\n+\n+  /** Shift one step forward.\n+   * Copy the current time into the previous time, hence preparing the\n+   * interpolator for future calls to {@link #storeTime storeTime}\n+   */\n+  public void shift() {\n+    previousTime = currentTime;\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(double t) {\n+\n+    currentTime      = t;\n+    h                = currentTime - previousTime;\n+    interpolatedTime = t;\n+    System.arraycopy(currentState, 0, interpolatedState, 0,\n+                     currentState.length);\n+\n+    // the step is not finalized anymore\n+    finalized = false;\n+\n+  }\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime() {\n+    return previousTime;\n+  }\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime() {\n+    return currentTime;\n+  }\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime() {\n+    return interpolatedTime;\n+  }\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed\n+   * (it was not allowed up to version 5.4 of Mantissa), but should be\n+   * used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * @param time time of the interpolated point\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public void setInterpolatedTime(double time)\n+    throws DerivativeException {\n+    interpolatedTime = time;\n+    double oneMinusThetaH = currentTime - interpolatedTime;\n+    computeInterpolatedState((h - oneMinusThetaH) / h, oneMinusThetaH);\n+  }\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by the\n+   * integrator itself, it avoid some nasty problems in degenerated\n+   * cases like null steps due to cancellation at step initialization,\n+   * step control or switching function triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward() {\n+    return forward;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected abstract void computeInterpolatedState(double theta,\n+                                                   double oneMinusThetaH)\n+    throws DerivativeException;\n+    \n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState() {\n+    return (double[]) interpolatedState.clone();\n+  }\n+\n+\n+  /**\n+   * Finalize the step.\n+\n+   * <p>Some Runge-Kutta-Fehlberg integrators need fewer functions\n+   * evaluations than their counterpart step interpolators. These\n+   * interpolators should perform the last evaluations they need by\n+   * themselves only if they need them. This method triggers these\n+   * extra evaluations. It can be called directly by the user step\n+   * handler and it is called automatically if {@link\n+   * #setInterpolatedTime} is called.</p>\n+\n+   * <p>Once this method has been called, <strong>no</strong> other\n+   * evaluation will be performed on this step. If there is a need to\n+   * have some side effects between the step handler and the\n+   * differential equations (for example update some data in the\n+   * equations once the step has been done), it is advised to call\n+   * this method explicitly from the step handler before these side\n+   * effects are set up. If the step handler induces no side effect,\n+   * then this method can safely be ignored, it will be called\n+   * transparently as needed.</p>\n+\n+   * <p><strong>Warning</strong>: since the step interpolator provided\n+   * to the step handler as a parameter of the {@link\n+   * StepHandler#handleStep handleStep} is valid only for the duration\n+   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n+   * simply store a reference and reuse it later. One should first\n+   * finalize the instance, then copy this finalized instance into a\n+   * new object that can be kept.</p>\n+\n+   * <p>This method calls the protected {@link #doFinalize doFinalize}\n+   * method if it has never been called during this step and set a\n+   * flag indicating that it has been called once. It is the {@link\n+   * #doFinalize doFinalize} method which should perform the\n+   * evaluations. This wrapping prevents from calling {@link\n+   * #doFinalize doFinalize} several times and hence evaluating the\n+   * differential equations too often. Therefore, subclasses are not\n+   * allowed not reimplement it, they should rather reimplement {@link\n+   * #doFinalize doFinalize}.</p>\n+\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+\n+   */\n+  public final void finalizeStep()\n+    throws DerivativeException {\n+    if (! finalized) {\n+      doFinalize();\n+      finalized = true;\n+    }\n+  }\n+\n+  /**\n+   * Really finalize the step.\n+   * The default implementation of this method does nothing.\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+  }\n+\n+  public abstract void writeExternal(ObjectOutput out)\n+    throws IOException;\n+\n+  public abstract void readExternal(ObjectInput in)\n+    throws IOException;\n+\n+  /** Save the base state of the instance.\n+   * This method performs step finalization if it has not been done\n+   * before.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  protected void writeBaseExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    out.writeInt(currentState.length);\n+    out.writeDouble(previousTime);\n+    out.writeDouble(currentTime);\n+    out.writeDouble(h);\n+    out.writeBoolean(forward);\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(currentState[i]);\n+    }\n+\n+    out.writeDouble(interpolatedTime);\n+\n+    // we do not store the interpolated state,\n+    // it will be recomputed as needed after reading\n+\n+    // finalize the step (and don't bother saving the now true flag)\n+    try {\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Read the base state of the instance.\n+   * This method does <strong>neither</strong> set the interpolated\n+   * time nor state. It is up to the derived class to reset it\n+   * properly calling the {@link #setInterpolatedTime} method later,\n+   * once all rest of the object state has been set up properly.\n+   * @param in stream where to read the state from\n+   * @return interpolated time be set later by the caller\n+   * @exception IOException in case of read error\n+   */\n+  protected double readBaseExternal(ObjectInput in)\n+    throws IOException {\n+\n+    int dimension = in.readInt();\n+    previousTime  = in.readDouble();\n+    currentTime   = in.readDouble();\n+    h             = in.readDouble();\n+    forward       = in.readBoolean();\n+\n+    currentState  = new double[dimension];\n+    for (int i = 0; i < currentState.length; ++i) {\n+      currentState[i] = in.readDouble();\n+    }\n+\n+    // we do NOT handle the interpolated time and state here\n+    interpolatedTime  = Double.NaN;\n+    interpolatedState = new double[dimension];\n+\n+    finalized = true;\n+\n+    return in.readDouble();\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This abstract class holds the common part of all adaptive\n+ * stepsize integrators for Ordinary Differential Equations.\n+\n+ * <p>These algorithms perform integration with stepsize control, which\n+ * means the user does not specify the integration step but rather a\n+ * tolerance on error. The error threshold is computed as\n+ * <pre>\n+ * threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))\n+ * </pre>\n+ * where absTol_i is the absolute tolerance for component i of the\n+ * state vector and relTol_i is the relative tolerance for the same\n+ * component. The user can also use only two scalar values absTol and\n+ * relTol which will be used for all components.</p>\n+\n+ * <p>If the estimated error for ym+1 is such that\n+ * <pre>\n+ * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1\n+ * </pre>\n+\n+ * (where n is the state vector dimension) then the step is accepted,\n+ * otherwise the step is rejected and a new attempt is made with a new\n+ * stepsize.</p>\n+\n+ * @version $Id: AdaptiveStepsizeIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class AdaptiveStepsizeIntegrator\n+  implements FirstOrderIntegrator {\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(double minStep, double maxStep,\n+                                    double scalAbsoluteTolerance,\n+                                    double scalRelativeTolerance) {\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n+    this.scalRelativeTolerance = scalRelativeTolerance;\n+    this.vecAbsoluteTolerance  = null;\n+    this.vecRelativeTolerance  = null;\n+\n+    // set the default step handler\n+    handler = DummyStepHandler.getInstance();\n+\n+    switchesHandler = new SwitchingFunctionsHandler();\n+\n+  }\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(double minStep, double maxStep,\n+                                    double[] vecAbsoluteTolerance,\n+                                    double[] vecRelativeTolerance) {\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = 0;\n+    this.scalRelativeTolerance = 0;\n+    this.vecAbsoluteTolerance  = vecAbsoluteTolerance;\n+    this.vecRelativeTolerance  = vecRelativeTolerance;\n+\n+    // set the default step handler\n+    handler = DummyStepHandler.getInstance();\n+\n+    switchesHandler = new SwitchingFunctionsHandler();\n+\n+  }\n+\n+  /** Set the initial step size.\n+   * <p>This method allows the user to specify an initial positive\n+   * step size instead of letting the integrator guess it by\n+   * itself. If this method is not called before integration is\n+   * started, the initial step size will be estimated by the\n+   * integrator.</p>\n+   * @param initialStepSize initial step size to use (must be positive even\n+   * for backward integration ; providing a negative value or a value\n+   * outside of the min/max step interval will lead the integrator to\n+   * ignore the value and compute the initial step size by itself)\n+   */\n+  public void setInitialStepSize(double initialStepSize) {\n+    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+      initialStep = -1.0;\n+    } else {\n+      initialStep = initialStepSize;\n+    }\n+  }\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler) {\n+    this.handler = handler;\n+  }\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler() {\n+    return handler;\n+  }\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence) {\n+    switchesHandler.add(function, maxCheckInterval, convergence);\n+  }\n+\n+  /** Initialize the integration step.\n+   * @param equations differential equations set\n+   * @param forward forward integration indicator\n+   * @param order order of the method\n+   * @param scale scaling vector for the state vector\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param yDot0 first time derivative of y0\n+   * @param y1 work array for a state vector\n+   * @param yDot1 work array for the first time derivative of y1\n+   * @return first integration step\n+   * @exception DerivativeException this exception is propagated to\n+   * the caller if the underlying user function triggers one\n+   */\n+  public double initializeStep(FirstOrderDifferentialEquations equations,\n+                               boolean forward, int order, double[] scale,\n+                               double t0, double[] y0, double[] yDot0,\n+                               double[] y1, double[] yDot1)\n+    throws DerivativeException {\n+\n+    if (initialStep > 0) {\n+      // use the user provided value\n+      return forward ? initialStep : -initialStep;\n+    }\n+\n+    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n+    // this guess will be used to perform an Euler step\n+    double ratio;\n+    double yOnScale2 = 0;\n+    double yDotOnScale2 = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = y0[j] / scale[j];\n+      yOnScale2    += ratio * ratio;\n+      ratio         = yDot0[j] / scale[j];\n+      yDotOnScale2 += ratio * ratio;\n+    }\n+\n+    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10))\n+      ? 1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    // perform an Euler step using the preceding rough guess\n+    for (int j = 0; j < y0.length; ++j) {\n+      y1[j] = y0[j] + h * yDot0[j];\n+    }\n+    equations.computeDerivatives(t0 + h, y1, yDot1);\n+\n+    // estimate the second derivative of the solution\n+    double yDDotOnScale = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n+      yDDotOnScale += ratio * ratio;\n+    }\n+    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n+\n+    // step size is computed such that\n+    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n+    double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n+    double h1 = (maxInv2 < 1.0e-15)\n+      ? Math.max(1.0e-6, 0.001 * Math.abs(h))\n+      : Math.pow(0.01 / maxInv2, 1.0 / order);\n+    h = Math.min(100.0 * Math.abs(h), h1);\n+    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n+    if (h < getMinStep()) {\n+      h = getMinStep();\n+    }\n+    if (h > getMaxStep()) {\n+      h = getMaxStep();\n+    }\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    return h;\n+\n+  }\n+\n+  /** Filter the integration step.\n+   * @param h signed step\n+   * @param acceptSmall if true, steps smaller than the minimal value\n+   * are silently increased up to this value, if false such small\n+   * steps generate an exception\n+   * @return a bounded integration step (h if no bound is reach, or a bounded value)\n+   * @exception IntegratorException if the step is too small and acceptSmall is false\n+   */\n+  protected double filterStep(double h, boolean acceptSmall)\n+    throws IntegratorException {\n+\n+    if (Math.abs(h) < minStep) {\n+      if (acceptSmall) {\n+        h = (h < 0) ? -minStep : minStep;\n+      } else {\n+        throw new IntegratorException(\"minimal step size ({0}) reached,\"\n+                                      + \" integration needs {1}\",\n+                                      new String[] {\n+                                        Double.toString(minStep),\n+                                        Double.toString(Math.abs(h))\n+                                      });\n+      }\n+    }\n+\n+    if (h > maxStep) {\n+      h = maxStep;\n+    } else if (h < -maxStep) {\n+      h = -maxStep;\n+    }\n+\n+    return h;\n+\n+  }\n+\n+  public abstract void integrate (FirstOrderDifferentialEquations equations,\n+                                  double t0, double[] y0,\n+                                  double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+  /** Get the minimal step.\n+   * @return minimal step\n+   */\n+  public double getMinStep() {\n+    return minStep;\n+  }\n+\n+  /** Get the maximal step.\n+   * @return maximal step\n+   */\n+  public double getMaxStep() {\n+    return maxStep;\n+  }\n+\n+  /** Minimal step. */\n+  private double minStep;\n+\n+  /** Maximal step. */\n+  private double maxStep;\n+\n+  /** User supplied initial step. */\n+  private double initialStep;\n+\n+  /** Allowed absolute scalar error. */\n+  protected double scalAbsoluteTolerance;\n+\n+  /** Allowed relative scalar error. */\n+  protected double scalRelativeTolerance;\n+\n+  /** Allowed absolute vectorial error. */\n+  protected double[] vecAbsoluteTolerance;\n+\n+  /** Allowed relative vectorial error. */\n+  protected double[] vecRelativeTolerance;\n+\n+  /** Step handler. */\n+  protected StepHandler handler;\n+\n+  /** Switching functions handler. */\n+  protected SwitchingFunctionsHandler switchesHandler;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the classical fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations (it is the most\n+ * often used Runge-Kutta method).\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/2 | 1/2   0    0    0\n+ *   1/2 |  0   1/2   0    0\n+ *    1  |  0    0    1    0\n+ *       |--------------------\n+ *       | 1/6  1/3  1/3  1/6\n+ * </pre>\n+ * </p>\n+\n+ * @see EulerIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: ClassicalRungeKuttaIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ClassicalRungeKuttaIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = \"classical Runge-Kutta\";\n+\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { 0.0, 1.0 / 2.0 },\n+    { 0.0, 0.0, 1.0 }\n+  };\n+\n+  private static final double[] b = {\n+    1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Runge-Kutta integrator with the given\n+   * step.\n+   * @param step integration step\n+   */\n+  public ClassicalRungeKuttaIntegrator(double step) {\n+    super(false, c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a step interpolator for the classical fourth\n+ * order Runge-Kutta integrator.\n+\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    + (1 - theta) (h/6) [ (-4 theta^2 + 5 theta - 1) y'_1\n+ *                                          +(4 theta^2 - 2 theta - 2) (y'_2 + y'_3)\n+ *                                          -(4 theta^2 +   theta + 1) y'_4\n+ *                                        ]\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+\n+ * @see ClassicalRungeKuttaIntegrator\n+\n+ * @version $Id: ClassicalRungeKuttaStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class ClassicalRungeKuttaStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link RungeKuttaStepInterpolator#reinitialize} method should be\n+   * called before using the instance in order to initialize the\n+   * internal arrays. This constructor is used only in order to delay\n+   * the initialization in some cases. The {@link RungeKuttaIntegrator}\n+   * class uses the prototyping design pattern to create the step\n+   * interpolators by cloning an uninitialized model and latter initializing\n+   * the copy.\n+   */\n+  public ClassicalRungeKuttaStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public ClassicalRungeKuttaStepInterpolator(ClassicalRungeKuttaStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new ClassicalRungeKuttaStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double fourTheta = 4 * theta;\n+    double s         = oneMinusThetaH / 6.0;\n+    double coeff1    = s * ((-fourTheta + 5) * theta - 1);\n+    double coeff23   = s * (( fourTheta - 2) * theta - 2);\n+    double coeff4    = s * ((-fourTheta - 1) * theta - 1);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                            + coeff1  * yDotK[0][i]\n+                            + coeff23 * (yDotK[1][i] + yDotK[2][i])\n+                            + coeff4  * yDotK[3][i];\n+     }\n+\n+  }\n+\n+  private static final long serialVersionUID = -6576285612589783992L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.io.Serializable;\n+\n+/**\n+ * This class stores all information provided by an ODE integrator\n+ * during the integration process and build a continuous model of the\n+ * solution from this.\n+\n+ * <p>This class act as a step handler from the integrator point of\n+ * view. It is called iteratively during the integration process and\n+ * stores a copy of all steps information in a sorted collection for\n+ * later use. Once the integration process is over, the user can use\n+ * the {@link #setInterpolatedTime setInterpolatedTime} and {@link\n+ * #getInterpolatedState getInterpolatedState} to retrieve this\n+ * information at any time. It is important to wait for the\n+ * integration to be over before attempting to call {@link\n+ * #setInterpolatedTime setInterpolatedTime} because some internal\n+ * variables are set only once the last step has been handled.</p>\n+\n+ * <p>This is useful for example if the main loop of the user\n+ * application should remain independant from the integration process\n+ * or if one needs to mimic the behaviour of an analytical model\n+ * despite a numerical model is used (i.e. one needs the ability to\n+ * get the model value at any time or to navigate through the\n+ * data).</p>\n+\n+ * <p>If problem modelization is done with several separate\n+ * integration phases for contiguous intervals, the same\n+ * ContinuousOutputModel can be used as step handler for all\n+ * integration phases as long as they are performed in order and in\n+ * the same direction. As an example, one can extrapolate the\n+ * trajectory of a satellite with one model (i.e. one set of\n+ * differential equations) up to the beginning of a maneuver, use\n+ * another more complex model including thrusters modelization and\n+ * accurate attitude control during the maneuver, and revert to the\n+ * first model after the end of the maneuver. If the same continuous\n+ * output model handles the steps of all integration phases, the user\n+ * do not need to bother when the maneuver begins or ends, he has all\n+ * the data available in a transparent manner.</p>\n+\n+ * <p>An important feature of this class is that it implements the\n+ * <code>Serializable</code> interface. This means that the result of\n+ * an integration can be serialized and reused later (if stored into a\n+ * persistent medium like a filesystem or a database) or elsewhere (if\n+ * sent to another application). Only the result of the integration is\n+ * stored, there is no reference to the integrated problem by\n+ * itself.</p>\n+\n+ * <p>One should be aware that the amount of data stored in a\n+ * ContinuousOutputModel instance can be important if the state vector\n+ * is large, if the integration interval is long or if the steps are\n+ * small (which can result from small tolerance settings in {@link\n+ * AdaptiveStepsizeIntegrator adaptive step size integrators}).</p>\n+\n+ * @see StepHandler\n+ * @see StepInterpolator\n+\n+ * @version $Id: ContinuousOutputModel.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ContinuousOutputModel\n+  implements StepHandler, Serializable {\n+\n+  /** Simple constructor.\n+   * Build an empty continuous output model.\n+   */\n+  public ContinuousOutputModel() {\n+    steps = new ArrayList();\n+    reset();\n+  }\n+\n+  /** Append another model at the end of the instance.\n+   * @param model model to add at the end of the instance\n+   * @exception IllegalArgumentException if the model to append is not\n+   * compatible with the instance (dimension of the state vector,\n+   * propagation direction, hole between the dates)\n+   */\n+  public void append(ContinuousOutputModel model) {\n+\n+    if (model.steps.size() == 0) {\n+      return;\n+    }\n+\n+    if (steps.size() == 0) {\n+      initialTime = model.initialTime;\n+      forward     = model.forward;\n+    } else {\n+\n+      if (getInterpolatedState().length != model.getInterpolatedState().length) {\n+        throw new IllegalArgumentException(\"state vector dimension mismatch\");\n+      }\n+\n+      if (forward ^ model.forward) {\n+        throw new IllegalArgumentException(\"propagation direction mismatch\");\n+      }\n+\n+      StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);\n+      double current  = lastInterpolator.getCurrentTime();\n+      double previous = lastInterpolator.getPreviousTime();\n+      double step = current - previous;\n+      double gap = model.getInitialTime() - current;\n+      if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n+        throw new IllegalArgumentException(\"hole between time ranges\");\n+      }\n+\n+    }\n+\n+    for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {\n+      AbstractStepInterpolator ai = (AbstractStepInterpolator) iter.next();\n+      steps.add(ai.clone());\n+    }\n+\n+    index = steps.size() - 1;\n+    finalTime = ((StepInterpolator) steps.get(index)).getCurrentTime();\n+\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>The essence of this class is to provide dense output over all\n+   * steps, hence it requires the internal steps to provide themselves\n+   * dense output. The method therefore returns always true.</p>\n+   * @return always true\n+   */\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+    initialTime = Double.NaN;\n+    finalTime   = Double.NaN;\n+    forward     = true;\n+    index       = 0;\n+    steps.clear();\n+   }\n+\n+  /** Handle the last accepted step.\n+   * A copy of the information provided by the last step is stored in\n+   * the instance for later use.\n+   * @param interpolator interpolator for the last accepted step.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException {\n+\n+    AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;\n+\n+    if (steps.size() == 0) {\n+      initialTime = interpolator.getPreviousTime();\n+      forward     = interpolator.isForward();\n+    }\n+\n+    ai.finalizeStep();\n+    steps.add(ai.clone());\n+\n+    if (isLast) {\n+      finalTime = ai.getCurrentTime();\n+      index     = steps.size() - 1;\n+    }\n+\n+  }\n+\n+  /**\n+   * Get the initial integration time.\n+   * @return initial integration time\n+   */\n+  public double getInitialTime() {\n+    return initialTime;\n+  }\n+    \n+  /**\n+   * Get the final integration time.\n+   * @return final integration time\n+   */\n+  public double getFinalTime() {\n+    return finalTime;\n+  }\n+\n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the final integration time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime() {\n+    return ((StepInterpolator) steps.get(index)).getInterpolatedTime();\n+  }\n+    \n+  /** Set the time of the interpolated point.\n+   * <p>This method should <strong>not</strong> be called before the\n+   * integration is over because some internal variables are set only\n+   * once the last step has been handled.</p>\n+   * <p>Setting the time outside of the integration interval is now\n+   * allowed (it was not allowed up to version 5.9 of Mantissa), but\n+   * should be used with care since the accuracy of the interpolator\n+   * will probably be very poor far from this interval. This allowance\n+   * has been added to simplify implementation of search algorithms\n+   * near the interval endpoints.</p>\n+   * @param time time of the interpolated point\n+   */\n+  public void setInterpolatedTime(double time) {\n+\n+    try {\n+      // initialize the search with the complete steps table\n+      int iMin = 0;\n+      StepInterpolator sMin = (StepInterpolator) steps.get(iMin);\n+      double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());\n+\n+      int iMax = steps.size() - 1;\n+      StepInterpolator sMax = (StepInterpolator) steps.get(iMax);\n+      double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());\n+\n+      // handle points outside of the integration interval\n+      // or in the first and last step\n+      if (locatePoint(time, sMin) <= 0) {\n+        index = iMin;\n+        sMin.setInterpolatedTime(time);\n+        return;\n+      }\n+      if (locatePoint(time, sMax) >= 0) {\n+        index = iMax;\n+        sMax.setInterpolatedTime(time);\n+        return;\n+      }\n+\n+      // reduction of the table slice size\n+      while (iMax - iMin > 5) {\n+\n+        // use the last estimated index as the splitting index\n+        StepInterpolator si = (StepInterpolator) steps.get(index);\n+        int location = locatePoint(time, si);\n+        if (location < 0) {\n+          iMax = index;\n+          tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n+        } else if (location > 0) {\n+          iMin = index;\n+          tMin = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n+        } else {\n+          // we have found the target step, no need to continue searching\n+          si.setInterpolatedTime(time);\n+          return;\n+        }\n+\n+        // compute a new estimate of the index in the reduced table slice\n+        int iMed = (iMin + iMax) / 2;\n+        StepInterpolator sMed = (StepInterpolator) steps.get(iMed);\n+        double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n+\n+        if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {\n+          // too close to the bounds, we estimate using a simple dichotomy\n+          index = iMed;\n+        } else {\n+          // estimate the index using a reverse quadratic polynom\n+          // (reverse means we have i = P(t), thus allowing to simply\n+          // compute index = P(time) rather than solving a quadratic equation)\n+          double d12 = tMax - tMed;\n+          double d23 = tMed - tMin;\n+          double d13 = tMax - tMin;\n+          double dt1 = time - tMax;\n+          double dt2 = time - tMed;\n+          double dt3 = time - tMin;\n+          double iLagrange = (  (dt2 * dt3 * d23) * iMax\n+                              - (dt1 * dt3 * d13) * iMed\n+                              + (dt1 * dt2 * d12) * iMin)\n+                           / (d12 * d23 * d13);\n+          index = (int) Math.rint(iLagrange);\n+        }\n+\n+        // force the next size reduction to be at least one tenth\n+        int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n+        int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n+        if (index < low) {\n+          index = low;\n+        } else if (index > high) {\n+          index = high;\n+        }\n+\n+      }\n+\n+      // now the table slice is very small, we perform an iterative search\n+      index = iMin;\n+      while ((index <= iMax)\n+             && (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {\n+        ++index;\n+      }\n+\n+      StepInterpolator si = (StepInterpolator) steps.get(index);\n+\n+      si.setInterpolatedTime(time);\n+\n+    } catch (DerivativeException de) {\n+      throw new RuntimeException(\"unexpected DerivativeException caught: \"\n+                                 + de.getMessage());\n+    }\n+\n+  }\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState() {\n+    return ((StepInterpolator) steps.get(index)).getInterpolatedState();\n+  }\n+\n+  /** Compare a step interval and a double. \n+   * @param time point to locate\n+   * @param interval step interval\n+   * @return -1 if the double is before the interval, 0 if it is in\n+   * the interval, and +1 if it is after the interval, according to\n+   * the interval direction\n+   */\n+  private int locatePoint(double time, StepInterpolator interval) {\n+    if (forward) {\n+      if (time < interval.getPreviousTime()) {\n+        return -1;\n+      } else if (time > interval.getCurrentTime()) {\n+        return +1;\n+      } else {\n+        return 0;\n+      }\n+    }\n+    if (time > interval.getPreviousTime()) {\n+      return -1;\n+    } else if (time < interval.getCurrentTime()) {\n+      return +1;\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  /** Initial integration time. */\n+  private double initialTime;\n+\n+  /** Final integration time. */\n+  private double finalTime;\n+\n+  /** Integration direction indicator. */\n+  private boolean forward;\n+\n+  /** Current interpolator index. */\n+  private int index;\n+\n+  /** Steps table. */\n+  private ArrayList steps;\n+\n+  private static final long serialVersionUID = 2259286184268533249L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/DerivativeException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are trigegred while computing\n+ * the differential equations.\n+ * @author Luc Maisonobe\n+ * @version $Id: DerivativeException.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public class DerivativeException\n+  extends MathException {\n+    \n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public DerivativeException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  /** Build an instance from an underlying cause.\n+   * @param cause cause for the exception\n+   */\n+  public DerivativeException(Throwable cause) {\n+    super(cause);\n+  }\n+\n+  private static final long serialVersionUID = -4100440615830558122L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54Integrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the 5(4) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step. However, since this\n+ * is an <i>fsal</i>, the last evaluation of one step is the same as\n+ * the first evaluation of the next step and hence can be avoided. So\n+ * the cost is really 6 functions evaluations per step.</p>\n+\n+ * <p>This method has been published (whithout the continuous output\n+ * that was added by Shampine in 1986) in the following article :\n+ * <pre>\n+ *  A family of embedded Runge-Kutta formulae\n+ *  J. R. Dormand and P. J. Prince\n+ *  Journal of Computational and Applied Mathematics\n+ *  volume 6, no 1, 1980, pp. 19-26\n+ * </pre></p>\n+\n+ * @version $Id: DormandPrince54Integrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class DormandPrince54Integrator\n+  extends RungeKuttaFehlbergIntegrator {\n+\n+  private static final String methodName = \"Dormand-Prince 5(4)\";\n+\n+  private static final double[] c = {\n+    1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    {1.0/5.0},\n+    {3.0/40.0, 9.0/40.0},\n+    {44.0/45.0, -56.0/15.0, 32.0/9.0},\n+    {19372.0/6561.0, -25360.0/2187.0, 64448.0/6561.0,  -212.0/729.0},\n+    {9017.0/3168.0, -355.0/33.0, 46732.0/5247.0, 49.0/176.0, -5103.0/18656.0},\n+    {35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0}\n+  };\n+\n+  private static final double[] b = {\n+    35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0\n+  };\n+\n+  private static final double e1 =     71.0 / 57600.0;\n+  private static final double e3 =    -71.0 / 16695.0;\n+  private static final double e4 =     71.0 / 1920.0;\n+  private static final double e5 = -17253.0 / 339200.0;\n+  private static final double e6 =     22.0 / 525.0;\n+  private static final double e7 =     -1.0 / 40.0;\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(double minStep, double maxStep,\n+                                   double scalAbsoluteTolerance,\n+                                   double scalRelativeTolerance) {\n+    super(true, c, a, b, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(double minStep, double maxStep,\n+                                   double[] vecAbsoluteTolerance,\n+                                   double[] vecRelativeTolerance) {\n+    super(true, c, a, b, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected double estimateError(double[][] yDotK,\n+                                 double[] y0, double[] y1,\n+                                 double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j]\n+                    + e4 * yDotK[3][j] +  e5 * yDotK[4][j]\n+                    + e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n+\n+      double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      double tol = (vecAbsoluteTolerance == null)\n+        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n+        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double ratio  = h * errSum / tol;\n+      error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince54Integrator\n+ *\n+ * @version $Id: DormandPrince54StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+class DormandPrince54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince54StepInterpolator() {\n+    super();\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince54StepInterpolator(DormandPrince54StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.v1 == null) {\n+\n+      v1 = null;\n+      v2 = null;\n+      v3 = null;\n+      v4 = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      v1 = (double[]) interpolator.v1.clone();\n+      v2 = (double[]) interpolator.v2.clone();\n+      v3 = (double[]) interpolator.v3.clone();\n+      v4 = (double[]) interpolator.v4.clone();\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new DormandPrince54StepInterpolator(this);\n+  }\n+\n+  /** Reinitialize the instance\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(FirstOrderDifferentialEquations equations,\n+                           double[] y, double[][] yDotK, boolean forward) {\n+    super.reinitialize(equations, y, yDotK, forward);\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v1 == null) {\n+        v1 = new double[interpolatedState.length];\n+        v2 = new double[interpolatedState.length];\n+        v3 = new double[interpolatedState.length];\n+        v4 = new double[interpolatedState.length];\n+      }\n+\n+      // no step finalization is needed for this interpolator\n+\n+      // we need to compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+        v1[i] = h * (a70 * yDotK[0][i] + a72 * yDotK[2][i] + a73 * yDotK[3][i]\n+                     + a74 * yDotK[4][i] + a75 * yDotK[5][i]);\n+        v2[i] = h * yDotK[0][i] - v1[i];\n+        v3[i] = v1[i] - v2[i] - h * yDotK[6][i];\n+        v4[i] = h * (d0 * yDotK[0][i] + d2 * yDotK[2][i] + d3 * yDotK[3][i]\n+                     + d4 * yDotK[4][i] + d5 * yDotK[5][i] + d6 * yDotK[6][i]);\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    // interpolate\n+    double eta = oneMinusThetaH / h;\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           - eta * (v1[i]\n+                                    - theta * (v2[i]\n+                                               + theta * (v3[i]\n+                                                          + eta * v4[i])));\n+    }\n+\n+  }\n+\n+  /** First vector for interpolation. */\n+  private double[] v1;\n+\n+  /** Second vector for interpolation. */\n+  private double[] v2;\n+\n+  /** Third vector for interpolation. */\n+  private double[] v3;\n+\n+  /** Fourth vector for interpolation. */\n+  private double[] v4;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  // last row of the Butcher-array internal weights, note that a71 is null\n+  private static final double a70 =    35.0 /  384.0;\n+  private static final double a72 =   500.0 / 1113.0;\n+  private static final double a73 =   125.0 /  192.0;\n+  private static final double a74 = -2187.0 / 6784.0;\n+  private static final double a75 =    11.0 /   84.0;\n+\n+  // dense output of Shampine (1986), note that d1 is null\n+  private static final double d0 =  -12715105075.0 /  11282082432.0;\n+  private static final double d2 =   87487479700.0 /  32700410799.0;\n+  private static final double d3 =  -10690763975.0 /   1880347072.0;\n+  private static final double d4 =  701980252875.0 / 199316789632.0;\n+  private static final double d5 =   -1453857185.0 /    822651844.0;\n+  private static final double d6 =      69997945.0 /     29380423.0;\n+\n+  private static final long serialVersionUID = 4104157279605906956L;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853Integrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the 8(5,3) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * of order 8(5,3) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 12 functions evaluations per step for integration and 4\n+ * evaluations for interpolation. However, since the first\n+ * interpolation evaluation is the same as the first integration\n+ * evaluation of the next step, we have included it in the integrator\n+ * rather than in the interpolator and specified the method was an\n+ * <i>fsal</i>. Hence, despite we have 13 stages here, the cost is\n+ * really 12 evaluations per step even if no interpolation is done,\n+ * and the overcost of interpolation is only 3 evaluations.</p>\n+\n+ * <p>This method is based on an 8(6) method by Dormand and Prince\n+ * (i.e. order 8 for the integration and order 6 for error estimation)\n+ * modified by Hairer and Wanner to use a 5th order error estimator\n+ * with 3rd order correction. This modification was introduced because\n+ * the original method failed in some cases (wrong steps can be\n+ * accepted when step size is too large, for example in the\n+ * Brusselator problem) and also had <i>severe difficulties when\n+ * applied to problems with discontinuities</i>. This modification is\n+ * explained in the second edition of the first volume (Nonstiff\n+ * Problems) of the reference book by Hairer, Norsett and Wanner:\n+ * <i>Solving Ordinary Differential Equations</i> (Springer-Verlag,\n+ * ISBN 3-540-56670-8).</p>\n+\n+ * @version $Id: DormandPrince853Integrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class DormandPrince853Integrator\n+  extends RungeKuttaFehlbergIntegrator {\n+\n+  private static final String methodName = \"Dormand-Prince 8 (5, 3)\";\n+\n+  private static final double sqrt6 = Math.sqrt(6.0);\n+\n+  private static final double[] c = {\n+    (12.0 - 2.0 * sqrt6) / 135.0, (6.0 - sqrt6) / 45.0, (6.0 - sqrt6) / 30.0,\n+    (6.0 + sqrt6) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n+    6.0/7.0, 1.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+\n+    // k2\n+    {(12.0 - 2.0 * sqrt6) / 135.0},\n+\n+    // k3\n+    {(6.0 - sqrt6) / 180.0, (6.0 - sqrt6) / 60.0},\n+\n+    // k4\n+    {(6.0 - sqrt6) / 120.0, 0.0, (6.0 - sqrt6) / 40.0},\n+\n+    // k5\n+    {(462.0 + 107.0 * sqrt6) / 3000.0, 0.0,\n+     (-402.0 - 197.0 * sqrt6) / 1000.0, (168.0 + 73.0 * sqrt6) / 375.0},\n+\n+    // k6\n+    {1.0 / 27.0, 0.0, 0.0, (16.0 + sqrt6) / 108.0, (16.0 - sqrt6) / 108.0},\n+\n+    // k7\n+    {19.0 / 512.0, 0.0, 0.0, (118.0 + 23.0 * sqrt6) / 1024.0,\n+     (118.0 - 23.0 * sqrt6) / 1024.0, -9.0 / 512.0},\n+\n+    // k8\n+    {13772.0 / 371293.0, 0.0, 0.0, (51544.0 + 4784.0 * sqrt6) / 371293.0,\n+     (51544.0 - 4784.0 * sqrt6) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},\n+\n+    // k9\n+    {58656157643.0 / 93983540625.0, 0.0, 0.0,\n+     (-1324889724104.0 - 318801444819.0 * sqrt6) / 626556937500.0,\n+     (-1324889724104.0 + 318801444819.0 * sqrt6) / 626556937500.0,\n+     96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,\n+     -165125654.0 / 3796875.0},\n+\n+    // k10\n+    {8909899.0 / 18653125.0, 0.0, 0.0,\n+     (-4521408.0 - 1137963.0 * sqrt6) / 2937500.0,\n+     (-4521408.0 + 1137963.0 * sqrt6) / 2937500.0,\n+     96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,\n+     -4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},\n+\n+    // k11\n+    {-20401265806.0 / 21769653311.0, 0.0, 0.0,\n+     (354216.0 + 94326.0 * sqrt6) / 112847.0,\n+     (354216.0 - 94326.0 * sqrt6) / 112847.0,\n+     -43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,\n+     14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,\n+     -1477884375.0 / 485066827.0},\n+\n+    // k12\n+    {39815761.0 / 17514443.0, 0.0, 0.0,\n+     (-3457480.0 - 960905.0 * sqrt6) / 551636.0,\n+     (-3457480.0 + 960905.0 * sqrt6) / 551636.0,\n+     -844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,\n+     -2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,\n+     226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},\n+\n+    // k13 should be for interpolation only, but since it is the same\n+    // stage as the first evaluation of the next step, we perform it\n+    // here at no cost by specifying this is an fsal method\n+    {104257.0/1920240.0, 0.0, 0.0, 0.0, 0.0, 3399327.0/763840.0,\n+     66578432.0/35198415.0, -1674902723.0/288716400.0,\n+     54980371265625.0/176692375811392.0, -734375.0/4826304.0,\n+     171414593.0/851261400.0, 137909.0/3084480.0}\n+\n+  };\n+\n+  private static final double[] b = {\n+      104257.0/1920240.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      3399327.0/763840.0,\n+      66578432.0/35198415.0,\n+      -1674902723.0/288716400.0,\n+      54980371265625.0/176692375811392.0,\n+      -734375.0/4826304.0,\n+      171414593.0/851261400.0,\n+      137909.0/3084480.0,\n+      0.0\n+  };\n+\n+  private static final double e1_01 =         116092271.0 / 8848465920.0;\n+  private static final double e1_06 =          -1871647.0 / 1527680.0;\n+  private static final double e1_07 =         -69799717.0 / 140793660.0;\n+  private static final double e1_08 =     1230164450203.0 / 739113984000.0;\n+  private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;\n+  private static final double e1_10 =         464500805.0 / 1389975552.0;\n+  private static final double e1_11 =     1606764981773.0 / 19613062656000.0;\n+  private static final double e1_12 =           -137909.0 / 6168960.0;\n+\n+  private static final double e2_01 =           -364463.0 / 1920240.0;\n+  private static final double e2_06 =           3399327.0 / 763840.0;\n+  private static final double e2_07 =          66578432.0 / 35198415.0;\n+  private static final double e2_08 =       -1674902723.0 / 288716400.0;\n+  private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;\n+  private static final double e2_10 =           -734375.0 / 4826304.0;\n+  private static final double e2_11 =         171414593.0 / 851261400.0;\n+  private static final double e2_12 =             69869.0 / 3084480.0;\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(double minStep, double maxStep,\n+                                    double scalAbsoluteTolerance,\n+                                    double scalRelativeTolerance) {\n+    super(true, c, a, b,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(double minStep, double maxStep,\n+                                    double[] vecAbsoluteTolerance,\n+                                    double[] vecRelativeTolerance) {\n+    super(true, c, a, b,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public int getOrder() {\n+    return 8;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected double estimateError(double[][] yDotK,\n+                                 double[] y0, double[] y1,\n+                                 double h) {\n+    double error1 = 0;\n+    double error2 = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j]\n+                     + e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j]\n+                     + e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j]\n+                     + e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n+      double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j]\n+                     + e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j]\n+                     + e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j]\n+                     + e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n+\n+      double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      double tol = (vecAbsoluteTolerance == null)\n+        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n+        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double ratio1  = errSum1 / tol;\n+      error1        += ratio1 * ratio1;\n+      double ratio2  = errSum2 / tol;\n+      error2        += ratio2 * ratio2;\n+    }\n+\n+    double den = error1 + 0.01 * error2;\n+    if (den <= 0.0) {\n+      den = 1.0;\n+    }\n+\n+    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.ObjectOutput;\n+import java.io.ObjectInput;\n+import java.io.IOException;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 8(5,3) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince853Integrator\n+ *\n+ * @version $Id: DormandPrince853StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+class DormandPrince853StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince853StepInterpolator() {\n+    super();\n+    yDotKLast = null;\n+    yTmp      = null;\n+    v         = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince853StepInterpolator(DormandPrince853StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState == null) {\n+\n+      yDotKLast = null;\n+      v         = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      int dimension = interpolator.currentState.length;\n+\n+      yDotKLast    = new double[3][];\n+      for (int k = 0; k < yDotKLast.length; ++k) {\n+        yDotKLast[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n+                         dimension);\n+      }\n+\n+      v = new double[7][];\n+      for (int k = 0; k < v.length; ++k) {\n+        v[k] = new double[dimension];\n+        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n+      }\n+\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+    // the step has been finalized, we don't need this anymore\n+    yTmp = null;\n+\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new DormandPrince853StepInterpolator(this);\n+  }\n+\n+  /** Reinitialize the instance\n+   * Some Runge-Kutta-Fehlberg integrators need fewer functions\n+   * evaluations than their counterpart step interpolators. So the\n+   * interpolator should perform the last evaluations they need by\n+   * themselves. The {@link RungeKuttaFehlbergIntegrator\n+   * RungeKuttaFehlbergIntegrator} abstract class calls this method in\n+   * order to let the step interpolator perform the evaluations it\n+   * needs. These evaluations will be performed during the call to\n+   * <code>doFinalize</code> if any, i.e. only if the step handler\n+   * either calls the {@link AbstractStepInterpolator#finalizeStep\n+   * finalizeStep} method or the {@link\n+   * AbstractStepInterpolator#getInterpolatedState getInterpolatedState}\n+   * method (for an interpolator which needs a finalization) or if it clones\n+   * the step interpolator.\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(FirstOrderDifferentialEquations equations,\n+                           double[] y, double[][] yDotK, boolean forward) {\n+\n+    super.reinitialize(equations, y, yDotK, forward);\n+\n+    int dimension = currentState.length;\n+\n+    yDotKLast = new double[3][];\n+    for (int k = 0; k < yDotKLast.length; ++k) {\n+      yDotKLast[k] = new double[dimension];\n+    }\n+\n+    yTmp = new double[dimension];\n+\n+    v = new double[7][];\n+    for (int k = 0; k < v.length; ++k) {\n+      v[k]  = new double[dimension];\n+    }\n+\n+    vectorsInitialized = false;\n+\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v == null) {\n+        v = new double[7][];\n+        for (int k = 0; k < 7; ++k) {\n+          v[k] = new double[interpolatedState.length];\n+        }\n+      }\n+\n+      // perform the last evaluations if they have not been done yet\n+      finalizeStep();\n+\n+      // compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+        v[0][i] = h * (b_01 * yDotK[0][i]  + b_06 * yDotK[5][i] + b_07 * yDotK[6][i]\n+                     + b_08 * yDotK[7][i]  + b_09 * yDotK[8][i] + b_10 * yDotK[9][i]\n+                     + b_11 * yDotK[10][i] + b_12 * yDotK[11][i]);\n+        v[1][i] = h * yDotK[0][i] - v[0][i];\n+        v[2][i] = v[0][i] - v[1][i] - h * yDotK[12][i];\n+        for (int k = 0; k < d.length; ++k) {\n+          v[k+3][i] = h * (d[k][0] * yDotK[0][i]  + d[k][1] * yDotK[5][i]  + d[k][2] * yDotK[6][i]\n+                         + d[k][3] * yDotK[7][i]  + d[k][4] * yDotK[8][i]  + d[k][5] * yDotK[9][i]\n+                         + d[k][6] * yDotK[10][i] + d[k][7] * yDotK[11][i] + d[k][8] * yDotK[12][i]\n+                         + d[k][9]  * yDotKLast[0][i]\n+                         + d[k][10] * yDotKLast[1][i]\n+                         + d[k][11] * yDotKLast[2][i]);\n+        }\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    double eta = oneMinusThetaH / h;\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           -   eta * (v[0][i]\n+                           - theta * (v[1][i]\n+                           + theta * (v[2][i]\n+                           +   eta * (v[3][i]\n+                           + theta * (v[4][i]\n+                           +   eta * (v[5][i]\n+                           + theta * (v[6][i])))))));\n+    }\n+\n+  }\n+ \n+  /**\n+   * Really finalize the step.\n+   * Perform the last 3 functions evaluations (k14, k15, k16)\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+\n+    double s;\n+\n+    // k14\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j]\n+        + k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j]\n+        + k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n+\n+    // k15\n+    for (int j = 0; j < currentState.length; ++j) {\n+     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j]\n+       + k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j]\n+       + k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j]\n+       + k15_14 * yDotKLast[0][j];\n+     yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n+\n+    // k16\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j]\n+        + k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j]\n+        + k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j]\n+        + k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n+\n+  }\n+\n+  /** Save the state of the instance.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    try {\n+      // save the local attributes\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+    out.writeInt(currentState.length);\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(yDotKLast[0][i]);\n+      out.writeDouble(yDotKLast[1][i]);\n+      out.writeDouble(yDotKLast[2][i]);\n+    }\n+\n+    // save the state of the base class\n+    super.writeExternal(out);\n+\n+  }\n+\n+  /** Read the state of the instance.\n+   * @param in stream where to read the state from\n+   * @exception IOException in case of read error\n+   */\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the local attributes\n+    yDotKLast = new double[3][];\n+    int dimension = in.readInt();\n+    yDotKLast[0] = new double[dimension];\n+    yDotKLast[1] = new double[dimension];\n+    yDotKLast[2] = new double[dimension];\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      yDotKLast[0][i] = in.readDouble();\n+      yDotKLast[1][i] = in.readDouble();\n+      yDotKLast[2][i] = in.readDouble();\n+    }\n+\n+    // read the base state\n+    super.readExternal(in);\n+\n+  }\n+\n+  /** Last evaluations. */\n+  private double[][] yDotKLast;\n+\n+  /** Temporary state vector. */\n+  private double[] yTmp;\n+\n+  /** Vectors for interpolation. */\n+  private double[][] v;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  // external weights of the integrator,\n+  // note that b_02 through b_05 are null\n+  private static double b_01 =         104257.0 / 1920240.0;\n+  private static double b_06 =        3399327.0 / 763840.0;\n+  private static double b_07 =       66578432.0 / 35198415.0;\n+  private static double b_08 =    -1674902723.0 / 288716400.0;\n+  private static double b_09 = 54980371265625.0 / 176692375811392.0;\n+  private static double b_10 =        -734375.0 / 4826304.0;\n+  private static double b_11 =      171414593.0 / 851261400.0;\n+  private static double b_12 =         137909.0 / 3084480.0;\n+\n+  // k14 for interpolation only\n+  private static double c14    = 1.0 / 10.0;\n+\n+  private static double k14_01 =       13481885573.0 / 240030000000.0      - b_01;\n+  private static double k14_06 =                 0.0                       - b_06;\n+  private static double k14_07 =      139418837528.0 / 549975234375.0      - b_07;\n+  private static double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;\n+  private static double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;\n+  private static double k14_10 =          57799439.0 / 377055000.0         - b_10;\n+  private static double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;\n+  private static double k14_12 =        1458939311.0 / 192780000000.0      - b_12;\n+  private static double k14_13 =             -4149.0 / 500000.0;\n+\n+  // k15 for interpolation only\n+  private static double c15    = 1.0 / 5.0;\n+\n+  private static double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;\n+  private static double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;\n+  private static double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;\n+  private static double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;\n+  private static double k15_09 =                 0.0                       - b_09;\n+  private static double k15_10 =                 0.0                       - b_10;\n+  private static double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;\n+  private static double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;\n+  private static double k15_13 =      -11518334563.0 / 33831184612500.0;\n+  private static double k15_14 =        1912306948.0 / 13532473845.0;\n+\n+  // k16 for interpolation only\n+  private static double c16    = 7.0 / 9.0;\n+\n+  private static double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;\n+  private static double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;\n+  private static double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;\n+  private static double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;\n+  private static double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;\n+  private static double k16_10 =                 0.0                       - b_10;\n+  private static double k16_11 =                 0.0                       - b_11;\n+  private static double k16_12 =                 0.0                       - b_12;\n+  private static double k16_13 =       -1199007803.0 / 857031517296.0;\n+  private static double k16_14 =      157882067000.0 / 53564469831.0;\n+  private static double k16_15 =     -290468882375.0 / 31741908048.0;\n+\n+  // interpolation weights\n+  // (beware that only the non-null values are in the table)\n+  private static double[][] d = {\n+\n+    {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n+            -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n+      3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,\n+            2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,\n+                  -126493.0 / 1421424.0,                    98350000.0 / 5419179.0,\n+                -18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},\n+\n+    {         32941697297.0 / 3159114840.0,             456696183123.0 / 1884966160.0,\n+           19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,\n+     -4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,\n+          -85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,\n+                  2479159.0 / 157936.0,                    -18750000.0 / 602131.0,\n+                -19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},\n+\n+    {         12627015655.0 / 631822968.0,              -72955222965.0 / 188496616.0,\n+          -13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,\n+      -296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,\n+             -18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,\n+                -11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,\n+                519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},\n+\n+    {          -450944925.0 / 17550638.0,               -14532122925.0 / 94248308.0,\n+            -595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,\n+      2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,\n+              53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,\n+                 -1718875.0 / 39484.0,                      58000000.0 / 602131.0,\n+                 -1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}\n+\n+  };\n+\n+  private static final long serialVersionUID = 4165537490327432186L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/DummyStepHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is a step handler that do nothing.\n+\n+ * <p>This class is provided as a convenience for users who are only\n+ * interested in the final state of an integration and not in the\n+ * intermediate steps. Its handleStep method does nothing.</p>\n+\n+ * <p>Since this class has no internal state, it is implemented using\n+ * the Singleton design pattern. This means that only one instance is\n+ * ever created, which can be retrieved using the getInstance\n+ * method. This explains why there is no public constructor.</p>\n+\n+ * @see StepHandler\n+\n+ * @version $Id: DummyStepHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class DummyStepHandler\n+  implements StepHandler {\n+\n+  /** Private constructor.\n+   * The constructor is private to prevent users from creating\n+   * instances (Singleton design-pattern).\n+   */\n+  private DummyStepHandler() {\n+  }\n+\n+  /** Get the only instance.\n+   * @return the only instance\n+   */\n+  public static DummyStepHandler getInstance() {\n+    if (instance == null) {\n+      instance = new DummyStepHandler();\n+    }\n+    return instance;\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * Since this handler does nothing, it does not require dense output.\n+   * @return always false\n+   */\n+  public boolean requiresDenseOutput() {\n+    return false;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+  }\n+\n+  /**\n+   * Handle the last accepted step.\n+   * This method does nothing in this class.\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range), it\n+   * should build a local copy using the clone method and store this\n+   * copy.\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+  }\n+\n+  /** The only instance. */\n+  private static DummyStepHandler instance = null;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/DummyStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/** This class is a step interpolator that does nothing.\n+ *\n+ * <p>This class is used when the {@link StepHandler \"step handler\"}\n+ * set up by the user does not need step interpolation. It does not\n+ * recompute the state when {@link AbstractStepInterpolator#setInterpolatedTime\n+ * setInterpolatedTime} is called. This implies the interpolated state\n+ * is always the state at the end of the current step.</p>\n+ *\n+ * @see StepHandler\n+ *\n+ * @version $Id: DummyStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public class DummyStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. As an example, the {@link\n+   * RungeKuttaFehlbergIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  public DummyStepInterpolator() {\n+    super();\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected DummyStepInterpolator(double[] y, boolean forward) {\n+    super(y, forward);\n+  }\n+\n+  /** Copy constructor.\n+\n+   * <p>The copied interpolator should have been finalized before the\n+   * copy, otherwise the copy will not be able to perform correctly\n+   * any interpolation and will throw a {@link NullPointerException}\n+   * later. Since we don't want this constructor to throw the\n+   * exceptions finalization may involve and since we don't want this\n+   * method to modify the state of the copied interpolator,\n+   * finalization is <strong>not</strong> done automatically, it\n+   * remains under user control.</p>\n+\n+   * <p>The copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance.</p>\n+\n+   * @param interpolator interpolator to copy from.\n+\n+   */\n+  protected DummyStepInterpolator(DummyStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * In this class, this method does nothing: the interpolated state\n+   * is always the state at the end of the current step.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta, double oneMinusThetaH)\n+    throws DerivativeException {\n+  }\n+    \n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+  }\n+\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    double t = readBaseExternal(in);\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = 1708010296707839488L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/EulerIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a simple Euler integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>The Euler algorithm is the simplest one that can be used to\n+ * integrate ordinary differential equations. It is a simple inversion\n+ * of the forward difference expression :\n+ * <code>f'=(f(t+h)-f(t))/h</code> which leads to\n+ * <code>f(t+h)=f(t)+hf'</code>. The interpolation scheme used for\n+ * dense output is the linear scheme already used for integration.</p>\n+\n+ * <p>This algorithm looks cheap because it needs only one function\n+ * evaluation per step. However, as it uses linear estimates, it needs\n+ * very small steps to achieve high accuracy, and small steps lead to\n+ * numerical errors and instabilities.</p>\n+\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a comparison reference for more useful\n+ * integrators.</p>\n+\n+ * @see MidpointIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: EulerIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class EulerIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = \"Euler\";\n+\n+  private static final double[] c = {\n+  };\n+\n+  private static final double[][] a = {\n+  };\n+\n+  private static final double[] b = {\n+    1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build an Euler integrator with the given step.\n+   * @param step integration step\n+   */\n+  public EulerIntegrator(double step) {\n+    super(false, c, a, b, new EulerStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/EulerStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a linear interpolator for step.\n+\n+ * <p>This interpolator allow to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) - (1-theta) h y'\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y' is the evaluation of\n+ * the derivatives already computed during the step.</p>\n+\n+ * @see EulerIntegrator\n+\n+ * @version $Id: EulerStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class EulerStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public EulerStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public EulerStepInterpolator(EulerStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new EulerStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = -7179861704951334960L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/** This class converts second order differential equations to first\n+ * order ones.\n+\n+ * <p>This class is a wrapper around a {@link\n+ * SecondOrderDifferentialEquations} which allow to use a {@link\n+ * FirstOrderIntegrator} to integrate it.</p>\n+\n+ * <p>The transformation is done by changing the n dimension state\n+ * vector to a 2n dimension vector, where the first n components are\n+ * the initial state variables and the n last components are their\n+ * first time derivative. The first time derivative of this state\n+ * vector then really contains both the first and second time\n+ * derivative of the initial state vector, which can be handled by the\n+ * underlying second order equations set.</p>\n+\n+ * <p>One should be aware that the data is duplicated during the\n+ * transformation process and that for each call to {@link\n+ * #computeDerivatives computeDerivatives}, this wrapper does copy 4n\n+ * scalars : 2n before the call to {@link\n+ * SecondOrderDifferentialEquations#computeSecondDerivatives\n+ * computeSecondDerivatives} in order to dispatch the y state vector\n+ * into z and zDot, and 2n after the call to gather zDot and zDDot\n+ * into yDot. Since the underlying problem by itself perhaps also\n+ * needs to copy data and dispatch the arrays into domain objects,\n+ * this has an impact on both memory and CPU usage. The only way to\n+ * avoid this duplication is to perform the transformation at the\n+ * problem level, i.e. to implement the problem as a first order one\n+ * and then avoid using this class.</p>\n+\n+ * @see FirstOrderIntegrator\n+ * @see FirstOrderDifferentialEquations\n+ * @see SecondOrderDifferentialEquations\n+\n+ * @version $Id: FirstOrderConverter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class FirstOrderConverter\n+  implements FirstOrderDifferentialEquations {\n+\n+  /** Simple constructor.\n+   * Build a converter around a second order equations set.\n+   * @param equations second order equations set to convert\n+   */\n+  public FirstOrderConverter (SecondOrderDifferentialEquations equations) {\n+      this.equations = equations;\n+      dimension      = equations.getDimension();\n+      z              = new double[dimension];\n+      zDot           = new double[dimension];\n+      zDDot          = new double[dimension];\n+  }\n+\n+  public int getDimension() {\n+    return 2 * dimension;\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot)\n+  throws DerivativeException {\n+\n+    // split the state vector in two\n+    System.arraycopy(y, 0,         z,    0, dimension);\n+    System.arraycopy(y, dimension, zDot, 0, dimension);\n+\n+    // apply the underlying equations set\n+    equations.computeSecondDerivatives(t, z, zDot, zDDot);\n+\n+    // build the result state derivative\n+    System.arraycopy(zDot,  0, yDot, 0,         dimension);\n+    System.arraycopy(zDDot, 0, yDot, dimension, dimension);\n+    \n+  }\n+\n+  /** Underlying second order equations set. */\n+  private SecondOrderDifferentialEquations equations;\n+\n+  /** second order problem dimension. */\n+  private int dimension;\n+\n+  /** state vector. */\n+  private double[] z;\n+\n+  /** first time derivative of the state vector. */\n+  private double[] zDot;\n+\n+  /** second time derivative of the state vector. */\n+  private double[] zDDot;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/** This interface represents a first order differential equations set.\n+ *\n+ * <p>This interface should be implemented by all real first order\n+ * differential equation problems before they can be handled by the\n+ * integrators {@link FirstOrderIntegrator#integrate} method.</p>\n+ *\n+ * <p>A first order differential equations problem, as seen by an\n+ * integrator is the time derivative <code>dY/dt</code> of a state\n+ * vector <code>Y</code>, both being one dimensional arrays. From the\n+ * integrator point of view, this derivative depends only on the\n+ * current time <code>t</code> and on the state vector\n+ * <code>Y</code>.</p>\n+ *\n+ * <p>For real problems, the derivative depends also on parameters\n+ * that do not belong to the state vector (dynamical model constants\n+ * for example). These constants are completely outside of the scope\n+ * of this interface, the classes that implement it are allowed to\n+ * handle them as they want.</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see FirstOrderConverter\n+ * @see SecondOrderDifferentialEquations\n+ * @see org.spaceroots.mantissa.utilities.ArraySliceMappable\n+ *\n+ * @version $Id: FirstOrderDifferentialEquations.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public interface FirstOrderDifferentialEquations {\n+    \n+    /** Get the dimension of the problem.\n+     * @return dimension of the problem\n+     */\n+    public int getDimension();\n+    \n+    /** Get the current time derivative of the state vector.\n+     * @param t current value of the independant <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    public void computeDerivatives(double t, double[] y, double[] yDot)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/** This interface represents a first order integrator for\n+ * differential equations.\n+\n+ * <p>The classes which are devoted to solve first order differential\n+ * equations should implement this interface. The problems which can\n+ * be handled should implement the {@link\n+ * FirstOrderDifferentialEquations} interface.</p>\n+\n+ * @see FirstOrderDifferentialEquations\n+ * @see StepHandler\n+ * @see SwitchingFunction\n+\n+ * @version $Id: FirstOrderIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface FirstOrderIntegrator {\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName();\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler);\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler();\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence);\n+\n+  /** Integrate the differential equations up to the given time\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param t target time for the integration\n+   * (can be set to a value smaller thant <code>t0</code> for backward integration)\n+   * @param y placeholder where to put the state vector at each successful\n+   *  step (and hence at the end of integration), can be the same object as y0\n+   * @throws IntegratorException if the integrator cannot perform integration\n+   * @throws DerivativeException this exception is propagated to the caller if\n+   * the underlying user function triggers one\n+   */\n+  public void integrate (FirstOrderDifferentialEquations equations,\n+                         double t0, double[] y0,\n+                         double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/FixedStepHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful fixed step.\n+\n+ * <p>This interface should be implemented by anyone who is interested\n+ * in getting the solution of an ordinary differential equation at\n+ * fixed time steps. Objects implementing this interface should be\n+ * wrapped within an instance of {@link StepNormalizer} that itself\n+ * is used as the general {@link StepHandler} by the integrator. The\n+ * {@link StepNormalizer} object is called according to the integrator\n+ * internal algorithms and it calls objects implementing this\n+ * interface as necessary at fixed time steps.</p>\n+\n+ * @see StepHandler\n+ * @see StepNormalizer\n+\n+ * @version $Id: FixedStepHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface FixedStepHandler {\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param t time of the current step\n+\n+   * @param y state vector at t. For efficiency purposes, the {@link\n+   * StepNormalizer} class reuse the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(double t, double[] y, boolean isLast);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/GillIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the Gill fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations .\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |    0        0       0      0\n+ *   1/2 |   1/2       0       0      0\n+ *   1/2 | (q-1)/2  (2-q)/2    0      0\n+ *    1  |    0       -q/2  (2+q)/2   0\n+ *       |-------------------------------\n+ *       |   1/6    (2-q)/6 (2+q)/6  1/6\n+ * </pre>\n+ * where q = sqrt(2)</p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: GillIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class GillIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = \"Gill\";\n+\n+  private static final double sqrt2 = Math.sqrt(2.0);\n+\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { (sqrt2 - 1.0) / 2.0, (2.0 - sqrt2) / 2.0 },\n+    { 0.0, -sqrt2 / 2.0, (2.0 + sqrt2) / 2.0 }\n+  };\n+\n+  private static final double[] b = {\n+    1.0 / 6.0, (2.0 - sqrt2) / 6.0, (2.0 + sqrt2) / 6.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Gill integrator with the given step.\n+   * @param step integration step\n+   */\n+  public GillIntegrator(double step) {\n+    super(false, c, a, b, new GillStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/GillStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a step interpolator for the Gill fourth\n+ * order Runge-Kutta integrator.\n+\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/6) [ (1 - theta) (1 - 4 theta) y'_1\n+ *                                        + (1 - theta) (1 + 2 theta) ((2-q) y'_2 + (2+q) y'_3)\n+ *                                        + (1 + theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ * where theta belongs to [0 ; 1], q = sqrt(2) and where y'_1 to y'_4\n+ * are the four evaluations of the derivatives already computed during\n+ * the step.</p>\n+\n+ * @see GillIntegrator\n+\n+ * @version $Id: GillStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class GillStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public GillStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GillStepInterpolator(GillStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new GillStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double fourTheta = 4 * theta;\n+    double s         = oneMinusThetaH / 6.0;\n+    double soMt      = s * (1 - theta);\n+    double c23       = soMt * (1 + 2 * theta);\n+    double coeff1    = soMt * (1 - fourTheta);\n+    double coeff2    = c23  * tMq;\n+    double coeff3    = c23  * tPq;\n+    double coeff4    = s * (1 + theta * (1 + fourTheta));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                            - coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]\n+                            - coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+     }\n+\n+  }\n+\n+  /** First Gill coefficient. */\n+  private static final double tMq = 2 - Math.sqrt(2.0);\n+\n+  /** Second Gill coefficient. */\n+  private static final double tPq = 2 + Math.sqrt(2.0);\n+\n+  private static final long serialVersionUID = -107804074496313322L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a Gragg-Bulirsch-Stoer integrator for\n+ * Ordinary Differential Equations.\n+\n+ * <p>The Gragg-Bulirsch-Stoer algorithm is one of the most efficient\n+ * ones currently available for smooth problems. It uses Richardson\n+ * extrapolation to estimate what would be the solution if the step\n+ * size could be decreased down to zero.</p>\n+\n+ * <p>\n+ * This method changes both the step size and the order during\n+ * integration, in order to minimize computation cost. It is\n+ * particularly well suited when a very high precision is needed. The\n+ * limit where this method becomes more efficient than high-order\n+ * Runge-Kutta-Fehlberg methods like {@link DormandPrince853Integrator\n+ * Dormand-Prince 8(5,3)} depends on the problem. Results given in the\n+ * Hairer, Norsett and Wanner book show for example that this limit\n+ * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz\n+ * equations (the authors note this problem is <i>extremely sensitive\n+ * to the errors in the first integration steps</i>), and around 1e-11\n+ * for a two dimensional celestial mechanics problems with seven\n+ * bodies (pleiades problem, involving quasi-collisions for which\n+ * <i>automatic step size control is essential</i>).\n+ * </p>\n+\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @author L. Maisonobe (Java port)\n+ * @version $Id: GraggBulirschStoerIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+\n+ */\n+\n+public class GraggBulirschStoerIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  private static final String methodName = \"Gragg-Bulirsch-Stoer\";\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(double minStep, double maxStep,\n+                                      double scalAbsoluteTolerance,\n+                                      double scalRelativeTolerance) {\n+    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(double minStep, double maxStep,\n+                                      double[] vecAbsoluteTolerance,\n+                                      double[] vecRelativeTolerance) {\n+    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Set the stability check controls.\n+   * <p>The stability check is performed on the first few iterations of\n+   * the extrapolation scheme. If this test fails, the step is rejected\n+   * and the stepsize is reduced.</p>\n+   * <p>By default, the test is performed, at most during two\n+   * iterations at each step, and at most once for each of these\n+   * iterations. The default stepsize reduction factor is 0.5.</p>\n+   * @param performTest if true, stability check will be performed,\n+     if false, the check will be skipped\n+   * @param maxIter maximal number of iterations for which checks are\n+   * performed (the number of iterations is reset to default if negative\n+   * or null)\n+   * @param maxChecks maximal number of checks for each iteration\n+   * (the number of checks is reset to default if negative or null)\n+   * @param stabilityReduction stepsize reduction factor in case of\n+   * failure (the factor is reset to default if lower than 0.0001 or\n+   * greater than 0.9999)\n+   */\n+  public void setStabilityCheck(boolean performTest,\n+                                int maxIter, int maxChecks,\n+                                double stabilityReduction) {\n+\n+    this.performTest = performTest;\n+    this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;\n+    this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;\n+\n+    if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {\n+      this.stabilityReduction = 0.5;\n+    } else {\n+      this.stabilityReduction = stabilityReduction;\n+    }\n+\n+  }\n+\n+  /** Set the step size control factors.\n+\n+   * <p>The new step size hNew is computed from the old one h by:\n+   * <pre>\n+   * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))\n+   * </pre>\n+   * where err is the scaled error and k the iteration number of the\n+   * extrapolation scheme (counting from 0). The default values are\n+   * 0.65 for stepControl1 and 0.94 for stepControl2.</p>\n+   * <p>The step size is subject to the restriction:\n+   * <pre>\n+   * stepControl3^(1/(2k+1))/stepControl4 <= hNew/h <= 1/stepControl3^(1/(2k+1))\n+   * </pre>\n+   * The default values are 0.02 for stepControl3 and 4.0 for\n+   * stepControl4.</p>\n+   * @param stepControl1 first stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl2 second stepsize control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl3 third stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl4 fourth stepsize control factor (the factor\n+   * is reset to default if lower than 1.0001 or greater than 999.9)\n+   */\n+  public void setStepsizeControl(double stepControl1, double stepControl2,\n+                                 double stepControl3, double stepControl4) {\n+\n+    if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {\n+      this.stepControl1 = 0.65;\n+    } else {\n+      this.stepControl1 = stepControl1;\n+    }\n+\n+    if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {\n+      this.stepControl2 = 0.94;\n+    } else {\n+      this.stepControl2 = stepControl2;\n+    }\n+\n+    if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {\n+      this.stepControl3 = 0.02;\n+    } else {\n+      this.stepControl3 = stepControl3;\n+    }\n+\n+    if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {\n+      this.stepControl4 = 4.0;\n+    } else {\n+      this.stepControl4 = stepControl4;\n+    }\n+\n+  }\n+\n+  /** Set the order control parameters.\n+   * <p>The Gragg-Bulirsch-Stoer method changes both the step size and\n+   * the order during integration, in order to minimize computation\n+   * cost. Each extrapolation step increases the order by 2, so the\n+   * maximal order that will be used is always even, it is twice the\n+   * maximal number of columns in the extrapolation table.</p>\n+   * <pre>\n+   * order is decreased if w(k-1) <= w(k)   * orderControl1\n+   * order is increased if w(k)   <= w(k-1) * orderControl2\n+   * </pre>\n+   * <p>where w is the table of work per unit step for each order\n+   * (number of function calls divided by the step length), and k is\n+   * the current order.</p>\n+   * <p>The default maximal order after construction is 18 (i.e. the\n+   * maximal number of columns is 9). The default values are 0.8 for\n+   * orderControl1 and 0.9 for orderControl2.</p>\n+   * @param maxOrder maximal order in the extrapolation table (the\n+   * maximal order is reset to default if order <= 6 or odd)\n+   * @param orderControl1 first order control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param orderControl2 second order control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   */\n+  public void setOrderControl(int maxOrder,\n+                              double orderControl1, double orderControl2) {\n+\n+    if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {\n+      this.maxOrder = 18;\n+    }\n+\n+    if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {\n+      this.orderControl1 = 0.8;\n+    } else {\n+      this.orderControl1 = orderControl1;\n+    }\n+\n+    if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {\n+      this.orderControl2 = 0.9;\n+    } else {\n+      this.orderControl2 = orderControl2;\n+    }\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler) {\n+\n+    super.setStepHandler(handler);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence) {\n+    super.addSwitchingFunction(function, maxCheckInterval, convergence);\n+    denseOutput = (handler.requiresDenseOutput()\n+                   || (! switchesHandler.isEmpty()));\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Initialize the integrator internal arrays. */\n+  private void initializeArrays() {\n+\n+    int size = maxOrder / 2;\n+\n+    if ((sequence == null) || (sequence.length != size)) {\n+      // all arrays should be reallocated with the right size\n+      sequence        = new int[size];\n+      costPerStep     = new int[size];\n+      coeff           = new double[size][];\n+      costPerTimeUnit = new double[size];\n+      optimalStep     = new double[size];\n+    }\n+\n+    if (denseOutput) {\n+      // step size sequence: 2, 6, 10, 14, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 4 * k + 2;\n+      }\n+    } else {\n+      // step size sequence: 2, 4, 6, 8, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 2 * (k + 1); \n+      }\n+    }\n+\n+    // initialize the order selection cost array\n+    // (number of function calls for each column of the extrapolation table)\n+    costPerStep[0] = sequence[0] + 1;\n+    for (int k = 1; k < size; ++k) {\n+      costPerStep[k] = costPerStep[k-1] + sequence[k];\n+    }\n+\n+    // initialize the extrapolation tables\n+    for (int k = 0; k < size; ++k) {\n+      coeff[k] = (k > 0) ? new double[k] : null;\n+      for (int l = 0; l < k; ++l) {\n+        double ratio = ((double) sequence[k]) / sequence[k-l-1];\n+        coeff[k][l] = 1.0 / (ratio * ratio - 1.0);\n+      }\n+    }\n+\n+  }\n+\n+  /** Set the interpolation order control parameter.\n+   * The interpolation order for dense output is 2k - mudif + 1. The\n+   * default value for mudif is 4 and the interpolation error is used\n+   * in stepsize control by default.\n+\n+   * @param useInterpolationError if true, interpolation error is used\n+   * for stepsize control\n+   * @param mudif interpolation order control parameter (the parameter\n+   * is reset to default if <= 0 or >= 7)\n+   */\n+  public void setInterpolationControl(boolean useInterpolationError,\n+                                      int mudif) {\n+\n+    this.useInterpolationError = useInterpolationError;\n+\n+    if ((mudif <= 0) || (mudif >= 7)) {\n+      this.mudif = 4;\n+    } else {\n+      this.mudif = mudif;\n+    }\n+\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Update scaling array.\n+   * @param y1 first state vector to use for scaling\n+   * @param y2 second state vector to use for scaling\n+   * @param scale scaling array to update\n+   */\n+  private void rescale(double[] y1, double[] y2, double[] scale) {\n+    if (vecAbsoluteTolerance == null) {\n+      for (int i = 0; i < scale.length; ++i) {\n+        double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n+      }\n+    } else {\n+      for (int i = 0; i < scale.length; ++i) {\n+        double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n+      }\n+    }\n+  }\n+\n+  /** Perform integration over one step using substeps of a modified\n+   * midpoint method.\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param step global step\n+   * @param k iteration number (from 0 to sequence.length - 1)\n+   * @param scale scaling array\n+   * @param f placeholder where to put the state vector derivatives at each substep\n+   *          (element 0 already contains initial derivative)\n+   * @param yMiddle placeholder where to put the state vector at the middle of the step\n+   * @param yEnd placeholder where to put the state vector at the end\n+   * @param yTmp placeholder for one state vector\n+   * @return true if computation was done properly,\n+   *         false if stability check failed before end of computation\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  private boolean tryStep(FirstOrderDifferentialEquations equations,\n+                          double t0, double[] y0, double step, int k,\n+                          double[] scale, double[][] f,\n+                          double[] yMiddle, double[] yEnd,\n+                          double[] yTmp)\n+    throws DerivativeException {\n+\n+    int    n        = sequence[k];\n+    double subStep  = step / n;\n+    double subStep2 = 2 * subStep;\n+\n+    // first substep\n+    double t = t0 + subStep;\n+    for (int i = 0; i < y0.length; ++i) {\n+      yTmp[i] = y0[i];\n+      yEnd[i] = y0[i] + subStep * f[0][i];\n+    }\n+    equations.computeDerivatives(t, yEnd, f[1]);\n+\n+    // other substeps\n+    for (int j = 1; j < n; ++j) {\n+\n+      if (2 * j == n) {\n+        // save the point at the middle of the step\n+        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n+      }\n+\n+      t += subStep;\n+      for (int i = 0; i < y0.length; ++i) {\n+        double middle = yEnd[i];\n+        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n+        yTmp[i]       = middle;\n+      }\n+\n+      equations.computeDerivatives(t, yEnd, f[j+1]);\n+\n+      // stability check\n+      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n+        double initialNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          double ratio = f[0][l] / scale[l];\n+          initialNorm += ratio * ratio;\n+        }\n+        double deltaNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n+          deltaNorm += ratio * ratio;\n+        }\n+        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {\n+          return false;\n+        }\n+      }\n+\n+    }\n+\n+    // correction of the last substep (at t0 + step)\n+    for (int i = 0; i < y0.length; ++i) {\n+      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  /** Extrapolate a vector.\n+   * @param offset offset to use in the coefficients table\n+   * @param k index of the last updated point\n+   * @param diag working diagonal of the Aitken-Neville's\n+   * triangle, without the last element\n+   * @param last last element\n+   */\n+  private void extrapolate(int offset, int k, double[][] diag, double[] last) {\n+\n+    // update the diagonal\n+    for (int j = 1; j < k; ++j) {\n+      for (int i = 0; i < last.length; ++i) {\n+        // Aitken-Neville's recursive formula\n+        diag[k-j-1][i] = diag[k-j][i]\n+                       + coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);\n+      }\n+    }\n+\n+    // update the last element\n+    for (int i = 0; i < last.length; ++i) {\n+      // Aitken-Neville's recursive formula\n+      last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);\n+    }\n+  }\n+\n+  public void integrate(FirstOrderDifferentialEquations equations,\n+                        double t0, double[] y0, double t, double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    // sanity check\n+    if (equations.getDimension() != y0.length) {\n+      throw new IntegratorException(\"dimensions mismatch: \"\n+                                    + \"ODE problem has dimension {0}\"\n+                                    + \", state vector has dimension {1}\",\n+                                    new String[] {\n+                                      Integer.toString(equations.getDimension()),\n+                                      Integer.toString(y0.length)\n+                                    });\n+    }\n+    if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+      throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                    new String[] {\n+                                      Double.toString(Math.abs(t - t0))\n+                                    });\n+    }\n+\n+    boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    double[] yDot0   = new double[y0.length];\n+    double[] y1      = new double[y0.length];\n+    double[] yTmp    = new double[y0.length];\n+    double[] yTmpDot = new double[y0.length];\n+\n+    double[][] diagonal = new double[sequence.length-1][];\n+    double[][] y1Diag = new double[sequence.length-1][];\n+    for (int k = 0; k < sequence.length-1; ++k) {\n+      diagonal[k] = new double[y0.length];\n+      y1Diag[k] = new double[y0.length];\n+    }\n+\n+    double[][][] fk  = new double[sequence.length][][];\n+    for (int k = 0; k < sequence.length; ++k) {\n+\n+      fk[k]    = new double[sequence[k] + 1][];\n+\n+      // all substeps start at the same point, so share the first array\n+      fk[k][0] = yDot0;\n+\n+      for (int l = 0; l < sequence[k]; ++l) {\n+        fk[k][l+1] = new double[y0.length];\n+      }\n+\n+    }\n+\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+\n+    double[] yDot1      = null;\n+    double[][] yMidDots = null;\n+    if (denseOutput) {\n+      yDot1    = new double[y0.length];\n+      yMidDots = new double[1 + 2 * sequence.length][];\n+      for (int j = 0; j < yMidDots.length; ++j) {\n+        yMidDots[j] = new double[y0.length];\n+      }\n+    } else {\n+      yMidDots    = new double[1][];\n+      yMidDots[0] = new double[y0.length];\n+    }\n+\n+    // initial scaling\n+    double[] scale = new double[y0.length];\n+    rescale(y, y, scale);\n+\n+    // initial order selection\n+    double log10R = Math.log(Math.max(1.0e-10,\n+                                      (vecRelativeTolerance == null)\n+                                      ? scalRelativeTolerance\n+                                      : vecRelativeTolerance[0]))\n+                  / Math.log(10.0);\n+    int targetIter = Math.max(1,\n+                              Math.min(sequence.length - 2,\n+                                       (int) Math.floor(0.5 - 0.6 * log10R)));\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator = null;\n+    if (denseOutput || (! switchesHandler.isEmpty())) {\n+      interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,\n+                                                            y1, yDot1,\n+                                                            yMidDots, forward);\n+    } else {\n+      interpolator = new DummyStepInterpolator(y, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    double  currentT         = t0;\n+    double  hNew             = 0;\n+    double  maxError         = Double.MAX_VALUE;\n+    boolean previousRejected = false;\n+    boolean firstTime        = true;\n+    boolean newStep          = true;\n+    boolean lastStep         = false;\n+    boolean firstStepAlreadyComputed = false;\n+    handler.reset();\n+    costPerTimeUnit[0] = 0;\n+    while (! lastStep) {\n+\n+      double h;\n+      double error;\n+      boolean reject = false;\n+\n+      if (newStep) {\n+\n+        interpolator.shift();\n+\n+        // first evaluation, at the beginning of the step\n+        if (! firstStepAlreadyComputed) {\n+          equations.computeDerivatives(currentT, y, yDot0);\n+        }\n+\n+        if (firstTime) {\n+\n+          hNew = initializeStep(equations, forward,\n+                                2 * targetIter + 1, scale,\n+                                currentT, y, yDot0, yTmp, yTmpDot);\n+\n+          if (! forward) {\n+            hNew = -hNew;\n+          }\n+\n+        }\n+\n+        newStep = false;\n+\n+      }\n+\n+      h = hNew;\n+\n+      // step adjustment near bounds\n+      if ((forward && (currentT + h > t))\n+          || ((! forward) && (currentT + h < t))) {\n+        h = t - currentT;\n+      }\n+      double nextT = currentT + h;\n+      lastStep = forward ? (nextT >= t) : (nextT <= t);\n+\n+      // iterate over several substep sizes\n+      int k = -1;\n+      for (boolean loop = true; loop; ) {\n+\n+        ++k;\n+\n+        // modified midpoint integration with the current substep\n+        if ( ! tryStep(equations, currentT, y, h, k, scale, fk[k],\n+                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n+                       (k == 0) ? y1 : y1Diag[k-1],\n+                       yTmp)) {\n+\n+          // the stability check failed, we reduce the global step\n+          hNew   = Math.abs(filterStep(h * stabilityReduction, false));\n+          reject = true;\n+          loop   = false;\n+\n+        } else {\n+\n+          // the substep was computed successfully\n+          if (k > 0) {\n+\n+            // extrapolate the state at the end of the step\n+            // using last iteration data\n+            extrapolate(0, k, y1Diag, y1);\n+            rescale(y, y1, scale);\n+\n+            // estimate the error at the end of the step.\n+            error = 0;\n+            for (int j = 0; j < y0.length; ++j) {\n+              double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];\n+              error += e * e;\n+            }\n+            error = Math.sqrt(error / y0.length);\n+\n+            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n+              // error is too big, we reduce the global step\n+              hNew   = Math.abs(filterStep(h * stabilityReduction, false));\n+              reject = true;\n+              loop   = false;\n+            } else {\n+\n+              maxError = Math.max(4 * error, 1.0);\n+\n+              // compute optimal stepsize for this order\n+              double exp = 1.0 / (2 * k + 1);\n+              double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n+              double pow = Math.pow(stepControl3, exp);\n+              fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n+              optimalStep[k]     = Math.abs(filterStep(h * fac, true));\n+              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n+\n+              // check convergence\n+              switch (k - targetIter) {\n+\n+              case -1 :\n+                if ((targetIter > 1) && ! previousRejected) {\n+\n+                  // check if we can stop iterations now\n+                  if (error <= 1.0) {\n+                    // convergence have been reached just before targetIter\n+                    loop = false;\n+                  } else {\n+                    // estimate if there is a chance convergence will\n+                    // be reached on next iteration, using the\n+                    // asymptotic evolution of error\n+                    double ratio = ((double) sequence [k] * sequence[k+1])\n+                                 / (sequence[0] * sequence[0]);\n+                    if (error > ratio * ratio) {\n+                      // we don't expect to converge on next iteration\n+                      // we reject the step immediately and reduce order\n+                      reject = true;\n+                      loop   = false;\n+                      targetIter = k;\n+                      if ((targetIter > 1)\n+                          && (costPerTimeUnit[targetIter-1]\n+                              < orderControl1 * costPerTimeUnit[targetIter])) {\n+                        --targetIter;\n+                      }\n+                      hNew = optimalStep[targetIter];\n+                    }\n+                  }\n+                }\n+                break;\n+\n+              case 0:\n+                if (error <= 1.0) {\n+                  // convergence has been reached exactly at targetIter\n+                  loop = false;\n+                } else {\n+                  // estimate if there is a chance convergence will\n+                  // be reached on next iteration, using the\n+                  // asymptotic evolution of error\n+                  double ratio = ((double) sequence[k+1]) / sequence[0];\n+                  if (error > ratio * ratio) {\n+                    // we don't expect to converge on next iteration\n+                    // we reject the step immediately\n+                    reject = true;\n+                    loop = false;\n+                    if ((targetIter > 1)\n+                        && (costPerTimeUnit[targetIter-1]\n+                            < orderControl1 * costPerTimeUnit[targetIter])) {\n+                      --targetIter;\n+                    }\n+                    hNew = optimalStep[targetIter];\n+                  }\n+                }\n+                break;\n+\n+              case 1 :\n+                if (error > 1.0) {\n+                  reject = true;\n+                  if ((targetIter > 1)\n+                      && (costPerTimeUnit[targetIter-1]\n+                          < orderControl1 * costPerTimeUnit[targetIter])) {\n+                    --targetIter;\n+                  }\n+                  hNew = optimalStep[targetIter];\n+                }\n+                loop = false;\n+                break;\n+\n+              default :\n+                if ((firstTime || lastStep) && (error <= 1.0)) {\n+                  loop = false;\n+                }\n+                break;\n+\n+              }\n+\n+            }\n+          }\n+        }\n+      }\n+\n+      // dense output handling\n+      double hInt = getMaxStep();\n+      if (denseOutput && ! reject) {\n+\n+        // extrapolate state at middle point of the step\n+        for (int j = 1; j <= k; ++j) {\n+          extrapolate(0, j, diagonal, yMidDots[0]);\n+        }\n+\n+        // derivative at end of step\n+        equations.computeDerivatives(currentT + h, y1, yDot1);\n+\n+        int mu = 2 * k - mudif + 3;\n+\n+        for (int l = 0; l < mu; ++l) {\n+\n+          // derivative at middle point of the step\n+          int l2 = l / 2;\n+          double factor = Math.pow(0.5 * sequence[l2], l);\n+          int middleIndex = fk[l2].length / 2;\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n+          }\n+          for (int j = 1; j <= k - l2; ++j) {\n+            factor = Math.pow(0.5 * sequence[j + l2], l);\n+            middleIndex = fk[l2+j].length / 2;\n+            for (int i = 0; i < y0.length; ++i) {\n+              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n+            }\n+            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n+          }\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] *= h;\n+          }\n+\n+          // compute centered differences to evaluate next derivatives\n+          for (int j = (l + 1) / 2; j <= k; ++j) {\n+            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n+              for (int i = 0; i < y0.length; ++i) {\n+                fk[j][m][i] -= fk[j][m-2][i];\n+              }\n+            }\n+          }\n+\n+        }\n+\n+        if (mu >= 0) {\n+\n+          // estimate the dense output coefficients\n+          GraggBulirschStoerStepInterpolator gbsInterpolator\n+            = (GraggBulirschStoerStepInterpolator) interpolator;\n+          gbsInterpolator.computeCoefficients(mu, h);\n+\n+          if (useInterpolationError) {\n+            // use the interpolation error to limit stepsize\n+            double interpError = gbsInterpolator.estimateError(scale);\n+            hInt = Math.abs(h / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n+                                         0.01));\n+            if (interpError > 10.0) {\n+              hNew = hInt;\n+              reject = true;\n+            }\n+          }\n+\n+          // Switching functions handling\n+          if (!reject) {\n+            interpolator.storeTime(currentT + h);\n+            if (switchesHandler.evaluateStep(interpolator)) {\n+              reject = true;\n+              hNew = Math.abs(switchesHandler.getEventTime() - currentT);\n+            }\n+          }\n+\n+        }\n+\n+        if (!reject) {\n+          // we will reuse the slope for the beginning of next step\n+          firstStepAlreadyComputed = true;\n+          System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n+        }\n+\n+      }\n+\n+      if (! reject) {\n+\n+        // store end of step state\n+        currentT += h;\n+        System.arraycopy(y1, 0, y, 0, y0.length);\n+\n+        switchesHandler.stepAccepted(currentT, y);\n+        if (switchesHandler.stop()) {\n+          lastStep = true;\n+        }\n+\n+        // provide the step data to the step handler\n+        interpolator.storeTime(currentT);\n+        handler.handleStep(interpolator, lastStep);\n+\n+        if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+          // some switching function has triggered changes that\n+          // invalidate the derivatives, we need to recompute them\n+          firstStepAlreadyComputed = false;\n+        }\n+\n+        int optimalIter;\n+        if (k == 1) {\n+          optimalIter = 2;\n+          if (previousRejected) {\n+            optimalIter = 1;\n+          }\n+        } else if (k <= targetIter) {\n+          optimalIter = k;\n+          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n+            optimalIter = k-1;\n+          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n+            optimalIter = Math.min(k+1, sequence.length - 2);\n+          }\n+        } else {\n+          optimalIter = k - 1;\n+          if ((k > 2)\n+              && (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n+            optimalIter = k - 2;\n+          }\n+          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n+            optimalIter = Math.min(k, sequence.length - 2);\n+          }\n+        }\n+\n+        if (previousRejected) {\n+          // after a rejected step neither order nor stepsize\n+          // should increase\n+          targetIter = Math.min(optimalIter, k);\n+          hNew = Math.min(Math.abs(h), optimalStep[targetIter]);\n+        } else {\n+          // stepsize control\n+          if (optimalIter <= k) {\n+            hNew = optimalStep[optimalIter];\n+          } else {\n+            if ((k < targetIter)\n+                && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n+              hNew = filterStep(optimalStep[k]\n+                                * costPerStep[optimalIter+1] / costPerStep[k],\n+                                false);\n+            } else {\n+              hNew = filterStep(optimalStep[k]\n+                                * costPerStep[optimalIter] / costPerStep[k],\n+                                false);\n+            }\n+          }\n+\n+          targetIter = optimalIter;\n+\n+        }\n+\n+        newStep = true;\n+\n+      }\n+\n+      hNew = Math.min(hNew, hInt);\n+      if (! forward) {\n+        hNew = -hNew;\n+      }\n+\n+      firstTime = false;\n+\n+      if (reject) {\n+        lastStep = false;\n+        previousRejected = true;\n+      } else {\n+        previousRejected = false;\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** maximal order. */\n+  private int maxOrder;\n+\n+  /** step size sequence. */\n+  private int[] sequence;\n+\n+  /** overall cost of applying step reduction up to iteration k+1,\n+   *  in number of calls.\n+   */\n+  private int[] costPerStep;\n+\n+  /** cost per unit step. */\n+  private double[] costPerTimeUnit;\n+\n+  /** optimal steps for each order. */\n+  private double[] optimalStep;\n+\n+  /** extrapolation coefficients. */\n+  private double[][] coeff;\n+\n+  /** stability check enabling parameter. */\n+  private boolean performTest;\n+\n+  /** maximal number of checks for each iteration. */\n+  private int maxChecks;\n+\n+  /** maximal number of iterations for which checks are performed. */\n+  private int maxIter;\n+\n+  /** stepsize reduction factor in case of stability check failure. */\n+  private double stabilityReduction;\n+\n+  /** first stepsize control factor. */\n+  private double stepControl1;\n+\n+  /** second stepsize control factor. */\n+  private double stepControl2;\n+\n+  /** third stepsize control factor. */\n+  private double stepControl3;\n+\n+  /** fourth stepsize control factor. */\n+  private double stepControl4;\n+\n+  /** first order control factor. */\n+  private double orderControl1;\n+\n+  /** second order control factor. */\n+  private double orderControl2;\n+\n+  /** dense outpute required. */\n+  private boolean denseOutput;\n+\n+  /** use interpolation error in stepsize control. */\n+  private boolean useInterpolationError;\n+\n+  /** interpolation order control parameter. */\n+  private int mudif;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/**\n+ * This class implements an interpolator for the Gragg-Bulirsch-Stoer\n+ * integrator.\n+\n+ * <p>This interpolator compute dense output inside the last step\n+ * produced by a Gragg-Bulirsch-Stoer integrator.</p>\n+\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+\n+ * @see GraggBulirschStoerIntegrator\n+\n+ * @version $Id: GraggBulirschStoerStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @author L. Maisonobe (Java port)\n+\n+ */\n+\n+class GraggBulirschStoerStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Slope at the beginning of the step. */\n+  private double[] y0Dot;\n+\n+  /** State at the end of the step. */\n+  private double[] y1;\n+\n+  /** Slope at the end of the step. */\n+  private double[] y1Dot;\n+\n+  /** Derivatives at the middle of the step.\n+   * element 0 is state at midpoint, element 1 is first derivative ...\n+   */\n+  private double[][] yMidDots;\n+\n+  /** Interpolation polynoms. */\n+  private double[][] polynoms;\n+\n+  /** Error coefficients for the interpolation. */\n+  private double[] errfac;\n+\n+  /** Degree of the interpolation polynoms. */\n+  private int currentDegree;\n+\n+  /** Reallocate the internal tables.\n+   * Reallocate the internal tables in order to be able to handle\n+   * interpolation polynoms up to the given degree\n+   * @param maxDegree maximal degree to handle\n+   */\n+  private void resetTables(int maxDegree) {\n+\n+    if (maxDegree < 0) {\n+      polynoms      = null;\n+      errfac        = null;\n+      currentDegree = -1;\n+    } else {\n+\n+      double[][] newPols = new double[maxDegree + 1][];\n+      if (polynoms != null) {\n+        System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);\n+        for (int i = polynoms.length; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      } else {\n+        for (int i = 0; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      }\n+      polynoms = newPols;\n+\n+      // initialize the error factors array for interpolation\n+      if (maxDegree <= 4) {\n+        errfac = null;\n+      } else {\n+        errfac = new double[maxDegree - 4];\n+        for (int i = 0; i < errfac.length; ++i) {\n+          int ip5 = i + 5;\n+          errfac[i] = 1.0 / (ip5 * ip5);\n+          double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);\n+          for (int j = 0; j <= i; ++j) {\n+            errfac[i] *= e / (j + 1);\n+          }\n+        }\n+      }\n+\n+      currentDegree = 0;\n+\n+    }\n+\n+  }\n+\n+  /** Simple constructor.\n+   * This constructor should not be used directly, it is only intended\n+   * for the serialization process.\n+   */\n+  public GraggBulirschStoerStepInterpolator() {\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+    resetTables(-1);\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the current state\n+   * @param y0Dot reference to the integrator array holding the slope\n+   * at the beginning of the step\n+   * @param y1 reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param y1Dot reference to the integrator array holding the slope\n+   * at theend of the step\n+   * @param yMidDots reference to the integrator array holding the\n+   * derivatives at the middle point of the step\n+   * @param forward integration direction indicator\n+   */\n+  public GraggBulirschStoerStepInterpolator(double[] y, double[] y0Dot,\n+                                            double[] y1, double[] y1Dot,\n+                                            double[][] yMidDots,\n+                                            boolean forward) {\n+\n+    super(y, forward);\n+    this.y0Dot    = y0Dot;\n+    this.y1       = y1;\n+    this.y1Dot    = y1Dot;\n+    this.yMidDots = yMidDots;\n+\n+    resetTables(yMidDots.length + 4);\n+\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GraggBulirschStoerStepInterpolator\n+    (GraggBulirschStoerStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    int dimension = currentState.length;\n+\n+    // the interpolator has been finalized,\n+    // the following arrays are not needed anymore\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+\n+    // copy the interpolation polynoms (up to the current degree only)\n+    if (interpolator.polynoms == null) {\n+      polynoms = null;\n+      currentDegree = -1;\n+    } else {\n+      resetTables(interpolator.currentDegree);\n+      for (int i = 0; i < polynoms.length; ++i) {\n+        polynoms[i] = new double[dimension];\n+        System.arraycopy(interpolator.polynoms[i], 0,\n+                         polynoms[i], 0, dimension);\n+      }\n+      currentDegree = interpolator.currentDegree;\n+    }\n+\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new GraggBulirschStoerStepInterpolator(this);\n+  }\n+\n+  /** Compute the interpolation coefficients for dense output.\n+   * @param mu degree of the interpolation polynom\n+   * @param h current step\n+   */\n+  public void computeCoefficients(int mu, double h) {\n+\n+    if ((polynoms == null) || (polynoms.length <= (mu + 4))) {\n+      resetTables(mu + 4);\n+    }\n+\n+    currentDegree = mu + 4;\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+\n+      double yp0   = h * y0Dot[i];\n+      double yp1   = h * y1Dot[i];\n+      double ydiff = y1[i] - currentState[i];\n+      double aspl  = ydiff - yp1;\n+      double bspl  = yp0 - ydiff;\n+\n+      polynoms[0][i] = currentState[i];\n+      polynoms[1][i] = ydiff;\n+      polynoms[2][i] = aspl;\n+      polynoms[3][i] = bspl;\n+\n+      if (mu < 0) {\n+        return;\n+      }\n+\n+      // compute the remaining coefficients\n+      double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);\n+      polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);\n+\n+      if (mu > 0) {\n+        double ph1 = ydiff + 0.25 * (aspl - bspl);\n+        polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);\n+\n+        if (mu > 1) {\n+          double ph2 = yp1 - yp0;\n+          polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);\n+\n+          if (mu > 2) {\n+            double ph3 = 6 * (bspl - aspl);\n+            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);\n+\n+            for (int j = 4; j <= mu; ++j) {\n+              double fac1 = 0.5 * j * (j - 1);\n+              double fac2 = 2 * fac1 * (j - 2) * (j - 3);\n+              polynoms[j+4][i] = 16 * (yMidDots[j][i]\n+                                       + fac1 * polynoms[j+2][i]\n+                                       - fac2 * polynoms[j][i]);\n+            }\n+\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Estimate interpolation error.\n+   * @param scale scaling array\n+   * @return estimate of the interpolation error\n+   */\n+  public double estimateError(double[] scale) {\n+    double error = 0;\n+    if (currentDegree >= 5) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        double e = polynoms[currentDegree][i] / scale[i];\n+        error += e * e;\n+      }\n+      error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];\n+    }\n+    return error;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    int dimension = currentState.length;\n+\n+    double oneMinusTheta = 1.0 - theta;\n+    double theta05       = theta - 0.5;\n+    double t4            = theta * oneMinusTheta;\n+    t4 = t4 * t4;\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      interpolatedState[i] = polynoms[0][i]\n+        + theta * (polynoms[1][i]\n+                   + oneMinusTheta * (polynoms[2][i] * theta\n+                                      + polynoms[3][i] * oneMinusTheta));\n+\n+      if (currentDegree > 3) {\n+        double c = polynoms[currentDegree][i];\n+        for (int j = currentDegree - 1; j > 3; --j) {\n+          c = polynoms[j][i] + c * theta05 / (j - 3);\n+        }\n+        interpolatedState[i] += t4 * c;\n+      }\n+    }\n+\n+  }\n+    \n+  /** Save the state of the instance.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    int dimension = currentState.length;\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes (but not the temporary vectors)\n+    out.writeInt(currentDegree);\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        out.writeDouble(polynoms[k][l]);\n+      }\n+    }\n+\n+  }\n+\n+  /** Read the state of the instance.\n+   * @param in stream where to read the state from\n+   * @exception IOException in case of read error\n+   */\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    double t = readBaseExternal(in);\n+    int dimension = currentState.length;\n+\n+    // read the local attributes\n+    int degree = in.readInt();\n+    resetTables(degree);\n+    currentDegree = degree;\n+\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        polynoms[k][l] = in.readDouble();\n+      }\n+    }\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = 7320613236731409847L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54Integrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the 5(4) Higham and Hall integrator for\n+ * Ordinary Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta-Fehlberg integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step.</p>\n+\n+ * @version $Id: HighamHall54Integrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class HighamHall54Integrator\n+  extends RungeKuttaFehlbergIntegrator {\n+\n+  private static final String methodName = \"Higham-Hall 5(4)\";\n+\n+  private static final double[] c = {\n+    2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    {2.0/9.0},\n+    {1.0/12.0, 1.0/4.0},\n+    {1.0/8.0, 0.0, 3.0/8.0},\n+    {91.0/500.0, -27.0/100.0, 78.0/125.0, 8.0/125.0},\n+    {-11.0/20.0, 27.0/20.0, 12.0/5.0, -36.0/5.0, 5.0},\n+    {1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0}\n+  };\n+\n+  private static final double[] b = {\n+    1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0\n+  };\n+\n+  private static final double[] e = {\n+    -1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(double minStep, double maxStep,\n+                                double scalAbsoluteTolerance,\n+                                double scalRelativeTolerance) {\n+    super(false, c, a, b, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(double minStep, double maxStep,\n+                                double[] vecAbsoluteTolerance,\n+                                double[] vecRelativeTolerance) {\n+    super(false, c, a, b, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected double estimateError(double[][] yDotK,\n+                                 double[] y0, double[] y1,\n+                                 double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum = e[0] * yDotK[0][j];\n+      for (int l = 1; l < e.length; ++l) {\n+        errSum += e[l] * yDotK[l][j];\n+      }\n+\n+      double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      double tol = (vecAbsoluteTolerance == null)\n+        ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale)\n+        : (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      double ratio  = h * errSum / tol;\n+      error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Higham and Hall integrator.\n+ *\n+ * @see HighamHall54Integrator\n+ *\n+ * @version $Id: HighamHall54StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+class HighamHall54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaFehlbergIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public HighamHall54StepInterpolator() {\n+    super();\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public HighamHall54StepInterpolator(HighamHall54StepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new HighamHall54StepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double theta2 = theta * theta;\n+\n+    double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));\n+    double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n+    double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n+    double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n+    double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           + b0 * yDotK[0][i] + b2 * yDotK[2][i] + b3 * yDotK[3][i]\n+                           + b4 * yDotK[4][i] + b5 * yDotK[5][i];\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = -3583240427587318654L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/IntegratorException.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered during integration\n+ * @author Luc Maisonobe\n+ * @version $Id: IntegratorException.java 1705 2006-09-17 19:57:39Z luc $\n+ */\n+public class IntegratorException\n+  extends MathException {\n+    \n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public IntegratorException(String specifier, String[] parts) {\n+    super(specifier, parts);\n+  }\n+\n+  private static final long serialVersionUID = -1390328069787882608L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/MidpointIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a second order Runge-Kutta integrator for\n+ * Ordinary Differential Equations.\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0\n+ *   1/2 | 1/2   0\n+ *       |----------\n+ *       |  0    1\n+ * </pre>\n+ * </p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+\n+ * @version $Id: MidpointIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class MidpointIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = \"midpoint\";\n+\n+  private static final double[] c = {\n+    1.0 / 2.0\n+  };\n+\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 }\n+  };\n+\n+  private static final double[] b = {\n+    0.0, 1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a midpoint integrator with the given step.\n+   * @param step integration step\n+   */\n+  public MidpointIntegrator(double step) {\n+    super(false, c, a, b, new MidpointStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/MidpointStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a step interpolator for second order\n+ * Runge-Kutta integrator.\n+\n+ * <p>This interpolator allow to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) + (1-theta) h [theta y'_1 - (1+theta) y'_2]\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y'_1 and y'_2 are the two\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+\n+ * @see MidpointIntegrator\n+\n+ * @version $Id: MidpointStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class MidpointStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public MidpointStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public MidpointStepInterpolator(MidpointStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new MidpointStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double coeff1 = oneMinusThetaH * theta;\n+    double coeff2 = oneMinusThetaH * (1.0 + theta);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                           + coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i];\n+    }\n+\n+  }\n+\n+  private static final long serialVersionUID = -865524111506042509L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaFehlbergIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the common part of all Runge-Kutta-Fehlberg\n+ * integrators for Ordinary Differential Equations.\n+\n+ * <p>These methods are embedded explicit Runge-Kutta methods with two\n+ * sets of coefficients allowing to estimate the error, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ *       |  b'1  b'2 ...   b's-1 b's\n+ * </pre>\n+ * </p>\n+\n+ * <p>In fact, we rather use the array defined by ej = bj - b'j to\n+ * compute directly the error rather than computing two estimates and\n+ * then comparing them.</p>\n+\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+\n+ * @version $Id: RungeKuttaFehlbergIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class RungeKuttaFehlbergIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  protected RungeKuttaFehlbergIntegrator(boolean fsal,\n+                                         double[] c, double[][] a, double[] b,\n+                                         RungeKuttaStepInterpolator prototype,\n+                                         double minStep, double maxStep,\n+                                         double scalAbsoluteTolerance,\n+                                         double scalRelativeTolerance) {\n+\n+    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    this.safety = 0.9;\n+\n+    // set the default values of the algorithm control parameters\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  protected RungeKuttaFehlbergIntegrator(boolean fsal,\n+                                         double[] c, double[][] a, double[] b,\n+                                         RungeKuttaStepInterpolator prototype,\n+                                         double   minStep, double maxStep,\n+                                         double[] vecAbsoluteTolerance,\n+                                         double[] vecRelativeTolerance) {\n+\n+    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    this.safety = 0.9;\n+\n+    // set the default values of the algorithm control parameters\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public abstract String getName();\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public abstract int getOrder();\n+\n+  /** Get the safety factor for stepsize control.\n+   * @return safety factor\n+   */\n+  public double getSafety() {\n+    return safety;\n+  }\n+\n+  /** Set the safety factor for stepsize control.\n+   * @param safety safety factor\n+   */\n+  public void setSafety(double safety) {\n+    this.safety = safety;\n+  }\n+\n+  public void integrate(FirstOrderDifferentialEquations equations,\n+                        double t0, double[] y0,\n+                        double t, double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    // sanity check\n+    if (equations.getDimension() != y0.length) {\n+      throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\"\n+                                    + \" state vector has dimension {1}\",\n+                                    new String[] {\n+                                      Integer.toString(equations.getDimension()),\n+                                      Integer.toString(y0.length)\n+                                    });\n+    }\n+    if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+      throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                    new String[] {\n+                                      Double.toString(Math.abs(t - t0))\n+                                    });\n+    }\n+    \n+    boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {\n+      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    double  currentT  = t0;\n+    double  hNew      = 0;\n+    boolean firstTime = true;\n+    boolean lastStep;\n+    handler.reset();\n+    do {\n+\n+      interpolator.shift();\n+\n+      double h     = 0;\n+      double error = 0;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          equations.computeDerivatives(currentT, y, yDotK[0]);\n+        }\n+\n+        if (firstTime) {\n+          double[] scale;\n+          if (vecAbsoluteTolerance != null) {\n+            scale = vecAbsoluteTolerance;\n+          } else {\n+            scale = new double[y0.length];\n+            for (int i = 0; i < scale.length; ++i) {\n+              scale[i] = scalAbsoluteTolerance;\n+            }\n+          }\n+          hNew = initializeStep(equations, forward, getOrder(), scale,\n+                                currentT, y, yDotK[0], yTmp, yDotK[1]);\n+          firstTime = false;\n+        }\n+\n+        h = hNew;\n+\n+        // step adjustment near bounds\n+        if ((forward && (currentT + h > t))\n+            || ((! forward) && (currentT + h < t))) {\n+          h = t - currentT;\n+        }\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + h * sum;\n+          }\n+\n+          equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + h * sum;\n+        }\n+\n+        // estimate the error at the end of the step\n+        error = estimateError(yDotK, y, yTmp, h);\n+        if (error <= 1.0) {\n+\n+          // Switching functions handling\n+          interpolator.storeTime(currentT + h);\n+          if (switchesHandler.evaluateStep(interpolator)) {\n+            // reject the step to match exactly the next switch time\n+            hNew = switchesHandler.getEventTime() - currentT;\n+          } else {\n+            // accept the step\n+            loop = false;\n+          }\n+\n+        } else {\n+          // reject the step and attempt to reduce error by stepsize control\n+          double factor = Math.min(maxGrowth,\n+                                   Math.max(minReduction,\n+                                            safety * Math.pow(error, exp)));\n+          hNew = filterStep(h * factor, false);\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      currentT += h;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      switchesHandler.stepAccepted(currentT, y);\n+      if (switchesHandler.stop()) {\n+        lastStep = true;\n+      } else {\n+        lastStep = forward ? (currentT >= t) : (currentT <= t);\n+      }\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(currentT);\n+      handler.handleStep(interpolator, lastStep);\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+        // some switching function has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(currentT, y, yDotK[0]);\n+      }\n+\n+      if (! lastStep) {\n+        // stepsize control for next step\n+        double  factor     = Math.min(maxGrowth,\n+                                      Math.max(minReduction,\n+                                               safety * Math.pow(error, exp)));\n+        double  scaledH    = h * factor;\n+        double  nextT      = currentT + scaledH;\n+        boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+        hNew = filterStep(scaledH, nextIsLast);\n+      }\n+\n+    } while (! lastStep);\n+\n+  }\n+\n+  /** Get the minimal reduction factor for stepsize control.\n+   * @return minimal reduction factor\n+   */\n+  public double getMinReduction() {\n+    return minReduction;\n+  }\n+\n+  /** Set the minimal reduction factor for stepsize control.\n+   * @param minReduction minimal reduction factor\n+   */\n+  public void setMinReduction(double minReduction) {\n+    this.minReduction = minReduction;\n+  }\n+\n+  /** Get the maximal growth factor for stepsize control.\n+   * @return maximal growth factor\n+   */\n+  public double getMaxGrowth() {\n+    return maxGrowth;\n+  }\n+\n+  /** Set the maximal growth factor for stepsize control.\n+   * @param maxGrowth maximal growth factor\n+   */\n+  public void setMaxGrowth(double maxGrowth) {\n+    this.maxGrowth = maxGrowth;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected abstract double estimateError(double[][] yDotK,\n+                                          double[] y0, double[] y1,\n+                                          double h);\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Stepsize control exponent. */\n+  private double exp;\n+\n+  /** Safety factor for stepsize control. */\n+  private double safety;\n+\n+  /** Minimal reduction factor for stepsize control. */\n+  private double minReduction;\n+\n+  /** Maximal growth factor for stepsize control. */\n+  private double maxGrowth;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the common part of all fixed step Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+\n+ * <p>These methods are explicit Runge-Kutta methods, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ * </pre>\n+ * </p>\n+\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+\n+ * @version $Id: RungeKuttaIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public abstract class RungeKuttaIntegrator\n+  implements FirstOrderIntegrator {\n+\n+  /** Simple constructor.\n+   * Build a Runge-Kutta integrator with the given\n+   * step. The default step handler does nothing.\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b external weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param step integration step\n+   */\n+  protected RungeKuttaIntegrator(boolean fsal,\n+                                 double[] c, double[][] a, double[] b,\n+                                 RungeKuttaStepInterpolator prototype,\n+                                 double step) {\n+    this.fsal       = fsal;\n+    this.c          = c;\n+    this.a          = a;\n+    this.b          = b;\n+    this.prototype  = prototype;\n+    this.step       = step;\n+    handler         = DummyStepHandler.getInstance();\n+    switchesHandler = new SwitchingFunctionsHandler();\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public abstract String getName();\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler) {\n+    this.handler = handler;\n+  }\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler() {\n+    return handler;\n+  }\n+\n+  /** Add a switching function to the integrator.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void addSwitchingFunction(SwitchingFunction function,\n+                                   double maxCheckInterval,\n+                                   double convergence) {\n+    switchesHandler.add(function, maxCheckInterval, convergence);\n+  }\n+\n+  public void integrate(FirstOrderDifferentialEquations equations,\n+                        double t0, double[] y0,\n+                        double t, double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    // sanity check\n+    if (equations.getDimension() != y0.length) {\n+      throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\"\n+                                    + \" state vector has dimension {1}\",\n+                                    new String[] {\n+                                      Integer.toString(equations.getDimension()),\n+                                      Integer.toString(y0.length)\n+                                    });\n+    }\n+    if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+      throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                    new String[] {\n+                                      Double.toString(Math.abs(t - t0))\n+                                    });\n+    }\n+    \n+    boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {\n+      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    // recompute the step\n+    double  currentT  = t0;\n+    long    nbStep    = Math.max(1l, Math.abs(Math.round((t - t0) / step)));\n+    double  h         = (t - t0) / nbStep;\n+    boolean firstTime = true;\n+    boolean lastStep  = false;\n+    handler.reset();\n+    for (long i = 0; ! lastStep; ++i) {\n+\n+      interpolator.shift();\n+\n+      boolean needUpdate = false;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          equations.computeDerivatives(currentT, y, yDotK[0]);\n+          firstTime = false;\n+        }\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + h * sum;\n+          }\n+\n+          equations.computeDerivatives(currentT + c[k-1] * h, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + h * sum;\n+        }\n+\n+        // Switching functions handling\n+        interpolator.storeTime(currentT + h);\n+        if (switchesHandler.evaluateStep(interpolator)) {\n+          needUpdate = true;\n+          h = switchesHandler.getEventTime() - currentT;\n+        } else {\n+          loop = false;\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      currentT += h;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      switchesHandler.stepAccepted(currentT, y);\n+      if (switchesHandler.stop()) {\n+        lastStep = true;\n+      } else {\n+        lastStep = (i == (nbStep - 1));\n+      }\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(currentT);\n+      handler.handleStep(interpolator, lastStep);\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+        // some switching function has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(currentT, y, yDotK[0]);\n+      }\n+\n+      if (needUpdate) {\n+        // a switching function has changed the step\n+        // we need to recompute stepsize\n+        nbStep = Math.max(1l, Math.abs(Math.round((t - currentT) / step)));\n+        h = (t - currentT) / nbStep;\n+        i = -1;\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Integration step. */\n+  private double step;\n+\n+  /** Step handler. */\n+  private StepHandler handler;\n+\n+  /** Switching functions handler. */\n+  protected SwitchingFunctionsHandler switchesHandler;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for Runge-Kutta and Runge-Kutta-Fehlberg\n+ * integrators.\n+ *\n+ * @see RungeKuttaIntegrator\n+ * @see RungeKuttaFehlbergIntegrator\n+ *\n+ * @version $Id: RungeKuttaStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+abstract class RungeKuttaStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} and {@link\n+   * RungeKuttaFehlbergIntegrator} classes uses the prototyping design\n+   * pattern to create the step interpolators by cloning an\n+   * uninitialized model and latter initializing the copy.\n+   */\n+  protected RungeKuttaStepInterpolator() {\n+    super();\n+    yDotK     = null;\n+    equations = null;\n+  }\n+\n+  /** Copy constructor.\n+\n+  * <p>The copied interpolator should have been finalized before the\n+  * copy, otherwise the copy will not be able to perform correctly any\n+  * interpolation and will throw a {@link NullPointerException}\n+  * later. Since we don't want this constructor to throw the\n+  * exceptions finalization may involve and since we don't want this\n+  * method to modify the state of the copied interpolator,\n+  * finalization is <strong>not</strong> done automatically, it\n+  * remains under user control.</p>\n+\n+  * <p>The copy is a deep copy: its arrays are separated from the\n+  * original arrays of the instance.</p>\n+\n+  * @param interpolator interpolator to copy from.\n+\n+  */\n+  public RungeKuttaStepInterpolator(RungeKuttaStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState != null) {\n+      int dimension = currentState.length;\n+\n+      yDotK = new double[interpolator.yDotK.length][];\n+      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n+        yDotK[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotK[k], 0,\n+                         yDotK[k], 0, dimension);\n+      }\n+\n+    } else {\n+      yDotK = null;\n+    }\n+\n+    // we cannot keep any reference to the equations in the copy\n+    // the interpolator should have been finalized before\n+    equations = null;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n+   * than their counterpart step interpolators. So the interpolator\n+   * should perform the last evaluations they need by themselves. The\n+   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n+   * RungeKuttaFehlbergIntegrator RungeKuttaFehlbergIntegrator}\n+   * abstract classes call this method in order to let the step\n+   * interpolator perform the evaluations it needs. These evaluations\n+   * will be performed during the call to <code>doFinalize</code> if\n+   * any, i.e. only if the step handler either calls the {@link\n+   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n+   * {@link AbstractStepInterpolator#getInterpolatedState\n+   * getInterpolatedState} method (for an interpolator which needs a\n+   * finalization) or if it clones the step interpolator.</p>\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(FirstOrderDifferentialEquations equations,\n+                           double[] y, double[][] yDotK, boolean forward) {\n+    reinitialize(y, forward);\n+    this.yDotK = yDotK;\n+    this.equations = equations;\n+  }\n+\n+  /** Save the state of the instance.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  public void writeExternal(ObjectOutput out)\n+    throws IOException {\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes\n+    out.writeInt(yDotK.length);\n+    for (int k = 0; k < yDotK.length; ++k) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        out.writeDouble(yDotK[k][i]);\n+      }\n+    }\n+\n+    // we do not save any reference to the equations\n+\n+  }\n+\n+  /** Read the state of the instance.\n+   * @param in stream where to read the state from\n+   * @exception IOException in case of read error\n+   */\n+  public void readExternal(ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    double t = readBaseExternal(in);\n+\n+    // read the local attributes\n+    int kMax = in.readInt();\n+    yDotK = new double[kMax][];\n+    for (int k = 0; k < kMax; ++k) {\n+      yDotK[k] = new double[currentState.length];\n+      for (int i = 0; i < currentState.length; ++i) {\n+        yDotK[k][i] = in.readDouble();\n+      }\n+    }\n+\n+    equations = null;\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw new IOException(e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Slopes at the intermediate points */\n+  protected double[][] yDotK;\n+\n+  /** Reference to the differential equations beeing integrated. */\n+  protected FirstOrderDifferentialEquations equations;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/** This interface represents a second order differential equations set.\n+\n+ * <p>This interface should be implemented by all real second order\n+ * differential equation problems before they can be handled by the\n+ * integrators {@link SecondOrderIntegrator#integrate} method.</p>\n+\n+ * <p>A second order differential equations problem, as seen by an\n+ * integrator is the second time derivative <code>d2Y/dt^2</code> of a\n+ * state vector <code>Y</code>, both being one dimensional\n+ * arrays. From the integrator point of view, this derivative depends\n+ * only on the current time <code>t</code>, on the state vector\n+ * <code>Y</code> and on the first time derivative of the state\n+ * vector.</p>\n+\n+ * <p>For real problems, the derivative depends also on parameters\n+ * that do not belong to the state vector (dynamical model constants\n+ * for example). These constants are completely outside of the scope\n+ * of this interface, the classes that implement it are allowed to\n+ * handle them as they want.</p>\n+\n+ * @see SecondOrderIntegrator\n+ * @see FirstOrderConverter\n+ * @see FirstOrderDifferentialEquations\n+ * @see org.spaceroots.mantissa.utilities.ArraySliceMappable\n+\n+ * @version $Id: SecondOrderDifferentialEquations.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface SecondOrderDifferentialEquations {\n+\n+  /** Get the dimension of the problem.\n+   * @return dimension of the problem\n+   */\n+  public int getDimension();\n+    \n+  /** Get the current time derivative of the state vector.\n+   * @param t current value of the independant <I>time</I> variable\n+   * @param y array containing the current value of the state vector\n+   * @param yDot array containing the current value of the first derivative\n+   * of the state vector\n+   * @param yDDot placeholder array where to put the second time derivative\n+   * of the state vector\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n+                                       double[] yDDot)\n+  throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/** This interface represents a second order integrator for\n+ * differential equations.\n+\n+ * <p>The classes which are devoted to solve second order differential\n+ * equations should implement this interface. The problems which can\n+ * be handled should implement the {@link\n+ * SecondOrderDifferentialEquations} interface.</p>\n+\n+ * @see SecondOrderDifferentialEquations\n+\n+ * @version $Id: SecondOrderIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface SecondOrderIntegrator {\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName();\n+\n+  /** Set the step handler for this integrator.\n+   * The handler will be called by the integrator for each accepted\n+   * step.\n+   * @param handler handler for the accepted steps\n+   */\n+  public void setStepHandler (StepHandler handler);\n+\n+  /** Get the step handler for this integrator.\n+   * @return the step handler for this integrator\n+   */\n+  public StepHandler getStepHandler();\n+\n+  /** Integrate the differential equations up to the given time\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param yDot0 initial value of the first derivative of the state\n+   * vector at t0\n+   * @param t target time for the integration\n+   * (can be set to a value smaller thant <code>t0</code> for backward integration)\n+   * @param y placeholder where to put the state vector at each\n+   * successful step (and hence at the end of integration), can be the\n+   * same object as y0\n+   * @param yDot placeholder where to put the first derivative of\n+   * the state vector at time t, can be the same object as yDot0\n+   * @throws IntegratorException if the integrator cannot perform integration\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  public void integrate(SecondOrderDifferentialEquations equations,\n+                        double t0, double[] y0, double[] yDot0,\n+                        double t, double[] y, double[] yDot)\n+  throws DerivativeException, IntegratorException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/StepHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful step.\n+\n+ * <p>The ODE integrators compute the evolution of the state vector at\n+ * some grid points that depend on their own internal algorithm. Once\n+ * they have found a new grid point (possibly after having computed\n+ * several evaluation of the derivative at intermediate points), they\n+ * provide it to objects implementing this interface. These objects\n+ * typically either ignore the intermediate steps and wait for the\n+ * last one, store the points in an ephemeris, or forward them to\n+ * specialized processing or output methods.</p>\n+\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepInterpolator\n+\n+ * @version $Id: StepHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public interface StepHandler {\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>This method allows the integrator to avoid performing extra\n+   * computation if the handler does not need dense output. If this\n+   * method returns false, the integrator will call the {@link\n+   * #handleStep} method with a {@link DummyStepInterpolator} rather\n+   * than a custom interpolator.</p>\n+   * @return true if the handler needs dense output\n+   */\n+  public boolean requiresDenseOutput();\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset();\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range, as the\n+   * {@link ContinuousOutputModel ContinuousOutputModel} class does),\n+   * it should build a local copy using the clone method of the\n+   * interpolator and store this copy. Keeping only a reference to the\n+   * interpolator and reusing it will result in unpredictable\n+   * behaviour (potentially crashing the application).\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/StepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.Externalizable;\n+\n+/** This interface represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects implementing this\n+ * interface to the step handlers. These objects are often custom\n+ * objects tightly bound to the integrator internal algorithms. The\n+ * handlers can use these objects to retrieve the state vector at\n+ * intermediate times between the previous and the current grid points\n+ * (this feature is often called dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ *\n+ * @version $Id: StepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public interface StepInterpolator\n+  extends Externalizable {\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime();\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime();\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime();\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed\n+   * (it was not allowed up to version 5.4 of Mantissa), but should be\n+   * used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * @param time time of the interpolated point\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public void setInterpolatedTime(double time)\n+    throws DerivativeException;\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   */\n+  public double[] getInterpolatedState();\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by\n+   * the integrator itself, it avoid some nasty problems in\n+   * degenerated cases like null steps due to cancellation at step\n+   * initialization, step control or switching function\n+   * triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/StepNormalizer.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class wraps an object implementing {@link FixedStepHandler}\n+ * into a {@link StepHandler}.\n+\n+ * <p>This wrapper allows to use fixed step handlers with general\n+ * integrators which cannot guaranty their integration steps will\n+ * remain constant and therefore only accept general step\n+ * handlers.</p>\n+\n+ * <p>The stepsize used is selected at construction time. The {@link\n+ * FixedStepHandler#handleStep handleStep} method of the underlying\n+ * {@link FixedStepHandler} object is called at the beginning time of\n+ * the integration t0 and also at times t0+h, t0+2h, ... If the\n+ * integration range is an integer multiple of the stepsize, then the\n+ * last point handled will be the endpoint of the integration tend, if\n+ * not, the last point will belong to the interval [tend - h ;\n+ * tend].</p>\n+\n+ * <p>There is no constraint on the integrator, it can use any\n+ * timestep it needs (time steps longer or shorter than the fixed time\n+ * step and non-integer ratios are all allowed).</p>\n+\n+ * @see StepHandler\n+ * @see FixedStepHandler\n+\n+ * @version $Id: StepNormalizer.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class StepNormalizer\n+  implements StepHandler {\n+\n+  /** Simple constructor.\n+   * @param h fixed time step (sign is not used)\n+   * @param handler fixed time step handler to wrap\n+   */\n+  public StepNormalizer(double h, FixedStepHandler handler) {\n+    this.h       = Math.abs(h);\n+    this.handler = handler;\n+    reset();\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * This handler needs dense output in order to provide data at\n+   * regularly spaced steps regardless of the steps the integrator\n+   * uses, so this method always returns true.\n+   * @return always true\n+   */\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+    lastTime  = Double.NaN;\n+    lastState = null;\n+    forward   = true;\n+  }\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range), it\n+   * should build a local copy using the clone method and store this\n+   * copy.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException {\n+\n+    double nextTime;\n+\n+    if (lastState == null) {\n+\n+      lastTime = interpolator.getPreviousTime();\n+      interpolator.setInterpolatedTime(lastTime);\n+\n+      double[] state = interpolator.getInterpolatedState();\n+      lastState = (double[]) state.clone();\n+\n+      // take the integration direction into account\n+      forward = (interpolator.getCurrentTime() >= lastTime);\n+      if (! forward) {\n+        h = -h;\n+      }\n+\n+    }\n+\n+    nextTime = lastTime + h;\n+    boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+    while (nextInStep) {\n+\n+      // output the stored previous step\n+      handler.handleStep(lastTime, lastState, false);\n+\n+      // store the next step\n+      lastTime = nextTime;\n+      interpolator.setInterpolatedTime(lastTime);\n+      System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                       lastState, 0, lastState.length);\n+\n+      nextTime  += h;\n+      nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+\n+    }\n+\n+    if (isLast) {\n+      // there will be no more steps,\n+      // the stored one should be flagged as being the last\n+      handler.handleStep(lastTime, lastState, true);\n+    }\n+\n+  }\n+\n+  /** Fixed time step. */\n+  private double h;\n+\n+  /** Underlying step handler. */\n+  private FixedStepHandler handler;\n+\n+  /** Last step time. */\n+  private double lastTime;\n+\n+  /** Last State vector. */\n+  private double[] lastState;\n+\n+  /** Integration direction indicator. */\n+  private boolean forward;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/SwitchState.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.BrentSolver;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealSolver;\n+\n+/** This class handles the state for one {@link SwitchingFunction\n+ * switching function} during integration steps.\n+ *\n+ * <p>Each time the integrator proposes a step, the switching function\n+ * should be checked. This class handles the state of one function\n+ * during one integration step, with references to the state at the\n+ * end of the preceding step. This information is used to determine if\n+ * the function should trigger an event or not during the proposed\n+ * step (and hence the step should be reduced to ensure the event\n+ * occurs at a bound rather than inside the step).</p>\n+ *\n+ * @version $Id: SwitchState.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+class SwitchState implements Serializable {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 3256541562455482289L;\n+\n+  /** Switching function. */\n+  private SwitchingFunction function;\n+\n+  /** Maximal time interval between switching function checks. */\n+  private double maxCheckInterval;\n+\n+  /** Convergence threshold for event localisation. */\n+  private double convergence;\n+\n+  /** Time at the beginning of the step. */\n+  private double t0;\n+\n+  /** Value of the switching function at the beginning of the step. */\n+  private double g0;\n+\n+  /** Simulated sign of g0 (we cheat when crossing events). */\n+  private boolean g0Positive;\n+\n+  /** Indicator of event expected during the step. */\n+  private boolean pendingEvent;\n+\n+  /** Occurrence time of the pending event. */\n+  private double pendingEventTime;\n+\n+  /** Occurrence time of the previous event. */\n+  private double previousEventTime;\n+\n+  /** Variation direction around pending event.\n+   *  (this is considered with respect to the integration direction)\n+   */\n+  private boolean increasing;\n+\n+  /** Next action indicator. */\n+  private int nextAction;\n+\n+  /** Simple constructor.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public SwitchState(SwitchingFunction function,\n+                     double maxCheckInterval, double convergence) {\n+    this.function         = function;\n+    this.maxCheckInterval = maxCheckInterval;\n+    this.convergence      = Math.abs(convergence);\n+\n+    // some dummy values ...\n+    t0                = Double.NaN;\n+    g0                = Double.NaN;\n+    g0Positive        = true;\n+    pendingEvent      = false;\n+    pendingEventTime  = Double.NaN;\n+    previousEventTime = Double.NaN;\n+    increasing        = true;\n+    nextAction        = SwitchingFunction.CONTINUE;\n+\n+  }\n+\n+  /** Reinitialize the beginning of the step.\n+   * @param t0 value of the independant <i>time</i> variable at the\n+   * beginning of the step\n+   * @param y0 array containing the current value of the state vector\n+   * at the beginning of the step\n+   */\n+  public void reinitializeBegin(double t0, double[] y0) {\n+    this.t0 = t0;\n+    g0 = function.g(t0, y0);\n+    g0Positive = (g0 >= 0);\n+  }\n+\n+  /** Evaluate the impact of the proposed step on the switching function.\n+   * @param interpolator step interpolator for the proposed step\n+   * @return true if the switching function triggers an event before\n+   * the end of the proposed step (this implies the step should be\n+   * rejected)\n+   */\n+  public boolean evaluateStep(final StepInterpolator interpolator) {\n+\n+    try {\n+\n+      double t1 = interpolator.getCurrentTime();\n+      int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n+      double h  = (t1 - t0) / n;\n+\n+      double ta = t0;\n+      double ga = g0;\n+      double tb = t0 + ((t1 > t0) ? convergence : -convergence);\n+      for (int i = 0; i < n; ++i) {\n+\n+        // evaluate function value at the end of the substep\n+        tb += h;\n+        interpolator.setInterpolatedTime(tb);\n+        double gb = function.g(tb, interpolator.getInterpolatedState());\n+\n+        // check events occurrence\n+        if (g0Positive ^ (gb >= 0)) {\n+          // there is a sign change: an event is expected during this step\n+\n+          // variation direction, with respect to the integration direction\n+          increasing = (gb >= ga);\n+\n+          try {\n+              UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {\n+                  public double value(double t) throws FunctionEvaluationException {\n+                      try {\n+                          interpolator.setInterpolatedTime(t);\n+                          return function.g(t, interpolator.getInterpolatedState());\n+                      } catch (DerivativeException e) {\n+                          throw new FunctionEvaluationException(t, e);\n+                      }\n+                  }\n+              });\n+              solver.setAbsoluteAccuracy(convergence);\n+              solver.setMaximalIterationCount(1000);\n+              double root = solver.solve(ta, tb);\n+              if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\n+                  pendingEventTime = root;\n+                  if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                      // we were already waiting for this event which was\n+                      // found during a previous call for a step that was\n+                      // rejected, this step must now be accepted since it\n+                      // properly ends exactly at the event occurrence\n+                      return false;\n+                  }\n+                  // either we were not waiting for the event or it has\n+                  // moved in such a way the step cannot be accepted\n+                  pendingEvent = true;\n+                  return true;\n+              }\n+          } catch (ConvergenceException ce) {\n+              throw new RuntimeException(\"internal error\");\n+          }\n+\n+        } else {\n+          // no sign change: there is no event for now\n+          ta = tb;\n+          ga = gb;\n+        }\n+\n+      }\n+\n+      // no event during the whole step\n+      pendingEvent     = false;\n+      pendingEventTime = Double.NaN;\n+      return false;\n+\n+    } catch (DerivativeException e) {\n+      throw new RuntimeException(\"unexpected exception: \" + e.getMessage());\n+    } catch (FunctionEvaluationException e) {\n+      throw new RuntimeException(\"unexpected exception: \" + e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Get the occurrence time of the event triggered in the current\n+   * step.\n+   * @return occurrence time of the event triggered in the current\n+   * step.\n+   */\n+  public double getEventTime() {\n+    return pendingEventTime;\n+  }\n+\n+  /** Acknowledge the fact the step has been accepted by the integrator.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * end of the step\n+   * @param y array containing the current value of the state vector\n+   * at the end of the step\n+   */\n+  public void stepAccepted(double t, double[] y) {\n+\n+    t0 = t;\n+    g0 = function.g(t, y);\n+\n+    if (pendingEvent) {\n+      // force the sign to its value \"just after the event\"\n+      previousEventTime = t;\n+      g0Positive        = increasing;\n+      nextAction        = function.eventOccurred(t, y);\n+    } else {\n+      g0Positive = (g0 >= 0);\n+      nextAction = SwitchingFunction.CONTINUE;\n+    }\n+  }\n+\n+  /** Check if the integration should be stopped at the end of the\n+   * current step.\n+   * @return true if the integration should be stopped\n+   */\n+  public boolean stop() {\n+    return nextAction == SwitchingFunction.STOP;\n+  }\n+\n+  /** Let the switching function reset the state if it wants.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * beginning of the next step\n+   * @param y array were to put the desired state vector at the beginning\n+   * of the next step\n+   * @return true if the integrator should reset the derivatives too\n+   */\n+  public boolean reset(double t, double[] y) {\n+\n+    if (! pendingEvent) {\n+      return false;\n+    }\n+\n+    if (nextAction == SwitchingFunction.RESET_STATE) {\n+      function.resetState(t, y);\n+    }\n+    pendingEvent      = false;\n+    pendingEventTime  = Double.NaN;\n+\n+    return (nextAction == SwitchingFunction.RESET_STATE)\n+        || (nextAction == SwitchingFunction.RESET_DERIVATIVES);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunction.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n+\n+/** This interface represents a switching function.\n+ *\n+ * <p>A switching function allows to handle discrete events in\n+ * integration problems. These events occur for example when the\n+ * integration process should be stopped as some value is reached\n+ * (G-stop facility), or when the derivatives have\n+ * discontinuities, or simply when the user wants to monitor some\n+ * states boundaries crossings. These events are traditionally defined\n+ * as occurring when a <code>g</code> function sign changes, hence\n+ * the name <em>switching functions</em>.</p>\n+ *\n+ * <p>Since events are only problem-dependent and are triggered by the\n+ * independant <i>time</i> variable and the state vector, they can\n+ * occur at virtually any time, unknown in advance. The integrators will\n+ * take care to avoid sign changes inside the steps, they will reduce\n+ * the step size when such an event is detected in order to put this\n+ * event exactly at the end of the current step. This guarantees that\n+ * step interpolation (which always has a one step scope) is relevant\n+ * even in presence of discontinuities. This is independent from the\n+ * stepsize control provided by integrators that monitor the local\n+ * error (this feature is available on all integrators, including\n+ * fixed step ones).</p>\n+ *\n+ * @version $Id: SwitchingFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public interface SwitchingFunction extends Serializable {\n+\n+  /** Stop indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should be\n+   * stopped after the event ending the current step.</p>\n+   */\n+  public static final int STOP = 0;\n+\n+  /** Reset state indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new state\n+   * vector (which will be retrieved thanks to the {@link #resetState\n+   * resetState} method).</p>\n+   */\n+  public static final int RESET_STATE = 1;\n+\n+  /** Reset derivatives indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new derivatives\n+   * vector (which will be retrieved thanks to the {@link\n+   * FirstOrderDifferentialEquations#computeDerivatives} method).</p>\n+   */\n+  public static final int RESET_DERIVATIVES = 2;\n+\n+  /** Continue indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should go\n+   * on after the event ending the current step.</p>\n+   */\n+  public static final int CONTINUE = 3;\n+\n+  /** Compute the value of the switching function.\n+\n+   * <p>Discrete events are generated when the sign of this function\n+   * changes, the integrator will take care to change the stepsize in\n+   * such a way these events occur exactly at step boundaries. This\n+   * function must be continuous (at least in its roots neighborhood),\n+   * as the integrator will need to find its roots to locate the events.</p>\n+\n+   * @param t current value of the independant <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return value of the g function\n+   */\n+  public double g(double t, double[] y);\n+\n+  /** Handle an event and choose what to do next.\n+\n+   * <p>This method is called when the integrator has accepted a step\n+   * ending exactly on a sign change of the function, just before the\n+   * step handler itself is called. It allows the user to update his\n+   * internal data to acknowledge the fact the event has been handled\n+   * (for example setting a flag in the {@link\n+   * FirstOrderDifferentialEquations differential equations} to switch\n+   * the derivatives computation in case of discontinuity), or to\n+   * direct the integrator to either stop or continue integration,\n+   * possibly with a reset state or derivatives.</p>\n+\n+   * <ul>\n+   *   <li>if {@link #STOP} is returned, the step handler will be called\n+   *   with the <code>isLast</code> flag of the {@link\n+   *   StepHandler#handleStep handleStep} method set to true and the\n+   *   integration will be stopped,</li>\n+   *   <li>if {@link #RESET_STATE} is returned, the {@link #resetState\n+   *   resetState} method will be called once the step handler has\n+   *   finished its task, and the integrator will also recompute the\n+   *   derivatives,</li>\n+   *   <li>if {@link #RESET_DERIVATIVES} is returned, the integrator\n+   *   will recompute the derivatives,\n+   *   <li>if {@link #CONTINUE} is returned, no specific action will\n+   *   be taken (apart from having called this method) and integration\n+   *   will continue.</li>\n+   * </ul>\n+\n+   * @param t current value of the independant <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return indication of what the integrator should do next, this\n+   * value must be one of {@link #STOP}, {@link #RESET_STATE},\n+   * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n+   */\n+  public int eventOccurred(double t, double[] y);\n+  \n+  /** Reset the state prior to continue the integration.\n+\n+   * <p>This method is called after the step handler has returned and\n+   * before the next step is started, but only when {@link\n+   * #eventOccurred} has itself returned the {@link #RESET_STATE}\n+   * indicator. It allows the user to reset the state vector for the\n+   * next step, without perturbing the step handler of the finishing\n+   * step. If the {@link #eventOccurred} never returns the {@link\n+   * #RESET_STATE} indicator, this function will never be called, and it is\n+   * safe to leave its body empty.</p>\n+\n+   * @param t current value of the independant <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * the new state should be put in the same array\n+   */\n+  public void resetState(double t, double[] y);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+\n+/** This class handles several {@link SwitchingFunction switching\n+ * functions} during integration.\n+ *\n+ * @see SwitchingFunction\n+ *\n+ * @version $Id: SwitchingFunctionsHandler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+ *\n+ */\n+\n+public class SwitchingFunctionsHandler {\n+\n+  /** Simple constructor.\n+   * Create an empty handler\n+   */\n+  public SwitchingFunctionsHandler() {\n+    functions   = new ArrayList();\n+    first       = null;\n+    initialized = false;\n+  }\n+\n+  /** Add a switching function.\n+   * @param function switching function\n+   * @param maxCheckInterval maximal time interval between switching\n+   * function checks (this interval prevents missing sign changes in\n+   * case the integration steps becomes very large)\n+   * @param convergence convergence threshold in the event time search\n+   */\n+  public void add(SwitchingFunction function,\n+                  double maxCheckInterval, double convergence) {\n+    functions.add(new SwitchState(function, maxCheckInterval, convergence));\n+  }\n+\n+  /** Check if the handler does not have any condition.\n+   * @return true if handler is empty\n+   */\n+  public boolean isEmpty() {\n+    return functions.isEmpty();\n+  }\n+\n+  /** Evaluate the impact of the proposed step on all handled\n+   * switching functions.\n+   * @param interpolator step interpolator for the proposed step\n+   * @return true if at least one switching function triggers an event\n+   * before the end of the proposed step (this implies the step should\n+   * be rejected)\n+   */\n+  public boolean evaluateStep(StepInterpolator interpolator) {\n+\n+    try {\n+\n+      first = null;\n+      if (functions.isEmpty()) {\n+        // there is nothing to do, return now to avoid setting the\n+        // interpolator time (and hence avoid unneeded calls to the\n+        // user function due to interpolator finalization)\n+        return false;\n+      }\n+\n+      if (! initialized) {\n+\n+        // initialize the switching functions\n+        double t0 = interpolator.getPreviousTime();\n+        interpolator.setInterpolatedTime(t0);\n+        double [] y = interpolator.getInterpolatedState();\n+        for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+          ((SwitchState) iter.next()).reinitializeBegin(t0, y);\n+        }\n+\n+        initialized = true;\n+\n+      }\n+\n+      // check events occurrence\n+      for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+\n+        SwitchState state = (SwitchState) iter.next();\n+        if (state.evaluateStep(interpolator)) {\n+          if (first == null) {\n+            first = state;\n+          } else {\n+            if (interpolator.isForward()) {\n+              if (state.getEventTime() < first.getEventTime()) {\n+                first = state;\n+              }\n+            } else {\n+              if (state.getEventTime() > first.getEventTime()) {\n+                first = state;\n+              }\n+            }\n+          }\n+        }\n+\n+      }\n+\n+      return first != null;\n+\n+    } catch (DerivativeException e) {\n+      throw new RuntimeException(\"unexpected exception: \" + e.getMessage());\n+    }\n+\n+  }\n+\n+  /** Get the occurrence time of the first event triggered in the\n+   * last evaluated step.\n+   * @return occurrence time of the first event triggered in the last\n+   * evaluated step, or </code>Double.NaN</code> if no event is\n+   * triggered\n+   */\n+  public double getEventTime() {\n+    return (first == null) ? Double.NaN : first.getEventTime();\n+  }\n+\n+  /** Inform the switching functions that the step has been accepted\n+   * by the integrator.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * end of the step\n+   * @param y array containing the current value of the state vector\n+   * at the end of the step\n+   */\n+  public void stepAccepted(double t, double[] y) {\n+    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+      ((SwitchState) iter.next()).stepAccepted(t, y);\n+    }\n+  }\n+\n+  /** Check if the integration should be stopped at the end of the\n+   * current step.\n+   * @return true if the integration should be stopped\n+   */\n+  public boolean stop() {\n+    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+      if (((SwitchState) iter.next()).stop()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /** Let the switching functions reset the state if they want.\n+   * @param t value of the independant <i>time</i> variable at the\n+   * beginning of the next step\n+   * @param y array were to put the desired state vector at the beginning\n+   * of the next step\n+   * @return true if the integrator should reset the derivatives too\n+   */\n+  public boolean reset(double t, double[] y) {\n+    boolean resetDerivatives = false;\n+    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n+      if (((SwitchState) iter.next()).reset(t, y)) {\n+        resetDerivatives = true;\n+      }\n+    }\n+    return resetDerivatives;\n+  }\n+\n+  /** Switching functions. */\n+  private ArrayList functions;\n+\n+  /** First active switching function. */\n+  private SwitchState first;\n+\n+  /** Initialization indicator. */\n+  private boolean initialized;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/ThreeEighthesIntegrator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements the 3/8 fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations.\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/3 | 1/3   0    0    0\n+ *   2/3 |-1/3   1    0    0\n+ *    1  |  1   -1    1    0\n+ *       |--------------------\n+ *       | 1/8  3/8  3/8  1/8\n+ * </pre>\n+ * </p>\n+\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+\n+ * @version $Id: ThreeEighthesIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+public class ThreeEighthesIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  private static final String methodName = \"3/8\";\n+\n+  private static final double[] c = {\n+    1.0 / 3.0, 2.0 / 3.0, 1.0\n+  };\n+\n+  private static final double[][] a = {\n+    {  1.0 / 3.0 },\n+    { -1.0 / 3.0, 1.0 },\n+    {  1.0, -1.0, 1.0 }\n+  };\n+\n+  private static final double[] b = {\n+    1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a 3/8 integrator with the given step.\n+   * @param step integration step\n+   */\n+  public ThreeEighthesIntegrator(double step) {\n+    super(false, c, a, b, new ThreeEighthesStepInterpolator(), step);\n+  }\n+\n+  /** Get the name of the method.\n+   * @return name of the method\n+   */\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/ThreeEighthesStepInterpolator.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class implements a step interpolator for the 3/8 fourth\n+ * order Runge-Kutta integrator.\n+\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/8) [ (1 - 7 theta + 8 theta^2) y'_1\n+ *                                      + 3 (1 +   theta - 4 theta^2) y'_2\n+ *                                      + 3 (1 +   theta)             y'_3\n+ *                                      +   (1 +   theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+\n+ * @see ThreeEighthesIntegrator\n+\n+ * @version $Id: ThreeEighthesStepInterpolator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @author L. Maisonobe\n+\n+ */\n+\n+class ThreeEighthesStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public ThreeEighthesStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public ThreeEighthesStepInterpolator(ThreeEighthesStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /**\n+   * Clone the instance.\n+   * the copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new ThreeEighthesStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(double theta,\n+                                          double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    double fourTheta2 = 4 * theta * theta;\n+    double s          = oneMinusThetaH / 8.0;\n+    double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);\n+    double coeff2     = 3 * s * (1 + theta - fourTheta2);\n+    double coeff3     = 3 * s * (1 + theta);\n+    double coeff4     = s * (1 + theta + fourTheta2);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i]\n+                            - coeff1 * yDotK[0][i] - coeff2 * yDotK[1][i]\n+                            - coeff3 * yDotK[2][i] - coeff4 * yDotK[3][i];\n+     }\n+\n+  }\n+\n+  private static final long serialVersionUID = -3345024435978721931L;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/ClassicalRungeKuttaIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.ClassicalRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+public class ClassicalRungeKuttaIntegratorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()+10],\n+                                                        1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()],\n+                                                        0.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalError() < 4.0e-12);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalError() > 0.005);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+    private double maxError = 0;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ClassicalRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class ClassicalRungeKuttaStepInterpolatorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class ContinuousOutputModelTest\n+  extends TestCase {\n+\n+  public ContinuousOutputModelTest(String name) {\n+    super(name);\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();\n+    cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());\n+    cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());\n+    cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));\n+  }\n+\n+  public void testRandomAccess()\n+    throws DerivativeException, IntegratorException {\n+\n+    ContinuousOutputModel cm = new ContinuousOutputModel();\n+    integ.setStepHandler(cm);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-9);\n+\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ContinuousOutputModelTest.class);\n+  }\n+\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8);\n+  }\n+\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince54IntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince54IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,\n+                                                                           1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-15;\n+      double scalRelativeTolerance = 1.0e-15;\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 scalAbsoluteTolerance,\n+                                                                 scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testSmallLastStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract pb = new TestProblem5();\n+    double minStep = 1.25;\n+    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+    double scalAbsoluteTolerance = 6.0e-4;\n+    double scalRelativeTolerance = 6.0e-4;\n+\n+    AdaptiveStepsizeIntegrator integ =\n+      new DormandPrince54Integrator(minStep, maxStep,\n+                                    scalAbsoluteTolerance,\n+                                    scalRelativeTolerance);\n+\n+    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);\n+    integ.setStepHandler(handler);\n+    integ.setInitialStepSize(1.7);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(handler.wasLastSeen());\n+\n+  }\n+\n+  private static class DP54SmallLastHandler implements StepHandler {\n+\n+    public DP54SmallLastHandler(double minStep) {\n+      lastSeen = false;\n+      this.minStep = minStep;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+      if (isLast) {\n+        lastSeen = true;\n+        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();\n+        assertTrue(Math.abs(h) < minStep);\n+      }\n+    }\n+\n+    public boolean wasLastSeen() {\n+      return lastSeen;\n+    }\n+\n+    private boolean lastSeen;\n+    private double  minStep;\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 scalAbsoluteTolerance,\n+                                                                 scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 0.7 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalError() < (0.7 * scalAbsoluteTolerance));\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 5.0e-6);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2800);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new VariableHandler());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 7.0e-10);\n+        assertTrue(nbSteps < 400);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    public VariableHandler() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 450.0));\n+        assertTrue(maxStep > (1.0 / 4.2));\n+      }\n+    }  \n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince54StepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class DormandPrince54StepInterpolatorTest\n+  extends TestCase {\n+\n+  public DormandPrince54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 119500);\n+    assertTrue(bos.size () < 120500);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 7.0e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince853IntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.DummyStepHandler;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince853IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince853IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-15;\n+      double scalRelativeTolerance = 1.0e-15;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-9;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 5.0e-8);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2900);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.setStepHandler(new VariableHandler());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public void testNoDenseOutput()\n+    throws DerivativeException, IntegratorException {\n+    TestProblem1 pb1 = new TestProblem1();\n+    TestProblem1 pb2 = (TestProblem1) pb1.clone();\n+    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());\n+    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-4;\n+    double scalRelativeTolerance = 1.0e-4;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.setStepHandler(DummyStepHandler.getInstance());\n+    integ.integrate(pb1,\n+                    pb1.getInitialTime(), pb1.getInitialState(),\n+                    pb1.getFinalTime(), new double[pb1.getDimension()]);\n+    int callsWithoutDenseOutput = pb1.getCalls();\n+\n+    integ.setStepHandler(new InterpolatingStepHandler());\n+    integ.integrate(pb2,\n+                    pb2.getInitialTime(), pb2.getInitialState(),\n+                    pb2.getFinalTime(), new double[pb2.getDimension()]);\n+    int callsWithDenseOutput = pb2.getCalls();\n+\n+    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n+\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.4e-10);\n+        assertTrue(nbSteps < 150);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    public VariableHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 100.0));\n+        assertTrue(maxStep > (1.0 / 2.0));\n+      }\n+    }\n+    private boolean firstTime = true;\n+    private double  minStep = 0;\n+    private double  maxStep = 0;\n+  }\n+\n+  private static class InterpolatingStepHandler implements StepHandler {\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+      double prev = interpolator.getPreviousTime();\n+      double curr = interpolator.getCurrentTime();\n+      interpolator.setInterpolatedTime(0.5*(prev + curr));\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince853StepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class DormandPrince853StepInterpolatorTest\n+  extends TestCase {\n+\n+  public DormandPrince853StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 86000);\n+    assertTrue(bos.size () < 87000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 2.4e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/EulerIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.EulerIntegrator;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+public class EulerIntegratorTest\n+  extends TestCase {\n+\n+  public EulerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new EulerIntegrator(0.01).integrate(pb,\n+                                          0.0, new double[pb.getDimension()+10],\n+                                          1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new EulerIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      \n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+   assertTrue(handler.getLastError() < 2.0e-4);\n+   assertTrue(handler.getMaximalError() < 1.0e-3);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalError() > 0.2);\n+\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(EulerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/EulerStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.EulerIntegrator;\n+import org.apache.commons.math.ode.EulerStepInterpolator;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class EulerStepInterpolatorTest\n+  extends TestCase {\n+\n+  public EulerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoReset() {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationAtBounds()\n+    throws DerivativeException {\n+\n+    double   t0 = 0;\n+    double[] y0 = {0.0, 1.0, -2.0};\n+\n+    double[] y = (double[]) y0.clone();\n+    double[][] yDot = { new double[y0.length] };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(t0);\n+\n+    double dt = 1.0;\n+    y[0] =  1.0;\n+    y[1] =  3.0;\n+    y[2] = -4.0;\n+    yDot[0][0] = (y[0] - y0[0]) / dt;\n+    yDot[0][1] = (y[1] - y0[1]) / dt;\n+    yDot[0][2] = (y[2] - y0[2]) / dt;\n+    interpolator.shift();\n+    interpolator.storeTime(t0 + dt);\n+\n+    interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationInside()\n+    throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 82000);\n+    assertTrue(bos.size () < 83000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.001);\n+\n+  }\n+\n+  private static class DummyEquations\n+    implements FirstOrderDifferentialEquations {\n+    public int getDimension() {\n+      return 0;\n+    }\n+    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EulerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.ClassicalRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderConverter;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.SecondOrderDifferentialEquations;\n+\n+import junit.framework.*;\n+\n+public class FirstOrderConverterTest\n+  extends TestCase {\n+\n+  public FirstOrderConverterTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDoubleDimension() {\n+    for (int i = 1; i < 10; ++i) {\n+      SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2);\n+      FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2);\n+      assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+      \n+    double previousError = Double.NaN;\n+    for (int i = 0; i < 10; ++i) {\n+\n+      double step  = Math.pow(2.0, -(i + 1));\n+      double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)\n+                   - Math.sin(4.0);\n+      if (i > 0) {\n+        assertTrue(Math.abs(error) < Math.abs(previousError));\n+      }\n+      previousError = error;\n+      \n+    }\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)\n+                   - Math.sin(4.0);\n+    assertTrue(Math.abs(error) < 1.0e-10);\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+    double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)\n+                   - Math.sin(4.0);\n+    assertTrue(Math.abs(error) > 0.1);\n+  }\n+  \n+  public static Test suite() {\n+    return new TestSuite(FirstOrderConverterTest.class);\n+  }\n+\n+  private static class Equations\n+    implements SecondOrderDifferentialEquations {\n+      \n+      private int n;\n+\n+      private double omega2;\n+      \n+      public Equations(int n, double omega) {\n+        this.n = n;\n+        omega2 = omega * omega;\n+      }\n+      \n+      public int getDimension() {\n+        return n;\n+      }\n+      \n+      public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n+                                           double[] yDDot) {\n+        for (int i = 0; i < n; ++i) {\n+          yDDot[i] = -omega2 * y[i];\n+        }\n+    }\n+      \n+  }\n+\n+  private double integrateWithSpecifiedStep(double omega,\n+                                            double t0, double t,\n+                                            double step)\n+  throws DerivativeException, IntegratorException {\n+    double[] y0 = new double[2];\n+    y0[0] = Math.sin(omega * t0);\n+    y0[1] = omega * Math.cos(omega * t0);\n+    ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);\n+    double[] y = new double[2];\n+    i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);\n+    return y[0];\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/GillIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.GillIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+public class GillIntegratorTest\n+  extends TestCase {\n+\n+  public GillIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new GillIntegrator(0.01).integrate(pb,\n+                                         0.0, new double[pb.getDimension()+10],\n+                                         1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 5; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new GillIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 5) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalError() < 4.0e-12);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalError() > 0.005);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    integ.setStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ = new GillIntegrator(0.3);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.001);\n+      }\n+    }\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/GillStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.GillIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class GillStepInterpolatorTest\n+  extends TestCase {\n+\n+  public GillStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.003);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/GraggBulirschStoerIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.GraggBulirschStoerIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+import junit.framework.*;\n+\n+public class GraggBulirschStoerIntegratorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      GraggBulirschStoerIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      GraggBulirschStoerIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb  = new TestProblem1();\n+      double minStep   = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+      double absTolerance = 1.0e-20;\n+      double relTolerance = 1.0e-20;\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         absTolerance, relTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -4; ++i) {\n+      TestProblem1 pb     = new TestProblem1();\n+      double minStep      = 0;\n+      double maxStep      = pb.getFinalTime() - pb.getInitialTime();\n+      double absTolerance = Math.pow(10.0, i);\n+      double relTolerance = absTolerance;\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         absTolerance, relTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the coefficients are only valid for this test\n+      // and have been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      double ratio =  handler.getMaximalError() / absTolerance;\n+      assertTrue(ratio < 2.4);\n+      assertTrue(ratio > 0.02);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-10;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 5.0e-8);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-6;\n+    double relTolerance   = 1.0e-6;\n+\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2150);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-8;\n+    double relTolerance   = 1.0e-8;\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new VariableStepHandler());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public void testUnstableDerivative()\n+    throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 100; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((100 - a) * prev + a * curr) / 100;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.7e-6);\n+        assertTrue(nbSteps < 80);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static class VariableStepHandler implements StepHandler {\n+    public VariableStepHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < 8.2e-3);\n+        assertTrue(maxStep > 1.7);\n+      }\n+    }\n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.GraggBulirschStoerIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class GraggBulirschStoerStepInterpolatorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 34000);\n+    assertTrue(bos.size () < 35000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 5.0e-11);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/HighamHall54IntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.HighamHall54Integrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+import junit.framework.*;\n+\n+public class HighamHall54IntegratorTest\n+  extends TestCase {\n+\n+  public HighamHall54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0,\n+                                                                     1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-15;\n+      double scalRelativeTolerance = 1.0e-15;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb);\n+      integ.setStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalError() < (1.3 * scalAbsoluteTolerance));\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testSwitchingFunctions()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            scalAbsoluteTolerance,\n+                                                            scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n+    }\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalError() < 1.0e-7);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            scalAbsoluteTolerance,\n+                                                            scalRelativeTolerance);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      ++nbSteps;\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 1.54e-10);\n+        assertTrue(nbSteps < 520);\n+      }\n+    }\n+    private TestProblem3 pb;\n+    private int nbSteps;\n+    private double maxError;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/HighamHall54StepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.HighamHall54Integrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+public class HighamHall54StepInterpolatorTest\n+  extends TestCase {\n+\n+  public HighamHall54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 158000);\n+    assertTrue(bos.size () < 159000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.6e-10);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/MidpointIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MidpointIntegrator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+public class MidpointIntegratorTest\n+  extends TestCase {\n+\n+  public MidpointIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new MidpointIntegrator(0.01).integrate(pb,\n+                                             0.0, new double[pb.getDimension()+10],\n+                                             1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+        FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+        }\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-7);\n+    assertTrue(handler.getMaximalError() < 1.0e-6);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalError() > 0.05);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/MidpointStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MidpointIntegrator;\n+\n+public class MidpointStepInterpolatorTest\n+  extends TestCase {\n+\n+  public MidpointStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 98000);\n+    assertTrue(bos.size () < 99000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-6);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/StepNormalizerTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.FixedStepHandler;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepNormalizer;\n+\n+import junit.framework.*;\n+\n+public class StepNormalizerTest\n+  extends TestCase {\n+\n+  public StepNormalizerTest(String name) {\n+    super(name);\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.setStepHandler(new StepNormalizer(range / 10.0,\n+                                       new FixedStepHandler() {\n+                                         private boolean firstCall = true;\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                boolean isLast) {\n+                                           if (firstCall) {\n+                                             checkValue(t, pb.getInitialTime());\n+                                             firstCall = false;\n+                                           }\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t, pb.getFinalTime());\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void testBeforeEnd()\n+    throws DerivativeException, IntegratorException {\n+    final double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.setStepHandler(new StepNormalizer(range / 10.5,\n+                                       new FixedStepHandler() {\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                boolean isLast) {\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t,\n+                                                        pb.getFinalTime() - range / 21.0);\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public void setLastSeen(boolean lastSeen) {\n+    this.lastSeen = lastSeen;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(StepNormalizerTest.class);\n+  }\n+\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);\n+    lastSeen = false;\n+  }\n+\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+  boolean lastSeen;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/StepProblem.java\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+\n+public class StepProblem\n+  implements FirstOrderDifferentialEquations, SwitchingFunction {\n+\n+  public StepProblem(double rateBefore, double rateAfter,\n+                     double switchTime) {\n+    this.rateAfter  = rateAfter;\n+    this.switchTime = switchTime;\n+    setRate(rateBefore);\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] = rate;\n+  }\n+\n+  public int getDimension() {\n+    return 1;\n+  }\n+\n+  public void setRate(double rate) {\n+    this.rate = rate;\n+  }\n+\n+  public int eventOccurred(double t, double[] y) {\n+    setRate(rateAfter);\n+    return RESET_DERIVATIVES;\n+  }\n+\n+  public double g(double t, double[] y) {\n+    return t - switchTime;\n+  }\n+\n+  public void resetState(double t, double[] y) {\n+  }\n+\n+  private double rate;\n+  private double rateAfter;\n+  private double switchTime;\n+\n+  private static final long serialVersionUID = 7590601995477504318L;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblem1.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = -y\n+ * </pre>\n+ * the solution of this equation is a simple exponential function :\n+ * <pre>\n+ *   y (t) = y (t0) exp (t0-t)\n+ * </pre>\n+ * </p>\n+\n+ */\n+class TestProblem1\n+  extends TestProblemAbstract {\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem1() {\n+    super();\n+    double[] y0 = { 1.0, 0.1 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(4.0);\n+    double[] errorScale = { 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem1(TestProblem1 problem) {\n+    super(problem);\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem1(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = -y[i];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double c = Math.exp (t0 - t);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c * y0[i];\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblem2.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = t^3 - t y\n+ * </pre>\n+ * with the initial condition y (0) = 0. The solution of this equation\n+ * is the following function :\n+ * <pre>\n+ *   y (t) = t^2 + 2 (ext (- t^2 / 2) - 1)\n+ * </pre>\n+ * </p>\n+\n+ */\n+class TestProblem2\n+  extends TestProblemAbstract {\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem2() {\n+    super();\n+    double[] y0 = { 0.0 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(1.0);\n+    double[] errorScale = { 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem2(TestProblem2 problem) {\n+    super(problem);\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem2(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = t * (t * t - y[i]);\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double t2 = t * t;\n+    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c;\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblem3.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0\n+ *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e))\n+ *    r = sqrt (y1^2 + y2^2), e = 0.9\n+ * </pre>\n+ * This is a two-body problem in the plane which can be solved by\n+ * Kepler's equation\n+ * <pre>\n+ *   y1 (t) = ...\n+ * </pre>\n+ * </p>\n+\n+ */\n+class TestProblem3\n+  extends TestProblemAbstract {\n+\n+  /** Eccentricity */\n+  double e;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   * @param e eccentricity\n+   */\n+  public TestProblem3(double e) {\n+    super();\n+    this.e = e;\n+    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(20.0);\n+    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem3() {\n+    this(0.1);\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem3(TestProblem3 problem) {\n+    super(problem);\n+    e = problem.e;\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem3(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // current radius\n+    double r2 = y[0] * y[0] + y[1] * y[1];\n+    double invR3 = 1 / (r2 * Math.sqrt(r2));\n+\n+    // compute the derivatives\n+    yDot[0] = y[2];\n+    yDot[1] = y[3];\n+    yDot[2] = -invR3  * y[0];\n+    yDot[3] = -invR3  * y[1];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+\n+    // solve Kepler's equation\n+    double E = t;\n+    double d = 0;\n+    double corr = 0;\n+    do {\n+      double f2  = e * Math.sin(E);\n+      double f0  = d - f2;\n+      double f1  = 1 - e * Math.cos(E);\n+      double f12 = f1 + f1;\n+      corr  = f0 * f12 / (f1 * f12 - f0 * f2);\n+      d -= corr;\n+      E = t + d;\n+    } while (Math.abs(corr) > 1.0e-12);\n+\n+    double cosE = Math.cos(E);\n+    double sinE = Math.sin(E);\n+\n+    y[0] = cosE - e;\n+    y[1] = Math.sqrt(1 - e * e) * sinE;\n+    y[2] = -sinE / (1 - e * cosE);\n+    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);\n+\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblem4.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    x'' = -x\n+ * </pre>\n+ * And when x decreases down to 0, the state should be changed as follows :\n+ * <pre>\n+ *   x' -> -x'\n+ * </pre>\n+ * The theoretical solution of this problem is x = |sin(t+a)|\n+ * </p>\n+\n+ */\n+class TestProblem4\n+  extends TestProblemAbstract {\n+\n+  /** Time offset. */\n+  private double a;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /** Simple constructor. */\n+  public TestProblem4() {\n+    super();\n+    a = 1.2;\n+    double[] y0 = { Math.sin(a), Math.cos(a) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(15);\n+    double[] errorScale = { 1.0, 0.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem4(TestProblem4 problem) {\n+    super(problem);\n+    a = problem.a;\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem4(this);\n+  }\n+\n+  public SwitchingFunction[] getSwitchingFunctions() {\n+    return new SwitchingFunction[] { new Bounce(), new Stop() };\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] =  y[1];\n+    yDot[1] = -y[0];\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double sin = Math.sin(t + a);\n+    double cos = Math.cos(t + a);\n+    y[0] = Math.abs(sin);\n+    y[1] = (sin >= 0) ? cos : -cos;\n+    return y;\n+  }\n+\n+  private static class Bounce implements SwitchingFunction {\n+\n+    private static final long serialVersionUID = 1356097180027801200L;\n+    private int sign;\n+\n+    public Bounce() {\n+      sign = +1;\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return sign * y[0];\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      // this sign change is needed because the state will be reset soon\n+      sign = -sign;\n+      return SwitchingFunction.RESET_STATE;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+      y[1] = -y[1];\n+    }\n+\n+  }\n+\n+  private static class Stop implements SwitchingFunction {\n+\n+    private static final long serialVersionUID = 6975050568227951931L;\n+\n+    public Stop() {\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return t - 12.0;\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      return SwitchingFunction.STOP;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+    }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblem5.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ * <p>This is the same as problem 1 except integration is done\n+ * backward in time</p>\n+ */\n+class TestProblem5\n+  extends TestProblem1 {\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem5() {\n+    super();\n+    setFinalConditions(2 * t0 - t1);\n+  }\n+ \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblemAbstract.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+\n+/**\n+ * This class is used as the base class of the problems that are\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+abstract class TestProblemAbstract\n+  implements FirstOrderDifferentialEquations, Cloneable {\n+\n+  /** Dimension of the problem. */\n+  protected int n;\n+\n+  /** Number of functions calls. */\n+  protected int calls;\n+\n+  /** Initial time */\n+  protected double t0;\n+\n+  /** Initial state */\n+  protected double[] y0;\n+\n+  /** Final time */\n+  protected double t1;\n+\n+  /** Error scale */\n+  protected double[] errorScale;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  protected TestProblemAbstract() {\n+    n          = 0;\n+    calls      = 0;\n+    t0         = 0;\n+    y0         = null;\n+    t1         = 0;\n+    errorScale = null;\n+  }\n+\n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  protected TestProblemAbstract(TestProblemAbstract problem) {\n+    n     = problem.n;\n+    calls = problem.calls;\n+    t0    = problem.t0;\n+    if (problem.y0 == null) {\n+      y0 = null;\n+    } else {\n+      y0 = (double[]) problem.y0.clone();\n+    }\n+    if (problem.errorScale == null) {\n+      errorScale = null;\n+    } else {\n+      errorScale = (double[]) problem.errorScale.clone();\n+    }\n+    t1 = problem.t1;\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public abstract Object clone();\n+\n+  /**\n+   * Set the initial conditions\n+   * @param t0 initial time\n+   * @param y0 initial state vector\n+   */\n+  protected void setInitialConditions(double t0, double[] y0) {\n+    calls     = 0;\n+    n         = y0.length;\n+    this.t0   = t0;\n+    this.y0   = (double[]) y0.clone(); \n+   }\n+\n+  /**\n+   * Set the final conditions.\n+   * @param t1 final time\n+   */\n+  protected void setFinalConditions(double t1) {\n+    this.t1 = t1;\n+  }\n+\n+  /**\n+   * Set the error scale\n+   * @param errorScale error scale\n+   */\n+  protected void setErrorScale(double[] errorScale) {\n+    this.errorScale = (double[]) errorScale.clone(); \n+  }\n+\n+  public int getDimension() {\n+    return n;\n+  }\n+\n+  /**\n+   * Get the initial time.\n+   * @return initial time\n+   */\n+  public double getInitialTime() {\n+    return t0;\n+  }\n+\n+  /**\n+   * Get the initial state vector.\n+   * @return initial state vector\n+   */\n+  public double[] getInitialState() {\n+    return y0;\n+  }\n+\n+  /**\n+   * Get the final time.\n+   * @return final time\n+   */\n+  public double getFinalTime() {\n+    return t1;\n+  }\n+\n+  /**\n+   * Get the error scale.\n+   * @return error scale\n+   */\n+  public double[] getErrorScale() {\n+    return errorScale;\n+  }\n+\n+  /**\n+   * Get the switching functions.\n+   * @return switching functions\n+   */\n+  public SwitchingFunction[] getSwitchingFunctions() {\n+    return new SwitchingFunction[0];\n+  }\n+\n+  /**\n+   * Get the number of calls.\n+   * @return nuber of calls\n+   */\n+  public int getCalls() {\n+    return calls;\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    ++calls;\n+    doComputeDerivatives(t, y, yDot);\n+  }\n+\n+  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);\n+\n+  /**\n+   * Compute the theoretical state at the specified time.\n+   * @param t time at which the state is required\n+   * @return state vector at time t\n+   */\n+  abstract public double[] computeTheoreticalState(double t);\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblemFactory.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ */\n+class TestProblemFactory {\n+\n+  /** Problems pool. */\n+  private static TestProblemAbstract[] pool = {\n+    new TestProblem1(),\n+    new TestProblem2(),\n+    new TestProblem3(),\n+    new TestProblem4(),\n+    new TestProblem5()\n+  };\n+\n+  /**\n+   * Private constructor.\n+   * This is a utility class, so there are no instance at all.\n+   */\n+  private TestProblemFactory() {\n+  }\n+\n+  /**\n+   * Get the problems.\n+   * @return array of problems to solve\n+   */\n+  public static TestProblemAbstract[] getProblems() {\n+    return pool;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/TestProblemHandler.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+\n+/**\n+ * This class is used to handle steps for the test problems\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+class TestProblemHandler\n+  implements StepHandler {\n+\n+  /** Associated problem. */\n+  private TestProblemAbstract problem;\n+\n+  /** Maximal error encountered during the integration. */\n+  private double maxError;\n+\n+  /** Error at the end of the integration. */\n+  private double lastError;\n+\n+  /** Time at the end of integration. */\n+  private double lastTime;\n+\n+  /**\n+   * Simple constructor.\n+   * @param problem problem for which steps should be handled\n+   */\n+  public TestProblemHandler(TestProblemAbstract problem) {\n+    this.problem = problem;\n+    reset();\n+  }\n+\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  public void reset() {\n+    maxError  = 0;\n+    lastError = 0;\n+  }\n+\n+  public void handleStep(StepInterpolator interpolator,\n+                         boolean isLast)\n+    throws DerivativeException {\n+\n+    double pT = interpolator.getPreviousTime();\n+    double cT = interpolator.getCurrentTime();\n+    double[] errorScale = problem.getErrorScale();\n+\n+    // store the error at the last step\n+    if (isLast) {\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(cT);\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > lastError) {\n+          lastError = error;\n+        }\n+      }\n+      lastTime = cT;\n+    }\n+\n+    // walk through the step\n+    for (int k = 0; k <= 20; ++k) {\n+\n+      double time = pT + (k * (cT - pT)) / 20;\n+      interpolator.setInterpolatedTime(time);\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());\n+\n+      // update the errors\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  /**\n+   * Get the maximal error encountered during integration.\n+   * @return maximal error\n+   */\n+  public double getMaximalError() {\n+    return maxError;\n+  }\n+\n+  /**\n+   * Get the error at the end of the integration.\n+   * @return error at the end of the integration\n+   */\n+  public double getLastError() {\n+    return lastError;\n+  }\n+\n+  /**\n+   * Get the time at the end of the integration.\n+   * @return time at the end of the integration.\n+   */\n+  public double getLastTime() {\n+    return lastTime;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/ThreeEighthesIntegratorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.StepHandler;\n+import org.apache.commons.math.ode.StepInterpolator;\n+import org.apache.commons.math.ode.SwitchingFunction;\n+import org.apache.commons.math.ode.ThreeEighthesIntegrator;\n+\n+public class ThreeEighthesIntegratorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ThreeEighthesIntegrator(0.01).integrate(pb,\n+                                                  0.0, new double[pb.getDimension()+10],\n+                                                  1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+    \n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb);\n+        integ.setStepHandler(handler);\n+        SwitchingFunction[] functions = pb.getSwitchingFunctions();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n+        }\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        double error = handler.getMaximalError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+      }\n+\n+    }\n+\n+  }\n+\n+ public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalError() < 4.0e-12);\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb);\n+    integ.setStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalError() > 0.005);\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.setStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      maxError = 0;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+      maxError = 0;\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+\n+    private TestProblem3 pb;\n+    private double maxError = 0;\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/ThreeEighthesStepInterpolatorTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.ode;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.ThreeEighthesIntegrator;\n+\n+public class ThreeEighthesStepInterpolatorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(integ.getStepHandler());\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesStepInterpolatorTest.class);\n+  }\n+\n+}", "timestamp": 1172531560, "metainfo": ""}