{"sha": "e564e3892a5bb8d74f1d9805574bed7fba8c4197", "log": "Merged ZipfDistribution and ZipfDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n \n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * The Zipf (or zeta) Distribution.\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/ZipfDistribution.html\">Zipf\n- * Distribution</a></li>\n- * </ul>\n- * </p>\n+ * Implementation of the Zipf distribution.\n  *\n+ * @see <a href=\"http://mathworld.wolfram.com/ZipfDistribution.html\">Zipf distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface ZipfDistribution extends IntegerDistribution {\n+public class ZipfDistribution extends AbstractIntegerDistribution\n+    implements Serializable {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -140627372283420404L;\n+    /** Number of elements. */\n+    private final int numberOfElements;\n+    /** Exponent parameter of the distribution. */\n+    private final double exponent;\n+\n+    /**\n+     * Create a new Zipf distribution with the given number of elements and\n+     * exponent.\n+     *\n+     * @param numberOfElements Number of elements.\n+     * @param exponent Exponent.\n+     * @exception NotStrictlyPositiveException if {@code numberOfElements <= 0}\n+     * or {@code exponent <= 0}.\n+     */\n+    public ZipfDistribution(final int numberOfElements, final double exponent)\n+        throws NotStrictlyPositiveException {\n+        if (numberOfElements <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n+                                                   numberOfElements);\n+        }\n+        if (exponent <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.EXPONENT,\n+                                                   exponent);\n+        }\n+\n+        this.numberOfElements = numberOfElements;\n+        this.exponent = exponent;\n+    }\n+\n     /**\n      * Get the number of elements (e.g. corpus size) for the distribution.\n      *\n      * @return the number of elements\n      */\n-    int getNumberOfElements();\n-\n-    /**\n-     * Get the exponent characterising the distribution.\n+    public int getNumberOfElements() {\n+        return numberOfElements;\n+    }\n+\n+    /**\n+     * Get the exponent characterizing the distribution.\n      *\n      * @return the exponent\n      */\n-    double getExponent();\n+    public double getExponent() {\n+        return exponent;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double probability(final int x) {\n+        if (x <= 0 || x > numberOfElements) {\n+            return 0.0;\n+        }\n+\n+        return (1.0 / FastMath.pow(x, exponent)) / generalizedHarmonic(numberOfElements, exponent);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double cumulativeProbability(final int x) {\n+        if (x <= 0) {\n+            return 0.0;\n+        } else if (x >= numberOfElements) {\n+            return 1.0;\n+        }\n+\n+        return generalizedHarmonic(x, exponent) / generalizedHarmonic(numberOfElements, exponent);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainLowerBound(final double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainUpperBound(final double p) {\n+        return numberOfElements;\n+    }\n+\n+    /**\n+     * Calculates the Nth generalized harmonic number. See\n+     * <a href=\"http://mathworld.wolfram.com/HarmonicSeries.html\">Harmonic\n+     * Series</a>.\n+     *\n+     * @param n Term in the series to calculate (must be larger than 1)\n+     * @param m Exponent (special case {@code m = 1} is the harmonic series).\n+     * @return the n<sup>th</sup> generalized harmonic number.\n+     */\n+    private double generalizedHarmonic(final int n, final double m) {\n+        double value = 0;\n+        for (int k = n; k > 0; --k) {\n+            value += 1.0 / FastMath.pow(k, m);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 1 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 1)\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return 1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is the number of elements.\n+     *\n+     * @return upper bound of the support\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return getNumberOfElements();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For number of elements {@code N} and exponent {@code s}, the mean is\n+     * {@code Hs1 / Hs}, where\n+     * <ul>\n+     *  <li>{@code Hs1 = generalizedHarmonic(N, s - 1)},</li>\n+     *  <li>{@code Hs = generalizedHarmonic(N, s)}.</li>\n+     * </ul>\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final int N = getNumberOfElements();\n+        final double s = getExponent();\n+\n+        final double Hs1 = generalizedHarmonic(N, s - 1);\n+        final double Hs = generalizedHarmonic(N, s);\n+\n+        return Hs1 / Hs;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For number of elements {@code N} and exponent {@code s}, the mean is\n+     * {@code (Hs2 / Hs) - (Hs1^2 / Hs^2)}, where\n+     * <ul>\n+     *  <li>{@code Hs2 = generalizedHarmonic(N, s - 2)},</li>\n+     *  <li>{@code Hs1 = generalizedHarmonic(N, s - 1)},</li>\n+     *  <li>{@code Hs = generalizedHarmonic(N, s)}.</li>\n+     * </ul>\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final int N = getNumberOfElements();\n+        final double s = getExponent();\n+\n+        final double Hs2 = generalizedHarmonic(N, s - 2);\n+        final double Hs1 = generalizedHarmonic(N, s - 1);\n+        final double Hs = generalizedHarmonic(N, s);\n+\n+        return (Hs2 / Hs) - ((Hs1 * Hs1) / (Hs * Hs));\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.PascalDistribution;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.WeibullDistribution;\n-import org.apache.commons.math.distribution.ZipfDistributionImpl;\n+import org.apache.commons.math.distribution.ZipfDistribution;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n     }\n \n     /**\n-     * Generates a random value from the {@link ZipfDistributionImpl Zipf Distribution}.\n+     * Generates a random value from the {@link ZipfDistribution Zipf Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public int nextZipf(int numberOfElements, double exponent) {\n-        return nextInversionDeviate(new ZipfDistributionImpl(numberOfElements, exponent));\n+        return nextInversionDeviate(new ZipfDistribution(numberOfElements, exponent));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n \n     @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions1() {\n-        new ZipfDistributionImpl(0, 1);\n+        new ZipfDistribution(0, 1);\n     }\n \n     @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions2() {\n-        new ZipfDistributionImpl(1, 0);\n+        new ZipfDistribution(1, 0);\n     }\n \n     //-------------- Implementations for abstract methods -----------------------\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n-        return new ZipfDistributionImpl(10, 1);\n+        return new ZipfDistribution(10, 1);\n     }\n \n     /** Creates the default probability density test input values */\n     public void testMoments() {\n         final double tol = 1e-9;\n         ZipfDistribution dist;\n-        \n-        dist = new ZipfDistributionImpl(2, 0.5);\n+\n+        dist = new ZipfDistribution(2, 0.5);\n         Assert.assertEquals(dist.getNumericalMean(), FastMath.sqrt(2), tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol); \n+        Assert.assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.PoissonDistribution;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.WeibullDistribution;\n-import org.apache.commons.math.distribution.ZipfDistributionImpl;\n+import org.apache.commons.math.distribution.ZipfDistribution;\n import org.apache.commons.math.distribution.ZipfDistributionTest;\n import org.apache.commons.math.stat.Frequency;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n         int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n-        ZipfDistributionImpl distribution = (ZipfDistributionImpl) testInstance.makeDistribution();\n+        ZipfDistribution distribution = (ZipfDistribution) testInstance.makeDistribution();\n         double[] expectedCounts = new double[length];\n         long[] observedCounts = new long[length];\n         for (int i = 0; i < length; i++) {", "timestamp": 1322319487, "metainfo": ""}