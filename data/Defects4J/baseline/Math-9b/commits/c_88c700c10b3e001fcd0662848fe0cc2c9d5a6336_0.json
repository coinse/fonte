{"sha": "88c700c10b3e001fcd0662848fe0cc2c9d5a6336", "log": "added missing methods in Vector1D/2D/3D  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/Vector.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector.java\n import java.text.NumberFormat;\n \n /** This interface represents a generic vector in a vectorial space or a point in an affine space.\n- * @version $Id:$\n+ * @param <S> Type of the space.\n+ * @version $Id$\n  * @see Space\n  * @see Vector\n  * @since 3.0\n      */\n     Vector<S> subtract(double factor, Vector<S> v);\n \n+    /** Get the opposite of the instance.\n+     * @return a new vector which is opposite to the instance\n+     */\n+    Vector<S> negate();\n+\n+    /** Get a normalized vector aligned with the instance.\n+     * @return a new normalized vector\n+     * @exception ArithmeticException if the norm is zero\n+     */\n+    Vector<S> normalize();\n+\n+    /** Multiply the instance by a scalar.\n+     * @param a scalar\n+     * @return a new vector\n+     */\n+    Vector<S> scalarMultiply(double a);\n+\n     /**\n      * Returns true if any coordinate of this vector is NaN; false otherwise\n      * @return  true if any coordinate of this vector is NaN; false otherwise\n      */\n     double distanceSq(Vector<S> v);\n \n+    /** Compute the dot-product of the instance and another vector.\n+     * @param v second vector\n+     * @return the dot product this.v\n+     */\n+    double dotProduct(Vector<S> v);\n+\n     /** Get a string representation of this vector.\n-     * @param format the custom format for components.\n+     * @param format the custom format for components\n+     * @return a string representation of this vector\n      */\n-    public String toString(final NumberFormat format);\n+    String toString(final NumberFormat format);\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Vector1D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Vector1D.java\n \n import java.text.NumberFormat;\n \n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.geometry.Space;\n import org.apache.commons.math.geometry.Vector;\n-import org.apache.commons.math.geometry.Space;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /** This class represents a 1D vector.\n  * <p>Instances of this class are guaranteed to be immutable.</p>\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class Vector1D implements Vector<Euclidean1D> {\n     }\n \n     /** {@inheritDoc} */\n+    public Vector1D normalize() {\n+        double s = getNorm();\n+        if (s == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+        }\n+        return scalarMultiply(1 / s);\n+    }\n+    /** {@inheritDoc} */\n+    public Vector1D negate() {\n+        return new Vector1D(-x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D scalarMultiply(double a) {\n+        return new Vector1D(a * x);\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isNaN() {\n         return Double.isNaN(x);\n     }\n         Vector1D p3 = (Vector1D) p;\n         final double dx = p3.x - x;\n         return dx * dx;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(final Vector<Euclidean1D> v) {\n+        final Vector1D v1 = (Vector1D) v;\n+        return x * v1.x;\n     }\n \n     /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n  */\n public class Vector3D implements Serializable, Vector<Euclidean3D> {\n \n-    /** Serializable version id. */\n-    private static final long serialVersionUID = 1313493323784566947L;\n-\n     /** Null vector (coordinates: 0, 0, 0). */\n     public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n \n         new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n \n     /** Serializable version identifier. */\n- \n+    private static final long serialVersionUID = 1313493323784566947L;\n+\n     /** Abscissa. */\n     private final double x;\n \n         return x * v3.x + y * v3.y + z * v3.z;\n     }\n \n-    /** {@inheritDoc} */\n+    /** Compute the cross-product of the instance with another vector.\n+     * @param v other vectorvector\n+     * @return the cross product this ^ v as a new Vector3D\n+     */\n     public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n         final Vector3D v3 = (Vector3D) v;\n \n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Vector2D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Vector2D.java\n \n import java.text.NumberFormat;\n \n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.geometry.Space;\n import org.apache.commons.math.geometry.Vector;\n import org.apache.commons.math.util.FastMath;\n \n /** This class represents a 2D vector.\n  * <p>Instances of this class are guaranteed to be immutable.</p>\n- * @version $Id:$\n+ * @version $Id$\n  * @since 3.0\n  */\n public class Vector2D implements Vector<Euclidean2D> {\n     }\n \n     /** {@inheritDoc} */\n-    public Vector2D toVector() {\n-        return new Vector2D(x, y);\n-    }\n-\n-    /** {@inheritDoc} */\n     public double getNorm1() {\n         return FastMath.abs(x) + FastMath.abs(y);\n     }\n     }\n \n     /** {@inheritDoc} */\n+    public Vector2D normalize() {\n+        double s = getNorm();\n+        if (s == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+        }\n+        return scalarMultiply(1 / s);\n+    }\n+    /** {@inheritDoc} */\n+    public Vector2D negate() {\n+        return new Vector2D(-x, -y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D scalarMultiply(double a) {\n+        return new Vector2D(a * x, a * y);\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isNaN() {\n         return Double.isNaN(x) || Double.isNaN(y);\n     }\n         final double dx = p3.x - x;\n         final double dy = p3.y - y;\n         return dx * dx + dy * dy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(final Vector<Euclidean2D> v) {\n+        final Vector2D v2 = (Vector2D) v;\n+        return x * v2.x + y * v2.y;\n     }\n \n     /** Compute the distance between two vectors according to the L<sub>2</sub> norm.", "timestamp": 1307128940, "metainfo": ""}