{"sha": "28d3fbd14b959f93bd6954d7cfecb4127245897e", "log": "added a transformer from symmetric matrix to tri-diagonal matrix (this is only for internal purposes only yet, it will be used later)  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/**\n+ * Class transforming a symmetrical matrix to tri-diagonal shape.\n+ * <p>A symmetrical m &times; m matrix A can be written as the product of three matrices:\n+ * A = Q &times; T &times; Q<sup>T</sup> with Q an orthogonal matrix and T a symmetrical\n+ * tri-diagonal matrix. Both Q and T are m &times; m matrices.</p>\n+ * <p>Transformation to tri-diagonal shape is often not a goal by itself, but it is\n+ * an intermediate step in more general decomposition algorithms like {@link\n+ * EigenValuesDecomposition Eigen Values Decomposition}. This class is therefore\n+ * intended for internal use by the library and is not public. As a consequence of\n+ * this explicitly limited scope, many methods directly returns references to\n+ * internal arrays, not copies.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class TriDiagonalTransformer implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8935390784125343332L;\n+\n+    /** Householder vectors. */\n+    private final double householderVectors[][];\n+\n+    /** Main diagonal. */\n+    private final double[] main;\n+\n+    /** Secondary diagonal. */\n+    private final double[] secondary;\n+\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+\n+    /** Cached value of Qt. */\n+    private RealMatrix cachedQt;\n+\n+    /** Cached value of T. */\n+    private RealMatrix cachedT;\n+\n+    /**\n+     * Build the transformation to tri-diagonal shape of a symmetrical matrix.\n+     * <p>The specified matrix is assumed to be symmetrical without any check.\n+     * Only the upper triangular part of the matrix is used.</p>\n+     * @param matrix the symmetrical matrix to transform.\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public TriDiagonalTransformer(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        if (!matrix.isSquare()) {\n+            throw new InvalidMatrixException(\"transformation to tri-diagonal requires that the matrix be square\");\n+        }\n+\n+        final int m = matrix.getRowDimension();\n+        householderVectors = matrix.getData();\n+        main      = new double[m];\n+        secondary = new double[m - 1];\n+        cachedQ   = null;\n+        cachedQt  = null;\n+        cachedT   = null;\n+\n+        // transform matrix\n+        transform();\n+\n+    }\n+\n+    /**\n+     * Returns the matrix Q of the transform. \n+     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQ() {\n+        if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n+\n+    /**\n+     * Returns the transpose of the matrix Q of the transform. \n+     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQT() {\n+\n+        if (cachedQt == null) {\n+\n+            final int m = householderVectors.length;\n+            final double[][] qtData  = new double[m][m];\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = m - 1; k >= 1; --k) {\n+                final double[] hK = householderVectors[k - 1];\n+                final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n+                qtData[k][k] = 1;\n+                if (hK[k] != 0.0) {\n+                    for (int j = k; j < m; ++j) {\n+                        final double[] qtJ = qtData[j];\n+                        double beta = 0;\n+                        for (int i = k; i < m; ++i) {\n+                            beta -= qtJ[i] * hK[i];\n+                        }\n+                        beta *= inv;\n+\n+                        for (int i = k; i < m; ++i) {\n+                            qtJ[i] -= beta * hK[i];\n+                        }\n+                    }\n+                }\n+            }\n+            qtData[0][0] = 1;\n+\n+            // cache the matrix for subsequent calls\n+            cachedQt = new RealMatrixImpl(qtData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedQt;\n+\n+    }\n+\n+    /**\n+     * Returns the tri-diagonal matrix T of the transform. \n+     * @return the T matrix\n+     */\n+    public RealMatrix getT() {\n+\n+        if (cachedT == null) {\n+\n+            final int m = main.length;\n+            double[][] tData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                double[] tDataI = tData[i];\n+                tDataI[i] = main[i];\n+                if (i > 0) {\n+                    tDataI[i - 1] = secondary[i - 1];\n+                }\n+                if (i < main.length - 1) {\n+                    tDataI[i + 1] = secondary[i];\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedT = new RealMatrixImpl(tData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedT;\n+\n+    }\n+\n+    /**\n+     * Get the Householder vectors of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[][] getHouseholderVectorsRef() {\n+        return householderVectors;\n+    }\n+\n+    /**\n+     * Get the main diagonal elements of the matrix T of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the T matrix\n+     */\n+    double[] getMainDiagonalRef() {\n+        return main;\n+    }\n+\n+    /**\n+     * Get the secondary diagonal elements of the matrix T of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the secondary diagonal elements of the T matrix\n+     */\n+    double[] getSecondaryDiagonalRef() {\n+        return secondary;\n+    }\n+\n+    /**\n+     * Transform original matrix to tri-diagonal form.\n+     * <p>Transformation is done using Householder transforms.</p>\n+     */\n+    private void transform() {\n+\n+        final int m = householderVectors.length;\n+        final double[] z = new double[m];\n+        for (int k = 0; k < m - 1; k++) {\n+\n+            //zero-out a row and a column simultaneously\n+            final double[] hK = householderVectors[k];\n+            main[k] = hK[k];\n+            double xNormSqr = 0;\n+            for (int j = k + 1; j < m; ++j) {\n+                final double c = hK[j];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            secondary[k] = a;\n+            if (a != 0.0) {\n+                // apply Householder transform from left and right simultaneously\n+\n+                hK[k + 1] -= a;\n+                final double beta = -1 / (a * hK[k + 1]);\n+\n+                // compute a = beta A v, where v is the Householder vector\n+                // this loop is written in such a way\n+                //   1) only the upper triangular part of the matrix is accessed\n+                //   2) access is cache-friendly for a matrix stored in rows\n+                Arrays.fill(z, k + 1, m, 0);\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    final double hKI = hK[i];\n+                    double zI = hI[i] * hKI;\n+                    for (int j = i + 1; j < m; ++j) {\n+                        final double hIJ = hI[j];\n+                        zI   += hIJ * hK[j];\n+                        z[j] += hIJ * hKI;\n+                    }\n+                    z[i] = beta * (z[i] + zI);\n+                }\n+\n+                // compute gamma = beta vT z / 2\n+                double gamma = 0;\n+                for (int i = k + 1; i < m; ++i) {\n+                    gamma += z[i] * hK[i];\n+                }\n+                gamma *= beta / 2;\n+\n+                // compute z = z - gamma v\n+                for (int i = k + 1; i < m; ++i) {\n+                    z[i] -= gamma * hK[i];\n+                }\n+\n+                // update matrix: A = A - v zT - z vT\n+                // only the upper triangular part of the matrix is updated\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    for (int j = i; j < m; ++j) {\n+                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n+                    }\n+                }\n+\n+            }\n+\n+        }\n+        main[m - 1] = householderVectors[m - 1][m - 1];\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class TriDiagonalTransformerTest extends TestCase {\n+\n+    private double[][] testSquare5 = {\n+            { 1, 2, 3, 1, 1 },\n+            { 2, 1, 1, 3, 1 },\n+            { 3, 1, 1, 1, 2 },\n+            { 1, 3, 1, 2, 1 },\n+            { 1, 1, 2, 1, 3 }\n+    };\n+\n+    private double[][] testSquare3 = {\n+            { 1, 3, 4 },\n+            { 3, 2, 2 },\n+            { 4, 2, 0 }\n+    };\n+\n+    public TriDiagonalTransformerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testNonSquare() {\n+        try {\n+            new TriDiagonalTransformer(new RealMatrixImpl(new double[3][2], false));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testAEqualQTQt() {\n+        checkAEqualQTQt(new RealMatrixImpl(testSquare5, false));\n+        checkAEqualQTQt(new RealMatrixImpl(testSquare3, false));\n+    }\n+\n+    private void checkAEqualQTQt(RealMatrix matrix) {\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        RealMatrix q  = transformer.getQ();\n+        RealMatrix qT = transformer.getQT();\n+        RealMatrix t  = transformer.getT();\n+        double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 4.0e-15);\n+    }\n+\n+    public void testQOrthogonal() {\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQ());\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQ());\n+    }\n+\n+    public void testQTOrthogonal() {\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQT());\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQT());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);        \n+    }\n+\n+    public void testTTriDiagonal() {\n+        checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getT());\n+        checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getT());\n+    }\n+\n+    private void checkTriDiagonal(RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if ((i < j - 1) || (i > j + 1)) {\n+                    assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                }                    \n+            }\n+        }\n+    }\n+\n+    public void testMatricesValues5() {\n+        checkMatricesValues(testSquare5,\n+                            new double[][] {\n+                                { 1.0,  0.0,                 0.0,                  0.0,                   0.0 },\n+                                { 0.0, -0.5163977794943222,  0.016748280772542083, 0.839800693771262,     0.16669620021405473 },\n+                                { 0.0, -0.7745966692414833, -0.4354553000860955,  -0.44989322880603355,  -0.08930153582895772 },\n+                                { 0.0, -0.2581988897471611,  0.6364346693566014,  -0.30263204032131164,   0.6608313651342882 },\n+                                { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }\n+                            },\n+                            new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },\n+                            new double[] { -Math.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });\n+    }\n+\n+    public void testMatricesValues3() {\n+        checkMatricesValues(testSquare3,\n+                            new double[][] {\n+                                {  1.0,  0.0,  0.0 },\n+                                {  0.0, -0.6,  0.8 },\n+                                {  0.0, -0.8, -0.6 },\n+                            },\n+                            new double[] { 1, 2.64, -0.64 },\n+                            new double[] { -5, -1.52 });\n+    }\n+\n+    private void checkMatricesValues(double[][] matrix, double[][] qRef,\n+                                     double[] mainDiagnonal,\n+                                     double[] secondaryDiagonal) {\n+        TriDiagonalTransformer transformer =\n+            new TriDiagonalTransformer(new RealMatrixImpl(matrix, false));\n+\n+        // check values against known references\n+        RealMatrix q = transformer.getQ();\n+        assertEquals(0, q.subtract(new RealMatrixImpl(qRef, false)).getNorm(), 1.0e-14);\n+\n+        RealMatrix t = transformer.getT();\n+        double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];\n+        for (int i = 0; i < mainDiagnonal.length; ++i) {\n+            tData[i][i] = mainDiagnonal[i];\n+            if (i > 0) {\n+                tData[i][i - 1] = secondaryDiagonal[i - 1];\n+            }\n+            if (i < secondaryDiagonal.length) {\n+                tData[i][i + 1] = secondaryDiagonal[i];\n+            }\n+        }\n+        assertEquals(0, t.subtract(new RealMatrixImpl(tData, false)).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(q == transformer.getQ());\n+        assertTrue(t == transformer.getT());\n+        \n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TriDiagonalTransformerTest.class);\n+    }\n+\n+}", "timestamp": 1222724861, "metainfo": ""}