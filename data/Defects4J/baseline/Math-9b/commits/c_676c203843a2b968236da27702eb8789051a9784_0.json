{"sha": "676c203843a2b968236da27702eb8789051a9784", "log": "Updated contributed sources - Mantissa 7 upgrade. JIRA: MATH-162  ", "commit": "\n--- a/src/mantissa/src/org/spaceroots/mantissa/MessagesResources.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources.java\n   }\n \n   public Object[][] getContents() {\n-    return contents;\n+    return (Object[][]) contents.clone();\n   }\n \n   static final Object[][] contents = {\n--- a/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n   }\n \n   public Object[][] getContents() {\n-    return contents;\n+    return (Object[][]) contents.clone();\n   }\n \n   static final Object[][] contents = {\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Chebyshev.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Chebyshev.java\n \n package org.spaceroots.mantissa.algebra;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * This class implements Chebyshev polynomials.\n \n  * <p>Chebyshev polynomials can be defined by the following recurrence\n  * relations:\n  * <pre>\n- *  T0(X)   = 1\n- *  T1(X)   = X\n- *  Tk+1(X) = 2X Tk(X) - Tk-1(X)\n+ *  T<sub>0</sub>(X)   = 1\n+ *  T<sub>1</sub>(X)   = X\n+ *  T<sub>k+1</sub>(X) = 2X T<sub>k</sub>(X) - T<sub>k-1</sub>(X)\n  * </pre></p>\n \n  * @version $Id: Chebyshev.java 1705 2006-09-17 19:57:39Z luc $\n public class Chebyshev\n   extends OrthogonalPolynomial {\n \n+  /** Generator for the Chebyshev polynomials. */\n+  private static final CoefficientsGenerator generator =\n+    new CoefficientsGenerator(new RationalNumber(1l),\n+                              new RationalNumber(0l),\n+                              new RationalNumber(1l)) {\n+    public void setRecurrenceCoefficients(int k) {\n+      // the recurrence relation is\n+      // Tk+1(X) = 2X Tk(X) - Tk-1(X)\n+      setRecurrenceCoefficients(new RationalNumber(0l),\n+                                new RationalNumber(2l),\n+                                new RationalNumber(1l));\n+    }\n+  };\n+\n   /** Simple constructor.\n    * Build a degree 0 Chebyshev polynomial\n    */\n   public Chebyshev() {\n-    super(0, l, maxDegree);\n+    super(0, generator);\n   }\n \n   /** Simple constructor.\n    * Build a degree d Chebyshev polynomial\n-   * @param d degree of the polynomial\n+   * @param degree degree of the polynomial\n    */\n-  public Chebyshev(int d) {\n-    super(d, l, maxDegree);\n+  public Chebyshev(int degree) {\n+    super(degree, generator);\n   }\n \n-  /** Initialize the recurrence coefficients.\n-   * The recurrence relation is\n-   *  <pre>Tk+1(X) = 2X Tk(X) - Tk-1(X)</pre>\n-   * @param k index of the current step\n-   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n-   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n-   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n-   */\n-  protected void initRecurrenceCoefficients(int k,\n-                                            RationalNumber b2k,\n-                                            RationalNumber b3k,\n-                                            RationalNumber b4k) {\n-    b2k.reset(0l);\n-    b3k.reset(2l);\n-    b4k.reset(1l);\n-  }\n-\n-  /** Set the maximal degree of already computed polynomials.\n-   * @param d maximal degree of already computed polynomials\n-   */\n-  protected void setMaxDegree(int d) {\n-    maxDegree = d;\n-  }\n-\n-  private static final long serialVersionUID = 8367010179599693222L;\n-\n-  /** List holding the coefficients of the polynomials computed so far. */\n-  private static List l;\n-\n-  /** Maximal degree of the polynomials computed so far. */\n-  private static int maxDegree;\n-\n-  /** Build the first two polynomials. */\n-  static {\n-\n-    l = new ArrayList ();\n-\n-    // T0(X)  = 1\n-    l.add(new RationalNumber(1l));\n-\n-    // T1(X)  = X\n-    l.add(new RationalNumber(0l));\n-    l.add(new RationalNumber(1l));\n-\n-    maxDegree = 1;\n-\n-  }\n+  private static final long serialVersionUID = -893367988717182601L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Hermite.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Hermite.java\n \n package org.spaceroots.mantissa.algebra;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * This class implements Hermite polynomials.\n \n  * <p>Hermite polynomials can be defined by the following recurrence\n  * relations:\n  * <pre>\n- *  H0(X)   = 1\n- *  H1(X)   = 2X\n- *  Hk+1(X) = 2X Hk(X) - 2k Hk-1(X)\n+ *  H<sub>0</sub>(X)   = 1\n+ *  H<sub>1</sub>(X)   = 2X\n+ *  H<sub>k+1</sub>(X) = 2X H<sub>k</sub>(X) - 2k H<sub>k-1</sub>(X)\n  * </pre></p>\n \n  * @version $Id: Hermite.java 1705 2006-09-17 19:57:39Z luc $\n public class Hermite\n   extends OrthogonalPolynomial {\n \n+  /** Generator for the Hermite polynomials. */\n+  private static final CoefficientsGenerator generator =\n+    new CoefficientsGenerator(new RationalNumber(1l),\n+                              new RationalNumber(0l),\n+                              new RationalNumber(2l)) {\n+    public void setRecurrenceCoefficients(int k) {\n+      // the recurrence relation is\n+      // Hk+1(X) = 2X Hk(X) - 2k Hk-1(X)\n+      setRecurrenceCoefficients(new RationalNumber(0l),\n+                                new RationalNumber(2l),\n+                                new RationalNumber(k * 2l));\n+    }\n+  };\n+\n   /** Simple constructor.\n    * Build a degree 0 Hermite polynomial\n    */\n   public Hermite() {\n-    super(0, l, maxDegree);\n+    super(0, generator);\n   }\n \n   /** Simple constructor.\n    * Build a degree d Hermite polynomial\n-   * @param d degree of the polynomial\n+   * @param degree degree of the polynomial\n    */\n-  public Hermite(int d) {\n-    super(d, l, maxDegree);\n+  public Hermite(int degree) {\n+    super(degree, generator);\n   }\n \n-  /** Initialize the recurrence coefficients.\n-   * The recurrence relation is\n-   *  <pre>Hk+1(X) = 2X Hk(X) - 2k Hk-1(X)</pre>\n-   * @param k index of the current step\n-   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n-   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n-   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n-   */\n-  protected void initRecurrenceCoefficients(int k,\n-                                            RationalNumber b2k,\n-                                            RationalNumber b3k,\n-                                            RationalNumber b4k) {\n-    b2k.reset(0l);\n-    b3k.reset(2l);\n-    b4k.reset(2l * k);\n-  }\n-\n-  /** Set the maximal degree of already computed polynomials.\n-   * @param d maximal degree of already computed polynomials\n-   */\n-  protected void setMaxDegree(int d) {\n-    maxDegree = d;\n-  }\n-\n-  private static final long serialVersionUID = -4639726453485128770L;\n-\n-  /** Table holding the coefficients of the polynomials computed so far. */\n-  private static List l;\n-\n-  /** Maximal degree of the polynomials computed so far. */\n-  private static int maxDegree;\n-\n-  /** Build the first two polynomials. */\n-  static {\n-\n-    l = new ArrayList ();\n-\n-    // H0(X)  = 1\n-    l.add(new RationalNumber(1l));\n-\n-    // H1(X)  = 2X\n-    l.add(new RationalNumber(0l));\n-    l.add(new RationalNumber(2l));\n-\n-    maxDegree = 1;\n-\n-  }\n+  private static final long serialVersionUID = 7910082423686662133L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Laguerre.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Laguerre.java\n \n package org.spaceroots.mantissa.algebra;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * This class implements Laguerre polynomials.\n \n  * <p>Laguerre polynomials can be defined by the following recurrence\n  * relations:\n  * <pre>\n- *        L0(X)   = 1\n- *        L1(X)   = 1 - X\n- *  (k+1) Lk+1(X) = (2k + 1 - X) Lk(X) - k Lk-1(X)\n+ *        L<sub>0</sub>(X)   = 1\n+ *        L<sub>1</sub>(X)   = 1 - X\n+ *  (k+1) L<sub>k+1</sub>(X) = (2k + 1 - X) L<sub>k</sub>(X) - k L<sub>k-1</sub>(X)\n  * </pre></p>\n \n  * @version $Id: Laguerre.java 1705 2006-09-17 19:57:39Z luc $\n public class Laguerre\n   extends OrthogonalPolynomial {\n \n+  /** Generator for the Laguerre polynomials. */\n+  private static final CoefficientsGenerator generator =\n+    new CoefficientsGenerator(new RationalNumber(1l),\n+                              new RationalNumber(1l),\n+                              new RationalNumber(-1l)) {\n+    public void setRecurrenceCoefficients(int k) {\n+      // the recurrence relation is\n+      // (k+1) Lk+1(X) = (2k + 1 - X) Lk(X) - k Lk-1(X)\n+      long kP1 = k + 1;\n+      setRecurrenceCoefficients(new RationalNumber(2 * k + 1, kP1),\n+                                new RationalNumber(-1l, kP1),\n+                                new RationalNumber(k, kP1));\n+    }\n+  };\n+\n   /** Simple constructor.\n    * Build a degree 0 Laguerre polynomial\n    */\n   public Laguerre() {\n-    super(0, l, maxDegree);\n+    super(0, generator);\n   }\n \n   /** Simple constructor.\n    * Build a degree d Laguerre polynomial\n-   * @param d degree of the polynomial\n+   * @param degree degree of the polynomial\n    */\n-  public Laguerre(int d) {\n-    super(d, l, maxDegree);\n+  public Laguerre(int degree) {\n+    super(degree, generator);\n   }\n \n-  /** Initialize the recurrence coefficients.\n-   * The recurrence relation is\n-   *  <pre>(k+1) Lk+1(X) = (2k + 1 - X) Lk(X) - k Lk-1(X)</pre>\n-   * @param k index of the current step\n-   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n-   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n-   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n-   */\n-  protected void initRecurrenceCoefficients(int k,\n-                                            RationalNumber b2k,\n-                                            RationalNumber b3k,\n-                                            RationalNumber b4k) {\n-    long kP1 = k + 1;\n-    b2k.reset(2 * k + 1, kP1);\n-    b3k.reset(-1l, kP1);\n-    b4k.reset(k, kP1);\n-  }\n-\n-  /** Set the maximal degree of already computed polynomials.\n-   * @param d maximal degree of already computed polynomials\n-   */\n-  protected void setMaxDegree(int d) {\n-    maxDegree = d;\n-  }\n-\n-  private static final long serialVersionUID = -750526984136835515L;\n-\n-  /** List holding the coefficients of the polynomials computed so far. */\n-  private static List l;\n-\n-  /** Maximal degree of the polynomials computed so far. */\n-  private static int maxDegree;\n-\n-  /** Build the first two polynomials. */\n-  static {\n-\n-    l = new ArrayList ();\n-\n-    // L0(X)  = 1\n-    l.add(new RationalNumber(1l));\n-\n-    // L1(X)  = 1 - X\n-    l.add(new RationalNumber(1l));\n-    l.add(new RationalNumber(-1l));\n-\n-    maxDegree = 1;\n-\n-  }\n+  private static final long serialVersionUID = 3213856667479179710L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Legendre.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Legendre.java\n \n package org.spaceroots.mantissa.algebra;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n /**\n  * This class implements Legendre polynomials.\n \n  * <p>Legendre polynomials can be defined by the following recurrence\n  * relations:\n  * <pre>\n- *        P0(X)   = 1\n- *        P1(X)   = X\n- *  (k+1) Pk+1(X) = (2k+1) X Pk(X) - k Pk-1(X)\n+ *        P<sub>0</sub>(X)   = 1\n+ *        P<sub>1</sub>(X)   = X\n+ *  (k+1) P<sub>k+1</sub>(X) = (2k+1) X P<sub>k</sub>(X) - k P<sub>k-1</sub>(X)\n  * </pre></p>\n \n  * @version $Id: Legendre.java 1705 2006-09-17 19:57:39Z luc $\n public class Legendre\n   extends OrthogonalPolynomial {\n \n+  /** Generator for the Legendre polynomials. */\n+  private static final CoefficientsGenerator generator =\n+    new CoefficientsGenerator(new RationalNumber(1l),\n+                              new RationalNumber(0l),\n+                              new RationalNumber(1l)) {\n+    public void setRecurrenceCoefficients(int k) {\n+      // the recurrence relation is\n+      // (k+1) Pk+1(X) = (2k+1) X Pk(X) - k Pk-1(X)\n+      long kP1 = k + 1;\n+      setRecurrenceCoefficients(new RationalNumber(0l),\n+                                new RationalNumber(2 * k + 1, kP1),\n+                                new RationalNumber(k, kP1));\n+    }\n+  };\n+\n   /** Simple constructor.\n    * Build a degree 0 Legendre polynomial\n    */\n   public Legendre() {\n-    super(0, l, maxDegree);\n+    super(0, generator);\n   }\n \n   /** Simple constructor.\n    * Build a degree d Legendre polynomial\n-   * @param d degree of the polynomial\n+   * @param degree degree of the polynomial\n    */\n-  public Legendre(int d) {\n-    super(d, l, maxDegree);\n+  public Legendre(int degree) {\n+    super(degree, generator);\n   }\n \n-  /** Initialize the recurrence coefficients.\n-   * The recurrence relation is\n-   *  <pre>(k+1) Pk+1(X) = (2k+1) X Pk(X) - k Ok-1(X)</pre>\n-   * @param k index of the current step\n-   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n-   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n-   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n-   */\n-  protected void initRecurrenceCoefficients(int k,\n-                                            RationalNumber b2k,\n-                                            RationalNumber b3k,\n-                                            RationalNumber b4k) {\n-    long kP1 = k + 1;\n-    b2k.reset(0l);\n-    b3k.reset(2 * k + 1, kP1);\n-    b4k.reset(k, kP1);\n-  }\n-\n-  /** Set the maximal degree of already computed polynomials.\n-   * @param d maximal degree of already computed polynomials\n-   */\n-  protected void setMaxDegree(int d) {\n-    maxDegree = d;\n-  }\n-\n-  private static final long serialVersionUID = 428266828791532209L;\n-\n-  /** List holding the coefficients of the polynomials computed so far. */\n-  private static List l;\n-\n-  /** Maximal degree of the polynomials computed so far. */\n-  private static int maxDegree;\n-\n-  /** Build the first two polynomials. */\n-  static {\n-\n-    l = new ArrayList ();\n-\n-    // P0(X)  = 1\n-    l.add(new RationalNumber(1l));\n-\n-    // P1(X)  = X\n-    l.add(new RationalNumber(0l));\n-    l.add(new RationalNumber(1l));\n-\n-    maxDegree = 1;\n-\n-  }\n+  private static final long serialVersionUID = 4014485393845978429L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/OrthogonalPolynomial.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/OrthogonalPolynomial.java\n \n package org.spaceroots.mantissa.algebra;\n \n-import java.util.List;\n-\n /**\n  * This class is the base class for orthogonal polynomials.\n \n  * <p>Orthogonal polynomials can be defined by recurrence relations like:\n  * <pre>\n- *      O0(X)   = some 0 degree polynomial\n- *      O1(X)   = some first degree polynomial\n- *  a1k Ok+1(X) = (a2k + a3k X) Ok(X) - a4k Ok-1(X)\n+ *      O<sub>0</sub>(X)   = some 0 degree polynomial\n+ *      O<sub>1</sub>(X)   = some first degree polynomial\n+ *  a<sub>1,k</sub> O<sub>k+1</sub>(X) = (a<sub>2,k</sub> + a<sub>3,k</sub> X) O<sub>k</sub>(X) - a<sub>4,k</sub> O<sub>k-1</sub>(X)\n  * </pre>\n- * where a0k, a1k, a2k and a3k are simple expressions which either are\n+ * where a<sub>1,k</sub>, a<sub>2,k</sub>, a<sub>3,k</sub> and\n+ * a<sub>4,k</sub> are simple expressions which either are\n  * constants or depend on k.</p>\n \n  * @version $Id: OrthogonalPolynomial.java 1705 2006-09-17 19:57:39Z luc $\n \n   /** Simple constructor.\n    * Build a degree d orthogonal polynomial\n-   * @param d degree of the polynomial\n-   * @param l list containing all coefficients already computed\n-   * @param maxDegree maximal degree of computed coefficients, this\n-   * coefficient <em>must</em> be greater or equal to 1, i.e. the\n-   * derived class <em>must</em> have initialized the first two\n-   * polynomials of degree 0 and 1 before this constructor can be\n-   * called.\n+   * @param degree degree of the polynomial\n+   * @param generator coefficients generator for the current type of polynomials\n    */\n-  protected OrthogonalPolynomial(int d, List l, int maxDegree) {\n-    if (d > maxDegree) {\n-      computeUpToDegree(d, l, maxDegree);\n-    }\n-\n-    // coefficient  for polynomial 0 is  l [0]\n-    // coefficient  for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)\n-    // coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)\n-    // coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)\n-    // coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)\n-    // coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)\n-    // coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)\n-    // ...\n-    int start = d * (d + 1) / 2;\n-\n-    a = new RationalNumber[d+1];\n-    for (int i = 0; i <= d; ++i) {\n-      a[i] = new RationalNumber((RationalNumber) l.get(start + i));\n-    }\n-\n-    unknown = null;\n-\n-  }\n-\n-  /** Initialize the recurrence coefficients.\n-   * The recurrence relation is\n-   *  <pre>a1k Ok+1(X) = (a2k + a3k X) Ok(X) - a4k Ok-1(X)</pre>\n-   * @param k index of the current step\n-   * @param b2k coefficient to initialize (b2k = a2k / a1k)\n-   * @param b3k coefficient to initialize (b3k = a3k / a1k)\n-   * @param b4k coefficient to initialize (b4k = a4k / a1k)\n-   */\n-  protected abstract void initRecurrenceCoefficients(int k,\n-                                                     RationalNumber b2k,\n-                                                     RationalNumber b3k,\n-                                                     RationalNumber b4k);\n-\n-  /** Set the maximal degree of already computed polynomials.\n-   * @param d maximal degree of already computed polynomials\n-   */\n-  protected abstract void setMaxDegree(int d);\n-\n-  /** Compute all the polynomial coefficients up to a given degree.\n-   * @param d maximal degree\n-   * @param l list containing all coefficients already computed\n-   * @param maxDegree maximal degree of computed coefficients\n-   */\n-  protected void computeUpToDegree(int d, List l, int maxDegree) {\n-\n-    RationalNumber b2k = new RationalNumber();\n-    RationalNumber b3k = new RationalNumber();\n-    RationalNumber b4k = new RationalNumber();\n-\n-    int startK = (maxDegree - 1) * maxDegree / 2;\n-    for (int k = maxDegree; k < d; ++k) {\n-\n-      // start indices of two previous polynomials Ok(X) and Ok-1(X)\n-      int startKm1 = startK;\n-      startK += k;\n-\n-      // a1k Ok+1(X) = (a2k + a3k X) Ok(X) - a4k Ok-1(X)\n-      // we use bik = aik/a1k\n-      initRecurrenceCoefficients(k, b2k, b3k, b4k);\n-\n-      RationalNumber ckPrev = null;\n-      RationalNumber ck     = (RationalNumber)l.get(startK);\n-      RationalNumber ckm1   = (RationalNumber)l.get(startKm1);\n-\n-      // degree 0 coefficient\n-      RationalNumber coeff  = RationalNumber.multiply(ck, b2k);\n-      coeff.multiplyAndSubtractFromSelf(ckm1, b4k);\n-      l.add(coeff);\n-\n-      // degree 1 to degree k-1 coefficients\n-      for (int i = 1; i < k; ++i) {\n-        ckPrev = ck;\n-        ck     = (RationalNumber)l.get(startK + i);\n-        ckm1   = (RationalNumber)l.get(startKm1 + i);\n-        coeff  = RationalNumber.multiply(ck, b2k);\n-        coeff.multiplyAndAddToSelf(ckPrev, b3k);\n-        coeff.multiplyAndSubtractFromSelf(ckm1, b4k);\n-        l.add(coeff);\n-      }\n-\n-      // degree k coefficient\n-      ckPrev = ck;\n-      ck     = (RationalNumber)l.get(startK + k);\n-      coeff  = RationalNumber.multiply(ck, b2k);\n-      coeff.multiplyAndAddToSelf(ckPrev, b3k);\n-      l.add(coeff);\n-\n-      // degree k+1 coefficient\n-      l.add(RationalNumber.multiply(ck, b3k));\n-\n-    }\n-\n-    setMaxDegree(d);\n-\n+  protected OrthogonalPolynomial(int degree, CoefficientsGenerator generator) {\n+    a       = generator.getCoefficients(degree);\n   }\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n \n import java.io.Serializable;\n import java.math.BigInteger;\n-\n-/**\n- * This class implements polynomials with one unknown.\n+import java.util.Arrays;\n+\n+/** This class implements polynomials with one unknown.\n \n  * <p>This is an abstract class that only declares general methods but\n  * does not hold the coefficients by themselves. Specific subclasses\n  * considered (value of the polynom for a given unknown,\n  * derivative).</p>\n \n+ * <p>Instances of this class are immutable.</p>\n+\n  * @version $Id: Polynomial.java 1705 2006-09-17 19:57:39Z luc $\n  * @author L. Maisonobe\n \n */\n-public abstract class Polynomial\n-  implements Cloneable, Serializable {\n-\n-  /** Create a copy of the instance.\n-   * @return a copy of the instance\n-   */\n-  public abstract Object clone();\n+public abstract class Polynomial implements Serializable {\n \n   /** Check if the instance is the null polynomial.\n    * @return true if the polynomial is null\n   public abstract int getDegree();\n \n   /** Negate the instance.\n-   */\n-  public abstract void negateSelf();\n+   * @return a new polynomial\n+   */\n+  public abstract Polynomial negate();\n \n   /** Multiply the instance by a constant.\n    * @param r constant to multiply by\n-   */\n-  public abstract void multiplySelf(RationalNumber r);\n+   * @return a new polynomial\n+   */\n+  public abstract Polynomial multiply(RationalNumber r);\n \n   /** Multiply the instance by a constant.\n    * @param l constant to multiply by\n-   */\n-  public abstract void multiplySelf(long l);\n+   * @return a new Polynomial\n+   */\n+  public abstract Polynomial multiply(long l);\n \n   /** Multiply the instance by a constant.\n    * @param i constant to multiply by\n-   */\n-  public void multiplySelf(BigInteger i) {\n-    multiplySelf(new RationalNumber(i));\n+   * @return a new Polynomial\n+   */\n+  public Polynomial multiply(BigInteger i) {\n+    return multiply(new RationalNumber(i));\n   }\n \n-  /** Get the value of the polynomial for a specified unknown.\n+  /** Divide the instance by a constant.\n+   * @param l constant to multiply by\n+   * @return a new polynomial\n+   * @exception ArithmeticException if the constant is zero\n+   */\n+  public Polynomial divide(long l) {\n+    return divide(new RationalNumber(l));\n+  }\n+\n+  /** Divide the instance by a constant.\n+   * @param r constant to multiply by\n+   * @return a new polynomial\n+   * @exception ArithmeticException if the constant is zero\n+   */\n+  public Polynomial divide(RationalNumber r) {\n+    return multiply(r.invert());\n+  }\n+\n+  /** Divide the instance by a constant.\n+   * @param i constant to multiply by\n+   * @return a new polynomial\n+   * @exception ArithmeticException if the constant is zero\n+   */\n+  public Polynomial divide(BigInteger i) {\n+    return divide(new RationalNumber(i));\n+  }\n+\n+ /** Get the value of the polynomial for a specified unknown.\n    * @param x value of the unknown\n    * @return value of the polynomial\n    */\n    */\n   public abstract Polynomial getDerivative();\n \n-  /** Set the name of the unknown (to appear during conversions to strings).\n-   * @param name name to set (if null, the default 'x' value  will be used)\n-   */\n-  public abstract void setUnknownName(String name);\n-\n   /** This class implements polynomials with one unknown and rational\n    * coefficients.\n \n      * Build a null polynomial\n      */\n     public Rational() {\n-      a = new RationalNumber[1];\n-      a[0] = new RationalNumber(0l);\n-      unknown = null;\n+      a = new RationalNumber[] { RationalNumber.ZERO };\n     }\n \n     /** Simple constructor.\n      * @param value constant value of the polynomial\n      */\n     public Rational(RationalNumber value) {\n-      a = new RationalNumber[1];\n-      a[0] = value;\n-      unknown = null;\n+      a = new RationalNumber[] { value };\n     }\n \n     /** Simple constructor.\n      */\n     public Rational(RationalNumber a1, RationalNumber a0) {\n       if (! a1.isZero()) {\n-        a = new RationalNumber[2];\n-        a[1] = a1;\n-      } else {\n-        a = new RationalNumber[1];\n-      }\n-      a[0] = a0;\n-      unknown = null;\n+        a = new RationalNumber[] { a0, a1 };\n+      } else {\n+        a = new RationalNumber[] { a0 };\n+      }\n     }\n \n     /** Simple constructor.\n      */\n     public Rational(RationalNumber a2, RationalNumber a1, RationalNumber a0) {\n       if (! a2.isZero()) {\n-        a = new RationalNumber[3];\n-        a[2] = a2;\n-        a[1] = a1;\n+        a = new RationalNumber[] { a0, a1, a2 };\n       } else {\n         if (! a1.isZero()) {\n-          a = new RationalNumber[2];\n-          a[1] = a1;\n+          a = new RationalNumber[] { a0, a1 };\n         } else {\n-          a = new RationalNumber[1];\n-        }\n-      }\n-      a[0] = a0;\n-      unknown = null;\n+          a = new RationalNumber[] { a0 };\n+        }\n+      }\n+    }\n+\n+    /** Simple constructor.\n+     * Build a third degree polynomial\n+     * @param a3 leeding degree coefficient\n+     * @param a2 second degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Rational(long a3, long a2, long a1, long a0) {\n+      this(new RationalNumber(a3),\n+           new RationalNumber(a2),\n+           new RationalNumber(a1),\n+           new RationalNumber(a0));\n+    }\n+\n+    /** Simple constructor.\n+     * Build a third degree polynomial\n+     * @param a3 leeding degree coefficient\n+     * @param a2 second degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Rational(RationalNumber a3, RationalNumber a2,\n+                    RationalNumber a1, RationalNumber a0) {\n+      if (! a3.isZero()) {\n+        a = new RationalNumber[] { a0, a1, a2, a3 };\n+      } else {\n+        if (! a2.isZero()) {\n+          a = new RationalNumber[] { a0, a1, a2 };\n+        } else {\n+          if (! a1.isZero()) {\n+            a = new RationalNumber[] { a0, a1 };\n+          } else {\n+            a = new RationalNumber[] { a0 };\n+          }\n+        }\n+      }\n     }\n \n     /** Simple constructor.\n       this.a = new RationalNumber[i + 1];\n       System.arraycopy(a, 0, this.a, 0, i + 1);\n \n-      unknown = null;\n-\n     }\n \n     /** Simple constructor.\n     public Rational(RationalNumber c, int degree) {\n \n       if (c.isZero() || degree < 0) {\n-        a = new RationalNumber[1];\n-        a[0] = new RationalNumber(0l);\n+        a = new RationalNumber[] { RationalNumber.ZERO };\n       } else {\n         a = new RationalNumber[degree + 1];\n-        for (int i = 0; i < degree; ++i) {\n-          a[i] = new RationalNumber(0l);\n-        }\n-        a[degree] = new RationalNumber(c);\n-      }\n-\n-      unknown = null;\n-\n-    }\n-\n-    /** Copy constructor.\n-     * The copy is a deep copy: the polynomials do <em>not</em> share\n-     * their coefficients arrays\n-     * @param p polynomial to copy\n-     */\n-    public Rational(Rational p) {\n-\n-      a = new RationalNumber[p.a.length];\n-      for (int i = 0; i < a.length; ++i) {\n-        a[i] = new RationalNumber(p.a[i]);\n-      }\n-\n-      if (p.unknown == null) {\n-        unknown = null;\n-      } else {\n-        unknown = new String(p.unknown);\n-      }\n-\n-    }\n-\n-    /** Create a copy of the instance.\n-     * @return a copy of the instance\n-     */\n-    public Object clone() {\n-      return new Rational(this);\n+        Arrays.fill(a, 0, degree, RationalNumber.ZERO);\n+        a[degree] = c;\n+      }\n+\n     }\n \n     /** Check if the instance is the null polynomial.\n     }\n \n     /** Get the coefficients of the polynomial.\n-     * @return a reference to the internal coefficients array, the array\n+     * @return a copy of the coefficients array, the array\n      * element at index 0 is the constant term while the element at\n-     * index a.length-1 is the leeding degree coefficient\n+     * index a.length-1 is the leading degree coefficient\n      */\n     public RationalNumber[] getCoefficients() {\n-      return a;\n-    }\n-\n-    /** Set the name of the unknown (to appear during conversions to strings).\n-     * @param name name to set (if null, the default 'x' value  will be used)\n-     */\n-    public void setUnknownName(String name) {\n-      unknown = name;\n-    }\n-\n-    /** Simplify the polynomial, by removing null high degree terms.\n-     */\n-    private void simplify() {\n-\n-      int i = a.length - 1;\n-      while ((i > 0) && a[i].isZero()) {\n-        --i;\n-      }\n-\n-      if (i < a.length - 1) {\n-        RationalNumber[] newA = new RationalNumber[i + 1];\n-        System.arraycopy(a, 0, newA, 0, i + 1);\n-        a = newA;\n-      }\n-\n-    }\n-\n-    /** Add a polynomial to the instance.\n+      return (RationalNumber[]) a.clone();\n+    }\n+\n+    /** Add a polynomial to the instance\n      * @param p polynomial to add\n-     */\n-    public void addToSelf(Rational p) {\n-\n-      if (p.a.length > a.length) {\n-        RationalNumber[] newA = new RationalNumber[p.a.length];\n-        System.arraycopy(a, 0, newA, 0, a.length);\n-        for (int i = a.length; i < newA.length; ++i) {\n-          newA[i] = new RationalNumber(0l);\n-        }\n-        a = newA;\n-      }\n-\n-      for (int i = 0; i < p.a.length; ++i) {\n-        a[i].addToSelf(p.a[i]);\n-      }\n-\n-      simplify();\n-\n-    }\n-\n-    /** Add two polynomials.\n-     * @param p1 first polynomial\n-     * @param p2 second polynomial\n-     * @return a new polynomial which is the sum of p1 and p2\n-     */\n-    public static Rational add(Rational p1, Rational p2) {\n-      Rational copy = new Rational(p1);\n-      copy.addToSelf(p2);\n-      return copy;\n+     * @return a new polynomial which is the sum of the instance and p\n+     */\n+    public Rational add(Rational p) {\n+\n+      // identify the lowest degree polynomial\n+      int lowLength  = Math.min(a.length, p.a.length);\n+      int highLength = Math.max(a.length, p.a.length);\n+\n+      // build the coefficients array\n+      RationalNumber[] newA = new RationalNumber[highLength];\n+      for (int i = 0; i < lowLength; ++i) {\n+        newA[i] = a[i].add(p.a[i]);\n+      }\n+      System.arraycopy((a.length < p.a.length) ? p.a : a,\n+                       lowLength, newA, lowLength, highLength - lowLength);\n+\n+      return new Rational(newA);\n+\n     }\n \n     /** Subtract a polynomial from the instance.\n      * @param p polynomial to subtract\n-     */\n-    public void subtractFromSelf(Rational p) {\n-\n-      if (p.a.length > a.length) {\n-        RationalNumber[] newA = new RationalNumber[p.a.length];\n-        System.arraycopy(a, 0, newA, 0, a.length);\n-        for (int i = a.length; i < newA.length; ++i) {\n-          newA[i] = new RationalNumber(0l);\n-        }\n-        a = newA;\n-      }\n-\n-      for (int i = 0; i < p.a.length; ++i) {\n-        a[i].subtractFromSelf(p.a[i]);\n-      }\n-\n-      simplify();\n-\n-    }\n-\n-    /** Subtract two polynomials.\n-     * @param p1 first polynomial\n-     * @param p2 second polynomial\n-     * @return a new polynomial which is the difference p1 minus p2\n-     */\n-    public static Rational subtract(Rational p1, Rational p2) {\n-      Rational copy = new Rational(p1);\n-      copy.subtractFromSelf(p2);\n-      return copy;\n+     * @return a new polynomial which is the difference the instance minus p\n+     */\n+    public Rational subtract(Rational p) {\n+\n+      // identify the lowest degree polynomial\n+      int lowLength  = Math.min(a.length, p.a.length);\n+      int highLength = Math.max(a.length, p.a.length);\n+\n+      // build the coefficients array\n+      RationalNumber[] newA = new RationalNumber[highLength];\n+      for (int i = 0; i < lowLength; ++i) {\n+        newA[i] = a[i].subtract(p.a[i]);\n+      }\n+      if (a.length < p.a.length) {\n+        for (int i = lowLength; i < highLength; ++i) {\n+          newA[i] = p.a[i].negate();\n+        }\n+      } else {\n+        System.arraycopy(a, lowLength, newA, lowLength, highLength - lowLength);\n+      }\n+\n+      return new Rational(newA);\n+\n     }\n \n     /** Negate the instance.\n-     */\n-    public void negateSelf() {\n+     * @return a new polynomial\n+     */\n+    public Polynomial negate() {\n+      RationalNumber[] newA = new RationalNumber[a.length];\n       for (int i = 0; i < a.length; ++i) {\n-        a[i].negateSelf();\n-      }\n-    }\n-\n-    /** Negate a polynomial.\n-     * @param p polynomial to negate\n-     * @return a new polynomial which is the opposite of p\n-     */\n-    public static Rational negate(Rational p) {\n-      Rational copy = new Rational(p);\n-      copy.negateSelf();\n-      return copy;\n+        newA[i] = a[i].negate();\n+      }\n+      return new Rational(newA);\n     }\n \n     /** Multiply the instance by a polynomial.\n      * @param p polynomial to multiply by\n-     */\n-    public void multiplySelf(Rational p) {\n+     * @return a new polynomial\n+     */\n+    public Rational multiply(Rational p) {\n \n       RationalNumber[] newA = new RationalNumber[a.length + p.a.length - 1];\n \n       for (int i = 0; i < newA.length; ++i) {\n-        newA[i] = new RationalNumber(0l);\n+        newA[i] = RationalNumber.ZERO;\n         for (int j = Math.max(0, i + 1 - p.a.length);\n              j < Math.min(a.length, i + 1);\n              ++j) {\n-          newA[i].addToSelf(RationalNumber.multiply(a[j], p.a[i-j]));\n-        }\n-      }\n-\n-      a = newA;\n-\n-    }\n-\n-    /** Multiply two polynomials.\n-     * @param p1 first polynomial\n-     * @param p2 second polynomial\n-     * @return a new polynomial which is the product of p1 and p2\n-     */\n-    public static Rational multiply(Rational p1, Rational p2) {\n-      Rational copy = new Rational(p1);\n-      copy.multiplySelf(p2);\n-      return copy;\n+          newA[i] = newA[i].add(a[j].multiply(p.a[i-j]));\n+        }\n+      }\n+\n+      return new Rational(newA);\n+\n+    }\n+\n+    /** Multiply the instance by a constant.\n+     * @param l constant to multiply by\n+     * @return a new polynomial\n+     */\n+    public Polynomial multiply(long l) {\n+      return multiply(new RationalNumber(l));\n     }\n \n     /** Multiply the instance by a constant.\n      * @param r constant to multiply by\n-     */\n-    public void multiplySelf(RationalNumber r) {\n+     * @return a new polynomial\n+     */\n+    public Polynomial multiply(RationalNumber r) {\n \n       if (r.isZero()) {\n-        a = new RationalNumber[1];\n-        a[0] = new RationalNumber(0l);\n-      }\n-\n+        return new Rational(new RationalNumber[] { RationalNumber.ZERO });\n+      }\n+\n+      if (r.isOne()) {\n+        return this;\n+      }\n+\n+      RationalNumber[] newA = new RationalNumber[a.length];\n       for (int i = 0; i < a.length; ++i) {\n-        a[i].multiplySelf(r);\n-      }\n-\n-    }\n-\n-    /** Multiply a polynomial by a constant.\n-     * @param p polynomial\n-     * @param r constant\n-     * @return a new polynomial which is the product of p and r\n-     */\n-    public static Rational multiply(Rational p, RationalNumber r) {\n-      Rational copy = new Rational(p);\n-      copy.multiplySelf(r);\n-      return copy;\n-    }\n-\n-    /** Multiply the instance by a constant.\n-     * @param l constant to multiply by\n-     */\n-    public void multiplySelf(long l) {\n-\n-      if (l == 0l) {\n-        a = new RationalNumber[1];\n-        a[0] = new RationalNumber(0l);\n-      }\n-\n-      for (int i = 0; i < a.length; ++i) {\n-        a[i].multiplySelf(l);\n-      }\n-\n-    }\n-\n-    /** Multiply a polynomial by a constant.\n-     * @param p polynomial\n-     * @param l constant\n-     * @return a new polynomial which is the product of p and l\n-     */\n-    public static Rational multiply(Rational p, long l) {\n-      Rational copy = new Rational(p);\n-      copy.multiplySelf(l);\n-      return copy;\n+        newA[i] = a[i].multiply(r);\n+      }\n+      return new Rational(newA);\n+\n     }\n \n     /** Get the value of the polynomial for a specified unknown.\n      * @return a new polynomial which is the derivative of the instance\n      */\n     public Polynomial getDerivative() {\n-      Rational derivative = new Rational();\n       if (a.length == 1) {\n-        return derivative;\n-      }\n-      derivative.a = new RationalNumber[a.length - 1];\n+        return new Rational();\n+      }\n+      RationalNumber[] newA = new RationalNumber[a.length - 1];\n       for (int i = 1; i < a.length; ++i) {\n-        derivative.a[i-1] = RationalNumber.multiply(a[i], i);\n-      }\n-      return derivative;\n+        newA[i - 1] = a[i].multiply(i);\n+      }\n+      return new Rational(newA);\n     }\n \n     /** Perform the euclidian division of two polynomials.\n                                                    Rational divisor) {\n \n       Rational quotient  = new Rational(0l);\n-      Rational remainder = new Rational(dividend);\n+      Rational remainder = dividend;\n \n       int divisorDegree   = divisor.getDegree();\n       int remainderDegree = remainder.getDegree();\n       while ((! remainder.isZero()) && (remainderDegree >= divisorDegree)) {\n \n-        RationalNumber c = RationalNumber.divide(remainder.a[remainderDegree],\n-                                                 divisor.a[divisorDegree]);\n+        RationalNumber c =\n+          remainder.a[remainderDegree].divide(divisor.a[divisorDegree]);\n         Rational monomial = new Rational(c, remainderDegree - divisorDegree);\n \n-        remainder.subtractFromSelf(Rational.multiply(monomial, divisor));\n-        quotient.addToSelf(monomial);\n+        remainder = remainder.subtract(monomial.multiply(divisor));\n+        quotient  = quotient.add(monomial);\n \n         remainderDegree = remainder.getDegree();\n \n       BigInteger lcm = BigInteger.ONE;\n \n       for (int i = 0; i < a.length; ++i) {\n-        RationalNumber newCoeff = RationalNumber.multiply(a[i], lcm);\n+        RationalNumber newCoeff = a[i].multiply(lcm);\n         if (! newCoeff.isInteger()) {\n           lcm = lcm.multiply(newCoeff.getDenominator());\n         }\n     * (i.e. we display <code>-3</code> for a constant negative polynomial,\n     * but <code>1 - 3 x + x^2</code> if the negative coefficient is not\n     * the first one displayed).</p>\n-\n-    * <p>The name of the unknown is <code>x</code> by default, but can\n-    * be changed using the {@link #setUnknownName setUnknownName}\n-    * method.</p>\n \n     * @return a string representation of the polynomial\n \n             s.append(' ');\n           }\n \n-          s.append((unknown == null) ? defaultUnknown : unknown);\n+          s.append(\"x\");\n           if (i > 1) {\n             s.append('^');\n             s.append(Integer.toString(i));\n     /** Coefficients array. */\n     protected RationalNumber[] a;\n \n-    /** Name of the unknown. */\n-    protected String unknown;\n-\n-    private static final long serialVersionUID = 3035650338772911046L;\n+    private static final long serialVersionUID = -794133890636181115L;\n \n   }\n \n      * Build a null polynomial\n      */\n     public Double() {\n-      a = new double[1];\n-      a[0] = 0;\n-      unknown = null;\n+      a = new double[] { 0.0 };\n     }\n \n     /** Simple constructor.\n      * Build a constant polynomial\n      * @param value constant value of the polynomial\n      */\n+    public Double(long value) {\n+      this((double) value);\n+    }\n+\n+    /** Simple constructor.\n+     * Build a constant polynomial\n+     * @param value constant value of the polynomial\n+     */\n     public Double(double value) {\n-      a = new double[1];\n-      a[0] = value;\n-      unknown = null;\n+      a = new double[] { value };\n     }\n \n     /** Simple constructor.\n      * @param a1 leeding degree coefficient\n      * @param a0 constant term\n      */\n+    public Double(long a1, long a0) {\n+      this((double) a1, (double) a0);\n+    }\n+\n+    /** Simple constructor.\n+     * Build a first degree polynomial\n+     * @param a1 leeding degree coefficient\n+     * @param a0 constant term\n+     */\n     public Double(double a1, double a0) {\n-      if (Math.abs(a1) > 1.0e-12) {\n-        a = new double[2];\n-        a[1] = a1;\n-      } else {\n-        a = new double[1];\n-      }\n-      a[0] = a0;\n-      unknown = null;\n+      if (a1 != 0) {\n+        a = new double[] { a0, a1 };\n+      } else {\n+        a = new double[] { a0 };\n+      }\n     }\n \n     /** Simple constructor.\n      * @param a1 first degree coefficient\n      * @param a0 constant term\n      */\n+    public Double(long a2, long a1, long a0) {\n+      this((double) a2, (double) a1, (double) a0);\n+    }\n+\n+    /** Simple constructor.\n+     * Build a second degree polynomial\n+     * @param a2 leeding degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n     public Double(double a2, double a1, double a0) {\n-      if (Math.abs(a2) > 1.0e-12) {\n-        a = new double[3];\n-        a[2] = a2;\n-        a[1] = a1;\n-      } else {\n-        if (Math.abs(a1) > 1.0e-12) {\n-          a = new double[2];\n-          a[1] = a1;\n+      if (a2 != 0) {\n+        a = new double[] { a0, a1, a2 };\n+      } else {\n+        if (a1 != 0) {\n+          a = new double[] { a0, a1 };\n         } else {\n-          a = new double[1];\n-        }\n-      }\n-      a[0] = a0;\n-      unknown = null;\n+          a = new double[] { a0 };\n+        }\n+      }\n+    }\n+\n+    /** Simple constructor.\n+     * Build a third degree polynomial\n+     * @param a3 leeding degree coefficient\n+     * @param a2 second degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Double(long a3, long a2, long a1, long a0) {\n+      this((double) a3, (double) a2, (double) a1, (double) a0);\n+    }\n+\n+    /** Simple constructor.\n+     * Build a third degree polynomial\n+     * @param a3 leeding degree coefficient\n+     * @param a2 second degree coefficient\n+     * @param a1 first degree coefficient\n+     * @param a0 constant term\n+     */\n+    public Double(double a3, double a2, double a1, double a0) {\n+      if (a3 != 0) {\n+        a = new double[] { a0, a1, a2, a3 };\n+      } else {\n+        if (a2 != 0) {\n+          a = new double[] { a0, a1, a2 };\n+        } else {\n+          if (a1 != 0) {\n+            a = new double[] { a0, a1 };\n+          } else {\n+            a = new double[] { a0 };\n+          }\n+        }\n+      }\n     }\n \n     /** Simple constructor.\n \n       // remove null high degree coefficients\n       int i = a.length - 1;\n-      while ((i > 0) && (Math.abs(a[i]) <= 1.0e-12)) {\n+      while ((i > 0) && (a[i] == 0)) {\n         --i;\n       }\n \n       this.a = new double[i + 1];\n       System.arraycopy(a, 0, this.a, 0, i + 1);\n \n-      unknown = null;\n-\n     }\n \n     /** Simple constructor.\n      * @param degree degree associated with the coefficient\n      */\n     public Double(double c, int degree) {\n-\n-      if ((Math.abs(c) <= 1.0e-12) || degree < 0) {\n-        a = new double[1];\n-        a[0] = 0;\n+      if ((c == 0) || degree < 0) {\n+        a = new double[] { 0.0 };\n       } else {\n         a = new double[degree + 1];\n-        for (int i = 0; i < degree; ++i) {\n-          a[i] = 0;\n-        }\n+        Arrays.fill(a, 0, degree, 0.0);\n         a[degree] = c;\n       }\n-\n-      unknown = null;\n-\n-    }\n-\n-    /** Copy constructor.\n-     * The copy is a deep copy: the polynomials do <em>not</em> share\n-     * their coefficients arrays\n-     * @param p polynomial to copy\n-     */\n-    public Double(Double p) {\n-\n-      a = new double[p.a.length];\n+    }\n+\n+    /** Simple constructor.\n+     * Build a {@link Polynomial.Double Polynomial.Double} from a\n+     * {@link Polynomial.Rational Polynomial.Rational}\n+     * @param r a rational polynomial\n+     */\n+    public Double(Rational r) {\n+      // convert the coefficients\n+      a = new double[r.a.length];\n       for (int i = 0; i < a.length; ++i) {\n-        a[i] = p.a[i];\n-      }\n-\n-      if (p.unknown == null) {\n-        unknown = null;\n-      } else {\n-        unknown = new String(p.unknown);\n-      }\n-\n-    }\n-\n-    /** Copy constructor.\n-     * The copy is a deep copy: the polynomials do <em>not</em> share\n-     * their coefficients arrays\n-     * @param p polynomial to copy\n-     */\n-    public Double(Rational p) {\n-\n-      RationalNumber[] pA = p.getCoefficients();\n-      a = new double[pA.length];\n-      for (int i = 0; i < a.length; ++i) {\n-        a[i] = pA[i].doubleValue();\n-      }\n-\n-      if (p.unknown == null) {\n-        unknown = null;\n-      } else {\n-        unknown = new String(p.unknown);\n-      }\n-\n-    }\n-\n-    /** Create a copy of the instance.\n-     * @return a copy of the instance\n-     */\n-    public Object clone() {\n-      return new Double(this);\n+        a[i] = r.a[i].doubleValue();\n+      }\n     }\n \n     /** Check if the instance is the null polynomial.\n      * @return true if the polynomial is null\n      */\n     public boolean isZero() {\n-      return (a.length == 1) && (Math.abs(a[0]) < 1.0e-12);\n+      return (a.length == 1) && (a[0] == 0);\n     }\n \n     /** Check if the instance is the constant unit polynomial.\n      * @return true if the polynomial is the constant unit polynomial\n      */\n     public boolean isOne() {\n-      return (a.length == 1) && (Math.abs(a[0] - 1) < 1.0e-12);\n+      return (a.length == 1) && ((a[0] - 1.0) == 0);\n     }\n \n     /** Check if the instance is the identity polynomial.\n      * @return true if the polynomial is the identity polynomial\n      */\n     public boolean isIdentity() {\n-      return (a.length == 2)\n-        && (Math.abs(a[0]) < 1.0e-12)\n-        && (Math.abs(a[1] - 1) < 1.0e-12);\n+      return (a.length == 2) && (a[0] == 0) && ((a[1] - 1.0) == 0);\n     }\n \n     /** Get the polynomial degree.\n     }\n \n     /** Get the coefficients of the polynomial.\n-     * @return a reference to the internal coefficients array, the array\n+     * @return a copy of the coefficients array, the array\n      * element at index 0 is the constant term while the element at\n-     * index a.length-1 is the leeding degree coefficient\n+     * index a.length-1 is the leading degree coefficient\n      */\n     public double[] getCoefficients() {\n-      return a;\n-    }\n-\n-    /** Simplify the polynomial, by removing null high degree terms.\n-     */\n-    private void simplify() {\n-\n-      int i = a.length - 1;\n-      while ((i > 0) && (Math.abs(a[i]) <= 1.0e-12)) {\n-        --i;\n-      }\n-\n-      if (i < a.length - 1) {\n-        double[] newA = new double[i + 1];\n-        System.arraycopy(a, 0, newA, 0, i + 1);\n-        a = newA;\n-      }\n-\n-    }\n-\n-    /** Add a polynomial to the instance.\n+      return (double[]) a.clone();\n+    }\n+\n+    /** Add a polynomial to the instance\n      * @param p polynomial to add\n-     */\n-    public void addToSelf(Double p) {\n-\n-      if (p.a.length > a.length) {\n-        double[] newA = new double[p.a.length];\n-        System.arraycopy(a, 0, newA, 0, a.length);\n-        for (int i = a.length; i < newA.length; ++i) {\n-          newA[i] = 0;\n-        }\n-        a = newA;\n-      }\n-\n-      for (int i = 0; i < p.a.length; ++i) {\n-        a[i] += p.a[i];\n-      }\n-\n-      simplify();\n-\n-    }\n-\n-    /** Add two polynomials.\n-     * @param p1 first polynomial\n-     * @param p2 second polynomial\n-     * @return a new polynomial which is the sum of p1 and p2\n-     */\n-    public static Double add(Double p1, Double p2) {\n-      Double copy = new Double(p1);\n-      copy.addToSelf(p2);\n-      return copy;\n+     * @return a new polynomial which is the sum of the instance and p\n+     */\n+    public Double add(Double p) {\n+\n+      // identify the lowest degree polynomial\n+      int lowLength  = Math.min(a.length, p.a.length);\n+      int highLength = Math.max(a.length, p.a.length);\n+\n+      // build the coefficients array\n+      double[] newA = new double[highLength];\n+      for (int i = 0; i < lowLength; ++i) {\n+        newA[i] = a[i] + p.a[i];\n+      }\n+      System.arraycopy((a.length < p.a.length) ? p.a : a,\n+                       lowLength, newA, lowLength, highLength - lowLength);\n+\n+      return new Double(newA);\n+\n     }\n \n     /** Subtract a polynomial from the instance.\n      * @param p polynomial to subtract\n-     */\n-    public void subtractFromSelf(Double p) {\n-\n-      if (p.a.length > a.length) {\n-        double[] newA = new double[p.a.length];\n-        System.arraycopy(a, 0, newA, 0, a.length);\n-        for (int i = a.length; i < newA.length; ++i) {\n-          newA[i] = 0;\n-        }\n-        a = newA;\n-      }\n-\n-      for (int i = 0; i < p.a.length; ++i) {\n-        a[i] -= p.a[i];\n-      }\n-\n-      simplify();\n-\n-    }\n-\n-    /** Subtract two polynomials.\n-     * @param p1 first polynomial\n-     * @param p2 second polynomial\n-     * @return a new polynomial which is the difference p1 minus p2\n-     */\n-    public static Double subtract(Double p1, Double p2) {\n-      Double copy = new Double(p1);\n-      copy.subtractFromSelf(p2);\n-      return copy;\n+     * @return a new polynomial which is the difference the instance minus p\n+     */\n+    public Double subtract(Double p) {\n+\n+      // identify the lowest degree polynomial\n+      int lowLength  = Math.min(a.length, p.a.length);\n+      int highLength = Math.max(a.length, p.a.length);\n+\n+      // build the coefficients array\n+      double[] newA = new double[highLength];\n+      for (int i = 0; i < lowLength; ++i) {\n+        newA[i] = a[i] - p.a[i];\n+      }\n+      if (a.length < p.a.length) {\n+        for (int i = lowLength; i < highLength; ++i) {\n+          newA[i] = -p.a[i];\n+        }\n+      } else {\n+        System.arraycopy(a, lowLength, newA, lowLength, highLength - lowLength);\n+      }\n+\n+      return new Double(newA);\n+\n     }\n \n     /** Negate the instance.\n-     */\n-    public void negateSelf() {\n+     * @return a new polynomial\n+     */\n+    public Polynomial negate() {\n+      double[] newA = new double[a.length];\n       for (int i = 0; i < a.length; ++i) {\n-        a[i] = -a[i];\n-      }\n-    }\n-\n-    /** Negate a polynomial.\n-     * @param p polynomial to negate\n-     * @return a new polynomial which is the opposite of p\n-     */\n-    public static Double negate(Double p) {\n-      Double copy = new Double(p);\n-      copy.negateSelf();\n-      return copy;\n+        newA[i] = -a[i];\n+      }\n+      return new Double(newA);\n     }\n \n     /** Multiply the instance by a polynomial.\n      * @param p polynomial to multiply by\n-     */\n-    public void multiplySelf(Double p) {\n+     * @return a new polynomial\n+     */\n+    public Double multiply(Double p) {\n \n       double[] newA = new double[a.length + p.a.length - 1];\n \n       for (int i = 0; i < newA.length; ++i) {\n-        newA[i] = 0;\n+        newA[i] = 0.0;\n         for (int j = Math.max(0, i + 1 - p.a.length);\n              j < Math.min(a.length, i + 1);\n              ++j) {\n         }\n       }\n \n-      a = newA;\n-\n-    }\n-\n-    /** Multiply two polynomials.\n-     * @param p1 first polynomial\n-     * @param p2 second polynomial\n-     * @return a new polynomial which is the product of p1 and p2\n-     */\n-    public static Double multiply(Double p1, Double p2) {\n-      Double copy = new Double(p1);\n-      copy.multiplySelf(p2);\n-      return copy;\n+      return new Double(newA);\n+\n+    }\n+\n+    /** Multiply the instance by a constant.\n+     * @param l constant to multiply by\n+     * @return a new polynomial\n+     */\n+    public Polynomial multiply(long l) {\n+      return multiply((double) l);\n     }\n \n     /** Multiply the instance by a constant.\n      * @param r constant to multiply by\n-     */\n-    public void multiplySelf(double r) {\n-\n-      if (Math.abs(r) < 1.0e-12) {\n-        a = new double[1];\n-        a[0] = 0;\n-      }\n-\n-      for (int i = 0; i < a.length; ++i) {\n-        a[i] *= r;\n-      }\n-\n-    }\n-\n-    /** Multiply a polynomial by a constant.\n-     * @param p polynomial\n-     * @param r constant\n-     * @return a new polynomial which is the product of p and r\n-     */\n-    public static Double multiply(Double p, double r) {\n-      Double copy = new Double(p);\n-      copy.multiplySelf(r);\n-      return copy;\n+     * @return a new polynomial\n+     */\n+    public Polynomial multiply(RationalNumber r) {\n+      return multiply(r.doubleValue());\n     }\n \n     /** Multiply the instance by a constant.\n      * @param r constant to multiply by\n-     */\n-    public void multiplySelf(RationalNumber r) {\n-\n-      if (r.isZero()) {\n-        a = new double[1];\n-        a[0] = 0;\n-      }\n-\n-      double rValue = r.doubleValue();\n+     * @return a new polynomial\n+     */\n+    public Polynomial multiply(double r) {\n+\n+      if (r == 0) {\n+        return new Double(new double[] { 0.0 });\n+      }\n+\n+      double[] newA = new double[a.length];\n       for (int i = 0; i < a.length; ++i) {\n-        a[i] *= rValue;\n-      }\n-\n-    }\n-\n-    /** Multiply the instance by a constant.\n-     * @param l constant to multiply by\n-     */\n-    public void multiplySelf(long l) {\n-\n-      if (l == 0l) {\n-        a = new double[1];\n-        a[0] = 0;\n-      }\n-\n-      for (int i = 0; i < a.length; ++i) {\n-        a[i] *= l;\n-      }\n-\n-    }\n-\n-    /** Multiply a polynomial by a constant.\n-     * @param p polynomial\n-     * @param l constant\n-     * @return a new polynomial which is the product of p and l\n-     */\n-    public static Double multiply(Double p, long l) {\n-      Double copy = new Double(p);\n-      copy.multiplySelf(l);\n-      return copy;\n+        newA[i] = a[i] * r;\n+      }\n+      return new Double(newA);\n+\n     }\n \n     /** Get the value of the polynomial for a specified unknown.\n      * @return a new polynomial which is the derivative of the instance\n      */\n     public Polynomial getDerivative() {\n-      Double derivative = new Double();\n       if (a.length == 1) {\n-        return derivative;\n-      }\n-      derivative.a = new double[a.length - 1];\n+        return new Double();\n+      }\n+      double[] newA = new double[a.length - 1];\n       for (int i = 1; i < a.length; ++i) {\n-        derivative.a[i-1] = a[i] * i;\n-      }\n-      return derivative;\n-    }\n-\n-    /** Set the name of the unknown (to appear during conversions to strings).\n-     * @param name name to set (if null, the default 'x' value  will be used)\n-     */\n-    public void setUnknownName(String name) {\n-      unknown = name;\n+        newA[i - 1] = a[i] * i;\n+      }\n+      return new Double(newA);\n     }\n \n     /** Returns a string representation of the polynomial.\n     * but <code>1 - 3 x + x^2</code> if the negative coefficient is not\n     * the first one displayed).</p>\n \n-    * <p>The name of the unknown is <code>x</code> by default, but can\n-    * be changed using the {@link #setUnknownName setUnknownName}\n-    * method.</p>\n-\n     * @return a string representation of the polynomial\n \n     */\n     public String toString() {\n \n-      double maxCoeff = 0;\n-      for (int i = 0; i < a.length; ++i) {\n-        double abs = Math.abs(a[i]);\n-        if (abs > maxCoeff) {\n-          maxCoeff = abs;\n-        }\n-      }\n-      double epsilon = 1.0e-12 * maxCoeff;\n-\n       StringBuffer s = new StringBuffer();\n-      if (Math.abs(a[0]) <= epsilon) {\n+      if (a[0] == 0.0) {\n         if (a.length == 1) {\n           return \"0\";\n         }\n       } else {\n-        s.append(a[0]);\n+        s.append(java.lang.Double.toString(a[0]));\n       }\n \n       for (int i = 1; i < a.length; ++i) {\n \n-        if (Math.abs(a[i]) > epsilon) {\n+        if (a[i] != 0) {\n \n           if (s.length() > 0) {\n             if (a[i] < 0) {\n           }\n \n           double absAi = Math.abs(a[i]);\n-          if (Math.abs(absAi - 1) > 1.0e-12) {\n-            s.append(absAi);\n+          if ((absAi - 1) != 0) {\n+            s.append(java.lang.Double.toString(absAi));\n             s.append(' ');\n           }\n \n-          s.append((unknown == null) ? defaultUnknown : unknown);\n+          s.append(\"x\");\n           if (i > 1) {\n             s.append('^');\n             s.append(Integer.toString(i));\n     /** Coefficients array. */\n     protected double[] a;\n \n-    /** Name of the unknown. */\n-    protected String unknown;\n-\n-    private static final long serialVersionUID = -5907669461605191069L;\n+    private static final long serialVersionUID = -4210522025715687648L;\n \n   }\n \n-  /** Default name of unknowns. */\n-  protected static String defaultUnknown = new String(\"x\");\n-\n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/PolynomialFraction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/PolynomialFraction.java\n \n package org.spaceroots.mantissa.algebra;\n \n+import java.io.Serializable;\n import java.math.BigInteger;\n \n /**\n  * This class implements fractions of polynomials with one unknown and\n  * rational coefficients.\n+ * <p>Instances of this class are immutable.</p>\n \n  * @version $Id: PolynomialFraction.java 1705 2006-09-17 19:57:39Z luc $\n  * @author L. Maisonobe\n \n  */\n \n-public class PolynomialFraction {\n+public class PolynomialFraction implements Serializable {\n \n   /**\n    * Simple constructor.\n    * Build a constant null fraction\n    */\n   public PolynomialFraction() {\n-    this(new Polynomial.Rational(new RationalNumber(0l)),\n-         new Polynomial.Rational(new RationalNumber(1l)));\n+    this(new Polynomial.Rational(RationalNumber.ZERO),\n+         new Polynomial.Rational(RationalNumber.ONE));\n   }\n \n   /**\n    * @exception ArithmeticException if the denominator is null\n    */\n   public PolynomialFraction(long numerator, long denominator) {\n-    this(new Polynomial.Rational(new RationalNumber(numerator)),\n-         new Polynomial.Rational(new RationalNumber(denominator)));\n+    this(new Polynomial.Rational(numerator),\n+         new Polynomial.Rational(denominator));\n   }\n \n   /**\n       throw new ArithmeticException(\"null denominator\");\n     }\n \n-    p = new Polynomial.Rational(numerator);\n-    q = new Polynomial.Rational(denominator);\n+    p = numerator;\n+    q = denominator;\n \n     RationalNumber[] a = q.getCoefficients();\n     if (a[a.length - 1].isNegative()) {\n-      p.negateSelf();\n-      q.negateSelf();\n+      p = (Polynomial.Rational) p.negate();\n+      q = (Polynomial.Rational) q.negate();\n     }\n \n     simplify();\n \n   }\n \n-  /**\n-   * Simple constructor.\n+  /** Simple constructor.\n    * Build a fraction from a single integer\n    * @param l value of the fraction\n    */\n     this(i, BigInteger.ONE);\n   }\n \n-  /**\n-   * Simple constructor.\n+  /** Simple constructor.\n    * Build a fraction from a single rational number\n    * @param r value of the fraction\n    */\n     this(r.getNumerator(), r.getDenominator());\n   }\n \n-  /**\n-   * Simple constructor.\n-   * Build a fraction from a single Polynom\n+  /** Simple constructor.\n+   * Build a fraction from a single Polynomial\n    * @param p value of the fraction\n    */\n   public PolynomialFraction(Polynomial.Rational p) {\n-    this(p, new Polynomial.Rational(new RationalNumber(1l)));\n-  }\n-\n-  /**\n-   * Copy-constructor.\n-   * @param f fraction to copy\n-   */\n-  public PolynomialFraction(PolynomialFraction f) {\n-    p = new Polynomial.Rational(f.p);\n-    q = new Polynomial.Rational(f.q);\n-  }\n-\n-  /**\n-   * Negate the instance\n-   */\n-  public void negateSelf() {\n-    p.negateSelf();\n-  }\n-\n-  /**\n-   * Negate a fraction.\n-   * @param f fraction to negate\n-   * @return a new fraction which is the opposite of f\n-   */\n-  public static PolynomialFraction negate(PolynomialFraction f) {\n-    PolynomialFraction copy = new PolynomialFraction(f);\n-    copy.negateSelf();\n-    return copy;\n-  }\n-\n-  /**\n-   * Add a fraction to the instance.\n-   * @param f fraction to add.\n-   */\n-  public void addToSelf(PolynomialFraction f) {\n-    PolynomialFraction sum = add(this, f);\n-    p = sum.p;\n-    q = sum.q;\n-  }\n-\n-  /** Add two fractions.\n-   * @param f1 first fraction\n-   * @param f2 second fraction\n-   * @return a new fraction which is the sum of f1 and f2\n-   */\n-  public static PolynomialFraction add(PolynomialFraction f1,\n-                                       PolynomialFraction f2) {\n-    Polynomial.Rational num =\n-      Polynomial.Rational.add(Polynomial.Rational.multiply(f1.p, f2.q),\n-                              Polynomial.Rational.multiply(f2.p, f1.q));\n-    Polynomial.Rational den = Polynomial.Rational.multiply(f1.q, f2.q);\n-    return new PolynomialFraction(num, den);\n-  }\n-\n-  /**\n-   * Subtract a fraction to the instance.\n-   * @param f fraction to subtract.\n-   */\n-  public void subtractFromSelf(PolynomialFraction f) {\n-    PolynomialFraction diff = subtract(this, f);\n-    p = diff.p;\n-    q = diff.q;\n-  }\n-\n-  /** Subtract two fractions.\n-   * @param f1 first fraction\n-   * @param f2 second fraction\n-   * @return a new fraction which is the difference f1 minus f2\n-   */\n-  public static PolynomialFraction subtract(PolynomialFraction f1,\n-                                            PolynomialFraction f2) {\n-    Polynomial.Rational num =\n-      Polynomial.Rational.subtract(Polynomial.Rational.multiply(f1.p, f2.q),\n-                                   Polynomial.Rational.multiply(f2.p, f1.q));\n-    Polynomial.Rational den = Polynomial.Rational.multiply(f1.q, f2.q);\n-    return new PolynomialFraction(num, den);\n-  }\n-\n-  /** Multiply the instance by a fraction.\n-   * @param f fraction to multiply by\n-   */\n-  public void multiplySelf(PolynomialFraction f) {\n-    p.multiplySelf(f.p);\n-    q.multiplySelf(f.q);\n-    simplify();\n-  }\n-\n-  /** Multiply two fractions.\n-   * @param f1 first fraction\n-   * @param f2 second fraction\n-   * @return a new fraction which is the product of f1 and f2\n-   */\n-  public static PolynomialFraction multiply(PolynomialFraction f1,\n-                                            PolynomialFraction f2) {\n-    PolynomialFraction copy = new PolynomialFraction(f1);\n-    copy.multiplySelf(f2);\n-    return copy;\n-  }\n-\n-  /** Divide the instance by a fraction.\n-   * @param f fraction to divide by\n+    this(p, new Polynomial.Rational(1l));\n+  }\n+\n+  /** Negate the instance.\n+   * @return a new polynomial fraction opposite to the instance\n+   */\n+  public PolynomialFraction negate() {\n+    return new PolynomialFraction((Polynomial.Rational) p.negate(), q);\n+  }\n+\n+  /** Add a polynomial fraction to the instance.\n+   * @param f polynomial fraction to add.\n+   * @return a new polynomial fraction\n+   */\n+  public PolynomialFraction add(PolynomialFraction f) {\n+    return new PolynomialFraction(p.multiply(f.q).add(f.p.multiply(q)),\n+                                  q.multiply(f.q));\n+  }\n+\n+  /** Subtract a fraction from the instance.\n+   * @param f polynomial fraction to subtract.\n+   * @return a new polynomial fraction\n+   */\n+  public PolynomialFraction subtract(PolynomialFraction f) {\n+    return new PolynomialFraction(p.multiply(f.q).subtract(f.p.multiply(q)),\n+                                  q.multiply(f.q));\n+  }\n+\n+  /** Multiply the instance by a polynomial fraction.\n+   * @param f polynomial fraction to multiply by\n+   * @return a new polynomial fraction\n+   */\n+  public PolynomialFraction multiply(PolynomialFraction f) {\n+    PolynomialFraction product =\n+      new PolynomialFraction(p.multiply(f.p), q.multiply(f.q));\n+    product.simplify();\n+    return product;\n+  }\n+\n+  /** Divide the instance by a polynomial fraction.\n+   * @param f polynomial fraction to divide by\n+   * @return a new polynomial fraction\n    * @exception ArithmeticException if f is null\n    */\n-  public void divideSelf(PolynomialFraction f) {\n+  public PolynomialFraction divide(PolynomialFraction f) {\n \n     if (f.p.isZero()) {\n       throw new ArithmeticException(\"divide by zero\");\n     }\n \n-    p.multiplySelf(f.q);\n-    q.multiplySelf(f.p);\n-\n-    RationalNumber[] a = q.getCoefficients();\n+    Polynomial.Rational newP = p.multiply(f.q);\n+    Polynomial.Rational newQ = q.multiply(f.p);\n+\n+    RationalNumber[] a = newQ.getCoefficients();\n     if (a[a.length - 1].isNegative()) {\n-      p.negateSelf();\n-      q.negateSelf();\n-    }\n-\n-    simplify();\n-\n-  }\n-\n-  /** Divide two fractions.\n-   * @param f1 first fraction\n-   * @param f2 second fraction\n-   * @return a new fraction which is the quotient of f1 by f2\n-   */\n-  public static PolynomialFraction divide(PolynomialFraction f1,\n-                                          PolynomialFraction f2) {\n-    PolynomialFraction copy = new PolynomialFraction(f1);\n-    copy.divideSelf(f2);\n-    return copy;\n+      newP = (Polynomial.Rational) newP.negate();\n+      newQ = (Polynomial.Rational) newQ.negate();\n+    }\n+\n+    PolynomialFraction result = new PolynomialFraction(newP, newQ);\n+    result.simplify();\n+    return result;\n+\n   }\n \n   /** Invert the instance.\n-   * Replace the instance by its inverse.\n-   * @exception ArithmeticException if the instance is null\n-   */\n-  public void invertSelf() {\n+   * @return the inverse of the instance\n+   * @exception ArithmeticException if the instance is zero\n+   */\n+  public PolynomialFraction invert() {\n \n     if (p.isZero()) {\n       throw new ArithmeticException(\"divide by zero\");\n     }\n \n-    Polynomial.Rational tmp = p;\n-    p = q;\n-    q = tmp;\n-\n-    RationalNumber[] a = q.getCoefficients();\n-    if (a[a.length - 1].isNegative()) {\n-      p.negateSelf();\n-      q.negateSelf();\n-    }\n-\n-    simplify();\n-\n-  }\n-\n-  /** Invert a fraction.\n-   * @param f fraction to invert\n-   * @return a new fraction which is the inverse of f\n-   */\n-  public static PolynomialFraction invert(PolynomialFraction f) {\n-    PolynomialFraction copy = new PolynomialFraction(f);\n-    copy.invertSelf();\n-    return copy;\n+    RationalNumber[] a = p.getCoefficients();\n+    PolynomialFraction inverse =\n+      (a[a.length - 1].isNegative())\n+      ? new PolynomialFraction((Polynomial.Rational) q.negate(),\n+                               (Polynomial.Rational) p.negate())\n+      : new PolynomialFraction(q, p);\n+    inverse.simplify();\n+    return inverse;\n+\n   }\n \n   /** Simplify a fraction.\n    */\n   private void simplify() {\n \n-    Polynomial.Rational a = new Polynomial.Rational(p);\n-    Polynomial.Rational b = new Polynomial.Rational(q);\n+    Polynomial.Rational a = p;\n+    Polynomial.Rational b = q;\n     if (a.getDegree() < b.getDegree()) {\n       Polynomial.Rational tmp = a;\n       a = b;\n \n     if (q.getDegree() == 0) {\n       if (! q.isOne()) {\n-        RationalNumber f = q.getCoefficients()[0];\n-        f.invertSelf();\n-        p.multiplySelf(f);\n+        p = (Polynomial.Rational) p.divide(q.getCoefficients()[0]);\n         q = new Polynomial.Rational(1l);\n       }\n     } else {\n \n       BigInteger lcm = p.getDenominatorsLCM();\n       if (lcm.compareTo(BigInteger.ONE) != 0) {\n-        p.multiplySelf(lcm);\n-        q.multiplySelf(lcm);\n+        p = (Polynomial.Rational) p.multiply(lcm);\n+        q = (Polynomial.Rational) q.multiply(lcm);\n       }\n \n       lcm = q.getDenominatorsLCM();\n       if (lcm.compareTo(BigInteger.ONE) != 0) {\n-        p.multiplySelf(lcm);\n-        q.multiplySelf(lcm);\n+        p = (Polynomial.Rational) p.multiply(lcm);\n+        q = (Polynomial.Rational) q.multiply(lcm);\n       }\n \n     }\n \n     if (q.getCoefficients()[q.getDegree()].isNegative()) {\n-      p.negateSelf();\n-      q.negateSelf();\n+      p = (Polynomial.Rational) p.negate();\n+      q = (Polynomial.Rational) q.negate();\n     }\n \n   }\n    */\n   public Polynomial.Rational getDenominator() {\n     return q;\n-  }\n-\n-  /** Set the name of the unknown (to appear during conversions to\n-   * strings).\n-   * @param name name to set (if null, the default 'x' value will be\n-   * used)\n-   */\n-  public void setUnknownName(String name) {\n-    p.setUnknownName(name);\n-    q.setUnknownName(name);\n   }\n \n   public String toString() {\n   /** Denominator. */\n   private Polynomial.Rational q;\n \n+  private static final long serialVersionUID = 6033909492898954748L;\n+\n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/RationalNumber.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/RationalNumber.java\n \n package org.spaceroots.mantissa.algebra;\n \n+import java.io.Serializable;\n import java.math.BigInteger;\n+\n /**\n  * This class implements reduced rational numbers.\n+ * <p>Instances of this class are immutable.</p>\n \n  * @version $Id: RationalNumber.java 1705 2006-09-17 19:57:39Z luc $\n  * @author L. Maisonobe\n \n  */\n \n-public class RationalNumber {\n+public class RationalNumber implements Serializable {\n+\n+  /** Zero as a rational numer. */\n+  public static final RationalNumber ZERO = new RationalNumber(0l);\n+\n+  /** One as a rational numer. */\n+  public static final RationalNumber ONE  = new RationalNumber(1l);\n \n   /**\n    * Simple constructor.\n     q = BigInteger.ONE;\n   }\n \n-  /**\n-   * Simple constructor.\n+  /** Simple constructor.\n    * Build a rational number from a numerator and a denominator.\n    * @param numerator numerator of the rational number\n    * @param denominator denominator of the rational number\n    * @exception ArithmeticException if the denominator is zero\n    */\n   public RationalNumber(long numerator, long denominator) {\n-    reset(numerator, denominator);\n-  }\n-\n-  /**\n-   * Simple constructor.\n+\n+    if (denominator == 0l) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    p = BigInteger.valueOf(numerator);\n+    q = BigInteger.valueOf(denominator);\n+\n+    if (q.signum() < 0) {\n+      p = p.negate();\n+      q = q.negate();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Simple constructor.\n    * Build a rational number from a numerator and a denominator.\n    * @param numerator numerator of the rational number\n    * @param denominator denominator of the rational number\n    * @exception ArithmeticException if the denominator is zero\n    */\n   public RationalNumber(BigInteger numerator, BigInteger denominator) {\n-    reset(numerator, denominator);\n-  }\n-\n-  /**\n-   * Simple constructor.\n+\n+    if (denominator.signum() == 0) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    p = numerator;\n+    q = denominator;\n+\n+    if (q.signum() < 0) {\n+      p = p.negate();\n+      q = q.negate();\n+    }\n+\n+    simplify();\n+\n+  }\n+\n+  /** Simple constructor.\n    * Build a rational number from a single integer\n    * @param l value of the rational number\n    */\n     q = BigInteger.ONE;\n   }\n \n-  /**\n-   * Simple constructor.\n+  /** Simple constructor.\n    * Build a rational number from a single integer\n    * @param i value of the rational number\n    */\n     q = BigInteger.ONE;\n   }\n \n-  /**\n-   * Copy-constructor.\n-   * @param r rational number to copy\n-   */\n-  public RationalNumber(RationalNumber r) {\n-    p = r.p;\n-    q = r.q;\n-  }\n-\n-  /** Reset the instance from a numerator and a denominator.\n-   * @param numerator numerator of the rational number\n-   * @param denominator denominator of the rational number\n-   * @exception ArithmeticException if the denominator is zero\n-   */\n-  public void reset(long numerator, long denominator) {\n-    if (denominator == 0l) {\n-      throw new ArithmeticException(\"divide by zero\");\n-    }\n-\n-    p = BigInteger.valueOf(numerator);\n-    q = BigInteger.valueOf(denominator);\n-\n-    if (q.signum() < 0) {\n-      p = p.negate();\n-      q = q.negate();\n-    }\n-\n-    simplify();\n-\n-  }\n-\n-  /** Reset the instance from a numerator and a denominator.\n-   * @param numerator numerator of the rational number\n-   * @param denominator denominator of the rational number\n-   * @exception ArithmeticException if the denominator is zero\n-   */\n-  public void reset(BigInteger numerator, BigInteger denominator) {\n-    if (denominator.signum() == 0) {\n-      throw new ArithmeticException(\"divide by zero\");\n-    }\n-\n-    p = numerator;\n-    q = denominator;\n-\n-    if (q.signum() < 0) {\n-      p = p.negate();\n-      q = q.negate();\n-    }\n-\n-    simplify();\n-\n-  }\n-\n-  /** Reset the instance from a single integer\n-   * @param l value of the rational number\n-   */\n-  public void reset(long l) {\n-    p = BigInteger.valueOf(l);\n-    q = BigInteger.ONE;\n-  }\n-\n-  /** Reset the instance from a single integer\n-   * @param i value of the rational number\n-   */\n-  public void reset(BigInteger i) {\n-    p = i;\n-    q = BigInteger.ONE;\n-  }\n-\n-  /** Reset the instance from another rational number.\n-   * @param r rational number to copy\n-   */\n-  public void reset(RationalNumber r) {\n-    p = r.p;\n-    q = r.q;\n-  }\n-\n-  /**\n-   * Negate the instance\n-   */\n-  public void negateSelf() {\n-    p = p.negate();\n-  }\n-\n-  /**\n-   * Negate a rational number.\n-   * @param r rational number to negate\n-   * @return a new rational number which is the opposite of r\n-   */\n-  public static RationalNumber negate(RationalNumber r) {\n-    RationalNumber copy = new RationalNumber(r);\n-    copy.negateSelf();\n-    return copy;\n-  }\n-\n-  /**\n-   * Add a rational number to the instance.\n-   * @param r rational number to add.\n-   */\n-  public void addToSelf(RationalNumber r) {\n-    p = p.multiply(r.q).add(r.p.multiply(q));\n-    q = q.multiply(r.q);\n-    simplify();\n-  }\n-\n-  /** Add two rational numbers.\n-   * @param r1 first rational number\n-   * @param r2 second rational number\n-   * @return a new rational number which is the sum of r1 and r2\n-   */\n-  public static RationalNumber add(RationalNumber r1, RationalNumber r2) {\n-    return new RationalNumber(r1.p.multiply(r2.q).add(r2.p.multiply(r1.q)),\n-                              r1.q.multiply(r2.q));\n-  }\n-\n-  /**\n-   * Subtract a rational number to the instance.\n-   * @param r rational number to subtract.\n-   */\n-  public void subtractFromSelf(RationalNumber r) {\n-    p = p.multiply(r.q).subtract(r.p.multiply(q));\n-    q = q.multiply(r.q);\n-    simplify();\n-  }\n-\n-  /** Subtract two rational numbers.\n-   * @param r1 first rational number\n-   * @param r2 second rational number\n-   * @return a new rational number which is the difference r1 minus r2\n-   */\n-  public static RationalNumber subtract(RationalNumber r1, RationalNumber r2) {\n-    return new RationalNumber(r1.p.multiply(r2.q).subtract(r2.p.multiply(r1.q)),\n-                              r1.q.multiply(r2.q));\n+  /** Negate the instance.\n+   * @return a new rational number, opposite to the isntance\n+   */\n+  public RationalNumber negate() {\n+    return new RationalNumber(p.negate(), q);\n+  }\n+\n+  /** Add an integer to the instance.\n+   * @param l integer to add\n+   * @return a new rational number which is the sum of the instance and l\n+   */\n+  public RationalNumber add(long l) {\n+    return add(BigInteger.valueOf(l));\n+  }\n+\n+  /** Add an integer to the instance.\n+   * @param l integer to add\n+   * @return a new rational number which is the sum of the instance and l\n+   */\n+  public RationalNumber add(BigInteger l) {\n+    return new RationalNumber(p.add(q.multiply(l)), q);\n+  }\n+\n+  /** Add a rational number to the instance.\n+   * @param r rational number to add\n+   * @return a new rational number which is the sum of the instance and r\n+   */\n+  public RationalNumber add(RationalNumber r) {\n+    return new RationalNumber(p.multiply(r.q).add(r.p.multiply(q)),\n+                              q.multiply(r.q));\n+  }\n+\n+  /** Subtract an integer from the instance.\n+   * @param l integer to subtract\n+   * @return a new rational number which is the difference the instance minus l\n+   */\n+  public RationalNumber subtract(long l) {\n+    return subtract(BigInteger.valueOf(l));\n+  }\n+\n+  /** Subtract an integer from the instance.\n+   * @param l integer to subtract\n+   * @return a new rational number which is the difference the instance minus l\n+   */\n+  public RationalNumber subtract(BigInteger l) {\n+    return new RationalNumber(p.subtract(q.multiply(l)), q);\n+  }\n+\n+  /** Subtract a rational number from the instance.\n+   * @param r rational number to subtract\n+   * @return a new rational number which is the difference the instance minus r\n+   */\n+  public RationalNumber subtract(RationalNumber r) {\n+    return new RationalNumber(p.multiply(r.q).subtract(r.p.multiply(q)),\n+                              q.multiply(r.q));\n   }\n \n   /** Multiply the instance by an integer.\n    * @param l integer to multiply by\n-   */\n-  public void multiplySelf(long l) {\n-    p = p.multiply(BigInteger.valueOf(l));\n-    simplify();\n+   * @return a new rational number which is the produc of the instance by l\n+   */\n+  public RationalNumber multiply(long l) {\n+    return multiply(BigInteger.valueOf(l));\n   }\n \n   /** Multiply the instance by an integer.\n-   * @param i integer to multiply by\n-   */\n-  public void multiplySelf(BigInteger i) {\n-    p = p.multiply(i);\n-    simplify();\n-  }\n-\n-  /** Multiply a rational number by an integer.\n    * @param l integer to multiply by\n-   */\n-  public static RationalNumber multiply(RationalNumber r, long l) {\n-    return new RationalNumber(r.p.multiply(BigInteger.valueOf(l)), r.q);\n-  }\n-\n-  /** Multiply a rational number by an integer.\n-   * @param i integer to multiply by\n-   */\n-  public static RationalNumber multiply(RationalNumber r, BigInteger i) {\n-    return new RationalNumber(r.p.multiply(i), r.q);\n+   * @return a new rational number which is the produc of the instance by l\n+   */\n+  public RationalNumber multiply(BigInteger l) {\n+    return new RationalNumber(p.multiply(l), q);\n   }\n \n   /** Multiply the instance by a rational number.\n-   * @param r rational number to multiply by\n-   */\n-  public void multiplySelf(RationalNumber r) {\n-    p = p.multiply(r.p);\n-    q = q.multiply(r.q);\n-    simplify();\n-  }\n-\n-  /** Multiply two rational numbers.\n-   * @param r1 first rational number\n-   * @param r2 second rational number\n-   * @return a new rational number which is the product of r1 and r2\n-   */\n-  public static RationalNumber multiply(RationalNumber r1, RationalNumber r2) {\n-    return new RationalNumber(r1.p.multiply(r2.p),\n-                              r1.q.multiply(r2.q));\n+   * @param r rational number to multiply the instance with\n+   * @return a new rational number which is the product of the instance and r\n+   */\n+  public RationalNumber multiply(RationalNumber r) {\n+    return new RationalNumber(p.multiply(r.p), q.multiply(r.q));\n   }\n \n   /** Divide the instance by an integer.\n    * @param l integer to divide by\n+   * @return a new rational number which is the quotient of the instance by l\n    * @exception ArithmeticException if l is zero\n    */\n-  public void divideSelf(long l) {\n-\n-    if (l == 0l) {\n-      throw new ArithmeticException(\"divide by zero\");\n-    } else if (l > 0l) {\n-      q = q.multiply(BigInteger.valueOf(l));\n-    } else {\n-      p = p.negate();\n-      q = q.multiply(BigInteger.valueOf(-l));\n-    }\n-\n-    simplify();\n-\n+  public RationalNumber divide(long l) {\n+    return divide(BigInteger.valueOf(l));\n   }\n \n   /** Divide the instance by an integer.\n-   * @param i integer to divide by\n+   * @param l integer to divide by\n+   * @return a new rational number which is the quotient of the instance by l\n    * @exception ArithmeticException if l is zero\n    */\n-  public void divideSelf(BigInteger i) {\n-\n-    if (i.signum() == 0) {\n-      throw new ArithmeticException(\"divide by zero\");\n-    } else if (i.signum() > 0) {\n-      q = q.multiply(i);\n-    } else {\n-      p = p.negate();\n-      q = q.multiply(i.negate());\n-    }\n-\n-    simplify();\n-\n-  }\n-\n-  /** Divide a rational number by an integer\n-   * @param r rational number\n-   * @param l integer\n-   * @return a new rational number which is the quotient of r by l\n-   * @exception ArithmeticException if l is zero\n-   */\n-  public static RationalNumber divide(RationalNumber r, long l) {\n-    RationalNumber copy = new RationalNumber(r);\n-    copy.divideSelf(l);\n-    return copy;\n-  }\n-\n-  /** Divide a rational number by an integer\n-   * @param r rational number\n-   * @param i integer\n-   * @return a new rational number which is the quotient of r by l\n-   * @exception ArithmeticException if l is zero\n-   */\n-  public static RationalNumber divide(RationalNumber r, BigInteger i) {\n-    RationalNumber copy = new RationalNumber(r);\n-    copy.divideSelf(i);\n-    return copy;\n+  public RationalNumber divide(BigInteger l) {\n+\n+    if (l.signum() == 0) {\n+      throw new ArithmeticException(\"divide by zero\");\n+    }\n+\n+    if (l.signum() > 0) {\n+      return new RationalNumber(p, q.multiply(l));\n+    }\n+\n+    return new RationalNumber(p.negate(), q.multiply(l.negate()));\n+\n   }\n \n   /** Divide the instance by a rational number.\n    * @param r rational number to divide by\n+   * @return a new rational number which is the quotient of the instance by r\n    * @exception ArithmeticException if r is zero\n    */\n-  public void divideSelf(RationalNumber r) {\n+  public RationalNumber divide(RationalNumber r) {\n \n     if (r.p.signum() == 0) {\n       throw new ArithmeticException(\"divide by zero\");\n     }\n \n-    p = p.multiply(r.q);\n-    q = q.multiply(r.p);\n-\n-    if (q.signum() < 0) {\n-      p = p.negate();\n-      q = q.negate();\n-    }\n-\n-    simplify();\n-\n-  }\n-\n-  /** Divide two rational numbers.\n-   * @param r1 first rational number\n-   * @param r2 second rational number\n-   * @return a new rational number which is the quotient of r1 by r2\n-   * @exception ArithmeticException if r2 is zero\n-   */\n-  public static RationalNumber divide(RationalNumber r1, RationalNumber r2) {\n-    RationalNumber copy = new RationalNumber(r1);\n-    copy.divideSelf(r2);\n-    return copy;\n+    BigInteger newP = p.multiply(r.q);\n+    BigInteger newQ = q.multiply(r.p);\n+\n+    return (newQ.signum() < 0) ? new RationalNumber(newP.negate(),\n+                                                    newQ.negate())\n+                               : new RationalNumber(newP, newQ);\n+\n   }\n \n   /** Invert the instance.\n-   * Replace the instance by its inverse.\n+   * @return the inverse of the instance\n    * @exception ArithmeticException if the instance is zero\n    */\n-  public void invertSelf() {\n+  public RationalNumber invert() {\n \n     if (p.signum() == 0) {\n       throw new ArithmeticException(\"divide by zero\");\n     }\n \n-    BigInteger tmp = p;\n-    p = q;\n-    q = tmp;\n-\n-    if (q.signum() < 0) {\n-      p = p.negate();\n-      q = q.negate();\n-    }\n-\n-  }\n-\n-  /** Invert a rational number.\n-   * @param r rational number to invert\n-   * @return a new rational number which is the inverse of r\n-   * @exception ArithmeticException if r is zero\n-   */\n-  public static RationalNumber invert(RationalNumber r) {\n-    return new RationalNumber(r.q, r.p);\n-  }\n-\n-  /**\n-   * Add the product of two rational numbers to the instance.\n-   * This operation is equivalent to\n-   * <code>addToSelf(RationalNumber.multiply(r1, r2))</code> except\n-   * that no intermediate simplification is attempted.\n-   * @param r1 first term of the product to add\n-   * @param r2 second term of the product to add\n-   */\n-  public void multiplyAndAddToSelf(RationalNumber r1, RationalNumber r2) {\n-    BigInteger r1qr2q = r1.q.multiply(r2.q);\n-    p = p.multiply(r1qr2q).add(r1.p.multiply(r2.p).multiply(q));\n-    q = q.multiply(r1qr2q);\n-    simplify();\n-  }\n-\n-  /**\n-   * Subtract the product of two rational numbers from the instance.\n-   * This operation is equivalent to\n-   * <code>subtractFromSelf(RationalNumber.multiply(r1, r2))</code>\n-   * except that no intermediate simplification is attempted.\n-   * @param r1 first term of the product to subtract\n-   * @param r2 second term of the product to subtract\n-   */\n-  public void multiplyAndSubtractFromSelf(RationalNumber r1, RationalNumber r2) {\n-    BigInteger r1qr2q = r1.q.multiply(r2.q);\n-    p = p.multiply(r1qr2q).subtract(r1.p.multiply(r2.p).multiply(q));\n-    q = q.multiply(r1qr2q);\n-    simplify();\n+    return (q.signum() < 0) ? new RationalNumber(q.negate(), p.negate())\n+                            : new RationalNumber(q, p);\n+\n   }\n \n   /** Simplify a rational number by removing common factors.\n     }\n   }\n \n-  /**\n-   * Get the numerator.\n+  /** Get the numerator.\n    * @return the signed numerator\n    */\n   public BigInteger getNumerator() {\n     return p;\n   }\n \n-  /**\n-   * Get the denominator.\n+  /** Get the denominator.\n    * @return the denominator (always positive)\n    */\n   public BigInteger getDenominator() {\n   /** Denominator. */\n   private BigInteger q;\n \n+  private static final long serialVersionUID = -324954393137577531L;\n+\n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/AbstractCurveFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/AbstractCurveFitter.java\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Iterator;\n \n import org.spaceroots.mantissa.estimation.*;\n \n public abstract class AbstractCurveFitter\n   implements EstimationProblem, Serializable {\n \n-  /**\n-   * Simple constructor.\n+  /** Simple constructor.\n    * @param n number of coefficients in the underlying function\n-   * @param maxIterations maximum number of iterations allowed\n-   * @param convergence criterion threshold below which we do not need\n-   * to improve the criterion anymore\n-   * @param steadyStateThreshold steady state detection threshold, the\n-   * problem has reached a steady state (read converged) if\n-   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n-   * <code>Jn</code> and <code>Jn-1</code> are the current and\n-   * preceding criterion value (square sum of the weighted residuals\n-   * of considered measurements).\n-   * @param epsilon threshold under which the matrix of the linearized\n-   * problem is considered singular (see {@link\n-   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n-   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n-   */\n-  protected AbstractCurveFitter(int n,\n-                                int maxIterations,\n-                                double convergence,\n-                                double steadyStateThreshold,\n-                                double epsilon) {\n-\n-    coefficients              = new EstimatedParameter[n];\n-    measurements              = new ArrayList();\n-    measurementsArray         = null;\n-    this.maxIterations        = maxIterations;\n-    this.steadyStateThreshold = steadyStateThreshold;\n-    this.convergence          = convergence;\n-    this.epsilon              = epsilon;\n-\n-  }\n-\n-  /**\n-   * Simple constructor.\n+   * @param estimator estimator to use for the fitting\n+   */\n+  protected AbstractCurveFitter(int n, Estimator estimator) {\n+\n+    coefficients   = new EstimatedParameter[n];\n+    measurements   = new ArrayList();\n+    this.estimator = estimator;\n+  }\n+\n+  /** Simple constructor.\n    * @param coefficients first estimate of the coefficients. A\n    * reference to this array is hold by the newly created object. Its\n    * elements will be adjusted during the fitting process and they will\n    * be set to the adjusted coefficients at the end.\n-   * @param maxIterations maximum number of iterations allowed\n-   * @param convergence criterion threshold below which we do not need\n-   * to improve the criterion anymore\n-   * @param steadyStateThreshold steady state detection threshold, the\n-   * problem has reached a steady state (read converged) if\n-   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n-   * <code>Jn</code> and <code>Jn-1</code> are the current and\n-   * preceding criterion value (square sum of the weighted residuals\n-   * of considered measurements).\n-   * @param epsilon threshold under which the matrix of the linearized\n-   * problem is considered singular (see {@link\n-   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n-   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+   * @param estimator estimator to use for the fitting\n    */\n   protected AbstractCurveFitter(EstimatedParameter[] coefficients,\n-                                int maxIterations,\n-                                double convergence,\n-                                double steadyStateThreshold,\n-                                double epsilon) {\n-\n-    this.coefficients         = coefficients;\n-    measurements              = new ArrayList();\n-    measurementsArray         = null;\n-    this.maxIterations        = maxIterations;\n-    this.steadyStateThreshold = steadyStateThreshold;\n-    this.convergence          = convergence;\n-    this.epsilon              = epsilon;\n+                                Estimator estimator) {\n+\n+    this.coefficients = coefficients;\n+    measurements      = new ArrayList();\n+    this.estimator     = estimator;\n   }\n \n   /** Add a weighted (x,y) pair to the sample.\n    * @param y      ordinate, we have <code>y = f (x)</code>\n    */\n   public void addWeightedPair(double weight, double x, double y) {\n-    measurementsArray = null;\n     measurements.add(new FitMeasurement(weight, x, y));\n   }\n \n    */\n   public double[] fit()\n     throws EstimationException {\n-    // perform the fit using a linear least square estimator\n-    new GaussNewtonEstimator(maxIterations, convergence,\n-                             steadyStateThreshold, epsilon).estimate(this);\n+    // perform the fit\n+    estimator.estimate(this);\n \n     // extract the coefficients\n     double[] fittedCoefficients = new double[coefficients.length];\n   }\n \n   public WeightedMeasurement[] getMeasurements() {\n-    if (measurementsArray == null) {\n-      measurementsArray = new FitMeasurement[measurements.size()];\n-      int i = 0;\n-      for (Iterator iterator = measurements.iterator(); iterator.hasNext(); ++i) {\n-        measurementsArray[i] = (FitMeasurement) iterator.next();\n-      }\n-    }\n-    return measurementsArray;\n+    return (WeightedMeasurement[]) measurements.toArray(new FitMeasurement[measurements.size()]);\n   }\n \n   /** Get the unbound parameters of the problem.\n    * @return unbound parameters\n    */\n   public EstimatedParameter[] getUnboundParameters() {\n-   return coefficients;\n+   return (EstimatedParameter[]) coefficients.clone();\n   }\n \n   /** Get all the parameters of the problem.\n    * @return parameters\n    */\n   public EstimatedParameter[] getAllParameters() {\n-   return coefficients;\n+   return (EstimatedParameter[]) coefficients.clone();\n   }\n \n   /** Utility method to sort the measurements with respect to the abscissa.\n       }\n     }\n \n-    // make sure subsequent calls to getMeasurements\n-    // will not use the unsorted array\n-    measurementsArray = null;\n-\n   }\n \n   /** Get the value of the function at x according to the current parameters value.\n   /** Measurements vector */\n   protected List measurements;\n \n-  /** Measurements array.\n-   * This array contains the same entries as measurements_, but in a\n-   * different structure.\n-   */\n-  private FitMeasurement[] measurementsArray;\n-\n-  private int    maxIterations;\n-  private double convergence;\n-  private double steadyStateThreshold;\n-  private double epsilon;\n+  /** Estimator for the fitting problem. */\n+  private Estimator estimator;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/F2FP2Iterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/F2FP2Iterator.java\n \n     // get the raw values from the underlying FFPIterator\n     VectorialValuedPair point = ffpIterator.nextSamplePoint();\n+    double[] y = point.y;\n \n-    // hack the values (to avoid building a new object)\n-    double[] y = point.getY();\n-    y[0] *= y[0];\n-    y[1] *= y[1];\n-    return point;\n+    // square the values\n+    return new VectorialValuedPair(point.x,\n+                                   new double[] {\n+                                     y[0] * y[0], y[1] * y[1]             \n+                                   });\n \n   }\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicCoefficientsGuesser.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicCoefficientsGuesser.java\n \n  * <p>The algorithm used to guess the coefficients is as follows:</p>\n \n- * <p>We know f (t) at some sampling points ti and want to find a,\n- * omega and phi such that f (t) = a cos (omega t + phi).\n+ * <p>We know f (t) at some sampling points t<sub>i</sub> and want to find a,\n+ * &omega; and &phi; such that f (t) = a cos (&omega; t + &phi;).\n  * </p>\n  *\n  * <p>From the analytical expression, we can compute two primitives :\n  * <pre>\n- *     If2  (t) = int (f^2)  = a^2 * [t + S (t)] / 2\n- *     If'2 (t) = int (f'^2) = a^2 * omega^2 * [t - S (t)] / 2\n- *     where S (t) = sin (2 * (omega * t + phi)) / (2 * omega)\n+ *     If2  (t) = &int; f<sup>2</sup>  = a<sup>2</sup> &times; [t + S (t)] / 2\n+ *     If'2 (t) = &int; f'<sup>2</sup> = a<sup>2</sup> &omega;<sup>2</sup> &times; [t - S (t)] / 2\n+ *     where S (t) = sin (2 (&omega; t + &phi;)) / (2 &omega;)\n  * </pre>\n  * </p>\n  *\n  * <p>We can remove S between these expressions :\n  * <pre>\n- *     If'2 (t) = a^2 * omega ^ 2 * t - omega ^ 2 * If2 (t)\n+ *     If'2 (t) = a<sup>2</sup> &omega;<sup>2</sup> t - &omega;<sup>2</sup> If2 (t)\n  * </pre>\n  * </p>\n  *\n  * <p>The preceding expression shows that If'2 (t) is a linear\n- * combination of both t and If2 (t): If'2 (t) = A * t + B * If2 (t)\n+ * combination of both t and If2 (t): If'2 (t) = A &times; t + B &times; If2 (t)\n  * </p>\n  *\n  * <p>From the primitive, we can deduce the same form for definite\n- * integrals between t1 and ti for each ti :\n- * <pre>\n- *   If2 (ti) - If2 (t1) = A * (ti - t1) + B * (If2 (ti) - If2 (t1))\n+ * integrals between t<sub>1</sub> and t<sub>i</sub> for each t<sub>i</sub> :\n+ * <pre>\n+ *   If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>) = A &times; (t<sub>i</sub> - t<sub>1</sub>) + B &times; (If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>))\n  * </pre>\n  * </p>\n  *\n  * each sample points.\n  * </p>\n  *\n- * <p>For a bilinear expression z (xi, yi) = A * xi + B * yi, the\n- * coefficients a and b that minimize a least square criterion\n- * Sum ((zi - z (xi, yi))^2) are given by these expressions:</p>\n- * <pre>\n- *\n- *         Sum (yi^2) Sum (xi zi) - Sum (xi yi) Sum (yi zi)\n- *     A = ------------------------------------------------\n- *         Sum (xi^2) Sum (yi^2)  - Sum (xi yi) Sum (xi yi)\n- *\n- *         Sum (xi^2) Sum (yi zi) - Sum (xi yi) Sum (xi zi)\n- *     B = ------------------------------------------------\n- *         Sum (xi^2) Sum (yi^2)  - Sum (xi yi) Sum (xi yi)\n- * </pre>\n- * </p>\n- *\n- *\n- * <p>In fact, we can assume both a and omega are positive and\n- * compute them directly, knowing that A = a^2 * omega^2 and that\n- * B = - omega^2. The complete algorithm is therefore:</p>\n- * <pre>\n- *\n- * for each ti from t1 to t(n-1), compute:\n- *   f  (ti)\n- *   f' (ti) = (f (t(i+1)) - f(t(i-1))) / (t(i+1) - t(i-1))\n- *   xi = ti - t1\n- *   yi = int (f^2) from t1 to ti\n- *   zi = int (f'^2) from t1 to ti\n- *   update the sums Sum (xi^2), Sum (yi^2),\n- *                   Sum (xi yi), Sum (xi zi)\n- *                   and Sum (yi zi)\n+ * <p>For a bilinear expression z (x<sub>i</sub>, y<sub>i</sub>) = A &times; x<sub>i</sub> + B &times; y<sub>i</sub>, the\n+ * coefficients A and B that minimize a least square criterion\n+ * &sum; (z<sub>i</sub> - z (x<sub>i</sub>, y<sub>i</sub>))<sup>2</sup> are given by these expressions:</p>\n+ * <pre>\n+ *\n+ *         &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ *     A = ------------------------\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ *\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub>\n+ *     B = ------------------------\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ * </pre>\n+ * </p>\n+ *\n+ *\n+ * <p>In fact, we can assume both a and &omega; are positive and\n+ * compute them directly, knowing that A = a<sup>2</sup> &omega;<sup>2</sup> and that\n+ * B = - &omega;<sup>2</sup>. The complete algorithm is therefore:</p>\n+ * <pre>\n+ *\n+ * for each t<sub>i</sub> from t<sub>1</sub> to t<sub>n-1</sub>, compute:\n+ *   f  (t<sub>i</sub>)\n+ *   f' (t<sub>i</sub>) = (f (t<sub>i+1</sub>) - f(t<sub>i-1</sub>)) / (t<sub>i+1</sub> - t<sub>i-1</sub>)\n+ *   x<sub>i</sub> = t<sub>i</sub> - t<sub>1</sub>\n+ *   y<sub>i</sub> = &int; f<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+ *   z<sub>i</sub> = &int; f'<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+ *   update the sums &sum;x<sub>i</sub>x<sub>i</sub>, &sum;y<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>z<sub>i</sub> and &sum;y<sub>i</sub>z<sub>i</sub>\n  * end for\n  *\n- *            |-------------------------------------------------\n- *         \\  | Sum (yi^2) Sum (xi zi) - Sum (xi yi) Sum (yi zi)\n- * a     =  \\ | ------------------------------------------------\n- *           \\| Sum (xi yi) Sum (xi zi) - Sum (xi^2) Sum (yi zi)\n- *\n- *\n- *            |-------------------------------------------------\n- *         \\  | Sum (xi yi) Sum (xi zi) - Sum (xi^2) Sum (yi zi)\n- * omega =  \\ | ------------------------------------------------\n- *           \\| Sum (xi^2) Sum (yi^2)  - Sum (xi yi) Sum (xi yi)\n- *\n- * </pre>\n- * </p>\n-\n- * <p>Once we know omega, we can compute:\n- * <pre>\n- *    fc = omega * f (t) * cos (omega * t) - f' (t) * sin (omega * t)\n- *    fs = omega * f (t) * sin (omega * t) + f' (t) * cos (omega * t)\n- * </pre>\n- * </p>\n-\n- * <p>It appears that <code>fc = a * omega * cos (phi)</code> and\n- * <code>fs = -a * omega * sin (phi)</code>, so we can use these\n- * expressions to compute phi. The best estimate over the sample is\n+ *            |--------------------------\n+ *         \\  | &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ * a     =  \\ | ------------------------\n+ *           \\| &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ *\n+ *\n+ *            |--------------------------\n+ *         \\  | &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ * &omega;     =  \\ | ------------------------\n+ *           \\| &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ *\n+ * </pre>\n+ * </p>\n+\n+ * <p>Once we know &omega;, we can compute:\n+ * <pre>\n+ *    fc = &omega; f (t) cos (&omega; t) - f' (t) sin (&omega; t)\n+ *    fs = &omega; f (t) sin (&omega; t) + f' (t) cos (&omega; t)\n+ * </pre>\n+ * </p>\n+\n+ * <p>It appears that <code>fc = a &omega; cos (&phi;)</code> and\n+ * <code>fs = -a &omega; sin (&phi;)</code>, so we can use these\n+ * expressions to compute &phi;. The best estimate over the sample is\n  * given by averaging these expressions.\n  * </p>\n \n   implements Serializable{\n \n   public HarmonicCoefficientsGuesser(AbstractCurveFitter.FitMeasurement[] measurements) {\n-    this.measurements = measurements;\n+    this.measurements =\n+      (AbstractCurveFitter.FitMeasurement[]) measurements.clone();\n     a                 = Double.NaN;\n     omega             = Double.NaN;\n   }\n     guessPhi();\n   }\n \n-  /** Estimate a first guess of the a and omega coefficients.\n+  /** Estimate a first guess of the a and &omega; coefficients.\n \n    * @exception ExhaustedSampleException if the sample is exhausted.\n \n     SampledFunctionIterator sampler =\n       new EnhancedSimpsonIntegratorSampler(iter);\n     VectorialValuedPair p0 = sampler.nextSamplePoint();\n-    double   p0X = p0.getX();\n-    double[] p0Y = p0.getY();\n+    double   p0X = p0.x;\n+    double[] p0Y = p0.y;\n \n     // get the points for the linear model\n     while (sampler.hasNext()) {\n \n       VectorialValuedPair point = sampler.nextSamplePoint();\n-      double   pX = point.getX();\n-      double[] pY = point.getY();\n-\n-      double dx  = pX    - p0X;\n-      double dy0 = pY[0] - p0Y[0];\n-      double dy1 = pY[1] - p0Y[1];\n-\n-      sx2 += dx  * dx;\n-      sy2 += dy0 * dy0;\n-      sxy += dx  * dy0;\n-      sxz += dx  * dy1;\n-      syz += dy0 * dy1;\n+      double   pX = point.x;\n+      double[] pY = point.y;\n+\n+      double x = pX    - p0X;\n+      double y = pY[0] - p0Y[0];\n+      double z = pY[1] - p0Y[1];\n+\n+      sx2 += x * x;\n+      sy2 += y * y;\n+      sxy += x * y;\n+      sxz += x * z;\n+      syz += y * z;\n \n     }\n \n \n   }\n \n-  /** Estimate a first guess of the phi coefficient.\n+  /** Estimate a first guess of the &phi; coefficient.\n \n    * @exception ExhaustedSampleException if the sample is exhausted.\n \n \n     while (iter.hasNext()) {\n       VectorialValuedPair point = iter.nextSamplePoint();\n-      double   omegaX = omega * point.getX();\n-      double[] pY     = point.getY();\n+      double   omegaX = omega * point.x;\n       double   cosine = Math.cos(omegaX);\n       double   sine   = Math.sin(omegaX);\n-      fcMean += omega * pY[0] * cosine - pY[1] *   sine;\n-      fsMean += omega * pY[0] *   sine + pY[1] * cosine;\n+      fcMean += omega * point.y[0] * cosine - point.y[1] *   sine;\n+      fsMean += omega * point.y[0] *   sine + point.y[1] * cosine;\n     }\n \n     phi = Math.atan2(-fsMean, fcMean);\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicFitter.java\n \n package org.spaceroots.mantissa.fitting;\n \n-import java.io.Serializable;\n-\n-import org.spaceroots.mantissa.estimation.*;\n+import org.spaceroots.mantissa.estimation.EstimatedParameter;\n+import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.Estimator;\n+import org.spaceroots.mantissa.estimation.GaussNewtonEstimator;\n import org.spaceroots.mantissa.functions.ExhaustedSampleException;\n import org.spaceroots.mantissa.functions.FunctionException;\n \n  */\n \n public class HarmonicFitter\n-  extends AbstractCurveFitter\n-  implements EstimationProblem, Serializable {\n+  extends AbstractCurveFitter {\n+\n+  /** Simple constructor.\n+   * @param estimator estimator to use for the fitting\n+   */\n+  public HarmonicFitter(Estimator estimator) {\n+    super(3, estimator);\n+    coefficients[0]  = new EstimatedParameter(\"a\", 2.0 * Math.PI);\n+    coefficients[1]  = new EstimatedParameter(\"omega\", 0.0);\n+    coefficients[2]  = new EstimatedParameter(\"phi\", 0.0);\n+    firstGuessNeeded = true;\n+  }\n+\n+  /**\n+   * Simple constructor.\n+\n+   * <p>This constructor can be used when a first estimate of the\n+   * coefficients is already known.</p>\n+\n+   * @param coefficients first estimate of the coefficients.\n+   * A reference to this array is hold by the newly created\n+   * object. Its elements will be adjusted during the fitting process\n+   * and they will be set to the adjusted coefficients at the end.\n+   * @param estimator estimator to use for the fitting\n+\n+   */\n+  public HarmonicFitter(EstimatedParameter[] coefficients,\n+                        Estimator estimator) {\n+    super(coefficients, estimator);\n+    firstGuessNeeded = false;\n+  }\n \n   /**\n    * Simple constructor.\n    * problem is considered singular (see {@link\n    * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n    * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n+   * @deprecated replaced by {@link #HarmonicFitter(Estimator)}\n+   * as of version 7.0\n    */\n   public HarmonicFitter(int maxIterations, double convergence,\n                         double steadyStateThreshold, double epsilon) {\n-    super(3, maxIterations, convergence, steadyStateThreshold, epsilon);\n-    coefficients[0]  = new EstimatedParameter(\"a\", 2.0 * Math.PI);\n-    coefficients[1]  = new EstimatedParameter(\"omega\", 0.0);\n-    coefficients[2]  = new EstimatedParameter(\"phi\", 0.0);\n-    firstGuessNeeded = true;\n+    this(new GaussNewtonEstimator(maxIterations, convergence,\n+                                   steadyStateThreshold, epsilon));\n   }\n \n   /**\n    * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n    * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n \n+   * @deprecated replaced by {@link #HarmonicFitter(EstimatedParameter[],\n+   * Estimator)} as of version 7.0\n    */\n   public HarmonicFitter(EstimatedParameter[] coefficients,\n                         int maxIterations, double convergence,\n                         double steadyStateThreshold, double epsilon) {\n-    super(coefficients,\n-          maxIterations, convergence,\n-          steadyStateThreshold, epsilon);\n-    firstGuessNeeded = false;\n+    this(coefficients,\n+          new GaussNewtonEstimator(maxIterations, convergence,\n+                                   steadyStateThreshold, epsilon));\n   }\n \n   public double[] fit()\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialFitter.java\n \n package org.spaceroots.mantissa.fitting;\n \n-import java.io.Serializable;\n-\n-import org.spaceroots.mantissa.estimation.*;\n+import org.spaceroots.mantissa.estimation.EstimatedParameter;\n+import org.spaceroots.mantissa.estimation.Estimator;\n+import org.spaceroots.mantissa.estimation.GaussNewtonEstimator;\n \n /** This class implements a curve fitting specialized for polynomials.\n \n  */\n \n public class PolynomialFitter\n-  extends AbstractCurveFitter\n-  implements EstimationProblem, Serializable {\n+  extends AbstractCurveFitter {\n \n-  /**\n-   * Simple constructor.\n+  /** Simple constructor.\n+\n+   * <p>The polynomial fitter built this way are complete polynoms,\n+   * ie. a n-degree polynom has n+1 coefficients. In order to build\n+   * fitter for sparse polynoms (for example <code>a x^20 - b\n+   * x^30</code>, on should first build the coefficients array and\n+   * provide it to {@link\n+   * #PolynomialFitter(PolynomialCoefficient[], int, double, double,\n+   * double)}.</p>\n+   * @param degree maximal degree of the polynom\n+   * @param estimator estimator to use for the fitting\n+   */\n+  public PolynomialFitter(int degree, Estimator estimator) {\n+    super(degree + 1, estimator);\n+    for (int i = 0; i < coefficients.length; ++i) {\n+      coefficients[i] = new PolynomialCoefficient(i);\n+    }\n+  }\n+\n+  /** Simple constructor.\n+\n+   * <p>This constructor can be used either when a first estimate of\n+   * the coefficients is already known (which is of little interest\n+   * because the fit cost is the same whether a first guess is known or\n+   * not) or when one needs to handle sparse polynoms like <code>a\n+   * x^20 - b x^30</code>.</p>\n+\n+   * @param coefficients first estimate of the coefficients.\n+   * A reference to this array is hold by the newly created\n+   * object. Its elements will be adjusted during the fitting process\n+   * and they will be set to the adjusted coefficients at the end.\n+   * @param estimator estimator to use for the fitting\n+   */\n+  public PolynomialFitter(PolynomialCoefficient[] coefficients,\n+                          Estimator estimator) {\n+    super(coefficients, estimator);\n+  }\n+\n+  /** Simple constructor.\n \n    * <p>The polynomial fitter built this way are complete polynoms,\n    * ie. a n-degree polynom has n+1 coefficients. In order to build\n    * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n    * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n  \n+   * @deprecated replaced by {@link #PolynomialFitter(int,Estimator)}\n+   * as of version 7.0\n    */\n   public PolynomialFitter(int degree,\n                           int maxIterations, double convergence,\n                           double steadyStateThreshold, double epsilon) {\n-\n-    super(degree + 1,\n-          maxIterations, steadyStateThreshold,\n-          convergence, epsilon);\n-\n-    for (int i = 0; i < coefficients.length; ++i) {\n-      coefficients[i] = new PolynomialCoefficient(i);\n-    }\n-\n+    this(degree,\n+         new GaussNewtonEstimator(maxIterations, steadyStateThreshold,\n+                                  convergence, epsilon));\n   }\n \n-  /**\n-   * Simple constructor.\n+  /** Simple constructor.\n \n    * <p>This constructor can be used either when a first estimate of\n    * the coefficients is already known (which is of little interest\n    * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n    * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n \n+   * @deprecated replaced by {@link #PolynomialFitter(PolynomialCoefficient[],\n+   * Estimator)} as of version 7.0\n    */\n   public PolynomialFitter(PolynomialCoefficient[] coefficients,\n                           int maxIterations, double convergence,\n                           double steadyStateThreshold, double epsilon) {\n-    super(coefficients,\n-          maxIterations, steadyStateThreshold,\n-          convergence, epsilon);\n+    this(coefficients,\n+         new GaussNewtonEstimator(maxIterations, steadyStateThreshold,\n+                                  convergence, epsilon));\n   }\n \n   /** Get the value of the function at x according to the current parameters value.\n    * @return partial derivative\n    */\n   public double partial(double x, EstimatedParameter p) {\n-    return Math.pow(x, ((PolynomialCoefficient) p).degree);\n+    if (p instanceof PolynomialCoefficient) {\n+      return Math.pow(x, ((PolynomialCoefficient) p).degree);\n+    }\n+    throw new RuntimeException(\"internal error\");\n   }\n \n-  private static final long serialVersionUID = -226724596015163603L;\n+  private static final long serialVersionUID = -744904084649890769L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunction.java\n // under the License.\n \n package org.spaceroots.mantissa.functions.scalar;\n+\n+import java.io.Serializable;\n \n import org.spaceroots.mantissa.functions.FunctionException;\n \n  * @author L. Maisonobe\n \n  */\n-public interface ComputableFunction {\n+public interface ComputableFunction extends Serializable {\n \n   /** Get the value of the function at the specified abscissa.\n    * @param x current abscissa\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunction.java\n // under the License.\n \n package org.spaceroots.mantissa.functions.scalar;\n+\n+import java.io.Serializable;\n \n import org.spaceroots.mantissa.functions.FunctionException;\n \n  * @author L. Maisonobe\n \n  */\n-public interface SampledFunction {\n+public interface SampledFunction extends Serializable {\n \n   /** Get the number of points in the sample.\n    * @return number of points in the sample\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunction.java\n // under the License.\n \n package org.spaceroots.mantissa.functions.vectorial;\n+\n+import java.io.Serializable;\n \n import org.spaceroots.mantissa.functions.FunctionException;\n \n  * @author L. Maisonobe\n \n  */\n-public interface ComputableFunction {\n+public interface ComputableFunction extends Serializable {\n   /** Get the dimension of the vectorial values of the function.\n    * @return dimension\n    */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunction.java\n // under the License.\n \n package org.spaceroots.mantissa.functions.vectorial;\n+\n+import java.io.Serializable;\n \n import org.spaceroots.mantissa.functions.FunctionException;\n \n  * @author L. Maisonobe\n \n  */\n-public interface SampledFunction {\n+public interface SampledFunction extends Serializable {\n \n   /** Get the number of points in the sample.\n    * @return number of points in the sample\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPair.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPair.java\n /** This class represents an (x, f(x)) pair for vectorial functions.\n \n  * <p>A vectorial function is a function of one vectorial parameter x whose\n- * value is a vector. This class is used has a simple placeholder to\n+ * value is a vector. This class is used has a simple immutable placeholder to\n  * contain both an abscissa and the value of the function at this\n  * abscissa.</p>\n \n    */\n   public VectorialValuedPair(double x, double[] y) {\n     this.x = x;\n-    this.y = y;\n-  }\n-\n-  /**\n-   * Copy-constructor.\n-   * @param p point to copy\n-   */\n-  public VectorialValuedPair(VectorialValuedPair p) {\n-    x = p.x;\n-    y = p.y;\n-  }\n-\n-  /**\n-   * Getter for the abscissa.\n-   * @return value of the abscissa\n-   */\n-  public double getX() {\n-    return x;\n-  }\n-\n-  /**\n-   * Getter for the ordinate.\n-   * @return value of the ordinate\n-   */\n-  public double[] getY() {\n-    return y;\n-  }\n-\n-  /**\n-   * Setter for the abscissa.\n-   * @param x new value for the abscissa\n-   */\n-  public void setX(double x) {\n-    this.x = x;\n-  }\n-\n-  /**\n-   * Setter for the ordinate.\n-   * @param y new value for the ordinate\n-   */\n-  public void setY(double[] y) {\n-    this.y = y;\n+    this.y = (double[]) y.clone();\n   }\n \n   /** Abscissa of the point. */\n-  private double x;\n+  public final double x;\n \n   /** Vectorial ordinate of the point, y = f (x). */\n-  private double[] y;\n+  public final double[] y;\n \n-  private static final long serialVersionUID = -1336411215846160578L;\n+  private static final long serialVersionUID = -7397116933564410103L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/geometry/Rotation.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/Rotation.java\n  * <code>Rotation</code> instance (see the various constructors and\n  * getters). In addition, a rotation can also be built implicitely\n  * from a set of vectors and their image.</p>\n- * <p>This implies that this class can be used to transform one\n- * representation into another one. For example, converting a rotation\n+ * <p>This implies that this class can be used to convert from one\n+ * representation to another one. For example, converting a rotation\n  * matrix into a set of Cardan angles from can be done using the\n  * followong single line of code:</p>\n  * <pre>\n    * <p>Beware that many people routinely use the term Euler angles even\n    * for what really are Cardan angles (this confusion is especially\n    * widespread in the aerospace business where Roll, Pitch and Yaw angles\n-   * are often tagged as Euler angles).</p>\n+   * are often wrongly tagged as Euler angles).</p>\n \n    * @param order order of rotations to use\n    * @param alpha1 angle of the first elementary rotation\n    */\n   public Rotation(RotationOrder order,\n                   double alpha1, double alpha2, double alpha3) {\n-    this(computeRotation(order, alpha1, alpha2, alpha3));\n-  }\n-\n-  /** Copy constructor.\n-   * <p>This constructor is used only for the sake of Cardan/Euler\n-   * angles handling.</p>\n-   * @param r rotation to copy\n-   */\n-  private Rotation(Rotation r) {\n-    q0 = r.q0;\n-    q1 = r.q1;\n-    q2 = r.q2;\n-    q3 = r.q3;\n-  }\n-\n-  /** Build a rotation from three Cardan or Euler elementary rotations.\n-   * @param order order of rotations to use\n-   * @param alpha1 angle of the first elementary rotation\n-   * @param alpha2 angle of the second elementary rotation\n-   * @param alpha3 angle of the third elementary rotation\n-   */\n-  public static Rotation computeRotation(RotationOrder order,\n-                                         double alpha1,\n-                                         double alpha2,\n-                                         double alpha3) {\n-    if (order == RotationOrder.XYZ) {\n-      return compose(new Rotation(Vector3D.plusI, alpha1),\n-                     new Rotation(Vector3D.plusJ, alpha2),\n-                     new Rotation(Vector3D.plusK, alpha3));\n-    } else if (order == RotationOrder.XZY) {\n-      return compose(new Rotation(Vector3D.plusI, alpha1),\n-                     new Rotation(Vector3D.plusK, alpha2),\n-                     new Rotation(Vector3D.plusJ, alpha3));\n-    } else if (order == RotationOrder.YXZ) {\n-      return compose(new Rotation(Vector3D.plusJ, alpha1),\n-                     new Rotation(Vector3D.plusI, alpha2),\n-                     new Rotation(Vector3D.plusK, alpha3));\n-    } else if (order == RotationOrder.YZX) {\n-      return compose(new Rotation(Vector3D.plusJ, alpha1),\n-                     new Rotation(Vector3D.plusK, alpha2),\n-                     new Rotation(Vector3D.plusI, alpha3));\n-    } else if (order == RotationOrder.ZXY) {\n-      return compose(new Rotation(Vector3D.plusK, alpha1),\n-                     new Rotation(Vector3D.plusI, alpha2),\n-                     new Rotation(Vector3D.plusJ, alpha3));\n-    } else if (order == RotationOrder.ZYX) {\n-     return compose(new Rotation(Vector3D.plusK, alpha1),\n-                    new Rotation(Vector3D.plusJ, alpha2),\n-                    new Rotation(Vector3D.plusI, alpha3));\n-    } else if (order == RotationOrder.XYX) {\n-     return compose(new Rotation(Vector3D.plusI, alpha1),\n-                    new Rotation(Vector3D.plusJ, alpha2),\n-                    new Rotation(Vector3D.plusI, alpha3));\n-    } else if (order == RotationOrder.XZX) {\n-     return compose(new Rotation(Vector3D.plusI, alpha1),\n-                    new Rotation(Vector3D.plusK, alpha2),\n-                    new Rotation(Vector3D.plusI, alpha3));\n-    } else if (order == RotationOrder.YXY) {\n-     return compose(new Rotation(Vector3D.plusJ, alpha1),\n-                    new Rotation(Vector3D.plusI, alpha2),\n-                    new Rotation(Vector3D.plusJ, alpha3));\n-    } else if (order == RotationOrder.YZY) {\n-     return compose(new Rotation(Vector3D.plusJ, alpha1),\n-                    new Rotation(Vector3D.plusK, alpha2),\n-                    new Rotation(Vector3D.plusJ, alpha3));\n-    } else if (order == RotationOrder.ZXZ) {\n-     return compose(new Rotation(Vector3D.plusK, alpha1),\n-                    new Rotation(Vector3D.plusI, alpha2),\n-                    new Rotation(Vector3D.plusK, alpha3));\n-    } else { // last possibility is ZYZ\n-     return compose(new Rotation(Vector3D.plusK, alpha1),\n-                    new Rotation(Vector3D.plusJ, alpha2),\n-                    new Rotation(Vector3D.plusK, alpha3));\n-    }\n-  }\n-\n-  /** Override the instance by the composition of three rotations.\n-   * @param r3 last (outermost) rotation to compose\n-   * @param r2 intermediate rotation to compose\n-   * @param r1 first (innermost) rotation to compose\n-   */\n-  private static Rotation compose(Rotation r3, Rotation r2, Rotation r1) {\n-    return r3.applyTo(r2.applyTo(r1));\n+    Rotation r1 = new Rotation(order.getA1(), alpha1);\n+    Rotation r2 = new Rotation(order.getA2(), alpha2);\n+    Rotation r3 = new Rotation(order.getA3(), alpha3);\n+    Rotation composed = r1.applyTo(r2.applyTo(r3));\n+    q0 = composed.q0;\n+    q1 = composed.q1;\n+    q2 = composed.q2;\n+    q3 = composed.q3;\n   }\n \n   /** Revert a rotation.\n    * Build a rotation which reverse the effect of another\n-   * rotation. This means that is r(u) = v, then r.revert (v) = u. The\n+   * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n    * instance is not changed.\n    * @return a new rotation whose effect is the reverse of the effect\n    * of the instance\n   /** Third coordinate of the vectorial part of the quaternion. */\n   private final double q3;\n \n-  private static final long serialVersionUID = 7264384082212242475L;\n+  private static final long serialVersionUID = 5127795878493115119L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/geometry/RotationOrder.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/RotationOrder.java\n    * This is a utility class that cannot be instantiated by the user,\n    * so its only constructor is private.\n    * @param name name of the rotation order\n+   * @param a1 axis of the first rotation\n+   * @param a2 axis of the second rotation\n+   * @param a3 axis of the third rotation\n    */\n-  private RotationOrder(String name) {\n+  private RotationOrder(String name,\n+                        Vector3D a1, Vector3D a2, Vector3D a3) {\n     this.name = name;\n+    this.a1   = a1;\n+    this.a2   = a2;\n+    this.a3   = a3;\n   }\n \n   /** Get a string representation of the instance.\n     return name;\n   }\n \n+  /** Get the axis of the first rotation.\n+   * @return axis of the first rotation\n+   */\n+  public Vector3D getA1() {\n+    return a1;\n+  }\n+\n+  /** Get the axis of the second rotation.\n+   * @return axis of the second rotation\n+   */\n+  public Vector3D getA2() {\n+    return a2;\n+  }\n+\n+  /** Get the axis of the second rotation.\n+   * @return axis of the second rotation\n+   */\n+  public Vector3D getA3() {\n+    return a3;\n+  }\n+\n   /** Set of Cardan angles.\n    * this ordered set of rotations is around X, then around Y, then\n    * around Z\n    */\n-  public static final RotationOrder XYZ = new RotationOrder(\"XYZ\");\n+  public static final RotationOrder XYZ =\n+    new RotationOrder(\"XYZ\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around X, then around Z, then\n    * around Y\n    */\n-  public static final RotationOrder XZY = new RotationOrder(\"XZY\");\n+  public static final RotationOrder XZY =\n+    new RotationOrder(\"XZY\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Y, then around X, then\n    * around Z\n    */\n-  public static final RotationOrder YXZ = new RotationOrder(\"YXZ\");\n+  public static final RotationOrder YXZ =\n+    new RotationOrder(\"YXZ\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Y, then around Z, then\n    * around X\n    */\n-  public static final RotationOrder YZX = new RotationOrder(\"YZX\");\n+  public static final RotationOrder YZX =\n+    new RotationOrder(\"YZX\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Z, then around X, then\n    * around Y\n    */\n-  public static final RotationOrder ZXY = new RotationOrder(\"ZXY\");\n+  public static final RotationOrder ZXY =\n+    new RotationOrder(\"ZXY\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Z, then around Y, then\n    * around X\n    */\n-  public static final RotationOrder ZYX = new RotationOrder(\"ZYX\");\n+  public static final RotationOrder ZYX =\n+    new RotationOrder(\"ZYX\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around X, then around Y, then\n    * around X\n    */\n-  public static final RotationOrder XYX = new RotationOrder(\"XYX\");\n+  public static final RotationOrder XYX =\n+    new RotationOrder(\"XYX\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around X, then around Z, then\n    * around X\n    */\n-  public static final RotationOrder XZX = new RotationOrder(\"XZX\");\n+  public static final RotationOrder XZX =\n+    new RotationOrder(\"XZX\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Y, then around X, then\n    * around Y\n    */\n-  public static final RotationOrder YXY = new RotationOrder(\"YXY\");\n+  public static final RotationOrder YXY =\n+    new RotationOrder(\"YXY\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Y, then around Z, then\n    * around Y\n    */\n-  public static final RotationOrder YZY = new RotationOrder(\"YZY\");\n+  public static final RotationOrder YZY =\n+    new RotationOrder(\"YZY\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Z, then around X, then\n    * around Z\n    */\n-  public static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\");\n+  public static final RotationOrder ZXZ =\n+    new RotationOrder(\"ZXZ\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Z, then around Y, then\n    * around Z\n    */\n-  public static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\");\n+  public static final RotationOrder ZYZ =\n+    new RotationOrder(\"ZYZ\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);\n \n   /** Name of the rotations order. */\n   private final String name;\n \n+  /** Axis of the first rotation. */\n+  private final Vector3D a1;\n+\n+  /** Axis of the second rotation. */\n+  private final Vector3D a2;\n+\n+  /** Axis of the third rotation. */\n+  private final Vector3D a3;\n+\n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/geometry/Vector3D.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/Vector3D.java\n \n import java.io.Serializable;\n \n-\n /** This class implements vectors in a three-dimensional space.\n- * <p>Vector3D are guaranteed to be immutable objects.</p>\n- * @version $Id: Vector3D.java 1705 2006-09-17 19:57:39Z luc $\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ * @version $Id: Vector3D.java 1716 2006-12-13 22:56:35Z luc $\n  * @author L. Maisonobe\n  */\n-public class Vector3D implements Serializable {\n+\n+public class Vector3D\n+  implements Serializable {\n \n   /** First canonical vector (coordinates : 1, 0, 0). */\n   public static final Vector3D plusI = new Vector3D(1, 0, 0);\n   /** Third canonical vector (coordinates : 0, 0, 1). */\n   public static final Vector3D plusK = new Vector3D(0, 0, 1);\n \n-  /** Opposite of the third canonical vector (coordinates : 0, 0, -1). */\n+  /** Opposite of the third canonical vector (coordinates : 0, 0, -1).  */\n   public static final Vector3D minusK = new Vector3D(0, 0, -1);\n \n   /** Simple constructor.\n \n   /** Linear constructor\n    * Build a vector from two other ones and corresponding scale factors.\n-   * The vector built will be a * u +  b * v\n-   * @param a first scale factor\n-   * @param u first base (unscaled) vector\n-   * @param b second scale factor\n-   * @param v second base (unscaled) vector\n-   */\n-  public Vector3D(double a, Vector3D u, double b, Vector3D v) {\n-    this.x = a * u.x + b * v.x;\n-    this.y = a * u.y + b * v.y;\n-    this.z = a * u.z + b * v.z;\n+   * The vector built will be a1 * u1 + a2 * u2\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n+    this.x = a1 * u1.x + a2 * u2.x;\n+    this.y = a1 * u1.y + a2 * u2.y;\n+    this.z = a1 * u1.z + a2 * u2.z;\n   }\n \n   /** Linear constructor\n    * Build a vector from three other ones and corresponding scale factors.\n-   * The vector built will be a * u +  b * v + c * w\n-   * @param a first scale factor\n-   * @param u first base (unscaled) vector\n-   * @param b second scale factor\n-   * @param v second base (unscaled) vector\n-   * @param c third scale factor\n-   * @param w third base (unscaled) vector\n-   */\n-  public Vector3D(double a, Vector3D u, double b, Vector3D v,\n-                  double c, Vector3D w) {\n-    this.x = a * u.x + b * v.x + c * w.x;\n-    this.y = a * u.y + b * v.y + c * w.y;\n-    this.z = a * u.z + b * v.z + c * w.z;\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n   }\n \n   /** Linear constructor\n    * Build a vector from four other ones and corresponding scale factors.\n-   * The vector built will be a * t +  b * u + c * v + d * w\n-   * @param a first scale factor\n-   * @param t first base (unscaled) vector\n-   * @param b second scale factor\n-   * @param u second base (unscaled) vector\n-   * @param c third scale factor\n-   * @param v third base (unscaled) vector\n-   * @param d third scale factor\n-   * @param w third base (unscaled) vector\n-   */\n-  public Vector3D(double a, Vector3D t, double b, Vector3D u,\n-                  double c, Vector3D v, double d, Vector3D w) {\n-    this.x = a * t.x + b * u.x + c * v.x + d * w.x;\n-    this.y = a * t.y + b * u.y + c * v.y + d * w.y;\n-    this.z = a * t.z + b * u.z + c * v.z + d * w.z;\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   * @param a4 fourth scale factor\n+   * @param u4 fourth base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3, double a4, Vector3D u4) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n   }\n \n   /** Get the abscissa of the vector.\n    * @return abscissa of the vector\n    * @see #Vector3D(double, double, double)\n-   * @see #setX(double)\n    */\n   public double getX() {\n     return x;\n   /** Get the ordinate of the vector.\n    * @return ordinate of the vector\n    * @see #Vector3D(double, double, double)\n-   * @see #setY(double)\n    */\n   public double getY() {\n     return y;\n   /** Get the height of the vector.\n    * @return height of the vector\n    * @see #Vector3D(double, double, double)\n-   * @see #setZ(double)\n    */\n   public double getZ() {\n     return z;\n     return Math.asin(z / getNorm());\n   }\n \n-  /** Normalize a vector.\n-    * @param v vector to normalize\n-   * @return a new vector equal to v / ||v||\n-   * @exception ArithmeticException if the norm of the instance is null\n-   */\n-  public static Vector3D normalize(Vector3D v) {\n-    double norm = v.getNorm();\n-    if (norm == 0) {\n+  /** Add a vector to the instance.\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(Vector3D v) {\n+    return new Vector3D(x + v.x, y + v.y, z + v.z);\n+  }\n+\n+  /** Add a scaled vector to the instance.\n+   * @param factor scale factor to apply to v before adding it\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(double factor, Vector3D v) {\n+    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n+  }\n+\n+  /** Subtract a vector from the instance.\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(Vector3D v) {\n+    return new Vector3D(x - v.x, y - v.y, z - v.z);\n+  }\n+\n+  /** Subtract a scaled vector from the instance.\n+   * @param factor scale factor to apply to v before subtracting it\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(double factor, Vector3D v) {\n+    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n+  }\n+\n+  /** Normalize the instance.\n+   * @return a new normalized vector\n+   * @exception ArithmeticException if the norm is null\n+   */\n+  public Vector3D normalize() {\n+    double s = getNorm();\n+    if (s == 0) {\n       throw new ArithmeticException(\"null norm\");\n     }\n-    double inv = 1.0 / norm;\n-    return new Vector3D(inv * v.x, inv * v.y, inv * v.z);\n-  }\n-\n-  /** Add two vectors.\n-   * Add two vectors and return the sum as a new vector\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return a new vector equal to v1 + v2\n-   */\n-  public static Vector3D add(Vector3D v1, Vector3D v2) {\n-    return new Vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n-  }\n-\n-  /** Subtract two vectors.\n-   * Subtract two vectors and return the difference as a new vector\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return a new vector equal to v1 - v2\n-   */\n-  public static Vector3D subtract(Vector3D v1, Vector3D v2) {\n-    return new Vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n+    return multiply(1 / s);\n   }\n \n   /** Get a vector orthogonal to the instance.\n    * following example shows how to build a frame having the k axis\n    * aligned with the known vector u :\n    * <pre><code>\n-   *   Vector3D k = Vector3D.normalize(u);\n+   *   Vector3D k = u.normalize();\n    *   Vector3D i = k.orthogonal();\n    *   Vector3D j = Vector3D.crossProduct(k, i);\n    * </code></pre></p>\n \n   }\n \n-  /** Get the opposite of a vector.\n-   * @param u vector to revert\n-   * @return a new vector which is -u\n-   */\n-  public static Vector3D negate(Vector3D u) {\n-    return new Vector3D(-u.x, -u.y, -u.z);\n-  }\n-\n-  /** Multiply a vector by a scalar\n-   * Multiply a vectors by a scalar and return the product as a new vector\n+  /** Get the opposite of the instance.\n+   * @return a new vector which is opposite to the instance\n+   */\n+  public Vector3D negate() {\n+    return new Vector3D(-x, -y, -z);\n+  }\n+\n+  /** Multiply the instance by a scalar\n    * @param a scalar\n-   * @param v vector\n-   * @return a new vector equal to a * v\n-   */\n-  public static Vector3D multiply(double a, Vector3D v) {\n-    return new Vector3D(a * v.x, a * v.y, a * v.z);\n+   * @return a new vector\n+   */\n+  public Vector3D multiply(double a) {\n+    return new Vector3D(a * x, a * y, a * z);\n   }\n \n   /** Compute the dot-product of two vectors.\n   /** Height. */\n   private final double z;\n \n-  private static final long serialVersionUID = 484345009325358136L;\n+  private static final long serialVersionUID = 7318440192750283659L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/DiagonalMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/DiagonalMatrix.java\n \n package org.spaceroots.mantissa.linalg;\n \n-import java.io.Serializable;\n-\n /** This class implements diagonal matrices of linear algebra.\n \n  * @version $Id: DiagonalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n  */\n \n public class DiagonalMatrix\n-  extends SquareMatrix\n-  implements Serializable, Cloneable {\n+  extends SquareMatrix {\n \n   /** Simple constructor.\n    * This constructor builds a diagonal matrix of specified order, all\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralMatrix.java\n \n package org.spaceroots.mantissa.linalg;\n \n-import java.io.Serializable;\n-\n /** This class represents matrices of the most general type.\n \n  * <p>This class is the basic implementation of matrices to use when\n  */\n \n public class GeneralMatrix\n-  extends Matrix\n-  implements Serializable {\n+  extends Matrix {\n \n   /** Simple constructor.\n    * Build a matrix with null elements.\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralSquareMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralSquareMatrix.java\n \n package org.spaceroots.mantissa.linalg;\n \n-import java.io.Serializable;\n-\n /** This class implements general square matrices of linear algebra.\n \n  * @version $Id: GeneralSquareMatrix.java 1705 2006-09-17 19:57:39Z luc $\n  */\n \n public class GeneralSquareMatrix\n-  extends SquareMatrix\n-  implements Serializable, Cloneable {\n+  extends SquareMatrix {\n \n   /** Simple constructor.\n    * This constructor builds a square matrix of specified order, all\n       }\n     }\n \n-    // release the memory as soon as possible\n-    work = null;\n-\n     lower = new LowerTriangularMatrix(rows, lowerData);\n     upper = new UpperTriangularMatrix(rows, upperData);\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/LowerTriangularMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/LowerTriangularMatrix.java\n \n package org.spaceroots.mantissa.linalg;\n \n-import java.io.Serializable;\n-\n /** This class implements lower triangular matrices of linear algebra.\n \n  * @version $Id: LowerTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n  */\n \n public class LowerTriangularMatrix\n-  extends SquareMatrix\n-  implements Serializable, Cloneable {\n+  extends SquareMatrix {\n \n   /** Simple constructor.\n    * This constructor builds a lower triangular matrix of specified order, all\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/Matrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/Matrix.java\n \n     this.rows    = rows;\n     this.columns = columns;\n-    this.data    = data;\n+    this.data    = (data == null) ? null : (double[]) data.clone();\n \n   }\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/NonNullRange.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/NonNullRange.java\n \n  */\n class NonNullRange\n-  implements Serializable, Cloneable {\n+  implements Serializable {\n \n   /** Index in row/column count of the first non-null element. */\n   public final int begin;\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SquareMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SquareMatrix.java\n \n package org.spaceroots.mantissa.linalg;\n \n-import java.io.Serializable;\n-\n /** This class factor all services common to square matrices of linear algebra.\n \n  * <p>This class is the base class of all square matrix\n  */\n \n public abstract class SquareMatrix\n-  extends Matrix\n-  implements Serializable, Cloneable {\n+  extends Matrix {\n   /** Simple constructor.\n    * Build a matrix with null elements.\n    * @param order order of the matrix\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SymetricalMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SymetricalMatrix.java\n \n package org.spaceroots.mantissa.linalg;\n \n-import java.io.Serializable;\n-\n /** This class implements symetrical matrices of linear algebra.\n \n  * @version $Id: SymetricalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n  */\n \n public class SymetricalMatrix\n-  extends GeneralSquareMatrix\n-  implements Serializable, Cloneable {\n+  extends GeneralSquareMatrix {\n \n   /** Simple constructor.\n    * This constructor builds a symetrical matrix of specified order, all\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/UpperTriangularMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/UpperTriangularMatrix.java\n \n package org.spaceroots.mantissa.linalg;\n \n-import java.io.Serializable;\n-\n /** This class implements upper triangular matrices of linear algebra.\n \n  * @version $Id: UpperTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n  */\n \n public class UpperTriangularMatrix\n-  extends SquareMatrix\n-  implements Serializable, Cloneable {\n+  extends SquareMatrix {\n \n   /** Simple constructor.\n    * This constructor builds a upper triangular matrix of specified order, all\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/AbstractStepInterpolator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/AbstractStepInterpolator.java\n     interpolatedTime  = interpolator.interpolatedTime;\n \n     if (interpolator.currentState != null) {\n-      int dimension = interpolator.currentState.length;\n-\n-      currentState = new double[dimension];\n-      System.arraycopy(interpolator.currentState, 0, currentState, 0,\n-                       dimension);\n-\n-      interpolatedState = new double[dimension];\n-      System.arraycopy(interpolator.interpolatedState, 0, interpolatedState, 0,\n-                       dimension);\n+      currentState      = (double[]) interpolator.currentState.clone();\n+      interpolatedState = (double[]) interpolator.interpolatedState.clone();\n     } else {\n       currentState      = null;\n       interpolatedState = null;\n   * @return a copy of the instance.\n \n   */\n-  public abstract Object clone();\n+  public Object clone() {\n+    try {\n+      return super.clone();\n+    } catch (CloneNotSupportedException cnse) {\n+      // should never happen\n+      return null;\n+    }\n+  }\n \n   /** Shift one step forward.\n    * Copy the current time into the previous time, hence preparing the\n    * @return state vector at time {@link #getInterpolatedTime}\n    */\n   public double[] getInterpolatedState() {\n-    return interpolatedState;\n+    return (double[]) interpolatedState.clone();\n   }\n \n \n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaIntegrator.java\n public class ClassicalRungeKuttaIntegrator\n   extends RungeKuttaIntegrator {\n \n-  private static final String methodName = new String(\"classical Runge-Kutta\");\n+  private static final String methodName = \"classical Runge-Kutta\";\n \n   private static final double[] c = {\n     1.0 / 2.0, 1.0 / 2.0, 1.0\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince54Integrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince54Integrator.java\n public class DormandPrince54Integrator\n   extends RungeKuttaFehlbergIntegrator {\n \n-  private static final String methodName = new String(\"Dormand-Prince 5(4)\");\n+  private static final String methodName = \"Dormand-Prince 5(4)\";\n \n   private static final double[] c = {\n     1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince54StepInterpolator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince54StepInterpolator.java\n \n     } else {\n \n-      int dimension = interpolator.v1.length;\n-\n-      v1 = new double[dimension];\n-      v2 = new double[dimension];\n-      v3 = new double[dimension];\n-      v4 = new double[dimension];\n-\n-      System.arraycopy(interpolator.v1, 0, v1, 0, dimension);\n-      System.arraycopy(interpolator.v2, 0, v2, 0, dimension);\n-      System.arraycopy(interpolator.v3, 0, v3, 0, dimension);\n-      System.arraycopy(interpolator.v4, 0, v4, 0, dimension);\n-\n+      v1 = (double[]) interpolator.v1.clone();\n+      v2 = (double[]) interpolator.v2.clone();\n+      v3 = (double[]) interpolator.v3.clone();\n+      v4 = (double[]) interpolator.v4.clone();\n       vectorsInitialized = interpolator.vectorsInitialized;\n \n     }\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince853Integrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DormandPrince853Integrator.java\n public class DormandPrince853Integrator\n   extends RungeKuttaFehlbergIntegrator {\n \n-  private static final String methodName = new String(\"Dormand-Prince 8 (5, 3)\");\n+  private static final String methodName = \"Dormand-Prince 8 (5, 3)\";\n \n   private static final double sqrt6 = Math.sqrt(6.0);\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/DummyStepInterpolator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/DummyStepInterpolator.java\n    * to create the step interpolators by cloning an uninitialized\n    * model and latter initializing the copy.\n    */\n-  protected DummyStepInterpolator() {\n+  public DummyStepInterpolator() {\n     super();\n   }\n \n    */\n   protected DummyStepInterpolator(DummyStepInterpolator interpolator) {\n     super(interpolator);\n-  }\n-\n-  /** Copy the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance.\n-   */\n-  public Object clone() {\n-    return new DummyStepInterpolator(this);\n   }\n \n   /** Compute the state at the interpolated time.\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/EulerIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/EulerIntegrator.java\n public class EulerIntegrator\n   extends RungeKuttaIntegrator {\n \n-  private static final String methodName = new String(\"Euler\");\n+  private static final String methodName = \"Euler\";\n \n   private static final double[] c = {\n   };\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/GillIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/GillIntegrator.java\n public class GillIntegrator\n   extends RungeKuttaIntegrator {\n \n-  private static final String methodName = new String(\"Gill\");\n+  private static final String methodName = \"Gill\";\n \n   private static final double sqrt2 = Math.sqrt(2.0);\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegrator.java\n public class GraggBulirschStoerIntegrator\n   extends AdaptiveStepsizeIntegrator {\n \n-  private static final String methodName = new String(\"Gragg-Bulirsch-Stoer\");\n+  private static final String methodName = \"Gragg-Bulirsch-Stoer\";\n \n   /** Simple constructor.\n    * Build a Gragg-Bulirsch-Stoer integrator with the given step\n                     // estimate if there is a chance convergence will\n                     // be reached on next iteration, using the\n                     // asymptotic evolution of error\n-                    double ratio = sequence [k] * sequence[k+1]\n+                    double ratio = ((double) sequence [k] * sequence[k+1])\n                                  / (sequence[0] * sequence[0]);\n                     if (error > ratio * ratio) {\n                       // we don't expect to converge on next iteration\n                   // estimate if there is a chance convergence will\n                   // be reached on next iteration, using the\n                   // asymptotic evolution of error\n-                  double ratio = sequence[k+1] / sequence[0];\n+                  double ratio = ((double) sequence[k+1]) / sequence[0];\n                   if (error > ratio * ratio) {\n                     // we don't expect to converge on next iteration\n                     // we reject the step immediately\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/HighamHall54Integrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/HighamHall54Integrator.java\n public class HighamHall54Integrator\n   extends RungeKuttaFehlbergIntegrator {\n \n-  private static final String methodName = new String(\"Higham-Hall 5(4)\");\n+  private static final String methodName = \"Higham-Hall 5(4)\";\n \n   private static final double[] c = {\n     2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/MidpointIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/MidpointIntegrator.java\n public class MidpointIntegrator\n   extends RungeKuttaIntegrator {\n \n-  private static final String methodName = new String(\"midpoint\");\n+  private static final String methodName = \"midpoint\";\n \n   private static final double[] c = {\n     1.0 / 2.0\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/StepNormalizer.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/StepNormalizer.java\n       interpolator.setInterpolatedTime(lastTime);\n \n       double[] state = interpolator.getInterpolatedState();\n-      lastState = new double[state.length];\n-      System.arraycopy(state, 0, lastState, 0, lastState.length);\n+      lastState = (double[]) state.clone();\n \n       // take the integration direction into account\n       forward = (interpolator.getCurrentTime() >= lastTime);\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchState.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchState.java\n  */\n class SwitchState\n   implements ComputableFunction, ConvergenceChecker {\n+\n+  private static final long serialVersionUID = 6944466361876662425L;\n \n   /** Switching function. */\n   private SwitchingFunction function;\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunction.java\n // under the License.\n \n package org.spaceroots.mantissa.ode;\n+\n+import java.io.Serializable;\n \n /** This interface represents a switching function.\n  *\n  *\n  */\n \n-public interface SwitchingFunction {\n+public interface SwitchingFunction extends Serializable {\n \n   /** Stop indicator.\n    * <p>This value should be used as the return value of the {@link\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/ThreeEighthesIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/ThreeEighthesIntegrator.java\n public class ThreeEighthesIntegrator\n   extends RungeKuttaIntegrator {\n \n-  private static final String methodName = new String(\"3/8\");\n+  private static final String methodName = \"3/8\";\n \n   private static final double[] c = {\n     1.0 / 3.0, 2.0 / 3.0, 1.0\n--- a/src/mantissa/src/org/spaceroots/mantissa/optimization/DirectSearchOptimizer.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/DirectSearchOptimizer.java\n     }\n \n     RandomVectorGenerator rvg =\n-      new CorrelatedRandomVectorGenerator(statistics.getMean(null),\n+      new CorrelatedRandomVectorGenerator(statistics.getMean(),\n                                           statistics.getCovarianceMatrix(null),\n                                           new UniformRandomGenerator(seed));\n     setMultiStart(starts, rvg);\n       if (i < n) {\n         System.arraycopy(vertexA, i, vertex, i, n - i);\n       }\n-      simplex[i] = new PointCostPair(vertex);\n+      simplex[i] = new PointCostPair(vertex, Double.NaN);\n     }\n \n   }\n     int n = vertices.length - 1;\n     simplex = new PointCostPair[n + 1];\n     for (int i = 0; i <= n; ++i) {\n-      simplex[i] = new PointCostPair(vertices[i]);\n+      simplex[i] = new PointCostPair(vertices[i], Double.NaN);\n     }\n   }\n \n     double[] vertex = generator.nextVector();\n     int n = vertex.length;\n     simplex = new PointCostPair[n + 1];\n-    simplex[0] = new PointCostPair(vertex);\n+    simplex[0] = new PointCostPair(vertex, Double.NaN);\n \n     // fill up the vertex\n     for (int i = 1; i <= n; ++i) {\n-      simplex[i] = new PointCostPair(generator.nextVector());\n+      simplex[i] = new PointCostPair(generator.nextVector(), Double.NaN);\n     }\n \n   }\n    * minimizes} has not been called\n    */\n   public PointCostPair[] getMinima() {\n-    return minima;\n+    return (PointCostPair[]) minima.clone();\n   }\n \n   /** Minimizes a cost function.\n     // evaluate the cost at all non-evaluated simplex points\n     for (int i = 0; i < simplex.length; ++i) {\n       PointCostPair pair = simplex[i];\n-      if (! pair.isEvaluated()) {\n-        pair.setCost(evaluateCost(pair.getPoint()));\n+      if (Double.isNaN(pair.cost)) {\n+        simplex[i] = new PointCostPair(pair.point, evaluateCost(pair.point));\n       }\n     }\n \n   protected void replaceWorstPoint(PointCostPair pointCostPair) {\n     int n = simplex.length - 1;\n     for (int i = 0; i < n; ++i) {\n-      if (simplex[i].getCost() > pointCostPair.getCost()) {\n+      if (simplex[i].cost > pointCostPair.cost) {\n         PointCostPair tmp = simplex[i];\n         simplex[i]        = pointCostPair;\n         pointCostPair     = tmp;\n         } else if (o2 == null) {\n           return -1;\n         } else {\n-          double cost1 = ((PointCostPair) o1).getCost();\n-          double cost2 = ((PointCostPair) o2).getCost();\n+          double cost1 = ((PointCostPair) o1).cost;\n+          double cost2 = ((PointCostPair) o2).cost;\n           return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);\n         }\n       }\n--- a/src/mantissa/src/org/spaceroots/mantissa/optimization/MultiDirectional.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/MultiDirectional.java\n \n       // save the original vertex\n       PointCostPair[] original = simplex;\n-      double originalCost = original[0].getCost();\n+      double originalCost = original[0].cost;\n \n       // perform a reflection step\n       double reflectedCost = evaluateNewSimplex(original, 1.0);\n   private double evaluateNewSimplex(PointCostPair[] original, double coeff)\n     throws CostException {\n \n-    double[] xSmallest = original[0].getPoint();\n+    double[] xSmallest = original[0].point;\n     int n = xSmallest.length;\n \n     // create the linearly transformed simplex\n     simplex = new PointCostPair[n + 1];\n     simplex[0] = original[0];\n     for (int i = 1; i <= n; ++i) {\n-      double[] xOriginal    = original[i].getPoint();\n+      double[] xOriginal    = original[i].point;\n       double[] xTransformed = new double[n];\n       for (int j = 0; j < n; ++j) {\n         xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n       }\n-      simplex[i] = new PointCostPair(xTransformed);\n+      simplex[i] = new PointCostPair(xTransformed, Double.NaN);\n     }\n \n     // evaluate it\n     evaluateSimplex();\n-    return simplex[0].getCost();\n+    return simplex[0].cost;\n \n   }\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/optimization/NelderMead.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/NelderMead.java\n     int n = simplex.length - 1;\n \n     // interesting costs\n-    double   smallest      = simplex[0].getCost();\n-    double   secondLargest = simplex[n-1].getCost();\n-    double   largest       = simplex[n].getCost();\n-    double[] xLargest      = simplex[n].getPoint();\n+    double   smallest      = simplex[0].cost;\n+    double   secondLargest = simplex[n-1].cost;\n+    double   largest       = simplex[n].cost;\n+    double[] xLargest      = simplex[n].point;\n \n     // compute the centroid of the best vertices\n     // (dismissing the worst point at index n)\n     double[] centroid = new double[n];\n     for (int i = 0; i < n; ++i) {\n-      double[] x = simplex[i].getPoint();\n+      double[] x = simplex[i].point;\n       for (int j = 0; j < n; ++j) {\n         centroid[j] += x[j];\n       }\n     if ((smallest <= costR) && (costR < secondLargest)) {\n \n       // accept the reflected point\n-      PointCostPair r = new PointCostPair(xR);\n-      r.setCost(costR);\n-      replaceWorstPoint(r);\n+      replaceWorstPoint(new PointCostPair(xR, costR));\n \n     } else if (costR < smallest) {\n \n \n       if (costE < costR) {\n         // accept the expansion point\n-        PointCostPair e = new PointCostPair(xE);\n-        e.setCost(costE);\n-        replaceWorstPoint(e);\n+        replaceWorstPoint(new PointCostPair(xE, costE));\n       } else {\n         // accept the reflected point\n-        PointCostPair r = new PointCostPair(xR);\n-        r.setCost(costR);\n-        replaceWorstPoint(r);\n+        replaceWorstPoint(new PointCostPair(xR, costR));\n       }\n \n     } else {\n \n         if (costC <= costR) {\n           // accept the contraction point\n-          PointCostPair c = new PointCostPair(xC);\n-          c.setCost(costC);\n-          replaceWorstPoint(c);\n+          replaceWorstPoint(new PointCostPair(xC, costC));\n           return;\n         }\n \n \n         if (costC < largest) {\n           // accept the contraction point\n-          PointCostPair c = new PointCostPair(xC);\n-          c.setCost(costC);\n-          replaceWorstPoint(c);\n+          replaceWorstPoint(new PointCostPair(xC, costC));\n           return;\n         }\n \n       }\n \n       // perform a shrink\n-      double[] xSmallest = simplex[0].getPoint();\n+      double[] xSmallest = simplex[0].point;\n       for (int i = 1; i < simplex.length; ++i) {\n-        PointCostPair pair = simplex[i];\n-        double[] x = pair.getPoint();\n+        double[] x = simplex[i].point;\n         for (int j = 0; j < n; ++j) {\n           x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n         }\n-        pair.setCost(Double.NaN);\n+        simplex[i] = new PointCostPair(x, Double.NaN);\n       }\n       evaluateSimplex();\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/optimization/PointCostPair.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/optimization/PointCostPair.java\n package org.spaceroots.mantissa.optimization;\n \n /** This class holds a point and its associated cost.\n- * <p>A cost/point pair is not evaluated at build time. Its associated\n- * cost set to <code>Double.NaN</code> until it is evaluated.</p>\n+ * <p>This is a simple immutable container.</p>\n  * @author Luc Maisonobe\n- * @version $Id: PointCostPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id: PointCostPair.java 1709 2006-12-03 21:16:50Z luc $\n  * @see CostFunction\n  */\n public class PointCostPair {\n \n-  /** Build a point/cost pair with non-evaluated cost.\n+  /** Build a point/cost pair.\n    * @param point point coordinates\n+   * @param cost point cost\n    */\n-  public PointCostPair(double[] point) {\n-    this.point = point;\n-    cost = Double.NaN;\n-  }\n-\n-  /** Reset the point coordinates.\n-   * <p>Resetting the points coordinates automatically reset the cost\n-   * to non-evaluated</p>\n-   * @param point new point coordinates\n-   * @return old point coordinates (this can be re-used to put the\n-   * coordinates of another point without re-allocating an array)\n-   */\n-  public double[] setPoint(double[] point) {\n-    double[] oldPoint = this.point;\n-    this.point = point;\n-    cost = Double.NaN;\n-    return oldPoint;\n-  }\n-\n-  /** Get the point coordinates.\n-   * @return point coordinates\n-   */\n-  public double[] getPoint() {\n-    return point;\n-  }\n-\n-  /** Set the cost.\n-   * @param cost cost to store in the instance (can be\n-   * <code>Double.NaN</code> to reset the instance to non-evaluated)\n-   */\n-  public void setCost(double cost) {\n+  public PointCostPair(double[] point, double cost) {\n+    this.point = (double[]) point.clone();\n     this.cost = cost;\n   }\n \n-  /** Get the cost.\n-   * @return cost associated to the point (or <code>Double.NaN</code>\n-   * if the instance is not evaluated)\n-   */\n-  public double getCost() {\n-    return cost;\n-  }\n-\n-  /** Check if the cost has been evaluated.\n-   * <p>The cost is considered to be non-evaluated if it is\n-   * <code>Double.isNaN(pair.getCost())</code> would return true</p>\n-   * @return true if the cost has been evaluated\n-   */\n-  public boolean isEvaluated() {\n-    return ! Double.isNaN(cost);\n-  }\n-\n   /** Point coordinates. */\n-  private double[] point;\n+  public final double[] point;\n \n   /** Cost associated to the point. */\n-  private double cost;\n+  public final double cost;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegrator.java\n \n     try {\n       while (true) {\n-        sum = sampler.nextSamplePoint().getY();\n+        sum = sampler.nextSamplePoint().y;\n       }\n     } catch(ExhaustedSampleException e) {\n     }\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegratorSampler.java\n     try {\n       next = iter.nextSamplePoint();\n \n-      double h1 = current.getX() - previous.getX();\n-      double h2 = next.getX()    - current.getX();\n+      double h1 = current.x - previous.x;\n+      double h2 = next.x    - current.x;\n       double cP = (h1 + h2) * (2 * h1 - h2) / (6 * h1);\n       double cC = (h1 + h2) * (h1 + h2) * (h1 + h2) / (6 * h1 * h2);\n       double cN = (h1 + h2) * (2 * h2 - h1) / (6 * h2);\n \n-      double[] pY = previous.getY();\n-      double[] cY = current.getY();\n-      double[] nY = next.getY();\n+      double[] pY = previous.y;\n+      double[] cY = current.y;\n+      double[] nY = next.y;\n       for (int i = 0; i < sum.length; ++i) {\n         sum [i] += cP * pY[i] + cC * cY[i] + cN * nY[i];\n       }\n     } catch(ExhaustedSampleException e) {\n       // we have an incomplete step at the end of the sample\n       // we use a trapezoid scheme for this last step\n-      double halfDx = 0.5 * (current.getX() - previous.getX());\n-      double[] pY = previous.getY();\n-      double[] cY = current.getY();\n+      double halfDx = 0.5 * (current.x - previous.x);\n+      double[] pY = previous.y;\n+      double[] cY = current.y;\n       for (int i = 0; i < sum.length; ++i) {\n         sum [i] += halfDx * (pY[i] + cY[i]);\n       }\n-      return new VectorialValuedPair(current.getX(), sum);\n+      return new VectorialValuedPair(current.x, sum);\n     }\n \n-    double[] values = new double[sum.length];\n-    System.arraycopy(sum, 0, values, 0, sum.length);\n-    return new VectorialValuedPair(next.getX(), values);\n+    return new VectorialValuedPair(next.x, (double[]) sum.clone());\n \n   }\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegrator.java\n \n     try {\n       while (true) {\n-        sum = sampler.nextSamplePoint().getY();\n+        sum = sampler.nextSamplePoint().y;\n       }\n     } catch(ExhaustedSampleException e) {\n     }\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegratorSampler.java\n     // performs one step of a Riemann scheme\n     VectorialValuedPair previous = current;\n     current = iter.nextSamplePoint();\n-    double step =  (current.getX() - previous.getX());\n-    double[] pY = previous.getY();\n+    double step =  (current.x - previous.x);\n+    double[] pY = previous.y;\n     for (int i = 0; i < sum.length; ++i) {\n       sum[i] += step * pY[i];\n     }\n \n-    double[] values = new double[sum.length];\n-    System.arraycopy(sum, 0, values, 0, sum.length);\n-    return new VectorialValuedPair (current.getX(), values);\n+    return new VectorialValuedPair (current.x, (double[]) sum.clone());\n \n   }\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegrator.java\n \n     try {\n       while (true) {\n-        sum = sampler.nextSamplePoint().getY();\n+        sum = sampler.nextSamplePoint().y;\n       }\n     } catch(ExhaustedSampleException e) {\n     }\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegratorSampler.java\n     VectorialValuedPair previous = current;\n     current = iter.nextSamplePoint();\n \n-    double halfDx = 0.5 * (current.getX() - previous.getX());\n-    double[] pY = previous.getY();\n-    double[] cY = current.getY();\n+    double halfDx = 0.5 * (current.x - previous.x);\n+    double[] pY = previous.y;\n+    double[] cY = current.y;\n     for (int i = 0; i < sum.length; ++i) {\n       sum[i] += halfDx * (pY[i] + cY[i]);\n     }\n \n-    double[] values = new double[sum.length];\n-    System.arraycopy(sum, 0, values, 0, sum.length);\n-    return new VectorialValuedPair (current.getX(), values);\n+    return new VectorialValuedPair (current.x, (double[]) sum.clone());\n \n   }\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/CorrelatedRandomVectorGenerator.java\n                                     });\n       throw new IllegalArgumentException(message);\n     }\n-    this.mean = mean;\n+    this.mean = (double[]) mean.clone();\n \n     factorize(covariance);\n \n     this.generator = generator;\n     normalized = new double[rank];\n-    correlated = new double[order];\n \n   }\n \n \n     this.generator = generator;\n     normalized = new double[rank];\n-    correlated = new double[order];\n \n   }\n \n   }\n \n   /** Generate a correlated random vector.\n-   * @return a random vector as an array of double. The generator\n-   * <em>will</em> reuse the same array for each call, in order to\n-   * save the allocation time, so the user should keep a copy by\n-   * himself if he needs so.\n+   * @return a random vector as an array of double. The returned array\n+   * is created at each call, the caller can do what it wants with it.\n    */\n   public double[] nextVector() {\n \n     }\n \n     // compute correlated vector\n+    double[] correlated = new double[mean.length];\n     for (int i = 0; i < correlated.length; ++i) {\n       correlated[i] = mean[i];\n       for (int j = 0; j < rank; ++j) {\n   /** Storage for the normalized vector. */\n   private double[] normalized;\n \n-  /** Storage for the random vector. */\n-  private double[] correlated;\n-\n-  private static final long serialVersionUID = -4754497552287369719L;\n+  private static final long serialVersionUID = -88563624902398453L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/GaussianRandomGenerator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/GaussianRandomGenerator.java\n public class GaussianRandomGenerator\n   implements NormalizedRandomGenerator {\n \n-  /** Underlying generator. */\n-  Random generator;\n-\n   /** Create a new generator.\n    * The seed of the generator is related to the current time.\n    */\n     return generator.nextGaussian();\n   }\n \n+  /** Underlying generator. */\n+  private Random generator;\n+\n+  private static final long serialVersionUID = 5504568059866195697L;\n+\n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/NormalizedRandomGenerator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/NormalizedRandomGenerator.java\n \n package org.spaceroots.mantissa.random;\n \n+import java.io.Serializable;\n+\n /** This interface represent a normalized random generator for\n  * scalars.\n  * Normalized generator should provide null mean and unit standard\n  * @version $Id: NormalizedRandomGenerator.java 1705 2006-09-17 19:57:39Z luc $\n  * @author L. Maisonobe\n  */\n-public interface NormalizedRandomGenerator {\n+public interface NormalizedRandomGenerator extends Serializable {\n \n   /** Generate a random scalar with null mean and unit standard deviation.\n    * <p>This method does <strong>not</strong> specify the shape of the\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/UncorrelatedRandomVectorGenerator.java\n     if (mean.length != standardDeviation.length) {\n       throw new IllegalArgumentException(\"dimension mismatch\");\n     }\n-    this.mean              = mean;\n-    this.standardDeviation = standardDeviation;\n+    this.mean              = (double[]) mean.clone();\n+    this.standardDeviation = (double[]) standardDeviation.clone();\n \n     this.generator = generator;\n-    random = new double[mean.length];\n \n   }\n \n     }\n \n     this.generator = generator;\n-    random = new double[dimension];\n \n   }\n \n   }\n \n   /** Generate a correlated random vector.\n-   * @return a random vector as an array of double. The generator\n-   * <em>will</em> reuse the same array for each call, in order to\n-   * save the allocation time, so the user should keep a copy by\n-   * himself if he needs so.\n+   * @return a random vector as an array of double. The returned array\n+   * is created at each call, the caller can do what it wants with it.\n    */\n   public double[] nextVector() {\n \n+    double[] random = new double[mean.length]; \n     for (int i = 0; i < random.length; ++i) {\n       random[i] = mean[i] + standardDeviation[i] * generator.nextDouble();\n     }\n   /** Underlying scalar generator. */\n   NormalizedRandomGenerator generator;\n \n-  /** Storage for the random vector. */\n-  private double[] random;\n-\n-  private static final long serialVersionUID = -3323293740860311151L;\n+  private static final long serialVersionUID = -9094322067568302961L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/UniformRandomGenerator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/UniformRandomGenerator.java\n public class UniformRandomGenerator\n   implements NormalizedRandomGenerator {\n \n-  private static final double SQRT3 = Math.sqrt(3.0);\n-\n-  private static final double TWOSQRT3 = 2.0 * Math.sqrt(3.0);\n-\n-  /** Underlying generator. */\n-  Random generator;\n-\n   /** Create a new generator.\n    * The seed of the generator is related to the current time.\n    */\n     return TWOSQRT3 * generator.nextDouble() - SQRT3;\n   }\n \n+  /** Underlying generator. */\n+  private Random generator;\n+\n+  private static final double SQRT3 = Math.sqrt(3.0);\n+\n+  private static final double TWOSQRT3 = 2.0 * Math.sqrt(3.0);\n+\n+  private static final long serialVersionUID = -6913329325753217654L;\n+\n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/VectorialSampleStatistics.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/VectorialSampleStatistics.java\n \n import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n \n-import java.util.Arrays;\n-\n /** This class compute basic statistics on a scalar sample.\n  * @version $Id: VectorialSampleStatistics.java 1705 2006-09-17 19:57:39Z luc $\n  * @author L. Maisonobe\n     sum2       = null;\n   }\n \n-  /** Allocate all the arrays. */\n-  private void allocate() {\n-    min        = new double[dimension];\n-    minIndices = new int[dimension];\n-    max        = new double[dimension];\n-    maxIndices = new int[dimension];\n-    sum        = new double[dimension];\n-    sum2       = new double[dimension * (dimension + 1) / 2];\n-  }\n-\n   /** Add one point to the instance.\n    * @param x value of the sample point\n    * @exception IllegalArgumentException if there is a dimension\n \n     if (n == 0) {\n \n-      dimension = x.length;\n-      allocate();\n-\n-      Arrays.fill(minIndices, 0);\n-      Arrays.fill(maxIndices, 0);\n-      System.arraycopy(x, 0, min, 0, dimension);\n-      System.arraycopy(x, 0, max, 0, dimension);\n-      System.arraycopy(x, 0, sum, 0, dimension);\n+      dimension  = x.length;\n+      minIndices = new int[dimension];\n+      maxIndices = new int[dimension];\n+      min        = (double[]) x.clone();\n+      max        = (double[]) x.clone();\n+      sum        = (double[]) x.clone();\n+      sum2       = new double[dimension * (dimension + 1) / 2];\n \n       int k = 0;\n       for (int i = 0; i < dimension; ++i) {\n     if (n == 0) {\n \n       dimension = s.dimension;\n-      allocate();\n-\n-      System.arraycopy(s.min,         0, min,         0, dimension);\n-      System.arraycopy(s.minIndices,  0, minIndices,  0, dimension);\n-      System.arraycopy(s.max,         0, max,         0, dimension);\n-      System.arraycopy(s.maxIndices,  0, maxIndices,  0, dimension);\n-      System.arraycopy(s.sum,         0, sum,         0, dimension);\n-      System.arraycopy(s.sum2,        0, sum2,        0, sum2.length);\n+      min        = (double[]) s.min.clone();\n+      minIndices = (int[])    s.minIndices.clone();\n+      max        = (double[]) s.max.clone();\n+      maxIndices = (int[])    s.maxIndices.clone();\n+      sum        = (double[]) s.sum.clone();\n+      sum2       = (double[]) s.sum2.clone();\n \n     } else {\n       int k = 0;\n    * of the sample at which the minimum was encountered can be\n    * retrieved with the {@link #getMinIndices getMinIndices}\n    * method.</p>\n-   * @return minimal value in the sample (the array is a reference to\n-   * an internal array that changes each time something is added to\n-   * the instance, the caller should neither change it nor rely on its\n-   * value in the long term)\n+   * @return minimal value in the sample (a new array is created\n+   * at each call, the caller may do what it wants to with it)\n    * @see #getMinIndices\n    */\n   public double[] getMin() {\n-    return min;\n+    return (double[]) min.clone();\n   }\n \n   /** Get the indices at which the minimal value occurred in the sample.\n    * @return a vector reporting at which occurrence each component of\n-   * the sample reached its minimal value (the array is a reference to\n-   * an internal array that changes each time something is added to\n-   * the instance, the caller should neither change it nor rely on its\n-   * value in the long term)\n+   * the sample reached its minimal value (a new array is created\n+   * at each call, the caller may do what it wants to with it)\n    * @see #getMin\n    */\n   public int[] getMinIndices() {\n-    return minIndices;\n+    return (int[]) minIndices.clone();\n   }\n \n   /** Get the maximal value in the sample.\n    * of the sample at which the maximum was encountered can be\n    * retrieved with the {@link #getMaxIndices getMaxIndices}\n    * method.</p>\n-   * @return maximal value in the sample (the array is a reference to\n-   * an internal array that changes each time something is added to\n-   * the instance, the caller should neither change it nor rely on its\n-   * value in the long term)\n+   * @return maximal value in the sample (a new array is created\n+   * at each call, the caller may do what it wants to with it)\n    * @see #getMaxIndices\n    */\n   public double[] getMax() {\n-    return max;\n+    return (double[]) max.clone();\n   }\n \n   /** Get the indices at which the maximal value occurred in the sample.\n    * @return a vector reporting at which occurrence each component of\n-   * the sample reached its maximal value (the array is a reference to\n-   * an internal array that changes each time something is added to\n-   * the instance, the caller should neither change it nor rely on its\n-   * value in the long term)\n+   * the sample reached its maximal value (a new array is created\n+   * at each call, the caller may do what it wants to with it)\n    * @see #getMax\n    */\n   public int[] getMaxIndices() {\n-    return maxIndices;\n+    return (int[]) maxIndices.clone();\n   }\n \n   /** Get the mean value of the sample.\n-   * @param mean placeholder where to store the array, if null a new\n-   * array will be allocated\n-   * @return mean value of the sample or null if the sample is empty\n-   * and hence the dimension of the vectors is still unknown\n-   * (reference to mean if it was non-null, reference to a new array\n-   * otherwise)\n-   */\n-  public double[] getMean(double[] mean) {\n+   * @return mean value of the sample or an empty array\n+   * if the sample is empty (a new array is created\n+   * at each call, the caller may do what it wants to with it)\n+   */\n+  public double[] getMean() {\n     if (n == 0) {\n-      return null;\n-    }\n-    if (mean == null) {\n-      mean = new double[dimension];\n-    }\n+      return new double[0];\n+    }\n+    double[] mean = new double[dimension];\n     for (int i = 0; i < dimension; ++i) {\n       mean[i] = sum[i] / n;\n     }\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapper.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapper.java\n \n   }\n \n-  /** Get the internal data array.\n-   * @return internal data array\n+  /** Get the data array.\n+   * @return copy of the data array\n    */\n-  public double[] getInternalDataArray() {\n+  public double[] getDataArray() {\n     if (internalData == null) {\n       internalData = new double [size];\n     }\n-    return internalData;\n+    return (double[]) internalData.clone();\n   }\n \n   /** Map data from the internal array to the domain objects.\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableArray.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableArray.java\n   /** Simple constructor.\n    * Build a mappable array from an existing array\n    * @param array array to use\n-   * @param doReallocate true if a new array should be allocated and\n-   * initialized using the other argument, false if the instance\n-   * should reference the existing array throughout its lifetime\n    */\n-  public MappableArray(double[] array, boolean doReallocate) {\n-    if (doReallocate) {\n-      internalArray = new double[array.length];\n-      System.arraycopy(array, 0, internalArray, 0, array.length);\n-    } else {\n-      internalArray = array;\n-    }\n+  public MappableArray(double[] array) {\n+    internalArray = (double[]) array.clone();\n   }\n \n   /** Get the array stored in the instance.\n    * @return array stored in the instance\n    */\n   public double[] getArray () {\n-    return internalArray;\n+    return (double[]) internalArray.clone();\n   }\n \n   /** Get the dimension of the internal array.\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/ChebyshevTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/ChebyshevTest.java\n     super(name);\n   }\n \n-  public void aatestOne() {\n+  public void testOne() {\n     assertTrue(new Chebyshev().isOne());\n   }\n \n \n   }\n \n-  public void aatestBounds() {\n+  public void testBounds() {\n     for (int k = 0; k < 12; ++k) {\n-      Chebyshev Tk = new Chebyshev(k);\n+      OrthogonalPolynomial Tk = new Chebyshev(k);\n       for (double x = -1.0; x <= 1.0; x += 0.02) {\n         assertTrue(Math.abs(Tk.valueAt(x)) < (1.0 + 1.0e-12));\n       }\n     }\n   }\n \n-  public void aatestDifferentials() {\n+  public void testDifferentials() {\n     for (int k = 0; k < 12; ++k) {\n \n       Polynomial.Rational Tk0 = new Chebyshev(k);\n       Polynomial.Rational g1 = new Polynomial.Rational(-1l, 0l);\n       Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);\n \n-      Polynomial.Rational Tk0g0 = Polynomial.Rational.multiply(Tk0, g0);\n-      Polynomial.Rational Tk1g1 = Polynomial.Rational.multiply(Tk1, g1);\n-      Polynomial.Rational Tk2g2 = Polynomial.Rational.multiply(Tk2, g2);\n+      Polynomial.Rational Tk0g0 = Tk0.multiply(g0);\n+      Polynomial.Rational Tk1g1 = Tk1.multiply(g1);\n+      Polynomial.Rational Tk2g2 = Tk2.multiply(g2);\n \n-      Polynomial.Rational d =\n-        Polynomial.Rational.add(Tk0g0, Polynomial.Rational.add(Tk1g1, Tk2g2));\n+      Polynomial.Rational d = Tk0g0.add(Tk1g1.add(Tk2g2));\n       assertTrue(d.isZero());\n \n     }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/HermiteTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/HermiteTest.java\n       Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);\n       Polynomial.Rational g2 = new Polynomial.Rational(1l);\n \n-      Polynomial.Rational Hk0g0 = Polynomial.Rational.multiply(Hk0, g0);\n-      Polynomial.Rational Hk1g1 = Polynomial.Rational.multiply(Hk1, g1);\n-      Polynomial.Rational Hk2g2 = Polynomial.Rational.multiply(Hk2, g2);\n+      Polynomial.Rational Hk0g0 = Hk0.multiply(g0);\n+      Polynomial.Rational Hk1g1 = Hk1.multiply(g1);\n+      Polynomial.Rational Hk2g2 = Hk2.multiply(g2);\n \n-      Polynomial.Rational d =\n-        Polynomial.Rational.add(Hk0g0, Polynomial.Rational.add(Hk1g1, Hk2g2));\n+      Polynomial.Rational d = Hk0g0.add(Hk1g1.add(Hk2g2));\n       assertTrue(d.isZero());\n \n     }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/LaguerreTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/LaguerreTest.java\n       Polynomial.Rational g1 = new Polynomial.Rational(-1l, 1l);\n       Polynomial.Rational g2 = new Polynomial.Rational(1l, 0l);\n \n-      Polynomial.Rational Lk0g0 = Polynomial.Rational.multiply(Lk0, g0);\n-      Polynomial.Rational Lk1g1 = Polynomial.Rational.multiply(Lk1, g1);\n-      Polynomial.Rational Lk2g2 = Polynomial.Rational.multiply(Lk2, g2);\n+      Polynomial.Rational Lk0g0 = Lk0.multiply(g0);\n+      Polynomial.Rational Lk1g1 = Lk1.multiply(g1);\n+      Polynomial.Rational Lk2g2 = Lk2.multiply(g2);\n \n-      Polynomial.Rational d =\n-        Polynomial.Rational.add(Lk0g0, Polynomial.Rational.add(Lk1g1, Lk2g2));\n+      Polynomial.Rational d = Lk0g0.add(Lk1g1.add(Lk2g2));\n       assertTrue(d.isZero());\n \n     }\n   }\n \n   public void checkLaguerre(Laguerre p, long denominator, String reference) {\n-    assertTrue(Laguerre.multiply(p, denominator).toString().equals(reference));\n+    assertTrue(p.multiply(denominator).toString().equals(reference));\n   }\n \n   public static Test suite() {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/LegendreTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/LegendreTest.java\n       Polynomial.Rational g1 = new Polynomial.Rational(-2l, 0l);\n       Polynomial.Rational g2 = new Polynomial.Rational(-1l, 0l, 1l);\n \n-      Polynomial.Rational Pk0g0 = Polynomial.Rational.multiply(Pk0, g0);\n-      Polynomial.Rational Pk1g1 = Polynomial.Rational.multiply(Pk1, g1);\n-      Polynomial.Rational Pk2g2 = Polynomial.Rational.multiply(Pk2, g2);\n+      Polynomial.Rational Pk0g0 = Pk0.multiply(g0);\n+      Polynomial.Rational Pk1g1 = Pk1.multiply(g1);\n+      Polynomial.Rational Pk2g2 = Pk2.multiply(g2);\n \n-      Polynomial.Rational d =\n-        Polynomial.Rational.add(Pk0g0, Polynomial.Rational.add(Pk1g1, Pk2g2));\n+      Polynomial.Rational d = Pk0g0.add(Pk1g1.add(Pk2g2));\n       assertTrue(d.isZero());\n \n     }\n   }\n \n   public void checkLegendre(Legendre p, long denominator, String reference) {\n-    assertTrue(Legendre.multiply(p, denominator).toString().equals(reference));\n+    assertTrue(p.multiply(denominator).toString().equals(reference));\n   }\n \n   public static Test suite() {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialDoubleTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialDoubleTest.java\n \n   public void testConversion() {\n     Polynomial.Rational r = new Polynomial.Rational(1l, 3l, -5l);\n-    r.multiplySelf(new RationalNumber(1l, 2l));\n+    r = (Polynomial.Rational) r.multiply(new RationalNumber(1l, 2l));\n     Polynomial.Double p = new Polynomial.Double(r);\n     checkPolynomial(p, \"-2.5 + 1.5 x + 0.5 x^2\");\n   }\n \n   public void testString() {\n-\n     Polynomial.Double p = new Polynomial.Double(1.0, 3.0, -5.0);\n     checkPolynomial(p, \"-5.0 + 3.0 x + x^2\");\n-    p.setUnknownName(\"alpha\");\n-    checkPolynomial(p, \"-5.0 + 3.0 alpha + alpha^2\");\n-    p.setUnknownName(null);\n-    checkPolynomial(p, \"-5.0 + 3.0 x + x^2\");\n-\n     checkPolynomial(new Polynomial.Double(3.0, -2.0, 0.0),\n                     \"-2.0 x + 3.0 x^2\");\n     checkPolynomial(new Polynomial.Double(3.0, -2.0, 1.0),\n                     \"1.0 + 3.0 x^2\");\n     checkPolynomial(new Polynomial.Double(0.0),\n                     \"0\");\n-\n   }\n \n   public void testAddition() {\n \n     Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);\n     Polynomial.Double p2 = new Polynomial.Double(0.0, -1.0, 2.0);\n-    assertTrue(Polynomial.Double.add(p1, p2).isZero());\n+    assertTrue(p1.add(p2).isZero());\n \n-    p2 = new Polynomial.Double(p1);\n-    p2.addToSelf(p2);\n+    p2 = p1.add(p1);\n     checkPolynomial(p2, \"-4.0 + 2.0 x\");\n \n     p1 = new Polynomial.Double(2.0, -4.0, 1.0);\n     p2 = new Polynomial.Double(-2.0, 3.0, -1.0);\n-    p1.addToSelf(p2);\n+    p1 = p1.add(p2);\n     assertEquals(1, p1.getDegree());\n     checkPolynomial(p1, \"-x\");\n \n   public void testSubtraction() {\n \n     Polynomial.Double p1 = new Polynomial.Double(1.0, -2.0);\n-    assertTrue(Polynomial.Double.subtract(p1, p1).isZero());\n+    assertTrue(p1.subtract(p1).isZero());\n \n     Polynomial.Double p2 = new Polynomial.Double(6.0, -2.0);\n-    p2.subtractFromSelf(p1);\n+    p2 = p2.subtract(p1);\n     checkPolynomial(p2, \"5.0 x\");\n \n     p1 = new Polynomial.Double(2.0, -4.0, 1.0);\n     p2 = new Polynomial.Double(2.0, 3.0, -1.0);\n-    p1.subtractFromSelf(p2);\n+    p1 = p1.subtract(p2);\n     assertEquals(1, p1.getDegree());\n     checkPolynomial(p1, \"2.0 - 7.0 x\");\n \n \n     Polynomial.Double p1 = new Polynomial.Double(2.0, -3.0);\n     Polynomial.Double p2 = new Polynomial.Double(1.0, 2.0, 3.0);\n-    checkPolynomial(Polynomial.Double.multiply(p1, p2), \"-9.0 + x^2 + 2.0 x^3\");\n+    checkPolynomial(p1.multiply(p2), \"-9.0 + x^2 + 2.0 x^3\");\n \n     p1 = new Polynomial.Double(1.0, 0.0);\n-    p2 = new Polynomial.Double(p1);\n+    p2 = p1;\n     for (int i = 2; i < 10; ++i) {\n-      p2.multiplySelf(p1);\n+      p2 = p2.multiply(p1);\n       checkPolynomial(p2, \"x^\" + i);\n     }\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialFractionTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialFractionTest.java\n   public void testInvert() {\n \n     PolynomialFraction f = new PolynomialFraction(2l, 4l);\n-    f.invertSelf();\n+    f= f.invert();\n     checkValue(f, \"2\");\n-    f.invertSelf();\n+    f = f.invert();\n     checkValue(f, \"1/2\");\n \n     f = new PolynomialFraction(120l);\n-    f.invertSelf();\n+    f = f.invert();\n     checkValue(f, \"1/120\");\n \n     f = new PolynomialFraction(0l, 4l);\n     try {\n-      f.invertSelf();\n+      f = f.invert();\n       fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException e) {\n     } catch (Exception e) {\n     }\n \n     f = new PolynomialFraction(307692l, 999999l);\n-    PolynomialFraction fInverse = PolynomialFraction.invert(f);\n+    PolynomialFraction fInverse = f.invert();\n     checkValue(fInverse, \"13/4\");\n     checkValue(f, \"4/13\");\n \n   public void testAddition() {\n \n     PolynomialFraction f1 = new PolynomialFraction(4l, 6l);\n-    f1.addToSelf(f1);\n+    f1 = f1.add(f1);\n     checkValue(f1, \"4/3\");\n \n-    checkValue(PolynomialFraction.add(new PolynomialFraction(17l, 3l),\n-                                      new PolynomialFraction(-17l, 3l)),\n+    checkValue(new PolynomialFraction(17l, 3l).add(new PolynomialFraction(-17l, 3l)),\n                \"0\");\n-    checkValue(PolynomialFraction.add(new PolynomialFraction(2l, 3l),\n-                                      new PolynomialFraction(3l, 4l)),\n+    checkValue(new PolynomialFraction(2l, 3l).add(new PolynomialFraction(3l, 4l)),\n                \"17/12\");\n-    checkValue(PolynomialFraction.add(new PolynomialFraction(1l, 6l),\n-                                      new PolynomialFraction(2l, 6l)),\n+    checkValue(new PolynomialFraction(1l, 6l).add(new PolynomialFraction(2l, 6l)),\n                \"1/2\");\n-    checkValue(PolynomialFraction.add(new PolynomialFraction(4l, 5l),\n-                                      new PolynomialFraction(-3l, 4l)),\n+    checkValue(new PolynomialFraction(4l, 5l).add(new PolynomialFraction(-3l, 4l)),\n                \"1/20\");\n-    checkValue(PolynomialFraction.add(new PolynomialFraction(-3l, 4l),\n-                                      new PolynomialFraction(4l, 5l)),\n+    checkValue(new PolynomialFraction(-3l, 4l).add(new PolynomialFraction(4l, 5l)),\n                \"1/20\");\n \n   }\n   public void testSubtraction() {\n \n     PolynomialFraction f1 = new PolynomialFraction(4l, 6l);\n-    f1.subtractFromSelf(f1);\n-    checkValue(f1, \"0\");\n+    checkValue(f1.subtract(f1), \"0\");\n \n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(7l, 3l),\n-                                           new PolynomialFraction(-7l, 3l)),\n+    checkValue(new PolynomialFraction(7l, 3l).subtract(new PolynomialFraction(-7l, 3l)),\n                \"14/3\");\n \n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(3l, 4l),\n-                                           new PolynomialFraction(2l, 3l)),\n+    checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(2l, 3l)),\n                \"1/12\");\n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(3l, 4l),\n-                                           new PolynomialFraction(-2l, 3l)),\n+    checkValue(new PolynomialFraction(3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),\n                \"17/12\");\n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-3l, 4l),\n-                                           new PolynomialFraction(2l, 3l)),\n+    checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(2l, 3l)),\n                \"-17/12\");\n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-3l, 4l),\n-                                           new PolynomialFraction(-2l, 3l)),\n+    checkValue(new PolynomialFraction(-3l, 4l).subtract(new PolynomialFraction(-2l, 3l)),\n                \"-1/12\");\n \n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(2l, 3l),\n-                                           new PolynomialFraction(3l, 4l)),\n+    checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(3l, 4l)),\n                \"-1/12\");\n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-2l, 3l),\n-                                           new PolynomialFraction(3l, 4l)),\n+    checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(3l, 4l)),\n                \"-17/12\");\n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(2l, 3l),\n-                                           new PolynomialFraction(-3l, 4l)),\n+    checkValue(new PolynomialFraction(2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),\n                \"17/12\");\n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(-2l, 3l),\n-                                           new PolynomialFraction(-3l, 4l)),\n+    checkValue(new PolynomialFraction(-2l, 3l).subtract(new PolynomialFraction(-3l, 4l)),\n                \"1/12\");\n \n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(1l, 6l),\n-                                           new PolynomialFraction(2l, 6l)),\n+    checkValue(new PolynomialFraction(1l, 6l).subtract(new PolynomialFraction(2l, 6l)),\n                \"-1/6\");\n-    checkValue(PolynomialFraction.subtract(new PolynomialFraction(1l, 2l),\n-                                           new PolynomialFraction(1l, 6l)),\n+    checkValue(new PolynomialFraction(1l, 2l).subtract(new PolynomialFraction(1l, 6l)),\n                \"1/3\");\n \n   }\n   public void testMultiplication() {\n \n     PolynomialFraction f = new PolynomialFraction(2l, 3l);\n-    f.multiplySelf(new PolynomialFraction(9l,4l));\n-    checkValue(f, \"3/2\");\n+    checkValue(f.multiply(new PolynomialFraction(9l,4l)), \"3/2\");\n \n-    checkValue(PolynomialFraction.multiply(new PolynomialFraction(1l, 2l),\n-                                           new PolynomialFraction(0l)),\n+    checkValue(new PolynomialFraction(1l, 2l).multiply(new PolynomialFraction(0l)),\n                \"0\");\n-    checkValue(PolynomialFraction.multiply(new PolynomialFraction(4l, 15l),\n-                                           new PolynomialFraction(-5l, 2l)),\n+    checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),\n                \"-2/3\");\n-    checkValue(PolynomialFraction.multiply(new PolynomialFraction(-4l, 15l),\n-                                           new PolynomialFraction(5l, 2l)),\n+    checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(5l, 2l)),\n                \"-2/3\");\n-    checkValue(PolynomialFraction.multiply(new PolynomialFraction(4l, 15l),\n-                                           new PolynomialFraction(5l, 2l)),\n+    checkValue(new PolynomialFraction(4l, 15l).multiply(new PolynomialFraction(5l, 2l)),\n                \"2/3\");\n-    checkValue(PolynomialFraction.multiply(new PolynomialFraction(-4l, 15l),\n-                                           new PolynomialFraction(-5l, 2l)),\n+    checkValue(new PolynomialFraction(-4l, 15l).multiply(new PolynomialFraction(-5l, 2l)),\n                \"2/3\");\n \n   }\n   public void testDivision() {\n \n     PolynomialFraction f = new PolynomialFraction(2l, 3l);\n-    f.divideSelf(new PolynomialFraction(4l,9l));\n-    checkValue(f, \"3/2\");\n+    ;\n+    checkValue(f.divide(new PolynomialFraction(4l,9l)), \"3/2\");\n \n     try {\n-      PolynomialFraction.divide(new PolynomialFraction(1l, 2l),\n-                                new PolynomialFraction(0l));\n+      new PolynomialFraction(1l, 2l).divide(new PolynomialFraction(0l));\n       fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException e) {\n     } catch (Exception e) {\n       fail(\"wrong exception caught\");\n     }\n \n-    checkValue(PolynomialFraction.divide(new PolynomialFraction(4l, 15l),\n-                                         new PolynomialFraction(-2l, 5l)),\n+    checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(-2l, 5l)),\n                \"-2/3\");\n-    checkValue(PolynomialFraction.divide(new PolynomialFraction(-4l, 15l),\n-                                         new PolynomialFraction(2l, 5l)),\n+    checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(2l, 5l)),\n                \"-2/3\");\n-    checkValue(PolynomialFraction.divide(new PolynomialFraction(4l, 15l),\n-                                         new PolynomialFraction(2l, 5l)),\n+    checkValue(new PolynomialFraction(4l, 15l).divide(new PolynomialFraction(2l, 5l)),\n                \"2/3\");\n-    checkValue(PolynomialFraction.divide(new PolynomialFraction(-4l, 15l),\n-                                         new PolynomialFraction(-2l, 5l)),\n+    checkValue(new PolynomialFraction(-4l, 15l).divide(new PolynomialFraction(-2l, 5l)),\n                \"2/3\");\n \n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialRationalTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/PolynomialRationalTest.java\n \n     Polynomial.Rational p = new Polynomial.Rational(1l, 3l, -5l);\n     checkPolynomial(p, \"-5 + 3 x + x^2\");\n-    p.setUnknownName(\"alpha\");\n-    checkPolynomial(p, \"-5 + 3 alpha + alpha^2\");\n-    p.setUnknownName(null);\n-    checkPolynomial(p, \"-5 + 3 x + x^2\");\n \n     checkPolynomial(new Polynomial.Rational(3l, -2l, 0l), \"-2 x + 3 x^2\");\n     checkPolynomial(new Polynomial.Rational(3l, -2l, 1l), \"1 - 2 x + 3 x^2\");\n \n     Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);\n     Polynomial.Rational p2 = new Polynomial.Rational(0l, -1l, 2l);\n-    assertTrue(Polynomial.Rational.add(p1, p2).isZero());\n+    assertTrue(p1.add(p2).isZero());\n \n-    p2 = new Polynomial.Rational(p1);\n-    p2.addToSelf(p2);\n+    p2 = p1.add(p1);\n     checkPolynomial(p2, \"-4 + 2 x\");\n \n     p1 = new Polynomial.Rational(2l, -4l, 1l);\n     p2 = new Polynomial.Rational(-2l, 3l, -1l);\n-    p1.addToSelf(p2);\n+    p1 = p1.add(p2);\n     assertEquals(1, p1.getDegree());\n     checkPolynomial(p1, \"-x\");\n \n   public void testSubtraction() {\n \n     Polynomial.Rational p1 = new Polynomial.Rational(1l, -2l);\n-    assertTrue(Polynomial.Rational.subtract(p1, p1).isZero());\n+    assertTrue(p1.subtract(p1).isZero());\n \n     Polynomial.Rational p2 = new Polynomial.Rational(6l, -2l);\n-    p2.subtractFromSelf(p1);\n+    p2 = p2.subtract(p1);\n     checkPolynomial(p2, \"5 x\");\n \n     p1 = new Polynomial.Rational(2l, -4l, 1l);\n     p2 = new Polynomial.Rational(2l, 3l, -1l);\n-    p1.subtractFromSelf(p2);\n+    p1 = p1.subtract(p2);\n     assertEquals(1, p1.getDegree());\n     checkPolynomial(p1, \"2 - 7 x\");\n \n \n     Polynomial.Rational p1 = new Polynomial.Rational(2l, -3l);\n     Polynomial.Rational p2 = new Polynomial.Rational(1l, 2l, 3l);\n-    checkPolynomial(Polynomial.Rational.multiply(p1, p2), \"-9 + x^2 + 2 x^3\");\n+    checkPolynomial(p1.multiply(p2), \"-9 + x^2 + 2 x^3\");\n \n     p1 = new Polynomial.Rational(1l, 0l);\n-    p2 = new Polynomial.Rational(p1);\n+    p2 = p1;\n     for (int i = 2; i < 10; ++i) {\n-      p2.multiplySelf(p1);\n+      p2 = p2.multiply(p1);\n       checkPolynomial(p2, \"x^\" + i);\n     }\n \n     checkPolynomial(p, \"3/4 - 1/6 x + 2/5 x^2\");\n     BigInteger lcm = p.getDenominatorsLCM();\n     assertEquals(BigInteger.valueOf(60l), lcm);\n-    p.multiplySelf(lcm);\n+    p = (Polynomial.Rational) p.multiply(lcm);\n     checkPolynomial(p, \"45 - 10 x + 24 x^2\");\n   }\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/RationalNumberTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/algebra/RationalNumberTest.java\n \n   public void testInvert() {\n \n-    RationalNumber f = new RationalNumber(2l, 4l);\n-    f.invertSelf();\n+    RationalNumber f = new RationalNumber(2l, 4l).invert();\n     checkValue(f, \"2\");\n-    f.invertSelf();\n+    f = f.invert();\n     checkValue(f, \"1/2\");\n \n-    f = new RationalNumber(120l);\n-    f.invertSelf();\n+    f = new RationalNumber(120l).invert();\n     checkValue(f, \"1/120\");\n \n     f = new RationalNumber(0l, 4l);\n     try {\n-      f.invertSelf();\n+      f.invert();\n       fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException e) {\n     } catch (Exception e) {\n     }\n \n     f = new RationalNumber(307692l, 999999l);\n-    RationalNumber fInverse = RationalNumber.invert(f);\n+    RationalNumber fInverse = f.invert();\n     checkValue(fInverse, \"13/4\");\n     checkValue(f, \"4/13\");\n \n   public void testAddition() {\n \n     RationalNumber f1 = new RationalNumber(4l, 6l);\n-    f1.addToSelf(f1);\n+    f1 = f1.add(f1);\n     checkValue(f1, \"4/3\");\n \n-    checkValue(RationalNumber.add(new RationalNumber(17l, 3l),\n-                                  new RationalNumber(-17l, 3l)),\n+    checkValue(new RationalNumber(17l, 3l).add(new RationalNumber(-17l, 3l)),\n                \"0\");\n-    checkValue(RationalNumber.add(new RationalNumber(2l, 3l),\n-                                  new RationalNumber(3l, 4l)),\n+    checkValue(new RationalNumber(2l, 3l).add(new RationalNumber(3l, 4l)),\n                \"17/12\");\n-    checkValue(RationalNumber.add(new RationalNumber(1l, 6l),\n-                                  new RationalNumber(2l, 6l)),\n+    checkValue(new RationalNumber(1l, 6l).add(new RationalNumber(2l, 6l)),\n                \"1/2\");\n-    checkValue(RationalNumber.add(new RationalNumber(4l, 5l),\n-                                  new RationalNumber(-3l, 4l)),\n+    checkValue(new RationalNumber(4l, 5l).add(new RationalNumber(-3l, 4l)),\n                \"1/20\");\n-    checkValue(RationalNumber.add(new RationalNumber(-3l, 4l),\n-                                  new RationalNumber(4l, 5l)),\n+    checkValue(new RationalNumber(-3l, 4l).add(new RationalNumber(4l, 5l)),\n                \"1/20\");\n \n   }\n   public void testSubtraction() {\n \n     RationalNumber f1 = new RationalNumber(4l, 6l);\n-    f1.subtractFromSelf(f1);\n+    f1 = f1.subtract(f1);\n     checkValue(f1, \"0\");\n \n-    checkValue(RationalNumber.subtract(new RationalNumber(7l, 3l),\n-                                       new RationalNumber(-7l, 3l)),\n+    checkValue(new RationalNumber(7l, 3l).subtract(new RationalNumber(-7l, 3l)),\n                \"14/3\");\n \n-    checkValue(RationalNumber.subtract(new RationalNumber(3l, 4l),\n-                                       new RationalNumber(2l, 3l)),\n+    checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(2l, 3l)),\n                \"1/12\");\n-    checkValue(RationalNumber.subtract(new RationalNumber(3l, 4l),\n-                                       new RationalNumber(-2l, 3l)),\n+    checkValue(new RationalNumber(3l, 4l).subtract(new RationalNumber(-2l, 3l)),\n                \"17/12\");\n-    checkValue(RationalNumber.subtract(new RationalNumber(-3l, 4l),\n-                                       new RationalNumber(2l, 3l)),\n+    checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(2l, 3l)),\n                \"-17/12\");\n-    checkValue(RationalNumber.subtract(new RationalNumber(-3l, 4l),\n-                                       new RationalNumber(-2l, 3l)),\n+    checkValue(new RationalNumber(-3l, 4l).subtract(new RationalNumber(-2l, 3l)),\n                \"-1/12\");\n \n-    checkValue(RationalNumber.subtract(new RationalNumber(2l, 3l),\n-                                       new RationalNumber(3l, 4l)),\n+    checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(3l, 4l)),\n                \"-1/12\");\n-    checkValue(RationalNumber.subtract(new RationalNumber(-2l, 3l),\n-                                       new RationalNumber(3l, 4l)),\n+    checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(3l, 4l)),\n                \"-17/12\");\n-    checkValue(RationalNumber.subtract(new RationalNumber(2l, 3l),\n-                                       new RationalNumber(-3l, 4l)),\n+    checkValue(new RationalNumber(2l, 3l).subtract(new RationalNumber(-3l, 4l)),\n                \"17/12\");\n-    checkValue(RationalNumber.subtract(new RationalNumber(-2l, 3l),\n-                                       new RationalNumber(-3l, 4l)),\n+    checkValue(new RationalNumber(-2l, 3l).subtract(new RationalNumber(-3l, 4l)),\n                \"1/12\");\n \n-    checkValue(RationalNumber.subtract(new RationalNumber(1l, 6l),\n-                                       new RationalNumber(2l, 6l)),\n+    checkValue(new RationalNumber(1l, 6l).subtract(new RationalNumber(2l, 6l)),\n                \"-1/6\");\n-    checkValue(RationalNumber.subtract(new RationalNumber(1l, 2l),\n-                                       new RationalNumber(1l, 6l)),\n+    checkValue(new RationalNumber(1l, 2l).subtract(new RationalNumber(1l, 6l)),\n                \"1/3\");\n \n   }\n   public void testMultiplication() {\n \n     RationalNumber f = new RationalNumber(2l, 3l);\n-    f.multiplySelf(new RationalNumber(9l,4l));\n+    f = f.multiply(new RationalNumber(9l,4l));\n     checkValue(f, \"3/2\");\n \n-    checkValue(RationalNumber.multiply(new RationalNumber(1l, 2l),\n-                                       new RationalNumber(0l)),\n+    checkValue(new RationalNumber(1l, 2l).multiply(new RationalNumber(0l)),\n                \"0\");\n-    checkValue(RationalNumber.multiply(new RationalNumber(4l, 15l),\n-                                       new RationalNumber(-5l, 2l)),\n+    checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(-5l, 2l)),\n                \"-2/3\");\n-    checkValue(RationalNumber.multiply(new RationalNumber(-4l, 15l),\n-                                       new RationalNumber(5l, 2l)),\n+    checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(5l, 2l)),\n                \"-2/3\");\n-    checkValue(RationalNumber.multiply(new RationalNumber(4l, 15l),\n-                                       new RationalNumber(5l, 2l)),\n+    checkValue(new RationalNumber(4l, 15l).multiply(new RationalNumber(5l, 2l)),\n                \"2/3\");\n-    checkValue(RationalNumber.multiply(new RationalNumber(-4l, 15l),\n-                                       new RationalNumber(-5l, 2l)),\n+    checkValue(new RationalNumber(-4l, 15l).multiply(new RationalNumber(-5l, 2l)),\n                \"2/3\");\n \n   }\n   public void testDivision() {\n \n     RationalNumber f = new RationalNumber(2l, 3l);\n-    f.divideSelf(new RationalNumber(4l,9l));\n+    f = f.divide(new RationalNumber(4l,9l));\n     checkValue(f, \"3/2\");\n \n     try {\n-      RationalNumber.divide(new RationalNumber(1l, 2l),\n-                            new RationalNumber(0l));\n+      new RationalNumber(1l, 2l).divide(new RationalNumber(0l));\n       fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException e) {\n     } catch (Exception e) {\n       fail(\"wrong exception caught\");\n     }\n \n-    checkValue(RationalNumber.divide(new RationalNumber(4l, 15l),\n-                                     new RationalNumber(-2l, 5l)),\n+    checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(-2l, 5l)),\n                \"-2/3\");\n-    checkValue(RationalNumber.divide(new RationalNumber(-4l, 15l),\n-                                     new RationalNumber(2l, 5l)),\n+    checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(2l, 5l)),\n                \"-2/3\");\n-    checkValue(RationalNumber.divide(new RationalNumber(4l, 15l),\n-                                     new RationalNumber(2l, 5l)),\n+    checkValue(new RationalNumber(4l, 15l).divide(new RationalNumber(2l, 5l)),\n                \"2/3\");\n-    checkValue(RationalNumber.divide(new RationalNumber(-4l, 15l),\n-                                     new RationalNumber(-2l, 5l)),\n+    checkValue(new RationalNumber(-4l, 15l).divide(new RationalNumber(-2l, 5l)),\n                \"2/3\");\n \n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/AllTests.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/AllTests.java\n     suite.addTest(WeightedMeasurementTest.suite());\n     suite.addTest(GaussNewtonEstimatorTest.suite());\n     suite.addTest(LevenbergMarquardtEstimatorTest.suite());\n+    suite.addTest(MinpackTest.suite());\n \n     return suite; \n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/GaussNewtonEstimatorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/GaussNewtonEstimatorTest.java\n     for (int i = 0; i < gridSize; ++i) {\n       for (int j = 0; j < gridSize; ++j) {\n \n-        String name            = new Integer(k).toString();\n+        String name            = Integer.toString(k);\n         perfectPars[2 * k]     = new EstimatedParameter(\"x\" + name, i);\n         perfectPars[2 * k + 1] = new EstimatedParameter(\"y\" + name, j);\n         ++k;\n \n   }\n \n-  private class Distance extends WeightedMeasurement {\n+  private static class Distance extends WeightedMeasurement {\n \n     public Distance(double weight, double measuredValue,\n                     EstimatedParameter x1, EstimatedParameter y1,\n   }\n \n   public WeightedMeasurement[] getMeasurements() {\n-    return measurements;\n+    return (WeightedMeasurement[]) measurements.clone();\n   }\n \n   public EstimatedParameter[] getUnboundParameters() {\n-    return unboundPars;\n+    return (EstimatedParameter[]) unboundPars.clone();\n   }\n \n   public EstimatedParameter[] getAllParameters() {\n-    return randomizedPars;\n+    return (EstimatedParameter[]) randomizedPars.clone();\n   }\n \n   private EstimatedParameter[]  perfectPars;\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/LevenbergMarquardtEstimatorTest.java\n package org.spaceroots.mantissa.estimation;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.IdentityHashMap;\n import java.util.Iterator;\n import java.util.Set;\n     assertEquals( 0.20750021499570379,  circle.getY(),      1.0e-8);\n   }\n \n-  public void testMinpackLinearFullRank()\n-    throws EstimationException {\n-    minpackTest(new LinearFullRankFunction(10, 5, 1.0,\n-                                           5.0, 2.23606797749979), false);\n-    minpackTest(new LinearFullRankFunction(50, 5, 1.0,\n-                                           8.06225774829855, 6.70820393249937), false);\n-  }\n-\n-  public void testMinpackLinearRank1()\n-    throws EstimationException {\n-    minpackTest(new LinearRank1Function(10, 5, 1.0,\n-                                        291.521868819476, 1.4638501094228), false);\n-    minpackTest(new LinearRank1Function(50, 5, 1.0,\n-                                        3101.60039334535, 3.48263016573496), false);\n-  }\n-\n-  public void testMinpackLinearRank1ZeroColsAndRows()\n-    throws EstimationException {\n-    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);\n-    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);\n-  }\n-\n-  public void testMinpackRosenbrok()\n-    throws EstimationException {\n-    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n-                                       Math.sqrt(24.2)), false);\n-    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },\n-                                       Math.sqrt(1795769.0)), false);\n-    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },\n-                                       11.0 * Math.sqrt(169000121.0)), false);\n-  }\n-\n-  public void testMinpackHelicalValley()\n-    throws EstimationException {\n-    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },\n-                                          50.0), false);\n-    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },\n-                                          102.95630140987), false);\n-    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},\n-                                          991.261822123701), false);\n-  }\n-    \n-  public void testMinpackPowellSingular()\n-    throws EstimationException {\n-    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n-                                           14.6628782986152), false);\n-    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },\n-                                           1270.9838708654), false);\n-    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },\n-                                           126887.903284750), false);\n-  }\n-    \n-  public void testMinpackFreudensteinRoth()\n-    throws EstimationException {\n-    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n-                                             20.0124960961895, 6.99887517584575,\n-                                             new double[] {\n-                                               11.4124844654993,\n-                                               -0.896827913731509\n-                                             }), false);\n-    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n-                                             12432.833948863, 6.9988751744895,\n-                                             new double[] {\n-                                               11.4130046614746,\n-                                               -0.896796038685958\n-                                             }), false);\n-    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n-                                             11426454.595762, 6.99887517242903,\n-                                             new double[] {\n-                                               11.4127817857886,\n-                                               -0.89680510749204\n-                                             }), false);\n-  }\n-    \n-  public void testMinpackBard()\n-    throws EstimationException {\n-    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n-                                 new double[] {\n-                                   0.0824105765758334,\n-                                   1.1330366534715,\n-                                   2.34369463894115\n-                                 }), false);\n-    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,\n-                                 new double[] {\n-                                   0.840666673818329,\n-                                   -158848033.259565,\n-                                   -164378671.653535\n-                                 }), false);\n-    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,\n-                                 new double[] {\n-                                   0.840666673867645,\n-                                   -158946167.205518,\n-                                   -164464906.857771\n-                                 }), false);\n-  }\n-    \n-  public void testMinpackKowalikOsborne()\n-    throws EstimationException {\n-    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n-                                           0.0728915102882945,\n-                                           0.017535837721129,\n-                                           new double[] {\n-                                             0.192807810476249,\n-                                             0.191262653354071,\n-                                             0.123052801046931,\n-                                             0.136053221150517\n-                                           }), false);\n-    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },\n-                                           2.97937007555202,\n-                                           0.032052192917937,\n-                                           new double[] {\n-                                             728675.473768287,\n-                                             -14.0758803129393,\n-                                             -32977797.7841797,\n-                                             -20571594.1977912\n-                                           }), false);\n-    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },\n-                                           29.9590617016037,\n-                                           0.0175364017658228,\n-                                           new double[] {\n-                                             0.192948328597594,\n-                                             0.188053165007911,\n-                                             0.122430604321144,\n-                                             0.134575665392506\n-                                           }), true);\n-  }\n-    \n-  public void testMinpackMeyer()\n-    throws EstimationException {\n-    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n-                                  41153.4665543031, 9.37794514651874,\n-                                  new double[] {\n-                                    0.00560963647102661,\n-                                    6181.34634628659,\n-                                    345.223634624144\n-                                  }), false);\n-    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },\n-                                  4168216.89130846, 792.917871779501,\n-                                  new double[] {\n-                                    1.42367074157994e-11,\n-                                    33695.7133432541,\n-                                    901.268527953801\n-                                  }), true);\n-  }\n-    \n-  public void testMinpackWatson()\n-    throws EstimationException {\n-  \n-    minpackTest(new WatsonFunction(6, 0.0,\n-                                   5.47722557505166, 0.0478295939097601,\n-                                   new double[] {\n-                                     -0.0157249615083782, 1.01243488232965,\n-                                     -0.232991722387673,  1.26043101102818,\n-                                     -1.51373031394421,   0.99299727291842\n-                                   }), false);\n-    minpackTest(new WatsonFunction(6, 10.0,\n-                                   6433.12578950026, 0.0478295939096951,\n-                                   new double[] {\n-                                     -0.0157251901386677, 1.01243485860105,\n-                                     -0.232991545843829,  1.26042932089163,\n-                                     -1.51372776706575,   0.99299573426328\n-                                   }), false);\n-    minpackTest(new WatsonFunction(6, 100.0,\n-                                   674256.040605213, 0.047829593911544,\n-                                   new double[] {\n-                                    -0.0157247019712586, 1.01243490925658,\n-                                    -0.232991922761641,  1.26043292929555,\n-                                    -1.51373320452707,   0.99299901922322\n-                                   }), false);\n-\n-    minpackTest(new WatsonFunction(9, 0.0,\n-                                   5.47722557505166, 0.00118311459212420,\n-                                   new double[] {\n-                                    -0.153070644166722e-4, 0.999789703934597,\n-                                     0.0147639634910978,   0.146342330145992,\n-                                     1.00082109454817,    -2.61773112070507,\n-                                     4.10440313943354,    -3.14361226236241,\n-                                     1.05262640378759\n-                                   }), false);\n-    minpackTest(new WatsonFunction(9, 10.0,\n-                                   12088.127069307, 0.00118311459212513,\n-                                   new double[] {\n-                                   -0.153071334849279e-4, 0.999789703941234,\n-                                    0.0147639629786217,   0.146342334818836,\n-                                    1.00082107321386,    -2.61773107084722,\n-                                    4.10440307655564,    -3.14361222178686,\n-                                    1.05262639322589\n-                                   }), false);\n-    minpackTest(new WatsonFunction(9, 100.0,\n-                                   1269109.29043834, 0.00118311459212384,\n-                                   new double[] {\n-                                    -0.153069523352176e-4, 0.999789703958371,\n-                                     0.0147639625185392,   0.146342341096326,\n-                                     1.00082104729164,    -2.61773101573645,\n-                                     4.10440301427286,    -3.14361218602503,\n-                                     1.05262638516774\n-                                   }), false);\n-\n-    minpackTest(new WatsonFunction(12, 0.0,\n-                                   5.47722557505166, 0.217310402535861e-4,\n-                                   new double[] {\n-                                    -0.660266001396382e-8, 1.00000164411833,\n-                                    -0.000563932146980154, 0.347820540050756,\n-                                    -0.156731500244233,    1.05281515825593,\n-                                    -3.24727109519451,     7.2884347837505,\n-                                   -10.271848098614,       9.07411353715783,\n-                                    -4.54137541918194,     1.01201187975044\n-                                   }), false);\n-    minpackTest(new WatsonFunction(12, 10.0,\n-                                   19220.7589790951, 0.217310402518509e-4,\n-                                   new double[] {\n-                                    -0.663710223017410e-8, 1.00000164411787,\n-                                    -0.000563932208347327, 0.347820540486998,\n-                                    -0.156731503955652,    1.05281517654573,\n-                                    -3.2472711515214,      7.28843489430665,\n-                                   -10.2718482369638,      9.07411364383733,\n-                                    -4.54137546533666,     1.01201188830857\n-                                   }), false);\n-    minpackTest(new WatsonFunction(12, 100.0,\n-                                   2018918.04462367, 0.217310402539845e-4,\n-                                   new double[] {\n-                                    -0.663806046485249e-8, 1.00000164411786,\n-                                    -0.000563932210324959, 0.347820540503588,\n-                                    -0.156731504091375,    1.05281517718031,\n-                                    -3.24727115337025,     7.28843489775302,\n-                                   -10.2718482410813,      9.07411364688464,\n-                                    -4.54137546660822,     1.0120118885369\n-                                   }), false);\n-\n-  }\n-    \n-  public void testMinpackBox3Dimensional()\n-  throws EstimationException {\n-    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n-                                            32.1115837449572), false);\n-  }\n-    \n-  public void testMinpackJennrichSampson()\n-    throws EstimationException {\n-    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n-                                            64.5856498144943, 11.1517793413499,\n-                                            new double[] {\n-                                             0.257819926636811, 0.257829976764542\n-                                            }), false);\n-  }\n-\n-  public void testMinpackBrownDennis()\n-    throws EstimationException {\n-    minpackTest(new BrownDennisFunction(20,\n-                                        new double[] { 25.0, 5.0, -5.0, -1.0 },\n-                                        2815.43839161816, 292.954288244866,\n-                                        new double[] {\n-                                         -11.59125141003, 13.2024883984741,\n-                                         -0.403574643314272, 0.236736269844604\n-                                        }), false);\n-    minpackTest(new BrownDennisFunction(20,\n-                                        new double[] { 250.0, 50.0, -50.0, -10.0 },\n-                                        555073.354173069, 292.954270581415,\n-                                        new double[] {\n-                                         -11.5959274272203, 13.2041866926242,\n-                                         -0.403417362841545, 0.236771143410386\n-                                       }), false);\n-    minpackTest(new BrownDennisFunction(20,\n-                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },\n-                                        61211252.2338581, 292.954306151134,\n-                                        new double[] {\n-                                         -11.5902596937374, 13.2020628854665,\n-                                         -0.403688070279258, 0.236665033746463\n-                                        }), false);\n-  }\n-    \n-  public void testMinpackChebyquad()\n-    throws EstimationException {\n-    minpackTest(new ChebyquadFunction(1, 8, 1.0,\n-                                      1.88623796907732, 1.88623796907732,\n-                                      new double[] { 0.5 }), false);\n-    minpackTest(new ChebyquadFunction(1, 8, 10.0,\n-                                      5383344372.34005, 1.88424820499951,\n-                                      new double[] { 0.9817314924684 }), false);\n-    minpackTest(new ChebyquadFunction(1, 8, 100.0,\n-                                      0.118088726698392e19, 1.88424820499347,\n-                                      new double[] { 0.9817314852934 }), false);\n-    minpackTest(new ChebyquadFunction(8, 8, 1.0,\n-                                      0.196513862833975, 0.0593032355046727,\n-                                      new double[] {\n-                                        0.0431536648587336, 0.193091637843267,\n-                                        0.266328593812698,  0.499999334628884,\n-                                        0.500000665371116,  0.733671406187302,\n-                                        0.806908362156733,  0.956846335141266\n-                                      }), false);\n-    minpackTest(new ChebyquadFunction(9, 9, 1.0,\n-                                      0.16994993465202, 0.0,\n-                                      new double[] {\n-                                        0.0442053461357828, 0.199490672309881,\n-                                        0.23561910847106,   0.416046907892598,\n-                                        0.5,                0.583953092107402,\n-                                        0.764380891528940,  0.800509327690119,\n-                                        0.955794653864217\n-                                      }), false);\n-    minpackTest(new ChebyquadFunction(10, 10, 1.0,\n-                                      0.183747831178711, 0.0806471004038253,\n-                                      new double[] {\n-                                        0.0596202671753563, 0.166708783805937,\n-                                        0.239171018813509,  0.398885290346268,\n-                                        0.398883667870681,  0.601116332129320,\n-                                        0.60111470965373,   0.760828981186491,\n-                                        0.833291216194063,  0.940379732824644\n-                                      }), false);\n-  }\n-    \n-  public void testMinpackBrownAlmostLinear()\n-    throws EstimationException {\n-    minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n-                                              16.5302162063499, 0.0,\n-                                              new double[] {\n-                                                0.979430303349862, 0.979430303349862,\n-                                                0.979430303349862, 0.979430303349862,\n-                                                0.979430303349862, 0.979430303349862,\n-                                                0.979430303349862, 0.979430303349862,\n-                                                0.979430303349862, 1.20569696650138\n-                                              }), false);\n-    minpackTest(new BrownAlmostLinearFunction(10, 5.0,\n-                                              9765624.00089211, 0.0,\n-                                              new double[] {\n-                                               0.979430303349865, 0.979430303349865,\n-                                               0.979430303349865, 0.979430303349865,\n-                                               0.979430303349865, 0.979430303349865,\n-                                               0.979430303349865, 0.979430303349865,\n-                                               0.979430303349865, 1.20569696650135\n-                                              }), false);  \n-    minpackTest(new BrownAlmostLinearFunction(10, 50.0,\n-                                              0.9765625e17, 0.0,\n-                                              new double[] {\n-                                                1.0, 1.0, 1.0, 1.0, 1.0,\n-                                                1.0, 1.0, 1.0, 1.0, 1.0\n-                                              }), false);\n-    minpackTest(new BrownAlmostLinearFunction(30, 0.5,\n-                                              83.476044467848, 0.0,\n-                                              new double[] {\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 0.997754216442807,\n-                                                0.997754216442807, 1.06737350671578\n-                                              }), false);\n-    minpackTest(new BrownAlmostLinearFunction(40, 0.5,\n-                                              128.026364472323, 0.0,\n-                                              new double[] {\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                1.00000000000002, 1.00000000000002,\n-                                                0.999999999999121\n-                                              }), false);\n-    }\n-    \n-  public void testMinpackOsborne1()\n-    throws EstimationException {\n-      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n-                                       0.937564021037838, 0.00739249260904843,\n-                                       new double[] {\n-                                         0.375410049244025, 1.93584654543108,\n-                                        -1.46468676748716, 0.0128675339110439,\n-                                         0.0221227011813076\n-                                       }), false);\n-    }\n-    \n-  public void testMinpackOsborne2()\n-    throws EstimationException {\n-      \n-    minpackTest(new Osborne2Function(new double[] {\n-                                       1.3, 0.65, 0.65, 0.7, 0.6,\n-                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5\n-                                     },\n-                                     1.44686540984712, 0.20034404483314,\n-                                     new double[] {\n-                                       1.30997663810096,  0.43155248076,\n-                                       0.633661261602859, 0.599428560991695,\n-                                       0.754179768272449, 0.904300082378518,\n-                                       1.36579949521007, 4.82373199748107,\n-                                       2.39868475104871, 4.56887554791452,\n-                                       5.67534206273052\n-                                     }), false);\n-  }\n-\n-  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n-    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n-    estimator.setMaxCostEval(100 * (function.getN() + 1));\n-    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n-    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n-    estimator.setOrthoTolerance(2.22044604926e-16);\n-    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));\n-    try {\n-      estimator.estimate(function);\n-      assertFalse(exceptionExpected);\n-    } catch (EstimationException lsse) {\n-      assertTrue(exceptionExpected);\n-    }\n-    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));\n-    assertTrue(function.checkTheoreticalMinParams());\n-  }\n-\n   private static class LinearProblem implements EstimationProblem {\n \n     public LinearProblem(LinearMeasurement[] measurements) {\n \n   }\n \n-  private static abstract class MinpackFunction implements EstimationProblem {\n- \n-    protected MinpackFunction(int m,\n-                              double[] startParams,\n-                              double   theoreticalStartCost,\n-                              double   theoreticalMinCost,\n-                              double[] theoreticalMinParams) {\n-      this.m = m;\n-      this.n = startParams.length;\n-      parameters = new EstimatedParameter[n];\n-      for (int i = 0; i < n; ++i) {\n-        parameters[i] = new EstimatedParameter(\"p\" + i, startParams[i]);\n-      }\n-      this.theoreticalStartCost = theoreticalStartCost;\n-      this.theoreticalMinCost   = theoreticalMinCost;\n-      this.theoreticalMinParams = theoreticalMinParams;\n-      this.costAccuracy         = 1.0e-8;\n-      this.paramsAccuracy       = 1.0e-5;\n-    }\n-\n-    protected static double[] buildArray(int n, double x) {\n-      double[] array = new double[n];\n-      Arrays.fill(array, x);\n-      return array;\n-    }\n-\n-    protected void setCostAccuracy(double costAccuracy) {\n-      this.costAccuracy = costAccuracy;\n-    }\n-\n-    protected void setParamsAccuracy(double paramsAccuracy) {\n-      this.paramsAccuracy = paramsAccuracy;\n-    }\n-\n-    public int getN() {\n-      return parameters.length;\n-    }\n-\n-    public boolean checkTheoreticalStartCost(double rms) {\n-      double threshold = costAccuracy * (1.0 + theoreticalStartCost);\n-      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;\n-    }\n-\n-    public boolean checkTheoreticalMinCost(double rms) {\n-      double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n-     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n-    }\n-\n-    public boolean checkTheoreticalMinParams() {\n-      if (theoreticalMinParams != null) {\n-        for (int i = 0; i < theoreticalMinParams.length; ++i) {\n-          double mi = theoreticalMinParams[i];\n-          double vi = parameters[i].getEstimate();\n-          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n-            return false;\n-          }\n-        }\n-      }\n-      return true;\n-    }\n- \n-    public WeightedMeasurement[] getMeasurements() {\n-      WeightedMeasurement[] measurements = new WeightedMeasurement[m];\n-      for (int i = 0; i < m; ++i) {\n-        measurements[i] = new MinpackMeasurement(i);\n-      }\n-      return measurements;\n-    }\n-\n-    public EstimatedParameter[] getUnboundParameters() {\n-      return parameters;\n-    }\n-\n-    public EstimatedParameter[] getAllParameters() {\n-      return parameters;\n-    }\n-\n-    protected abstract double[][] getJacobian();\n-\n-    protected abstract double[] getResiduals();\n-\n-    private class MinpackMeasurement extends WeightedMeasurement {\n-\n-      public MinpackMeasurement(int index) {\n-        super(1.0, 0.0);\n-        this.index = index;\n-      }\n-\n-      public double getTheoreticalValue() {\n-        // this is obviously NOT efficient as we recompute the whole vector\n-        // each time we need only one element, but it is only for test\n-        // purposes and is simpler to check.\n-        // This implementation should NOT be taken as an example, it is ugly!\n-        return getResiduals()[index];\n-      }\n-\n-      public double getPartial(EstimatedParameter parameter) {\n-        // this is obviously NOT efficient as we recompute the whole jacobian\n-        // each time we need only one element, but it is only for test\n-        // purposes and is simpler to check.\n-        // This implementation should NOT be taken as an example, it is ugly!\n-        for (int j = 0; j < n; ++j) {\n-          if (parameter == parameters[j]) {\n-            return getJacobian()[index][j];\n-          }\n-        }\n-        return 0;\n-      }\n-\n-      private int index;\n-      private static final long serialVersionUID = 1L;\n-\n-    }\n-\n-    protected int                  n;\n-    protected int                  m;\n-    protected EstimatedParameter[] parameters;\n-    protected double               theoreticalStartCost;\n-    protected double               theoreticalMinCost;\n-    protected double[]             theoreticalMinParams;\n-    protected double               costAccuracy;\n-    protected double               paramsAccuracy;\n-\n-  }\n-\n-  private static class LinearFullRankFunction extends MinpackFunction {\n-\n-    public LinearFullRankFunction(int m, int n, double x0,\n-                                  double theoreticalStartCost,\n-                                  double theoreticalMinCost) {\n-      super(m, buildArray(n, x0), theoreticalStartCost,\n-            theoreticalMinCost, buildArray(n, -1.0));\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double t = 2.0 / m;\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        jacobian[i] = new double[n];\n-        for (int j = 0; j < n; ++j) {\n-          jacobian[i][j] = (i == j) ? (1 - t) : -t;\n-        }\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double sum = 0;\n-      for (int i = 0; i < n; ++i) {\n-        sum += parameters[i].getEstimate();\n-      }\n-      double t  = 1 + 2 * sum / m;\n-      double[] f = new double[m];\n-      for (int i = 0; i < n; ++i) {\n-        f[i] = parameters[i].getEstimate() - t;\n-      }\n-      Arrays.fill(f, n, m, -t);\n-      return f;\n-    }\n-\n-  }\n-\n-  private static class LinearRank1Function extends MinpackFunction {\n-\n-    public LinearRank1Function(int m, int n, double x0,\n-                                  double theoreticalStartCost,\n-                                  double theoreticalMinCost) {\n-      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        jacobian[i] = new double[n];\n-        for (int j = 0; j < n; ++j) {\n-          jacobian[i][j] = (i + 1) * (j + 1);\n-        }\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double[] f = new double[m];\n-      double sum = 0;\n-      for (int i = 0; i < n; ++i) {\n-        sum += (i + 1) * parameters[i].getEstimate();\n-      }\n-      for (int i = 0; i < m; ++i) {\n-        f[i] = (i + 1) * sum - 1;\n-      }\n-      return f;\n-    }\n-\n-  }\n-\n-  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {\n-\n-    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n-      super(m, buildArray(n, x0),\n-            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),\n-            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n-            null);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        jacobian[i] = new double[n];\n-        jacobian[i][0] = 0;\n-        for (int j = 1; j < (n - 1); ++j) {\n-          if (i == 0) {\n-            jacobian[i][j] = 0;\n-          } else if (i != (m - 1)) {\n-            jacobian[i][j] = i * (j + 1);\n-          } else {\n-            jacobian[i][j] = 0;\n-          }\n-        }\n-        jacobian[i][n - 1] = 0;\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double[] f = new double[m];\n-      double sum = 0;\n-      for (int i = 1; i < (n - 1); ++i) {\n-        sum += (i + 1) * parameters[i].getEstimate();\n-      }\n-      for (int i = 0; i < (m - 1); ++i) {\n-        f[i] = i * sum - 1;\n-      }\n-      f[m - 1] = -1;\n-      return f;\n-    }\n-\n-  }\n-\n-  private static class RosenbrockFunction extends MinpackFunction {\n-\n-    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {\n-      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x1 = parameters[0].getEstimate();\n-      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };\n-    }\n-\n-  }\n-\n-  private static class HelicalValleyFunction extends MinpackFunction {\n-\n-    public HelicalValleyFunction(double[] startParams,\n-                                 double theoreticalStartCost) {\n-      super(3, startParams, theoreticalStartCost, 0.0,\n-            new double[] { 1.0, 0.0, 0.0 });\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double tmpSquare = x1 * x1 + x2 * x2;\n-      double tmp1 = twoPi * tmpSquare;\n-      double tmp2 = Math.sqrt(tmpSquare);\n-      return new double[][] {\n-        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },\n-        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },\n-        { 0, 0, 1 }\n-      };\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double tmp1;\n-      if (x1 == 0) {\n-        tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n-      } else {\n-        tmp1 = Math.atan(x2 / x1) / twoPi;\n-        if (x1 < 0) {\n-          tmp1 += 0.5;\n-        }\n-      }\n-      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);\n-      return new double[] {\n-        10.0 * (x3 - 10 * tmp1),\n-        10.0 * (tmp2 - 1),\n-        x3\n-      };\n-    }\n-\n-    private static final double twoPi = 2.0 * Math.PI;\n-\n-  }\n-\n-  private static class PowellSingularFunction extends MinpackFunction {\n-\n-    public PowellSingularFunction(double[] startParams,\n-                                  double theoreticalStartCost) {\n-      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n-      return new double[][] {\n-        { 1, 10, 0, 0 },\n-        { 0, 0, sqrt5, -sqrt5 },\n-        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },\n-        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }\n-      };\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n-      return new double[] {\n-        x1 + 10 * x2,\n-        sqrt5 * (x3 - x4),\n-        (x2 - 2 * x3) * (x2 - 2 * x3),\n-        sqrt10 * (x1 - x4) * (x1 - x4)\n-      };\n-    }\n-\n-    private static final double sqrt5  = Math.sqrt( 5.0);\n-    private static final double sqrt10 = Math.sqrt(10.0);\n-\n-  }\n-\n-  private static class FreudensteinRothFunction extends MinpackFunction {\n-\n-    public FreudensteinRothFunction(double[] startParams,\n-                                    double theoreticalStartCost,\n-                                    double theoreticalMinCost,\n-                                    double[] theoreticalMinParams) {\n-      super(2, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x2 = parameters[1].getEstimate();\n-      return new double[][] {\n-        { 1, x2 * (10 - 3 * x2) -  2 },\n-        { 1, x2 * ( 2 + 3 * x2) - 14, }\n-      };\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      return new double[] {\n-       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,\n-       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2\n-      };\n-    }\n-\n-  }\n-\n-  private static class BardFunction extends MinpackFunction {\n-\n-    public BardFunction(double x0,\n-                        double theoreticalStartCost,\n-                        double theoreticalMinCost,\n-                        double[] theoreticalMinParams) {\n-      super(15, buildArray(3, x0), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double tmp1 = i  + 1;\n-        double tmp2 = 15 - i;\n-        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n-        double tmp4 = x2 * tmp2 + x3 * tmp3;\n-        tmp4 *= tmp4;\n-        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        double tmp1 = i + 1;\n-        double tmp2 = 15 - i;\n-        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n-        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));\n-      }\n-      return f;\n-    }\n-\n-    private static final double[] y = {\n-      0.14, 0.18, 0.22, 0.25, 0.29,\n-      0.32, 0.35, 0.39, 0.37, 0.58,\n-      0.73, 0.96, 1.34, 2.10, 4.39\n-    };\n-\n-  }\n-\n-  private static class KowalikOsborneFunction extends MinpackFunction {\n-\n-    public KowalikOsborneFunction(double[] startParams,\n-                                  double theoreticalStartCost,\n-                                  double theoreticalMinCost,\n-                                  double[] theoreticalMinParams) {\n-      super(11, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-      if (theoreticalStartCost > 20.0) {\n-        setCostAccuracy(2.0e-4);\n-        setParamsAccuracy(5.0e-3);\n-      }\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double   x4 = parameters[3].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double tmp = v[i] * (v[i] + x3) + x4;\n-        double j1  = -v[i] * (v[i] + x2) / tmp;\n-        double j2  = -v[i] * x1 / tmp;\n-        double j3  = j1 * j2;\n-        double j4  = j3 / v[i];\n-        jacobian[i] = new double[] { j1, j2, j3, j4 };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);\n-      }\n-      return f;\n-    }\n-\n-    private static final double[] v = {\n-      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625\n-    };\n-\n-    private static final double[] y = {\n-      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,\n-      0.0456, 0.0342, 0.0323, 0.0235, 0.0246\n-    };\n-\n-  }\n-\n-  private static class MeyerFunction extends MinpackFunction {\n-\n-    public MeyerFunction(double[] startParams,\n-                         double theoreticalStartCost,\n-                         double theoreticalMinCost,\n-                         double[] theoreticalMinParams) {\n-      super(16, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-      if (theoreticalStartCost > 1.0e6) {\n-        setCostAccuracy(7.0e-3);\n-        setParamsAccuracy(2.0e-2);\n-      }\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = 5.0 * (i + 1) + 45.0 + x3;\n-        double tmp1 = x2 / temp;\n-        double tmp2 = Math.exp(tmp1);\n-        double tmp3 = x1 * tmp2 / temp;\n-        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n-      }\n-     return f;\n-    }\n-\n-    private static final double[] y = {\n-      34780.0, 28610.0, 23650.0, 19630.0,\n-      16370.0, 13720.0, 11540.0,  9744.0,\n-       8261.0,  7030.0,  6005.0,  5147.0,\n-       4427.0,  3820.0,  3307.0,  2872.0                  \n-    };\n-\n-  }\n-\n-  private static class WatsonFunction extends MinpackFunction {\n-\n-    public WatsonFunction(int n, double x0,\n-                          double theoreticalStartCost,\n-                          double theoreticalMinCost,\n-                          double[] theoreticalMinParams) {\n-      super(31, buildArray(n, x0), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-\n-      double[][] jacobian = new double[m][];\n-\n-      for (int i = 0; i < (m - 2); ++i) {\n-        double div = (i + 1) / 29.0;\n-        double s2  = 0.0;\n-        double dx  = 1.0;\n-        for (int j = 0; j < n; ++j) {\n-          s2 += dx * parameters[j].getEstimate();\n-          dx *= div;\n-        }\n-        double temp= 2 * div * s2;\n-        dx = 1.0 / div;\n-        jacobian[i] = new double[n];\n-        for (int j = 0; j < n; ++j) {\n-          jacobian[i][j] = dx * (j - temp);\n-          dx *= div;\n-        }\n-      }\n-\n-      jacobian[m - 2]    = new double[n];\n-      jacobian[m - 2][0] = 1;\n-\n-      jacobian[m - 1]   = new double[n];\n-      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();\n-      jacobian[m - 1][1]= 1;\n-\n-      return jacobian;\n-\n-    }\n-\n-    protected double[] getResiduals() {\n-     double[] f = new double[m];\n-     for (int i = 0; i < (m - 2); ++i) {\n-       double div = (i + 1) / 29.0;\n-       double s1 = 0;\n-       double dx = 1;\n-       for (int j = 1; j < n; ++j) {\n-         s1 += j * dx * parameters[j].getEstimate();\n-         dx *= div;\n-       }\n-       double s2 =0;\n-       dx =1;\n-       for (int j = 0; j < n; ++j) {\n-         s2 += dx * parameters[j].getEstimate();\n-         dx *= div;\n-       }\n-       f[i] = s1 - s2 * s2 - 1;\n-     }\n-\n-     double x1 = parameters[0].getEstimate();\n-     double x2 = parameters[1].getEstimate();\n-     f[m - 2] = x1;\n-     f[m - 1] = x2 - x1 * x1 - 1;\n-\n-     return f;\n-\n-    }\n-\n-  }\n-\n-  private static class Box3DimensionalFunction extends MinpackFunction {\n-\n-    public Box3DimensionalFunction(int m, double[] startParams,\n-                                   double theoreticalStartCost) {\n-      super(m, startParams, theoreticalStartCost,\n-            0.0, new double[] { 1.0, 10.0, 1.0 });\n-   }\n-\n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double tmp = (i + 1) / 10.0;\n-        jacobian[i] = new double[] {\n-          -tmp * Math.exp(-tmp * x1),\n-           tmp * Math.exp(-tmp * x2),\n-          Math.exp(-i - 1) - Math.exp(-tmp)\n-        };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        double tmp = (i + 1) / 10.0;\n-        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)\n-             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;\n-      }\n-      return f;\n-    }\n-\n-  }\n-\n-  private static class JennrichSampsonFunction extends MinpackFunction {\n-\n-    public JennrichSampsonFunction(int m, double[] startParams,\n-                                   double theoreticalStartCost,\n-                                   double theoreticalMinCost,\n-                                   double[] theoreticalMinParams) {\n-      super(m, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double t = i + 1;\n-        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = i + 1;\n-        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);\n-      }\n-      return f;\n-    }\n-\n-  }\n-\n-  private static class BrownDennisFunction extends MinpackFunction {\n-\n-    public BrownDennisFunction(int m, double[] startParams,\n-                               double theoreticalStartCost,\n-                               double theoreticalMinCost,\n-                               double[] theoreticalMinParams) {\n-      super(m, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double   x4 = parameters[3].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = (i + 1) / 5.0;\n-        double ti   = Math.sin(temp);\n-        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n-        double tmp2 = x3 + ti   * x4 - Math.cos(temp);\n-        jacobian[i] = new double[] {\n-          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2\n-        };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = (i + 1) / 5.0;\n-        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n-        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);\n-        f[i] = tmp1 * tmp1 + tmp2 * tmp2;\n-      }\n-      return f;\n-    }\n-\n-  }\n-\n-  private static class ChebyquadFunction extends MinpackFunction {\n-\n-    private static double[] buildChebyquadArray(int n, double factor) {\n-      double[] array = new double[n];\n-      double inv = factor / (n + 1);\n-      for (int i = 0; i < n; ++i) {\n-        array[i] = (i + 1) * inv;\n-      }\n-      return array;\n-    }\n-\n-    public ChebyquadFunction(int n, int m, double factor,\n-                             double theoreticalStartCost,\n-                             double theoreticalMinCost,\n-                             double[] theoreticalMinParams) {\n-      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        jacobian[i] = new double[n];\n-      }\n-\n-      double dx = 1.0 / n;\n-      for (int j = 0; j < n; ++j) {\n-        double tmp1 = 1;\n-        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n-        double temp = 2 * tmp2;\n-        double tmp3 = 0;\n-        double tmp4 = 2;\n-        for (int i = 0; i < m; ++i) {\n-          jacobian[i][j] = dx * tmp4;\n-          double ti = 4 * tmp2 + temp * tmp4 - tmp3;\n-          tmp3 = tmp4;\n-          tmp4 = ti;\n-          ti   = temp * tmp2 - tmp1;\n-          tmp1 = tmp2;\n-          tmp2 = ti;\n-        }\n-      }\n-\n-      return jacobian;\n-\n-    }\n-\n-    protected double[] getResiduals() {\n-\n-      double[] f = new double[m];\n-\n-      for (int j = 0; j < n; ++j) {\n-        double tmp1 = 1;\n-        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n-        double temp = 2 * tmp2;\n-        for (int i = 0; i < m; ++i) {\n-          f[i] += tmp2;\n-          double ti = temp * tmp2 - tmp1;\n-          tmp1 = tmp2;\n-          tmp2 = ti;\n-        }\n-      }\n-\n-      double dx = 1.0 / n;\n-      boolean iev = false;\n-      for (int i = 0; i < m; ++i) {\n-        f[i] *= dx;\n-        if (iev) {\n-          f[i] += 1.0 / (i * (i + 2));\n-        }\n-        iev = ! iev;\n-      }\n-\n-      return f;\n-\n-    }\n-\n-  }\n-\n-  private static class BrownAlmostLinearFunction extends MinpackFunction {\n-\n-    public BrownAlmostLinearFunction(int m, double factor,\n-                                     double theoreticalStartCost,\n-                                     double theoreticalMinCost,\n-                                     double[] theoreticalMinParams) {\n-      super(m, buildArray(m, factor), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        jacobian[i] = new double[n];\n-      }\n-\n-      double prod = 1;\n-      for (int j = 0; j < n; ++j) {\n-        prod *= parameters[j].getEstimate();\n-        for (int i = 0; i < n; ++i) {\n-          jacobian[i][j] = 1;\n-        }\n-        jacobian[j][j] = 2;\n-      }\n-\n-      for (int j = 0; j < n; ++j) {\n-        EstimatedParameter vj = parameters[j];\n-        double temp = vj.getEstimate();\n-        if (temp == 0) {\n-          temp = 1;\n-          prod = 1;\n-          for (int k = 0; k < n; ++k) {\n-            if (k != j) {\n-              prod *= parameters[k].getEstimate();\n-            }\n-          }\n-        }\n-        jacobian[n - 1][j] = prod / temp;\n-      }\n-\n-      return jacobian;\n-\n-    }\n-\n-    protected double[] getResiduals() {\n-      double[] f = new double[m];\n-      double sum  = -(n + 1);\n-      double prod = 1;\n-      for (int j = 0; j < n; ++j) {\n-        sum  += parameters[j].getEstimate();\n-        prod *= parameters[j].getEstimate();\n-      }\n-      for (int i = 0; i < n; ++i) {\n-        f[i] = parameters[i].getEstimate() + sum;\n-      }\n-      f[n - 1] = prod - 1;\n-      return f;\n-    }\n-\n-  }\n-\n-  private static class Osborne1Function extends MinpackFunction {\n-\n-    public Osborne1Function(double[] startParams,\n-                            double theoreticalStartCost,\n-                            double theoreticalMinCost,\n-                            double[] theoreticalMinParams) {\n-      super(33, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double   x4 = parameters[3].getEstimate();\n-      double   x5 = parameters[4].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = 10.0 * i;\n-        double tmp1 = Math.exp(-temp * x4);\n-        double tmp2 = Math.exp(-temp * x5);\n-        jacobian[i] = new double[] {\n-          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2\n-        };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n-      double x5 = parameters[4].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = 10.0 * i;\n-        double tmp1 = Math.exp(-temp * x4);\n-        double tmp2 = Math.exp(-temp * x5);\n-        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);\n-      }\n-      return f;\n-    }\n-\n-    private static final double[] y = {\n-      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,\n-      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,\n-      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406\n-    };\n-\n-  }\n-\n-  private static class Osborne2Function extends MinpackFunction {\n-\n-    public Osborne2Function(double[] startParams,\n-                            double theoreticalStartCost,\n-                            double theoreticalMinCost,\n-                            double[] theoreticalMinParams) {\n-      super(65, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x01 = parameters[0].getEstimate();\n-      double   x02 = parameters[1].getEstimate();\n-      double   x03 = parameters[2].getEstimate();\n-      double   x04 = parameters[3].getEstimate();\n-      double   x05 = parameters[4].getEstimate();\n-      double   x06 = parameters[5].getEstimate();\n-      double   x07 = parameters[6].getEstimate();\n-      double   x08 = parameters[7].getEstimate();\n-      double   x09 = parameters[8].getEstimate();\n-      double   x10 = parameters[9].getEstimate();\n-      double   x11 = parameters[10].getEstimate();\n-      double[][] jacobian = new double[m][];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = i / 10.0;\n-        double tmp1 = Math.exp(-x05 * temp);\n-        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n-        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n-        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n-        jacobian[i] = new double[] {\n-          -tmp1,\n-          -tmp2,\n-          -tmp3,\n-          -tmp4,\n-          temp * x01 * tmp1,\n-          x02 * (temp - x09) * (temp - x09) * tmp2,\n-          x03 * (temp - x10) * (temp - x10) * tmp3,\n-          x04 * (temp - x11) * (temp - x11) * tmp4,\n-          -2 * x02 * x06 * (temp - x09) * tmp2,\n-          -2 * x03 * x07 * (temp - x10) * tmp3,\n-          -2 * x04 * x08 * (temp - x11) * tmp4\n-        };\n-      }\n-      return jacobian;\n-    }\n-\n-    protected double[] getResiduals() {\n-      double x01 = parameters[0].getEstimate();\n-      double x02 = parameters[1].getEstimate();\n-      double x03 = parameters[2].getEstimate();\n-      double x04 = parameters[3].getEstimate();\n-      double x05 = parameters[4].getEstimate();\n-      double x06 = parameters[5].getEstimate();\n-      double x07 = parameters[6].getEstimate();\n-      double x08 = parameters[7].getEstimate();\n-      double x09 = parameters[8].getEstimate();\n-      double x10 = parameters[9].getEstimate();\n-      double x11 = parameters[10].getEstimate();\n-      double[] f = new double[m];\n-      for (int i = 0; i < m; ++i) {\n-        double temp = i / 10.0;\n-        double tmp1 = Math.exp(-x05 * temp);\n-        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n-        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n-        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n-        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);\n-      }\n-      return f;\n-    }\n-\n-    private static final double[] y = {\n-      1.366, 1.191, 1.112, 1.013, 0.991,\n-      0.885, 0.831, 0.847, 0.786, 0.725,\n-      0.746, 0.679, 0.608, 0.655, 0.616,\n-      0.606, 0.602, 0.626, 0.651, 0.724,\n-      0.649, 0.649, 0.694, 0.644, 0.624,\n-      0.661, 0.612, 0.558, 0.533, 0.495,\n-      0.500, 0.423, 0.395, 0.375, 0.372,\n-      0.391, 0.396, 0.405, 0.428, 0.429,\n-      0.523, 0.562, 0.607, 0.653, 0.672,\n-      0.708, 0.633, 0.668, 0.645, 0.632,\n-      0.591, 0.559, 0.597, 0.625, 0.739,\n-      0.710, 0.729, 0.720, 0.636, 0.581,\n-      0.428, 0.292, 0.162, 0.098, 0.054\n-    };\n-\n-  }\n-\n   public static Test suite() {\n     return new TestSuite(LevenbergMarquardtEstimatorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/WeightedMeasurementTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/WeightedMeasurementTest.java\n \n   public WeightedMeasurementTest(String name) {\n     super(name);\n+    p1 = null;\n+    p2 = null;\n   }\n \n   public void testConstruction() {\n-    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1);\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);\n     checkValue(m.getWeight(), 3.0);\n     checkValue(m.getMeasuredValue(), theoretical() + 0.1);\n   }\n \n   public void testIgnored() {\n-    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1);\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);\n     assertTrue(!m.isIgnored());\n     m.setIgnored(true);\n     assertTrue(m.isIgnored());\n   }\n \n   public void testTheory() {\n-    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1);\n+    WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this);\n     checkValue(m.getTheoreticalValue(), theoretical());\n     checkValue(m.getResidual(), 0.1);\n \n     }\n   }\n \n-  private class MyMeasurement\n+  private static class MyMeasurement\n     extends WeightedMeasurement {\n \n-    public MyMeasurement(double weight, double measuredValue) {\n+    public MyMeasurement(double weight, double measuredValue,\n+                         WeightedMeasurementTest testInstance) {\n       super(weight, measuredValue);\n+      this.testInstance = testInstance;\n     }\n \n     public double getTheoreticalValue() {\n-      return theoretical();\n+      return testInstance.theoretical();\n     }\n \n     public double getPartial(EstimatedParameter p) {\n-      return partial(p);\n+      return testInstance.partial(p);\n     }\n+\n+    private transient WeightedMeasurementTest testInstance;\n \n     private static final long serialVersionUID = -246712922500792332L;\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/AbstractCurveFitterTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/AbstractCurveFitterTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimatedParameter;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n import org.spaceroots.mantissa.estimation.WeightedMeasurement;\n \n public class AbstractCurveFitterTest\n \n   public AbstractCurveFitterTest(String name) {\n     super(name);\n+    fitter = null;\n   }\n \n   public void testAlreadySorted() {\n     fitter = new DummyFitter();\n   }\n \n-  public void tearOff() {\n+  public void tearDown() {\n     fitter = null;\n   }\n \n-  private class DummyFitter\n+  private static class DummyFitter\n     extends AbstractCurveFitter {\n \n     public DummyFitter() {\n-      super(10, 10, 0.0, 0.0, 0.0);\n+      super(10, new LevenbergMarquardtEstimator());\n     }\n \n     public double valueAt(double x) {\n       sortMeasurements();\n     }\n \n-    private static final long serialVersionUID = -5453139487565082528L;\n+    private static final long serialVersionUID = 4016396219767783678L;\n \n   }\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/HarmonicFitterTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/HarmonicFitterTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n import org.spaceroots.mantissa.estimation.WeightedMeasurement;\n \n public class HarmonicFitterTest\n     throws EstimationException {\n     HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n \n-    HarmonicFitter fitter = new HarmonicFitter(20, 1.0e-7,\n-                                               1.0e-10, 1.0e-10);\n+    HarmonicFitter fitter =\n+      new HarmonicFitter(new LevenbergMarquardtEstimator());\n     for (double x = 0.0; x < 1.3; x += 0.01) {\n       fitter.addWeightedPair(1.0, x, f.valueAt(x));\n     }\n     HarmonicFunction fitted = new HarmonicFunction(coeffs[0],\n                                                    coeffs[1],\n                                                    coeffs[2]);\n-    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-12);\n-    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 1.0e-12);\n-    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.0e-12);\n+    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-13);\n+    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 1.0e-13);\n+    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.0e-13);\n \n     for (double x = -1.0; x < 1.0; x += 0.01) {\n-      assertTrue(Math.abs(f.valueAt(x) - fitted.valueAt(x)) < 1.0e-12);\n+      assertTrue(Math.abs(f.valueAt(x) - fitted.valueAt(x)) < 1.0e-13);\n     }\n \n   }\n     Random randomizer = new Random(64925784252l);\n     HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n \n-    HarmonicFitter fitter = new HarmonicFitter(20, 1.0e-7,\n-                                               1.0e-10, 1.0e-10);\n+    HarmonicFitter fitter =\n+      new HarmonicFitter(new LevenbergMarquardtEstimator());\n     for (double x = 0.0; x < 10.0; x += 0.1) {\n       fitter.addWeightedPair(1.0, x,\n                              f.valueAt(x) + 0.01 * randomizer.nextGaussian());\n     double[] coeffs = fitter.fit();\n \n     new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);\n-    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-3);\n-    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 3.5e-3);\n-    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 2.0e-2);\n+    assertTrue(Math.abs(coeffs[0] - f.getA()) < 7.6e-4);\n+    assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 2.7e-3);\n+    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.3e-2);\n \n     WeightedMeasurement[] measurements = fitter.getMeasurements();\n     for (int i = 0; i < measurements.length; ++i) {\n     Random randomizer = new Random(64925784252l);\n     HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n \n-    HarmonicFitter fitter = new HarmonicFitter(100, 1.0e-7,\n-                                               1.0e-10, 1.0e-10);\n+    HarmonicFitter fitter =\n+      new HarmonicFitter(new LevenbergMarquardtEstimator());\n \n     // build a regularly spaced array of measurements\n     int size = 100;\n     double[] coeffs = fitter.fit();\n \n     new HarmonicFunction(coeffs[0], coeffs[1], coeffs[2]);\n-    assertTrue(Math.abs(coeffs[0] - f.getA()) < 1.0e-3);\n+    assertTrue(Math.abs(coeffs[0] - f.getA()) < 7.6e-4);\n     assertTrue(Math.abs(coeffs[1] - f.getOmega()) < 3.5e-3);\n-    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 2.0e-2);\n+    assertTrue(Math.abs(coeffs[2] - center(f.getPhi(), coeffs[2])) < 1.5e-2);\n \n     WeightedMeasurement[] measurements = fitter.getMeasurements();\n     for (int i = 0; i < measurements.length; ++i) {\n     return a - twoPi * Math.floor((a + Math.PI - ref) / twoPi);\n   }\n \n-  private class HarmonicFunction {\n+  private static class HarmonicFunction {\n     public HarmonicFunction(double a, double omega, double phi) {\n       this.a     = a;\n       this.omega = omega;\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/PolynomialFitterTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/fitting/PolynomialFitterTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.Estimator;\n+import org.spaceroots.mantissa.estimation.GaussNewtonEstimator;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n \n public class PolynomialFitterTest\n   extends TestCase {\n         p.initCoeff (i, randomizer.nextGaussian());\n       }\n \n-      PolynomialFitter fitter = new PolynomialFitter(degree,\n-                                                     10, 1.0e-7,\n-                                                     1.0e-10, 1.0e-10);\n+      PolynomialFitter fitter =\n+        new PolynomialFitter(degree, new LevenbergMarquardtEstimator());\n       for (int i = 0; i <= degree; ++i) {\n         fitter.addWeightedPair(1.0, i, p.valueAt(i));\n       }\n         p.initCoeff(i, randomizer.nextGaussian());\n       }\n \n-      PolynomialFitter fitter = new PolynomialFitter(degree,\n-                                                     10, 1.0e-7,\n-                                                     1.0e-10, 1.0e-10);\n+      PolynomialFitter fitter =\n+        new PolynomialFitter(degree, new LevenbergMarquardtEstimator());\n       for (double x = -1.0; x < 1.0; x += 0.01) {\n         fitter.addWeightedPair(1.0, x,\n                                p.valueAt(x) + 0.1 * randomizer.nextGaussian());\n \n   }\n \n-  public void testUnsolvableProblem()\n-    throws EstimationException {\n+  public void testRedundantSolvable() {\n+    // Levenberg-Marquardt should handle redundant information gracefully\n+    checkUnsolvableProblem(new LevenbergMarquardtEstimator(), true);\n+  }\n+\n+  public void testRedundantUnsolvable() {\n+    // Gauss-Newton should not be able to solve redundant information\n+    checkUnsolvableProblem(new GaussNewtonEstimator(10, 1.0e-7, 1.0e-7,\n+                                                    1.0e-10),\n+                           false);\n+  }\n+\n+  private void checkUnsolvableProblem(Estimator estimator,\n+                                      boolean solvable) {\n     Random randomizer = new Random(1248788532l);\n     for (int degree = 0; degree < 10; ++degree) {\n       Polynom p = new Polynom(degree);\n-      for (int i = 1; i <= degree; ++i) {\n+      for (int i = 0; i <= degree; ++i) {\n         p.initCoeff(i, randomizer.nextGaussian());\n       }\n \n-      PolynomialFitter fitter = new PolynomialFitter(degree,\n-                                                     10, 1.0e-7,\n-                                                     1.0e-10, 1.0e-10);\n+      PolynomialFitter fitter = new PolynomialFitter(degree, estimator);\n \n       // reusing the same point over and over again does not bring\n       // information, the problem cannot be solved in this case for\n         fitter.addWeightedPair(1.0, 0.0, p.valueAt(0.0));\n       }\n \n-      boolean gotIt = false;\n       try {\n         fitter.fit();\n+        assertTrue(solvable || (degree == 0));\n       } catch(EstimationException e) {\n-        gotIt = true;\n+        assertTrue((! solvable) && (degree > 0));\n       }\n-      assertTrue((degree == 0 && ! gotIt) || (degree > 0 && gotIt));\n \n     }\n \n     return new TestSuite(PolynomialFitterTest.class);\n   }\n \n-  private class Polynom {\n+  private static class Polynom {\n \n     public Polynom(int degree) {\n       coeffs = new double[degree + 1];\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIteratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIteratorTest.java\n     throws ExhaustedSampleException, FunctionException {\n \n     BasicSampledFunctionIterator iter =\n-      new BasicSampledFunctionIterator(new SampledFunction() {\n-\n-          private boolean fireException = false;\n-\n-          public int size() {\n-            return 2;\n-          }\n-\n-          public ScalarValuedPair samplePointAt(int i)\n-            throws FunctionException {\n-            if (fireException) {\n-              throw new FunctionException(\"boom\");\n-            }\n-            fireException = true;\n-            return new ScalarValuedPair(0.0, 0.0);\n-          }\n-\n-        });\n+      new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());\n \n     boolean exceptionOccurred = false;\n     try {\n     return new TestSuite(BasicSampledFunctionIteratorTest.class);\n   }\n \n-  private class Function\n+  private static class Function\n     implements SampledFunction {\n \n+    private static final long serialVersionUID = -5071329620086891960L;\n     private double begin;\n     private double step;\n     private int    n;\n     }\n   }\n \n+  private static class ExceptionGeneratingFunction\n+    implements SampledFunction {\n+\n+    private static final long serialVersionUID = 1417147976215668305L;\n+    private boolean fireException = false;\n+\n+    public int size() {\n+      return 2;\n+    }\n+\n+    public ScalarValuedPair samplePointAt(int i)\n+      throws FunctionException {\n+      if (fireException) {\n+        throw new FunctionException(\"boom\");\n+      }\n+      fireException = true;\n+      return new ScalarValuedPair(0.0, 0.0);\n+    }\n+\n+  }\n }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSamplerTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSamplerTest.java\n   public void testUnderlyingException() {\n \n     ComputableFunctionSampler sampler =\n-      new ComputableFunctionSampler(new ComputableFunction() {\n-          public double valueAt(double x)\n-            throws FunctionException {\n-            if (x < 0.5) {\n-              return -x;\n-            }\n-            throw new FunctionException(\"upper half range exception\");\n-          }\n-        },\n+      new ComputableFunctionSampler(new ExceptionGeneratingFunction(),\n                                     0.0, 0.1, 11);\n \n     boolean exceptionOccurred = false;\n     return new TestSuite(ComputableFunctionSamplerTest.class);\n   }\n \n-  private class Function\n+  private static class Function\n     implements ComputableFunction {\n \n+    private static final long serialVersionUID = -7173012970400285826L;\n     private double min;\n     private double max;\n \n \n   }\n \n+  private static class ExceptionGeneratingFunction\n+  implements ComputableFunction {\n+    private static final long serialVersionUID = 7853080602731012102L;\n+    public double valueAt(double x)\n+      throws FunctionException {\n+      if (x < 0.5) {\n+        return -x;\n+      }\n+      throw new FunctionException(\"upper half range exception\");\n+    }\n+  }\n+\n }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIteratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIteratorTest.java\n     for (int i = 0; i < 10; ++i) {\n       assertTrue(iter.hasNext());\n       VectorialValuedPair pair = iter.nextSamplePoint();\n-      assertTrue(Math.abs(pair.getX()    - 0.1 * i) < 1.0e-10);\n-      assertTrue(Math.abs(pair.getY()[0] + 0.1 * i) < 1.0e-10);\n-      assertTrue(Math.abs(pair.getY()[1] + 0.2 * i) < 1.0e-10);\n+      assertTrue(Math.abs(pair.x    - 0.1 * i) < 1.0e-10);\n+      assertTrue(Math.abs(pair.y[0] + 0.1 * i) < 1.0e-10);\n+      assertTrue(Math.abs(pair.y[1] + 0.2 * i) < 1.0e-10);\n     }\n \n   }\n     throws ExhaustedSampleException, FunctionException {\n \n     BasicSampledFunctionIterator iter =\n-      new BasicSampledFunctionIterator(new SampledFunction() {\n-\n-          private boolean fireException = false;\n-\n-          public int size() {\n-            return 2;\n-          }\n-\n-          public int getDimension() {\n-            return 2;\n-          }\n-\n-          public VectorialValuedPair samplePointAt(int i)\n-            throws FunctionException {\n-            if (fireException) {\n-              throw new FunctionException(\"boom\");\n-            }\n-            fireException = true;\n-            return new VectorialValuedPair(0.0, null);\n-          }\n-        });\n+      new BasicSampledFunctionIterator(new ExceptionGeneratingFunction());\n \n     boolean exceptionOccurred = false;\n     try {\n     return new TestSuite(BasicSampledFunctionIteratorTest.class);\n   }\n \n-  private class Function\n+  private static class Function\n     implements SampledFunction {\n \n+    private static final long serialVersionUID = -6049535144225908344L;\n     private double   begin;\n     private double   step;\n     private int      n;\n     }\n   }\n \n+  private static class ExceptionGeneratingFunction\n+    implements SampledFunction {\n+\n+    private static final long serialVersionUID = 3750401068561053681L;\n+    private boolean fireException = false;\n+\n+    public int size() {\n+      return 2;\n+    }\n+\n+    public int getDimension() {\n+      return 2;\n+    }\n+\n+    public VectorialValuedPair samplePointAt(int i)\n+      throws FunctionException {\n+      if (fireException) {\n+        throw new FunctionException(\"boom\");\n+      }\n+      fireException = true;\n+      return new VectorialValuedPair(0.0, new double[] { 0, 1 });\n+    }\n+  }\n+\n }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSamplerTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSamplerTest.java\n \n     assertTrue(sampler.size() == 11);\n     assertTrue(sampler.getDimension() == 2);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.000) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.000) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.000) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getX()     - 0.495) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[0]  + 0.495) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[1]  + 0.990) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(10).getX()    - 0.990) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[0] + 0.990) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[1] + 1.980) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.495) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.495) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.990) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).x    - 0.990) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 0.990) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 1.980) < 1.0e-10);\n \n   }\n \n \n     assertTrue(sampler.size() == 11);\n     assertTrue(sampler.getDimension() == 2);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getX()     - 0.5) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[0]  + 0.5) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[1]  + 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(10).getX()    - 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[0] + 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(10).getY()[1] + 2.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).x    - 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).y[0] + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(10).y[1] + 2.0) < 1.0e-10);\n \n   }\n \n \n     assertTrue(sampler.size() == 12);\n     assertTrue(sampler.getDimension() == 2);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.000) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.000) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.000) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getX()     - 0.415) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[0]  + 0.415) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(5).getY()[1]  + 0.830) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(11).getX()    - 0.913) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(11).getY()[0] + 0.913) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(11).getY()[1] + 1.826) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.000) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).x     - 0.415) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).y[0]  + 0.415) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(5).y[1]  + 0.830) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).x    - 0.913) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).y[0] + 0.913) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(11).y[1] + 1.826) < 1.0e-10);\n \n   }\n \n \n     assertTrue(sampler.size() == 13);\n     assertTrue(sampler.getDimension() == 2);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getX()     - 0.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[0]  + 0.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(0).getY()[1]  + 0.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(6).getX()     - 0.5) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(6).getY()[0]  + 0.5) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(6).getY()[1]  + 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(12).getX()    - 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(12).getY()[0] + 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(sampler.samplePointAt(12).getY()[1] + 2.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).x     - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[0]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(0).y[1]  + 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).x     - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).y[0]  + 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(6).y[1]  + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).x    - 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).y[0] + 1.0) < 1.0e-10);\n+    assertTrue(Math.abs(sampler.samplePointAt(12).y[1] + 2.0) < 1.0e-10);\n \n   }\n \n   public void testUnderlyingException() {\n \n     ComputableFunctionSampler sampler =\n-      new ComputableFunctionSampler(new ComputableFunction() {\n-\n-          public int getDimension() {\n-            return 2;\n-          }\n-\n-          public double[] valueAt(double x)\n-            throws FunctionException {\n-            if (x < 0.5) {\n-              double[] res = new double[2];\n-              res[0] = -x;\n-              res[1] = -2.0 * x;\n-              return res;\n-            }\n-            throw new FunctionException(\"upper half range exception\");\n-           }\n-\n-        },\n+      new ComputableFunctionSampler(new ExceptionGeneratingFunction(),\n                                     0.0, 0.1, 11);\n \n     boolean exceptionOccurred = false;\n     return new TestSuite(ComputableFunctionSamplerTest.class);\n   }\n \n-  private class Function\n+  private static class Function\n     implements ComputableFunction {\n     private double   min;\n     private double   max;\n       return values;\n \n     }\n+\n+    private static final long serialVersionUID = -1859103913610458563L;\n+\n+  }\n+\n+  private static class ExceptionGeneratingFunction\n+    implements ComputableFunction {\n+\n+    public int getDimension() {\n+      return 2;\n+    }\n+\n+    public double[] valueAt(double x)\n+      throws FunctionException {\n+      if (x < 0.5) {\n+        double[] res = new double[2];\n+        res[0] = -x;\n+        res[1] = -2.0 * x;\n+        return res;\n+      }\n+      throw new FunctionException(\"upper half range exception\");\n+     }\n+\n+    private static final long serialVersionUID = 2849780376767626912L;\n+\n   }\n \n }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPairTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPairTest.java\n     tab[0] = -8.4;\n     tab[1] = -3.2;\n     VectorialValuedPair pair = new VectorialValuedPair(1.2, tab);\n-    assertTrue(Math.abs(pair.getX()    - 1.2) < 1.0e-10);\n-    assertTrue(Math.abs(pair.getY()[0] + 8.4) < 1.0e-10);\n-    assertTrue(Math.abs(pair.getY()[1] + 3.2) < 1.0e-10);\n+    assertTrue(Math.abs(pair.x    - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(pair.y[0] + 8.4) < 1.0e-10);\n+    assertTrue(Math.abs(pair.y[1] + 3.2) < 1.0e-10);\n   }\n \n   public void testCopyConstructor() {\n     tab[0] = -8.4;\n     tab[1] = -3.2;\n     VectorialValuedPair pair1 = new VectorialValuedPair(1.2, tab);\n-    VectorialValuedPair pair2 = new VectorialValuedPair(pair1);\n-    assertTrue(Math.abs(pair2.getX()    - pair1.getX())    < 1.0e-10);\n-    assertTrue(Math.abs(pair2.getY()[0] - pair1.getY()[0]) < 1.0e-10);\n-    assertTrue(Math.abs(pair2.getY()[1] - pair1.getY()[1]) < 1.0e-10);\n-    assertTrue(Math.abs(pair2.getX()    - 1.2)        < 1.0e-10);\n-    assertTrue(Math.abs(pair2.getY()[0] + 8.4)        < 1.0e-10);\n-    assertTrue(Math.abs(pair2.getY()[1] + 3.2)        < 1.0e-10);\n+    VectorialValuedPair pair2 = new VectorialValuedPair(pair1.x,\n+                                                        pair1.y);\n+    assertTrue(Math.abs(pair2.x    - pair1.x)    < 1.0e-10);\n+    assertTrue(Math.abs(pair2.y[0] - pair1.y[0]) < 1.0e-10);\n+    assertTrue(Math.abs(pair2.y[1] - pair1.y[1]) < 1.0e-10);\n+    assertTrue(Math.abs(pair2.x    - 1.2)        < 1.0e-10);\n+    assertTrue(Math.abs(pair2.y[0] + 8.4)        < 1.0e-10);\n+    assertTrue(Math.abs(pair2.y[1] + 3.2)        < 1.0e-10);\n   }\n \n   public static Test suite() {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/RotationTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/RotationTest.java\n     checkAngle(r.getAngle(), 2 * Math.PI / 3);\n \n     try {\n-      r = new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);\n+      new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);\n       fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException e) {\n     } catch (Exception e) {\n     Vector3D u = new Vector3D(3, 2, 1);\n     Vector3D v = new Vector3D(-4, 2, 2);\n     Rotation r = new Rotation(u, v);\n-    checkVector(r.applyTo(Vector3D.multiply(v.getNorm(), u)),\n-                Vector3D.multiply(u.getNorm(), v));\n-\n-    checkAngle(new Rotation(u, Vector3D.negate(u)).getAngle(), Math.PI);\n+    checkVector(r.applyTo(u.multiply(v.getNorm())), v.multiply(u.getNorm()));\n+\n+    checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);\n \n   }\n \n     Vector3D v2 = new Vector3D(-2, 0, 2);\n     Rotation r = new Rotation(u1, u2, v1, v2);\n     checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.negate(Vector3D.plusI));\n-\n-    r = new Rotation(u1, u2, Vector3D.negate(u1), Vector3D.negate(u2));\n+    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);\n+\n+    r = new Rotation(u1, u2, u1.negate(), u2.negate());\n     Vector3D axis = r.getAxis();\n     if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {\n       checkVector(axis, Vector3D.plusK);\n     } else {\n-      checkVector(axis, Vector3D.negate(Vector3D.plusK));\n+      checkVector(axis, Vector3D.minusK);\n     }\n     checkAngle(r.getAngle(), Math.PI);\n \n                         { 0.0, 1.0, 0.0 },\n                         { 1.0, 0.0, 0.0 } };\n       r = new Rotation(m5, 1.0e-7);\n-      fail(\"an exception should have been thrown\");\n+      fail(\"got \" + r + \", should have caught an exception\");\n     } catch (NotARotationMatrixException e) {\n+      // expected\n     } catch (Exception e) {\n       fail(\"wrong exception caught\");\n     }\n   }\n \n   private void checkVector(Vector3D v1, Vector3D v2) {\n-    assertTrue(Vector3D.subtract(v1, v2).getNorm() < 1.0e-10);\n+    assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);\n   }\n \n   private void checkAngle(double a1, double a2) {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/Vector3DTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/Vector3DTest.java\n \n     Vector3D v1 = new Vector3D(1, 2, 3);\n     Vector3D v2 = new Vector3D(-3, -2, -1);\n-    v1 = Vector3D.subtract(v1, v2);\n+    v1 = v1.subtract(v2);\n     checkVector(v1, new Vector3D(4, 4, 4));\n \n-    checkVector(Vector3D.subtract(v2, v1), new Vector3D(-7, -6, -5));\n+    checkVector(v2.subtract(v1), new Vector3D(-7, -6, -5));\n \n   }\n \n   public void testAdd() {\n     Vector3D v1 = new Vector3D(1, 2, 3);\n     Vector3D v2 = new Vector3D(-3, -2, -1);\n-    v1 = Vector3D.add(v1, v2);\n+    v1 = v1.add(v2);\n     checkVector(v1, new Vector3D(-2, 0, 2));\n \n-    checkVector(Vector3D.add(v2, v1), new Vector3D(-5, -2, 1));\n+    checkVector(v2.add(v1), new Vector3D(-5, -2, 1));\n \n   }\n \n   public void testScalarProduct() {\n     Vector3D v = new Vector3D(1, 2, 3);\n-    v = Vector3D.multiply(3, v);\n+    v = v.multiply(3);\n     checkVector(v, new Vector3D(3, 6, 9));\n \n-    checkVector(Vector3D.multiply(0.5, v), new Vector3D(1.5, 3, 4.5));\n+    checkVector(v.multiply(0.5), new Vector3D(1.5, 3, 4.5));\n \n   }\n \n   public void testAngularSeparation() {\n     Vector3D v1 = new Vector3D(2, -1, 4);\n \n-    Vector3D  k = Vector3D.normalize(v1);\n+    Vector3D  k = v1.normalize();\n     Vector3D  i = k.orthogonal();\n-\n-    Vector3D v2 = new Vector3D(Math.cos(1.2), k, Math.sin(1.2), i);\n+    Vector3D v2 = k.multiply(Math.cos(1.2)).add(i.multiply(Math.sin(1.2)));\n \n     assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n \n   }\n \n   private void checkVector(Vector3D v1, Vector3D v2) {\n-    assertTrue(Vector3D.subtract(v1, v2).getNorm() < 1.0e-12);\n+    assertTrue(v1.subtract(v2).getNorm() < 1.0e-12);\n   }\n   \n   public static Test suite() {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/DiagonalMatrixTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/DiagonalMatrixTest.java\n     boolean gotIt = false;\n     try {\n       d.setElement(3, 3, 0.0);\n-      result = d.solve(b, 1.0e-10);\n+      d.solve(b, 1.0e-10);\n     } catch (SingularMatrixException e) {\n       gotIt = true;\n     }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/GeneralMatrixTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/GeneralMatrixTest.java\n   }\n \n   public void testElements() {\n-    Matrix m = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    checkMatrix(m, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n+\n+    checkMatrix(m, new BilinearPattern(1.0, 0.01));\n \n   }\n \n   public void testCopy() {\n-    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n \n     GeneralMatrix m2 = new GeneralMatrix(m1);\n \n     assertTrue(m2.getRows() == m1.getRows());\n     assertTrue(m2.getColumns() == m1.getColumns());\n \n-    checkMatrix(m2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    checkMatrix(m2, new BilinearPattern(1.0, 0.01));\n \n   }\n \n   public void testDuplicate() {\n-    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n \n     Matrix m2 = m1.duplicate();\n     assertTrue(m2 instanceof GeneralMatrix);\n     assertTrue(m2.getRows() == m1.getRows());\n     assertTrue(m2.getColumns() == m1.getColumns());\n \n-    checkMatrix (m2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    checkMatrix (m2, new BilinearPattern(1.0, 0.01));\n \n   }\n \n \n   public void testAddOK() {\n \n-    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    Matrix m2 = buildMatrix(m1.getRows(),\n-                            m1.getColumns(),\n-                            new ElementPattern() {\n-                              public double value(int i, int j) {\n-                                return 100 * i - 0.01 * j;\n-                              }\n-                            });\n+    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new BilinearPattern(100, -0.01));\n \n     Matrix m3 = m1.add(m2);\n \n-    checkMatrix(m3, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 101 * i;\n-        }\n-      });\n+    checkMatrix(m3, new BilinearPattern(101, 0));\n \n   }\n \n   public void testSelfAdd() {\n \n-    GeneralMatrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    Matrix m2 = buildMatrix(m1.getRows(),\n-                            m1.getColumns(),\n-                            new ElementPattern() {\n-                              public double value(int i, int j) {\n-                                return 100 * i - 0.01 * j;\n-                              }\n-                            });\n+    GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new BilinearPattern(100, -0.01));\n \n     m1.selfAdd(m2);\n \n-    checkMatrix(m1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 101 * i;\n-        }\n-      });\n+    checkMatrix(m1, new BilinearPattern(101, 0));\n \n   }\n \n \n   public void testSubOK() {\n \n-    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    Matrix m2 = buildMatrix(m1.getRows(),\n-                            m1.getColumns(),\n-                            new ElementPattern() {\n-                              public double value(int i, int j) {\n-                                return 100 * i - 0.01 * j;\n-                              }\n-                            });\n+    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new BilinearPattern(100, -0.01));\n \n     Matrix m3 = m1.sub(m2);\n \n-    checkMatrix(m3, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 0.02 * j - 99 * i;\n-        }\n-      });\n+    checkMatrix(m3, new BilinearPattern(-99, 0.02));\n \n   }\n \n   public void testSelfSub() {\n \n-    GeneralMatrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    Matrix m2 = buildMatrix(m1.getRows(),\n-                            m1.getColumns(),\n-                            new ElementPattern() {\n-                              public double value(int i, int j) {\n-                                return 100 * i - 0.01 * j;\n-                              }\n-                            });\n+    GeneralMatrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n+\n+    Matrix m2 = buildMatrix(m1.getRows(),\n+                            m1.getColumns(),\n+                            new BilinearPattern(100, -0.01));\n \n     m1.selfSub(m2);\n \n-    checkMatrix(m1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 0.02 * j - 99 * i;\n-        }\n-      });\n+    checkMatrix(m1, new BilinearPattern(-99, 0.02));\n \n   }\n \n \n   public void testMulMOK() {\n \n-    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    Matrix m2 = buildMatrix(m1.getColumns(), 4, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2 * i - j;\n-        }\n-      });\n+    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n+\n+    Matrix m2 = buildMatrix(m1.getColumns(), 4, new BilinearPattern(2, -1));\n \n     Matrix m3 = m1.mul(m2);\n \n-    checkMatrix(m3, new ElementPattern() {\n-        public double value(int i, int j) {\n-          int p = 10; // must be equal to m1.getColumns()\n-          return p * ((2 * i - 0.01 *j) * (p - 1) / 2.0\n-                      - i* j\n-                      + (p - 1) * (2 * p - 1) / 300.0);\n-        }\n-      });\n+    checkMatrix(m3, new ComplexPattern(m1.getColumns()));\n \n   }\n \n   public void testMulD() {\n \n-    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n \n     Matrix m2 = m1.mul(2.5);\n \n-    checkMatrix(m2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2.5 * (i + 0.01 * j);\n-        }\n-      });\n+    checkMatrix(m2, new BilinearPattern(2.5, 0.025));\n \n   }\n \n   public void testSelfMul() {\n \n-    Matrix m = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    Matrix m = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n \n     m.selfMul(2.5);\n \n-    checkMatrix(m, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2.5 * (i + 0.01 * j);\n-        }\n-      });\n+    checkMatrix(m, new BilinearPattern(2.5, 0.025));\n \n   }\n \n   public void testTranspose() {\n \n-    Matrix m1 = buildMatrix(5, 10, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    Matrix m1 = buildMatrix(5, 10, new BilinearPattern(1.0, 0.01));\n \n     Matrix m2 = m1.getTranspose();\n \n     assertTrue(m1.getRows() == m2.getColumns());\n     assertTrue(m1.getColumns() == m2.getRows());\n \n-    checkMatrix(m2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 0.01 * i + j;\n-        }\n-      });\n+    checkMatrix(m2, new BilinearPattern(0.01, 1.0));\n \n   }\n \n     return new TestSuite(GeneralMatrixTest.class);\n   }\n \n-  public interface ElementPattern {\n+  private interface ElementPattern {\n     public double value(int i, int j);\n   }\n \n+  private static class BilinearPattern implements ElementPattern {\n+    public BilinearPattern(double coeffI, double coeffJ) {\n+      this.coeffI = coeffI;\n+      this.coeffJ = coeffJ;\n+    }\n+    public double value(int i, int j) {\n+      return coeffI * i + coeffJ * j;\n+    }\n+    private final double coeffI;\n+    private final double coeffJ;\n+  }\n+\n+  private static class ComplexPattern implements ElementPattern {\n+    public ComplexPattern(int p) {\n+      this.p = p;\n+    }\n+    public double value(int i, int j) {\n+      return p * ((2 * i - 0.01 *j) * (p - 1) / 2.0\n+                  - i* j\n+                  + (p - 1) * (2 * p - 1) / 300.0);\n+    }\n+    private final int p;\n+  }\n+  \n   public GeneralMatrix buildMatrix(int rows, int columns,\n-                                   ElementPattern pattern) {\n+                                   BilinearPattern pattern) {\n     GeneralMatrix m = new GeneralMatrix(rows, columns);\n \n     for (int i = 0; i < m.getRows(); ++i) {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/GeneralSquareMatrixTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/GeneralSquareMatrixTest.java\n   }\n \n   public void testElements() {\n-    Matrix m = buildMatrix(5, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    checkMatrix(m, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    Matrix m = buildMatrix(5, new BilinearPattern(1.0, 0.01));\n+\n+    checkMatrix(m, new BilinearPattern(1.0, 0.01));\n \n   }\n \n   public void testCopy() {\n-    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));\n \n     GeneralSquareMatrix m2 = new GeneralSquareMatrix(m1);\n \n     assertTrue(m2.getRows() == m1.getRows());\n     assertTrue(m2.getColumns() == m1.getColumns());\n \n-    checkMatrix(m2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    checkMatrix(m2, new BilinearPattern(1.0, 0.01));\n \n   }\n \n   public void testDuplicate() {\n-    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));\n \n     Matrix m2 = m1.duplicate();\n     assertTrue(m2 instanceof GeneralSquareMatrix);\n     assertTrue(m2.getRows() == m1.getRows());\n     assertTrue(m2.getColumns() == m1.getColumns());\n \n-    checkMatrix(m2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n+    checkMatrix(m2, new BilinearPattern(1.0, 0.01));\n \n   }\n \n   public void testSelfAdd() {\n-    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    GeneralSquareMatrix m2 = buildMatrix(5, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2 * i - 0.03 * j;\n-        }\n-      });\n+    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));\n+\n+    GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));\n \n \n     m1.selfAdd(m2);\n \n-    checkMatrix(m1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 3 * i - 0.02 * j;\n-        }\n-      });\n+    checkMatrix(m1, new BilinearPattern(3, -0.02));\n \n   }\n \n   public void testSelfSub() {\n-    GeneralSquareMatrix m1 = buildMatrix(5, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.01 * j;\n-        }\n-      });\n-\n-    GeneralSquareMatrix m2 = buildMatrix(5, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2 * i - 0.03 * j;\n-        }\n-      });\n+    GeneralSquareMatrix m1 = buildMatrix(5, new BilinearPattern(1.0, 0.01));\n+\n+    GeneralSquareMatrix m2 = buildMatrix(5, new BilinearPattern(2, -0.03));\n \n \n     m1.selfSub(m2);\n \n-    checkMatrix(m1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 0.04 * j - i;\n-        }\n-      });\n+    checkMatrix(m1, new BilinearPattern(-1, 0.04));\n \n   }\n \n     result = p.a.solve(p.b, 1.0e-10);\n     checkSolve(p, result);\n \n-    boolean gotIt = false;\n     try {\n       p = buildProblem3();\n       result = p.a.solve(p.b, 1.0e-10);\n+      fail(\"got \" + result + \", should have caught an exception\");\n     } catch(SingularMatrixException e) {\n-      gotIt = true;\n-    }\n-    assertTrue(gotIt);\n-\n+      // expected\n+    } catch(Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+ \n   }\n \n   public void testInverse()\n \n     a = buildProblem1().a;\n     inverse = a.getInverse(1.0e-10);\n-    checkMatrix(a.mul(inverse), new ElementPattern() {\n-        public double value(int i, int j) {\n-          return (i == j) ? 1.0 : 0.0;\n-        }\n-      });\n+    checkMatrix(a.mul(inverse), new IdentityPattern());\n     \n     a = buildProblem2().a;\n     inverse = a.getInverse(1.0e-10);\n-    checkMatrix(a.mul(inverse), new ElementPattern() {\n-        public double value(int i, int j) {\n-          return (i == j) ? 1.0 : 0.0;\n-        }\n-      });\n-\n-    boolean gotIt = false;\n+    checkMatrix(a.mul(inverse), new IdentityPattern());\n+\n     try {\n       a = buildProblem3().a;\n       inverse = a.getInverse(1.0e-10);\n+      fail(\"got \" + inverse + \", should have caught an exception\");\n     } catch(SingularMatrixException e) {\n-      gotIt = true;\n-    }\n-    assertTrue(gotIt);\n+      // expected\n+    } catch(Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n \n   }\n \n     return new TestSuite(GeneralSquareMatrixTest.class);\n   }\n \n-  public interface ElementPattern {\n+  private interface ElementPattern {\n     public double value(int i, int j);\n+  }\n+\n+  private static class BilinearPattern implements ElementPattern {\n+    public BilinearPattern(double coeffI, double coeffJ) {\n+      this.coeffI = coeffI;\n+      this.coeffJ = coeffJ;\n+    }\n+    public double value(int i, int j) {\n+      return coeffI * i + coeffJ * j;\n+    }\n+    private final double coeffI;\n+    private final double coeffJ;\n+  }\n+\n+  private static class IdentityPattern implements ElementPattern {\n+    public double value(int i, int j) {\n+      return (i == j) ? 1.0 : 0.0;\n+    }\n   }\n \n   public GeneralSquareMatrix buildMatrix(int order,\n     }\n   }\n \n-  private class LinearProblem {\n+  private static class LinearProblem {\n     public GeneralSquareMatrix a;\n     public Matrix              x;\n     public Matrix              b;\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/LowerTriangularMatrixTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/LowerTriangularMatrixTest.java\n         } else {\n           boolean gotIt = false;\n           try {\n-            l.setElement\n-              (i, j, -1.3);\n+            l.setElement(i, j, -1.3);\n           } catch(ArrayIndexOutOfBoundsException e) {\n             gotIt = true;\n           }\n       }\n     }\n \n-    checkMatrix(l, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    checkMatrix(l, new BilinearPattern(1.0, 0.1));\n \n   }\n \n   public void testCopy() {\n \n-    LowerTriangularMatrix l1 = buildMatrix(4, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));\n \n     LowerTriangularMatrix l2 = new LowerTriangularMatrix (l1);\n \n-    checkMatrix (l2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    checkMatrix (l2, new BilinearPattern(1.0, 0.01));\n \n   }\n \n   public void testDuplicate() {\n \n-    LowerTriangularMatrix l1 = buildMatrix(4, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    LowerTriangularMatrix l1 = buildMatrix(4, new BilinearPattern(1.0, 0.01));\n \n     Matrix l2 = l1.duplicate();\n     assertTrue(l2 instanceof LowerTriangularMatrix);\n \n-    checkMatrix(l2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    checkMatrix(l2, new BilinearPattern(1.0, 0.01));\n \n   }\n \n   public void testTranspose() {\n \n-    LowerTriangularMatrix l = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    LowerTriangularMatrix l = buildMatrix(7, new BilinearPattern(1.0, 0.1));\n \n     Matrix transposed = l.getTranspose();\n     assertTrue(transposed instanceof UpperTriangularMatrix);\n   }\n \n   public void testSelfAdd() {\n-    LowerTriangularMatrix l1 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 3 * i - 0.2 * j;\n-        }\n-      });\n-\n-    LowerTriangularMatrix l2 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2 * i - 0.4 * j; }\n-      });\n+    LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));\n+\n+    LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));\n \n     l1.selfAdd(l2);\n \n-    checkMatrix(l1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 5 * i - 0.6 * j;\n-        }\n-      });\n+    checkMatrix(l1, new BilinearPattern(5, -0.6));\n   }\n \n   public void testSelfSub() {\n-    LowerTriangularMatrix l1 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 3 * i - 0.2 * j;\n-        }\n-      });\n-\n-    LowerTriangularMatrix l2 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2 * i - 0.4 * j;\n-        }\n-      });\n+    LowerTriangularMatrix l1 = buildMatrix(7, new BilinearPattern(3, -0.2));\n+\n+    LowerTriangularMatrix l2 = buildMatrix(7, new BilinearPattern(2, -0.4));\n \n     l1.selfSub(l2);\n \n-    checkMatrix(l1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.2 * j;\n-        }\n-      });\n+    checkMatrix(l1, new BilinearPattern(1, 0.2));\n   }\n \n   public void testDeterminant() {\n     boolean gotIt = false;\n     try {\n       l.setElement(3, 3, 0.0);\n-      result = l.solve(b, 1.0e-10);\n+      l.solve(b, 1.0e-10);\n     } catch(SingularMatrixException e) {\n       gotIt = true;\n     }\n \n   public interface ElementPattern {\n     public double value(int i, int j);\n+  }\n+\n+  private static class BilinearPattern implements ElementPattern {\n+    public BilinearPattern(double coeffI, double coeffJ) {\n+      this.coeffI = coeffI;\n+      this.coeffJ = coeffJ;\n+    }\n+    public double value(int i, int j) {\n+      return coeffI * i + coeffJ * j;\n+    }\n+    private final double coeffI;\n+    private final double coeffJ;\n   }\n \n   public LowerTriangularMatrix buildMatrix(int order,\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/UpperTriangularMatrixTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/linalg/UpperTriangularMatrixTest.java\n       }\n     }\n \n-    checkMatrix(u, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    checkMatrix(u, new BilinearPattern(1.0, 0.1));\n \n   }\n \n   public void testCopy() {\n \n-    UpperTriangularMatrix u1 = buildMatrix(4, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));\n \n     UpperTriangularMatrix u2 = new UpperTriangularMatrix(u1);\n \n-    checkMatrix(u2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    checkMatrix(u2, new BilinearPattern(1.0, 0.1));\n \n   }\n \n   public void testDuplicate() {\n \n-    UpperTriangularMatrix u1 = buildMatrix(4, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    UpperTriangularMatrix u1 = buildMatrix(4, new BilinearPattern(1.0, 0.1));\n \n     Matrix u2 = u1.duplicate();\n     assertTrue(u2 instanceof UpperTriangularMatrix);\n \n-    checkMatrix(u2, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    checkMatrix(u2, new BilinearPattern(1.0, 0.1));\n \n   }\n \n   public void testTranspose() {\n \n-    UpperTriangularMatrix u = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.1 * j;\n-        }\n-      });\n+    UpperTriangularMatrix u = buildMatrix(7, new BilinearPattern(1.0, 0.1));\n \n     Matrix transposed = u.getTranspose();\n     assertTrue(transposed instanceof LowerTriangularMatrix);\n   }\n \n   public void testSelfAdd() {\n-    UpperTriangularMatrix u1 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 3 * i - 0.2 * j;\n-        }\n-      });\n-\n-    UpperTriangularMatrix u2 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2 * i - 0.4 * j;\n-        }\n-      });\n+    UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));\n+\n+    UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));\n \n     u1.selfAdd(u2);\n \n-    checkMatrix(u1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 5 * i - 0.6 * j;\n-        }\n-      });\n+    checkMatrix(u1, new BilinearPattern(5, -0.6));\n   }\n \n   public void testSelfSub() {\n-    UpperTriangularMatrix u1 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 3 * i - 0.2 * j;\n-        }\n-      });\n-\n-    UpperTriangularMatrix u2 = buildMatrix(7, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return 2 * i - 0.4 * j;\n-        }\n-      });\n+    UpperTriangularMatrix u1 = buildMatrix(7, new BilinearPattern(3, -0.2));\n+\n+    UpperTriangularMatrix u2 = buildMatrix(7, new BilinearPattern(2, -0.4));\n \n     u1.selfSub(u2);\n \n-    checkMatrix(u1, new ElementPattern() {\n-        public double value(int i, int j) {\n-          return i + 0.2 * j;\n-        }\n-      });\n+    checkMatrix(u1, new BilinearPattern(1, 0.2));\n   }\n \n   public void testDeterminant() {\n     boolean gotIt = false;\n     try {\n       u.setElement(3, 3, 0.0);\n-      result = u.solve(b, 1.0e-10);\n+      u.solve(b, 1.0e-10);\n     } catch(SingularMatrixException e) {\n       gotIt = true;\n     }\n \n   public interface ElementPattern {\n     public double value(int i, int j);\n+  }\n+\n+  private static class BilinearPattern implements ElementPattern {\n+    public BilinearPattern(double coeffI, double coeffJ) {\n+      this.coeffI = coeffI;\n+      this.coeffJ = coeffJ;\n+    }\n+    public double value(int i, int j) {\n+      return coeffI * i + coeffJ * j;\n+    }\n+    private final double coeffI;\n+    private final double coeffJ;\n   }\n \n   public UpperTriangularMatrix buildMatrix(int order,\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ClassicalRungeKuttaIntegratorTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n import org.spaceroots.mantissa.fitting.PolynomialFitter;\n \n public class ClassicalRungeKuttaIntegratorTest\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n   public void testOrder()\n   throws EstimationException, DerivativeException,\n          IntegratorException {\n-    PolynomialFitter fitter = new PolynomialFitter(1,\n-                                                   10, 1.0e-7, 1.0e-10,\n-                                                   1.0e-10);\n+    PolynomialFitter fitter =\n+      new PolynomialFitter(1, new LevenbergMarquardtEstimator());\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n \n     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n-    integ.setStepHandler(new StepHandler() {\n-                      private double maxError = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                        maxError = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-\n-                        double[] interpolatedY = interpolator.getInterpolatedState ();\n-                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n-                        double dx = interpolatedY[0] - theoreticalY[0];\n-                        double dy = interpolatedY[1] - theoreticalY[1];\n-                        double error = dx * dx + dy * dy;\n-                        if (error > maxError) {\n-                          maxError = error;\n-                        }\n-                        if (isLast) {\n-                          // even with more than 1000 evaluations per period,\n-                          // RK4 is not able to integrate such an eccentric\n-                          // orbit with a good accuracy\n-                          assertTrue(maxError > 0.005);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n   }\n \n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+    private double maxError = 0;\n+    private TestProblem3 pb;\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ContinuousOutputModelTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ContinuousOutputModelTest.java\n \n   public ContinuousOutputModelTest(String name) {\n     super(name);\n+    pb    = null;\n+    integ = null;\n   }\n \n   public void testBoundaries()\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince54IntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince54IntegratorTest.java\n \n   }\n \n-  private class DP54SmallLastHandler implements StepHandler {\n+  private static class DP54SmallLastHandler implements StepHandler {\n \n     public DP54SmallLastHandler(double minStep) {\n       lastSeen = false;\n     TestProblemHandler handler = new TestProblemHandler(pb);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-    if (functions != null) {\n-      for (int l = 0; l < functions.length; ++l) {\n-        integ.addSwitchingFunction(functions[l],\n-                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n-      }\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      private int nbSteps = 0;\n-                      private double maxError = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return true;\n-                      }\n-                      public void reset() {\n-                        nbSteps = 0;\n-                        maxError = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast)\n-                        throws DerivativeException {\n-\n-                        ++nbSteps;\n-                        for (int a = 1; a < 10; ++a) {\n-\n-                          double prev   = interpolator.getPreviousTime();\n-                          double curr   = interpolator.getCurrentTime();\n-                          double interp = ((10 - a) * prev + a * curr) / 10;\n-                          interpolator.setInterpolatedTime(interp);\n-\n-                          double[] interpolatedY = interpolator.getInterpolatedState ();\n-                          double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n-                          double dx = interpolatedY[0] - theoreticalY[0];\n-                          double dy = interpolatedY[1] - theoreticalY[1];\n-                          double error = dx * dx + dy * dy;\n-                          if (error > maxError) {\n-                            maxError = error;\n-                          }\n-                        }\n-                        if (isLast) {\n-                          assertTrue(maxError < 7.0e-10);\n-                          assertTrue(nbSteps < 400);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      private boolean firstTime = true;\n-                      private double  minStep = 0;\n-                      private double  maxStep = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                        firstTime = true;\n-                        minStep = 0;\n-                        maxStep = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-\n-                        double step = Math.abs(interpolator.getCurrentTime()\n-                                               - interpolator.getPreviousTime());\n-                        if (firstTime) {\n-                          minStep   = Math.abs(step);\n-                          maxStep   = minStep;\n-                          firstTime = false;\n-                        } else {\n-                          if (step < minStep) {\n-                            minStep = step;\n-                          }\n-                          if (step > maxStep) {\n-                            maxStep = step;\n-                          }\n-                        }\n-\n-                        if (isLast) {\n-                          assertTrue(minStep < (1.0 / 450.0));\n-                          assertTrue(maxStep > (1.0 / 4.2));\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new VariableHandler());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n   }\n \n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 7.0e-10);\n+        assertTrue(nbSteps < 400);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    public VariableHandler() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 450.0));\n+        assertTrue(maxStep > (1.0 / 4.2));\n+      }\n+    }  \n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(DormandPrince54IntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince853IntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince853IntegratorTest.java\n     TestProblemHandler handler = new TestProblemHandler(pb);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-    if (functions != null) {\n-      for (int l = 0; l < functions.length; ++l) {\n-        integ.addSwitchingFunction(functions[l],\n-                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n-      }\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                 scalAbsoluteTolerance,\n                                                                 scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      private int nbSteps = 0;\n-                      private double maxError = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return true;\n-                      }\n-                      public void reset() {\n-                        nbSteps = 0;\n-                        maxError = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast)\n-                        throws DerivativeException {\n-\n-                        ++nbSteps;\n-                        for (int a = 1; a < 10; ++a) {\n-\n-                          double prev   = interpolator.getPreviousTime();\n-                          double curr   = interpolator.getCurrentTime();\n-                          double interp = ((10 - a) * prev + a * curr) / 10;\n-                          interpolator.setInterpolatedTime(interp);\n-\n-                          double[] interpolatedY = interpolator.getInterpolatedState ();\n-                          double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n-                          double dx = interpolatedY[0] - theoreticalY[0];\n-                          double dy = interpolatedY[1] - theoreticalY[1];\n-                          double error = dx * dx + dy * dy;\n-                          if (error > maxError) {\n-                            maxError = error;\n-                          }\n-                        }\n-                        if (isLast) {\n-                          assertTrue(maxError < 2.4e-10);\n-                          assertTrue(nbSteps < 150);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                scalAbsoluteTolerance,\n                                                                scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      private boolean firstTime = true;\n-                      private double  minStep = 0;\n-                      private double  maxStep = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                        firstTime = true;\n-                        minStep = 0;\n-                        maxStep = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-\n-                        double step = Math.abs(interpolator.getCurrentTime()\n-                                               - interpolator.getPreviousTime());\n-                        if (firstTime) {\n-                          minStep   = Math.abs(step);\n-                          maxStep   = minStep;\n-                          firstTime = false;\n-                        } else {\n-                          if (step < minStep) {\n-                            minStep = step;\n-                          }\n-                          if (step > maxStep) {\n-                            maxStep = step;\n-                          }\n-                        }\n-\n-                        if (isLast) {\n-                          assertTrue(minStep < (1.0 / 100.0));\n-                          assertTrue(maxStep > (1.0 / 2.0));\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new VariableHandler());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n                                                                 scalAbsoluteTolerance,\n                                                                 scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-                      }\n-      });\n+    integ.setStepHandler(DummyStepHandler.getInstance());\n     integ.integrate(pb1,\n                     pb1.getInitialTime(), pb1.getInitialState(),\n                     pb1.getFinalTime(), new double[pb1.getDimension()]);\n     int callsWithoutDenseOutput = pb1.getCalls();\n \n-    integ.setStepHandler(new StepHandler() {\n-                      public boolean requiresDenseOutput() {\n-                        return true;\n-                      }\n-                      public void reset() {\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast)\n-                        throws DerivativeException {\n-                        double prev = interpolator.getPreviousTime();\n-                        double curr = interpolator.getCurrentTime();\n-                        interpolator.setInterpolatedTime(0.5*(prev + curr));\n-                      }\n-      });\n+    integ.setStepHandler(new InterpolatingStepHandler());\n     integ.integrate(pb2,\n                     pb2.getInitialTime(), pb2.getInitialState(),\n                     pb2.getFinalTime(), new double[pb2.getDimension()]);\n     assertEquals(8.0, y[0], 1.0e-12);\n   }\n \n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.4e-10);\n+        assertTrue(nbSteps < 150);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    public VariableHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 100.0));\n+        assertTrue(maxStep > (1.0 / 2.0));\n+      }\n+    }\n+    private boolean firstTime = true;\n+    private double  minStep = 0;\n+    private double  maxStep = 0;\n+  }\n+\n+  private static class InterpolatingStepHandler implements StepHandler {\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+      double prev = interpolator.getPreviousTime();\n+      double curr = interpolator.getCurrentTime();\n+      interpolator.setInterpolatedTime(0.5*(prev + curr));\n+    }\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(DormandPrince853IntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/EulerIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/EulerIntegratorTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n import org.spaceroots.mantissa.fitting.PolynomialFitter;\n \n public class EulerIntegratorTest\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n   public void testOrder()\n   throws EstimationException, DerivativeException,\n          IntegratorException {\n-    PolynomialFitter fitter = new PolynomialFitter(1,\n-                                                   10, 1.0e-7, 1.0e-10,\n-                                                   1.0e-10);\n+    PolynomialFitter fitter =\n+      new PolynomialFitter(1, new LevenbergMarquardtEstimator());\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/EulerStepInterpolatorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/EulerStepInterpolatorTest.java\n     double   t0 = 0;\n     double[] y0 = {0.0, 1.0, -2.0};\n \n-    double[] y = new double[y0.length];\n-    System.arraycopy(y0, 0, y, 0, y0.length);\n+    double[] y = (double[]) y0.clone();\n     double[][] yDot = { new double[y0.length] };\n     EulerStepInterpolator interpolator = new EulerStepInterpolator();\n     interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n \n   }\n \n-  private class DummyEquations\n+  private static class DummyEquations\n     implements FirstOrderDifferentialEquations {\n     public int getDimension() {\n       return 0;\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/FirstOrderConverterTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/FirstOrderConverterTest.java\n     return new TestSuite(FirstOrderConverterTest.class);\n   }\n \n-  private class Equations\n+  private static class Equations\n     implements SecondOrderDifferentialEquations {\n       \n       private int n;\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GillIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GillIntegratorTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n import org.spaceroots.mantissa.fitting.PolynomialFitter;\n \n public class GillIntegratorTest\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n   public void testOrder()\n   throws EstimationException, DerivativeException,\n          IntegratorException {\n-    PolynomialFitter fitter = new PolynomialFitter(1,\n-                                                   10, 1.0e-7, 1.0e-10,\n-                                                   1.0e-10);\n+    PolynomialFitter fitter =\n+      new PolynomialFitter(1, new LevenbergMarquardtEstimator());\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n \n     FirstOrderIntegrator integ = new GillIntegrator(step);\n-    integ.setStepHandler(new StepHandler() {\n-                      private double maxError = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                        maxError = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-\n-                        double[] interpolatedY = interpolator.getInterpolatedState ();\n-                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n-                        double dx = interpolatedY[0] - theoreticalY[0];\n-                        double dy = interpolatedY[1] - theoreticalY[1];\n-                        double error = dx * dx + dy * dy;\n-                        if (error > maxError) {\n-                          maxError = error;\n-                        }\n-                        if (isLast) {\n-                          // even with more than 1000 evaluations per period,\n-                          // RK4 is not able to integrate such an eccentric\n-                          // orbit with a good accuracy\n-                          assertTrue(maxError > 0.001);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new KeplerStepHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     assertEquals(8.0, y[0], 1.0e-12);\n   }\n \n+  private static class KeplerStepHandler implements StepHandler {\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.001);\n+      }\n+    }\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(GillIntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegratorTest.java\n     TestProblemHandler handler = new TestProblemHandler(pb);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-    if (functions != null) {\n-      for (int l = 0; l < functions.length; ++l) {\n-        integ.addSwitchingFunction(functions[l],\n-                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n-      }\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                        absTolerance, relTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      private int nbSteps = 0;\n-                      private double maxError = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return true;\n-                      }\n-                      public void reset() {\n-                        nbSteps = 0;\n-                        maxError = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast)\n-                        throws DerivativeException {\n-\n-                        ++nbSteps;\n-                        for (int a = 1; a < 100; ++a) {\n-\n-                          double prev   = interpolator.getPreviousTime();\n-                          double curr   = interpolator.getCurrentTime();\n-                          double interp = ((100 - a) * prev + a * curr) / 100;\n-                          interpolator.setInterpolatedTime(interp);\n-\n-                          double[] interpolatedY = interpolator.getInterpolatedState ();\n-                          double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n-                          double dx = interpolatedY[0] - theoreticalY[0];\n-                          double dy = interpolatedY[1] - theoreticalY[1];\n-                          double error = dx * dx + dy * dy;\n-                          if (error > maxError) {\n-                            maxError = error;\n-                          }\n-                        }\n-                        if (isLast) {\n-                          assertTrue(maxError < 2.7e-6);\n-                          assertTrue(nbSteps < 80);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new KeplerStepHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     FirstOrderIntegrator integ =\n       new GraggBulirschStoerIntegrator(minStep, maxStep,\n                                        absTolerance, relTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      private boolean firstTime = true;\n-                      private double  minStep = 0;\n-                      private double  maxStep = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                        firstTime = true;\n-                        minStep = 0;\n-                        maxStep = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-\n-                        double step = Math.abs(interpolator.getCurrentTime()\n-                                               - interpolator.getPreviousTime());\n-                        if (firstTime) {\n-                          minStep   = Math.abs(step);\n-                          maxStep   = minStep;\n-                          firstTime = false;\n-                        } else {\n-                          if (step < minStep) {\n-                            minStep = step;\n-                          }\n-                          if (step > maxStep) {\n-                            maxStep = step;\n-                          }\n-                        }\n-\n-                        if (isLast) {\n-                          assertTrue(minStep < 8.2e-3);\n-                          assertTrue(maxStep > 1.7);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new VariableStepHandler());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n     assertEquals(8.0, y[0], 1.0e-12);\n   }\n \n+  private static class KeplerStepHandler implements StepHandler {\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 100; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((100 - a) * prev + a * curr) / 100;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.7e-6);\n+        assertTrue(nbSteps < 80);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static class VariableStepHandler implements StepHandler {\n+    public VariableStepHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < 8.2e-3);\n+        assertTrue(maxStep > 1.7);\n+      }\n+    }\n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n   public static Test suite() {\n     return new TestSuite(GraggBulirschStoerIntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/HighamHall54IntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/HighamHall54IntegratorTest.java\n     TestProblemHandler handler = new TestProblemHandler(pb);\n     integ.setStepHandler(handler);\n     SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-    if (functions != null) {\n-      for (int l = 0; l < functions.length; ++l) {\n-        integ.addSwitchingFunction(functions[l],\n-                                   Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n-      }\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addSwitchingFunction(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep);\n     }\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n                                                             scalAbsoluteTolerance,\n                                                             scalRelativeTolerance);\n-    integ.setStepHandler(new StepHandler() {\n-                      private int nbSteps = 0;\n-                      private double maxError = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                        nbSteps = 0;\n-                        maxError = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-\n-                        ++nbSteps;\n-                        double[] interpolatedY = interpolator.getInterpolatedState ();\n-                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n-                        double dx = interpolatedY[0] - theoreticalY[0];\n-                        double dy = interpolatedY[1] - theoreticalY[1];\n-                        double error = dx * dx + dy * dy;\n-                        if (error > maxError) {\n-                          maxError = error;\n-                        }\n-                        if (isLast) {\n-                          assertTrue(maxError < 1.54e-10);\n-                          assertTrue(nbSteps < 520);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      ++nbSteps;\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 1.54e-10);\n+        assertTrue(nbSteps < 520);\n+      }\n+    }\n+    private TestProblem3 pb;\n+    private int nbSteps;\n+    private double maxError;\n   }\n \n   public static Test suite() {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/MidpointIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/MidpointIntegratorTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n import org.spaceroots.mantissa.fitting.PolynomialFitter;\n \n public class MidpointIntegratorTest\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n \n   public void testOrder()\n   throws EstimationException, DerivativeException, IntegratorException {\n-    PolynomialFitter fitter = new PolynomialFitter(1,\n-                                                   10, 1.0e-7, 1.0e-10,\n-                                                   1.0e-10);\n+    PolynomialFitter fitter =\n+      new PolynomialFitter(1, new LevenbergMarquardtEstimator());\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb,\n                         pb.getInitialTime(), pb.getInitialState(),\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/StepNormalizerTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/StepNormalizerTest.java\n \n   public StepNormalizerTest(String name) {\n     super(name);\n+    pb    = null;\n+    integ = null;\n   }\n \n   public void testBoundaries()\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem1.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem1.java\n    */\n   public TestProblem1(TestProblem1 problem) {\n     super(problem);\n-    y = new double[problem.y.length];\n-    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+    y = (double[]) problem.y.clone();\n   }\n \n   /**\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem2.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem2.java\n    */\n   public TestProblem2(TestProblem2 problem) {\n     super(problem);\n-    y = new double[problem.y.length];\n-    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+    y = (double[]) problem.y.clone();\n   }\n \n   /**\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem3.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem3.java\n   public TestProblem3(TestProblem3 problem) {\n     super(problem);\n     e = problem.e;\n-    y = new double[problem.y.length];\n-    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+    y = (double[]) problem.y.clone();\n   }\n \n   /**\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem4.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem4.java\n   public TestProblem4(TestProblem4 problem) {\n     super(problem);\n     a = problem.a;\n-    y = new double[problem.y.length];\n-    System.arraycopy(problem.y, 0, y, 0, problem.y.length);\n+    y = (double[]) problem.y.clone();\n   }\n \n   /**\n \n   private static class Bounce implements SwitchingFunction {\n \n+    private static final long serialVersionUID = 1356097180027801200L;\n     private int sign;\n \n     public Bounce() {\n \n   private static class Stop implements SwitchingFunction {\n \n+    private static final long serialVersionUID = 6975050568227951931L;\n+\n     public Stop() {\n     }\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblemAbstract.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblemAbstract.java\n     if (problem.y0 == null) {\n       y0 = null;\n     } else {\n-      y0 = new double[problem.y0.length];\n-      System.arraycopy(problem.y0, 0, y0, 0, problem.y0.length);\n+      y0 = (double[]) problem.y0.clone();\n     }\n     if (problem.errorScale == null) {\n       errorScale = null;\n     } else {\n-      errorScale = new double[problem.errorScale.length];\n-      System.arraycopy(problem.errorScale, 0, errorScale, 0,\n-                       problem.errorScale.length);\n+      errorScale = (double[]) problem.errorScale.clone();\n     }\n     t1 = problem.t1;\n   }\n     calls     = 0;\n     n         = y0.length;\n     this.t0   = t0;\n-    this.y0   = new double[y0.length];\n-    System.arraycopy(y0, 0, this.y0, 0, y0.length); \n+    this.y0   = (double[]) y0.clone(); \n    }\n \n   /**\n    * @param errorScale error scale\n    */\n   protected void setErrorScale(double[] errorScale) {\n-    this.errorScale = new double[errorScale.length];\n-    System.arraycopy(errorScale, 0, this.errorScale, 0,\n-                     errorScale.length); \n+    this.errorScale = (double[]) errorScale.clone(); \n   }\n \n   public int getDimension() {\n    * @return switching functions\n    */\n   public SwitchingFunction[] getSwitchingFunctions() {\n-    return null;\n+    return new SwitchingFunction[0];\n   }\n \n   /**\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ThreeEighthesIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/ThreeEighthesIntegratorTest.java\n import junit.framework.*;\n \n import org.spaceroots.mantissa.estimation.EstimationException;\n+import org.spaceroots.mantissa.estimation.LevenbergMarquardtEstimator;\n import org.spaceroots.mantissa.fitting.PolynomialFitter;\n \n public class ThreeEighthesIntegratorTest\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n   public void testOrder()\n   throws EstimationException, DerivativeException,\n          IntegratorException {\n-    PolynomialFitter fitter = new PolynomialFitter(1,\n-                                                   10, 1.0e-7, 1.0e-10,\n-                                                   1.0e-10);\n+    PolynomialFitter fitter =\n+      new PolynomialFitter(1, new LevenbergMarquardtEstimator());\n \n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n         TestProblemHandler handler = new TestProblemHandler(pb);\n         integ.setStepHandler(handler);\n         SwitchingFunction[] functions = pb.getSwitchingFunctions();\n-        if (functions != null) {\n-          for (int l = 0; l < functions.length; ++l) {\n-            integ.addSwitchingFunction(functions[l],\n-                                       Double.POSITIVE_INFINITY, 1.0e-6 * step);\n-          }\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addSwitchingFunction(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step);\n         }\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n \n     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n-    integ.setStepHandler(new StepHandler() {\n-                      private double maxError = 0;\n-                      public boolean requiresDenseOutput() {\n-                        return false;\n-                      }\n-                      public void reset() {\n-                        maxError = 0;\n-                      }\n-                      public void handleStep(StepInterpolator interpolator,\n-                                             boolean isLast) {\n-\n-                        double[] interpolatedY = interpolator.getInterpolatedState ();\n-                        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n-                        double dx = interpolatedY[0] - theoreticalY[0];\n-                        double dy = interpolatedY[1] - theoreticalY[1];\n-                        double error = dx * dx + dy * dy;\n-                        if (error > maxError) {\n-                          maxError = error;\n-                        }\n-                        if (isLast) {\n-                          // even with more than 1000 evaluations per period,\n-                          // RK4 is not able to integrate such an eccentric\n-                          // orbit with a good accuracy\n-                          assertTrue(maxError > 0.005);\n-                        }\n-                      }\n-      });\n+    integ.setStepHandler(new KeplerHandler(pb));\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n   }\n \n+  private static class KeplerHandler implements StepHandler {\n+\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      maxError = 0;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+      maxError = 0;\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+\n+    private TestProblem3 pb;\n+    private double maxError = 0;\n+\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(ThreeEighthesIntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/optimization/MultiDirectionalTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/optimization/MultiDirectionalTest.java\n                                        new double[] {  3.5, -2.3 });\n \n     assertTrue(count > 60);\n-    assertTrue(optimum.getCost() > 0.02);\n+    assertTrue(optimum.cost > 0.02);\n \n   }\n \n                                        new double[] {  3.0, -1.0, 0.0, 1.0 },\n                                        new double[] {  4.0,  0.0, 1.0, 2.0 });\n     assertTrue(count > 850);\n-    assertTrue(optimum.getCost() > 0.015);\n+    assertTrue(optimum.cost > 0.015);\n \n   }\n \n-  private class ValueChecker implements ConvergenceChecker {\n+  private static class ValueChecker implements ConvergenceChecker {\n \n     public ValueChecker(double threshold) {\n       this.threshold = threshold;\n     public boolean converged(PointCostPair[] simplex) {\n       PointCostPair smallest = simplex[0];\n       PointCostPair largest  = simplex[simplex.length - 1];\n-      return (largest.getCost() - smallest.getCost()) < threshold;\n+      return (largest.cost - smallest.cost) < threshold;\n     }\n \n     private double threshold;\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/optimization/NelderMeadTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/optimization/NelderMeadTest.java\n                                  new double[] {  3.5, -2.3 });\n \n     assertTrue(count < 50);\n-    assertEquals(0.0, optimum.getCost(), 6.0e-4);\n-    assertEquals(1.0, optimum.getPoint()[0], 0.05);\n-    assertEquals(1.0, optimum.getPoint()[1], 0.05);\n+    assertEquals(0.0, optimum.cost, 6.0e-4);\n+    assertEquals(1.0, optimum.point[0], 0.05);\n+    assertEquals(1.0, optimum.point[1], 0.05);\n \n   }\n \n                                  new double[] {  3.0, -1.0, 0.0, 1.0 },\n                                  new double[] {  4.0,  0.0, 1.0, 2.0 });\n     assertTrue(count < 150);\n-    assertEquals(0.0, optimum.getCost(), 6.0e-4);\n-    assertEquals(0.0, optimum.getPoint()[0], 0.07);\n-    assertEquals(0.0, optimum.getPoint()[1], 0.07);\n-    assertEquals(0.0, optimum.getPoint()[2], 0.07);\n-    assertEquals(0.0, optimum.getPoint()[3], 0.07);\n+    assertEquals(0.0, optimum.cost, 6.0e-4);\n+    assertEquals(0.0, optimum.point[0], 0.07);\n+    assertEquals(0.0, optimum.point[1], 0.07);\n+    assertEquals(0.0, optimum.point[2], 0.07);\n+    assertEquals(0.0, optimum.point[3], 0.07);\n \n   }\n \n-  private class ValueChecker implements ConvergenceChecker {\n+  private static class ValueChecker implements ConvergenceChecker {\n \n     public ValueChecker(double threshold) {\n       this.threshold = threshold;\n     public boolean converged(PointCostPair[] simplex) {\n       PointCostPair smallest = simplex[0];\n       PointCostPair largest  = simplex[simplex.length - 1];\n-      return (largest.getCost() - smallest.getCost()) < threshold;\n+      return (largest.cost - smallest.cost) < threshold;\n     }\n \n     private double threshold;\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegratorTest.java\n     return new TestSuite(GaussLegendreIntegratorTest.class);\n   }\n \n-  private class Polynom implements ComputableFunction {\n+  private static class Polynom implements ComputableFunction {\n+\n     public Polynom(int degree, Random random, double max) {\n       coeffs = new double[degree + 1];\n       for (int i = 0; i <= degree; ++i) {\n \n     private double[] coeffs;\n \n+     private static final long serialVersionUID = -7304282612679254557L;\n+\n   }\n \n }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegratorTest.java\n     return new TestSuite(GaussLegendreIntegratorTest.class);\n   }\n \n-  private class Polynom implements ComputableFunction {\n+  private static class Polynom implements ComputableFunction {\n     public Polynom (int degree, Random random, double max) {\n       coeffs0 = new double[degree + 1];\n       coeffs1 = new double[degree + 1];\n     private double[] coeffs0;\n     private double[] coeffs1;\n \n+    private static final long serialVersionUID = -8032020368915042278L;\n+\n   }\n \n }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/random/CorrelatedRandomVectorGeneratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/CorrelatedRandomVectorGeneratorTest.java\n \n   public CorrelatedRandomVectorGeneratorTest(String name) {\n     super(name);\n+    mean       = null;\n+    covariance = null;\n+    generator  = null;\n   }\n \n   public void testRank() {\n       sample.add(generator.nextVector());\n     }\n \n-    double[] estimatedMean = sample.getMean(null);\n+    double[] estimatedMean = sample.getMean();\n     SymetricalMatrix estimatedCovariance = sample.getCovarianceMatrix(null);\n     for (int i = 0; i < estimatedMean.length; ++i) {\n       assertEquals(mean[i], estimatedMean[i], 0.07);\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/random/ScalarSampleStatisticsTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/ScalarSampleStatisticsTest.java\n \n   public ScalarSampleStatisticsTest(String name) {\n     super(name);\n+    points = null;\n   }\n \n   public void testBasicStats() {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/random/UncorrelatedRandomVectorGeneratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/UncorrelatedRandomVectorGeneratorTest.java\n \n   public UncorrelatedRandomVectorGeneratorTest(String name) {\n     super(name);\n+    mean = null;\n+    standardDeviation = null;\n+    generator = null;\n   }\n \n   public void testMeanAndCorrelation() {\n       sample.add(generator.nextVector());\n     }\n \n-    double[] estimatedMean = sample.getMean(null);\n+    double[] estimatedMean = sample.getMean();\n     double scale;\n     SymetricalMatrix estimatedCorrelation = sample.getCovarianceMatrix(null);\n     for (int i = 0; i < estimatedMean.length; ++i) {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/random/VectorialSampleStatisticsTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/random/VectorialSampleStatisticsTest.java\n \n   public VectorialSampleStatisticsTest(String name) {\n     super(name);\n+    points = null;\n   }\n \n   public void testSimplistic() {\n \n     double[] min = sample.getMin();\n     double[] max = sample.getMax();\n-    double[] mean = sample.getMean(null);\n+    double[] mean = sample.getMean();\n     SymetricalMatrix c = sample.getCovarianceMatrix(null);\n \n     double[]   refMin  = new double[] {-0.70, 0.00, -3.10};\n \n     double[] min = even.getMin();\n     double[] max = even.getMax();\n-    double[] mean = even.getMean(null);\n+    double[] mean = even.getMean();\n     SymetricalMatrix c = even.getCovarianceMatrix(null);\n \n     double[] refMin = all.getMin();\n     double[] refMax = all.getMax();\n-    double[] refMean = all.getMean(null);\n+    double[] refMean = all.getMean();\n     SymetricalMatrix refC = all.getCovarianceMatrix(null);\n \n     for (int i = 0; i < min.length; ++i) {\n \n     double[] min = direct.getMin();\n     double[] max = direct.getMax();\n-    double[] mean = direct.getMean(null);\n+    double[] mean = direct.getMean();\n     SymetricalMatrix c = direct.getCovarianceMatrix(null);\n \n     double[] refMin = loop.getMin();\n     double[] refMax = loop.getMax();\n-    double[] refMean = loop.getMean(null);\n+    double[] refMean = loop.getMean();\n     SymetricalMatrix refC = loop.getCovarianceMatrix(null);\n \n     for (int i = 0; i < min.length; ++i) {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/roots/BrentSolverTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/roots/BrentSolverTest.java\n \n   }\n \n-  private class Checker implements ConvergenceChecker {\n+  private static class Checker implements ConvergenceChecker {\n \n     private double tolerance;\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/roots/TestProblem.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/roots/TestProblem.java\n       problems.add(new APSProblem28(n28[k], -10000.0, 10000.0, roots28[k]));\n     }\n \n-    return (TestProblem[]) problems.toArray(new TestProblem[0]);\n+    return (TestProblem[]) problems.toArray(new TestProblem[problems.size()]);\n \n   }\n \n   private static class APSProblem1 extends TestProblem {\n+    private static final long serialVersionUID = -186095948802525864L;\n     public APSProblem1(double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n     }\n   }\n \n   private static class APSProblems2To11 extends TestProblem {\n+    private static final long serialVersionUID = -1284328672006328516L;\n     public APSProblems2To11(double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n     }\n   }\n \n   private static class APSProblems12To14 extends TestProblem {\n+    private static final long serialVersionUID = 3371996034561221313L;\n     private int n;\n     public APSProblems12To14(int n, double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n   }\n \n   private static class APSProblems15To17 extends TestProblem {\n+    private static final long serialVersionUID = -5460543876513796612L;\n     private int    n;\n     private double u;\n     public APSProblems15To17(int n, double u,\n   }\n \n   private static class APSProblem18 extends TestProblem {\n+    private static final long serialVersionUID = 6762799934117390438L;\n     public APSProblem18(double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n     }\n   }\n \n   private static class APSProblem19 extends TestProblem {\n+    private static final long serialVersionUID = 4962041891152128524L;\n     private int n;\n     public APSProblem19(int n, double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n   }\n \n   private static class APSProblem20 extends TestProblem {\n+    private static final long serialVersionUID = -7391954140799812791L;\n     private int n;\n     private int oPoMn2;\n     public APSProblem20(int n, double a, double b, double expectedRoot) {\n   }\n \n   private static class APSProblem21 extends TestProblem {\n+    private static final long serialVersionUID = -4160028543895639114L;\n     private int n;\n     public APSProblem21(int n, double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n   }\n \n   private static class APSProblem22 extends TestProblem {\n+    private static final long serialVersionUID = 3807046732154081146L;\n     private int n;\n     private int oPoMn4;\n     public APSProblem22(int n, double a, double b, double expectedRoot) {\n   }\n \n   private static class APSProblem23 extends TestProblem {\n+    private static final long serialVersionUID = -486669213837396921L;\n     private int n;\n     public APSProblem23(int n, double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n   }\n \n   private static class APSProblem24 extends TestProblem {\n+    private static final long serialVersionUID = -628275471717968182L;\n     private int n;\n     public APSProblem24(int n, double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n   }\n \n   private static class APSProblem25 extends TestProblem {\n+    private static final long serialVersionUID = 5207170686914959073L;\n     private double u;\n     private double v;;\n     public APSProblem25(int n, double a, double b, double expectedRoot) {\n   }\n \n   private static class APSProblem26 extends TestProblem {\n+    private static final long serialVersionUID = 1063884352586457076L;\n+\n     public APSProblem26(double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n     }\n   }\n \n   private static class APSProblem27 extends TestProblem {\n+    private static final long serialVersionUID = -3549158218723499035L;\n     private double u;\n     public APSProblem27(int n, double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n   }\n \n   private static class APSProblem28 extends TestProblem {\n+    private static final long serialVersionUID = -8198306839874267863L;\n     private double threshold;\n-    private double yHigh;\n+    private static final double yHigh= Math.exp(1.0) - 1.859;\n     private int    u;\n     public APSProblem28(int n, double a, double b, double expectedRoot) {\n       super(a, b, expectedRoot);\n       threshold = 0.002 / (1 + n);\n-      yHigh     = Math.exp(1.0) - 1.859;\n       u         = (n + 1) * 500;\n     }\n     public double valueAt(double x) {\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/ArrayMapperTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/ArrayMapperTest.java\n   public ArrayMapperTest(String name) {\n     super(name);\n     mapper = null;\n+    b1 = null;\n+    b2 = null;\n+    b3 = null;\n   }\n \n   public void testDimensionCheck() {\n     int size = b1.getStateDimension();\n     size += b2.getStateDimension();\n     size += b3.getStateDimension();\n-    assertTrue(mapper.getInternalDataArray().length == size);\n+    assertTrue(mapper.getDataArray().length == size);\n   }\n \n   public void testUpdateObjects() {\n \n     mapper.updateArray();\n \n-    double[] data = mapper.getInternalDataArray();\n+    double[] data = mapper.getDataArray();\n     for (int i = 0; i < 7; ++i) {\n       assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);\n     }\n     return new TestSuite(ArrayMapperTest.class);\n   }\n \n-  private class DomainObject implements ArraySliceMappable {\n+  private static class DomainObject implements ArraySliceMappable {\n \n     private double[] data;\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/MappableArrayTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/MappableArrayTest.java\n \n   public MappableArrayTest(String name) {\n     super(name);\n+    array1 = null;\n+    array2 = null;\n+    array3 = null;\n+    mapper = null;\n   }\n \n   public void testDimensionCheck() {\n-    assertTrue(mapper.getInternalDataArray().length == 9);\n+    assertTrue(mapper.getDataArray().length == 9);\n   }\n \n-  public void testRealloc() {\n+  public void testUpdateObjects() {\n \n-    for (int i = 0; i < reusedArray.length; ++i) {\n-      reusedArray[i] = -1.0;\n-    }\n-\n-    for (int i = 0; i < clonedArray.length; ++i) {\n-      clonedArray[i] = -1.0;\n-    }\n-\n-    double[] data = new double [mapper.getInternalDataArray().length];\n+    double[] data = new double [mapper.getDataArray().length];\n     for (int i = 0; i < data.length; ++i) {\n       data [i] = i * 0.1;\n     }\n \n     mapper.updateObjects(data);\n \n-    assertTrue(Math.abs(reusedArray[0] - 0.4) < 1.0e-10);\n-    assertTrue(Math.abs(reusedArray[1] - 0.5) < 1.0e-10);\n+    double[] a1 = array1.getArray();\n+    assertTrue(Math.abs(a1[0] - 0.0) < 1.0e-10);\n+    assertTrue(Math.abs(a1[1] - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(a1[2] - 0.2) < 1.0e-10);\n+    assertTrue(Math.abs(a1[3] - 0.3) < 1.0e-10);\n \n-    assertTrue(Math.abs(clonedArray[0] + 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(clonedArray[1] + 1.0) < 1.0e-10);\n-    assertTrue(Math.abs(clonedArray[2] + 1.0) < 1.0e-10);\n+    double[] a2 = array2.getArray();\n+    assertTrue(Math.abs(a2[0] - 0.4) < 1.0e-10);\n+    assertTrue(Math.abs(a2[1] - 0.5) < 1.0e-10);\n \n-  }\n-  \n-  public void testUpdateObjects() {\n-\n-    double[] data = new double [mapper.getInternalDataArray().length];\n-    for (int i = 0; i < data.length; ++i) {\n-      data [i] = i * 0.1;\n-    }\n-\n-    mapper.updateObjects(data);\n-\n-    assertTrue(Math.abs(array1.getArray()[0] - 0.0) < 1.0e-10);\n-    assertTrue(Math.abs(array1.getArray()[1] - 0.1) < 1.0e-10);\n-    assertTrue(Math.abs(array1.getArray()[2] - 0.2) < 1.0e-10);\n-    assertTrue(Math.abs(array1.getArray()[3] - 0.3) < 1.0e-10);\n-\n-    assertTrue(Math.abs(array2.getArray()[0] - 0.4) < 1.0e-10);\n-    assertTrue(Math.abs(array2.getArray()[1] - 0.5) < 1.0e-10);\n-\n-    assertTrue(Math.abs(array3.getArray()[0] - 0.6) < 1.0e-10);\n-    assertTrue(Math.abs(array3.getArray()[1] - 0.7) < 1.0e-10);\n-    assertTrue(Math.abs(array3.getArray()[2] - 0.8) < 1.0e-10);\n-\n-  }\n-  \n-  public void testUpdateArray() {\n-\n-    array1.getArray()[0] = 00.0;\n-    array1.getArray()[1] = 10.0;\n-    array1.getArray()[2] = 20.0;\n-    array1.getArray()[3] = 30.0;\n-\n-    array2.getArray()[0] = 40.0;\n-    array2.getArray()[1] = 50.0;\n-\n-    array3.getArray()[0] = 60.0;\n-    array3.getArray()[1] = 70.0;\n-    array3.getArray()[2] = 80.0;\n-\n-    mapper.updateArray();\n-\n-    double[] data = mapper.getInternalDataArray();\n-    for (int i = 0; i < data.length; ++i) {\n-      assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);\n-    }\n+    double[] a3 = array3.getArray();\n+    assertTrue(Math.abs(a3[0] - 0.6) < 1.0e-10);\n+    assertTrue(Math.abs(a3[1] - 0.7) < 1.0e-10);\n+    assertTrue(Math.abs(a3[2] - 0.8) < 1.0e-10);\n \n   }\n   \n \n   public void setUp() {\n \n-    reusedArray = new double[2];\n-    clonedArray = new double[3];\n-\n     array1 = new MappableArray(4);\n-    array2 = new MappableArray(reusedArray, false);\n-    array3 = new MappableArray(clonedArray, true);\n+    array2 = new MappableArray(new double[2]);\n+    array3 = new MappableArray(new double[3]);\n \n     mapper = new ArrayMapper();\n     mapper.manageMappable(array1);\n   }\n \n   public void tearDown() {\n-    reusedArray = null;\n-    clonedArray = null;\n-\n     array1 = null;\n     array2 = null;\n     array3 = null;\n-\n     mapper = null;\n-\n   }\n-\n-  private double[] reusedArray;\n-  private double[] clonedArray;\n \n   private MappableArray array1;\n   private MappableArray array2;\n   private MappableArray array3;\n-\n-  private ArrayMapper mapper;\n+  private ArrayMapper   mapper;\n \n }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/MappableScalarTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/utilities/MappableScalarTest.java\n \n   public MappableScalarTest(String name) {\n     super(name);\n+    mapper  = null;\n+    scalar1 = null;\n+    scalar2 = null;\n+    scalar3 = null;\n   }\n \n   public void testDimensionCheck() {\n-    assertTrue(mapper.getInternalDataArray().length == 3);\n+    assertTrue(mapper.getDataArray().length == 3);\n   }\n \n   public void testUpdateObjects() {\n \n-    double[] data = new double [mapper.getInternalDataArray().length];\n+    double[] data = new double [mapper.getDataArray().length];\n     for (int i = 0; i < data.length; ++i) {\n       data [i] = i * 0.1;\n     }\n \n     mapper.updateArray();\n \n-    double[] data = mapper.getInternalDataArray();\n+    double[] data = mapper.getDataArray();\n     for (int i = 0; i < data.length; ++i) {\n       assertTrue(Math.abs(data [i] - i * 10.0) < 1.0e-10);\n     }", "timestamp": 1166566267, "metainfo": ""}