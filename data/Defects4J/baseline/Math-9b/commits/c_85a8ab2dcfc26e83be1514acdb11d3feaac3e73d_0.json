{"sha": "85a8ab2dcfc26e83be1514acdb11d3feaac3e73d", "log": "Fixed error in binomial coefficient computation JIRA: MATH-241 Reported and patched by Christian Semrau  ", "commit": "\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n-\n-        long result = Math.round(binomialCoefficientDouble(n, k));\n-        if (result == Long.MAX_VALUE) {\n-            throw new ArithmeticException(\n-                \"result too large to represent in a long integer\");\n+        // Use symmetry for large k\n+        if (k > n / 2)\n+            return binomialCoefficient(n, n - k);\n+        \n+        // We use the formula\n+        // (n choose k) = n! / (n-k)! / k!\n+        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n+        // which could be written\n+        // (n choose k) == (n-1 choose k-1) * n / k\n+        long result = 1;\n+        if (n <= 61) {\n+            // For n <= 61, the naive implementation cannot overflow.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                result = result * i / j;\n+            }\n+        } else if (n <= 66) {\n+            // For n > 61 but n <= 66, the result cannot overflow,\n+            // but we must take care not to overflow intermediate values.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                // We know that (result * i) is divisible by j,\n+                // but (result * i) may overflow, so we split j:\n+                // Filter out the gcd, d, so j/d and i/d are integer.\n+                // result is divisible by (j/d) because (j/d)\n+                // is relative prime to (i/d) and is a divisor of\n+                // result * (i/d).\n+                long d = gcd(i, j);\n+                result = (result / (j / d)) * (i / d);\n+            }\n+        } else {\n+            // For n > 66, a result overflow might occur, so we check\n+            // the multiplication, taking care to not overflow\n+            // unnecessary.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                long d = gcd(i, j);\n+                result = mulAndCheck((result / (j / d)), (i / d));\n+            }\n         }\n         return result;\n     }\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientDouble(final int n, final int k) {\n-        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n+        if (n < k) {\n+            throw new IllegalArgumentException(\n+                \"must have n >= k for binomial coefficient (n,k)\");\n+        }\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\n+                \"must have n >= 0 for binomial coefficient (n,k)\");\n+        }\n+        if ((n == k) || (k == 0)) {\n+            return 1d;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        if (k > n/2) {\n+            return binomialCoefficientDouble(n, n - k);\n+        }\n+        if (n < 67) {\n+            return binomialCoefficient(n,k);\n+        }\n+        \n+        double result = 1d;\n+        for (int i = 1; i <= k; i++) {\n+             result *= (double)(n - k + i) / (double)i;\n+        }\n+  \n+        return Math.floor(result + 0.5);\n     }\n     \n     /**\n             return 0;\n         }\n         if ((k == 1) || (k == n - 1)) {\n-            return Math.log((double)n);\n-        }\n+            return Math.log((double) n);\n+        }\n+        \n+        /*\n+         * For values small enough to do exact integer computation,\n+         * return the log of the exact value \n+         */\n+        if (n < 67) {  \n+            return Math.log(binomialCoefficient(n,k));\n+        }\n+        \n+        /*\n+         * Return the log of binomialCoefficientDouble for values that will not\n+         * overflow binomialCoefficientDouble\n+         */\n+        if (n < 1030) { \n+            return Math.log(binomialCoefficientDouble(n, k));\n+        } \n+        \n+        /*\n+         * Sum logs for values that could overflow\n+         */\n         double logSum = 0;\n \n         // n!/k!\n             logSum -= Math.log((double)i);\n         }\n \n-        return logSum;\n+        return logSum;      \n     }\n     \n     /**\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n package org.apache.commons.math.util;\n \n import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n         return suite;\n     }\n \n+    /** cached binomial coefficients */\n+    private static List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();\n+\n     /**\n-     * Exact recursive implementation to test against\n+     * Exact (caching) recursive implementation to test against\n      */\n-    private long binomialCoefficient(int n, int k) {\n+    private long binomialCoefficient(int n, int k) throws ArithmeticException {\n+        if (binomialCache.size() > n) {\n+            Long cachedResult = binomialCache.get(n).get(new Integer(k));\n+            if (cachedResult != null) {\n+                return cachedResult.longValue();\n+            }\n+        }\n+        long result = -1;\n         if ((n == k) || (k == 0)) {\n-            return 1;\n-        }\n-        if ((k == 1) || (k == n - 1)) {\n-            return n;\n-        }\n-        return binomialCoefficient(n - 1, k - 1) + binomialCoefficient(n - 1, k);\n+            result = 1;\n+        } else if ((k == 1) || (k == n - 1)) {\n+            result = n;\n+        } else {\n+            result = MathUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),\n+                binomialCoefficient(n - 1, k));\n+        }\n+        if (result == -1) {\n+            throw new ArithmeticException(\n+                \"error computing binomial coefficient\");\n+        }\n+        for (int i = binomialCache.size(); i < n + 1; i++) {\n+            binomialCache.add(new HashMap<Integer, Long>());\n+        }\n+        binomialCache.get(n).put(new Integer(k), new Long(result));\n+        return result;\n     }\n \n     /**\n             }\n         }\n \n-        /*\n-         * Takes a long time for recursion to unwind, but succeeds and yields\n-         * exact value = 2,333,606,220\n-         * assertEquals(MathUtils.binomialCoefficient(34,17),\n-         * binomialCoefficient(34,17));\n-         */\n+        assertEquals(binomialCoefficient(34, 17), MathUtils\n+            .binomialCoefficient(34, 17));\n+    }\n+\n+    /**\n+     * Tests correctness for large n and sharpness of upper bound in API doc\n+     * JIRA: MATH-241\n+     */\n+    public void testBinomialCoefficientLarge() throws Exception {\n+        // This tests all legal and illegal values for n <= 200.\n+        for (int n = 0; n <= 200; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                long ourResult = -1;\n+                long exactResult = -1;\n+                boolean shouldThrow = false;\n+                boolean didThrow = false;\n+                try {\n+                    ourResult = MathUtils.binomialCoefficient(n, k);\n+                } catch (ArithmeticException ex) {\n+                    didThrow = true;\n+                }\n+                try {\n+                    exactResult = binomialCoefficient(n, k);\n+                } catch (ArithmeticException ex) {\n+                    shouldThrow = true;\n+                }\n+                assertEquals(n+\",\"+k, shouldThrow, didThrow);\n+                assertEquals(n+\",\"+k, exactResult, ourResult);\n+                assertTrue(n+\",\"+k, (n > 66 || !didThrow));\n+            }\n+        }\n+\n+        long ourResult = MathUtils.binomialCoefficient(300, 3);\n+        long exactResult = binomialCoefficient(300, 3);\n+        assertEquals(exactResult, ourResult);\n+\n+        ourResult = MathUtils.binomialCoefficient(700, 697);\n+        exactResult = binomialCoefficient(700, 697);\n+        assertEquals(exactResult, ourResult);\n+\n+        // This one should throw\n+        try {\n+            MathUtils.binomialCoefficient(700, 300);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // Expected\n+        }\n+\n+        // Larger values cannot be computed directly by our\n+        // test implementation because of stack limitations,\n+        // so we make little jumps to fill the cache.\n+        for (int i = 2000; i <= 10000; i += 2000) {\n+            ourResult = MathUtils.binomialCoefficient(i, 3);\n+            exactResult = binomialCoefficient(i, 3);\n+            assertEquals(exactResult, ourResult);\n+        }\n+\n     }\n \n     public void testBinomialCoefficientFail() {\n             ;\n         }\n         try {\n+            MathUtils.binomialCoefficient(67, 30);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            ;\n+        }\n+        try {\n             MathUtils.binomialCoefficient(67, 34);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n             ;\n         }\n         double x = MathUtils.binomialCoefficientDouble(1030, 515);\n-        assertTrue(\"expecting infinite binomial coefficient\", Double.isInfinite(x));\n+        assertTrue(\"expecting infinite binomial coefficient\", Double\n+            .isInfinite(x));\n     }\n \n     public void testCosh() {", "timestamp": 1232409122, "metainfo": ""}