{"sha": "814d15af44642e09a1c37ac66d4f172949abf674", "log": "In distribution.FastCosineTransformer, replaced the pair transform2() / inverseTransform2() with two factory methods: create() and createOrthogonal() (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  * @since 1.2\n  */\n public class FastCosineTransformer implements RealTransformer {\n-\n-    /** Construct a default transformer. */\n-    public FastCosineTransformer() {\n-        super();\n-    }\n-\n-    /**\n-     * Transform the given real data set.\n+    /**\n+     * {@code true} if the orthogonal version of the DCT should be used.\n+     *\n+     * @see #create()\n+     * @see #createOrthogonal()\n+     */\n+    private final boolean orthogonal;\n+\n+    /**\n+     * Creates a new instance of this class, with various normalization\n+     * conventions.\n+     *\n+     * @param orthogonal {@code false} if the DCT is <em>not</em> to be scaled,\n+     * {@code true} if it is to be scaled so as to make the transform\n+     * orthogonal.\n+     * @see #create()\n+     * @see #createOrthogonal()\n+     */\n+    public FastCosineTransformer(final boolean orthogonal) {\n+        this.orthogonal = orthogonal;\n+    }\n+\n+    /**\n      * <p>\n-     * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n-     *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n+     * Returns a new instance of this class. The returned transformer uses the\n+     * normalizing conventions described below.\n+     * <ul>\n+     * <li>Forward transform:\n+     * y<sub>n</sub> = (1/2) [x<sub>0</sub> + (-1)<sup>n</sup>x<sub>N-1</sub>]\n+     * + &sum;<sub>k=1</sub><sup>N-2</sup>\n+     * x<sub>k</sub> cos[&pi; nk / (N - 1)],</li>\n+     * <li>Inverse transform:\n+     * x<sub>k</sub> = [1 / (N - 1)] [y<sub>0</sub>\n+     * + (-1)<sup>k</sup>y<sub>N-1</sub>]\n+     * + [2 / (N - 1)] &sum;<sub>n=1</sub><sup>N-2</sup>\n+     * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n+     * </ul>\n+     * where N is the size of the data sample.\n      * </p>\n+     *\n+     * @return a new DCT transformer, with \"standard\" normalizing conventions\n+     */\n+    public static FastCosineTransformer create() {\n+        return new FastCosineTransformer(false);\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a new instance of this class. The returned transformer uses the\n+     * normalizing conventions described below.\n+     * <ul>\n+     * <li>Forward transform:\n+     * y<sub>n</sub> = [2(N - 1)]<sup>-1/2</sup> [x<sub>0</sub>\n+     * + (-1)<sup>n</sup>x<sub>N-1</sub>]\n+     * + [2 / (N - 1)]<sup>1/2</sup> &sum;<sub>k=1</sub><sup>N-2</sup>\n+     * x<sub>k</sub> cos[&pi; nk / (N - 1)],</li>\n+     * <li>Inverse transform:\n+     * x<sub>k</sub> = [2(N - 1)]<sup>-1/2</sup> [y<sub>0</sub>\n+     * + (-1)<sup>k</sup>y<sub>N-1</sub>]\n+     * + [2 / (N - 1)]<sup>1/2</sup> &sum;<sub>n=1</sub><sup>N-2</sup>\n+     * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n+     * </ul>\n+     * which make the transform orthogonal. N is the size of the data sample.\n+     * </p>\n+     *\n+     * @return a new DCT transformer, with \"orthogonal\" normalizing conventions\n+     */\n+    public static FastCosineTransformer createOrthogonal() {\n+        return new FastCosineTransformer(true);\n+    }\n+\n+    /**\n+     * Returns the forward transform of the specified real data set.\n      *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform(double[] f) throws IllegalArgumentException {\n+\n+        if (orthogonal) {\n+            final double s = FastMath.sqrt(2.0 / (f.length - 1));\n+            return FastFourierTransformer.scaleArray(fct(f), s);\n+        }\n         return fct(f);\n     }\n \n     /**\n-     * Transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n-     *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n-     * </p>\n+     * Returns the forward transform of the specified real function, sampled on\n+     * the specified interval.\n      *\n      * @param f the function to be sampled and transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n+     * @param min the (inclusive) lower bound for the interval\n+     * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] transform(UnivariateFunction f,\n-                              double min, double max, int n)\n-        throws IllegalArgumentException {\n-        double[] data = FastFourierTransformer.sample(f, min, max, n);\n-        return fct(data);\n-    }\n-\n-    /**\n-     * Transform the given real data set.\n-     * <p>\n-     * The formula is F<sub>n</sub> = &radic;(1/2N) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n-     *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the real data array to be transformed\n-     * @return the real transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform2(double[] f) throws IllegalArgumentException {\n-\n-        double scalingCoefficient = FastMath.sqrt(2.0 / (f.length - 1));\n-        return FastFourierTransformer.scaleArray(fct(f), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Transform the given real function, sampled on the given interval.\n-     * <p>\n-     * The formula is F<sub>n</sub> = &radic;(1/2N) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n-     *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n-     *\n-     * </p>\n-     *\n-     * @param f the function to be sampled and transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the real transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] transform2(UnivariateFunction f,\n-                               double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        double[] data = FastFourierTransformer.sample(f, min, max, n);\n-        double scalingCoefficient = FastMath.sqrt(2.0 / (n - 1));\n-        return FastFourierTransformer.scaleArray(fct(data), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real data set.\n-     * <p>\n-     * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n-     *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n-     * </p>\n+        double min, double max, int n) throws IllegalArgumentException {\n+\n+        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        return transform(data);\n+    }\n+\n+    /**\n+     * Returns the inverse transform of the specified real data set.\n      *\n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] inverseTransform(double[] f)\n-    throws IllegalArgumentException {\n-\n-        double scalingCoefficient = 2.0 / (f.length - 1);\n-        return FastFourierTransformer.scaleArray(fct(f), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real function, sampled on the given\n-     * interval.\n-     * <p>\n-     * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n-     *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n-     * </p>\n+        throws IllegalArgumentException {\n+\n+        final double s2 = 2.0 / (f.length - 1);\n+        final double s1 = orthogonal ? FastMath.sqrt(s2) : s2;\n+        return FastFourierTransformer.scaleArray(fct(f), s1);\n+    }\n+\n+    /**\n+     * Returns the inverse transform of the specified real function, sampled\n+     * on the given interval.\n      *\n      * @param f the function to be sampled and inversely transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n+     * @param min the (inclusive) lower bound for the interval\n+     * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double[] inverseTransform(UnivariateFunction f,\n-                                     double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        double[] data = FastFourierTransformer.sample(f, min, max, n);\n-        double scalingCoefficient = 2.0 / (n - 1);\n-        return FastFourierTransformer.scaleArray(fct(data), scalingCoefficient);\n-    }\n-\n-    /**\n-     * Inversely transform the given real data set.\n-     * <p>\n-     * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n-     *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the real data array to be inversely transformed\n-     * @return the real inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inverseTransform2(double[] f)\n-        throws IllegalArgumentException {\n-        return transform2(f);\n-    }\n-\n-    /**\n-     * Inversely transform the given real function, sampled on the given\n-     * interval.\n-     * <p>\n-     * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n-     *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n-     * </p>\n-     *\n-     * @param f the function to be sampled and inversely transformed\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param n the number of sample points\n-     * @return the real inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double[] inverseTransform2(UnivariateFunction f,\n-                                      double min, double max, int n)\n-        throws IllegalArgumentException {\n-\n-        return transform2(f, min, max, n);\n+        double min, double max, int n) throws IllegalArgumentException {\n+\n+        final double[] data = FastFourierTransformer.sample(f, min, max, n);\n+        return inverseTransform(data);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n      */\n     @Test\n     public void testAdHocData() {\n-        FastCosineTransformer transformer = new FastCosineTransformer();\n+        FastCosineTransformer transformer = FastCosineTransformer.create();\n         double result[], tolerance = 1E-12;\n \n         double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 };\n \n         FastFourierTransformer.scaleArray(x, FastMath.sqrt(0.5 * (x.length-1)));\n \n-        result = transformer.transform2(y);\n+        transformer = FastCosineTransformer.createOrthogonal();\n+        result = transformer.transform(y);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n         }\n \n-        result = transformer.inverseTransform2(x);\n+        result = transformer.inverseTransform(x);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(y[i], result[i], tolerance);\n         }\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        FastCosineTransformer transformer = new FastCosineTransformer();\n+        FastCosineTransformer transformer = FastCosineTransformer.create();\n         double min, max, result[], tolerance = 1E-12; int N = 9;\n \n         double expected[] = { 0.0, 3.26197262739567, 0.0,\n     @Test\n     public void testParameters() throws Exception {\n         UnivariateFunction f = new SinFunction();\n-        FastCosineTransformer transformer = new FastCosineTransformer();\n+        FastCosineTransformer transformer = FastCosineTransformer.create();\n \n         try {\n             // bad interval", "timestamp": 1323413243, "metainfo": ""}