{"sha": "ec7c825789105f5ba575ce5050ab21c05702d1da", "log": "Added missing throws declarations. JIRA: MATH-854.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math3/stat/StatUtils.java\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      *\n      * @param values the input array\n      * @return the variance of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double variance(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double variance(final double[] values) throws MathIllegalArgumentException {\n         return VARIANCE.evaluate(values);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null or the\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n      * array index parameters are not valid.</p>\n      *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     public static double variance(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return VARIANCE.evaluate(values, begin, length);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null or the\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n      * array index parameters are not valid.</p>\n      *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     public static double variance(final double[] values, final double mean,\n-            final int begin, final int length) {\n+            final int begin, final int length) throws MathIllegalArgumentException {\n         return VARIANCE.evaluate(values, mean, begin, length);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @return the variance of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double variance(final double[] values, final double mean) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double variance(final double[] values, final double mean)\n+    throws MathIllegalArgumentException {\n         return VARIANCE.evaluate(values, mean);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      *\n      * @param values the input array\n      * @return the population variance of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double populationVariance(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double populationVariance(final double[] values)\n+    throws MathIllegalArgumentException {\n         return new Variance(false).evaluate(values);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null or the\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n      * array index parameters are not valid.</p>\n      *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the population variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     public static double populationVariance(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return new Variance(false).evaluate(values, begin, length);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null or the\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n      * array index parameters are not valid.</p>\n      *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the population variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     public static double populationVariance(final double[] values, final double mean,\n-            final int begin, final int length) {\n+            final int begin, final int length) throws MathIllegalArgumentException {\n         return new Variance(false).evaluate(values, mean, begin, length);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @return the population variance of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double populationVariance(final double[] values, final double mean) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double populationVariance(final double[] values, final double mean)\n+    throws MathIllegalArgumentException {\n         return new Variance(false).evaluate(values, mean);\n     }\n \n      * Returns the maximum of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * <ul>\n      * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      *\n      * @param values the input array\n      * @return the maximum of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double max(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double max(final double[] values) throws MathIllegalArgumentException {\n         return MAX.evaluate(values);\n     }\n \n      * the input array, or <code>Double.NaN</code> if the designated subarray\n      * is empty.\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null or\n      * the array index parameters are not valid.</p>\n      * <p>\n      * <ul>\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the maximum of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n      */\n     public static double max(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return MAX.evaluate(values, begin, length);\n     }\n \n      * Returns the minimum of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * <ul>\n      * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      *\n      * @param values the input array\n      * @return the minimum of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double min(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double min(final double[] values) throws MathIllegalArgumentException {\n         return MIN.evaluate(values);\n     }\n \n      * the input array, or <code>Double.NaN</code> if the designated subarray\n      * is empty.\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null or\n      * the array index parameters are not valid.</p>\n      * <p>\n      * <ul>\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the minimum of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n      */\n     public static double min(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return MIN.evaluate(values, begin, length);\n     }\n \n      * @param values input array of values\n      * @param p the percentile value to compute\n      * @return the percentile value or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if <code>values</code> is null\n+     * @throws MathIllegalArgumentException if <code>values</code> is null\n      * or p is invalid\n      */\n-    public static double percentile(final double[] values, final double p) {\n+    public static double percentile(final double[] values, final double p)\n+    throws MathIllegalArgumentException {\n             return PERCENTILE.evaluate(values,p);\n     }\n \n      * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n      * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n      *  if <code>length = 1 </code></li>\n-     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>\n      *  is null , <code>begin</code> or <code>length</code> is invalid, or\n      * <code>p</code> is not a valid quantile value (p must be greater than 0\n      * and less than or equal to 100)</li>\n      * </ul></p>\n      * <p>\n-      * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n-      * a description of the percentile estimation algorithm used.</p>\n+     * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n+     * a description of the percentile estimation algorithm used.</p>\n      *\n      * @param values array of input values\n      * @param p  the percentile to compute\n      * @param begin  the first (0-based) element to include in the computation\n      * @param length  the number of array elements to include\n      * @return  the percentile value\n-     * @throws IllegalArgumentException if the parameters are not valid or the\n+     * @throws MathIllegalArgumentException if the parameters are not valid or the\n      * input array is null\n      */\n     public static double percentile(final double[] values, final int begin,\n-            final int length, final double p) {\n+            final int length, final double p) throws MathIllegalArgumentException {\n         return PERCENTILE.evaluate(values, begin, length, p);\n     }\n \n      * (positive) length.\n      * @throws NoDataException if the sample arrays are empty.\n      */\n-    public static double sumDifference(final double[] sample1, final double[] sample2) {\n+    public static double sumDifference(final double[] sample1, final double[] sample2)\n+    throws DimensionMismatchException, NoDataException {\n         int n = sample1.length;\n         if (n != sample2.length) {\n             throw new DimensionMismatchException(n, sample2.length);\n      * (positive) length.\n      * @throws NoDataException if the sample arrays are empty.\n      */\n-    public static double meanDifference(final double[] sample1, final double[] sample2) {\n+    public static double meanDifference(final double[] sample1, final double[] sample2)\n+    throws DimensionMismatchException, NoDataException{\n         return sumDifference(sample1, sample2) / sample1.length;\n     }\n \n      * @throws NumberIsTooSmallException if the arrays length is less than 2.\n      */\n     public static double varianceDifference(final double[] sample1,\n-                                            final double[] sample2,\n-                                            double meanDifference) {\n+            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n+            NumberIsTooSmallException {\n         double sum1 = 0d;\n         double sum2 = 0d;\n         double diff = 0d;\n     }\n \n     /**\n-     * Normalize (standardize) the series, so in the end it is having a mean of 0 and a standard deviation of 1.\n+     * Normalize (standardize) the sample, so it is has a mean of 0 and a standard deviation of 1.\n      *\n      * @param sample Sample to normalize.\n      * @return normalized (standardized) sample.\n--- a/src/main/java/org/apache/commons/math3/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/stat/clustering/KMeansPlusPlusClusterer.java\n      * @return a list of clusters containing the points\n      * @throws MathIllegalArgumentException if the data points are null or the number\n      *     of clusters is larger than the number of data points\n+     * @throws ConvergenceException if an empty cluster is encountered and the\n+     * {@link #emptyStrategy} is set to {@code ERROR}\n      */\n     public List<Cluster<T>> cluster(final Collection<T> points, final int k,\n                                     int numTrials, int maxIterationsPerTrial)\n-        throws MathIllegalArgumentException {\n+        throws MathIllegalArgumentException, ConvergenceException {\n \n         // at first, we have not found any clusters list yet\n         List<Cluster<T>> best = null;\n      * @return a list of clusters containing the points\n      * @throws MathIllegalArgumentException if the data points are null or the number\n      *     of clusters is larger than the number of data points\n+     * @throws ConvergenceException if an empty cluster is encountered and the\n+     * {@link #emptyStrategy} is set to {@code ERROR}\n      */\n     public List<Cluster<T>> cluster(final Collection<T> points, final int k,\n                                     final int maxIterations)\n-        throws MathIllegalArgumentException {\n+        throws MathIllegalArgumentException, ConvergenceException {\n \n         // sanity checks\n         MathUtils.checkNotNull(points);\n      *\n      * @param clusters the {@link Cluster}s to search\n      * @return a random point from the selected cluster\n-     */\n-    private T getPointFromLargestVarianceCluster(final Collection<Cluster<T>> clusters) {\n+     * @throws ConvergenceException if clusters are all empty\n+     */\n+    private T getPointFromLargestVarianceCluster(final Collection<Cluster<T>> clusters)\n+    throws ConvergenceException {\n \n         double maxVariance = Double.NEGATIVE_INFINITY;\n         Cluster<T> selected = null;\n      *\n      * @param clusters the {@link Cluster}s to search\n      * @return a random point from the selected cluster\n-     */\n-    private T getPointFromLargestNumberCluster(final Collection<Cluster<T>> clusters) {\n+     * @throws ConvergenceException if clusters are all empty\n+     */\n+    private T getPointFromLargestNumberCluster(final Collection<Cluster<T>> clusters) throws ConvergenceException {\n \n         int maxNumber = 0;\n         Cluster<T> selected = null;\n      *\n      * @param clusters the {@link Cluster}s to search\n      * @return point farthest to its cluster center\n-     */\n-    private T getFarthestPoint(final Collection<Cluster<T>> clusters) {\n+     * @throws ConvergenceException if clusters are all empty\n+     */\n+    private T getFarthestPoint(final Collection<Cluster<T>> clusters) throws ConvergenceException {\n \n         double maxDistance = Double.NEGATIVE_INFINITY;\n         Cluster<T> selectedCluster = null;\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n      *\n      * @param data rectangular array with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n-     * @throws IllegalArgumentException if the input data array is not\n+     * @throws MathIllegalArgumentException if the input data array is not\n      * rectangular with at least two rows and two columns.\n      */\n-    public Covariance(double[][] data, boolean biasCorrected) {\n+    public Covariance(double[][] data, boolean biasCorrected)\n+    throws MathIllegalArgumentException {\n         this(new BlockRealMatrix(data), biasCorrected);\n     }\n \n      * and two rows</p>\n      *\n      * @param data rectangular array with columns representing covariates\n-     * @throws IllegalArgumentException if the input data array is not\n+     * @throws MathIllegalArgumentException if the input data array is not\n      * rectangular with at least two rows and two columns.\n      */\n-    public Covariance(double[][] data) {\n+    public Covariance(double[][] data) throws MathIllegalArgumentException {\n         this(data, true);\n     }\n \n      *\n      * @param matrix matrix with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n-     * @throws IllegalArgumentException if the input matrix does not have\n+     * @throws MathIllegalArgumentException if the input matrix does not have\n      * at least two rows and two columns\n      */\n-    public Covariance(RealMatrix matrix, boolean biasCorrected) {\n+    public Covariance(RealMatrix matrix, boolean biasCorrected)\n+    throws MathIllegalArgumentException {\n        checkSufficientData(matrix);\n        n = matrix.getRowDimension();\n        covarianceMatrix = computeCovarianceMatrix(matrix, biasCorrected);\n      * <p>The matrix must have at least two columns and two rows</p>\n      *\n      * @param matrix matrix with columns representing covariates\n-     * @throws IllegalArgumentException if the input matrix does not have\n+     * @throws MathIllegalArgumentException if the input matrix does not have\n      * at least two rows and two columns\n      */\n-    public Covariance(RealMatrix matrix) {\n+    public Covariance(RealMatrix matrix) throws MathIllegalArgumentException {\n         this(matrix, true);\n     }\n \n      * @param matrix input matrix (must have at least two columns and two rows)\n      * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n      * @return covariance matrix\n-     */\n-    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) {\n+     * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n+     */\n+    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n+    throws MathIllegalArgumentException {\n         int dimension = matrix.getColumnDimension();\n         Variance variance = new Variance(biasCorrected);\n         RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n      * covariates. Covariances are computed using the bias-corrected formula.\n      * @param matrix input matrix (must have at least two columns and two rows)\n      * @return covariance matrix\n+     * @throws MathIllegalArgumentException if matrix does not contain sufficient data\n      * @see #Covariance\n      */\n-    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix) {\n+    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix)\n+    throws MathIllegalArgumentException {\n         return computeCovarianceMatrix(matrix, true);\n     }\n \n      * @param data input array (must have at least two columns and two rows)\n      * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n      * @return covariance matrix\n-     */\n-    protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) {\n+     * @throws MathIllegalArgumentException if the data array does not contain sufficient\n+     * data\n+     */\n+    protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n+    throws MathIllegalArgumentException {\n         return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n     }\n \n      * covariates. Covariances are computed using the bias-corrected formula.\n      * @param data input array (must have at least two columns and two rows)\n      * @return covariance matrix\n+     * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n      * @see #Covariance\n      */\n-    protected RealMatrix computeCovarianceMatrix(double[][] data) {\n+    protected RealMatrix computeCovarianceMatrix(double[][] data) throws MathIllegalArgumentException {\n         return computeCovarianceMatrix(data, true);\n     }\n \n      * @param yArray second data array\n      * @param biasCorrected if true, returned value will be bias-corrected\n      * @return returns the covariance for the two arrays\n-     * @throws  IllegalArgumentException if the arrays lengths do not match or\n+     * @throws  MathIllegalArgumentException if the arrays lengths do not match or\n      * there is insufficient data\n      */\n     public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n-        throws IllegalArgumentException {\n+        throws MathIllegalArgumentException {\n         Mean mean = new Mean();\n         double result = 0d;\n         int length = xArray.length;\n      * @param xArray first data array\n      * @param yArray second data array\n      * @return returns the covariance for the two arrays\n-     * @throws  IllegalArgumentException if the arrays lengths do not match or\n+     * @throws  MathIllegalArgumentException if the arrays lengths do not match or\n      * there is insufficient data\n      */\n     public double covariance(final double[] xArray, final double[] yArray)\n-        throws IllegalArgumentException {\n+        throws MathIllegalArgumentException {\n         return covariance(xArray, yArray, true);\n     }\n \n     /**\n-     * Throws IllegalArgumentException of the matrix does not have at least\n-     * two columns and two rows\n+     * Throws MathIllegalArgumentException if the matrix does not have at least\n+     * two columns and two rows.\n      * @param matrix matrix to check\n-     */\n-    private void checkSufficientData(final RealMatrix matrix) {\n+     * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n+     * to compute covariance\n+     */\n+    private void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {\n         int nRows = matrix.getRowDimension();\n         int nCols = matrix.getColumnDimension();\n         if (nRows < 2 || nCols < 2) {\n--- a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n \n         final double z = (Umin - EU) / FastMath.sqrt(VarU);\n \n+        // No try-catch or advertised exception because args are valid\n         final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n \n         return 2 * standardNormal.cumulativeProbability(z);\n--- a/src/main/java/org/apache/commons/math3/stat/inference/OneWayAnova.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/OneWayAnova.java\n         ConvergenceException, MaxCountExceededException {\n \n         AnovaStats a = anovaStats(categoryData);\n+        // No try-catch or advertised exception because args are valid\n         FDistribution fdist = new FDistribution(a.dfbg, a.dfwg);\n         return 1.0 - fdist.cumulativeProbability(a.F);\n \n     }\n \n     /**\n-        Convenience class to pass dfbg,dfwg,F values around within AnovaImpl.\n+        Convenience class to pass dfbg,dfwg,F values around within OneWayAnova.\n         No get/set methods provided.\n     */\n     private static class AnovaStats {\n--- a/src/main/java/org/apache/commons/math3/stat/inference/TTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/TTest.java\n \n import org.apache.commons.math3.distribution.TDistribution;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n         throws NullArgumentException, NumberIsTooSmallException {\n \n         checkSampleData(observed);\n+        // No try-catch or advertised exception because args have just been checked\n         return t(StatUtils.mean(observed), mu, StatUtils.variance(observed),\n                 observed.length);\n \n \n         checkSampleData(sample1);\n         checkSampleData(sample2);\n+        // No try-catch or advertised exception because args have just been checked\n         return homoscedasticT(StatUtils.mean(sample1), StatUtils.mean(sample2),\n                               StatUtils.variance(sample1), StatUtils.variance(sample2),\n                               sample1.length, sample2.length);\n \n         checkSampleData(sample1);\n         checkSampleData(sample2);\n+        // No try-catch or advertised exception because args have just been checked\n         return t(StatUtils.mean(sample1), StatUtils.mean(sample2),\n                  StatUtils.variance(sample1), StatUtils.variance(sample2),\n                  sample1.length, sample2.length);\n         MaxCountExceededException {\n \n         checkSampleData(sample);\n+        // No try-catch or advertised exception because args have just been checked\n         return tTest(StatUtils.mean(sample), mu, StatUtils.variance(sample),\n                      sample.length);\n \n \n         checkSampleData(sample1);\n         checkSampleData(sample2);\n+        // No try-catch or advertised exception because args have just been checked\n         return tTest(StatUtils.mean(sample1), StatUtils.mean(sample2),\n                      StatUtils.variance(sample1), StatUtils.variance(sample2),\n                      sample1.length, sample2.length);\n \n         checkSampleData(sample1);\n         checkSampleData(sample2);\n+        // No try-catch or advertised exception because args have just been checked\n         return homoscedasticTTest(StatUtils.mean(sample1),\n                                   StatUtils.mean(sample2),\n                                   StatUtils.variance(sample1),\n      * @param n sample n\n      * @return p-value\n      * @throws MaxCountExceededException if an error occurs computing the p-value\n+     * @throws MathIllegalArgumentException if n is not greater than 1\n      */\n     protected double tTest(final double m, final double mu,\n                            final double v, final double n)\n-        throws MaxCountExceededException {\n+        throws MaxCountExceededException, MathIllegalArgumentException {\n \n         double t = FastMath.abs(t(m, mu, v, n));\n         TDistribution distribution = new TDistribution(n - 1);\n      * @param n2 second sample n\n      * @return p-value\n      * @throws MaxCountExceededException if an error occurs computing the p-value\n+     * @throws NotStrictlyPositiveException if the estimated degrees of freedom is not\n+     * strictly positive\n      */\n     protected double tTest(final double m1, final double m2,\n                            final double v1, final double v2,\n                            final double n1, final double n2)\n-        throws MaxCountExceededException {\n+        throws MaxCountExceededException, NotStrictlyPositiveException {\n \n         final double t = FastMath.abs(t(m1, m2, v1, v2, n1, n2));\n         final double degreesOfFreedom = df(v1, v2, n1, n2);\n      * @param n2 second sample n\n      * @return p-value\n      * @throws MaxCountExceededException if an error occurs computing the p-value\n+     * @throws NotStrictlyPositiveException if the estimated degrees of freedom is not\n+     * strictly positive\n      */\n     protected double homoscedasticTTest(double m1, double m2,\n                                         double v1, double v2,\n                                         double n1, double n2)\n-        throws MaxCountExceededException {\n+        throws MaxCountExceededException, NotStrictlyPositiveException {\n \n         final double t = FastMath.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));\n         final double degreesOfFreedom = n1 + n2 - 2;\n--- a/src/main/java/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/WilcoxonSignedRankTest.java\n         // - 0.5 is a continuity correction\n         final double z = (Wmin - ES - 0.5) / FastMath.sqrt(VarS);\n \n+        // No try-catch or advertised exception because args are valid\n         final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n \n         return 2*standardNormal.cumulativeProbability(z);\n--- a/src/main/java/org/apache/commons/math3/stat/ranking/NaturalRanking.java\n+++ b/src/main/java/org/apache/commons/math3/stat/ranking/NaturalRanking.java\n                 Iterator<Integer> iterator = tiesTrace.iterator();\n                 long f = FastMath.round(c);\n                 while (iterator.hasNext()) {\n+                    // No advertised exception because args are guaranteed valid\n                     ranks[iterator.next()] =\n                         randomData.nextLong(f, f + length - 1);\n                 }\n--- a/src/main/java/org/apache/commons/math3/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/AbstractMultipleLinearRegression.java\n      * @throws MathIllegalArgumentException if the number of rows of {@code x}\n      * is not larger than the number of columns + 1\n      */\n-    protected void validateSampleData(double[][] x, double[] y) {\n+    protected void validateSampleData(double[][] x, double[] y) throws MathIllegalArgumentException {\n         if ((x == null) || (y == null)) {\n             throw new NullArgumentException();\n         }\n--- a/src/main/java/org/apache/commons/math3/stat/regression/MillerUpdatingRegression.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/MillerUpdatingRegression.java\n      * @param numberOfVariables number of regressors to expect, not including constant\n      * @param includeConstant include a constant automatically\n      * @param errorTolerance  zero tolerance, how machine zero is determined\n-     */\n-    public MillerUpdatingRegression(int numberOfVariables, boolean includeConstant, double errorTolerance) {\n+     * @throws ModelSpecificationException if {@code numberOfVariables is less than 1}\n+     */\n+    public MillerUpdatingRegression(int numberOfVariables, boolean includeConstant, double errorTolerance)\n+    throws ModelSpecificationException {\n         if (numberOfVariables < 1) {\n             throw new ModelSpecificationException(LocalizedFormats.NO_REGRESSORS);\n         }\n      *\n      * @param numberOfVariables maximum number of potential regressors\n      * @param includeConstant include a constant automatically\n-     */\n-    public MillerUpdatingRegression(int numberOfVariables, boolean includeConstant) {\n+     * @throws ModelSpecificationException if {@code numberOfVariables is less than 1}\n+     */\n+    public MillerUpdatingRegression(int numberOfVariables, boolean includeConstant)\n+    throws ModelSpecificationException {\n         this(numberOfVariables, includeConstant, Precision.EPSILON);\n     }\n \n      * @exception ModelSpecificationException if the length of {@code x} does not equal\n      * the number of independent variables in the model\n      */\n-    public void addObservation(final double[] x, final double y) {\n+    public void addObservation(final double[] x, final double y)\n+    throws ModelSpecificationException {\n \n         if ((!this.hasIntercept && x.length != nvars) ||\n                (this.hasIntercept && x.length + 1 != nvars)) {\n      * @throws ModelSpecificationException if {@code x} is not rectangular, does not match\n      * the length of {@code y} or does not contain sufficient data to estimate the model\n      */\n-    public void addObservations(double[][] x, double[] y) {\n+    public void addObservations(double[][] x, double[] y) throws ModelSpecificationException {\n         if ((x == null) || (y == null) || (x.length != y.length)) {\n             throw new ModelSpecificationException(\n                   LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n      * @param nreq how many of the regressors to include (either in canonical\n      * order, or in the current reordered state)\n      * @return an array with the estimated slope coefficients\n-     */\n-    private double[] regcf(int nreq) {\n+     * @throws ModelSpecificationException if {@code nreq} is less than 1\n+     * or greater than the number of independent variables\n+     */\n+    private double[] regcf(int nreq) throws ModelSpecificationException {\n         int nextr;\n         if (nreq < 1) {\n             throw new ModelSpecificationException(LocalizedFormats.NO_REGRESSORS);\n--- a/src/main/java/org/apache/commons/math3/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/OLSMultipleLinearRegression.java\n  */\n package org.apache.commons.math3.stat.regression;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.LUDecomposition;\n import org.apache.commons.math3.linear.QRDecomposition;\n      * Computes and caches QR decomposition of the X matrix.\n      * @param y the [n,1] array representing the y sample\n      * @param x the [n,k] array representing the x sample\n-     * @throws IllegalArgumentException if the x and y array data are not\n+     * @throws MathIllegalArgumentException if the x and y array data are not\n      *             compatible for the regression\n      */\n-    public void newSampleData(double[] y, double[][] x) {\n+    public void newSampleData(double[] y, double[][] x) throws MathIllegalArgumentException {\n         validateSampleData(x, y);\n         newYSampleData(y);\n         newXSampleData(x);\n      * formula is from \"The Hat Matrix in Regression and ANOVA\",\n      * David C. Hoaglin and Roy E. Welsch,\n      * <i>The American Statistician</i>, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.\n+     * </p>\n+     * <p>Data for the model must have been successfully loaded using one of\n+     * the {@code newSampleData} methods before invoking this method; otherwise\n+     * a {@code NullPointerException} will be thrown.</p>\n      *\n      * @return the hat matrix\n      */\n         RealMatrix Q = qr.getQ();\n         final int p = qr.getR().getColumnDimension();\n         final int n = Q.getColumnDimension();\n+        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n         Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n         double[][] augIData = augI.getDataRef();\n         for (int i = 0; i < n; i++) {\n         }\n \n         // Compute and return Hat matrix\n+        // No DME advertised - args valid if we get here\n         return Q.multiply(augI).multiply(Q.transpose());\n     }\n \n      * the {@link #calculateRSquared() R-squared} computation.</p>\n      *\n      * @return SSTO - the total sum of squares\n+     * @throws MathIllegalArgumentException if the sample has not been set or does\n+     * not contain at least 3 observations\n      * @see #isNoIntercept()\n      * @since 2.2\n      */\n-    public double calculateTotalSumOfSquares() {\n+    public double calculateTotalSumOfSquares() throws MathIllegalArgumentException {\n         if (isNoIntercept()) {\n             return StatUtils.sumSq(getY().toArray());\n         } else {\n      */\n     public double calculateResidualSumOfSquares() {\n         final RealVector residuals = calculateResiduals();\n+        // No advertised DME, args are valid\n         return residuals.dotProduct(residuals);\n     }\n \n      * and SSTO is the {@link #calculateTotalSumOfSquares() total sum of squares}\n      *\n      * @return R-square statistic\n-     * @since 2.2\n-     */\n-    public double calculateRSquared() {\n+     * @throws MathIllegalArgumentException if the sample has not been set or does\n+     * not contain at least 3 observations\n+     * @since 2.2\n+     */\n+    public double calculateRSquared() throws MathIllegalArgumentException {\n         return 1 - calculateResidualSumOfSquares() / calculateTotalSumOfSquares();\n     }\n \n      * </pre></p>\n      *\n      * @return adjusted R-Squared statistic\n+     * @throws MathIllegalArgumentException if the sample has not been set or does\n+     * not contain at least 3 observations\n      * @see #isNoIntercept()\n      * @since 2.2\n      */\n-    public double calculateAdjustedRSquared() {\n+    public double calculateAdjustedRSquared() throws MathIllegalArgumentException {\n         final double n = getX().getRowDimension();\n         if (isNoIntercept()) {\n             return 1 - (1 - calculateRSquared()) * (n / (n - getX().getColumnDimension()));\n     /**\n      * Calculates the regression coefficients using OLS.\n      *\n+     * <p>Data for the model must have been successfully loaded using one of\n+     * the {@code newSampleData} methods before invoking this method; otherwise\n+     * a {@code NullPointerException} will be thrown.</p>\n+     *\n      * @return beta\n      */\n     @Override\n      * <p>Uses QR decomposition to reduce (X<sup>T</sup>X)<sup>-1</sup>\n      * to (R<sup>T</sup>R)<sup>-1</sup>, with only the top p rows of\n      * R included, where p = the length of the beta vector.</p>\n+     *\n+     * <p>Data for the model must have been successfully loaded using one of\n+     * the {@code newSampleData} methods before invoking this method; otherwise\n+     * a {@code NullPointerException} will be thrown.</p>\n      *\n      * @return The beta variance-covariance matrix\n      */\n--- a/src/main/java/org/apache/commons/math3/stat/regression/RegressionResults.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/RegressionResults.java\n      * @throws OutOfRangeException if {@code index} is not in the interval\n      * {@code [0, number of parameters)}.\n      */\n-    public double getParameterEstimate(int index) {\n+    public double getParameterEstimate(int index) throws OutOfRangeException {\n         if (parameters == null) {\n             return Double.NaN;\n         }\n      * @throws OutOfRangeException if {@code index} is not in the interval\n      * {@code [0, number of parameters)}.\n      */\n-    public double getStdErrorOfEstimate(int index) {\n+    public double getStdErrorOfEstimate(int index) throws OutOfRangeException {\n         if (parameters == null) {\n             return Double.NaN;\n         }\n      * @throws OutOfRangeException if {@code i} or {@code j} is not in the\n      * interval {@code [0, number of parameters)}.\n      */\n-    public double getCovarianceOfParameters(int i, int j) {\n+    public double getCovarianceOfParameters(int i, int j) throws OutOfRangeException {\n         if (parameters == null) {\n             return Double.NaN;\n         }\n--- a/src/main/java/org/apache/commons/math3/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/SimpleRegression.java\n      * @throws ModelSpecificationException if the length of {@code data[i]} is not\n      * greater than or equal to 2\n      */\n-    public void addData(final double[][] data) {\n+    public void addData(final double[][] data) throws ModelSpecificationException {\n         for (int i = 0; i < data.length; i++) {\n             if( data[i].length < 2 ){\n                throw new ModelSpecificationException(LocalizedFormats.INVALID_REGRESSION_OBSERVATION,\n      * @throws ModelSpecificationException if the length of {@code x} does not equal\n      * the number of independent variables in the model\n      */\n-    public void addObservation(final double[] x,final double y) throws ModelSpecificationException{\n+    public void addObservation(final double[] x,final double y)\n+    throws ModelSpecificationException {\n         if( x == null || x.length == 0 ){\n             throw new ModelSpecificationException(LocalizedFormats.INVALID_REGRESSION_OBSERVATION,x!=null?x.length:0, 1);\n         }\n      * @throws ModelSpecificationException if {@code x} is not rectangular, does not match\n      * the length of {@code y} or does not contain sufficient data to estimate the model\n      */\n-    public void addObservations(final double[][] x,final double[] y) {\n+    public void addObservations(final double[][] x,final double[] y) throws ModelSpecificationException {\n         if ((x == null) || (y == null) || (x.length != y.length)) {\n             throw new ModelSpecificationException(\n                   LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n      * @return half-width of 95% confidence interval for the slope estimate\n      * @throws OutOfRangeException if the confidence interval can not be computed.\n      */\n-    public double getSlopeConfidenceInterval() {\n+    public double getSlopeConfidenceInterval() throws OutOfRangeException {\n         return getSlopeConfidenceInterval(0.05d);\n     }\n \n      * @return half-width of 95% confidence interval for the slope estimate\n      * @throws OutOfRangeException if the confidence interval can not be computed.\n      */\n-    public double getSlopeConfidenceInterval(final double alpha) {\n+    public double getSlopeConfidenceInterval(final double alpha)\n+    throws OutOfRangeException {\n+        if (n < 3) {\n+            return Double.NaN;\n+        }\n         if (alpha >= 1 || alpha <= 0) {\n             throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,\n                                           alpha, 0, 1);\n         }\n+        // No advertised NotStrictlyPositiveException here - will return NaN above\n         TDistribution distribution = new TDistribution(n - 2);\n         return getSlopeStdErr() *\n             distribution.inverseCumulativeProbability(1d - alpha / 2d);\n      * if the significance level can not be computed.\n      */\n     public double getSignificance() {\n+        if (n < 3) {\n+            return Double.NaN;\n+        }\n+        // No advertised NotStrictlyPositiveException here - will return NaN above\n         TDistribution distribution = new TDistribution(n - 2);\n         return 2d * (1.0 - distribution.cumulativeProbability(\n                     FastMath.abs(getSlope()) / getSlopeStdErr()));\n     }\n \n     /**\n-     * Performs a regression on data present in buffers and outputs a RegressionResults object\n+     * Performs a regression on data present in buffers and outputs a RegressionResults object.\n+     *\n+     * <p>If there are fewer than 3 observations in the model and {@code hasIntercept} is true\n+     * a {@code NoDataException} is thrown.  If there is no intercept term, the model must\n+     * contain at least 2 observations.</p>\n+     *\n      * @return RegressionResults acts as a container of regression output\n      * @throws ModelSpecificationException if the model is not correctly specified\n-     */\n-    public RegressionResults regress() throws ModelSpecificationException{\n-        if( hasIntercept ){\n+     * @throws NoDataException if there is not sufficient data in the model to\n+     * estimate the regression parameters\n+     */\n+    public RegressionResults regress() throws ModelSpecificationException, NoDataException {\n+        if (hasIntercept) {\n           if( n < 3 ){\n-              throw new NoDataException( LocalizedFormats.NOT_ENOUGH_DATA_REGRESSION );\n+              throw new NoDataException(LocalizedFormats.NOT_ENOUGH_DATA_REGRESSION);\n           }\n           if( FastMath.abs( sumXX ) > Precision.SAFE_MIN ){\n               final double[] params = new double[]{ getIntercept(), getSlope() };\n                       sumY, sumYY, getSumSquaredErrors(),true,false);\n           }\n         }else{\n-          if( n < 2 ){\n-              throw new NoDataException( LocalizedFormats.NOT_ENOUGH_DATA_REGRESSION );\n+          if (n < 2) {\n+              throw new NoDataException(LocalizedFormats.NOT_ENOUGH_DATA_REGRESSION);\n           }\n           if( !Double.isNaN(sumXX) ){\n           final double[] vcv = new double[]{ getMeanSquareError() / sumXX };\n      * indexed in variablesToInclude and outputs a RegressionResults object\n      * @param variablesToInclude an array of indices of regressors to include\n      * @return RegressionResults acts as a container of regression output\n-     * @throws ModelSpecificationException if the model is not correctly specified\n      * @throws MathIllegalArgumentException if the variablesToInclude array is null or zero length\n      * @throws OutOfRangeException if a requested variable is not present in model\n      */\n-    public RegressionResults regress(int[] variablesToInclude) throws ModelSpecificationException{\n+    public RegressionResults regress(int[] variablesToInclude) throws MathIllegalArgumentException{\n         if( variablesToInclude == null || variablesToInclude.length == 0){\n           throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED);\n         }\n--- a/src/main/java/org/apache/commons/math3/stat/regression/UpdatingMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/UpdatingMultipleLinearRegression.java\n  * limitations under the License.\n  */\n package org.apache.commons.math3.stat.regression;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NoDataException;\n \n /**\n  * An interface for regression models allowing for dynamic updating of the data.\n      * Performs a regression on data present in buffers and outputs a RegressionResults object\n      * @return RegressionResults acts as a container of regression output\n      * @throws ModelSpecificationException if the model is not correctly specified\n+     * @throws NoDataException if there is not sufficient data in the model to\n+     * estimate the regression parameters\n      */\n-    RegressionResults regress() throws ModelSpecificationException;\n+    RegressionResults regress() throws ModelSpecificationException, NoDataException;\n \n     /**\n      * Performs a regression on data present in buffers including only regressors\n      * @param variablesToInclude an array of indices of regressors to include\n      * @return RegressionResults acts as a container of regression output\n      * @throws ModelSpecificationException if the model is not correctly specified\n+     * @throws MathIllegalArgumentException if the variablesToInclude array is null or zero length\n      */\n-    RegressionResults regress(int[] variablesToInclude) throws ModelSpecificationException;\n+    RegressionResults regress(int[] variablesToInclude) throws ModelSpecificationException, MathIllegalArgumentException;\n }", "timestamp": 1349100532, "metainfo": ""}