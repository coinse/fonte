{"sha": "85387dc2d55dbbcc54063ff1ec2ab1f909bef7a4", "log": "Added a new minimization package with an implementation of the Brent algorithm contributed by Gilles Sadowski. The implementation needs some testing as it seems to never use the parabola fitting and only relying on golden section. This may be due to the refactoring I did on the original patch. Jira: MATH-177  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/minimization/BrentMinimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.minimization;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements Richard Brent's algorithm (from his book \"Algorithms for\n+ * Minimization without Derivatives\", p. 79) for finding minima of real\n+ * univariate functions.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BrentMinimizer extends UnivariateRealMinimizerImpl {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7185472920191999565L;\n+\n+    /**\n+     * Golden section.\n+     */\n+    private static final double c = 0.5 * (3 - Math.sqrt(5));\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public BrentMinimizer() {\n+        super(100, 1E-10);\n+    }\n+\n+    /**\n+     * Find a minimum in the given interval, start at startValue.\n+     * <p>\n+     * A minimizer may require that the interval brackets a single minimum.\n+     * </p>\n+     * @param f the function to minimize.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue this parameter is <em>not</em> used at all\n+     * @return a value where the function is minimum\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the minimizer detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the minimizer\n+     */\n+    public double minimize(final UnivariateRealFunction f,\n+                           final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return minimize(f, min, max);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public double minimize(final UnivariateRealFunction f,\n+                           final double min, final double max)\n+        throws MaxIterationsExceededException, \n+        FunctionEvaluationException {\n+        clearResult();\n+        return localmin(min, max, relativeAccuracy, absoluteAccuracy, f);\n+    }\n+    \n+    /**\n+     * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n+     *\n+     * If the function {@code f} is defined on the interval {@code (a, b)}, then\n+     * this method finds an approximation {@code x} to the point at which {@code f}\n+     * attains its minimum.<br/>\n+     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n+     * {@code f} is never evaluated at two points closer together than {@code tol}.\n+     * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n+     * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n+     * machine precision. {@code t} should be positive.\n+     *\n+     * @param f the function to solve\n+     * @param a Lower bound of the interval.\n+     * @param b Higher bound of the interval.\n+     * @param eps Relative accuracy.\n+     * @param t Absolute accuracy.\n+     * @return the point at which the function is minimal.\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded.\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function. \n+     */\n+    private double localmin(double a, double b, final double eps,\n+                            final double t, final UnivariateRealFunction f)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        double x = a + c * (b - a);\n+        double v = x;\n+        double w = x;\n+        double e = 0;\n+        double fx = f.value(x);\n+        double fv = fx;\n+        double fw = fx;\n+\n+        int count = 0;\n+        while (count < maximalIterationCount) {\n+            double m = 0.5 * (a + b);\n+            double tol = eps * Math.abs(x) + t;\n+            double t2 = 2 * tol;\n+\n+            // Check stopping criterion.\n+            if (Math.abs(x - m) > t2 - 0.5 * (b - a)) {\n+                double p = 0;\n+                double q = 0;\n+                double r = 0;\n+                double d = 0;\n+                double u = 0;\n+\n+                if (Math.abs(e) > tol) { // Fit parabola.\n+                    r = (x - w) * (fx - fv);\n+                    q = (x - v) * (fx - fw);\n+                    p = (x - v) * q - (x - w) * r;\n+                    q = 2 * (q - r);\n+\n+                    if (q > 0) {\n+                        p = -p;\n+                    } else {\n+                        q = -q;\n+                    }\n+\n+                    r = e;\n+                    e = d;\n+                }\n+\n+                if (Math.abs(p) < Math.abs(0.5 * q * r) &&\n+                    (p < q * (a - x)) && (p < q * (b - x))) { // Parabolic interpolation step.\n+                    d = p / q;\n+                    u = x + d;\n+\n+                    // f must not be evaluated too close to a or b.\n+                    if (((u - a) < t2) || ((b - u) < t2)) {\n+                        d = (x < m) ? tol : -tol;\n+                    }\n+                } else { // Golden section step.\n+                    e = ((x < m) ? b : a) - x;\n+                    d = c * e;\n+                }\n+\n+                // f must not be evaluated too close to a or b.\n+                u = x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));\n+                double fu = f.value(u);\n+\n+                // Update a, b, v, w and x.\n+                if (fu <= fx) {\n+                    if (u < x) {\n+                        b = x;\n+                    } else {\n+                        a = x;\n+                    }\n+                    v = w;\n+                    fv = fw;\n+                    w = x;\n+                    fw = fx;\n+                    x = u;\n+                    fx = fu;\n+                } else {\n+                    if (u < x) {\n+                        a = u;\n+                    } else {\n+                        b = u;\n+                    }\n+                    if ((fu <= fw) || (w == x)) {\n+                        v = w;\n+                        fv = fw;\n+                        w = u;\n+                        fw = fu;\n+                    } else if ((fu <= fv) || (v == x) || (v == w)) {\n+                        v = u;\n+                        fv = fu;\n+                    }\n+                }\n+            } else { // Termination.\n+                setResult(x, fx, count);\n+                return x;\n+            }\n+\n+            ++count;\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/minimization/UnivariateRealMinimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.minimization;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ConvergingAlgorithm;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) minimization algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface UnivariateRealMinimizer extends ConvergingAlgorithm {\n+\n+//    /**\n+//     * Set the function value accuracy.\n+//     * <p>\n+//     * This is used to determine when an evaluated function value or some other\n+//     * value which is used as divisor is zero.</p>\n+//     * <p>\n+//     * This is a safety guard and it shouldn't be necessary to change this in\n+//     * general.</p>\n+//     * \n+//     * @param accuracy the accuracy.\n+//     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+//     * the minimizer or is otherwise deemed unreasonable. \n+//     */\n+//    void setFunctionValueAccuracy(double accuracy);\n+//\n+//    /**\n+//     * Get the actual function value accuracy.\n+//     * @return the accuracy\n+//     */\n+//    double getFunctionValueAccuracy();\n+//\n+//    /**\n+//     * Reset the actual function accuracy to the default.\n+//     * The default value is provided by the minimizer implementation.\n+//     */\n+//    void resetFunctionValueAccuracy();\n+\n+    /**\n+     * Find a minimum in the given interval.\n+     * <p>\n+     * A minimizer may require that the interval brackets a single minimum.\n+     * </p>\n+     * @param f the function to minimize.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is minimum\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the minimizer detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the minimizer\n+     */\n+    double minimize(UnivariateRealFunction f, double min, double max)\n+        throws ConvergenceException, \n+        FunctionEvaluationException;\n+\n+    /**\n+     * Find a minimum in the given interval, start at startValue.\n+     * <p>\n+     * A minimizer may require that the interval brackets a single minimum.\n+     * </p>\n+     * @param f the function to minimize.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is minimum\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the minimizer detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the minimizer\n+     */\n+    double minimize(UnivariateRealFunction f, double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Get the result of the last run of the minimizer.\n+     * \n+     * @return the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getResult();\n+\n+    /**\n+     * Get the result of the last run of the minimizer.\n+     * \n+     * @return the value of the function at the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getFunctionValue();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/minimization/UnivariateRealMinimizerImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.minimization;\n+\n+import org.apache.commons.math.ConvergingAlgorithmImpl;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * minimizers.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class UnivariateRealMinimizerImpl\n+  extends ConvergingAlgorithmImpl implements UnivariateRealMinimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4543031162377070699L;\n+\n+//    /** Maximum error of function. */\n+//    protected double functionValueAccuracy;\n+//\n+//    /** Default maximum error of function. */\n+//    protected double defaultFunctionValueAccuracy;\n+\n+    /** Indicates where a root has been computed. */\n+    protected boolean resultComputed = false;\n+\n+    /** The last computed root. */\n+    protected double result;\n+\n+    /** Value of the function at the last computed result. */\n+    protected double functionValue;\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * \n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected UnivariateRealMinimizerImpl(int defaultMaximalIterationCount,\n+                                          double defaultAbsoluteAccuracy) {\n+        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n+//        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+    }\n+\n+    /** Check if a result has been computed.\n+     * @exception IllegalStateException if no result has been computed\n+     */\n+    protected void checkResultComputed() throws IllegalArgumentException {\n+        if (!resultComputed) {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getResult() {\n+        checkResultComputed();\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValue() {\n+        checkResultComputed();\n+        return functionValue;\n+    }\n+\n+//    /** {@inheritDoc} */\n+//    public void setFunctionValueAccuracy(double accuracy) {\n+//        functionValueAccuracy = accuracy;\n+//    }\n+//\n+//    /** {@inheritDoc} */\n+//    public double getFunctionValueAccuracy() {\n+//        return functionValueAccuracy;\n+//    }\n+//\n+//    /** {@inheritDoc} */\n+//    public void resetFunctionValueAccuracy() {\n+//        functionValueAccuracy = defaultFunctionValueAccuracy;\n+//    }\n+    \n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param result the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(double result, int iterationCount) {\n+        this.result = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param x the result to set\n+     * @param fx the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(double x, double fx, int iterationCount) {\n+        this.result = x;\n+        this.functionValue = fx;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.resultComputed = false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/minimization/BrentMinimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.minimization;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * @version $Revision$ $Date$ \n+ */\n+public final class BrentMinimizerTest extends TestCase {\n+\n+    public BrentMinimizerTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BrentMinimizerTest.class);\n+        suite.setName(\"BrentMinimizer Tests\");\n+        return suite;\n+    }\n+\n+    public void testSinMin() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealMinimizer minimizer = new BrentMinimizer();\n+        assertEquals(3 * Math.PI / 2, minimizer.minimize(f, 4, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+        assertEquals(3 * Math.PI / 2, minimizer.minimize(f, 1, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+    }\n+\n+   public void testQuinticMin() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealMinimizer minimizer = new BrentMinimizer();\n+        assertEquals(-0.27195613, minimizer.minimize(f, -0.3, -0.2), 1.0e-8);\n+        assertEquals( 0.82221643, minimizer.minimize(f,  0.3,  0.9), 1.0e-8);\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+\n+        // search in a large interval\n+        assertEquals(-0.27195613, minimizer.minimize(f, -1.0, 0.2), 1.0e-8);\n+        assertTrue(minimizer.getIterationCount() <= 50);\n+\n+   }\n+    \n+    public void testMinEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealMinimizer solver = new BrentMinimizer();\n+        \n+        // endpoint is minimum\n+        double result = solver.minimize(f, 3 * Math.PI / 2, 5);\n+        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n+\n+        result = solver.minimize(f, 4, 3 * Math.PI / 2);\n+        assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n+\n+    }\n+    \n+}", "timestamp": 1232293175, "metainfo": ""}