{"sha": "45add3a0e7e2e94bfc29e85c9ef0856e2e473a33", "log": "MATH-519 Workaround exception generated when the optimizer tries invalid values for the \"sigma\" parameter. Added a method to allow the user to pass his own initial guess.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.function.Gaussian;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n  * @version $Revision$ $Date$\n  */\n public class GaussianFitter extends CurveFitter {\n-\n     /**\n      * Constructs an instance using the specified optimizer.\n      *\n-     * @param optimizer optimizer to use for the fitting\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        super(optimizer);;\n+        super(optimizer);\n     }\n \n-\n     /**\n-     * Fits Gaussian function to the observed points.\n-     * It will call the base class\n-     * {@link CurveFitter#fit(\n-     * org.apache.commons.math.analysis.ParametricUnivariateRealFunction,\n-     * double[]) fit} method.\n+     * Fits a Gaussian function to the observed points.\n      *\n-     * @return the Gaussian function that best fits the observed points.\n+     * @param initialGuess First guess values in the following order:\n+     * <ul>\n+     *  <li>Norm</li>\n+     *  <li>Mean</li>\n+     *  <li>Sigma</li>\n+     * </ul>\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n+     */\n+    public double[] fit(double[] initialGuess) {\n+        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n+                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n+\n+                public double value(double x, double[] p) {\n+                    double v = Double.POSITIVE_INFINITY;\n+                    try {\n+                        v = g.value(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+\n+                public double[] gradient(double x, double[] p) {\n+                    double[] v = { Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY };\n+                    try {\n+                        v = g.gradient(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+            };\n+\n+        return fit(f, initialGuess);\n+    }\n+\n+    /**\n+     * Fits a Gaussian function to the observed points.\n+     *\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n      */\n     public double[] fit() {\n-        return fit(new Gaussian.Parametric(),\n-                   (new ParameterGuesser(getObservations())).guess());\n+        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n+        return fit(guess);\n     }\n \n     /**\n     public static class ParameterGuesser {\n         /** Observed points. */\n         private final WeightedObservedPoint[] observations;\n-\n         /** Resulting guessed parameters. */\n         private double[] parameters;\n \n         /**\n          * Guesses the parameters based on the observed points.\n          *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         public double[] guess() {\n             if (parameters == null) {\n         /**\n          * Guesses the parameters based on the specified observed points.\n          *\n-         * @param points observed points upon which should base guess\n-         *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @param points Observed points upon which should base guess.\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         private double[] basicGuess(WeightedObservedPoint[] points) {\n             Arrays.sort(points, createWeightedObservedPointComparator());\n             double[] params = new double[3];\n-\n \n             int maxYIdx = findMaxY(points);\n             params[0] = points[maxYIdx].getY();\n         /**\n          * Finds index of point in specified points with the largest Y.\n          *\n-         * @param points points to search\n-         *\n-         * @return index in specified points array\n+         * @param points Points to search.\n+         * @return the index in specified points array.\n          */\n         private int findMaxY(WeightedObservedPoint[] points) {\n             int maxYIdx = 0;\n         }\n \n         /**\n-         * Interpolates using the specified points to determine X at the specified\n-         * Y.\n-         *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return value of X at the specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * Interpolates using the specified points to determine X at the\n+         * specified Y.\n+         *\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         *  interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the value of X at the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private double interpolateXAtY(WeightedObservedPoint[] points,\n                                        int startIdx, int idxStep, double y)\n          * Gets the two bounding interpolation points from the specified points\n          * suitable for determining X at the specified Y.\n          *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return array containing two points suitable for determining X at the\n-         *         specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         * interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the array containing two points suitable for determining X at\n+         * the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n                                                                    int startIdx, int idxStep, double y)\n                 maxY = Math.max(maxY, point.getY());\n             }\n             throw new OutOfRangeException(y, minY, maxY);\n-\n         }\n \n         /**\n          * Determines whether a value is between two other values.\n          *\n-         * @param value value to determine whether is between <code>boundary1</code>\n-         *        and <code>boundary2</code>\n-         * @param boundary1 one end of the range\n-         * @param boundary2 other end of the range\n-         *\n-         * @return true if <code>value</code> is between <code>boundary1</code> and\n-         *         <code>boundary2</code> (inclusive); false otherwise\n+         * @param value Value to determine whether is between {@code boundary1}\n+         * and {@code boundary2}.\n+         * @param boundary1 One end of the range.\n+         * @param boundary2 Other end of the range.\n+         * @return {@code true} if {@code value} is between {@code boundary1} and\n+         * {@code boundary2} (inclusive), {@code false} otherwise.\n          */\n         private boolean isBetween(double value, double boundary1, double boundary2) {\n             return (value >= boundary1 && value <= boundary2) ||\n         }\n \n         /**\n-         * Factory method creating <code>Comparator</code> for comparing\n-         * <code>WeightedObservedPoint</code> instances.\n-         *\n-         * @return new <code>Comparator</code> instance\n+         * Factory method creating {@code Comparator} for comparing\n+         * {@code WeightedObservedPoint} instances.\n+         *\n+         * @return the new {@code Comparator} instance.\n          */\n         private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n             return new Comparator<WeightedObservedPoint>() {\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import static org.junit.Assert.assertEquals;\n-\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n \n+import org.junit.Assert;\n import org.junit.Test;\n \n /**\n         addDatasetToGaussianFitter(DATASET1, fitter);\n         double[] parameters = fitter.fit();\n \n-        assertEquals(3496978.1837704973, parameters[0], 1e-4);\n-        assertEquals(4.054933085999146, parameters[1], 1e-4);\n-        assertEquals(0.015039355620304326, parameters[2], 1e-4);\n+        Assert.assertEquals(3496978.1837704973, parameters[0], 1e-4);\n+        Assert.assertEquals(4.054933085999146, parameters[1], 1e-4);\n+        Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4);\n     }\n \n     /**\n         addDatasetToGaussianFitter(DATASET2, fitter);\n         double[] parameters = fitter.fit();\n \n-        assertEquals(233003.2967252038, parameters[0], 1e-4);\n-        assertEquals(-10.654887521095983, parameters[1], 1e-4);\n-        assertEquals(4.335937353196641, parameters[2], 1e-4);\n+        Assert.assertEquals(233003.2967252038, parameters[0], 1e-4);\n+        Assert.assertEquals(-10.654887521095983, parameters[1], 1e-4);\n+        Assert.assertEquals(4.335937353196641, parameters[2], 1e-4);\n     }  \n     \n     /**\n         addDatasetToGaussianFitter(DATASET3, fitter);\n         double[] parameters = fitter.fit();\n \n-        assertEquals(283863.81929180305, parameters[0], 1e-4);\n-        assertEquals(-13.29641995105174, parameters[1], 1e-4);\n-        assertEquals(1.7297330293549908, parameters[2], 1e-4);\n+        Assert.assertEquals(283863.81929180305, parameters[0], 1e-4);\n+        Assert.assertEquals(-13.29641995105174, parameters[1], 1e-4);\n+        Assert.assertEquals(1.7297330293549908, parameters[2], 1e-4);\n     }\n     \n     /**\n         addDatasetToGaussianFitter(DATASET4, fitter);\n         double[] parameters = fitter.fit();\n \n-        assertEquals(285250.66754309234, parameters[0], 1e-4);\n-        assertEquals(-13.528375695228455, parameters[1], 1e-4);\n-        assertEquals(1.5204344894331614, parameters[2], 1e-4);\n+        Assert.assertEquals(285250.66754309234, parameters[0], 1e-4);\n+        Assert.assertEquals(-13.528375695228455, parameters[1], 1e-4);\n+        Assert.assertEquals(1.5204344894331614, parameters[2], 1e-4);\n     }    \n \n     /**\n      */\n     @Test\n     public void testFit07()\n-    throws OptimizationException \n-    {\n+    throws OptimizationException {\n         GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n         addDatasetToGaussianFitter(DATASET5, fitter);\n         double[] parameters = fitter.fit();\n \n-        assertEquals(3514384.729342235, parameters[0], 1e-4);\n-        assertEquals(4.054970307455625, parameters[1], 1e-4);\n-        assertEquals(0.015029412832160017, parameters[2], 1e-4);\n+        Assert.assertEquals(3514384.729342235, parameters[0], 1e-4);\n+        Assert.assertEquals(4.054970307455625, parameters[1], 1e-4);\n+        Assert.assertEquals(0.015029412832160017, parameters[2], 1e-4);\n+    }\n+\n+    @Test\n+    public void testMath519() {\n+        // The optimizer will try negative sigma values but \"GaussianFitter\"\n+        // will catch the raised exceptions and return NaN values instead.\n+\n+        final double[] data = { \n+            1.1143831578403364E-29,\n+            4.95281403484594E-28,\n+            1.1171347211930288E-26,\n+            1.7044813962636277E-25,\n+            1.9784716574832164E-24,\n+            1.8630236407866774E-23,\n+            1.4820532905097742E-22,\n+            1.0241963854632831E-21,\n+            6.275077366673128E-21,\n+            3.461808994532493E-20,\n+            1.7407124684715706E-19,\n+            8.056687953553974E-19,\n+            3.460193945992071E-18,\n+            1.3883326374011525E-17,\n+            5.233894983671116E-17,\n+            1.8630791465263745E-16,\n+            6.288759227922111E-16,\n+            2.0204433920597856E-15,\n+            6.198768938576155E-15,\n+            1.821419346860626E-14,\n+            5.139176445538471E-14,\n+            1.3956427429045787E-13,\n+            3.655705706448139E-13,\n+            9.253753324779779E-13,\n+            2.267636001476696E-12,\n+            5.3880460095836855E-12,\n+            1.2431632654852931E-11\n+        };\n+\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        for (int i = 0; i < data.length; i++) {\n+            fitter.addObservedPoint(i, data[i]);\n+        }\n+        final double[] p = fitter.fit();\n+\n+        Assert.assertEquals(53.1572792, p[1], 1e-7);\n+        Assert.assertEquals(5.75214622, p[2], 1e-8);\n     }\n     \n     /**", "timestamp": 1298418646, "metainfo": ""}