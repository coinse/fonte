{"sha": "c377b9c6bc631f057b190ca331114ac7f8e67769", "log": "MATH-485 \"KalmanFilter\" and related classes updated by Thomas Neidhart according to comments on JIRA.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/filter/DefaultMeasurementModel.java\n+++ b/src/main/java/org/apache/commons/math/filter/DefaultMeasurementModel.java\n  */\n public class DefaultMeasurementModel implements MeasurementModel {\n \n+    /**\n+     * The measurement matrix, used to associate the measurement vector to the\n+     * internal state estimation vector.\n+     */\n     private RealMatrix measurementMatrix;\n+\n+    /**\n+     * The measurement noise covariance matrix.\n+     */\n     private RealMatrix measurementNoise;\n \n     /**\n      * Create a new {@link MeasurementModel}, taking double arrays as input\n      * parameters for the respective measurement matrix and noise.\n      *\n-     * @param measurementMatrix\n+     * @param measMatrix\n      *            the measurement matrix\n-     * @param measurementNoise\n+     * @param measNoise\n      *            the measurement noise matrix\n      */\n-    public DefaultMeasurementModel(final double[][] measurementMatrix,\n-            final double[][] measurementNoise) {\n-        this(new Array2DRowRealMatrix(measurementMatrix),\n-                new Array2DRowRealMatrix(measurementNoise));\n+    public DefaultMeasurementModel(final double[][] measMatrix,\n+            final double[][] measNoise) {\n+        this(new Array2DRowRealMatrix(measMatrix),\n+                new Array2DRowRealMatrix(measNoise));\n     }\n \n     /**\n      * Create a new {@link MeasurementModel}, taking {@link RealMatrix} objects\n      * as input parameters for the respective measurement matrix and noise.\n      *\n-     * @param measurementMatrix\n-     * @param measurementNoise\n+     * @param measMatrix\n+     *            the measurement matrix\n+     * @param measNoise\n+     *            the measurement noise matrix\n      */\n-    public DefaultMeasurementModel(final RealMatrix measurementMatrix,\n-            final RealMatrix measurementNoise) {\n-        this.measurementMatrix = measurementMatrix;\n-        this.measurementNoise = measurementNoise;\n+    public DefaultMeasurementModel(final RealMatrix measMatrix,\n+            final RealMatrix measNoise) {\n+        this.measurementMatrix = measMatrix;\n+        this.measurementNoise = measNoise;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/filter/DefaultProcessModel.java\n+++ b/src/main/java/org/apache/commons/math/filter/DefaultProcessModel.java\n  * @version $Id$\n  */\n public class DefaultProcessModel implements ProcessModel {\n+    /**\n+     * The state transition matrix, used to advance the internal state\n+     * estimation each time-step.\n+     */\n+    private RealMatrix stateTransitionMatrix;\n \n-    private RealMatrix stateTransitionMatrix;\n+    /**\n+     * The control matrix, used to integrate a control input into the state\n+     * estimation.\n+     */\n     private RealMatrix controlMatrix;\n-    private RealMatrix processNoise;\n-    private RealVector initialStateEstimate;\n-    private RealMatrix initialErrorCovariance;\n+\n+    /**\n+     * The process noise covariance matrix.\n+     */\n+    private RealMatrix processNoiseCovMatrix;\n+\n+    /**\n+     * The initial state estimation of the observed process.\n+     */\n+    private RealVector initialStateEstimateVector;\n+\n+    /**\n+     * The initial error covariance matrix of the observed process.\n+     */\n+    private RealMatrix initialErrorCovMatrix;\n \n     /**\n      * Create a new {@link ProcessModel}, taking double arrays as input\n      * parameters.\n      *\n-     * @param stateTransitionMatrix\n+     * @param stateTransition\n      *            the state transition matrix\n-     * @param controlMatrix\n+     * @param control\n      *            the control matrix\n      * @param processNoise\n      *            the process noise matrix\n      * @param initialErrorCovariance\n      *            the initial error covariance matrix\n      */\n-    public DefaultProcessModel(final double[][] stateTransitionMatrix,\n-            final double[][] controlMatrix, final double[][] processNoise,\n+    public DefaultProcessModel(final double[][] stateTransition,\n+            final double[][] control, final double[][] processNoise,\n             final double[] initialStateEstimate,\n             final double[][] initialErrorCovariance) {\n-        this(new Array2DRowRealMatrix(stateTransitionMatrix),\n-                new Array2DRowRealMatrix(controlMatrix),\n-                new Array2DRowRealMatrix(processNoise), new ArrayRealVector(\n-                        initialStateEstimate), new Array2DRowRealMatrix(\n-                        initialErrorCovariance));\n+        this(new Array2DRowRealMatrix(stateTransition),\n+                new Array2DRowRealMatrix(control),\n+                new Array2DRowRealMatrix(processNoise),\n+                new ArrayRealVector(initialStateEstimate),\n+                new Array2DRowRealMatrix(initialErrorCovariance));\n     }\n \n     /**\n      * parameters. The initial state estimate and error covariance are omitted\n      * and will be initialized by the {@link KalmanFilter} to default values.\n      *\n-     * @param stateTransitionMatrix\n+     * @param stateTransition\n      *            the state transition matrix\n-     * @param controlMatrix\n+     * @param control\n      *            the control matrix\n      * @param processNoise\n      *            the process noise matrix\n      */\n-    public DefaultProcessModel(final double[][] stateTransitionMatrix,\n-            final double[][] controlMatrix, final double[][] processNoise) {\n-        this(new Array2DRowRealMatrix(stateTransitionMatrix),\n-                new Array2DRowRealMatrix(controlMatrix),\n+    public DefaultProcessModel(final double[][] stateTransition,\n+            final double[][] control, final double[][] processNoise) {\n+        this(new Array2DRowRealMatrix(stateTransition),\n+                new Array2DRowRealMatrix(control),\n                 new Array2DRowRealMatrix(processNoise), null, null);\n     }\n \n      * Create a new {@link ProcessModel}, taking double arrays as input\n      * parameters.\n      *\n-     * @param stateTransitionMatrix\n+     * @param stateTransition\n      *            the state transition matrix\n-     * @param controlMatrix\n+     * @param control\n      *            the control matrix\n      * @param processNoise\n      *            the process noise matrix\n      * @param initialErrorCovariance\n      *            the initial error covariance matrix\n      */\n-    public DefaultProcessModel(final RealMatrix stateTransitionMatrix,\n-            final RealMatrix controlMatrix, final RealMatrix processNoise,\n+    public DefaultProcessModel(final RealMatrix stateTransition,\n+            final RealMatrix control, final RealMatrix processNoise,\n             final RealVector initialStateEstimate,\n             final RealMatrix initialErrorCovariance) {\n-        this.stateTransitionMatrix = stateTransitionMatrix;\n-        this.controlMatrix = controlMatrix;\n-        this.processNoise = processNoise;\n-        this.initialStateEstimate = initialStateEstimate;\n-        this.initialErrorCovariance = initialErrorCovariance;\n+        this.stateTransitionMatrix = stateTransition;\n+        this.controlMatrix = control;\n+        this.processNoiseCovMatrix = processNoise;\n+        this.initialStateEstimateVector = initialStateEstimate;\n+        this.initialErrorCovMatrix = initialErrorCovariance;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public RealMatrix getProcessNoise() {\n-        return processNoise;\n+        return processNoiseCovMatrix;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public RealVector getInitialStateEstimate() {\n-        return initialStateEstimate;\n+        return initialStateEstimateVector;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public RealMatrix getInitialErrorCovariance() {\n-        return initialErrorCovariance;\n+        return initialErrorCovMatrix;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/filter/KalmanFilter.java\n+++ b/src/main/java/org/apache/commons/math/filter/KalmanFilter.java\n package org.apache.commons.math.filter;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.CholeskyDecompositionImpl;\n import org.apache.commons.math.linear.NonSquareMatrixException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n-import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Implementation of a Kalman filter to estimate the state <i>x<sub>k</sub> of a\n- * discrete-time controlled process that is governed by the linear stochastic\n- * difference equation:\n+ * Implementation of a Kalman filter to estimate the state <i>x<sub>k</sub></i>\n+ * of a discrete-time controlled process that is governed by the linear\n+ * stochastic difference equation:\n  *\n  * <pre>\n- * <i>x<sub>k</sub> = <b>A</b><i>x<sub>k-1</sub> + <b>B</b><i>u<sub>k-1</sub> + <i>w<sub>k-1</sub>\n+ * <i>x<sub>k</sub></i> = <b>A</b><i>x<sub>k-1</sub></i> + <b>B</b><i>u<sub>k-1</sub></i> + <i>w<sub>k-1</sub></i>\n  * </pre>\n  *\n- * with a measurement <i>x<sub>k</sub> that is\n+ * with a measurement <i>x<sub>k</sub></i> that is\n  *\n  * <pre>\n- * <i>z<sub>k</sub> = <b>H</b><i>x<sub>k</sub> + <i>v<sub>k</sub>.\n+ * <i>z<sub>k</sub></i> = <b>H</b><i>x<sub>k</sub></i> + <i>v<sub>k</sub></i>.\n  * </pre>\n  *\n- * The random variables <i>w<sub>k</sub> and <i>v<sub>k</sub> represent the\n- * process and measurement noise and are assumed to be independent of each other\n- * and distributed with normal probability (white noise).\n+ * The random variables <i>w<sub>k</sub></i> and <i>v<sub>k</sub></i> represent\n+ * the process and measurement noise and are assumed to be independent of each\n+ * other and distributed with normal probability (white noise).\n  * <p>\n  * The Kalman filter cycle involves the following steps:\n  * <ol>\n  * <li>correct: adjust the projected estimate by an actual measurement</li>\n  * </ol>\n  * </p>\n+ * <br/>\n+ * <p>\n+ * The Kalman filter is initialized with a {@link ProcessModel} and a\n+ * {@link MeasurementModel}, which contain the corresponding transformation and\n+ * noise covariance matrices. The parameter names used in the respective models\n+ * correspond to the following names commonly used in the mathematical\n+ * literature:\n+ * <ul>\n+ * <li>A - state transition matrix</li>\n+ * <li>B - control input matrix</li>\n+ * <li>H - measurement matrix</li>\n+ * <li>Q - process noise covariance matrix</li>\n+ * <li>R - measurement noise covariance matrix</li>\n+ * <li>P - error covariance matrix</li>\n+ * </ul>\n+ * </p>\n  *\n  * @see <a href=\"http://www.cs.unc.edu/~welch/kalman/\">Kalman filter\n  *      resources</a>\n  * @see <a href=\"http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf\">An\n  *      introduction to the Kalman filter by Greg Welch and Gary Bishop</a>\n- * @see <a\n- *      href=\"http://academic.csuohio.edu/simond/courses/eec644/kalman.pdf\">Kalman\n- *      filter example by Dan Simon</a>\n- *\n+ * @see <a href=\"http://academic.csuohio.edu/simond/courses/eec644/kalman.pdf\">\n+ *      Kalman filter example by Dan Simon</a>\n+ * @see ProcessModel\n+ * @see MeasurementModel\n  * @version $Id$\n  */\n public class KalmanFilter {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 4878026651422612760L;\n-    /** The transition matrix, equivalent to A */\n-    private transient RealMatrix transitionMatrix;\n-    /** The transposed transition matrix */\n-    private transient RealMatrix transitionMatrixT;\n-    /** The control matrix, equivalent to B */\n-    private transient RealMatrix controlMatrix;\n-    /** The measurement matrix, equivalent to H */\n-    private transient RealMatrix measurementMatrix;\n-    /** The transposed measurement matrix */\n-    private transient RealMatrix measurementMatrixT;\n-    /** The internal state estimation vector, equivalent to x hat */\n-    private transient RealVector stateEstimation;\n-    /** The process noise covariance matrix, equivalent to Q */\n-    private transient RealMatrix processNoise;\n-    /** The measurement noise covariance matrix, equivalent to R */\n-    private transient RealMatrix measurementNoise;\n-    /** The error covariance matrix, equivalent to P */\n-    private transient RealMatrix errorCovariance;\n+    /** The process model used by this filter instance. */\n+    private final ProcessModel processModel;\n+    /** The measurement model used by this filter instance. */\n+    private final MeasurementModel measurementModel;\n+    /** The transition matrix, equivalent to A. */\n+    private RealMatrix transitionMatrix;\n+    /** The transposed transition matrix. */\n+    private RealMatrix transitionMatrixT;\n+    /** The control matrix, equivalent to B. */\n+    private RealMatrix controlMatrix;\n+    /** The measurement matrix, equivalent to H. */\n+    private RealMatrix measurementMatrix;\n+    /** The transposed measurement matrix. */\n+    private RealMatrix measurementMatrixT;\n+    /** The internal state estimation vector, equivalent to x hat. */\n+    private RealVector stateEstimation;\n+    /** The error covariance matrix, equivalent to P. */\n+    private RealMatrix errorCovariance;\n \n     /**\n      * Creates a new Kalman filter with the given process and measurement\n      * models.\n      *\n-     * @param processModel\n+     * @param process\n      *            the model defining the underlying process dynamics\n-     * @param measurementModel\n+     * @param measurement\n      *            the model defining the given measurement characteristics\n-     * @throws NullArgumentException\n+     * @throws org.apache.commons.math.exception.NullArgumentException\n      *             if any of the given inputs is null (except for the control\n      *             matrix)\n      * @throws NonSquareMatrixException\n      * @throws MatrixDimensionMismatchException\n      *             if the matrix dimensions do not fit together\n      */\n-    public KalmanFilter(final ProcessModel processModel,\n-            final MeasurementModel measurementModel)\n-            throws NullArgumentException, NonSquareMatrixException,\n-            MatrixDimensionMismatchException {\n-\n-        MathUtils.checkNotNull(processModel);\n-        MathUtils.checkNotNull(measurementModel);\n+    public KalmanFilter(final ProcessModel process,\n+                        final MeasurementModel measurement) {\n+\n+        MathUtils.checkNotNull(process);\n+        MathUtils.checkNotNull(measurement);\n+\n+        this.processModel = process;\n+        this.measurementModel = measurement;\n \n         transitionMatrix = processModel.getStateTransitionMatrix();\n         MathUtils.checkNotNull(transitionMatrix);\n         transitionMatrixT = transitionMatrix.transpose();\n \n         // create an empty matrix if no control matrix was given\n-        controlMatrix = (processModel.getControlMatrix() == null) ?\n-            new Array2DRowRealMatrix() :\n-            processModel.getControlMatrix();\n+        if (processModel.getControlMatrix() == null) {\n+            controlMatrix = new Array2DRowRealMatrix();\n+        } else {\n+            controlMatrix = processModel.getControlMatrix();\n+        }\n \n         measurementMatrix = measurementModel.getMeasurementMatrix();\n         MathUtils.checkNotNull(measurementMatrix);\n         measurementMatrixT = measurementMatrix.transpose();\n \n-        processNoise = processModel.getProcessNoise();\n+        // check that the process and measurement noise matrices are not null\n+        // they will be directly accessed from the model as they may change\n+        // over time\n+        RealMatrix processNoise = processModel.getProcessNoise();\n         MathUtils.checkNotNull(processNoise);\n-\n-        measurementNoise = measurementModel.getMeasurementNoise();\n-        MathUtils.checkNotNull(measurementNoise);\n+        RealMatrix measNoise = measurementModel.getMeasurementNoise();\n+        MathUtils.checkNotNull(measNoise);\n \n         // set the initial state estimate to a zero vector if it is not\n-        // available\n-        stateEstimation = (processModel.getInitialStateEstimate() == null) ?\n-            new ArrayRealVector(transitionMatrix.getColumnDimension()) :\n-            processModel.getInitialStateEstimate();\n-        MathUtils.checkNotNull(stateEstimation);\n+        // available from the process model\n+        if (processModel.getInitialStateEstimate() == null) {\n+            stateEstimation =\n+                new ArrayRealVector(transitionMatrix.getColumnDimension());\n+        } else {\n+            stateEstimation = processModel.getInitialStateEstimate();\n+        }\n \n         if (transitionMatrix.getColumnDimension() != stateEstimation.getDimension()) {\n             throw new DimensionMismatchException(transitionMatrix.getColumnDimension(),\n         }\n \n         // initialize the error covariance to the process noise if it is not\n-        // available\n-        errorCovariance = (processModel.getInitialErrorCovariance() == null) ? processNoise\n-                .copy() : processModel.getInitialErrorCovariance();\n-        MathUtils.checkNotNull(errorCovariance);\n+        // available from the process model\n+        if (processModel.getInitialErrorCovariance() == null) {\n+            errorCovariance = processNoise.copy();\n+        } else {\n+            errorCovariance = processModel.getInitialErrorCovariance();\n+        }\n \n         // sanity checks, the control matrix B may be null\n \n         }\n \n         // row dimension of R must be equal to row dimension of H\n-        if (measurementNoise.getRowDimension() != measurementMatrix.getRowDimension() ||\n-            measurementNoise.getColumnDimension() != 1) {\n-            throw new MatrixDimensionMismatchException(measurementNoise.getRowDimension(),\n-                                                       measurementNoise.getColumnDimension(),\n+        if (measNoise.getRowDimension() != measurementMatrix.getRowDimension() ||\n+            measNoise.getColumnDimension() != 1) {\n+            throw new MatrixDimensionMismatchException(measNoise.getRowDimension(),\n+                                                       measNoise.getColumnDimension(),\n                                                        measurementMatrix.getRowDimension(), 1);\n         }\n     }\n      * @throws DimensionMismatchException\n      *             if the dimension of the control vector does not fit\n      */\n-    public void predict(final double[] u) throws DimensionMismatchException {\n+    public void predict(final double[] u) {\n         predict(new ArrayRealVector(u));\n     }\n \n      * @throws DimensionMismatchException\n      *             if the dimension of the control vector does not fit\n      */\n-    public void predict(final RealVector u) throws DimensionMismatchException {\n+    public void predict(final RealVector u) {\n         // sanity checks\n         if (u != null &&\n             u.getDimension() != controlMatrix.getColumnDimension()) {\n         // project the error covariance ahead\n         // P(k)- = A * P(k-1) * A' + Q\n         errorCovariance = transitionMatrix.multiply(errorCovariance)\n-                .multiply(transitionMatrixT).add(processNoise);\n+                .multiply(transitionMatrixT)\n+                .add(processModel.getProcessNoise());\n     }\n \n     /**\n      *            the measurement vector\n      * @throws DimensionMismatchException\n      *             if the dimension of the measurement vector does not fit\n-     * @throws SingularMatrixException\n+     * @throws org.apache.commons.math.linear.SingularMatrixException\n      *             if the covariance matrix could not be inverted\n      */\n-    public void correct(final double[] z) throws DimensionMismatchException,\n-                                                 SingularMatrixException {\n+    public void correct(final double[] z) {\n         correct(new ArrayRealVector(z));\n     }\n \n      *            the measurement vector\n      * @throws DimensionMismatchException\n      *             if the dimension of the measurement vector does not fit\n-     * @throws SingularMatrixException\n+     * @throws org.apache.commons.math.linear.SingularMatrixException\n      *             if the covariance matrix could not be inverted\n      */\n-    public void correct(final RealVector z) throws DimensionMismatchException,\n-                                                   SingularMatrixException {\n+    public void correct(final RealVector z) {\n         // sanity checks\n         if (z != null &&\n             z.getDimension() != measurementMatrix.getRowDimension()) {\n         }\n \n         // S = H * P(k) - * H' + R\n-        RealMatrix S = measurementMatrix.multiply(errorCovariance)\n-            .multiply(measurementMatrixT).add(measurementNoise);\n+        RealMatrix s = measurementMatrix.multiply(errorCovariance)\n+            .multiply(measurementMatrixT)\n+            .add(measurementModel.getMeasurementNoise());\n \n         // invert S\n         // as the error covariance matrix is a symmetric positive\n         // semi-definite matrix, we can use the cholesky decomposition\n-        DecompositionSolver solver = new CholeskyDecompositionImpl(S).getSolver();\n+        DecompositionSolver solver = new CholeskyDecompositionImpl(s).getSolver();\n         RealMatrix invertedS = solver.getInverse();\n \n         // Inn = z(k) - H * xHat(k)-\n \n         // update covariance of prediction error\n         // P(k) = (I - K * H) * P(k)-\n-        RealMatrix Identity = MatrixUtils.createRealIdentityMatrix(kalmanGain.getRowDimension());\n-        errorCovariance = Identity.subtract(kalmanGain.multiply(measurementMatrix)).multiply(errorCovariance);\n+        RealMatrix identity = MatrixUtils.createRealIdentityMatrix(kalmanGain.getRowDimension());\n+        errorCovariance = identity.subtract(kalmanGain.multiply(measurementMatrix)).multiply(errorCovariance);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/filter/MeasurementModel.java\n+++ b/src/main/java/org/apache/commons/math/filter/MeasurementModel.java\n     RealMatrix getMeasurementMatrix();\n \n     /**\n-     * Returns the measurement noise matrix.\n+     * Returns the measurement noise matrix. This method is called by the\n+     * {@link KalmanFilter} every correct step, so implementations of this\n+     * interface may return a modified measurement noise depending on current\n+     * iteration step.\n      *\n      * @return the measurement noise matrix\n+     * @see KalmanFilter#correct(double[])\n+     * @see KalmanFilter#correct(org.apache.commons.math.linear.RealVector)\n      */\n     RealMatrix getMeasurementNoise();\n }\n--- a/src/main/java/org/apache/commons/math/filter/ProcessModel.java\n+++ b/src/main/java/org/apache/commons/math/filter/ProcessModel.java\n     RealMatrix getControlMatrix();\n \n     /**\n-     * Returns the process noise matrix.\n+     * Returns the process noise matrix. This method is called by the\n+     * {@link KalmanFilter} every predict step, so implementations of this\n+     * interface may return a modified process noise depending on current\n+     * iteration step.\n      *\n      * @return the process noise matrix\n+     * @see KalmanFilter#predict()\n+     * @see KalmanFilter#predict(double[])\n+     * @see KalmanFilter#predict(RealVector)\n      */\n     RealMatrix getProcessNoise();\n \n--- a/src/test/java/org/apache/commons/math/filter/KalmanFilterTest.java\n+++ b/src/test/java/org/apache/commons/math/filter/KalmanFilterTest.java\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n  */\n+\n package org.apache.commons.math.filter;\n \n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.junit.Assert;\n import org.junit.Test;\n \n+/**\n+ * Test for {@link KalmanFilter}.\n+ *\n+ * @version $Id$\n+ */\n public class KalmanFilterTest {\n     @Test\n     public void testConstant() {", "timestamp": 1308750159, "metainfo": ""}