{"sha": "ab5aadd5141bca5296a07f9a037e1e5886c93c6f", "log": "MATH-707 Class name change:   \"MultiStartMultivariateRealOptimizer\" -> \"MultivariateMultiStartOptimizer\"   \"BaseMultiStartMultivariateRealOptimizer\" -> \"BaseMultivariateMultiStartOptimizer\"   \"MultiStartDifferentiableMultivariateRealOptimizer\" -> \"DifferentiableMultivariateMultiStartOptimizer\"   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateMultiStartOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/**\n+ * Base class for all implementations of a multi-start optimizer.\n+ *\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * {@link MultivariateMultiStartOptimizer} or on\n+ * {@link DifferentiableMultivariateMultiStartOptimizer}.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class BaseMultivariateMultiStartOptimizer<FUNC extends MultivariateFunction>\n+    implements BaseMultivariateRealOptimizer<FUNC> {\n+    /** Underlying classical optimizer. */\n+    private final BaseMultivariateRealOptimizer<FUNC> optimizer;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+    /** Number of starts to go. */\n+    private int starts;\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+    /** Found optima. */\n+    private RealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform. If {@code starts == 1},\n+     * the {@link #optimize(int,MultivariateFunction,GoalType,double[])\n+     * optimize} will return the same solution as {@code optimizer} would.\n+     * @param generator Random vector generator to use for restarts.\n+     * @throws NullArgumentException if {@code optimizer} or {@code generator}\n+     * is {@code null}.\n+     * @throws NotStrictlyPositiveException if {@code starts < 1}.\n+     */\n+    protected BaseMultivariateMultiStartOptimizer(final BaseMultivariateRealOptimizer<FUNC> optimizer,\n+                                                      final int starts,\n+                                                      final RandomVectorGenerator generator) {\n+        if (optimizer == null ||\n+            generator == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (starts < 1) {\n+            throw new NotStrictlyPositiveException(starts);\n+        }\n+\n+        this.optimizer = optimizer;\n+        this.starts = starts;\n+        this.generator = generator;\n+    }\n+\n+    /**\n+     * Get all the optima found during the last call to {@link\n+     * #optimize(int,MultivariateFunction,GoalType,double[]) optimize}.\n+     * The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(int,MultivariateFunction,GoalType,double[])\n+     * optimize} method returns the best point only. This method\n+     * returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(int,MultivariateFunction,GoalType,double[]) optimize} method.\n+     * <br/>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(int,MultivariateFunction,GoalType,double[])\n+     * optimize} method did throw an exception.\n+     * This also means that if the first element is not {@code null}, it\n+     * is the best point found across all starts.\n+     *\n+     * @return an array containing the optima.\n+     * @throws MathIllegalStateException if {@link\n+     * #optimize(int,MultivariateFunction,GoalType,double[]) optimize}\n+     * has not been called.\n+     */\n+    public RealPointValuePair[] getOptima() {\n+        if (optima == null) {\n+            throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ConvergenceChecker<RealPointValuePair> getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealPointValuePair optimize(int maxEval, final FUNC f,\n+                                       final GoalType goal,\n+                                       double[] startPoint) {\n+        maxEvaluations = maxEval;\n+        RuntimeException lastException = null;\n+        optima = new RealPointValuePair[starts];\n+        totalEvaluations = 0;\n+\n+        // Multi-start loop.\n+        for (int i = 0; i < starts; ++i) {\n+            // CHECKSTYLE: stop IllegalCatch\n+            try {\n+                optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal,\n+                                               i == 0 ? startPoint : generator.nextVector());\n+            } catch (RuntimeException mue) {\n+                lastException = mue;\n+                optima[i] = null;\n+            }\n+            // CHECKSTYLE: resume IllegalCatch\n+\n+            totalEvaluations += optimizer.getEvaluations();\n+        }\n+\n+        sortPairs(goal);\n+\n+        if (optima[0] == null) {\n+            throw lastException; // cannot be null if starts >=1\n+        }\n+\n+        // Return the found point given the best objective function value.\n+        return optima[0];\n+    }\n+\n+    /**\n+     * Sort the optima from best to worst, followed by {@code null} elements.\n+     *\n+     * @param goal Goal type.\n+     */\n+    private void sortPairs(final GoalType goal) {\n+        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n+                public int compare(final RealPointValuePair o1,\n+                                   final RealPointValuePair o2) {\n+                    if (o1 == null) {\n+                        return (o2 == null) ? 0 : 1;\n+                    } else if (o2 == null) {\n+                        return -1;\n+                    }\n+                    final double v1 = o1.getValue();\n+                    final double v2 = o2.getValue();\n+                    return (goal == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+                }\n+            });\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateMultiStartOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/**\n+ * Special implementation of the {@link DifferentiableMultivariateRealOptimizer}\n+ * interface adding multi-start features to an existing optimizer.\n+ *\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ *\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public class DifferentiableMultivariateMultiStartOptimizer\n+    extends BaseMultivariateMultiStartOptimizer<DifferentiableMultivariateFunction>\n+    implements DifferentiableMultivariateRealOptimizer {\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n+     */\n+    public DifferentiableMultivariateMultiStartOptimizer(final DifferentiableMultivariateRealOptimizer optimizer,\n+                                                             final int starts,\n+                                                             final RandomVectorGenerator generator) {\n+        super(optimizer, starts, generator);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/MultivariateMultiStartOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/**\n+ * Special implementation of the {@link MultivariateRealOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ *\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ *\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public class MultivariateMultiStartOptimizer\n+    extends BaseMultivariateMultiStartOptimizer<MultivariateFunction>\n+    implements MultivariateRealOptimizer {\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer.\n+     *\n+     * @param optimizer Single-start optimizer to wrap.\n+     * @param starts Number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1.\n+     * @param generator Random vector generator to use for restarts.\n+     */\n+    public MultivariateMultiStartOptimizer(final MultivariateRealOptimizer optimizer,\n+                                               final int starts,\n+                                               final RandomVectorGenerator generator) {\n+        super(optimizer, starts, generator);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateMultiStartOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+\n+import java.awt.geom.Point2D;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorFunction;\n+import org.apache.commons.math.optimization.general.ConjugateGradientFormula;\n+import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;\n+import org.apache.commons.math.random.GaussianRandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class DifferentiableMultivariateMultiStartOptimizerTest {\n+\n+    @Test\n+    public void testCircleFitting() {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        NonLinearConjugateGradientOptimizer underlying =\n+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n+                                                    new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(753289573253l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(new double[] { 50.0, 50.0 }, new double[] { 10.0, 10.0 },\n+                                                  new GaussianRandomGenerator(g));\n+        DifferentiableMultivariateMultiStartOptimizer optimizer =\n+            new DifferentiableMultivariateMultiStartOptimizer(underlying, 10, generator);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(200, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n+        Assert.assertEquals(200, optimizer.getMaxEvaluations());\n+        RealPointValuePair[] optima = optimizer.getOptima();\n+        for (RealPointValuePair o : optima) {\n+            Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);\n+            Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n+            Assert.assertEquals(96.075902096, center.x, 1.0e-8);\n+            Assert.assertEquals(48.135167894, center.y, 1.0e-8);\n+        }\n+        Assert.assertTrue(optimizer.getEvaluations() > 70);\n+        Assert.assertTrue(optimizer.getEvaluations() < 90);\n+        Assert.assertEquals(3.1267527, optimum.getValue(), 1.0e-8);\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateFunction {\n+\n+        private ArrayList<Point2D.Double> points;\n+\n+        public Circle() {\n+            points  = new ArrayList<Point2D.Double>();\n+        }\n+\n+        public void addPoint(double px, double py) {\n+            points.add(new Point2D.Double(px, py));\n+        }\n+\n+        public double getRadius(Point2D.Double center) {\n+            double r = 0;\n+            for (Point2D.Double point : points) {\n+                r += point.distance(center);\n+            }\n+            return r / points.size();\n+        }\n+\n+        private double[] gradient(double[] point) {\n+\n+            // optimal radius\n+            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n+            double radius = getRadius(center);\n+\n+            // gradient of the sum of squared residuals\n+            double dJdX = 0;\n+            double dJdY = 0;\n+            for (Point2D.Double pk : points) {\n+                double dk = pk.distance(center);\n+                dJdX += (center.x - pk.x) * (dk - radius) / dk;\n+                dJdY += (center.y - pk.y) * (dk - radius) / dk;\n+            }\n+            dJdX *= 2;\n+            dJdY *= 2;\n+\n+            return new double[] { dJdX, dJdY };\n+        }\n+\n+        public double value(double[] variables) {\n+\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            double radius = getRadius(center);\n+\n+            double sum = 0;\n+            for (Point2D.Double point : points) {\n+                double di = point.distance(center) - radius;\n+                sum += di * di;\n+            }\n+            return sum;\n+        }\n+\n+        public MultivariateVectorFunction gradient() {\n+            return new MultivariateVectorFunction() {\n+                public double[] value(double[] point) {\n+                    return gradient(point);\n+                }\n+            };\n+        }\n+\n+        public MultivariateFunction partialDerivative(final int k) {\n+            return new MultivariateFunction() {\n+                public double value(double[] point) {\n+                    return gradient(point)[k];\n+                }\n+            };\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/MultivariateMultiStartOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.optimization.direct.NelderMeadSimplex;\n+import org.apache.commons.math.optimization.direct.SimplexOptimizer;\n+import org.apache.commons.math.random.GaussianRandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MultivariateMultiStartOptimizerTest {\n+    @Test\n+    public void testRosenbrock() {\n+        Rosenbrock rosenbrock = new Rosenbrock();\n+        SimplexOptimizer underlying\n+            = new SimplexOptimizer(new SimpleScalarValueChecker(-1, 1.0e-3));\n+        NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {\n+                { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n+            });\n+        underlying.setSimplex(simplex);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(16069223052l);\n+        RandomVectorGenerator generator =\n+            new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g));\n+        MultivariateMultiStartOptimizer optimizer =\n+            new MultivariateMultiStartOptimizer(underlying, 10, generator);\n+        RealPointValuePair optimum =\n+            optimizer.optimize(1100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+\n+        Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n+        Assert.assertTrue(optimizer.getEvaluations() > 900);\n+        Assert.assertTrue(optimizer.getEvaluations() < 1200);\n+        Assert.assertTrue(optimum.getValue() < 8.0e-4);\n+    }\n+\n+    private static class Rosenbrock implements MultivariateFunction {\n+        private int count;\n+\n+        public Rosenbrock() {\n+            count = 0;\n+        }\n+\n+        public double value(double[] x) {\n+            ++count;\n+            double a = x[1] - x[0] * x[0];\n+            double b = 1.0 - x[0];\n+            return 100 * a * a + b * b;\n+        }\n+\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+}", "timestamp": 1323431963, "metainfo": ""}