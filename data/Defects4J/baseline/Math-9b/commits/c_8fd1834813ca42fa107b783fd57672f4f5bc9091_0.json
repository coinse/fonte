{"sha": "8fd1834813ca42fa107b783fd57672f4f5bc9091", "log": "merged curve fitting from mantissa into commons-math  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/** Fitter for parametric univariate real functions y = f(x).\n+ * <p>When a univariate real function y = f(x) does depend on some\n+ * unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>,\n+ * this class can be used to find these parameters. It does this\n+ * by <em>fitting</em> the curve so it remains very close to a set of\n+ * observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>,\n+ * y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting\n+ * is done by finding the parameters values that minimizes the objective\n+ * function &sum;(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is\n+ * really a least squares problem.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class CurveFitter {\n+\n+    /** Optimizer to use for the fitting. */\n+    private final DifferentiableMultivariateVectorialOptimizer optimizer;\n+\n+    /** Observed points. */\n+    private final List<WeightedObservedPoint> observations;\n+\n+    /** Simple constructor.\n+     * @param optimizer optimizer to use for the fitting\n+     */\n+    public CurveFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+        this.optimizer = optimizer;\n+        observations = new ArrayList<WeightedObservedPoint>();\n+    }\n+\n+    /** Add an observed (x,y) point to the sample with unit weight.\n+     * <p>Calling this method is equivalent to call\n+     * <code>addObservedPoint(1.0, x, y)</code>.</p>\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have f(x) as close as possible to this value\n+     * @see #addObservedPoint(double, double, double)\n+     * @see #addObservedPoint(WeightedObservedPoint)\n+     * @see #getObservations()\n+     */\n+    public void addObservedPoint(double x, double y) {\n+        addObservedPoint(1.0, x, y);\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param weight weight of the observed point in the fit\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have f(x) as close as possible to this value\n+     * @see #addObservedPoint(double, double)\n+     * @see #addObservedPoint(WeightedObservedPoint)\n+     * @see #getObservations()\n+     */\n+    public void addObservedPoint(double weight, double x, double y) {\n+        observations.add(new WeightedObservedPoint(weight, x, y));\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param observed observed point to add\n+     * @see #addObservedPoint(double, double)\n+     * @see #addObservedPoint(double, double, double)\n+     * @see #getObservations()\n+     */\n+    public void addObservedPoint(WeightedObservedPoint observed) {\n+        observations.add(observed);\n+    }\n+\n+    /** Get the observed points.\n+     * @return observed points\n+     * @see #addObservedPoint(double, double)\n+     * @see #addObservedPoint(double, double, double)\n+     * @see #addObservedPoint(WeightedObservedPoint)\n+     */\n+    public WeightedObservedPoint[] getObservations() {\n+        return observations.toArray(new WeightedObservedPoint[observations.size()]);\n+    }\n+\n+    /** Fit a curve.\n+     * <p>This method compute the coefficients of the curve that best\n+     * fit the sample of weighted pairs previously given through calls\n+     * to the {@link #addWeightedPair addWeightedPair} method.</p>\n+     * @param f parametric function to fit\n+     * @param initialGuess first guess of the function parameters\n+     * @return fitted parameters\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    public double[] fit(final ParametricRealFunction f,\n+                        final double[] initialGuess)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        // prepare least squares problem\n+        double[] target  = new double[observations.size()];\n+        double[] weights = new double[observations.size()];\n+        int i = 0;\n+        for (WeightedObservedPoint point : observations) {\n+            target[i]  = point.getY();\n+            weights[i] = point.getWeight();\n+            ++i;\n+        }\n+\n+        // perform the fit\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(new TheoreticalValuesFunction(f), target, weights, initialGuess);\n+\n+        // extract the coefficients\n+        return optimum.getPointRef();\n+\n+    }\n+\n+    /** Vectorial function computing function theoretical values. */\n+    private class TheoreticalValuesFunction\n+        implements DifferentiableMultivariateVectorialFunction {\n+\n+        /** Function to fit. */\n+        private final ParametricRealFunction f;\n+\n+        /** Simple constructor.\n+         * @param f function to fit.\n+         */\n+        public TheoreticalValuesFunction(final ParametricRealFunction f) {\n+            this.f = f;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                public double[][] value(double[] point)\n+                    throws FunctionEvaluationException, IllegalArgumentException {\n+\n+                    final double[][] jacobian = new double[observations.size()][];\n+\n+                    int i = 0;\n+                    for (WeightedObservedPoint observed : observations) {\n+                        jacobian[i++] = f.gradient(observed.getX(), point);\n+                    }\n+\n+                    return jacobian;\n+\n+                }\n+            };\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] value(double[] point)\n+                throws FunctionEvaluationException, IllegalArgumentException {\n+\n+            // compute the residuals\n+            final double[] values = new double[observations.size()];\n+            int i = 0;\n+            for (WeightedObservedPoint observed : observations) {\n+                values[i++] = f.value(observed.getX(), point);\n+            }\n+\n+            return values;\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/fitting/HarmonicCoefficientsGuesser.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/** This class guesses harmonic coefficients from a sample.\n+\n+ * <p>The algorithm used to guess the coefficients is as follows:</p>\n+\n+ * <p>We know f (t) at some sampling points t<sub>i</sub> and want to find a,\n+ * &omega; and &phi; such that f (t) = a cos (&omega; t + &phi;).\n+ * </p>\n+ *\n+ * <p>From the analytical expression, we can compute two primitives :\n+ * <pre>\n+ *     If2  (t) = &int; f<sup>2</sup>  = a<sup>2</sup> &times; [t + S (t)] / 2\n+ *     If'2 (t) = &int; f'<sup>2</sup> = a<sup>2</sup> &omega;<sup>2</sup> &times; [t - S (t)] / 2\n+ *     where S (t) = sin (2 (&omega; t + &phi;)) / (2 &omega;)\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>We can remove S between these expressions :\n+ * <pre>\n+ *     If'2 (t) = a<sup>2</sup> &omega;<sup>2</sup> t - &omega;<sup>2</sup> If2 (t)\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>The preceding expression shows that If'2 (t) is a linear\n+ * combination of both t and If2 (t): If'2 (t) = A &times; t + B &times; If2 (t)\n+ * </p>\n+ *\n+ * <p>From the primitive, we can deduce the same form for definite\n+ * integrals between t<sub>1</sub> and t<sub>i</sub> for each t<sub>i</sub> :\n+ * <pre>\n+ *   If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>) = A &times; (t<sub>i</sub> - t<sub>1</sub>) + B &times; (If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>))\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>We can find the coefficients A and B that best fit the sample\n+ * to this linear expression by computing the definite integrals for\n+ * each sample points.\n+ * </p>\n+ *\n+ * <p>For a bilinear expression z (x<sub>i</sub>, y<sub>i</sub>) = A &times; x<sub>i</sub> + B &times; y<sub>i</sub>, the\n+ * coefficients A and B that minimize a least square criterion\n+ * &sum; (z<sub>i</sub> - z (x<sub>i</sub>, y<sub>i</sub>))<sup>2</sup> are given by these expressions:</p>\n+ * <pre>\n+ *\n+ *         &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ *     A = ------------------------\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ *\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub>\n+ *     B = ------------------------\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ * </pre>\n+ * </p>\n+ *\n+ *\n+ * <p>In fact, we can assume both a and &omega; are positive and\n+ * compute them directly, knowing that A = a<sup>2</sup> &omega;<sup>2</sup> and that\n+ * B = - &omega;<sup>2</sup>. The complete algorithm is therefore:</p>\n+ * <pre>\n+ *\n+ * for each t<sub>i</sub> from t<sub>1</sub> to t<sub>n-1</sub>, compute:\n+ *   f  (t<sub>i</sub>)\n+ *   f' (t<sub>i</sub>) = (f (t<sub>i+1</sub>) - f(t<sub>i-1</sub>)) / (t<sub>i+1</sub> - t<sub>i-1</sub>)\n+ *   x<sub>i</sub> = t<sub>i</sub> - t<sub>1</sub>\n+ *   y<sub>i</sub> = &int; f<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+ *   z<sub>i</sub> = &int; f'<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+ *   update the sums &sum;x<sub>i</sub>x<sub>i</sub>, &sum;y<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>z<sub>i</sub> and &sum;y<sub>i</sub>z<sub>i</sub>\n+ * end for\n+ *\n+ *            |--------------------------\n+ *         \\  | &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ * a     =  \\ | ------------------------\n+ *           \\| &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ *\n+ *\n+ *            |--------------------------\n+ *         \\  | &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ * &omega;     =  \\ | ------------------------\n+ *           \\| &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ *\n+ * </pre>\n+ * </p>\n+\n+ * <p>Once we know &omega;, we can compute:\n+ * <pre>\n+ *    fc = &omega; f (t) cos (&omega; t) - f' (t) sin (&omega; t)\n+ *    fs = &omega; f (t) sin (&omega; t) + f' (t) cos (&omega; t)\n+ * </pre>\n+ * </p>\n+\n+ * <p>It appears that <code>fc = a &omega; cos (&phi;)</code> and\n+ * <code>fs = -a &omega; sin (&phi;)</code>, so we can use these\n+ * expressions to compute &phi;. The best estimate over the sample is\n+ * given by averaging these expressions.\n+ * </p>\n+\n+ * <p>Since integrals and means are involved in the preceding\n+ * estimations, these operations run in O(n) time, where n is the\n+ * number of measurements.</p>\n+\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+\n+ */\n+public class HarmonicCoefficientsGuesser {\n+\n+    /** Sampled observations. */\n+    private final WeightedObservedPoint[] observations;\n+\n+    /** Guessed amplitude. */\n+    private double a;\n+\n+    /** Guessed pulsation &omega;. */\n+    private double omega;\n+\n+    /** Guessed phase &phi;. */\n+    private double phi;\n+\n+    /** Simple constructor.\n+     * @param observations sampled observations\n+     */\n+    public HarmonicCoefficientsGuesser(WeightedObservedPoint[] observations) {\n+        this.observations = observations.clone();\n+        a                 = Double.NaN;\n+        omega             = Double.NaN;\n+    }\n+\n+    /** Estimate a first guess of the coefficients.\n+     * @exception OptimizationException if the sample is too short or if\n+     * the first guess cannot be computed (when the elements under the\n+     * square roots are negative).\n+     * */\n+    public void guess() throws OptimizationException {\n+        sortObservations();\n+        guessAOmega();\n+        guessPhi();\n+    }\n+\n+    /** Sort the observations with respect to the abscissa.\n+     */\n+    private void sortObservations() {\n+\n+        // Since the samples are almost always already sorted, this\n+        // method is implemented as an insertion sort that reorders the\n+        // elements in place. Insertion sort is very efficient in this case.\n+        WeightedObservedPoint curr = observations[0];\n+        for (int j = 1; j < observations.length; ++j) {\n+            WeightedObservedPoint prec = curr;\n+            curr = observations[j];\n+            if (curr.getX() < prec.getX()) {\n+                // the current element should be inserted closer to the beginning\n+                int i = j - 1;\n+                WeightedObservedPoint mI = observations[i];\n+                while ((i >= 0) && (curr.getX() < mI.getX())) {\n+                    observations[i + 1] = mI;\n+                    if (i-- != 0) {\n+                        mI = observations[i];\n+                    } else {\n+                        mI = null;\n+                    }\n+                }\n+                observations[i + 1] = curr;\n+                curr = observations[j];\n+            }\n+        }\n+\n+    }\n+\n+    /** Estimate a first guess of the a and &omega; coefficients.\n+     * @exception OptimizationException if the sample is too short or if\n+     * the first guess cannot be computed (when the elements under the\n+     * square roots are negative).\n+     */\n+    private void guessAOmega() throws OptimizationException {\n+\n+        // initialize the sums for the linear model between the two integrals\n+        double sx2 = 0.0;\n+        double sy2 = 0.0;\n+        double sxy = 0.0;\n+        double sxz = 0.0;\n+        double syz = 0.0;\n+\n+        double currentX        = observations[0].getX();\n+        double currentY        = observations[0].getY();\n+        double f2Integral      = 0;\n+        double fPrime2Integral = 0;\n+        final double startX = currentX;\n+        for (int i = 1; i < observations.length; ++i) {\n+\n+            // one step forward\n+            final double previousX = currentX;\n+            final double previousY = currentY;\n+            currentX = observations[i].getX();\n+            currentY = observations[i].getY();\n+\n+            // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n+            // considering a linear model for f (and therefore constant f')\n+            final double dx = currentX - previousX;\n+            final double dy = currentY - previousY;\n+            final double f2StepIntegral =\n+                dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n+            final double fPrime2StepIntegral = dy * dy / dx;\n+\n+            final double x   = currentX - startX;\n+            f2Integral      += f2StepIntegral;\n+            fPrime2Integral += fPrime2StepIntegral;\n+\n+            sx2 += x * x;\n+            sy2 += f2Integral * f2Integral;\n+            sxy += x * f2Integral;\n+            sxz += x * fPrime2Integral;\n+            syz += f2Integral * fPrime2Integral;\n+\n+        }\n+\n+        // compute the amplitude and pulsation coefficients\n+        double c1 = sy2 * sxz - sxy * syz;\n+        double c2 = sxy * sxz - sx2 * syz;\n+        double c3 = sx2 * sy2 - sxy * sxy;\n+        if ((c1 / c2 < 0.0) || (c2 / c3 < 0.0)) {\n+            throw new OptimizationException(\"unable to first guess the harmonic coefficients\");\n+        }\n+        a     = Math.sqrt(c1 / c2);\n+        omega = Math.sqrt(c2 / c3);\n+\n+    }\n+\n+    /** Estimate a first guess of the &phi; coefficient.\n+     */\n+    private void guessPhi() {\n+\n+        // initialize the means\n+        double fcMean = 0.0;\n+        double fsMean = 0.0;\n+\n+        double currentX = observations[0].getX();\n+        double currentY = observations[0].getY();\n+        for (int i = 1; i < observations.length; ++i) {\n+\n+            // one step forward\n+            final double previousX = currentX;\n+            final double previousY = currentY;\n+            currentX = observations[i].getX();\n+            currentY = observations[i].getY();\n+            final double currentYPrime = (currentY - previousY) / (currentX - previousX);\n+\n+            double   omegaX = omega * currentX;\n+            double   cosine = Math.cos(omegaX);\n+            double   sine   = Math.sin(omegaX);\n+            fcMean += omega * currentY * cosine - currentYPrime *   sine;\n+            fsMean += omega * currentY *   sine + currentYPrime * cosine;\n+\n+        }\n+\n+        phi = Math.atan2(-fsMean, fcMean);\n+\n+    }\n+\n+    /** Get the guessed amplitude a.\n+     * @return guessed amplitude a;\n+     */\n+    public double getGuessedAmplitude() {\n+        return a;\n+    }\n+\n+    /** Get the guessed pulsation &omega;.\n+     * @return guessed pulsation &omega;\n+     */\n+    public double getGuessedPulsation() {\n+        return omega;\n+    }\n+\n+    /** Get the guessed phase &phi;.\n+     * @return guessed phase &phi;\n+     */\n+    public double getGuessedPhase() {\n+        return phi;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/** This class implements a curve fitting specialized for sinusoids.\n+ * <p>Harmonic fitting is a very simple case of curve fitting. The\n+ * estimated coefficients are the amplitude a, the pulsation &omega; and\n+ * the phase &phi;: <code>f (t) = a cos (&omega; t + &phi;)</code>. They are\n+ * searched by a least square estimator initialized with a rough guess\n+ * based on integrals.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class HarmonicFitter {\n+\n+    /** Fitter for the coefficients. */\n+    private final CurveFitter fitter;\n+\n+    /** Values for amplitude, pulsation &omega; and phase &phi;. */\n+    private double[] parameters;\n+\n+    /** Simple constructor.\n+     * @param optimizer optimizer to use for the fitting\n+     */\n+    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+        this.fitter = new CurveFitter(optimizer);\n+        parameters  = null;\n+    }\n+\n+    /** Simple constructor.\n+     * <p>This constructor can be used when a first guess of the\n+     * coefficients is already known.</p>\n+     * @param optimizer optimizer to use for the fitting\n+     * @param initialGuess guessed values for amplitude (index 0),\n+     * pulsation &omega; (index 1) and phase &phi; (index 2)\n+     */\n+    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer,\n+                          final double[] initialGuess) {\n+        this.fitter     = new CurveFitter(optimizer);\n+        this.parameters = initialGuess.clone();\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param weight weight of the observed point in the fit\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have P(x) as close as possible to this value\n+     */\n+    public void addObservedPoint(double weight, double x, double y) {\n+        fitter.addObservedPoint(weight, x, y);\n+    }\n+\n+    /** Fit an harmonic function to the observed points.\n+     * @return harmonic function best fitting the observed points\n+     * @throws OptimizationException if the sample is too short or if\n+     * the first guess cannot be computed\n+     */\n+    public HarmonicFunction fit() throws OptimizationException {\n+        try {\n+\n+            // shall we compute the first guess of the parameters ourselves ?\n+            if (parameters == null) {\n+                final WeightedObservedPoint[] observations = fitter.getObservations();\n+                if (observations.length < 4) {\n+                    throw new OptimizationException(\"sample contains {0} observed points, at least {1} are required\",\n+                                                    observations.length, 4);\n+                }\n+\n+                HarmonicCoefficientsGuesser guesser = new HarmonicCoefficientsGuesser(observations);\n+                guesser.guess();\n+                parameters = new double[] {\n+                                 guesser.getGuessedAmplitude(),\n+                                 guesser.getGuessedPulsation(),\n+                                 guesser.getGuessedPhase()\n+                            };\n+\n+            }\n+\n+            double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);\n+            return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);\n+\n+        } catch (FunctionEvaluationException fee) {\n+            // this should never happen\n+            throw MathRuntimeException.createInternalError(fee);\n+        }\n+    }\n+\n+    /** Parametric harmonic function. */\n+    private static class ParametricHarmonicFunction implements ParametricRealFunction {\n+\n+        /** {@inheritDoc} */\n+        public double value(double x, double[] parameters) {\n+            final double a     = parameters[0];\n+            final double omega = parameters[1];\n+            final double phi   = parameters[2];\n+            return a * Math.cos(omega * x + phi);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] gradient(double x, double[] parameters) {\n+            final double a     = parameters[0];\n+            final double omega = parameters[1];\n+            final double phi   = parameters[2];\n+            final double alpha = omega * x + phi;\n+            final double cosAlpha = Math.cos(alpha);\n+            final double sinAlpha = Math.sin(alpha);\n+            return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/fitting/HarmonicFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+\n+/** Harmonic function of the form <code>f (t) = a cos (&omega; t + &phi;)</code>.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class HarmonicFunction implements DifferentiableUnivariateRealFunction {\n+\n+    /** Amplitude a. */\n+    private final double a;\n+\n+    /** Pulsation &omega;. */\n+    private final double omega;\n+\n+    /** Phase &phi;. */\n+    private final double phi;\n+\n+    /** Simple constructor.\n+     * @param a amplitude\n+     * @param omega pulsation\n+     * @param phi phase\n+     */\n+    public HarmonicFunction(double a, double omega, double phi) {\n+        this.a     = a;\n+        this.omega = omega;\n+        this.phi   = phi;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return a * Math.cos(omega * x + phi);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public HarmonicFunction derivative() {\n+        return new HarmonicFunction(a * omega, omega, phi + Math.PI / 2);\n+    }\n+\n+    /** Get the amplitude a.\n+     * @return amplitude a;\n+     */\n+    public double getAmplitude() {\n+        return a;\n+    }\n+\n+    /** Get the pulsation &omega;.\n+     * @return pulsation &omega;\n+     */\n+    public double getPulsation() {\n+        return omega;\n+    }\n+\n+    /** Get the phase &phi;.\n+     * @return phase &phi;\n+     */\n+    public double getPhase() {\n+        return phi;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * An interface representing a real function that depends on one independent\n+ * variable plus some extra parameters.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface ParametricRealFunction {\n+\n+    /**\n+     * Compute the value of the function.\n+     * @param x the point for which the function value should be computed\n+     * @param parameters function parameters\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    public double value(double x, double[] parameters)\n+        throws FunctionEvaluationException;\n+\n+    /**\n+     * Compute the gradient of the function with respect to its parameters.\n+     * @param x the point for which the function value should be computed\n+     * @param parameters function parameters\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    public double[] gradient(double x, double[] parameters)\n+        throws FunctionEvaluationException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/** This class implements a curve fitting specialized for polynomials.\n+ * <p>Polynomial fitting is a very simple case of curve fitting. The\n+ * estimated coefficients are the polynomial coefficients. They are\n+ * searched by a least square estimator.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public class PolynomialFitter {\n+\n+    /** Fitter for the coefficients. */\n+    private final CurveFitter fitter;\n+\n+    /** Polynomial degree. */\n+    private final int degree;\n+\n+    /** Simple constructor.\n+     * <p>The polynomial fitter built this way are complete polynomials,\n+     * ie. a n-degree polynomial has n+1 coefficients.</p>\n+     * @param degree maximal degree of the polynomial\n+     * @param optimizer optimizer to use for the fitting\n+     */\n+    public PolynomialFitter(int degree, final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+        this.fitter = new CurveFitter(optimizer);\n+        this.degree = degree;\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param weight weight of the observed point in the fit\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have P(x) as close as possible to this value\n+     */\n+    public void addObservedPoint(double weight, double x, double y) {\n+        fitter.addObservedPoint(weight, x, y);\n+    }\n+\n+    /** Get the polynomial fitting the weighted (x, y) points.\n+     * @return polynomial function best fitting the observed points\n+     * @exception OptimizationException if the algorithm failed to converge\n+     */\n+    public PolynomialFunction fit()\n+        throws OptimizationException {\n+        try {\n+            return new PolynomialFunction(fitter.fit(new ParametricPolynomial(), new double[degree + 1]));\n+        } catch (FunctionEvaluationException fee) {\n+            // this should never happen\n+            throw MathRuntimeException.createInternalError(fee);\n+        }\n+    }\n+\n+    /** Dedicated parametric polynomial class. */\n+    private static class ParametricPolynomial implements ParametricRealFunction {\n+\n+        /** {@inheritDoc} */\n+        public double[] gradient(double x, double[] parameters)\n+                throws FunctionEvaluationException {\n+            final double[] gradient = new double[parameters.length];\n+            double xn = 1.0;\n+            for (int i = 0; i < parameters.length; ++i) {\n+                gradient[i] = xn;\n+                xn *= x;\n+            }\n+            return gradient;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double value(final double x, final double[] parameters) {\n+            double y = 0;\n+            for (int i = parameters.length - 1; i >= 0; --i) {\n+                y = y * x + parameters[i];\n+            }\n+            return y;\n+        }\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/fitting/WeightedObservedPoint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.io.Serializable;\n+\n+/** This class is a simple container for weighted observed point in\n+ * {@link CurveFitter curve fitting}.\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class WeightedObservedPoint implements Serializable {\n+\n+    /** Serializable version id. */\n+    private static final long serialVersionUID = 5306874947404636157L;\n+\n+    /** Weight of the measurement in the fitting process. */\n+    private final double weight;\n+\n+    /** Abscissa of the point. */\n+    private final double x;\n+\n+    /** Observed value of the function at x. */\n+    private final double y;\n+\n+    /** Simple constructor.\n+     * @param weight weight of the measurement in the fitting process\n+     * @param x abscissa of the measurement\n+     * @param y ordinate of the measurement\n+     */\n+    public WeightedObservedPoint(final double weight, final double x, final double y) {\n+        this.weight = weight;\n+        this.x      = x;\n+        this.y      = y;\n+    }\n+\n+    /** Get the weight of the measurement in the fitting process.\n+     * @return weight of the measurement in the fitting process\n+     */\n+    public double getWeight() {\n+        return weight;\n+    }\n+\n+    /** Get the abscissa of the point.\n+     * @return abscissa of the point\n+     */\n+    public double getX() {\n+        return x;\n+    }\n+\n+    /** Get the observed value of the function at x.\n+     * @return observed value of the function at x\n+     */\n+    public double getY() {\n+        return y;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.Test;\n+\n+public class HarmonicFitterTest {\n+\n+    @Test\n+    public void testNoError() throws OptimizationException {\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer());\n+        for (double x = 0.0; x < 1.3; x += 0.01) {\n+            fitter.addObservedPoint(1.0, x, f.value(x));\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.0e-13);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 1.0e-13);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.0e-13);\n+\n+        for (double x = -1.0; x < 1.0; x += 0.01) {\n+            assertTrue(Math.abs(f.value(x) - fitted.value(x)) < 1.0e-13);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void test1PercentError() throws OptimizationException {\n+        Random randomizer = new Random(64925784252l);\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer());\n+        for (double x = 0.0; x < 10.0; x += 0.1) {\n+            fitter.addObservedPoint(1.0, x,\n+                                   f.value(x) + 0.01 * randomizer.nextGaussian());\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 2.7e-3);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.3e-2);\n+\n+    }\n+\n+    @Test\n+    public void testInitialGuess() throws OptimizationException {\n+        Random randomizer = new Random(45314242l);\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer(), new double[] { 0.15, 3.6, 4.5 });\n+        for (double x = 0.0; x < 10.0; x += 0.1) {\n+            fitter.addObservedPoint(1.0, x,\n+                                   f.value(x) + 0.01 * randomizer.nextGaussian());\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 1.2e-3);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.3e-3);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.7e-2);\n+\n+    }\n+\n+    @Test\n+    public void testUnsorted() throws OptimizationException {\n+        Random randomizer = new Random(64925784252l);\n+        HarmonicFunction f = new HarmonicFunction(0.2, 3.4, 4.1);\n+\n+        HarmonicFitter fitter =\n+            new HarmonicFitter(new LevenbergMarquardtOptimizer());\n+\n+        // build a regularly spaced array of measurements\n+        int size = 100;\n+        double[] xTab = new double[size];\n+        double[] yTab = new double[size];\n+        for (int i = 0; i < size; ++i) {\n+            xTab[i] = 0.1 * i;\n+            yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian();\n+        }\n+\n+        // shake it\n+        for (int i = 0; i < size; ++i) {\n+            int i1 = randomizer.nextInt(size);\n+            int i2 = randomizer.nextInt(size);\n+            double xTmp = xTab[i1];\n+            double yTmp = yTab[i1];\n+            xTab[i1] = xTab[i2];\n+            yTab[i1] = yTab[i2];\n+            xTab[i2] = xTmp;\n+            yTab[i2] = yTmp;\n+        }\n+\n+        // pass it to the fitter\n+        for (int i = 0; i < size; ++i) {\n+            fitter.addObservedPoint(1.0, xTab[i], yTab[i]);\n+        }\n+\n+        HarmonicFunction fitted = fitter.fit();\n+        assertEquals(f.getAmplitude(), fitted.getAmplitude(), 7.6e-4);\n+        assertEquals(f.getPulsation(), fitted.getPulsation(), 3.5e-3);\n+        assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.5e-2);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n+import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+import org.junit.Test;\n+\n+public class PolynomialFitterTest {\n+\n+    @Test\n+    public void testNoError() throws OptimizationException {\n+        Random randomizer = new Random(64925784252l);\n+        for (int degree = 1; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter =\n+                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());\n+            for (int i = 0; i <= degree; ++i) {\n+                fitter.addObservedPoint(1.0, i, p.value(i));\n+            }\n+\n+            PolynomialFunction fitted = fitter.fit();\n+\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                double error = Math.abs(p.value(x) - fitted.value(x)) /\n+                               (1.0 + Math.abs(p.value(x)));\n+                assertEquals(0.0, error, 1.0e-6);\n+            }\n+\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSmallError() throws OptimizationException {\n+        Random randomizer = new Random(53882150042l);\n+        double maxError = 0;\n+        for (int degree = 0; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter =\n+                new PolynomialFitter(degree, new LevenbergMarquardtOptimizer());\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                fitter.addObservedPoint(1.0, x,\n+                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n+            }\n+\n+            PolynomialFunction fitted = fitter.fit();\n+\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                double error = Math.abs(p.value(x) - fitted.value(x)) /\n+                              (1.0 + Math.abs(p.value(x)));\n+                maxError = Math.max(maxError, error);\n+                assertTrue(Math.abs(error) < 0.1);\n+            }\n+        }\n+        assertTrue(maxError > 0.01);\n+\n+    }\n+\n+    @Test\n+    public void testRedundantSolvable() {\n+        // Levenberg-Marquardt should handle redundant information gracefully\n+        checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true);\n+    }\n+\n+    @Test\n+    public void testRedundantUnsolvable() {\n+        // Gauss-Newton should not be able to solve redundant information\n+        DifferentiableMultivariateVectorialOptimizer optimizer =\n+            new GaussNewtonOptimizer(true);\n+        checkUnsolvableProblem(optimizer, false);\n+    }\n+\n+    private void checkUnsolvableProblem(DifferentiableMultivariateVectorialOptimizer optimizer,\n+                                        boolean solvable) {\n+        Random randomizer = new Random(1248788532l);\n+        for (int degree = 0; degree < 10; ++degree) {\n+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n+\n+            PolynomialFitter fitter = new PolynomialFitter(degree, optimizer);\n+\n+            // reusing the same point over and over again does not bring\n+            // information, the problem cannot be solved in this case for\n+            // degrees greater than 1 (but one point is sufficient for\n+            // degree 0)\n+            for (double x = -1.0; x < 1.0; x += 0.01) {\n+                fitter.addObservedPoint(1.0, 0.0, p.value(0.0));\n+            }\n+\n+            try {\n+                fitter.fit();\n+                assertTrue(solvable || (degree == 0));\n+            } catch(OptimizationException e) {\n+                assertTrue((! solvable) && (degree > 0));\n+            }\n+\n+        }\n+\n+    }\n+\n+    private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) {\n+        final double[] coefficients = new double[degree + 1];\n+        for (int i = 0; i <= degree; ++i) {\n+            coefficients[i] = randomizer.nextGaussian();\n+        }\n+        return new PolynomialFunction(coefficients);\n+    }\n+\n+}", "timestamp": 1245414976, "metainfo": ""}