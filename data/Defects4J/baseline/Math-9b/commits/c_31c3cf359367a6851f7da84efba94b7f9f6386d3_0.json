{"sha": "31c3cf359367a6851f7da84efba94b7f9f6386d3", "log": "Simplified names of ODE with Jacobians integration classes Added step handling for this feature  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.jacobians;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/** This class enhances a first order integrator for differential equations to\n+ * compute also partial derivatives of the solution with respect to initial state\n+ * and parameters.\n+ * <p>In order to compute both the state and its derivatives, the ODE problem\n+ * is extended with jacobians of the raw ODE and the variational equations are\n+ * added to form a new compound problem of higher dimension. If the original ODE\n+ * problem has dimension n and there are p parameters, the compound problem will\n+ * have dimension n &times; (1 + n + k).</p>\n+ * @see ParameterizedODE\n+ * @see ParameterizedODEWithJacobians\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+public class FirstOrderIntegratorWithJacobians {\n+\n+    /** Underlying integrator for compound problem. */\n+    private final FirstOrderIntegrator integrator;\n+\n+    /** Raw equations to integrate. */\n+    private final ParameterizedODEWithJacobians ode;\n+\n+    /** Build an enhanced integrator using internal differentiation to compute jacobians.\n+     * @param integrator underlying integrator to solve the compound problem\n+     * @param ode original problem (f in the equation y' = f(t, y))\n+     * @param p parameters array (may be null if {@link\n+     * ParameterizedODE#getParametersDimension()\n+     * getParametersDimension()} from original problem is zero)\n+     * @param hY step sizes to use for computing the jacobian df/dy, must have the\n+     * same dimension as the original problem\n+     * @param hP step sizes to use for computing the jacobian df/dp, must have the\n+     * same dimension as the original problem parameters dimension\n+     * @see #EnhancedFirstOrderIntegrator(FirstOrderIntegrator,\n+     * ParameterizedODEWithJacobians)\n+     */\n+    public FirstOrderIntegratorWithJacobians(final FirstOrderIntegrator integrator,\n+                                             final ParameterizedODE ode,\n+                                             final double[] p, final double[] hY, final double[] hP) {\n+        checkDimension(ode.getDimension(), hY);\n+        checkDimension(ode.getParametersDimension(), p);\n+        checkDimension(ode.getParametersDimension(), hP);\n+        this.integrator = integrator;\n+        this.ode = new FiniteDifferencesWrapper(ode, p, hY, hP);\n+    }\n+\n+    /** Build an enhanced integrator using ODE builtin jacobian computation features.\n+     * @param integrator underlying integrator to solve the compound problem\n+     * @param ode original problem, which can compute the jacobians by itself\n+     * @see #EnhancedFirstOrderIntegrator(FirstOrderIntegrator,\n+     * ParameterizedODE, double[], double[], double[])\n+     */\n+    public FirstOrderIntegratorWithJacobians(final FirstOrderIntegrator integrator,\n+                                             final ParameterizedODEWithJacobians ode) {\n+        this.integrator = integrator;\n+        this.ode = ode;\n+    }\n+\n+    /** Add a step handler to this integrator.\n+     * <p>The handler will be called by the integrator for each accepted\n+     * step.</p>\n+     * @param handler handler for the accepted steps\n+     * @see #getStepHandlers()\n+     * @see #clearStepHandlers()\n+     */\n+    public void addStepHandler(StepHandlerWithJacobians handler) {\n+        integrator.addStepHandler(new StepHandlerWrapper(handler));\n+    }\n+\n+    /** Get all the step handlers that have been added to the integrator.\n+     * @return an unmodifiable collection of the added events handlers\n+     * @see #addStepHandler(StepHandlerWithJacobians)\n+     * @see #clearStepHandlers()\n+     */\n+    public Collection<StepHandlerWithJacobians> getStepHandlers() {\n+        final Collection<StepHandlerWithJacobians> handlers =\n+            new ArrayList<StepHandlerWithJacobians>();\n+        for (final StepHandler handler : integrator.getStepHandlers()) {\n+            if (handler instanceof StepHandlerWrapper) {\n+                handlers.add(((StepHandlerWrapper) handler).getHandler());\n+            }\n+        }\n+        return handlers;\n+    }\n+\n+    /** Remove all the step handlers that have been added to the integrator.\n+     * @see #addStepHandler(StepHandlerWithJacobians)\n+     * @see #getStepHandlers()\n+     */\n+    public void clearStepHandlers() {\n+\n+        // preserve the handlers we did not add ourselves\n+        final Collection<StepHandler> otherHandlers = new ArrayList<StepHandler>();\n+        for (final StepHandler handler : integrator.getStepHandlers()) {\n+            if (!(handler instanceof StepHandlerWrapper)) {\n+                otherHandlers.add(handler);\n+            }\n+        }\n+\n+        // clear all handlers\n+        integrator.clearStepHandlers();\n+\n+        // put back the preserved handlers\n+        for (final StepHandler handler : otherHandlers) {\n+            integrator.addStepHandler(handler);\n+        }\n+\n+    }\n+\n+    /** Integrate the differential equations and the variational equations up to the given time.\n+     * <p>This method solves an Initial Value Problem (IVP) and also computes the derivatives\n+     * of the solution with respect to initial state and parameters. This can be used as\n+     * a basis to solve Boundary Value Problems (BVP).</p>\n+     * <p>Since this method stores some internal state variables made\n+     * available in its public interface during integration ({@link\n+     * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n+     * @param equations differential equations to integrate\n+     * @param t0 initial time\n+     * @param y0 initial value of the state vector at t0\n+     * @param dY0dP initial value of the state vector derivative with respect to the\n+     * parameters at t0\n+     * @param t target time for the integration\n+     * (can be set to a value smaller than <code>t0</code> for backward integration)\n+     * @param y placeholder where to put the state vector at each successful\n+     *  step (and hence at the end of integration), can be the same object as y0\n+     * @param dYdY0 placeholder where to put the state vector derivative with respect\n+     * to the initial state (dy[i]/dy0[j] is in element array dYdY0[i][j]) at each successful\n+     *  step (and hence at the end of integration)\n+     * @param dYdP placeholder where to put the state vector derivative with respect\n+     * to the parameters (dy[i]/dp[j] is in element array dYdP[i][j]) at each successful\n+     *  step (and hence at the end of integration)\n+     * @return stop time, will be the same as target time if integration reached its\n+     * target, but may be different if some event handler stops it at some point.\n+     * @throws IntegratorException if the integrator cannot perform integration\n+     * @throws DerivativeException this exception is propagated to the caller if\n+     * the underlying user function triggers one\n+     */\n+    public double integrate(final double t0, final double[] y0, final double[][] dY0dP,\n+                            final double t, final double[] y,\n+                            final double[][] dYdY0, final double[][] dYdP)\n+        throws DerivativeException, IntegratorException {\n+\n+        final int n = ode.getDimension();\n+        final int k = ode.getParametersDimension();\n+        checkDimension(n, y0);\n+        checkDimension(n, y);\n+        checkDimension(n, dYdY0);\n+        checkDimension(n, dYdY0[0]);\n+        if (k != 0) {\n+            checkDimension(n, dY0dP);\n+            checkDimension(k, dY0dP[0]);\n+            checkDimension(n, dYdP);\n+            checkDimension(k, dYdP[0]);\n+        }\n+\n+        // the compound state z contains the raw state y and its derivatives\n+        // with respect to initial state y0 and to parameters p\n+        //    y[i]         is stored in z[i]\n+        //    dy[i]/dy0[j] is stored in z[n + i * n + j]\n+        //    dy[i]/dp[j]  is stored in z[n * (n + 1) + i * k + j]\n+        final int q = n * (1 + n + k);\n+\n+        // set up initial state, including partial derivatives\n+        final double[] z = new double[q];\n+        System.arraycopy(y0, 0, z, 0, n);\n+        for (int i = 0; i < n; ++i) {\n+\n+            // set diagonal element of dy/dy0 to 1.0 at t = t0\n+            z[i * (1 + n) + n] = 1.0;\n+\n+            // set initial derivatives with respect to parameters\n+            System.arraycopy(dY0dP[i], 0, z, n * (n + 1) + i * k, k);\n+\n+        }\n+\n+        // integrate the compound state variational equations\n+        final double stopTime = integrator.integrate(new FirstOrderDifferentialEquations() {\n+\n+            /** Current state. */\n+            private final double[]   y    = new double[n];\n+\n+            /** Time derivative of the current state. */\n+            private final double[]   yDot = new double[n];\n+\n+            /** Derivatives of yDot with respect to state. */\n+            private final double[][] dFdY = new double[n][n];\n+\n+            /** Derivatives of yDot with respect to parameters. */\n+            private final double[][] dFdP = new double[n][k];\n+\n+            /** {@inheritDoc} */\n+            public int getDimension() {\n+                return q;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void computeDerivatives(final double t, final double[] z, final double[] zDot)\n+                throws DerivativeException {\n+\n+                // compute raw ODE and its jacobians: dy/dt, d[dy/dt]/dy0 and d[dy/dt]/dp\n+                System.arraycopy(z,    0, y,    0, n);\n+                ode.computeDerivatives(t, y, yDot);\n+                ode.computeJacobians(t, y, yDot, dFdY, dFdP);\n+\n+                // state part of the compound equations\n+                System.arraycopy(yDot, 0, zDot, 0, n);\n+\n+                // variational equations: from d[dy/dt]/dy0 to d[dy/dy0]/dt\n+                for (int i = 0; i < n; ++i) {\n+                    final double[] dFdYi = dFdY[i];\n+                    for (int j = 0; j < n; ++j) {\n+                        double s = 0;\n+                        int zIndex = n + j;\n+                        for (int l = 0; l < n; ++l) {\n+                            s += dFdYi[l] * z[zIndex];\n+                            zIndex += l;\n+                        }\n+                        zDot[n + i * n + j] = s;\n+                    }\n+                }\n+\n+                // variational equations: d[dy/dt]/dy0 and d[dy/dt]/dp to d[dy/dp]/dt\n+                for (int i = 0; i < n; ++i) {\n+                    final double[] dFdYi = dFdY[i];\n+                    final double[] dFdPi = dFdP[i];\n+                    for (int j = 0; j < k; ++j) {\n+                        double s = dFdPi[j];\n+                        int zIndex = n * (n + 1)+ j;\n+                        for (int l = 0; l < n; ++l) {\n+                            s += dFdYi[l] * z[zIndex];\n+                            zIndex += k;\n+                        }\n+                        zDot[n * (n + 1) + i * k + j] = s;\n+                    }\n+                }\n+\n+            }\n+\n+        }, t0, z, t, z);\n+\n+        // dispatch the final compound state into the state and partial derivatives arrays\n+        System.arraycopy(z, 0, y, 0, n);\n+        for (int i = 0; i < n; ++i) {\n+            System.arraycopy(z, n * (i + 1), dYdY0[i], 0, n);\n+        }\n+        for (int i = 0; i < n; ++i) {\n+            System.arraycopy(z, n * (n + 1) + i * k, dYdP[i], 0, k);\n+        }\n+\n+        return stopTime;\n+\n+    }\n+\n+    /** Check array dimensions.\n+     * @param expected expected dimension\n+     * @param array (may be null if expected is 0)\n+     * @throws IllegalArgumentException if the array dimension does not match the expected one\n+     */\n+    private void checkDimension(final int expected, final Object array)\n+        throws IllegalArgumentException {\n+        int arrayDimension = (array == null) ? 0 : Array.getLength(array);\n+        if (arrayDimension != expected) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"dimension mismatch {0} != {1}\", arrayDimension, expected);\n+        }\n+    }\n+\n+    /** Wrapper class to compute jacobians by finite differences for ODE which do not compute them themselves. */\n+    private static class FiniteDifferencesWrapper\n+        implements ParameterizedODEWithJacobians {\n+\n+        /** Raw ODE without jacobians computation. */\n+        private final ParameterizedODE ode;\n+\n+        /** Parameters array (may be null if parameters dimension from original problem is zero) */\n+        private final double[] p;\n+\n+        /** Step sizes to use for computing the jacobian df/dy. */\n+        private final double[] hY;\n+\n+        /** Step sizes to use for computing the jacobian df/dp. */\n+        private final double[] hP;\n+\n+        /** Temporary array for state derivatives used to compute jacobians. */\n+        private final double[] tmpDot;\n+\n+        /** Simple constructor.\n+         * @param ode original ODE problem, without jacobians computations\n+         * @param p parameters array (may be null if parameters dimension from original problem is zero)\n+         * @param hY step sizes to use for computing the jacobian df/dy\n+         * @param hP step sizes to use for computing the jacobian df/dp\n+         */\n+        public FiniteDifferencesWrapper(final ParameterizedODE ode,\n+                                        final double[] p, final double[] hY, final double[] hP) {\n+            this.ode = ode;\n+            this.p  = p.clone();\n+            this.hY = hY.clone();\n+            this.hP = hP.clone();\n+            tmpDot = new double[ode.getDimension()];\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            return ode.getDimension();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeDerivatives(double t, double[] y, double[] yDot) throws DerivativeException {\n+            ode.computeDerivatives(t, y, yDot);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getParametersDimension() {\n+            return ode.getParametersDimension();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setParameter(int i, double value) {\n+            ode.setParameter(i, value);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeJacobians(double t, double[] y, double[] yDot,\n+                                     double[][] dFdY, double[][] dFdP)\n+            throws DerivativeException {\n+\n+            final int n = ode.getDimension();\n+            final int k = ode.getParametersDimension();\n+\n+            // compute df/dy where f is the ODE and y is the state array\n+            for (int j = 0; j < n; ++j) {\n+                final double savedYj = y[j];\n+                y[j] += hY[j];\n+                ode.computeDerivatives(t, y, tmpDot);\n+                for (int i = 0; i < n; ++i) {\n+                    dFdY[i][j] = (tmpDot[i] - yDot[i]) / hY[j];\n+                }\n+                y[j] = savedYj;\n+            }\n+\n+            // compute df/dp where f is the ODE and p is the parameters array\n+            for (int j = 0; j < k; ++j) {\n+                ode.setParameter(j, p[j] +  hP[j]);\n+                ode.computeDerivatives(t, y, tmpDot);\n+                for (int i = 0; i < n; ++i) {\n+                    dFdP[i][j] = (tmpDot[i] - yDot[i]) / hP[j];\n+                }\n+                ode.setParameter(j, p[j]);\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** Wrapper for step handlers. */\n+    private class StepHandlerWrapper implements StepHandler {\n+\n+        /** Underlying step handler with jacobians. */\n+        private final StepHandlerWithJacobians handler;\n+\n+        /** Simple constructor.\n+         * @param handler underlying step handler with jacobians\n+         */\n+        public StepHandlerWrapper(final StepHandlerWithJacobians handler) {\n+            this.handler = handler;\n+        }\n+\n+        /** Get the underlying step handler with jacobians.\n+         * @return underlying step handler with jacobians\n+         */\n+        public StepHandlerWithJacobians getHandler() {\n+            return handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+            throws DerivativeException {\n+            handler.handleStep(new StepInterpolatorWrapper(interpolator,\n+                                                           ode.getDimension(),\n+                                                           ode.getParametersDimension()),\n+                               isLast);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean requiresDenseOutput() {\n+            return handler.requiresDenseOutput();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void reset() {\n+            handler.reset();\n+        }\n+\n+    }\n+\n+    /** Wrapper for step interpolators. */\n+    private static class StepInterpolatorWrapper\n+        implements StepInterpolatorWithJacobians {\n+\n+        /** Wrapped interpolator. */\n+        private StepInterpolator interpolator;\n+\n+        /** State array. */\n+        private double[] y;\n+\n+        /** State derivative array. */\n+        private double[] yDot;\n+\n+        /** Jacobian with respect to initial state dy/dy0. */\n+        private double[][] dydy0;\n+\n+        /** Jacobian with respect to parameters dy/dp. */\n+        private double[][] dydp;\n+\n+        /** Simple constructor.\n+         * @param interpolator wrapped interpolator\n+         * @param n dimension of the original ODE\n+         * @param k number of parameters\n+         */\n+        public StepInterpolatorWrapper(final StepInterpolator interpolator,\n+                                       final int n, final int k) {\n+            this.interpolator = interpolator;\n+            y     = new double[n];\n+            yDot  = new double[n];\n+            dydy0 = new double[n][n];\n+            dydp  = new double[n][k];\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setInterpolatedTime(double time) {\n+            interpolator.setInterpolatedTime(time);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isForward() {\n+            return interpolator.isForward();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getPreviousTime() {\n+            return interpolator.getPreviousTime();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getInterpolatedTime() {\n+            return interpolator.getInterpolatedTime();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] getInterpolatedY() throws DerivativeException {\n+            double[] extendedState = interpolator.getInterpolatedState();\n+            System.arraycopy(extendedState, 0, y, 0, y.length);\n+            return y;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[][] getInterpolatedDyDy0() throws DerivativeException {\n+            double[] extendedState = interpolator.getInterpolatedState();\n+            final int n = y.length;\n+            int start = n;\n+            for (int i = 0; i < n; ++i) {\n+                System.arraycopy(extendedState, start, dydy0[i], 0, n);\n+                start += n;\n+            }\n+            return dydy0;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[][] getInterpolatedDyDp() throws DerivativeException {\n+            double[] extendedState = interpolator.getInterpolatedState();\n+            final int n = y.length;\n+            final int k = dydp[0].length;\n+            int start = n * (n + 1);\n+            for (int i = 0; i < n; ++i) {\n+                System.arraycopy(extendedState, start, dydp[i], 0, k);\n+                start += k;\n+            }\n+            return dydp;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] getInterpolatedYDot() throws DerivativeException {\n+            double[] extendedDerivatives = interpolator.getInterpolatedDerivatives();\n+            System.arraycopy(extendedDerivatives, 0, yDot, 0, yDot.length);\n+            return yDot;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[][] getInterpolatedDyDy0Dot() throws DerivativeException {\n+            double[] extendedDerivatives = interpolator.getInterpolatedDerivatives();\n+            final int n = y.length;\n+            int start = n;\n+            for (int i = 0; i < n; ++i) {\n+                System.arraycopy(extendedDerivatives, start, dydy0[i], 0, n);\n+                start += n;\n+            }\n+            return dydy0;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[][] getInterpolatedDyDpDot() throws DerivativeException {\n+            double[] extendedDerivatives = interpolator.getInterpolatedDerivatives();\n+            final int n = y.length;\n+            final int k = dydp[0].length;\n+            int start = n * (n + 1);\n+            for (int i = 0; i < n; ++i) {\n+                System.arraycopy(extendedDerivatives, start, dydp[i], 0, k);\n+                start += k;\n+            }\n+            return dydp;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getCurrentTime() {\n+            return interpolator.getCurrentTime();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public StepInterpolatorWithJacobians copy() throws DerivativeException {\n+            return new StepInterpolatorWrapper(interpolator.copy(),\n+                                               y.length, dydy0[0].length);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void writeExternal(ObjectOutput out) throws IOException {\n+            out.writeObject(interpolator);\n+            final int n = y.length;\n+            final int k = dydp[0].length;\n+            out.writeInt(n);\n+            out.writeInt(k);\n+            for (int i = 0; i < n; ++i) {\n+                out.writeDouble(y[i]);\n+            }\n+            for (int i = 0; i < n; ++i) {\n+                out.writeDouble(yDot[i]);\n+            }\n+            for (int i = 0; i < n; ++i) {\n+                for (int j = 0; j < n; ++j) {\n+                    out.writeDouble(dydy0[i][j]);\n+                }\n+            }\n+            for (int i = 0; i < n; ++i) {\n+                for (int j = 0; j < k; ++j) {\n+                    out.writeDouble(dydp[i][j]);\n+                }\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+            interpolator = (StepInterpolator) in.readObject();\n+            final int n = in.readInt();\n+            final int k = in.readInt();\n+            y = new double[n];\n+            dydy0 = new double[n][n];\n+            dydp = new double[n][k];\n+            for (int i = 0; i < n; ++i) {\n+                y[i] = in.readDouble();\n+            }\n+            for (int i = 0; i < n; ++i) {\n+                yDot[i] = in.readDouble();\n+            }\n+            for (int i = 0; i < n; ++i) {\n+                for (int j = 0; j < n; ++j) {\n+                    dydy0[i][j] = in.readDouble();\n+                }\n+            }\n+            for (int i = 0; i < n; ++i) {\n+                for (int j = 0; j < k; ++j) {\n+                    dydp[i][j] = in.readDouble();\n+                }\n+            }\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/ParameterizedODE.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.jacobians;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+\n+\n+/** This interface represents {@link FirstOrderDifferentialEquations\n+ * first order differential equations} with parameters.\n+ *\n+ * @see FirstOrderIntegratorWithJacobians\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public interface ParameterizedODE\n+    extends FirstOrderDifferentialEquations {\n+\n+    /** Get the number of parameters.\n+     * @return number of parameters\n+     */\n+    int getParametersDimension();\n+\n+    /** Set a parameter.\n+     * @param i index of the parameters (must be between 0\n+     * and {@link #getParametersDimension() getParametersDimension() - 1})\n+     * @param value value for the parameter\n+     */\n+    void setParameter(int i, double value);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/ParameterizedODEWithJacobians.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.jacobians;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+\n+/** This interface represents {@link ParameterizedODE\n+ * first order differential equations} with parameters and partial derivatives.\n+ *\n+ * @see FirstOrderIntegratorWithJacobians\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public interface ParameterizedODEWithJacobians\n+    extends ParameterizedODE {\n+\n+    /** Compute the partial derivatives of ODE with respect to state.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot array containing the current value of the time derivative of the state vector\n+     * @param dFdY placeholder array where to put the jacobian of the ODE with respect to the state vector\n+     * @param dFdP placeholder array where to put the jacobian of the ODE with respect to the parameters\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP)\n+        throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/StepHandlerWithJacobians.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.jacobians;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful step.\n+ *\n+ * <p>The ODE integrators compute the evolution of the state vector at\n+ * some grid points that depend on their own internal algorithm. Once\n+ * they have found a new grid point (possibly after having computed\n+ * several evaluation of the derivative at intermediate points), they\n+ * provide it to objects implementing this interface. These objects\n+ * typically either ignore the intermediate steps and wait for the\n+ * last one, store the points in an ephemeris, or forward them to\n+ * specialized processing or output methods.</p>\n+ *\n+ * @see FirstOrderIntegratorWithJacobians\n+ * @see StepInterpolatorWithJacobians\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public interface StepHandlerWithJacobians {\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>This method allows the integrator to avoid performing extra\n+   * computation if the handler does not need dense output. If this\n+   * method returns false, the integrator will call the {@link\n+   * #handleStep} method with a {@link DummyStepInterpolator} rather\n+   * than a custom interpolator.</p>\n+   * @return true if the handler needs dense output\n+   */\n+  boolean requiresDenseOutput();\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  void reset();\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range, as the\n+   * {@link org.apache.commons.math.ode.ContinuousOutputModel\n+   * ContinuousOutputModel} class does), it should build a local copy\n+   * using the clone method of the interpolator and store this copy.\n+   * Keeping only a reference to the interpolator and reusing it will\n+   * result in unpredictable behavior (potentially crashing the application).\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  void handleStep(StepInterpolatorWithJacobians interpolator, boolean isLast) throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/StepInterpolatorWithJacobians.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.jacobians;\n+\n+import java.io.Externalizable;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/** This interface represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects implementing this\n+ * interface to the step handlers. These objects are often custom\n+ * objects tightly bound to the integrator internal algorithms. The\n+ * handlers can use these objects to retrieve the state vector at\n+ * intermediate times between the previous and the current grid points\n+ * (this feature is often called dense output).</p>\n+ * <p>One important thing to note is that the step handlers may be so\n+ * tightly bound to the integrators that they often share some internal\n+ * state arrays. This imply that one should <em>never</em> use a direct\n+ * reference to a step interpolator outside of the step handler, either\n+ * for future use or for use in another thread. If such a need arise, the\n+ * step interpolator <em>must</em> be copied using the dedicated\n+ * {@link #copy()} method.\n+ * </p>\n+ *\n+ * @see FirstOrderIntegratorWithJacobians\n+ * @see StepHandlerWithJacobians\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public interface StepInterpolatorWithJacobians extends Externalizable {\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  double getPreviousTime();\n+\n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  double getCurrentTime();\n+\n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  double getInterpolatedTime();\n+\n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed, but\n+   * should be used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * <p>Setting the time changes the instance internal state. If a\n+   * specific state must be preserved, a copy of the instance must be\n+   * created using {@link #copy()}.</p>\n+   * @param time time of the interpolated point\n+   */\n+  void setInterpolatedTime(double time);\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedYDot()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  double[] getInterpolatedY() throws DerivativeException;\n+\n+  /**\n+   * Get the partial derivatives of the state vector with respect to\n+   * the initial state of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return partial derivatives of the state vector with respect to\n+   * the initial state at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedY()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  double[][] getInterpolatedDyDy0() throws DerivativeException;\n+\n+  /**\n+   * Get the partial derivatives of the state vector with respect to\n+   * the ODE parameters of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return partial derivatives of the state vector with respect to\n+   * the ODE parameters at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedY()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  double[][] getInterpolatedDyDp() throws DerivativeException;\n+\n+  /**\n+   * Get the time derivatives of the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedY()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  double[] getInterpolatedYDot() throws DerivativeException;\n+\n+  /**\n+   * Get the time derivatives of the jacobian of the state vector\n+   * with respect to the initial state of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return time derivatives of the jacobian of the state vector\n+   * with respect to the initial state at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedY()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  double[][] getInterpolatedDyDy0Dot() throws DerivativeException;\n+\n+  /**\n+   * Get the time derivatives of the jacobian of the state vector\n+   * with respect to the ODE parameters of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return time derivatives of the jacobian of the state vector\n+   * with respect to the ODE parameters at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedY()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  double[][] getInterpolatedDyDpDot() throws DerivativeException;\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by\n+   * the integrator itself, it avoid some nasty problems in\n+   * degenerated cases like null steps due to cancellation at step\n+   * initialization, step control or discrete events\n+   * triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  boolean isForward();\n+\n+  /** Copy the instance.\n+   * <p>The copied instance is guaranteed to be independent from the\n+   * original one. Both can be used with different settings for\n+   * interpolated time without any side effect.</p>\n+   * @return a deep copy of the instance, which can be used independently.\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @see #setInterpolatedTime(double)\n+   */\n+   StepInterpolatorWithJacobians copy() throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.jacobians;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.jacobians.FirstOrderIntegratorWithJacobians;\n+import org.apache.commons.math.ode.jacobians.ParameterizedODEWithJacobians;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class FirstOrderIntegratorWithJacobiansTest {\n+\n+    @Test\n+    public void testLowAccuracyExternalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+        double hP = 1.0e-12;\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            double[] y = { 1.3, b };\n+            integ.integrate(brusselator, 0, y, 20.0, y);\n+            double[] yP = { 1.3, b + hP };\n+            brusselator.setParameter(0, b + hP);\n+            integ.integrate(brusselator, 0, yP, 20.0, yP);\n+            residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());\n+            residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 600);\n+        Assert.assertTrue(residuals0.getStandardDeviation() > 30);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 800);\n+        Assert.assertTrue(residuals1.getStandardDeviation() > 50);\n+    }\n+\n+    @Test\n+    public void testHighAccuracyExternalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+        double hP = 1.0e-12;\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            double[] y = { 1.3, b };\n+            integ.integrate(brusselator, 0, y, 20.0, y);\n+            double[] yP = { 1.3, b + hP };\n+            brusselator.setParameter(0, b + hP);\n+            integ.integrate(brusselator, 0, yP, 20.0, yP);\n+            residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());\n+            residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 0.02);\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.03);\n+        Assert.assertTrue(residuals0.getStandardDeviation() > 0.003);\n+        Assert.assertTrue(residuals0.getStandardDeviation() < 0.004);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 0.04);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.05);\n+        Assert.assertTrue(residuals1.getStandardDeviation() > 0.006);\n+        Assert.assertTrue(residuals1.getStandardDeviation() < 0.007);\n+    }\n+\n+    @Test\n+    public void testInternalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+        double hP = 1.0e-12;\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            brusselator.setParameter(0, b);\n+            double[] z = { 1.3, b };\n+            double[][] dZdZ0 = new double[2][2];\n+            double[][] dZdP  = new double[2][1];\n+            double hY = 1.0e-12;\n+            FirstOrderIntegratorWithJacobians extInt =\n+                new FirstOrderIntegratorWithJacobians(integ, brusselator, new double[] { b },\n+                                                 new double[] { hY, hY }, new double[] { hP });\n+            extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n+            residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());\n+            residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());\n+        }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.006);\n+        Assert.assertTrue(residuals0.getStandardDeviation() < 0.0009);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.006);\n+        Assert.assertTrue(residuals1.getStandardDeviation() < 0.0012);\n+    }\n+\n+    @Test\n+    public void testAnalyticalDifferentiation()\n+        throws IntegratorException, DerivativeException {\n+        FirstOrderIntegrator integ =\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n+        SummaryStatistics residuals0 = new SummaryStatistics();\n+        SummaryStatistics residuals1 = new SummaryStatistics();\n+        for (double b = 2.88; b < 3.08; b += 0.001) {\n+            Brusselator brusselator = new Brusselator(b);\n+            brusselator.setParameter(0, b);\n+            double[] z = { 1.3, b };\n+            double[][] dZdZ0 = new double[2][2];\n+            double[][] dZdP  = new double[2][1];\n+            FirstOrderIntegratorWithJacobians extInt =\n+                new FirstOrderIntegratorWithJacobians(integ, brusselator);\n+            extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n+            residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());\n+            residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());\n+       }\n+        Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.004);\n+        Assert.assertTrue(residuals0.getStandardDeviation() < 0.001);\n+        Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.005);\n+        Assert.assertTrue(residuals1.getStandardDeviation() < 0.001);\n+    }\n+\n+    private static class Brusselator implements ParameterizedODEWithJacobians {\n+\n+        private double b;\n+\n+        public Brusselator(double b) {\n+            this.b = b;\n+        }\n+\n+        public int getDimension() {\n+            return 2;\n+        }\n+\n+        public void setParameter(int i, double p) {\n+            b = p;\n+        }\n+\n+        public int getParametersDimension() {\n+            return 1;\n+        }\n+\n+        public void computeDerivatives(double t, double[] y, double[] yDot) {\n+            double prod = y[0] * y[0] * y[1];\n+            yDot[0] = 1 + prod - (b + 1) * y[0];\n+            yDot[1] = b * y[0] - prod;\n+        }\n+\n+        public void computeJacobians(double t, double[] y, double[] yDot, double[][] dFdY, double[][] dFdP) {\n+            double p = 2 * y[0] * y[1];\n+            double y02 = y[0] * y[0];\n+            dFdY[0][0] = p - (1 + b);\n+            dFdY[0][1] = y02;\n+            dFdY[1][0] = b - p;\n+            dFdY[1][1] = -y02;\n+            dFdP[0][0] = -y[0];\n+            dFdP[1][0] = y[0];\n+        }\n+\n+        public double dYdP0() {\n+            return -1087.8787631970476 + (1050.4387741821572 + (-338.90621620263096 + 36.51793006801084 * b) * b) * b;\n+        }\n+\n+        public double dYdP1() {\n+            return 1499.0904666097015 + (-1434.9574631810726 + (459.71079478756945 - 49.29949940968588 * b) * b) * b;\n+        }\n+\n+    };\n+\n+}", "timestamp": 1267651696, "metainfo": ""}