{"sha": "def9fbf8701afa6937fe582c7572c7be011c319f", "log": "Use the new highly accurate linearCombination utility methods in 3D Euclidean geometry.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n      * @param u2 second base (unscaled) vector\n      */\n     public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n-        this.x = a1 * u1.x + a2 * u2.x;\n-        this.y = a1 * u1.y + a2 * u2.y;\n-        this.z = a1 * u1.z + a2 * u2.z;\n+        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x);\n+        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y);\n+        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z);\n     }\n \n     /** Linear constructor\n      */\n     public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                     double a3, Vector3D u3) {\n-        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n-        this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n-        this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n+        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n+        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n+        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n     }\n \n     /** Linear constructor\n      */\n     public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                     double a3, Vector3D u3, double a4, Vector3D u4) {\n-        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n-        this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n-        this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n+        this.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x, a4, u4.x);\n+        this.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y, a4, u4.y);\n+        this.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z, a4, u4.z);\n     }\n \n     /** Get the abscissa of the vector.\n \n     /** {@inheritDoc} */\n     public double getNorm() {\n+        // there are no cancellation problems here, so we use the straightforward formula\n         return FastMath.sqrt (x * x + y * y + z * z);\n     }\n \n     /** {@inheritDoc} */\n     public double getNormSq() {\n+        // there are no cancellation problems here, so we use the straightforward formula\n         return x * x + y * y + z * z;\n     }\n \n \n     /** {@inheritDoc} */\n     public Vector3D add(double factor, final Vector<Euclidean3D> v) {\n-        final Vector3D v3 = (Vector3D) v;\n-        return new Vector3D(x + factor * v3.x, y + factor * v3.y, z + factor * v3.z);\n+        return new Vector3D(1, this, factor, (Vector3D) v);\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public Vector3D subtract(final double factor, final Vector<Euclidean3D> v) {\n-        final Vector3D v3 = (Vector3D) v;\n-        return new Vector3D(x - factor * v3.x, y - factor * v3.y, z - factor * v3.z);\n+        return new Vector3D(1, this, -factor, (Vector3D) v);\n     }\n \n     /** {@inheritDoc} */\n             throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n \n-        double dot = dotProduct(v1, v2);\n+        double dot = v1.dotProduct(v2);\n         double threshold = normProduct * 0.9999;\n         if ((dot < -threshold) || (dot > threshold)) {\n             // the vectors are almost aligned, compute using the sine\n         return 643 * (164 * MathUtils.hash(x) +  3 * MathUtils.hash(y) +  MathUtils.hash(z));\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * <p>\n+     * The implementation uses specific multiplication and addition\n+     * algorithms to preserve accuracy and reduce cancellation effects.\n+     * It should be very accurate even for nearly orthogonal vectors.\n+     * </p>\n+     * @see MathUtils#linearCombination(double, double, double, double, double, double)\n+     */\n     public double dotProduct(final Vector<Euclidean3D> v) {\n         final Vector3D v3 = (Vector3D) v;\n-        return x * v3.x + y * v3.y + z * v3.z;\n+        return MathUtils.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n     }\n \n     /** Compute the cross-product of the instance with another vector.\n-     * @param v other vectorvector\n+     * @param v other vector\n      * @return the cross product this ^ v as a new Vector3D\n      */\n     public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n         final Vector3D v3 = (Vector3D) v;\n-\n-        final double n1 = getNormSq();\n-        final double n2 = v.getNormSq();\n-        if ((n1 * n2) < MathUtils.SAFE_MIN) {\n-            return ZERO;\n-        }\n-\n-        // rescale both vectors without losing precision,\n-        // to ensure their norm are the same order of magnitude\n-        final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n-        final double x1    = FastMath.scalb(x,   -deltaExp);\n-        final double y1    = FastMath.scalb(y,   -deltaExp);\n-        final double z1    = FastMath.scalb(z,   -deltaExp);\n-        final double x2    = FastMath.scalb(v3.x, deltaExp);\n-        final double y2    = FastMath.scalb(v3.y, deltaExp);\n-        final double z2    = FastMath.scalb(v3.z, deltaExp);\n-\n-        // we reduce cancellation errors by preconditioning,\n-        // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n-        // v3 without loss of precision. See Kahan lecture\n-        // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n-        // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n-\n-        // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n-        final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n-        final double rho   = FastMath.rint(256 * ratio) / 256;\n-\n-        final double x3 = x1 - rho * x2;\n-        final double y3 = y1 - rho * y2;\n-        final double z3 = z1 - rho * z2;\n-\n-        // compute cross product from v3 and v2 instead of v1 and v2\n-        return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n-\n+        return new Vector3D(MathUtils.linearCombination(y, v3.z, -z, v3.y),\n+                            MathUtils.linearCombination(z, v3.x, -x, v3.z),\n+                            MathUtils.linearCombination(x, v3.y, -y, v3.x));\n     }\n \n     /** {@inheritDoc} */\n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/threed/Vector3DTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threed/Vector3DTest.java\n \n package org.apache.commons.math.geometry.euclidean.threed;\n \n-import org.apache.commons.math.geometry.euclidean.threed.Vector3D;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.random.Well1024a;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.exception.MathArithmeticException;\n-\n import org.junit.Assert;\n import org.junit.Test;\n \n         }\n     }\n \n+    @Test\n+    public void testAccurateDotProduct() {\n+        // the following two vectors are nearly but not exactly orthogonal\n+        // naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z\n+        // leads to a result of 0.0, instead of the correct -1.855129...\n+        Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,\n+                                   -5774608829631843.0 /  268435456.0,\n+                                   -7645843051051357.0 / 8589934592.0);\n+        Vector3D u2 = new Vector3D(-5712344449280879.0 /    2097152.0,\n+                                   -4550117129121957.0 /    2097152.0,\n+                                    8846951984510141.0 /     131072.0);\n+        double sNaive = u1.getX() * u2.getX() + u1.getY() * u2.getY() + u1.getZ() * u2.getZ();\n+        double sAccurate = u1.dotProduct(u2);\n+        Assert.assertEquals(0.0, sNaive, 1.0e-30);\n+        Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate, 1.0e-16);\n+    }\n+\n+    @Test\n+    public void testDotProduct() {\n+        // we compare accurate versus naive dot product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(553267312521321234l);\n+        for (int i = 0; i < 10000; ++i) {\n+            double ux = 10000 * random.nextDouble();\n+            double uy = 10000 * random.nextDouble();\n+            double uz = 10000 * random.nextDouble();\n+            double vx = 10000 * random.nextDouble();\n+            double vy = 10000 * random.nextDouble();\n+            double vz = 10000 * random.nextDouble();\n+            double sNaive = ux * vx + uy * vy + uz * vz;\n+            double sAccurate = new Vector3D(ux, uy, uz).dotProduct(new Vector3D(vx, vy, vz));\n+            Assert.assertEquals(sNaive, sAccurate, 2.5e-16 * sAccurate);\n+        }\n+    }\n+\n+    @Test\n+    public void testAccurateCrossProduct() {\n+        // the vectors u1 and u2 are nearly but not exactly anti-parallel\n+        // (7.31e-16 degrees from 180 degrees) naive cross product (i.e.\n+        // computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z\n+        // leads to a result of   [0.0009765, -0.0001220, -0.0039062],\n+        // instead of the correct [0.0006913, -0.0001254, -0.0007909]\n+        final Vector3D u1 = new Vector3D(-1321008684645961.0 /   268435456.0,\n+                                         -5774608829631843.0 /   268435456.0,\n+                                         -7645843051051357.0 /  8589934592.0);\n+        final Vector3D u2 = new Vector3D( 1796571811118507.0 /  2147483648.0,\n+                                          7853468008299307.0 /  2147483648.0,\n+                                          2599586637357461.0 / 17179869184.0);\n+        final Vector3D u3 = new Vector3D(12753243807587107.0 / 18446744073709551616.0, \n+                                         -2313766922703915.0 / 18446744073709551616.0, \n+                                          -227970081415313.0 /   288230376151711744.0);\n+        Vector3D cNaive = new Vector3D(u1.getY() * u2.getZ() - u1.getZ() * u2.getY(),\n+                                       u1.getZ() * u2.getX() - u1.getX() * u2.getZ(),\n+                                       u1.getX() * u2.getY() - u1.getY() * u2.getX());\n+        Vector3D cAccurate = u1.crossProduct(u2);\n+        Assert.assertTrue(u3.distance(cNaive) > 2.9 * u3.getNorm());\n+        Assert.assertEquals(0.0, u3.distance(cAccurate), 1.0e-30 * cAccurate.getNorm());\n+    }\n+\n+    @Test\n+    public void testCrossProduct() {\n+        // we compare accurate versus naive cross product implementations\n+        // on regular vectors (i.e. not extreme cases like in the previous test)\n+        Well1024a random = new Well1024a(885362227452043214l);\n+        for (int i = 0; i < 10000; ++i) {\n+            double ux = 10000 * random.nextDouble();\n+            double uy = 10000 * random.nextDouble();\n+            double uz = 10000 * random.nextDouble();\n+            double vx = 10000 * random.nextDouble();\n+            double vy = 10000 * random.nextDouble();\n+            double vz = 10000 * random.nextDouble();\n+            Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);\n+            Vector3D cAccurate = new Vector3D(ux, uy, uz).crossProduct(new Vector3D(vx, vy, vz));\n+            Assert.assertEquals(0.0, cAccurate.distance(cNaive), 6.0e-15 * cAccurate.getNorm());\n+        }\n+    }\n+\n     private void checkVector(Vector3D v, double x, double y, double z) {\n         Assert.assertEquals(x, v.getX(), 1.0e-12);\n         Assert.assertEquals(y, v.getY(), 1.0e-12);", "timestamp": 1312556576, "metainfo": ""}