{"sha": "704342d6280becc3be194a23dfda2e56c2a64aed", "log": "added JAMA-like LU-decomposition  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/LUDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * An interface to classes that implement a algorithm to calculate the \n+ * LU-decomposition of a real matrix.\n+ * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n+ * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n+ * to rearrange the rows of A before so that it can be decomposed. L is a lower\n+ * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n+ * <p>This interface is similar to the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * exception of the <code>det</code> method which has been renamed as {@link\n+ * #getDeterminant() getDeterminant}.</p>\n+ *   \n+ * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface LUDecomposition extends DecompositionSolver {\n+\n+    /**\n+     * Returns the matrix L of the decomposition. \n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix (or null if decomposed matrix is singular)\n+     */\n+    RealMatrix getL();\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an upper-triangular matrix</p>\n+     * @return the U matrix (or null if decomposed matrix is singular)\n+     */\n+    RealMatrix getU();\n+\n+    /**\n+     * Returns the P rows permutation matrix.\n+     * <p>P is a sparse matrix with exactly one element set to 1.0 in\n+     * each row and each column, all other elements being set to 0.0.</p>\n+     * <p>The positions of the 1 elements are given by the {@link #getPivot()\n+     * pivot permutation vector}.</p>\n+     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n+     * @see #getPivot()\n+     */\n+    RealMatrix getP();\n+\n+    /**\n+     * Returns the pivot permutation vector.\n+     * @return the pivot permutation vector\n+     * @see #getPermutation()\n+     */\n+    int[] getPivot();\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     * @see #getDeterminant()\n+     */\n+    boolean isNonSingular();\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     * @see #isNonSingular()\n+     */\n+    double getDeterminant();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Calculates the LUP-decomposition of a square matrix.\n+ * <p>The LUP-decomposition of a matrix A consists of three matrices\n+ * L, U and P that satisfy: A = LUP, L is lower triangular, and U is\n+ * upper triangular and P is a permutation matrix. All matrices are\n+ * m&times;m.</p>\n+ * <p>As shown by the presence of the P matrix, this decomposition is\n+ * implemented using partial pivoting.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LUDecompositionImpl implements LUDecomposition {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1606789599960880183L;\n+\n+    /** Bound to determine effective singularity in LU decomposition */\n+    private final double singularityThreshold;\n+\n+    /** Size of the matrix. */\n+    private final int m;\n+\n+    /** Entries of LU decomposition. */\n+    private final double lu[][];\n+\n+    /** Pivot permutation associated with LU decomposition */\n+    private final int[] pivot;\n+\n+    /** Parity of the permutation associated with the LU decomposition */\n+    private int parity;\n+\n+    /** Singularity indicator. */\n+    private boolean singular;\n+\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of P. */\n+    private RealMatrix cachedP;\n+\n+    /** Default bound to determine effective singularity in LU decomposition */\n+    private static final double DEFAULT_TOO_SMALL = 10E-12;\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * \n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public LUDecompositionImpl(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        this(matrix, DEFAULT_TOO_SMALL);\n+    }\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * \n+     * @param matrix The matrix to decompose.\n+     * @param singularityThreshold threshold (based on partial row norm)\n+     * under which a matrix is considered singular\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\n+        throws InvalidMatrixException {\n+        if (!matrix.isSquare()) {\n+            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n+        }\n+        this.singularityThreshold = singularityThreshold;\n+        m = matrix.getColumnDimension();\n+        lu = matrix.getData();\n+        pivot = new int[m];\n+        cachedL = null;\n+        cachedU = null;\n+        cachedP = null;\n+\n+        // perform decomposition\n+        luDecompose();\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getL() {\n+        if ((cachedL == null) && !singular) {\n+            final double[][] lData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                System.arraycopy(lu[i], 0, lData[i], 0, i);\n+                lData[i][i] = 1.0;\n+            }\n+            cachedL = new RealMatrixImpl(lData, false);\n+        }\n+        return cachedL;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getU() {\n+        if ((cachedU == null) && !singular) {\n+            final double[][] uData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                System.arraycopy(lu[i], i, uData[i], i, m - i);\n+            }\n+            cachedU = new RealMatrixImpl(uData, false);\n+        }\n+        return cachedU;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getP() {\n+        if ((cachedP == null) && !singular) {\n+            final double[][] pData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                pData[i][pivot[i]] = 1.0;\n+            }\n+            cachedP = new RealMatrixImpl(pData, false);\n+        }\n+        return cachedP;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int[] getPivot() {\n+        return pivot.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNonSingular() {\n+        return !singular;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant() {\n+        if (singular) {\n+            return 0;\n+        } else {\n+            double determinant = parity;\n+            for (int i = 0; i < m; i++) {\n+                determinant *= lu[i][i];\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] solve(double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        if (singular) {\n+            throw new InvalidMatrixException(\"Matrix is singular.\");\n+        }\n+\n+        final double[] bp = new double[m];\n+\n+        // Apply permutations to b\n+        for (int row = 0; row < m; row++) {\n+            bp[row] = b[pivot[row]];\n+        }\n+\n+        // Solve LY = b\n+        for (int col = 0; col < m; col++) {\n+            for (int i = col + 1; i < m; i++) {\n+                bp[i] -= bp[col] * lu[i][col];\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        for (int col = m - 1; col >= 0; col--) {\n+            bp[col] /= lu[col][col];\n+            for (int i = 0; i < col; i++) {\n+                bp[i] -= bp[col] * lu[i][col];\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+\n+            if (b.getDimension() != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+            if (singular) {\n+                throw new InvalidMatrixException(\"Matrix is singular.\");\n+            }\n+\n+            final double[] bp = new double[m];\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b.getEntry(pivot[row]);\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] /= lu[col][col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            return new RealVectorImpl(bp, false);\n+\n+        }\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X such that A &times; X = B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVectorImpl solve(RealVectorImpl b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix solve(RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (singular) {\n+            throw new InvalidMatrixException(\"Matrix is singular.\");\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+\n+        // Apply permutations to b\n+        final double[][] bp = new double[m][nColB];\n+        for (int row = 0; row < m; row++) {\n+            final double[] bpRow = bp[row];\n+            final int pRow = pivot[row];\n+            for (int col = 0; col < nColB; col++) {\n+                bpRow[col] = b.getEntry(pRow, col);\n+            }\n+        }\n+\n+        // Solve LY = b\n+        for (int col = 0; col < m; col++) {\n+            final double[] bpCol = bp[col];\n+            for (int i = col + 1; i < m; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = lu[i][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        for (int col = m - 1; col >= 0; col--) {\n+            final double[] bpCol = bp[col];\n+            final double luDiag = lu[col][col];\n+            for (int j = 0; j < nColB; j++) {\n+                bpCol[j] /= luDiag;\n+            }\n+            for (int i = 0; i < col; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = lu[i][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+    /**\n+     * Computes a new\n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algorithm</a>, with partial pivoting.</p>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.</p>\n+     */\n+    private void luDecompose() {\n+\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        parity = 1;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            double sum = 0;\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int max = col; // permutation row\n+            double largest = Double.NEGATIVE_INFINITY;\n+            for (int row = col; row < m; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+\n+                // maintain best permutation choice\n+                if (Math.abs(sum) > largest) {\n+                    largest = Math.abs(sum);\n+                    max = row;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (Math.abs(lu[max][col]) < singularityThreshold) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                for (int i = 0; i < m; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[max];\n+                pivot[max] = pivot[col];\n+                pivot[col] = temp;\n+                parity = -parity;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final double luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                lu[row][col] /= luDiag;\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class LUDecompositionImplTest extends TestCase {\n+    private double[][] testData = {\n+            { 1.0, 2.0, 3.0},\n+            { 2.0, 5.0, 3.0},\n+            { 1.0, 0.0, 8.0}\n+    };\n+    private double[][] testDataMinus = {\n+            { -1.0, -2.0, -3.0},\n+            { -2.0, -5.0, -3.0},\n+            { -1.0,  0.0, -8.0}\n+    };\n+    private double[][] luData = {\n+            { 2.0, 3.0, 3.0 },\n+            { 0.0, 5.0, 7.0 },\n+            { 6.0, 9.0, 8.0 }\n+    };\n+    \n+    // singular matrices\n+    private double[][] singular = {\n+            { 2.0, 3.0 },\n+            { 2.0, 3.0 }\n+    };\n+    private double[][] bigSingular = {\n+            { 1.0, 2.0,   3.0,    4.0 },\n+            { 2.0, 5.0,   3.0,    4.0 },\n+            { 7.0, 3.0, 256.0, 1930.0 },\n+            { 3.0, 7.0,   6.0,    8.0 }\n+    }; // 4th row = 1st + 2nd\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public LUDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LUDecompositionImplTest.class);\n+        suite.setName(\"LUDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        LUDecomposition LU = new LUDecompositionImpl(matrix);\n+        assertEquals(testData.length, LU.getL().getRowDimension());\n+        assertEquals(testData.length, LU.getL().getColumnDimension());\n+        assertEquals(testData.length, LU.getU().getRowDimension());\n+        assertEquals(testData.length, LU.getU().getColumnDimension());\n+        assertEquals(testData.length, LU.getP().getRowDimension());\n+        assertEquals(testData.length, LU.getP().getColumnDimension());\n+\n+    }\n+\n+    /** test non-square matrix */\n+    public void testNonSquare() {\n+        try {\n+            new LUDecompositionImpl(new RealMatrixImpl(new double[3][2], false));\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test PA = LU */\n+    public void testPAEqualLU() {\n+        RealMatrix matrix = new RealMatrixImpl(testData, false);\n+        LUDecomposition lu = new LUDecompositionImpl(matrix);\n+        RealMatrix l = lu.getL();\n+        RealMatrix u = lu.getU();\n+        RealMatrix p = lu.getP();\n+        double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(testDataMinus, false);\n+        lu = new LUDecompositionImpl(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealIdentityMatrix(17);\n+        lu = new LUDecompositionImpl(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(singular, false);\n+        lu = new LUDecompositionImpl(matrix);\n+        assertFalse(lu.isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+        matrix = new RealMatrixImpl(bigSingular, false);\n+        lu = new LUDecompositionImpl(matrix);\n+        assertFalse(lu.isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+    }\n+\n+    /** test that L is lower triangular with unit diagonal */\n+    public void testLLowerTriangular() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix l = new LUDecompositionImpl(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            assertEquals(l.getEntry(i, i), 1, entryTolerance);\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                assertEquals(l.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that U is upper triangular */\n+    public void testUUpperTriangular() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix u = new LUDecompositionImpl(matrix).getU();\n+        for (int i = 0; i < u.getRowDimension(); i++) {\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(u.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that P is a permutation matrix */\n+    public void testPPermutation() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix p   = new LUDecompositionImpl(matrix).getP();\n+\n+        RealMatrix ppT = p.multiply(p.transpose());\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());\n+        assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);\n+\n+        for (int i = 0; i < p.getRowDimension(); i++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int j = 0; j < p.getColumnDimension(); j++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+        for (int j = 0; j < p.getColumnDimension(); j++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int i = 0; i < p.getRowDimension(); i++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getRowDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+    }\n+\n+\n+    /** test singular */\n+    public void testSingular() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        assertTrue(lu.isNonSingular());\n+        lu = new LUDecompositionImpl(new RealMatrixImpl(singular, false));\n+        assertFalse(lu.isNonSingular());\n+        lu = new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false));\n+        assertFalse(lu.isNonSingular());\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            lu.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    public void testSolveSingularityErrors() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(singular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            lu.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1, 0 }, { 2, -5 }, { 3, 1 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 19, -71 }, { -6, 22 }, { -2, 9 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, lu.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(lu.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVectorImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         lu.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         lu.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues1() {\n+       LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        RealMatrix lRef = new RealMatrixImpl(new double[][] {\n+                { 1.0, 0.0, 0.0 },\n+                { 0.5, 1.0, 0.0 },\n+                { 0.5, 0.2, 1.0 }\n+        });\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+                { 2.0,  5.0, 3.0 },\n+                { 0.0, -2.5, 6.5 },\n+                { 0.0,  0.0, 0.2 }\n+        });\n+        RealMatrix pRef = new RealMatrixImpl(new double[][] {\n+                { 0.0, 1.0, 0.0 },\n+                { 0.0, 0.0, 1.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 1, 2, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues2() {\n+       LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(luData, false));\n+        RealMatrix lRef = new RealMatrixImpl(new double[][] {\n+                {    1.0,    0.0, 0.0 },\n+                {    0.0,    1.0, 0.0 },\n+                { 1.0 / 3.0, 0.0, 1.0 }\n+        });\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+                { 6.0, 9.0,    8.0    },\n+                { 0.0, 5.0,    7.0    },\n+                { 0.0, 0.0, 1.0 / 3.0 }\n+        });\n+        RealMatrix pRef = new RealMatrixImpl(new double[][] {\n+                { 0.0, 0.0, 1.0 },\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 2, 1, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+    /** test determinant */\n+    public void testDeterminant() {\n+        assertEquals(-1,\n+                     new LUDecompositionImpl(new RealMatrixImpl(testData, false)).getDeterminant(),\n+                     1.0e-15);\n+        assertEquals(-10,\n+                     new LUDecompositionImpl(new RealMatrixImpl(luData, false)).getDeterminant(),\n+                     1.0e-14);\n+        assertEquals(0,\n+                     new LUDecompositionImpl(new RealMatrixImpl(singular, false)).getDeterminant(),\n+                     1.0e-17);\n+        assertEquals(0,\n+                     new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)).getDeterminant(),\n+                     1.0e-17);\n+    }\n+\n+}", "timestamp": 1219277988, "metainfo": ""}