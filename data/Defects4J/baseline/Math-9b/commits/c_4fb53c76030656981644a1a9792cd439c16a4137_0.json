{"sha": "4fb53c76030656981644a1a9792cd439c16a4137", "log": "MATH-599 (part of the patch provided by D. Hendriks on JIRA, issue MATH-605). Improved Javadoc. Allow a bracketing interval to contain the root at its end-points.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n  * Base class for all bracketing <em>Secant</em>-based methods for root-finding\n  * (approximating a zero of a univariate real function).\n  *\n- * <p>Implementation of the {@link RegulaFalsiSolver <em>Regula Falsi</em>}, and\n+ * <p>Implementation of the {@link RegulaFalsiSolver <em>Regula Falsi</em>} and\n  * {@link IllinoisSolver <em>Illinois</em>} methods is based on the\n  * following article: M. Dowell and P. Jarratt,\n  * <em>A modified regula falsi method for computing the root of an\n  * BIT Numerical Mathematics, volume 12, number 4, pages 503-508, Springer,\n  * 1972.</p>\n  *\n- * <p>The  {@link SecantSolver <em>secant<em>} method is <em>not</emp> a\n- * bracketing method so it is not implemented here. It has a separate\n+ * <p>The {@link SecantSolver <em>Secant</em>} method is <em>not</em> a\n+ * bracketing method, so it is not implemented here. It has a separate\n  * implementation.</p>\n  *\n  * @since 3.0\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n      * @param f Function to solve.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n-     * @param allowedSolutions the kind of solutions that the root-finding algorithm may\n+     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n-     * @return a value where the function is zero.\n+     * @return A value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      * if the arguments do not satisfy the requirements specified by the solver.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n-     * @param allowedSolutions the kind of solutions that the root-finding algorithm may\n+     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n-     * @return a value where the function is zero.\n+     * @return A value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      * if the arguments do not satisfy the requirements specified by the solver.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n \n         // Keep finding better approximations.\n         while (true) {\n-\n             // Calculate the next approximation.\n             final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n             final double fx = computeObjectiveValue(x);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n     }\n \n     /**\n-     * Check whether the function takes opposite signs at the endpoints.\n+     * Check whether the interval bounds bracket a root. That is, if the\n+     * values at the endpoints are not equal to zero, then the function takes\n+     * opposite signs at the endpoints.\n      *\n      * @param function Function.\n      * @param lower Lower endpoint.\n         }\n         final double fLo = function.value(lower);\n         final double fHi = function.value(upper);\n-        return (fLo > 0 && fHi < 0) || (fLo < 0 && fHi > 0);\n+        return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);\n     }\n \n     /**\n     }\n \n     /**\n-     * Check that the endpoints specify an interval and the function takes\n-     * opposite signs at the endpoints.\n+     * Check that the endpoints specify an interval and the end points\n+     * bracket a root.\n      *\n      * @param function Function.\n      * @param lower Lower endpoint.", "timestamp": 1310387534, "metainfo": ""}