{"sha": "aefdc2a03f56e190e9e667b617bcb46e97f2026d", "log": "Document why OK to suppress unchecked warning Move tag as close as possible to site of warning  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n+++ b/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n      * @param second second parent (p2)\n      * @return pair of two children (c1,c2)\n      */\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\") // OK because of instanceof checks\n     public ChromosomePair crossover(Chromosome first, Chromosome second) {\n-        if (! (first instanceof AbstractListChromosome && second instanceof AbstractListChromosome)) {\n+        if (! (first instanceof AbstractListChromosome<?> && second instanceof AbstractListChromosome<?>)) {\n             throw new IllegalArgumentException(\"One point crossover works on FixedLengthChromosomes only.\");\n         }\n         return crossover((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n      * @param length of the array\n      * @return a new array\n      */\n-    @SuppressWarnings(\"unchecked\")\n     protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field,\n                                                                 final int length) {\n+        @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n         T[] array = (T[]) Array.newInstance(field.getZero().getClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n-    @SuppressWarnings(\"unchecked\")\n     @Override\n     public boolean equals(final Object object) {\n         if (object == this ) {\n             return true;\n         }\n-        if (object instanceof FieldMatrix == false) {\n+        if (object instanceof FieldMatrix<?> == false) {\n             return false;\n         }\n-        FieldMatrix<T> m = (FieldMatrix<T>) object;\n+        FieldMatrix<?> m = (FieldMatrix<?>) object;\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n      * @param length size of the array to build\n      * @return a new array\n      */\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\") // field is of type T\n     private T[] buildArray(final int length) {\n         return (T[]) Array.newInstance(field.getZero().getClass(), length);\n     }\n      *         not equal to this Vector3D instance\n      *\n      */\n-    @SuppressWarnings(\"unchecked\")\n     @Override\n     public boolean equals(Object other) {\n \n       }\n \n       try {\n-\n+          @SuppressWarnings(\"unchecked\") // May fail, but we ignore ClassCastException\n           FieldVector<T> rhs = (FieldVector<T>) other;\n           if (data.length != rhs.getDimension()) {\n               return false;\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n         }\n \n         /** {@inheritDoc} */\n-        @SuppressWarnings(\"unchecked\")\n         public T[] solve(T[] b)\n             throws IllegalArgumentException, InvalidMatrixException {\n \n                 throw new SingularMatrixException();\n             }\n \n+            @SuppressWarnings(\"unchecked\") // field is of type T\n             final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n \n             // Apply permutations to b\n         }\n \n         /** {@inheritDoc} */\n-        @SuppressWarnings(\"unchecked\")\n         public FieldVector<T> solve(FieldVector<T> b)\n             throws IllegalArgumentException, InvalidMatrixException {\n             try {\n                     throw new SingularMatrixException();\n                 }\n \n+                @SuppressWarnings(\"unchecked\") // field is of type T\n                 final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n \n                 // Apply permutations to b\n         }\n \n         /** {@inheritDoc} */\n-        @SuppressWarnings(\"unchecked\")\n         public FieldMatrix<T> solve(FieldMatrix<T> b)\n             throws IllegalArgumentException, InvalidMatrixException {\n \n             final int nColB = b.getColumnDimension();\n \n             // Apply permutations to b\n+            @SuppressWarnings(\"unchecked\") // field is of type T\n             final T[][] bp = (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { m, nColB });\n             for (int row = 0; row < m; row++) {\n                 final T[] bpRow = bp[row];\n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n      * @throws IllegalArgumentException if dimension is not positive\n      * @since 2.0\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public static <T extends FieldElement<T>> FieldMatrix<T>\n         createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n         final T zero = field.getZero();\n         final T one  = field.getOne();\n+        @SuppressWarnings(\"unchecked\") // zero is type T\n         final T[][] d = (T[][]) Array.newInstance(zero.getClass(), new int[] { dimension, dimension });\n         for (int row = 0; row < dimension; row++) {\n             final T[] dRow = d[row];", "timestamp": 1264471646, "metainfo": ""}