{"sha": "3f3ad389773e797d10fb52023def5f271ba92153", "log": "Changed Mean.evaluate() to use a two-pass algorithm, improving accuracy by exploiting the the fact that this method has access to the full array of data values.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n \n /**\n- * Returns the arithmetic mean of the available values. Uses the definitional \n- * formula:\n+ * <p>Computes the arithmetic mean of a set of values. Uses the definitional \n+ * formula:</p>\n  * <p>\n  * mean = sum(x_i) / n\n- * <p>\n- * where <code>n</code> is the number of observations.\n- * <p>\n- * The value of the statistic is computed using the following recursive\n- * updating algorithm:\n- * <p>\n+ * </p>\n+ * <p>where <code>n</code> is the number of observations.\n+ * </p>\n+ * <p>When {@link #increment(double)} is used to add data incrementally from a\n+ * stream of (unstored) values, the value of the statistic that \n+ * {@link #getResult()} returns is computed using the following recursive\n+ * updating algorithm: </p>\n  * <ol>\n  * <li>Initialize <code>m = </code> the first value</li>\n  * <li>For each additional value, update using <br>\n  *   <code>m = m + (new value - m) / (number of observations)</code></li>\n  * </ol>\n+ * <p> If {@link #evaluate(double[])} is used to compute the mean of an array\n+ * of stored values, a two-pass, corrected algorithm is used, starting with\n+ * the definitional formula computed using the array of stored values and then\n+ * correcting this by adding the mean deviation of the data values from the\n+ * arithmetic mean. See, e.g. \"Comparison of Several Algorithms for Computing\n+ * Sample Means and Variances,\" Robert F. Ling, Journal of the American\n+ * Statistical Association, Vol. 69, No. 348 (Dec., 1974), pp. 859-866. </p>\n  * <p>\n  *  Returns <code>Double.NaN</code> if the dataset is empty.\n- * <p>\n+ * </p>\n  * <strong>Note that this implementation is not synchronized.</strong> If \n  * multiple threads access an instance of this class concurrently, and at least\n  * one of the threads invokes the <code>increment()</code> or \n     public double evaluate(final double[] values,final int begin, final int length) {\n         if (test(values, begin, length)) {\n             Sum sum = new Sum();\n-            return sum.evaluate(values, begin, length) / ((double) length);\n+            double sampleSize = (double) length;\n+            \n+            // Compute initial estimate using definitional formula\n+            double xbar = sum.evaluate(values, begin, length) / sampleSize;\n+            \n+            // Compute correction factor in second pass\n+            double correction = 0;\n+            for (int i = begin; i < begin + length; i++) {\n+                correction += (values[i] - xbar);\n+            }\n+            return xbar + (correction/sampleSize);\n         }\n         return Double.NaN;\n     }\n--- a/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n+++ b/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n     }\n \n     /**\n-     * Test StorelessDescriptiveStatistics\n+     * Test SummaryStatistics - implementations that do not store the data\n+     * and use single pass algorithms to compute statistics\n     */\n-    public void testUnivariateImpl() throws Exception {\n+    public void testSummaryStatistics() throws Exception {\n         SummaryStatistics u = SummaryStatistics.newInstance(SummaryStatisticsImpl.class);\n         loadStats(\"data/PiDigits.txt\", u);\n-        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), .0000000000001);\n-        assertEquals(\"PiDigits: mean\", mean, u.getMean(), .0000000000001);  \n+        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-13);\n+        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-13);  \n \n         loadStats(\"data/Mavro.txt\", u);\n-        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), .00000000000001);\n-        assertEquals(\"Mavro: mean\", mean, u.getMean(), .00000000000001);\n+        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n         \n-        //loadStats(\"data/Michelso.txt\");\n-        //assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), .00000000000001);\n-        //assertEquals(\"Michelso: mean\", mean, u.getMean(), .00000000000001);   \n+        loadStats(\"data/Michelso.txt\", u);\n+        assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-13);\n+        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-13);   \n                                         \n         loadStats(\"data/NumAcc1.txt\", u);\n-        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), .00000000000001);\n-        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), .00000000000001);\n+        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n         \n-        //loadStats(\"data/NumAcc2.txt\");\n-        //assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), .000000001);\n-        //assertEquals(\"NumAcc2: mean\", mean, u.getMean(), .00000000000001);\n+        loadStats(\"data/NumAcc2.txt\", u);\n+        assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n     }\n \n     /**\n-     * Test StorelessDescriptiveStatistics\n+     * Test DescriptiveStatistics - implementations that store full array of\n+     * values and execute multi-pass algorithms\n      */\n-    public void testStoredUnivariateImpl() throws Exception {\n+    public void testDescriptiveStatistics() throws Exception {\n \n         DescriptiveStatistics u = DescriptiveStatistics.newInstance();\n         \n         loadStats(\"data/PiDigits.txt\", u);\n-        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), .0000000000001);\n-        assertEquals(\"PiDigits: mean\", mean, u.getMean(), .0000000000001);\n+        assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-14);\n         \n         loadStats(\"data/Mavro.txt\", u);\n-        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), .00000000000001);\n-        assertEquals(\"Mavro: mean\", mean, u.getMean(), .00000000000001);        \n+        assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);        \n         \n-        //loadStats(\"data/Michelso.txt\");\n-        //assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), .00000000000001);\n-        //assertEquals(\"Michelso: mean\", mean, u.getMean(), .00000000000001);   \n+        loadStats(\"data/Michelso.txt\", u);\n+        assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-14);   \n \n         loadStats(\"data/NumAcc1.txt\", u);\n-        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), .00000000000001);\n-        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), .00000000000001);\n+        assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n         \n-        //loadStats(\"data/NumAcc2.txt\");\n-        //assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), .000000001);\n-        //assertEquals(\"NumAcc2: mean\", mean, u.getMean(), .00000000000001);\n+        loadStats(\"data/NumAcc2.txt\", u);\n+        assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n+        assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n     }\n \n     /**", "timestamp": 1197082793, "metainfo": ""}