{"sha": "6a978ea29f680a87dfc380c760adf2e17b2e7c9c", "log": "-Changed UnivariateRealFunction.solve() to throw FunctionEvaluationException. -Changed UnivariateRealSolver.solve() to throw more specific exceptions:   ConvergenceException if max iterations is exceeded   IllegalArgumentException if endpoints do not (appear to) bracket a root   FunctionEvaluationException if an error occurs evaluating the function -Changed UnivariateRealSolver setters to throw IllegalArgumentException  instead of MathException when input property values are out of range. -Changed AbstractContinuousDistribution.inverseCumulativeProbability to handle  corner cases where solution equals domain lower or upper bound. -Improved javadoc. -Improved test coverage.   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n  */\n package org.apache.commons.math.analysis;\n \n-import java.io.Serializable;\n-\n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.ConvergenceException;\n \n /**\n- * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">bisection algorithm</a>\n- *  for finding zeros of univariate real functions.  This algorithm will find only one zero in the given interval.\n+ * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">\n+ * bisection algorithm</a> for finding zeros of univariate real functions. \n+ * <p>\n  * The function should be continuous but not necessarily smooth.\n- * @version $Revision: 1.17 $ $Date: 2004/06/23 16:26:14 $\n+ * \n+ * @version $Revision: 1.18 $ $Date: 2004/07/17 21:19:39 $\n  */\n-public class BisectionSolver extends UnivariateRealSolverImpl implements Serializable {\n+public class BisectionSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n     static final long serialVersionUID = 7137520585963699578L;\n     \n     /**\n      * Construct a solver for the given function.\n+     * \n      * @param f function to solve.\n      */\n     public BisectionSolver(UnivariateRealFunction f) {\n \n     /**\n      * Find a zero in the given interval.\n+     * \n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @param initial the start value to use (ignored).\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     *  the function\n+     * @throws IllegalArgumentException if min is not less than max\n      */\n     public double solve(double min, double max, double initial)\n-        throws MathException {\n-            \n+        throws ConvergenceException, FunctionEvaluationException {\n+          \n         return solve(min, max);\n     }\n     \n     /**\n      * Find a zero root in the given interval.\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException if the maximum iteration count is exceeded.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min is not less than max\n      */\n-    public double solve(double min, double max) throws MathException {\n+    public double solve(double min, double max) throws ConvergenceException,\n+        FunctionEvaluationException {\n+        \n         clearResult();\n-\n+        verifyInterval(min,max);\n         double m;\n         double fm;\n         double fmin;\n         int i = 0;\n         while (i < maximalIterationCount) {\n             m = UnivariateRealSolverUtils.midpoint(min, max);\n-            fmin = f.value(min);\n-            fm = f.value(m);\n+           fmin = f.value(min);\n+           fm = f.value(m);\n \n             if (fm * fmin > 0.0) {\n                 // max and m bracket the root.\n             ++i;\n         }\n         \n-        throw new MathException(\"Maximum number of iterations exceeded\");\n+        throw new ConvergenceException\n+            (\"Maximum number of iterations exceeded: \"  + maximalIterationCount);\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n- * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">Brent algorithm</a>\n- * for  finding zeros of real univariate\n- * functions. This algorithm will find only one zero in the given interval. \n+ * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n+ * Brent algorithm</a> for  finding zeros of real univariate functions.\n+ * <p>\n  * The function should be continuous but not necessarily smooth.\n  *  \n- * @version $Revision: 1.16 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.17 $ $Date: 2004/07/17 21:19:39 $\n  */\n-public class BrentSolver extends UnivariateRealSolverImpl implements Serializable {\n+public class BrentSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n     static final long serialVersionUID = 3350616277306882875L;\n \n     /**\n      * Construct a solver for the given function.\n+     * \n      * @param f function to solve.\n      */\n     public BrentSolver(UnivariateRealFunction f) {\n \n     /**\n      * Find a zero in the given interval.\n+     * <p>\n+     * Throws <code>ConvergenceException</code> if the values of the function\n+     * at the endpoints of the interval have the same sign.\n+     * \n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @param initial the start value to use (ignored).\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     *  the function\n+     * @throws IllegalArgumentException if initial is not between min and max\n      */\n     public double solve(double min, double max, double initial)\n-        throws MathException {\n+        throws ConvergenceException, FunctionEvaluationException {\n             \n         return solve(min, max);\n     }\n     \n     /**\n      * Find a zero in the given interval.\n+     * <p>\n+     * Requires that the values of the function at the endpoints have opposite\n+     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n+     * the case.\n+     * \n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MathException {\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+        \n         clearResult();\n+        verifyBracketing(min, max, f);\n+        \n         // Index 0 is the old approximation for the root.\n         // Index 1 is the last calculated approximation  for the root.\n         // Index 2 is a bracket for the root with respect to x1.\n         double x0 = min;\n         double x1 = max;\n-        double y0 = f.value(x0);\n-        double y1 = f.value(x1);\n-        if ((y0 > 0) == (y1 > 0)) {\n-            throw new MathException(\"Interval doesn't bracket a zero.\");\n-        }\n+        double y0;\n+        double y1;\n+        y0 = f.value(x0);\n+        y1 = f.value(x1);\n+   \n         double x2 = x0;\n         double y2 = y0;\n         double delta = x1 - x0;\n             }\n             i++;\n         }\n-        throw new MathException(\"Maximum number of iterations exceeded.\");\n+        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n \n package org.apache.commons.math.analysis;\n \n-import java.io.Serializable;\n-\n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException; \n \n /**\n  * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n- * Newton's Method</a> for finding zeros of real univariate functions. This\n- * algorithm will find only one zero in the given interval.  The function should\n- * be continuous but not necessarily smooth.\n+ * Newton's Method</a> for finding zeros of real univariate functions. \n+ * <p> \n+ * The function should be continuous but not necessarily smooth.\n  *\n- * @version $Revision: 1.5 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.6 $ $Date: 2004/07/17 21:19:39 $\n  */\n-public class NewtonSolver extends UnivariateRealSolverImpl implements Serializable {\n+public class NewtonSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n     static final long serialVersionUID = 2606474895443431607L;\n \n     /**\n      * Find a zero near the midpoint of <code>min</code> and <code>max</code>.\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException if the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function or derivative\n+     * @throws IllegalArgumentException if min is not less than max\n      */\n-    public double solve(double min, double max) throws MathException {\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException  {\n         return solve(min, max, UnivariateRealSolverUtils.midpoint(min, max));\n     }\n \n     /**\n      * Find a zero near the value <code>startValue</code>.\n+     * \n      * @param min the lower bound for the interval (ignored).\n      * @param max the upper bound for the interval (ignored).\n      * @param startValue the start value to use.\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+    * @throws ConvergenceException if the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function or derivative\n+     * @throws IllegalArgumentException if startValue is not between min and max\n      */\n     public double solve(double min, double max, double startValue)\n-        throws MathException {\n+        throws ConvergenceException, FunctionEvaluationException {\n         \n         clearResult();\n+        verifySequence(min, startValue, max);\n \n         double x0 = startValue;\n         double x1;\n         int i = 0;\n         while (i < maximalIterationCount) {\n             x1 = x0 - (f.value(x0) / derivative.value(x0));\n-\n             if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n                 \n                 setResult(x1, i);\n             ++i;\n         }\n         \n-        throw new MathException(\"Maximum number of iterations exceeded\");\n+        throw new ConvergenceException\n+            (\"Maximum number of iterations exceeded \" + i);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n  * Represents a polynomial spline function.\n  * <li> Let <code>j</code> be the index of the largest knot point that is less than or equal to <code>x</code>. \n  *  The value returned is <br> <code>polynomials[j](x - knot[j])</code></li></ol>\n  *\n- * @version $Revision: 1.6 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.7 $ $Date: 2004/07/17 21:19:39 $\n  */\n public class PolynomialSplineFunction implements UnivariateRealFunction, Serializable {\n    \n      * \n      * @param v the point for which the function value should be computed\n      * @return the value\n-     * @throws MathException if the function couldn't be computed due to\n-     *  missing additional data or other environmental problems.\n-     * @see UnivariateRealFunction#value(double)\n+     * @throws FunctionEvaluationException if v is outside of the domain of\n+     * of the spline function (less than the smallest knot point or greater\n+     * than the largest knot point)\n      */\n-    public double value(double v) throws MathException {\n+    public double value(double v) throws FunctionEvaluationException {\n         if (v < knots[0] || v >= knots[n]) {\n-            throw new IllegalArgumentException(\"Argument outside domain\");\n+            throw new FunctionEvaluationException(v,\"Argument outside domain\");\n         }\n         int i = Arrays.binarySearch(knots, v);\n         if (i < 0) {\n--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n \n /**\n  * Implements a modified version of the \n  * <a href=\"http://mathworld.wolfram.com/SecantMethod.html\">secant method</a>\n  * for approximating a zero of a real univariate function.  \n  * <p>\n- * The algorithm is modified to maintain bracketing of a root by subsequent approximations. \n- * Because of forced bracketing, convergence may be slower than the unrestricted secant algorithm. \n- * However, this implementation  should in general outperform the \n- * <a href=\"http://mathworld.wolfram.com/MethodofFalsePosition.html\">regula falsi method.</a>\n+ * The algorithm is modified to maintain bracketing of a root by successive\n+ * approximations. Because of forced bracketing, convergence may be slower than\n+ * the unrestricted secant algorithm. However, this implementation should in\n+ * general outperform the \n+ * <a href=\"http://mathworld.wolfram.com/MethodofFalsePosition.html\">\n+ * regula falsi method.</a>\n  * <p>\n- * The function is supposed to be continuous but not necessarily smooth.\n+ * The function is assumed to be continuous but not necessarily smooth.\n  *  \n- * @version $Revision: 1.16 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.17 $ $Date: 2004/07/17 21:19:39 $\n  */\n public class SecantSolver extends UnivariateRealSolverImpl implements Serializable {\n     \n \n     /**\n      * Find a zero in the given interval.\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @param initial the start value to use (ignored).\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use (ignored)\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n      */\n     public double solve(double min, double max, double initial)\n-        throws MathException {\n+        throws ConvergenceException, FunctionEvaluationException {\n             \n         return solve(min, max);\n     }\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n+     * @throws ConvergenceException  if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MathException {\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+        \n         clearResult();\n+        verifyBracketing(min, max, f);\n+        \n         // Index 0 is the old approximation for the root.\n         // Index 1 is the last calculated approximation  for the root.\n         // Index 2 is a bracket for the root with respect to x0.\n         double x1 = max;\n         double y0 = f.value(x0);\n         double y1 = f.value(x1);\n-        if ((y0 > 0) == (y1 > 0)) {\n-            throw new MathException(\"Interval doesn't bracket a zero.\");\n-        }\n         double x2 = x0;\n         double y2 = y0;\n         double oldDelta = x2 - x1;\n             oldDelta = x2 - x1;\n             i++;\n         }\n-        throw new MathException(\"Maximal iteration number exceeded\");\n+        throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n  * An interface representing a univariate real function.\n  *  \n- * @version $Revision: 1.13 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.14 $ $Date: 2004/07/17 21:19:39 $\n  */\n public interface UnivariateRealFunction {\n     /**\n      * Compute the value for the function.\n      * @param x the point for which the function value should be computed\n      * @return the value\n-     * @throws MathException if the function couldn't be computed due to\n-     *  missing additional data or other environmental problems.\n+     * @throws FunctionEvaluationException if the function evaluation fails\n      */\n-    public double value(double x) throws MathException;\n+    public double value(double x) throws FunctionEvaluationException;\n \n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n \n /**\n  * Interface for (univariate real) rootfinding algorithms.\n  * <p>\n  * Implementations will search for only one zero in the given interval.\n  *  \n- * @version $Revision: 1.13 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.14 $ $Date: 2004/07/17 21:19:39 $\n  */\n public interface UnivariateRealSolver {\n \n      * the \"reasonable value\" varies widely for different solvers.  Users are\n      * advised to use the default value supplied by the solver.\n      * <p>\n-     * An exception will be thrown if the number is exceeded.\n+     * A <code>ConvergenceException</code> will be thrown if this number\n+     * is exceeded.\n      *  \n      * @param count maximum number of iterations\n      */\n-    public void setMaximalIterationCount(int count);\n+    void setMaximalIterationCount(int count);\n \n     /**\n      * Get the upper limit for the number of iterations.\n      * \n      * @return the actual upper limit\n      */\n-    public int getMaximalIterationCount();\n+    int getMaximalIterationCount();\n \n     /**\n      * Reset the upper limit for the number of iterations to the default.\n      * \n      * @see #setMaximalIterationCount(int)\n      */\n-    public void resetMaximalIterationCount();\n+    void resetMaximalIterationCount();\n \n     /**\n      * Set the absolute accuracy.\n      * accuracy, but clients should not rely on this.\n      *  \n      * @param accuracy the accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or\n-     *         is otherwise deemed unreasonable. \n-     */\n-    public void setAbsoluteAccuracy(double accuracy) throws MathException;\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    void setAbsoluteAccuracy(double accuracy);\n \n     /**\n      * Get the actual absolute accuracy.\n      * \n      * @return the accuracy\n      */\n-    public double getAbsoluteAccuracy();\n+    double getAbsoluteAccuracy();\n \n     /**\n      * Reset the absolute accuracy to the default.\n      * <p>\n      * The default value is provided by the solver implementation.\n      */\n-    public void resetAbsoluteAccuracy();\n+    void resetAbsoluteAccuracy();\n \n     /**\n      * Set the relative accuracy.\n      * like 1E-1000.\n      * \n      * @param accuracy the relative accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or\n-     *         is otherwise deemed unreasonable. \n-     */\n-    public void setRelativeAccuracy(double accuracy) throws MathException;\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the solver or is otherwise deemed unreasonable. \n+     */\n+    void setRelativeAccuracy(double accuracy);\n \n     /**\n      * Get the actual relative accuracy.\n      * @return the accuracy\n      */\n-    public double getRelativeAccuracy();\n+    double getRelativeAccuracy();\n \n     /**\n      * Reset the relative accuracy to the default.\n      * The default value is provided by the solver implementation.\n      */\n-    public void resetRelativeAccuracy();\n+    void resetRelativeAccuracy();\n \n     /**\n      * Set the function value accuracy.\n      * general.\n      * \n      * @param accuracy the accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or\n-     *         is otherwise deemed unreasonable. \n-     */\n-    public void setFunctionValueAccuracy(double accuracy) throws MathException;\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    void setFunctionValueAccuracy(double accuracy);\n \n     /**\n      * Get the actual function value accuracy.\n      * @return the accuracy\n      */\n-    public double getFunctionValueAccuracy();\n+    double getFunctionValueAccuracy();\n \n     /**\n      * Reset the actual function accuracy to the default.\n      * The default value is provided by the solver implementation.\n      */\n-    public void resetFunctionValueAccuracy();\n+    void resetFunctionValueAccuracy();\n \n     /**\n      * Solve for a zero root in the given interval.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return a value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n-     */\n-    public double solve(double min, double max) throws MathException;\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the solver\n+     */\n+    double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException;\n \n     /**\n      * Solve for a zero in the given interval, start at startValue.\n      * @param max the upper bound for the interval.\n      * @param startValue the start value to use\n      * @return a value where the function is zero\n-     * @throws MathException if the iteration count was exceeded or the\n-     *  solver detects convergence problems otherwise.\n-     */\n-    public double solve(double min, double max, double startValue)\n-        throws MathException;\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the solver\n+     */\n+    double solve(double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException;\n \n     /**\n      * Get the result of the last run of the solver.\n+     * \n      * @return the last result.\n-     * @throws MathException if there is no result available, either\n+     * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n-    public double getResult() throws MathException;\n+    double getResult();\n \n     /**\n      * Get the number of iterations in the last run of the solver.\n      * problem.\n      * \n      * @return the last iteration count.\n-     * @throws MathException if there is no result available, either\n+     * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n-    public int getIterationCount() throws MathException;\n+    int getIterationCount();\n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n  * solvers.\n  *  \n- * @version $Revision: 1.14 $ $Date: 2004/06/23 16:26:14 $\n+ * @version $Revision: 1.15 $ $Date: 2004/07/17 21:19:39 $\n  */\n-public abstract class UnivariateRealSolverImpl implements UnivariateRealSolver, Serializable {\n+public abstract class UnivariateRealSolverImpl implements UnivariateRealSolver,\n+    Serializable {\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = 1112491292565386596L;\n \n     /**\n      * Construct a solver with given iteration count and accuracy.\n+     * \n      * @param f the function to solve.\n-     * @param defaultAbsoluteAccuracy maximum absolue error.\n-     * @param defaultMaximalIterationCount maximum number of iterations.\n-     * @throws IllegalArgumentException if function is null.\n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n      */\n     protected UnivariateRealSolverImpl(\n         UnivariateRealFunction f,\n \n     /**\n      * Access the last computed root.\n-     * @return the last computed root.\n-     * @throws MathException if no root has been computed.\n-     */\n-    public double getResult() throws MathException {\n+     * \n+     * @return the last computed root\n+     * @throws IllegalStateException if no root has been computed\n+     */\n+    public double getResult() {\n         if (resultComputed) {\n             return result;\n         } else {\n-            throw new MathException(\"No result available\");\n+            throw new IllegalStateException(\"No result available\");\n         }\n     }\n \n     /**\n      * Access the last iteration count.\n-     * @return the last iteration count.\n-     * @throws MathException if no root has been computed.\n+     * \n+     * @return the last iteration count\n+     * @throws IllegalStateException if no root has been computed\n      *  \n      */\n-    public int getIterationCount() throws MathException {\n+    public int getIterationCount() {\n         if (resultComputed) {\n             return iterationCount;\n         } else {\n-            throw new MathException(\"No result available\");\n+            throw new IllegalStateException(\"No result available\");\n         }\n     }\n \n     /**\n      * Convenience function for implementations.\n+     * \n      * @param result the result to set\n      * @param iterationCount the iteration count to set\n      */\n      * Set the absolute accuracy.\n      * \n      * @param accuracy the accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or\n-     *         is otherwise deemed unreasonable. \n-     */\n-    public void setAbsoluteAccuracy(double accuracy)\n-        throws MathException {\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the solver or is otherwise deemed unreasonable. \n+     */\n+    public void setAbsoluteAccuracy(double accuracy) {\n         absoluteAccuracy = accuracy;\n     }\n \n      * Set the relative accuracy.\n      * \n      * @param accuracy the relative accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or\n-     *         is otherwise deemed unreasonable. \n-     */\n-    public void setRelativeAccuracy(double accuracy) throws MathException {\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the solver or is otherwise deemed unreasonable. \n+     */\n+    public void setRelativeAccuracy(double accuracy) {\n         relativeAccuracy = accuracy;\n     }\n \n      * Set the function value accuracy.\n      * \n      * @param accuracy the accuracy.\n-     * @throws MathException if the accuracy can't be achieved by the solver or\n-     *         is otherwise deemed unreasonable. \n-     */\n-    public void setFunctionValueAccuracy(double accuracy)\n-        throws MathException {\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    public void setFunctionValueAccuracy(double accuracy) {\n         functionValueAccuracy = accuracy;\n     }\n \n     public void resetFunctionValueAccuracy() {\n         functionValueAccuracy = defaultFunctionValueAccuracy;\n     }\n+    \n+    \n+    /**\n+     * Returns true iff the function takes opposite signs at the endpoints.\n+     * \n+     * @param lower  the lower endpoint \n+     * @param upper  the upper endpoint\n+     * @param f the function\n+     * @return true if f(lower) * f(upper) < 0\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function at the endpoints\n+     */\n+    protected boolean isBracketing(double lower, double upper, \n+            UnivariateRealFunction f) throws FunctionEvaluationException {\n+        return  (f.value(lower) * f.value(upper) < 0);\n+    }\n+    \n+    /**\n+     * Returns true if the arguments form a (strictly) increasing sequence\n+     * \n+     * @param start  first number\n+     * @param mid   second number\n+     * @param end  third number\n+     * @return true if the arguments form an increasing sequence\n+     */\n+    protected boolean isSequence(double start, double mid, double end) {\n+        return (start < mid) && (mid < end);\n+    }\n+    \n+    /**\n+     * Verifies that the endpoints specify an interval, \n+     * throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException\n+     */\n+    protected void verifyInterval(double lower, double upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"Endpoints do not specify an interval: [\" + lower + \n+                        \",\" + upper + \"]\");\n+        }       \n+    }\n+    \n+    /**\n+     * Verifies that <code>lower < initial < upper</code>\n+     * throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param initial initial value\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException\n+     */\n+    protected void verifySequence(double lower, double initial, double upper) {\n+        if (!isSequence(lower, initial, upper)) {\n+            throw new IllegalArgumentException\n+                (\"Invalid interval, initial value parameters:  lower=\" + \n+                   lower + \" initial=\" + initial + \" upper=\" + upper);\n+        }       \n+    }\n+    \n+    /**\n+     * Verifies that the endpoints specify an interval and the function takes\n+     * opposite signs at the enpoints, throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param upper upper endpoint\n+     * @param f function\n+     * @throws IllegalArgumentException\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function at the endpoints\n+     */\n+    protected void verifyBracketing(double lower, double upper, \n+            UnivariateRealFunction f) throws FunctionEvaluationException {\n+        \n+        verifyInterval(lower, upper);\n+        if (!isBracketing(lower, upper, f)) {\n+            throw new IllegalArgumentException\n+            (\"Function values at endpoints do not have different signs.\" +\n+                    \"  Endpoints: [\" + lower + \",\" + upper + \"]\" + \n+                    \"  Values: [\" + f.value(lower) + \",\" + f.value(upper) + \"]\");       \n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.ConvergenceException;\n \n /**\n  * Utility routines for {@link UnivariateRealSolver} objects.\n- * @version $Revision: 1.9 $ $Date: 2004/06/23 16:26:14 $\n+ * \n+ * @version $Revision: 1.10 $ $Date: 2004/07/17 21:19:39 $\n  */\n public class UnivariateRealSolverUtils {\n     /**\n     private UnivariateRealSolverUtils() {\n         super();\n     }\n-\n-    /**\n-     * Method to solve for zeros of real univariate functions.  A\n-     * default solver is created and used for solving. \n+    \n+    /** Cached solver factory */\n+    private static UnivariateRealSolverFactory factory = null;\n+\n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n      * @param f the function.\n      * @param x0 the lower bound for the interval.\n      * @param x1 the upper bound for the interval.\n      * @return a value where the function is zero.\n-     * @throws MathException if the iteration count was exceeded or the\n-     *         solver detects convergence problems otherwise.\n+     * @throws ConvergenceException if the iteration count was exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function\n+     * @throws IllegalArgumentException if f is null or the endpoints do not\n+     * specify a valid interval\n      */\n     public static double solve(UnivariateRealFunction f, double x0, double x1)\n-        throws MathException\n-    {\n-        if(f == null){\n-            throw new IllegalArgumentException(\"f can not be null.\");    \n-        }\n-        \n-        return UnivariateRealSolverFactory.newInstance().newDefaultSolver(f)\n-            .solve(x0, x1);\n-    }\n-\n-    /**\n-     * Convience method to solve for zeros of real univariate functions.  A\n-     * default solver is created and used for solving. \n-     * @param f the function.\n-     * @param x0 the lower bound for the interval.\n-     * @param x1 the upper bound for the interval.\n-     * @param absoluteAccuracy the accuracy to be used by the solver.\n-     * @return a value where the function is zero.\n-     * @throws MathException if the iteration count was exceeded or the\n-     *         solver detects convergence problems otherwise.\n-     */\n-    public static double solve(\n-        UnivariateRealFunction f,\n-        double x0,\n-        double x1,\n-        double absoluteAccuracy)\n-        throws MathException\n-    {\n-        if(f == null){\n-            throw new IllegalArgumentException(\"f can not be null.\");    \n-        }\n-            \n-        UnivariateRealSolver solver = UnivariateRealSolverFactory.newInstance()\n-            .newDefaultSolver(f);\n+    throws ConvergenceException, FunctionEvaluationException {\n+        setup(f);\n+        return factory.newDefaultSolver(f).solve(x0, x1);\n+    }\n+\n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n+     * @param f the function\n+     * @param x0 the lower bound for the interval\n+     * @param x1 the upper bound for the interval\n+     * @param absoluteAccuracy the accuracy to be used by the solver\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if f is null, the endpoints do not \n+     * specify a valid interval, or the absoluteAccuracy is not valid for the\n+     * default solver\n+     */\n+    public static double solve(UnivariateRealFunction f, double x0, double x1,\n+            double absoluteAccuracy) throws ConvergenceException, \n+            FunctionEvaluationException {    \n+       \n+        setup(f);\n+        UnivariateRealSolver solver = factory.newDefaultSolver(f);\n         solver.setAbsoluteAccuracy(absoluteAccuracy);\n         return solver.solve(x0, x1);\n     }\n \n     /**\n-     * For a function, f, this method returns two values, a and b that bracket\n-     * a root of f.  That is to say, there exists a value c between a and b\n-     * such that f(c) = 0.\n+     * This method attempts to find two values a and b satisfying <ul>\n+    * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code></li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n+     * -- ConvergenceException </li>\n+     * </ul>\n+     * <p>\n+     * <strong>Note: </strong> this method can take \n+     * <code>Integer.MAX_VALUE</code> iterations to throw a \n+     * <code>ConvergenceException.</code>  Unless you are confident that there\n+     * is a root between <code>lowerBound</code> and <code>upperBound</code>\n+     * near <code>initial,</code> it is better to use \n+     * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n+     * explicitly specifying the maximum number of iterations.\n      *\n      * @param function the function\n-     * @param initial midpoint of the returned range.\n-     * @param lowerBound for numerical safety, a never is less than this value.\n-     * @param upperBound for numerical safety, b never is greater than this\n-     *                   value.\n-     * @return a two element array holding {a, b}.\n-     * @throws MathException if a root can not be bracketted.\n-     */\n-    public static double[] bracket(UnivariateRealFunction function,\n-                                   double initial,\n-                                   double lowerBound,\n-                                   double upperBound) throws MathException {\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @return a two element array holding {a, b}\n+     * @throws ConvergenceException if a root can not be bracketted\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n+     */\n+    public static double[] bracket(UnivariateRealFunction function, \n+            double initial, double lowerBound, double upperBound) \n+    throws ConvergenceException, FunctionEvaluationException {\n         return bracket( function, initial, lowerBound, upperBound,\n             Integer.MAX_VALUE ) ;\n     }\n \n-    /**\n-     * For a function, f, this method returns two values, a and b that bracket\n-     * a root of f.  That is to say, there exists a value c between a and b\n-     * such that f(c) = 0.\n-     *\n+     /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code> </li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> maximumIterations</code> iterations elapse \n+     * -- ConvergenceException </li></ul>\n+     * \n      * @param function the function\n-     * @param initial midpoint of the returned range.\n-     * @param lowerBound for numerical safety, a never is less than this value.\n-     * @param upperBound for numerical safety, b never is greater than this\n-     *                   value.\n-     * @param maximumIterations to guard against infinite looping, maximum\n-     *                          number of iterations to perform\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @param maximumIterations maximum number of iterations to perform\n      * @return a two element array holding {a, b}.\n-     * @throws MathException if a root can not be bracketted.\n+     * @throws ConvergenceException if the algorithm fails to find a and b\n+     * satisfying the desired conditions\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n      */\n     public static double[] bracket(UnivariateRealFunction function,\n-                                   double initial,\n-                                   double lowerBound,\n-                                   double upperBound,\n-                                   int maximumIterations) throws MathException {\n+            double initial, double lowerBound, double upperBound, \n+            int maximumIterations) throws ConvergenceException, \n+            FunctionEvaluationException {\n+        \n+        if (function == null) {\n+            throw new IllegalArgumentException (\"function is null.\");\n+        }\n+        if (maximumIterations <= 0)  {\n+            throw new IllegalArgumentException\n+            (\"bad value for maximumIterations: \" + maximumIterations);\n+        }\n+        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n+            throw new IllegalArgumentException\n+            (\"Invalid endpoint parameters:  lowerBound=\" + lowerBound + \n+              \" initial=\" + initial + \" upperBound=\" + upperBound);\n+        }\n         double a = initial;\n         double b = initial;\n         double fa;\n             a = Math.max(a - 1.0, lowerBound);\n             b = Math.min(b + 1.0, upperBound);\n             fa = function.value(a);\n+            \n             fb = function.value(b);\n-            numIterations += 1 ;\n-        } while ( (fa * fb > 0.0) && ( numIterations < maximumIterations ) );\n-    \n+            numIterations++ ;\n+        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n+                ((a > lowerBound) || (b < upperBound)));\n+   \n+        if (fa * fb >= 0.0 ) {\n+            throw new ConvergenceException\n+            (\"Number of iterations= \" + numIterations +\n+              \" maximum iterations= \"  + maximumIterations +\n+              \" initial= \" + initial + \" lowerBound=\" + lowerBound +\n+              \" upperBound=\" + upperBound + \" final a value=\" + a +\n+              \" final b value=\" + b + \" f(a)=\" + fa + \" f(b)=\" + fb);\n+        }\n+        \n         return new double[]{a, b};\n     }\n \n     /**\n      * Compute the midpoint of two values.\n+     * \n      * @param a first value.\n      * @param b second value.\n      * @return the midpoint. \n     public static double midpoint(double a, double b) {\n         return (a + b) * .5;\n     }\n+    \n+    /**\n+     * Checks to see if f is null, throwing IllegalArgumentException if so.\n+     * Also initializes factory if factory is null.\n+     * \n+     * @param f  input function\n+     * @throws IllegalArgumentException if f is null\n+     */\n+    private static void setup(UnivariateRealFunction f) {\n+       \n+        if (f == null) {\n+            throw new IllegalArgumentException(\"function can not be null.\");    \n+        }\n+        \n+        if (factory == null) {\n+            factory = UnivariateRealSolverFactory.newInstance();\n+        }       \n+    }\n }\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealSolverUtils;\n  * implementations for some of the methods that do not vary from distribution\n  * to distribution.\n  *  \n- * @version $Revision: 1.24 $ $Date: 2004/06/23 16:26:15 $\n+ * @version $Revision: 1.25 $ $Date: 2004/07/17 21:19:39 $\n  */\n public abstract class AbstractContinuousDistribution\n     implements ContinuousDistribution, Serializable {\n             throw new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n         }\n \n-        // by default, do simple root finding using bracketing and bisection.\n+        // by default, do simple root finding using bracketing and default solver.\n         // subclasses can overide if there is a better method.\n         UnivariateRealFunction rootFindingFunction =\n             new UnivariateRealFunction() {\n \n-            public double value(double x) throws MathException {\n-                return cumulativeProbability(x) - p;\n+            public double value(double x) throws FunctionEvaluationException {\n+                try {\n+                    return cumulativeProbability(x) - p;\n+                } catch (MathException ex) {\n+                    throw new FunctionEvaluationException\n+                        (x, \"Error computing cdf\", ex);\n+                }\n             }\n         };\n-\n-        // bracket root\n-        double[] bracket =\n-            UnivariateRealSolverUtils.bracket(\n-                rootFindingFunction,\n-                getInitialDomain(p),\n-                getDomainLowerBound(p),\n-                getDomainUpperBound(p));\n+              \n+        // Try to bracket root, test domain endoints if this fails     \n+        double lowerBound = getDomainLowerBound(p);\n+        double upperBound = getDomainUpperBound(p);\n+        double[] bracket = null;\n+        try {\n+            bracket = UnivariateRealSolverUtils.bracket(\n+                    rootFindingFunction, getInitialDomain(p),\n+                    lowerBound, upperBound);\n+        }  catch (ConvergenceException ex) {\n+            /* \n+             * Check domain endpoints to see if one gives value that is within\n+             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n+             * case if density has bounded support and p is 0 or 1).\n+             * \n+             * TODO: expose the default solver, defaultAbsoluteAccuracy as\n+             * a constant.\n+             */ \n+            if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n+                return lowerBound;\n+            }\n+            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n+                return upperBound;\n+            }     \n+            // Failed bracket convergence was not because of corner solution\n+            throw new MathException(ex);\n+        }\n \n         // find root\n-        double root =\n-            UnivariateRealSolverUtils.solve(\n-                rootFindingFunction,\n-                bracket[0],\n-                bracket[1]);\n-\n+        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n+                bracket[0],bracket[1]);\n         return root;\n     }\n \n--- a/src/test/org/apache/commons/math/analysis/BisectionSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/BisectionSolverTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.stat.univariate.DescriptiveStatistics;\n \n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.11 $ $Date: 2004/06/02 00:11:53 $\n+ * @version $Revision: 1.12 $ $Date: 2004/07/17 21:19:39 $\n  */\n public final class BisectionSolverTest extends TestCase {\n     /**\n \n         result = solver.solve(0.85, 5);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        \n+        assertEquals(result, solver.getResult(), 0);\n+        assertTrue(solver.getIterationCount() > 0);\n     }\n     \n     /**\n      * \n      */\n     public void testSetFunctionValueAccuracy(){\n-        double expected = 1.0e-2;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        try {\n-            solver.setFunctionValueAccuracy(expected);\n-            assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);\n-        } catch (MathException ex) {\n-            fail(ex.getMessage());\n-        }\n+        double expected = 1.0e-2;    \n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        solver.setFunctionValueAccuracy(expected);\n+        assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);\n     }        \n     \n     /**\n      * \n      */\n     public void testResetFunctionValueAccuracy(){\n-        double newValue = 1.0e-2;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        try {\n-            double oldValue = solver.getFunctionValueAccuracy();\n-            solver.setFunctionValueAccuracy(newValue);\n-            solver.resetFunctionValueAccuracy();\n-            assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);\n-        } catch(MathException ex){\n-            fail(ex.getMessage());\n-        }\n+        double newValue = 1.0e-2;    \n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        double oldValue = solver.getFunctionValueAccuracy();\n+        solver.setFunctionValueAccuracy(newValue);\n+        solver.resetFunctionValueAccuracy();\n+        assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);\n     }        \n     \n     /**\n      * \n      */\n     public void testSetAbsoluteAccuracy(){\n-        double expected = 1.0e-2;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        try {\n-            solver.setAbsoluteAccuracy(expected);\n-            assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2);\n-        } catch(MathException ex){\n-            fail(ex.getMessage());\n-        }\n+        double expected = 1.0e-2; \n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        solver.setAbsoluteAccuracy(expected);\n+        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); \n     }        \n     \n     /**\n      * \n      */\n     public void testResetAbsoluteAccuracy(){\n-        double newValue = 1.0e-2;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        try {\n-            double oldValue = solver.getAbsoluteAccuracy();\n-            solver.setAbsoluteAccuracy(newValue);\n-            solver.resetAbsoluteAccuracy();\n-            assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);\n-        } catch(MathException ex){\n-            fail(ex.getMessage());\n-        }\n+        double newValue = 1.0e-2;       \n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        double oldValue = solver.getAbsoluteAccuracy();\n+        solver.setAbsoluteAccuracy(newValue);\n+        solver.resetAbsoluteAccuracy();\n+        assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);\n     }        \n     \n     /**\n         \n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new BisectionSolver(f);\n-        try {\n-            solver.setRelativeAccuracy(expected);\n-            assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);\n-        } catch(MathException ex){\n-            fail(ex.getMessage());\n-        }\n+        solver.setRelativeAccuracy(expected);\n+        assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);\n     }        \n     \n     /**\n      * \n      */\n     public void testResetRelativeAccuracy(){\n-        double newValue = 1.0e-2;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        try {\n-            double oldValue = solver.getRelativeAccuracy();\n-            solver.setRelativeAccuracy(newValue);\n-            solver.resetRelativeAccuracy();\n-            assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n-        } catch(MathException ex){\n-            fail(ex.getMessage());\n-        }\n+        double newValue = 1.0e-2;        \n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        double oldValue = solver.getRelativeAccuracy();\n+        solver.setRelativeAccuracy(newValue);\n+        solver.resetRelativeAccuracy();\n+        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n     }        \n     \n     /**\n      * Test Serialization and Recovery\n      */\n-   public void testSerialization() {\n-\n-       \n-       try {\n-           UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n-           double result;\n-           \n-           BisectionSolver solver = new BisectionSolver(f);\n-           UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);\n-           \n-           result = solver.solve(-0.2, 0.2);\n-           assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(-0.1, 0.3);\n-           assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(-0.3, 0.45);\n-           assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.3, 0.7);\n-           assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.2, 0.6);\n-           assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.05, 0.95);\n-           assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.85, 1.25);\n-           assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.8, 1.2);\n-           assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.85, 1.75);\n-           assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.55, 1.45);\n-           assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n-           \n-           result = solver.solve(0.85, 5);\n-           assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-           assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());\n-           \n-       } catch(MathException ex){\n-           fail(ex.getMessage());\n-       }\n+   public void testSerialization() throws MathException {\n+       UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n+       double result;\n+       \n+       BisectionSolver solver = new BisectionSolver(f);\n+       UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);\n+       \n+       result = solver.solve(-0.2, 0.2);\n+       assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(-0.1, 0.3);\n+       assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(-0.3, 0.45);\n+       assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.3, 0.7);\n+       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.2, 0.6);\n+       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.05, 0.95);\n+       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.85, 1.25);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.8, 1.2);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.85, 1.75);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.55, 1.45);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(0.85, 5);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());\n        \n        /* Test Reset */\n-       try{ \n-           double newValue = 1.0e-2;\n-           UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n-           UnivariateRealSolver solver = new BisectionSolver(f);\n-\n-           double oldValue = solver.getRelativeAccuracy();\n-           solver.setRelativeAccuracy(newValue);\n-           solver.resetRelativeAccuracy();\n-           assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n-       \n-           UnivariateRealSolver  solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver); \n-       \n-           assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n-       \n-           solver2.setRelativeAccuracy(newValue);\n-           solver2.resetRelativeAccuracy();\n-       \n-           assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n-       \n-       } catch(MathException ex){\n-           fail(ex.getMessage());\n-       }\n-    \n+       double newValue = 1.0e-2;\n+       f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n+       solver = new BisectionSolver(f);\n+       \n+       double oldValue = solver.getRelativeAccuracy();\n+       solver.setRelativeAccuracy(newValue);\n+       solver.resetRelativeAccuracy();\n+       assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n+       \n+       solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver); \n+       \n+       assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+       \n+       solver2.setRelativeAccuracy(newValue);\n+       solver2.resetRelativeAccuracy();\n+       \n+       assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+       \n    }\n-    \n+   \n }\n--- a/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.1 $ $Date: 2004/04/08 21:19:17 $\n+ * @version $Revision: 1.2 $ $Date: 2004/07/17 21:19:39 $\n  */\n public final class NewtonSolverTest extends TestCase {\n     /**\n \n         result = solver.solve(1, 4);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        \n+        //TODO:  create abstract solver test class, move these there\n+        assertEquals(result, solver.getResult(), 0);\n+        assertTrue(solver.getIterationCount() > 0);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/org/apache/commons/math/analysis/QuinticFunction.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n  * Auxillary class for testing solvers.\n  *\n- * @version $Revision: 1.13 $ $Date: 2004/06/02 00:12:01 $ \n+ * @version $Revision: 1.14 $ $Date: 2004/07/17 21:19:39 $ \n  */\n public class QuinticFunction implements DifferentiableUnivariateRealFunction, Serializable {\n \n     /* Evaluate quintic.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n      */\n-    public double value(double x) throws MathException {\n+    public double value(double x) throws FunctionEvaluationException {\n         return (x-1)*(x-0.5)*x*(x+0.5)*(x+1);\n     }\n \n     public UnivariateRealFunction derivative() {\n         return new UnivariateRealFunction() {\n-            public double value(double x) throws MathException {\n+            public double value(double x) throws FunctionEvaluationException {\n                 return (5*x*x-3.75)*x*x+0.25;\n             }\n         };\n--- a/src/test/org/apache/commons/math/analysis/SinFunction.java\n+++ b/src/test/org/apache/commons/math/analysis/SinFunction.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n  * Auxillary class for testing solvers.\n  * which means linear approximation (Regula Falsi) will converge\n  * quadratically.\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/04/08 21:19:17 $\n+ * @version $Revision: 1.13 $ $Date: 2004/07/17 21:19:39 $\n  */\n public class SinFunction implements DifferentiableUnivariateRealFunction {\n \n     /* Evaluate sinus fuction.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n      */\n-    public double value(double x) throws MathException {\n+    public double value(double x) throws FunctionEvaluationException {\n         return Math.sin(x);\n     }\n \n      */\n     public UnivariateRealFunction derivative() {\n         return new UnivariateRealFunction() {\n-            public double value(double x) throws MathException {\n+            public double value(double x) throws FunctionEvaluationException {\n                 return Math.cos(x);\n             }\n         };\n--- a/src/test/org/apache/commons/math/analysis/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/org/apache/commons/math/analysis/UnivariateRealSolverUtilsTest.java\n \n package org.apache.commons.math.analysis;\n \n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathException;\n \n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.7 $ $Date: 2004/02/21 21:35:16 $\n+ * @version $Revision: 1.8 $ $Date: 2004/07/17 21:19:39 $\n  */\n public class UnivariateRealSolverUtilsTest extends TestCase {\n-    /**\n-     * \n-     */\n-    public void testSolveNull(){\n+    \n+    protected UnivariateRealFunction sin = new SinFunction();\n+    \n+    public void testSolveNull() throws MathException {\n         try {\n             UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n             fail();\n-        } catch(MathException ex){\n-            fail(\"math exception should no be thrown.\");\n         } catch(IllegalArgumentException ex){\n             // success\n         }\n     }\n     \n-    /**\n-     * \n-     */\n-    public void testSolveSin(){\n-        try {\n-            double x = UnivariateRealSolverUtils.solve(new SinFunction(), 1.0,\n+    public void testSolveBadParameters() throws MathException {\n+        try { // bad endpoints\n+            double x = UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0); \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }    \n+        try { // bad accuracy\n+            double x = UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0); \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n+    public void testSolveSin() throws MathException {     \n+        double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n                 4.0);\n-            assertEquals(Math.PI, x, 1.0e-4);\n-        } catch(MathException ex){\n-            fail(\"math exception should no be thrown.\");\n-        }\n+        assertEquals(Math.PI, x, 1.0e-4);\n     }\n-\n-    /**\n-     * \n-     */\n-    public void testSolveAccuracyNull(){\n+    \n+    public void testSolveAccuracyNull()  throws MathException {\n         try {\n             double accuracy = 1.0e-6;\n             UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);\n             fail();\n-        } catch(MathException ex){\n-            fail(\"math exception should no be thrown.\");\n         } catch(IllegalArgumentException ex){\n             // success\n         }\n     }\n     \n-    /**\n-     * \n-     */\n-    public void testSolveAccuracySin(){\n+    public void testSolveAccuracySin() throws MathException {\n+        double accuracy = 1.0e-6;\n+        double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n+                4.0, accuracy);\n+        assertEquals(Math.PI, x, accuracy);\n+    }\n+    \n+    public void testSolveNoRoot() throws MathException {\n         try {\n-            double accuracy = 1.0e-6;\n-            double x = UnivariateRealSolverUtils.solve(new SinFunction(), 1.0,\n-                4.0, accuracy);\n-            assertEquals(Math.PI, x, accuracy);\n-        } catch(MathException ex){\n-            fail(\"math exception should no be thrown.\");\n+            double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n+                    1.5);  \n+            fail(\"Expecting IllegalArgumentException \");  \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n         }\n     }\n+    \n+    public void testBracketSin() throws MathException {\n+        double[] result = UnivariateRealSolverUtils.bracket(sin, \n+                0.0, -2.0, 2.0);\n+        assertTrue(sin.value(result[0]) < 0);\n+        assertTrue(sin.value(result[1]) > 0);\n+    }\n+    \n+    public void testBracketCornerSolution() throws MathException {\n+        try {\n+            double[] result = UnivariateRealSolverUtils.bracket(sin, \n+                    1.5, 0, 2.0); \n+            fail(\"Expecting ConvergenceException\");\n+        } catch (ConvergenceException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testBadParameters() throws MathException {\n+        try { // null function\n+            double[] result = UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // initial not between endpoints\n+            double[] result = UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // endpoints not valid\n+            double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // bad maximum iterations\n+            double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n }", "timestamp": 1090099179, "metainfo": ""}