{"sha": "d34f4af471f656ee51054e7dd7804e38b5c67787", "log": "Added method getIterations() in o.a.c.m.utils.IterationEvent (MATH-735).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n+++ b/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n      * @version $Id: ConjugateGradient.java 1175404 2011-09-25 14:48:18Z\n      * celestin $\n      */\n-    public abstract static class ConjugateGradientEvent\n+    public static class ConjugateGradientEvent\n         extends IterativeLinearSolverEvent\n         implements ProvidesResidual {\n \n         /** */\n-        private static final long serialVersionUID = 6461730085343318121L;\n+        private static final long serialVersionUID = 20120128L;\n+\n+        /** The right-hand side vector. */\n+        private final RealVector b;\n+\n+        /** The current estimate of the residual. */\n+        private final RealVector r;\n+\n+        /** The current estimate of the solution. */\n+        private final RealVector x;\n \n         /**\n          * Creates a new instance of this class.\n          *\n-         * @param source The iterative algorithm on which the event initially\n-         * occurred.\n+         * @param source the iterative algorithm on which the event initially\n+         * occurred\n+         * @param iterations the number of iterations performed at the time\n+         * {@code this} event is created\n+         * @param x the current estimate of the solution\n+         * @param b the right-hand side vector\n+         * @param r the current estimate of the residual\n          */\n-        public ConjugateGradientEvent(final Object source) {\n-            super(source);\n+        public ConjugateGradientEvent(final Object source, final int iterations, final RealVector x, final RealVector b, final RealVector r) {\n+            super(source, iterations);\n+            this.x = RealVector.unmodifiableRealVector(x);\n+            this.b = RealVector.unmodifiableRealVector(b);\n+            this.r = RealVector.unmodifiableRealVector(r);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector getResidual() {\n+            return r;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public RealVector getRightHandSideVector() {\n+            return b;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public RealVector getSolution() {\n+            return x;\n         }\n     }\n \n         } else {\n             z = null;\n         }\n-        final IterativeLinearSolverEvent event;\n-        event = new ConjugateGradientEvent(this) {\n-\n-            private static final long serialVersionUID = 756911840348776676L;\n-\n-            public RealVector getResidual() {\n-                return ArrayRealVector.unmodifiableRealVector(r);\n-            }\n-\n-            @Override\n-            public RealVector getRightHandSideVector() {\n-                return ArrayRealVector.unmodifiableRealVector(b);\n-            }\n-\n-            @Override\n-            public RealVector getSolution() {\n-                return ArrayRealVector.unmodifiableRealVector(x);\n-            }\n-        };\n-        manager.fireInitializationEvent(event);\n+        IterativeLinearSolverEvent evt;\n+        evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r);\n+        manager.fireInitializationEvent(evt);\n         if (r2 <= r2max) {\n-            manager.fireTerminationEvent(event);\n+            manager.fireTerminationEvent(evt);\n             return x;\n         }\n         double rhoPrev = 0.;\n         while (true) {\n             manager.incrementIterationCount();\n-            manager.fireIterationStartedEvent(event);\n+            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r);\n+            manager.fireIterationStartedEvent(evt);\n             if (m != null) {\n                 z = m.solve(r);\n             }\n             r.combineToSelf(1., -alpha, q);\n             rhoPrev = rhoNext;\n             r2 = r.dotProduct(r);\n-            manager.fireIterationPerformedEvent(event);\n+            evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r);\n+            manager.fireIterationPerformedEvent(evt);\n             if (r2 <= r2max) {\n-                manager.fireTerminationEvent(event);\n+                manager.fireTerminationEvent(evt);\n                 return x;\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n     extends IterationEvent {\n \n     /** */\n-    private static final long serialVersionUID = 283291016904748030L;\n+    private static final long serialVersionUID = 20120128L;\n \n     /**\n      * Creates a new instance of this class.\n      *\n-     * @param source The iterative algorithm on which the event initially\n-     *        occurred.\n+     * @param source the iterative algorithm on which the event initially\n+     * occurred\n+     * @param iterations the number of iterations performed at the time\n+     * {@code this} event is created\n      */\n-    public IterativeLinearSolverEvent(final Object source) {\n-        super(source);\n+    public IterativeLinearSolverEvent(final Object source, final int iterations) {\n+        super(source, iterations);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n         }\n     }\n \n+    /**\n+     * The type of all events fired by this implementation of the SYMMLQ method.\n+     *\n+     * @version $Id$\n+     */\n+    private class SymmLQEvent extends IterativeLinearSolverEvent {\n+        /*\n+         * TODO This class relies dangerously on references being transparently\n+         * updated.\n+         */\n+\n+        /** */\n+        private static final long serialVersionUID = 20120128L;\n+\n+        /** A reference to the state of this solver. */\n+        private final State state;\n+\n+        /**\n+         * Creates a new instance of this class.\n+         *\n+         * @param source the iterative algorithm on which the event initially\n+         * occurred\n+         * @param state the state of this solver at the time of creation\n+         */\n+        public SymmLQEvent(final Object source, final State state) {\n+            super(source, getIterationManager().getIterations());\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public int getIterations() {\n+            return getIterationManager().getIterations();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public RealVector getRightHandSideVector() {\n+            return RealVector.unmodifiableRealVector(state.b);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public RealVector getSolution() {\n+            final int n = state.x.getDimension();\n+            final RealVector x = new ArrayRealVector(n);\n+            state.refine(x);\n+            return x;\n+        }\n+    }\n+\n     /** The cubic root of {@link #MACH_PREC}. */\n     private static final double CBRT_MACH_PREC;\n \n         manager.incrementIterationCount();\n \n         final State state = new State(a, m, b, x, goodb, shift);\n-        final IterativeLinearSolverEvent event = createEvent(state);\n+        final IterativeLinearSolverEvent event = new SymmLQEvent(this, state);\n         if (state.beta1 == 0.) {\n             /* If b = 0 exactly, stop with x = 0. */\n             manager.fireTerminationEvent(event);\n         IllConditionedOperatorException, MaxCountExceededException {\n         return solveInPlace(a, null, b, x, false, 0.);\n     }\n-\n-    /**\n-     * Creates the event to be fired during the solution process. Unmodifiable\n-     * views of the RHS vector, and the current estimate of the solution are\n-     * returned by the created event.\n-     *\n-     * @param state Reference to the current state of this algorithm.\n-     * @return The newly created event.\n-     */\n-    private IterativeLinearSolverEvent createEvent(final State state) {\n-        final RealVector bb = RealVector.unmodifiableRealVector(state.b);\n-\n-        final IterativeLinearSolverEvent event;\n-        event = new IterativeLinearSolverEvent(this) {\n-\n-           private static final long serialVersionUID = 3656926699603081076L;\n-\n-            @Override\n-            public RealVector getRightHandSideVector() {\n-                return bb;\n-            }\n-\n-            @Override\n-            public RealVector getSolution() {\n-                final int n = state.x.getDimension();\n-                final RealVector x = new ArrayRealVector(n);\n-                state.refine(x);\n-                return x;\n-            }\n-        };\n-        return event;\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/util/IterationEvent.java\n+++ b/src/main/java/org/apache/commons/math/util/IterationEvent.java\n  */\n public class IterationEvent extends EventObject {\n     /** */\n-    private static final long serialVersionUID = -1405936936084001482L;\n+    private static final long serialVersionUID = 20120128L;\n+\n+    /** The number of iterations performed so far. */\n+    private final int iterations;\n \n     /**\n      * Creates a new instance of this class.\n      *\n-     * @param source The iterative algorithm on which the event initially\n-     * occurred.\n+     * @param source the iterative algorithm on which the event initially\n+     * occurred\n+     * @param iterations the number of iterations performed at the time\n+     * {@code this} event is created\n      */\n-    public IterationEvent(final Object source) {\n+    public IterationEvent(final Object source, final int iterations) {\n         super(source);\n+        this.iterations = iterations;\n     }\n-}\n+\n+    /**\n+     * Returns the number of iterations performed at the time {@code this} event\n+     * is created.\n+     *\n+     * @return the number of iterations performed\n+     */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+ }\n--- a/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n  */\n package org.apache.commons.math.linear;\n \n+import java.util.Arrays;\n+\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.util.IterationEvent;\n         final int maxIterations = 100;\n         final RealLinearOperator a = new HilbertMatrix(n);\n         final IterativeLinearSolver solver;\n-        final int[] count = new int[] {\n-            0, 0, 0, 0\n-        };\n+        /*\n+         * count[0] = number of calls to initializationPerformed\n+         * count[1] = number of calls to iterationStarted\n+         * count[2] = number of calls to iterationPerformed\n+         * count[3] = number of calls to terminationPerformed\n+         */\n+        final int[] count = new int[] {0, 0, 0, 0};\n         final IterationListener listener = new IterationListener() {\n \n             public void initializationPerformed(final IterationEvent e) {\n-                count[0] = 1;\n-                count[1] = 0;\n-                count[2] = 0;\n-                count[3] = 0;\n-\n+                ++count[0];\n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n                 ++count[2];\n-            }\n-\n-            public void iterationStarted(IterationEvent e) {\n+                Assert.assertEquals(\"iteration performed\",\n+                    count[2], e.getIterations() - 1);\n+            }\n+\n+            public void iterationStarted(final IterationEvent e) {\n                 ++count[1];\n-\n+                Assert.assertEquals(\"iteration started\",\n+                    count[1], e.getIterations() - 1);\n             }\n \n             public void terminationPerformed(final IterationEvent e) {\n         solver.getIterationManager().addIterationListener(listener);\n         final RealVector b = new ArrayRealVector(n);\n         for (int j = 0; j < n; j++) {\n+            Arrays.fill(count, 0);\n             b.set(0.);\n             b.setEntry(j, 1.);\n             solver.solve(a, b);\n             String msg = String.format(\"column %d (initialization)\", j);\n             Assert.assertEquals(msg, 1, count[0]);\n-            msg = String.format(\"column %d (iterations started)\", j);\n-            Assert.assertEquals(msg, solver.getIterationManager()\n-                .getIterations() - 1, count[1]);\n-            msg = String.format(\"column %d (iterations performed)\", j);\n-            Assert.assertEquals(msg, solver.getIterationManager()\n-                .getIterations() - 1, count[2]);\n             msg = String.format(\"column %d (finalization)\", j);\n             Assert.assertEquals(msg, 1, count[3]);\n         }\n--- a/src/test/java/org/apache/commons/math/linear/SymmLQTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SymmLQTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.FastMath;\n         final int maxIterations = 100;\n         final RealLinearOperator a = new HilbertMatrix(n);\n         final IterativeLinearSolver solver;\n-        final int[] count = new int[] {\n-            0, 0, 0, 0\n-        };\n+        /*\n+         * count[0] = number of calls to initializationPerformed\n+         * count[1] = number of calls to iterationStarted\n+         * count[2] = number of calls to iterationPerformed\n+         * count[3] = number of calls to terminationPerformed\n+         */\n+        final int[] count = new int[] {0, 0, 0, 0};\n         final IterationListener listener = new IterationListener() {\n \n             public void initializationPerformed(final IterationEvent e) {\n-                count[0] = 1;\n-                count[1] = 0;\n-                count[2] = 0;\n-                count[3] = 0;\n-\n+                ++count[0];\n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n                 ++count[2];\n+                Assert.assertEquals(\"iteration performed\",\n+                    count[2], e.getIterations() - 1);\n             }\n \n             public void iterationStarted(final IterationEvent e) {\n                 ++count[1];\n-\n+                Assert.assertEquals(\"iteration started\",\n+                    count[1], e.getIterations() - 1);\n             }\n \n             public void terminationPerformed(final IterationEvent e) {\n         solver.getIterationManager().addIterationListener(listener);\n         final RealVector b = new ArrayRealVector(n);\n         for (int j = 0; j < n; j++) {\n+            Arrays.fill(count, 0);\n             b.set(0.);\n             b.setEntry(j, 1.);\n             solver.solve(a, b);\n             String msg = String.format(\"column %d (initialization)\", j);\n             Assert.assertEquals(msg, 1, count[0]);\n-            msg = String.format(\"column %d (iterations started)\", j);\n-            Assert.assertEquals(msg, solver.getIterationManager()\n-                .getIterations() - 1, count[1]);\n-            msg = String.format(\"column %d (iterations performed)\", j);\n-            Assert.assertEquals(msg, solver.getIterationManager()\n-                .getIterations() - 1, count[2]);\n             msg = String.format(\"column %d (finalization)\", j);\n             Assert.assertEquals(msg, 1, count[3]);\n         }\n     public void testNonSelfAdjointOperator() {\n         final RealLinearOperator a;\n         a = new Array2DRowRealMatrix(new double[][] {\n-            {\n-                1., 2., 3.\n-            }, {\n-                2., 4., 5.\n-            }, {\n-                2.999, 5., 6.\n-            }\n+            {1., 2., 3.},\n+            {2., 4., 5.},\n+            {2.999, 5., 6.}\n         });\n         final RealVector b;\n-        b = new ArrayRealVector(new double[] {\n-            1., 1., 1.\n-        });\n+        b = new ArrayRealVector(new double[] {1., 1., 1.});\n         new SymmLQ(100, 1., true).solve(a, b);\n     }\n \n     @Test(expected = NonSelfAdjointOperatorException.class)\n     public void testNonSelfAdjointPreconditioner() {\n         final RealLinearOperator a = new Array2DRowRealMatrix(new double[][] {\n-            {\n-                1., 2., 3.\n-            }, {\n-                2., 4., 5.\n-            }, {\n-                3., 5., 6.\n-            }\n+            {1., 2., 3.},\n+            {2., 4., 5.},\n+            {3., 5., 6.}\n         });\n         final Array2DRowRealMatrix mMat;\n         mMat = new Array2DRowRealMatrix(new double[][] {\n-            {\n-                1., 0., 1.\n-            }, {\n-                0., 1., 0.\n-            }, {\n-                0., 0., 1.\n-            }\n+            {1., 0., 1.},\n+            {0., 1., 0.},\n+            {0., 0., 1.}\n         });\n         final DecompositionSolver mSolver;\n         mSolver = new LUDecomposition(mMat).getSolver();", "timestamp": 1327756754, "metainfo": ""}