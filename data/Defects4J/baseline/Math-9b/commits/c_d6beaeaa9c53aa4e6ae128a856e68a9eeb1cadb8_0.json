{"sha": "d6beaeaa9c53aa4e6ae128a856e68a9eeb1cadb8", "log": "tighten checkstyle rules for hidden fields  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n     /**\n      * Convenience function for implementations.\n      * \n-     * @param result the result to set\n+     * @param newResult the result to set\n      * @param iterationCount the iteration count to set\n      */\n-    protected final void setResult(double result, int iterationCount) {\n-        this.result = result;\n+    protected final void setResult(double newResult, int iterationCount) {\n+        this.result         = newResult;\n         this.iterationCount = iterationCount;\n         this.resultComputed = true;\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n     /**\n      * Convenience function for implementations.\n      * \n-     * @param result the result to set\n+     * @param newResult the result to set\n      * @param iterationCount the iteration count to set\n      */\n-    protected final void setResult(final double result, final int iterationCount) {\n-        this.result         = result;\n+    protected final void setResult(final double newResult, final int iterationCount) {\n+        this.result         = newResult;\n         this.iterationCount = iterationCount;\n         this.resultComputed = true;\n     }\n      * \n      * @param lower  the lower endpoint \n      * @param upper  the upper endpoint\n-     * @param f the function\n+     * @param function the function\n      * @return true if f(lower) * f(upper) < 0\n      * @throws FunctionEvaluationException if an error occurs evaluating the \n      * function at the endpoints\n      */\n     protected boolean isBracketing(final double lower, final double upper, \n-                                   final UnivariateRealFunction f)\n+                                   final UnivariateRealFunction function)\n         throws FunctionEvaluationException {\n-        final double f1 = f.value(lower);\n-        final double f2 = f.value(upper);\n+        final double f1 = function.value(lower);\n+        final double f2 = function.value(upper);\n         return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n     }\n     \n      * \n      * @param lower  lower endpoint\n      * @param upper upper endpoint\n-     * @param f function\n+     * @param function function\n      * @throws IllegalArgumentException\n      * @throws FunctionEvaluationException if an error occurs evaluating the \n      * function at the endpoints\n      */\n     protected void verifyBracketing(final double lower, final double upper, \n-                                    final UnivariateRealFunction f)\n+                                    final UnivariateRealFunction function)\n         throws FunctionEvaluationException {\n         \n         verifyInterval(lower, upper);\n-        if (!isBracketing(lower, upper, f)) {\n+        if (!isBracketing(lower, upper, function)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"function values at endpoints do not have different signs.  \" +\n                     \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n-                    lower, upper, f.value(lower), f.value(upper));       \n+                    lower, upper, function.value(lower), function.value(upper));       \n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n     /**\n      * Create a complex number given the real and imaginary parts.\n      *\n-     * @param real the real part\n-     * @param imaginary the imaginary part\n+     * @param realPart the real part\n+     * @param imaginaryPart the imaginary part\n      * @return a new complex number instance\n      * @since 1.2\n      */\n-    protected Complex createComplex(double real, double imaginary) {\n-        return new Complex(real, imaginary);\n+    protected Complex createComplex(double realPart, double imaginaryPart) {\n+        return new Complex(realPart, imaginaryPart);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n     private static final long serialVersionUID = 8589540077390120676L;\n     \n     /** The shape parameter. */\n-    private double alpha;\n+    private double shape;\n     \n     /** The scale parameter. */\n-    private double beta;\n+    private double scale;\n     \n     /**\n      * Creates weibull distribution with the given shape and scale and a\n      * @return the shape parameter.\n      */\n     public double getShape() {\n-        return alpha;\n+        return shape;\n     }\n     \n     /**\n      * @return the scale parameter.\n      */\n     public double getScale() {\n-        return beta;\n+        return scale;\n     }\n     \n     /**\n                   \"shape must be positive ({0})\",\n                   alpha);\n         }       \n-        this.alpha = alpha;\n+        this.shape = alpha;\n     }\n     \n     /**\n                   \"scale must be positive ({0})\",\n                   beta);\n         }       \n-        this.beta = beta;\n+        this.scale = beta;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n         updateJacobian();\n \n         // compute transpose(J).J, avoiding building big intermediate matrices\n-        final int rows = problem.getMeasurements().length;\n-        final int cols = problem.getUnboundParameters().length;\n-        final int max  = cols * rows;\n-        double[][] jTj = new double[cols][cols];\n-        for (int i = 0; i < cols; ++i) {\n-            for (int j = i; j < cols; ++j) {\n+        final int n = problem.getMeasurements().length;\n+        final int m = problem.getUnboundParameters().length;\n+        final int max  = m * n;\n+        double[][] jTj = new double[m][m];\n+        for (int i = 0; i < m; ++i) {\n+            for (int j = i; j < m; ++j) {\n                 double sum = 0;\n-                for (int k = 0; k < max; k += cols) {\n+                for (int k = 0; k < max; k += m) {\n                     sum += jacobian[k + i] * jacobian[k + j];\n                 }\n                 jTj[i][j] = sum;\n--- a/src/main/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n     /**\n      * \n      * Asserts that <code>representation</code> can represent a valid chromosome.\n-     * @param representation representation of the chromosome\n+     * @param chromosomeRepresentation representation of the chromosome\n      * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n      *         a valid chromosome\n      */\n-    protected abstract void checkValidity(List<T> representation) throws InvalidRepresentationException;\n+    protected abstract void checkValidity(List<T> chromosomeRepresentation) throws InvalidRepresentationException;\n \n     /**\n      * Returns the (immutable) inner representation of the chromosome.\n      * \n      * Usually, this method just calls a constructor of the class.\n      * \n-     * @param representation\n+     * @param chromosomeRepresentation\n      *            the inner array representation of the new chromosome.\n      * @return new instance extended from FixedLengthChromosome with the given\n      *         arrayRepresentation\n      */\n-    public abstract AbstractListChromosome<T> newFixedLengthChromosome(final List<T> representation);\n+    public abstract AbstractListChromosome<T> newFixedLengthChromosome(final List<T> chromosomeRepresentation);\n     \n     /**\n      * {@inheritDoc}\n--- a/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n      * {@inheritDoc}\n      */\n     @Override\n-    protected void checkValidity(List<Integer> representation) throws InvalidRepresentationException {\n-        for (int i : representation) {\n+    protected void checkValidity(List<Integer> chromosomeRepresentation) throws InvalidRepresentationException {\n+        for (int i : chromosomeRepresentation) {\n             if (i < 0 || i >1)\n                 throw new InvalidRepresentationException(\"Elements can be only 0 or 1.\");\n         }\n--- a/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n      * {@inheritDoc}\n      */\n     @Override    \n-    protected void checkValidity(java.util.List<Double> representation) throws InvalidRepresentationException {\n-        for (double val : representation) {\n+    protected void checkValidity(java.util.List<Double> chromosomeRepresentation) throws InvalidRepresentationException {\n+        for (double val : chromosomeRepresentation) {\n             if (val < 0 || val > 1) {\n                 throw new InvalidRepresentationException(\"Values of representation must be in [0,1] interval\");\n             }\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n             sigmaLow = 0;\n \n             // find start of a new split segment to process\n-            double eMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n-            double eMax = 0;\n-            double qMax = work[4 * n0 - 4];\n-            double qMin = qMax;\n+            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n+            double offDiagMax = 0;\n+            double diagMax    = work[4 * n0 - 4];\n+            double diagMin    = diagMax;\n             i0 = 0;\n             for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                 if (work[i + 2] <= 0) {\n                     i0 = 1 + i / 4;\n                     break;\n                 }\n-                if (qMin >= 4 * eMax) {\n-                    qMin = Math.min(qMin, work[i + 4]);\n-                    eMax = Math.max(eMax, work[i + 2]);\n-                }\n-                qMax = Math.max(qMax, work[i] + work[i + 2]);\n-                eMin = Math.min(eMin, work[i + 2]);\n-            }\n-            work[4 * n0 - 2] = eMin;\n+                if (diagMin >= 4 * offDiagMax) {\n+                    diagMin    = Math.min(diagMin, work[i + 4]);\n+                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n+                }\n+                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n+                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n+            }\n+            work[4 * n0 - 2] = offDiagMin;\n \n             // lower bound of Gershgorin disk\n-            dMin = -Math.max(0, qMin - 2 * Math.sqrt(qMin * eMax));\n+            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n \n             pingPong = 0;\n             int maxIter = 30 * (n0 - i0);\n                 // check for new splits after \"ping\" steps\n                 // when the last elements of qd array are very small\n                 if ((pingPong == 0) && (n0 - i0 > 3) &&\n-                    (work[4 * n0 - 1] <= TOLERANCE_2 * qMax) &&\n+                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                     (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n-                    int split = i0 - 1;\n-                    qMax = work[4 * i0];\n-                    eMin = work[4 * i0 + 2];\n+                    int split  = i0 - 1;\n+                    diagMax    = work[4 * i0];\n+                    offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                     for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                         if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                             // insert a split\n                             work[i + 2]  = -sigma;\n                             split        = i / 4;\n-                            qMax         = 0;\n-                            eMin         = work[i + 6];\n+                            diagMax      = 0;\n+                            offDiagMin   = work[i + 6];\n                             previousEMin = work[i + 7];\n                         } else {\n-                            qMax         = Math.max(qMax, work[i + 4]);\n-                            eMin         = Math.min(eMin, work[i + 2]);\n+                            diagMax      = Math.max(diagMax, work[i + 4]);\n+                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                             previousEMin = Math.min(previousEMin, work[i + 3]);\n                         }\n                     }\n-                    work[4 * n0 - 2] = eMin;\n+                    work[4 * n0 - 2] = offDiagMin;\n                     work[4 * n0 - 1] = previousEMin;\n                     i0 = split + 1;\n                 }\n \n     /**\n      * Update sigma.\n-     * @param tau shift to apply to sigma\n-     */\n-    private void updateSigma(final double tau) {\n+     * @param shift shift to apply to sigma\n+     */\n+    private void updateSigma(final double shift) {\n         // BEWARE: do NOT attempt to simplify the following statements\n         // the expressions below take care to accumulate the part of sigma\n         // that does not fit within a double variable into sigmaLow\n-        if (tau < sigma) {\n-            sigmaLow += tau;\n+        if (shift < sigma) {\n+            sigmaLow += shift;\n             final double t = sigma + sigmaLow;\n             sigmaLow -= t - sigma;\n             sigma = t;\n         } else {\n-            final double t = sigma + tau;\n-            sigmaLow += sigma - (t - tau);\n+            final double t = sigma + shift;\n+            sigmaLow += sigma - (t - shift);\n             sigma = t;\n         }\n     }\n         int r = m - 1;\n         double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n         for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {\n-            final double g = work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10];\n-            final double absG = Math.abs(g);\n+            final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\n             if (absG < minG) {\n                 r = i;\n                 minG = absG;\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n     private static final long serialVersionUID = -5962461716457143437L;\n \n     /** Number of rows of the matrix. */\n-    private final int rowDimension;\n+    private final int rows;\n \n     /** Number of columns of the matrix. */\n-    private final int columnDimension;\n+    private final int columns;\n \n     /** Storage for (sparse) matrix elements. */\n     private final OpenIntToDoubleHashMap entries;\n      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n-        this.rowDimension = rowDimension;\n-        this.columnDimension = columnDimension;\n+        this.rows    = rowDimension;\n+        this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n     }\n   \n      * @param matrix matrix to copy\n      */\n     public OpenMapRealMatrix(OpenMapRealMatrix matrix) {\n-        this.rowDimension = matrix.rowDimension;\n-        this.columnDimension = matrix.columnDimension;\n+        this.rows    = matrix.rows;\n+        this.columns = matrix.columns;\n         this.entries = new OpenIntToDoubleHashMap(matrix.entries);\n     }\n   \n     /** {@inheritDoc} */\n     @Override\n     public int getColumnDimension() {\n-        return columnDimension;\n+        return columns;\n     }\n \n     /** {@inheritDoc} */\n         final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n             iterator.advance();\n-            final int row = iterator.key() / columnDimension;\n-            final int col = iterator.key() - row * columnDimension;\n+            final int row = iterator.key() / columns;\n+            final int col = iterator.key() - row * columns;\n             out.setEntry(row, col, getEntry(row, col) + iterator.value());\n         }\n \n         final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n             iterator.advance();\n-            final int row = iterator.key() / columnDimension;\n-            final int col = iterator.key() - row * columnDimension;\n+            final int row = iterator.key() / columns;\n+            final int col = iterator.key() - row * columns;\n             out.setEntry(row, col, getEntry(row, col) - iterator.value());\n         }\n \n             MatrixUtils.checkMultiplicationCompatible(this, m);\n \n             final int outCols = m.getColumnDimension();\n-            final BlockRealMatrix out = new BlockRealMatrix(rowDimension, outCols);\n+            final BlockRealMatrix out = new BlockRealMatrix(rows, outCols);\n             for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n                 iterator.advance();\n                 final double value = iterator.value();\n                 final int key      = iterator.key();\n-                final int i        = key / columnDimension;\n-                final int k        = key % columnDimension;\n+                final int i        = key / columns;\n+                final int k        = key % columns;\n                 for (int j = 0; j < outCols; ++j) {\n                     out.addToEntry(i, j, value * m.getEntry(k, j));\n                 }\n         MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int outCols = m.getColumnDimension();\n-        OpenMapRealMatrix out = new OpenMapRealMatrix(rowDimension, outCols);\n+        OpenMapRealMatrix out = new OpenMapRealMatrix(rows, outCols);\n         for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n             iterator.advance();\n             final double value = iterator.value();\n             final int key      = iterator.key();\n-            final int i        = key / columnDimension;\n-            final int k        = key % columnDimension;\n+            final int i        = key / columns;\n+            final int k        = key % columns;\n             for (int j = 0; j < outCols; ++j) {\n                 final int rightKey = m.computeKey(k, j);\n                 if (m.entries.containsKey(rightKey)) {\n     /** {@inheritDoc} */\n     @Override\n     public int getRowDimension() {\n-        return rowDimension;\n+        return rows;\n     }\n \n     /** {@inheritDoc} */\n      * @return key within the map to access the matrix element\n      */\n     private int computeKey(int row, int column) {\n-        return row * columnDimension + column;\n+        return row * columns + column;\n     }\n \n \n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n     /**\n      * row dimension\n      */\n-    private final int rowDimension;\n+    private final int rows;\n     /**\n      * column dimension\n      */\n-    private final int columnDimension;\n+    private final int columns;\n     \n \n     /**\n      */\n     public SparseFieldMatrix(final Field<T> field) {\n         super(field);\n-        rowDimension = 0;\n-        columnDimension= 0;\n+        rows = 0;\n+        columns= 0;\n         entries = new OpenIntToFieldHashMap<T>(field);\n     }\n \n                              final int rowDimension, final int columnDimension)\n         throws IllegalArgumentException {\n         super(field, rowDimension, columnDimension);\n-        this.rowDimension = rowDimension;\n-        this.columnDimension = columnDimension;\n+        this.rows = rowDimension;\n+        this.columns = columnDimension;\n         entries = new OpenIntToFieldHashMap<T>(field);\n     }\n     \n      */\n     public SparseFieldMatrix(SparseFieldMatrix<T> other) {\n         super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n-        rowDimension = other.getRowDimension();\n-        columnDimension = other.getColumnDimension();\n+        rows = other.getRowDimension();\n+        columns = other.getColumnDimension();\n         entries = new OpenIntToFieldHashMap<T>(other.entries);\n     }\n \n      */\n     public SparseFieldMatrix(FieldMatrix<T> other){\n         super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n-        rowDimension = other.getRowDimension();\n-        columnDimension = other.getColumnDimension();\n+        rows = other.getRowDimension();\n+        columns = other.getColumnDimension();\n         entries = new OpenIntToFieldHashMap<T>(getField());\n-        for (int i = 0; i < rowDimension; i++) {\n-            for (int j = 0; j < columnDimension; j++) {\n+        for (int i = 0; i < rows; i++) {\n+            for (int j = 0; j < columns; j++) {\n                 setEntry(i, j, other.getEntry(i, j));\n             }\n         }\n     /** {@inheritDoc} */\n     @Override\n     public int getColumnDimension() {\n-        return columnDimension;\n+        return columns;\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     @Override\n     public int getRowDimension() {\n-        return rowDimension;\n+        return rows;\n     }\n \n     /** {@inheritDoc} */\n      * @return key within the map to access the matrix element\n      */\n     private int computeKey(int row, int column) {\n-        return row * columnDimension + column;\n+        return row * columns + column;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n     }\n \n     /** Perform some sanity checks on the integration parameters.\n-     * @param equations differential equations set\n+     * @param ode differential equations set\n      * @param t0 start time\n      * @param y0 state vector at t0\n      * @param t target time for the integration\n      * @param y placeholder where to put the state vector\n      * @exception IntegratorException if some inconsistency is detected\n      */\n-    protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+    protected void sanityChecks(final FirstOrderDifferentialEquations ode,\n                                 final double t0, final double[] y0,\n                                 final double t, final double[] y)\n         throws IntegratorException {\n \n-        if (equations.getDimension() != y0.length) {\n+        if (ode.getDimension() != y0.length) {\n             throw new IntegratorException(\n                     \"dimensions mismatch: ODE problem has dimension {0},\" +\n                     \" initial state vector has dimension {1}\",\n-                    equations.getDimension(), y0.length);\n-        }\n-\n-        if (equations.getDimension() != y.length) {\n+                    ode.getDimension(), y0.length);\n+        }\n+\n+        if (ode.getDimension() != y.length) {\n             throw new IntegratorException(\n                     \"dimensions mismatch: ODE problem has dimension {0},\" +\n                     \" final state vector has dimension {1}\",\n-                    equations.getDimension(), y.length);\n+                    ode.getDimension(), y.length);\n         }\n \n         if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n      * <p>The various step and event handlers for this starter integrator\n      * will be managed automatically by the multi-step integrator. Any\n      * user configuration for these elements will be cleared before use.</p>\n-     * @param starter starter integrator\n-     */\n-    public void setStarterIntegrator(FirstOrderIntegrator starter) {\n-        this.starter = starter;\n+     * @param starterIntegrator starter integrator\n+     */\n+    public void setStarterIntegrator(FirstOrderIntegrator starterIntegrator) {\n+        this.starter = starterIntegrator;\n     }\n \n     /** Start the integration.\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n     }\n \n     /** Reinitialize the beginning of the step.\n-     * @param t0 value of the independent <i>time</i> variable at the\n+     * @param tStart value of the independent <i>time</i> variable at the\n      * beginning of the step\n-     * @param y0 array containing the current value of the state vector\n+     * @param yStart array containing the current value of the state vector\n      * at the beginning of the step\n      * @exception EventException if the event handler\n      * value cannot be evaluated at the beginning of the step\n      */\n-    public void reinitializeBegin(final double t0, final double[] y0)\n+    public void reinitializeBegin(final double tStart, final double[] yStart)\n         throws EventException {\n-        this.t0 = t0;\n-        g0 = handler.g(t0, y0);\n+        t0 = tStart;\n+        g0 = handler.g(tStart, yStart);\n         g0Positive = (g0 >= 0);\n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n    * <p>By default, the test is performed, at most during two\n    * iterations at each step, and at most once for each of these\n    * iterations. The default stepsize reduction factor is 0.5.</p>\n-   * @param performTest if true, stability check will be performed,\n+   * @param performStabilityCheck if true, stability check will be performed,\n      if false, the check will be skipped\n-   * @param maxIter maximal number of iterations for which checks are\n+   * @param maxNumIter maximal number of iterations for which checks are\n    * performed (the number of iterations is reset to default if negative\n    * or null)\n-   * @param maxChecks maximal number of checks for each iteration\n+   * @param maxNumChecks maximal number of checks for each iteration\n    * (the number of checks is reset to default if negative or null)\n-   * @param stabilityReduction stepsize reduction factor in case of\n+   * @param stepsizeReductionFactor stepsize reduction factor in case of\n    * failure (the factor is reset to default if lower than 0.0001 or\n    * greater than 0.9999)\n    */\n-  public void setStabilityCheck(final boolean performTest,\n-                                final int maxIter, final int maxChecks,\n-                                final double stabilityReduction) {\n-\n-    this.performTest = performTest;\n-    this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;\n-    this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;\n-\n-    if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {\n+  public void setStabilityCheck(final boolean performStabilityCheck,\n+                                final int maxNumIter, final int maxNumChecks,\n+                                final double stepsizeReductionFactor) {\n+\n+    this.performTest = performStabilityCheck;\n+    this.maxIter     = (maxNumIter   <= 0) ? 2 : maxNumIter;\n+    this.maxChecks   = (maxNumChecks <= 0) ? 1 : maxNumChecks;\n+\n+    if ((stepsizeReductionFactor < 0.0001) || (stepsizeReductionFactor > 0.9999)) {\n       this.stabilityReduction = 0.5;\n     } else {\n-      this.stabilityReduction = stabilityReduction;\n+      this.stabilityReduction = stepsizeReductionFactor;\n     }\n \n   }\n    * </pre>\n    * The default values are 0.02 for stepControl3 and 4.0 for\n    * stepControl4.</p>\n-   * @param stepControl1 first stepsize control factor (the factor is\n+   * @param control1 first stepsize control factor (the factor is\n    * reset to default if lower than 0.0001 or greater than 0.9999)\n-   * @param stepControl2 second stepsize control factor (the factor\n+   * @param control2 second stepsize control factor (the factor\n    * is reset to default if lower than 0.0001 or greater than 0.9999)\n-   * @param stepControl3 third stepsize control factor (the factor is\n+   * @param control3 third stepsize control factor (the factor is\n    * reset to default if lower than 0.0001 or greater than 0.9999)\n-   * @param stepControl4 fourth stepsize control factor (the factor\n+   * @param control4 fourth stepsize control factor (the factor\n    * is reset to default if lower than 1.0001 or greater than 999.9)\n    */\n-  public void setStepsizeControl(final double stepControl1, final double stepControl2,\n-                                 final double stepControl3, final double stepControl4) {\n-\n-    if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {\n+  public void setStepsizeControl(final double control1, final double control2,\n+                                 final double control3, final double control4) {\n+\n+    if ((control1 < 0.0001) || (control1 > 0.9999)) {\n       this.stepControl1 = 0.65;\n     } else {\n-      this.stepControl1 = stepControl1;\n-    }\n-\n-    if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {\n+      this.stepControl1 = control1;\n+    }\n+\n+    if ((control2 < 0.0001) || (control2 > 0.9999)) {\n       this.stepControl2 = 0.94;\n     } else {\n-      this.stepControl2 = stepControl2;\n-    }\n-\n-    if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {\n+      this.stepControl2 = control2;\n+    }\n+\n+    if ((control3 < 0.0001) || (control3 > 0.9999)) {\n       this.stepControl3 = 0.02;\n     } else {\n-      this.stepControl3 = stepControl3;\n-    }\n-\n-    if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {\n+      this.stepControl3 = control3;\n+    }\n+\n+    if ((control4 < 1.0001) || (control4 > 999.9)) {\n       this.stepControl4 = 4.0;\n     } else {\n-      this.stepControl4 = stepControl4;\n+      this.stepControl4 = control4;\n     }\n \n   }\n    * <p>The default maximal order after construction is 18 (i.e. the\n    * maximal number of columns is 9). The default values are 0.8 for\n    * orderControl1 and 0.9 for orderControl2.</p>\n-   * @param maxOrder maximal order in the extrapolation table (the\n+   * @param maximalOrder maximal order in the extrapolation table (the\n    * maximal order is reset to default if order <= 6 or odd)\n-   * @param orderControl1 first order control factor (the factor is\n+   * @param control1 first order control factor (the factor is\n    * reset to default if lower than 0.0001 or greater than 0.9999)\n-   * @param orderControl2 second order control factor (the factor\n+   * @param control2 second order control factor (the factor\n    * is reset to default if lower than 0.0001 or greater than 0.9999)\n    */\n-  public void setOrderControl(final int maxOrder,\n-                              final double orderControl1, final double orderControl2) {\n-\n-    if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {\n+  public void setOrderControl(final int maximalOrder,\n+                              final double control1, final double control2) {\n+\n+    if ((maximalOrder <= 6) || (maximalOrder % 2 != 0)) {\n       this.maxOrder = 18;\n     }\n \n-    if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {\n+    if ((control1 < 0.0001) || (control1 > 0.9999)) {\n       this.orderControl1 = 0.8;\n     } else {\n-      this.orderControl1 = orderControl1;\n-    }\n-\n-    if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {\n+      this.orderControl1 = control1;\n+    }\n+\n+    if ((control2 < 0.0001) || (control2 > 0.9999)) {\n       this.orderControl2 = 0.9;\n     } else {\n-      this.orderControl2 = orderControl2;\n+      this.orderControl2 = control2;\n     }\n \n     // reinitialize the arrays\n    * default value for mudif is 4 and the interpolation error is used\n    * in stepsize control by default.\n \n-   * @param useInterpolationError if true, interpolation error is used\n+   * @param useInterpolationErrorForControl if true, interpolation error is used\n    * for stepsize control\n-   * @param mudif interpolation order control parameter (the parameter\n+   * @param mudifControlParameter interpolation order control parameter (the parameter\n    * is reset to default if <= 0 or >= 7)\n    */\n-  public void setInterpolationControl(final boolean useInterpolationError,\n-                                      final int mudif) {\n-\n-    this.useInterpolationError = useInterpolationError;\n-\n-    if ((mudif <= 0) || (mudif >= 7)) {\n+  public void setInterpolationControl(final boolean useInterpolationErrorForControl,\n+                                      final int mudifControlParameter) {\n+\n+    this.useInterpolationError = useInterpolationErrorForControl;\n+\n+    if ((mudifControlParameter <= 0) || (mudifControlParameter >= 7)) {\n       this.mudif = 4;\n     } else {\n-      this.mudif = mudif;\n+      this.mudif = mudifControlParameter;\n     }\n \n   }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n    * {@link AbstractStepInterpolator#getInterpolatedState\n    * getInterpolatedState} method (for an interpolator which needs a\n    * finalization) or if it clones the step interpolator.</p>\n-   * @param integrator integrator being used\n+   * @param rkIntegrator integrator being used\n    * @param y reference to the integrator array holding the state at\n    * the end of the step\n-   * @param yDotK reference to the integrator array holding all the\n+   * @param yDotArray reference to the integrator array holding all the\n    * intermediate slopes\n    * @param forward integration direction indicator\n    */\n-  public void reinitialize(final AbstractIntegrator integrator,\n-                           final double[] y, final double[][] yDotK, final boolean forward) {\n+  public void reinitialize(final AbstractIntegrator rkIntegrator,\n+                           final double[] y, final double[][] yDotArray, final boolean forward) {\n     reinitialize(y, forward);\n-    this.yDotK = yDotK;\n-    this.integrator = integrator;\n+    this.yDotK = yDotArray;\n+    this.integrator = rkIntegrator;\n   }\n \n   /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n   /** Reinitialize the instance\n    * @param y reference to the integrator array holding the state at\n    * the end of the step\n-   * @param forward integration direction indicator\n-   */\n-  protected void reinitialize(final double[] y, final boolean forward) {\n+   * @param isForward integration direction indicator\n+   */\n+  protected void reinitialize(final double[] y, final boolean isForward) {\n \n     previousTime      = Double.NaN;\n     currentTime       = Double.NaN;\n     interpolatedDerivatives = new double[y.length];\n \n     finalized         = false;\n-    this.forward      = forward;\n+    this.forward      = isForward;\n     this.dirtyState   = true;\n \n   }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n     /** Reinitialize the instance.\n      * <p>Beware that all arrays <em>must</em> be references to integrator\n      * arrays, in order to ensure proper update without copy.</p>\n-     * @param referenceTime time at which all arrays are defined\n-     * @param scalingH step size used in the scaled and nordsieck arrays\n-     * @param scaled reference to the integrator array holding the first\n+     * @param time time at which all arrays are defined\n+     * @param stepSize step size used in the scaled and nordsieck arrays\n+     * @param scaledDerivative reference to the integrator array holding the first\n      * scaled derivative\n-     * @param nordsieck reference to the integrator matrix holding the\n+     * @param nordsieckVector reference to the integrator matrix holding the\n      * nordsieck vector\n      */\n-    public void reinitialize(final double referenceTime, final double scalingH,\n-                             final double[] scaled, final Array2DRowRealMatrix nordsieck) {\n-        this.referenceTime = referenceTime;\n-        this.scalingH      = scalingH;\n-        this.scaled        = scaled;\n-        this.nordsieck     = nordsieck;\n+    public void reinitialize(final double time, final double stepSize,\n+                             final double[] scaledDerivative,\n+                             final Array2DRowRealMatrix nordsieckVector) {\n+        this.referenceTime = time;\n+        this.scalingH      = stepSize;\n+        this.scaled        = scaledDerivative;\n+        this.nordsieck     = nordsieckVector;\n \n         // make sure the state and derivatives will depend on the new arrays\n         setInterpolatedTime(getInterpolatedTime());\n     /** Rescale the instance.\n      * <p>Since the scaled and Nordiseck arrays are shared with the caller,\n      * this method has the side effect of rescaling this arrays in the caller too.</p>\n-     * @param scalingH new step size to use in the scaled and nordsieck arrays\n-     */\n-    public void rescale(final double scalingH) {\n-\n-        final double ratio = scalingH / this.scalingH;\n+     * @param stepSize new step size to use in the scaled and nordsieck arrays\n+     */\n+    public void rescale(final double stepSize) {\n+\n+        final double ratio = stepSize / scalingH;\n         for (int i = 0; i < scaled.length; ++i) {\n             scaled[i] *= ratio;\n         }\n             }\n         }\n \n-        this.scalingH = scalingH;\n+        scalingH = stepSize;\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker checker) {\n-        this.checker = checker;\n+    public void setConvergenceChecker(RealConvergenceChecker convergenceChecker) {\n+        this.checker = convergenceChecker;\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public RealPointValuePair optimize(final MultivariateRealFunction f,\n-                                         final GoalType goalType,\n-                                         final double[] startPoint)\n+    public RealPointValuePair optimize(final MultivariateRealFunction function,\n+                                       final GoalType goalType,\n+                                       final double[] startPoint)\n         throws FunctionEvaluationException, OptimizationException,\n         IllegalArgumentException {\n \n             setStartConfiguration(unit);\n         }\n \n-        this.f = f;\n+        this.f = function;\n         final Comparator<RealPointValuePair> comparator =\n             new Comparator<RealPointValuePair>() {\n                 public int compare(final RealPointValuePair o1,\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n     protected int rows;\n \n     /** Objective function. */\n-    private DifferentiableMultivariateVectorialFunction f;\n+    private DifferentiableMultivariateVectorialFunction function;\n \n     /** Objective function derivatives. */\n     private MultivariateMatrixFunction jF;\n \n     /** Target value for the objective functions at optimum. */\n-    protected double[] target;\n+    protected double[] targetValues;\n \n     /** Weight for the least squares cost computation. */\n-    protected double[] weights;\n+    protected double[] residualsWeights;\n \n     /** Current point. */\n     protected double[] point;\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(VectorialConvergenceChecker checker) {\n-        this.checker = checker;\n+    public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker) {\n+        this.checker = convergenceChecker;\n     }\n \n     /** {@inheritDoc} */\n         }\n         for (int i = 0; i < rows; i++) {\n             final double[] ji = jacobian[i];\n-            final double factor = -Math.sqrt(weights[i]);\n+            final double factor = -Math.sqrt(residualsWeights[i]);\n             for (int j = 0; j < cols; ++j) {\n                 ji[j] *= factor;\n             }\n             throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                   point);\n         }\n-        objective = f.value(point);\n+        objective = function.value(point);\n         if (objective.length != rows) {\n             throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n                                                   objective.length, rows);\n         }\n         cost = 0;\n         for (int i = 0, index = 0; i < rows; i++, index += cols) {\n-            final double residual = target[i] - objective[i];\n+            final double residual = targetValues[i] - objective[i];\n             residuals[i] = residual;\n-            cost += weights[i] * residual * residual;\n+            cost += residualsWeights[i] * residual * residual;\n         }\n         cost = Math.sqrt(cost);\n \n         double criterion = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            criterion += weights[i] * residual * residual;\n+            criterion += residualsWeights[i] * residual * residual;\n         }\n         return Math.sqrt(criterion / rows);\n     }\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / weights[i];\n+            chiSquare += residual * residual / residualsWeights[i];\n         }\n         return chiSquare;\n     }\n         jacobianEvaluations  = 0;\n \n         // store least squares problem characteristics\n-        this.f         = f;\n-        jF             = f.jacobian();\n-        this.target    = target.clone();\n-        this.weights   = weights.clone();\n-        this.point     = startPoint.clone();\n-        this.residuals = new double[target.length];\n+        function         = f;\n+        jF               = f.jacobian();\n+        targetValues     = target.clone();\n+        residualsWeights = weights.clone();\n+        this.point       = startPoint.clone();\n+        this.residuals   = new double[target.length];\n \n         // arrays shared with the other private methods\n         rows      = target.length;\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n     protected RealConvergenceChecker checker;\n \n     /** Objective function. */\n-    private DifferentiableMultivariateRealFunction f;\n+    private DifferentiableMultivariateRealFunction function;\n \n     /** Objective function gradient. */\n     private MultivariateVectorialFunction gradient;\n \n     /** Type of optimization. */\n-    protected GoalType goalType;\n+    protected GoalType goal;\n \n     /** Current point set. */\n     protected double[] point;\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker checker) {\n-        this.checker = checker;\n+    public void setConvergenceChecker(RealConvergenceChecker convergenceChecker) {\n+        this.checker = convergenceChecker;\n     }\n \n     /** {@inheritDoc} */\n \n     /** \n      * Compute the gradient vector.\n-     * @param point point at which the gradient must be evaluated\n+     * @param evaluationPoint point at which the gradient must be evaluated\n      * @return gradient at the specified point\n      * @exception FunctionEvaluationException if the function gradient\n      */\n-    protected double[] computeObjectiveGradient(final double[] point)\n+    protected double[] computeObjectiveGradient(final double[] evaluationPoint)\n         throws FunctionEvaluationException {\n         ++gradientEvaluations;\n-        return gradient.value(point);\n+        return gradient.value(evaluationPoint);\n     }\n \n     /** \n      * Compute the objective function value.\n-     * @param point point at which the objective function must be evaluated\n+     * @param evaluationPoint point at which the objective function must be evaluated\n      * @return objective function value at specified point\n      * @exception FunctionEvaluationException if the function cannot be evaluated\n      * or its dimension doesn't match problem dimension or the maximal number\n      * of iterations is exceeded\n      */\n-    protected double computeObjectiveValue(final double[] point)\n+    protected double computeObjectiveValue(final double[] evaluationPoint)\n         throws FunctionEvaluationException {\n         if (++evaluations > maxEvaluations) {\n             throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n-                                                  point);\n+                                                  evaluationPoint);\n         }\n-        return f.value(point);\n+        return function.value(evaluationPoint);\n     }\n \n     /** {@inheritDoc} */\n         gradientEvaluations = 0;\n \n         // store optimization problem characteristics\n-        this.f        = f;\n-        gradient      = f.gradient();\n-        this.goalType = goalType;\n-        point         = startPoint.clone();\n+        function = f;\n+        gradient = f.gradient();\n+        goal     = goalType;\n+        point    = startPoint.clone();\n \n         return doOptimize();\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n             for (int i = 0; i < rows; ++i) {\n \n                 final double[] grad   = jacobian[i];\n-                final double weight   = weights[i];\n-                final double residual = objective[i] - target[i];\n+                final double weight   = residualsWeights[i];\n+                final double residual = objective[i] - targetValues[i];\n \n                 // compute the normal equation\n                 final double wr = weight * residual;\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n \n     /**\n      * Set the solver to use during line search.\n-     * @param solver solver to use during line search, may be null\n+     * @param lineSearchSolver solver to use during line search, may be null\n      * to remove an already registered solver and fall back to the\n      * default {@link BrentSolver Brent solver}.\n      */\n-    public void setLineSearchSolver(final UnivariateRealSolver solver) {\n-        this.solver = solver;\n+    public void setLineSearchSolver(final UnivariateRealSolver lineSearchSolver) {\n+        this.solver = lineSearchSolver;\n     }\n \n     /**\n             }\n             final int n = point.length;\n             double[] r = computeObjectiveGradient(point);\n-            if (goalType == GoalType.MINIMIZE) {\n+            if (goal == GoalType.MINIMIZE) {\n                 for (int i = 0; i < n; ++i) {\n                     r[i] = -r[i];\n                 }\n                     point[i] += step * searchDirection[i];\n                 }\n                 r = computeObjectiveGradient(point);\n-                if (goalType == GoalType.MINIMIZE) {\n+                if (goal == GoalType.MINIMIZE) {\n                     for (int i = 0; i < n; ++i) {\n                         r[i] = -r[i];\n                     }\n--- a/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n     private int iterations;\n \n     /** Linear objective function. */\n-    protected LinearObjectiveFunction f;\n+    protected LinearObjectiveFunction function;\n \n     /** Linear constraints. */\n-    protected Collection<LinearConstraint> constraints;\n+    protected Collection<LinearConstraint> linearConstraints;\n \n     /** Type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}. */\n-    protected GoalType goalType;\n+    protected GoalType goal;\n \n     /** Whether to restrict the variables to non-negative values. */\n-    protected boolean restrictToNonNegative;\n+    protected boolean nonNegative;\n \n     /** Simple constructor with default settings.\n      * <p>The maximal number of evaluation is set to its default value.</p>\n          throws OptimizationException {\n \n         // store linear problem characteristics\n-        this.f                     = f;\n-        this.constraints           = constraints;\n-        this.goalType              = goalType;\n-        this.restrictToNonNegative = restrictToNonNegative;\n+        this.function          = f;\n+        this.linearConstraints = constraints;\n+        this.goal              = goalType;\n+        this.nonNegative       = restrictToNonNegative;\n \n         iterations  = 0;\n \n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n     public RealPointValuePair doOptimize()\n         throws OptimizationException {\n         final SimplexTableau tableau =\n-            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);\n+            new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n         solvePhase1(tableau);\n         tableau.discardArtificialVariables();\n         while (!isOptimal(tableau)) {\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n \n     /**\n      * Get new versions of the constraints which have positive right hand sides.\n-     * @param constraints original (not normalized) constraints\n+     * @param originalConstraints original (not normalized) constraints\n      * @return new versions of the constraints\n      */\n-    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> constraints) {\n+    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {\n         List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n-        for (LinearConstraint constraint : constraints) {\n+        for (LinearConstraint constraint : originalConstraints) {\n             normalized.add(normalize(constraint));\n         }\n         return normalized;\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n                     \"upper bound ({0}) must be greater than lower bound ({1})\",\n                     upper, lower);\n         }\n-        RandomGenerator rand = getRan();\n-        double r = rand.nextDouble();\n+        double r = getRan().nextDouble();\n         return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n     }\n \n                   \"upper bound ({0}) must be greater than lower bound ({1})\",\n                   upper, lower);\n         }\n-        RandomGenerator rand = getRan();\n-        double r = rand.nextDouble();\n+        double r = getRan().nextDouble();\n         return (long) ((r * upper) + ((1.0 - r) * lower) + r);\n     }\n \n                   \"the Poisson mean must be positive ({0})\", mean);\n         }\n \n-        RandomGenerator rand = getRan();\n+        final RandomGenerator generator = getRan();\n \n         double pivot = 6.0;\n         if (mean < pivot) {\n             double rnd = 1.0d;\n \n             while (n < 1000 * mean) {\n-                rnd = rand.nextDouble();\n+                rnd = generator.nextDouble();\n                 r = r * rnd;\n                 if (r >= p) {\n                     n++;\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"standard deviation must be positive ({0})\", sigma);\n         }\n-        RandomGenerator rand = getRan();\n-        return sigma * rand.nextGaussian() + mu;\n+        return sigma * getRan().nextGaussian() + mu;\n     }\n \n     /**\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"mean must be positive ({0})\", mean);\n         }\n-        RandomGenerator rand = getRan();\n-        double unif = rand.nextDouble();\n+        final RandomGenerator generator = getRan();\n+        double unif = generator.nextDouble();\n         while (unif == 0.0d) {\n-            unif = rand.nextDouble();\n+            unif = generator.nextDouble();\n         }\n         return -mean * Math.log(unif);\n     }\n                   \"upper bound ({0}) must be greater than lower bound ({1})\",\n                   upper, lower);\n         }\n-        RandomGenerator rand = getRan();\n+        final RandomGenerator generator = getRan();\n \n         // ensure nextDouble() isn't 0.0\n-        double u = rand.nextDouble();\n+        double u = generator.nextDouble();\n         while (u <= 0.0) {\n-            u = rand.nextDouble();\n+            u = generator.nextDouble();\n         }\n \n         return lower + u * (upper - lower);\n--- a/src/main/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n      * input rectangular array.  The columns of the array represent values\n      * of variables to be correlated.\n      * \n-     * @param data matrix with columns representing variables to correlate\n+     * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(double[][] data) {\n-       return computeCorrelationMatrix(new BlockRealMatrix(data));\n+    public RealMatrix computeCorrelationMatrix(double[][] matrix) {\n+       return computeCorrelationMatrix(new BlockRealMatrix(matrix));\n     }\n     \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n     }\n \n     /**\n-     * @param isBiasCorrected The isBiasCorrected to set.\n-     */\n-    public void setBiasCorrected(boolean isBiasCorrected) {\n-        this.isBiasCorrected = isBiasCorrected;\n+     * @param biasCorrected The isBiasCorrected to set.\n+     */\n+    public void setBiasCorrected(boolean biasCorrected) {\n+        this.isBiasCorrected = biasCorrected;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/inference/TestUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TestUtils.java\n     /**\n      * Set the (singleton) TTest instance.\n      * \n-     * @param tTest the new instance to use\n-     * @since 1.2\n-     */\n-    public static void setChiSquareTest(TTest tTest) {\n-        TestUtils.tTest = tTest;\n+     * @param chiSquareTest the new instance to use\n+     * @since 1.2\n+     */\n+    public static void setChiSquareTest(TTest chiSquareTest) {\n+        TestUtils.tTest = chiSquareTest;\n     }\n     \n     /**\n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      * IllegalArgumentException if the contractionCriteria is less than the \n      * expansionCriteria\n      * \n-     * @param expansionFactor factor to be checked\n-     * @param contractionCriteria criteria to be checked\n+     * @param expansion factor to be checked\n+     * @param contraction criteria to be checked\n      * @throws IllegalArgumentException if the contractionCriteria is less than\n      *         the expansionCriteria.\n      */\n-    protected void checkContractExpand(\n-        float contractionCriteria,\n-        float expansionFactor) {\n-\n-        if (contractionCriteria < expansionFactor) {\n+    protected void checkContractExpand(float contraction, float expansion) {\n+\n+        if (contraction < expansion) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would \" +\n                     \"lead to a never ending loop of expansion and contraction as a newly expanded \" +\n                     \"internal storage array would immediately satisfy the criteria for contraction\",\n-                    contractionCriteria, expansionFactor);\n-        }\n-\n-        if (contractionCriteria <= 1.0) {\n+                    contraction, expansion);\n+        }\n+\n+        if (contraction <= 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"contraction criteria smaller than one ({0}).  This would lead to a never ending \" +\n                     \"loop of expansion and contraction as an internal storage array length equal \" +\n                     \"to the number of elements would satisfy the contraction criteria.\",\n-                    contractionCriteria);\n-        }\n-\n-        if (expansionFactor <= 1.0) {\n+                    contraction);\n+        }\n+\n+        if (expansion <= 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"expansion factor smaller than one ({0})\",\n-                    expansionFactor);\n+                    expansion);\n         }\n     }\n     \n--- a/src/test/java/org/apache/commons/math/genetics/DummyBinaryChromosome.java\n+++ b/src/test/java/org/apache/commons/math/genetics/DummyBinaryChromosome.java\n     }\n \n     @Override\n-    public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> representation) {\n-        return new DummyBinaryChromosome(representation);\n+    public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> chromosomeRepresentation) {\n+        return new DummyBinaryChromosome(chromosomeRepresentation);\n     }\n \n     public double fitness() {\n--- a/src/test/java/org/apache/commons/math/genetics/DummyRandomKey.java\n+++ b/src/test/java/org/apache/commons/math/genetics/DummyRandomKey.java\n     }\n \n     @Override\n-    public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> representation) {\n-        return new DummyRandomKey(representation);\n+    public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> chromosomeRepresentation) {\n+        return new DummyRandomKey(chromosomeRepresentation);\n     }\n \n     public double fitness() {\n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n         }\n \n         @Override\n-        public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> representation) {\n-            return new FindOnes(representation);\n+        public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> chromosomeRepresentation) {\n+            return new FindOnes(chromosomeRepresentation);\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n         }\n \n         @Override\n-        public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> representation) {\n-            return new MinPermutations(representation);\n+        public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> chromosomeRepresentation) {\n+            return new MinPermutations(chromosomeRepresentation);\n         }\n     }\n }", "timestamp": 1251838979, "metainfo": ""}