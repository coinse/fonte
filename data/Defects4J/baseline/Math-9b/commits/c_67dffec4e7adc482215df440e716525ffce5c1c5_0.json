{"sha": "67dffec4e7adc482215df440e716525ffce5c1c5", "log": "Added support for atan2 in DSCompiler.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n                       final double[] x, final int xOffset,\n                       final double[] result, final int resultOffset) {\n \n-        final double y0 = y[yOffset];\n-        final double x0 = x[xOffset];\n-        result[resultOffset] = FastMath.atan2(y0, x0);\n-        if (order > 0) {\n-            for (int i = 1; i <= order; ++i) {\n-                // TODO compute higher order derivatives\n-                result[resultOffset + i] = Double.NaN;\n-            }\n+        // compute r = sqrt(x^2+y^2)\n+        double[] tmp1 = new double[getSize()];\n+        multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n+        double[] tmp2 = new double[getSize()];\n+        multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n+        add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n+        rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n+\n+        if (x[xOffset] >= 0) {\n+\n+            // compute atan2(y, x) = 2 atan(y / (r + x))\n+            add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n+            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n+            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n+            for (int i = 0; i < tmp2.length; ++i) {\n+                result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n+            }\n+\n+        } else {\n+\n+            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n+            subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n+            divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n+            atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n+            result[resultOffset] =\n+                    ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n+            for (int i = 1; i < tmp2.length; ++i) {\n+                result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n+            }\n+\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n     }\n \n     @Test\n+    public void testAtan2() {\n+        double[] epsilon = new double[] { 5.0e-16, 3.0e-15, 2.0e-14, 1.0e-12, 8.0e-11 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = -1.7; x < 2; x += 0.2) {\n+                DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);\n+                for (double y = -1.7; y < 2; y += 0.2) {\n+                    DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);\n+                    DerivativeStructure atan2 = DerivativeStructure.atan2(dsY, dsX);\n+                    DerivativeStructure ref = dsY.divide(dsX).atan();\n+                    if (x < 0) {\n+                        ref = (y < 0) ? ref.subtract(FastMath.PI) : ref.add(FastMath.PI);\n+                    }\n+                    DerivativeStructure zero = atan2.subtract(ref);\n+                    for (int n = 0; n <= maxOrder; ++n) {\n+                        for (int m = 0; m <= maxOrder; ++m) {\n+                            if (n + m <= maxOrder) {\n+                                Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon[n + m]);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n     public void testCompositionOneVariableY() {\n         double epsilon = 1.0e-13;\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {", "timestamp": 1344863186, "metainfo": ""}