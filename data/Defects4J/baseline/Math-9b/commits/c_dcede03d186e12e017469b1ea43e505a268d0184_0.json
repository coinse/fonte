{"sha": "dcede03d186e12e017469b1ea43e505a268d0184", "log": "Initial commit of package refactorings discussed in the group.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/ConvergenceException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Error thrown when a numerical computation can not be performed because the\n+ * numerical result failed to converge to a finite value.\n+ * \n+ * @author Brent Worden\n+ */\n+public class ConvergenceException extends RuntimeException {\n+    /**\n+     * Construct an exception with the given message.\n+     * @param message descriptive error message. \n+     */\n+    public ConvergenceException(String message) {\n+        super(message);\n+    }\n+\n+    /**\n+     * Construct an exception with the given message and root cause.\n+     * @param message descriptive error message.\n+     * @param cause root cause.\n+     */\n+    public ConvergenceException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/RootFinding.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Utility class comprised of root finding techniques.\n+ *\n+ * @author Brent Worden\n+ */\n+public class RootFinding {\n+    /** Maximum allowed numerical error. */\n+    private static final double EPSILON = 10e-9;\n+\n+    /**\n+     * Default constructor. Prohibit construction.\n+     */\n+    private RootFinding() {\n+        super();\n+    }\n+\n+    /**\n+     * For a function, f, this method returns two values, a and b that bracket\n+     * a root of f.  That is to say, there exists a value c between a and b\n+     * such that f(c) = 0.\n+     *\n+     * @param function the function\n+     * @param initial midpoint of the returned range.\n+     * @param lowerBound for numerical safety, a never is less than this value.\n+     * @param upperBound for numerical safety, b never is greater than this value.\n+     * @return a two element array holding {a, b}.\n+     */\n+    public static double[] bracket(UnivariateFunction function,\n+                                   double initial,\n+                                   double lowerBound,\n+                                   double upperBound) {\n+        return bracket( function, initial, lowerBound, upperBound, Integer.MAX_VALUE ) ;\n+    }\n+\n+    /**\n+     * For a function, f, this method returns two values, a and b that bracket\n+     * a root of f.  That is to say, there exists a value c between a and b\n+     * such that f(c) = 0.\n+     *\n+     * @param function the function\n+     * @param initial midpoint of the returned range.\n+     * @param lowerBound for numerical safety, a never is less than this value.\n+     * @param upperBound for numerical safety, b never is greater than this value.\n+     * @param maximumIterations to guard against infinite looping, maximum number of iterations to perform\n+     * @return a two element array holding {a, b}.\n+     */\n+    public static double[] bracket(UnivariateFunction function,\n+                                   double initial,\n+                                   double lowerBound,\n+                                   double upperBound,\n+                                   int maximumIterations) {\n+        double a = initial;\n+        double b = initial;\n+        double fa;\n+        double fb;\n+        int numIterations = 0 ;\n+\n+        do {\n+            a = Math.max(a - 1.0, lowerBound);\n+            b = Math.min(b + 1.0, upperBound);\n+            fa = function.evaluate(a);\n+            fb = function.evaluate(b);\n+            numIterations += 1 ;\n+        } while ( (fa * fb > 0.0) && ( numIterations < maximumIterations ) );\n+\n+        return new double[]{a, b};\n+    }\n+\n+    /**\n+     * For a function, f, this method returns a root c that lies between a and\n+     * b, and satisfies f(c) = 0.\n+     *\n+     * @param function the function\n+     * @param a lower (or upper) bound of a root\n+     * @param b upper (or lower) bound of a root\n+     * @return a root of f\n+     */\n+    public static double bisection(UnivariateFunction function,\n+                                   double a,\n+                                   double b) {\n+        double m;\n+        double fm;\n+        double fa;\n+\n+        if ( b < a ) {\n+            double xtemp = a ;\n+            a = b ;\n+            b = xtemp ;\n+        }\n+\n+        fa = function.evaluate(a);\n+\n+        while(Math.abs(a - b) > EPSILON) {\n+            m = (a + b) * 0.5;  // midpoint\n+            fm = function.evaluate(m);\n+\n+            if(fm * fa > 0.0) {\n+                // b and m bracket the root.\n+                a = m;\n+                fa = fm;\n+            } else {\n+                // a and m bracket the root.\n+                b = m;\n+            }\n+        }\n+\n+        return (a + b) * 0.5;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateFunction.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * @author Brent Worden\n+ */\n+public interface UnivariateFunction {\n+    // TODO: More documentation\n+\n+    /**\n+     * \n+     */\n+    double evaluate(double x);\n+}\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n  */\n package org.apache.commons.math.stat.distribution;\n \n-import org.apache.commons.math.RootFinding;\n-import org.apache.commons.math.UnivariateFunction;\n+import org.apache.commons.math.analysis.RootFinding;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n \n /**\n  * Base class for various continuous distributions.  It provides default\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Interface defining a real-valued matrix with basic algebraic operations\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:57 $\n+ */\n+public interface RealMatrix {\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     *\n+     * @return matrix copy\n+     */\n+    RealMatrix copy();\n+    \n+    /**\n+     * Compute the sum of this and m.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    RealMatrix add(RealMatrix m) throws IllegalArgumentException;   \n+    \n+    /**\n+     * Compute this minus m.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    RealMatrix subtract(RealMatrix m) throws IllegalArgumentException;   \n+    \n+    /**\n+     * Returns the rank of the matrix.\n+     *\n+     * @return the rank of this matrix\n+     */\n+    int getRank();\n+    \n+     /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    RealMatrix scalarAdd(double d);\n+    \n+    /**\n+     * Returns the result multiplying each entry of this by d.\n+     *\n+     * @param d    value to multiply all entries by\n+     * @return     d * this\n+     */\n+    RealMatrix scalarMultiply(double d);\n+    \n+    /**\n+     * Returns the result postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException \n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    RealMatrix multiply(RealMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    double[][] getData();\n+    \n+    /**\n+     * Overwrites the underlying data for the matrix with\n+     * a fresh copy of <code>data</code>.\n+     *\n+     * @param  data  2-dimensional array of entries\n+     */\n+    void setData(double[][] data);\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/\n+     * MaximumAbsoluteRowSumNorm.html\">maximum absolute row sum norm</a> \n+     * of the matrix.\n+     *\n+     * @return norm\n+     */\n+    double getNorm();\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws IllegalArgumentException if row > rowDimension\n+     */\n+    double[] getRow(int row) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     *\n+     * @param col  column to fetch\n+     * @return array of entries in the column\n+     * @throws IllegalArgumentException if column > columnDimension\n+     */\n+    double[] getColumn(int col) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the entry in the specified row and column.\n+     *\n+     * @param row  row location of entry to be fetched  \n+     * @param column  column location of entry to be fetched\n+     * @return     matrix entry in row,column\n+     * @throws     IllegalArgumentException if entry does not exist\n+     */\n+    double getEntry(int row, int column) throws IllegalArgumentException;\n+    \n+    /**\n+     * Sets the entry in the specified row and column to the specified value.\n+     *\n+     * @param row    row location of entry to be set \n+     * @param column    column location of entry to be set\n+     * @param value  value to set \n+     * @throws IllegalArgumentException if entry does not exist\n+     */\n+    void setEntry(int row, int column, double value) \n+        throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the transpose of this matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    RealMatrix transpose();\n+    \n+    /**\n+     * Returns the inverse of this matrix.\n+     *\n+     * @return inverse matrix\n+     * @throws IllegalArgumentException if *this is not invertible\n+     */\n+    RealMatrix inverse() throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the determinant of this matrix.\n+     *\n+     * @return determinant\n+     */\n+    double getDeterminant();\n+    \n+    /**\n+     * Is this a square matrix?\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    boolean isSquare();\n+    \n+    /**\n+     * Is this a singular matrix?\n+     * @return true if the matrix is singular\n+     */\n+    boolean isSingular();\n+    \n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n+     * @return rowDimension\n+     */\n+    int getRowDimension();\n+    \n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n+     * @return columnDimension\n+     */\n+    int getColumnDimension();\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     */\n+    double getTrace();\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    double[] operate(double[] v) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    RealMatrix preMultiply(double[] v) throws IllegalArgumentException;  \n+    \n+    /**\n+     * Returns the solution vector for a linear system with coefficient\n+     * matrix = this and constant vector = <code>b</code>.\n+     *\n+     * @param b  constant vector\n+     * @return   vector of solution values to AX = b, where A is *this\n+     * @throws   IllegalArgumentException if rowDimension != b.length or matrix \n+     *           is singular\n+     */\n+    double[] solve(double[] b) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if rowDimension != row dimension of b\n+     * or this is singular\n+     */\n+    RealMatrix solve(RealMatrix b) throws IllegalArgumentException;\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.linear;\n+import java.io.Serializable;\n+\n+/**\n+ * Implementation for RealMatrix using a double[][] array to store entries\n+ * and <a href=\"http://www.math.gatech.edu/~bourbaki/\n+ * math2601/Web-notes/2num.pdf\">LU decompostion</a> to support linear system \n+ * solution and inverse.\n+ * <p>\n+ * The <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes\n+ * /2num.pdf\">LU decompostion</a> is performed as needed, to support the \n+ * following operations: <ul>\n+ * <li>solve</li>\n+ * <li>isSingular</li>\n+ * <li>getDeterminant</li>\n+ * <li>inverse</li> </ul>\n+ * <p>\n+ * <strong>Usage note</strong>:<br>\n+ * The LU decomposition is stored and reused on subsequent calls.  If matrix\n+ * data are modified using any of the public setXxx methods, the saved \n+ * decomposition is discarded.  If data are modified via references to the\n+ * underlying array obtained using <code>getDataRef()</code>, then the stored\n+ * LU decomposition will not be discarded.  In this case, you need to \n+ * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n+ * before using any of the methods above.\n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:57 $\n+ */\n+public class RealMatrixImpl implements RealMatrix, Serializable {\n+\n+    /** Entries of the matrix */\n+    private double data[][] = null;\n+    \n+    /** Entries of LU decomposition.\n+     * All updates to data (other than luDecompostion) *must* set this to null\n+     */\n+    private double lu[][] = null;\n+    \n+    /** Pivot array associated with LU decompostion */\n+    private int[] pivot = null;\n+    \n+    /** Parity of the permutation associated with the LU decomposition */\n+    private int parity = 1;\n+    \n+    /** Bound to determine effective singularity in LU decomposition */\n+    private static double TOO_SMALL = 10E-12;\n+    \n+    /** \n+     * Creates a matrix with no data\n+     */\n+    public RealMatrixImpl() {\n+    }\n+    \n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension      the number of rows in the new matrix\n+     * @param columnDimension   the number of columns in the new matrix\n+     */\n+    public RealMatrixImpl(int rowDimension,\n+    int columnDimension) {\n+        data = new double[rowDimension][columnDimension];\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new RealMatrix using the <code>data</code> as the underlying\n+     * data array.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param d data for new matrix\n+     */\n+    public RealMatrixImpl(double[][] d) {\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new (column) RealMatrix using <code>v</code> as the \n+     * data for the unique column of the <code>v.length x 1</code> matrix \n+     * created.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public RealMatrixImpl(double[] v) {\n+        int nRows = v.length;\n+        data = new double[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+    \n+    /**\n+     * Create a new RealMatrix which is a copy of this.\n+     *\n+     * @return  the cloned matrix\n+     */\n+    public RealMatrix copy() {\n+        return new RealMatrixImpl(this.copyOut());\n+    }\n+    \n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getColumnDimension() ||\n+        this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        }\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        double[][] mData = m.getData();\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] + mData[row][col];\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as *this\n+     */\n+    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getColumnDimension() ||\n+        this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        }\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        double[][] mData = m.getData();\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] - mData[row][col];\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns the rank of the matrix.\n+     *\n+     * @return the rank of this matrix\n+     */\n+    public int getRank() {\n+        // FIXME: need to add singular value decomposition or drop this\n+        throw new UnsupportedOperationException(\"not implemented yet\");\n+    }\n+    \n+    \n+    /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    public RealMatrix scalarAdd(double d) {\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] + d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns the result multiplying each entry of this by <code>d</code>\n+     * @param d  value to multiply all entries by\n+     * @return d * this\n+     */\n+    public RealMatrix scalarMultiply(double d) {\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] * d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns the result postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException\n+            (\"Matrices are not multiplication compatible.\");\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        double[][] mData = m.getData();\n+        double[][] outData =\n+        new double[nRows][nCols];\n+        double sum = 0;\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                sum = 0;\n+                for (int i = 0; i < nCols; i++) {\n+                    sum += data[row][i] * mData[i][col];\n+                }\n+                outData[row][col] = sum;\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     * <p>\n+     * Makes a fresh copy of the underlying data.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    public double[][] getData() {\n+        return copyOut();\n+    }\n+    \n+    /**\n+     * Overwrites the underlying data for the matrix\n+     * with a fresh copy of <code>inData</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setData(double[][] inData) {\n+        copyIn(inData);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does not make a fresh copy of the underlying data.\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public double[][] getDataRef() {\n+        return data;\n+    }\n+    \n+    /**\n+     * Overwrites the underlying data for the matrix\n+     * with a reference to <code>inData</code>.\n+     * <p>\n+     * Does not make a fresh copy of <code>data</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setDataRef(double[][] inData) {\n+        this.data = inData;\n+        lu = null;\n+    }\n+    \n+    /**\n+     *\n+     * @return norm\n+     */\n+    public double getNorm() {\n+        double maxColSum = 0;\n+        for (int col = 0; col < this.getColumnDimension(); col++) {\n+            double sum = 0;\n+            for (int row = 0; row < this.getRowDimension(); row++) {\n+                sum += Math.abs(data[row][col]);\n+            }\n+            maxColSum = Math.max(maxColSum, sum);\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /**\n+     *\n+     * @param row  the row to be fetched\n+     * @return array of entries in the row\n+     * @throws IllegalArgumentException if row > rowDimension or row < 1\n+     */\n+    public double[] getRow(int row) throws IllegalArgumentException {\n+        if (row > this.getRowDimension() || row < 1) {\n+            throw new IllegalArgumentException(\"illegal row argument\");\n+        }\n+        int ncols = this.getColumnDimension();\n+        double[] out = new double[ncols];\n+        System.arraycopy(data[row - 1], 0, out, 0, ncols);\n+        return out;\n+    }\n+    \n+    /**\n+     * @param col column to fetch\n+     * @return array of entries in the column\n+     * @throws IllegalArgumentException if column > columnDimension or\n+     * column < 1\n+     */\n+    public double[] getColumn(int col) throws IllegalArgumentException {\n+        if (col > this.getColumnDimension() || col < 1) {\n+            throw new IllegalArgumentException(\"illegal column argument\");\n+        }\n+        int nRows = this.getRowDimension();\n+        double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = data[row][col - 1];\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws IllegalArgumentException if entry does not exist\n+     */\n+    public double getEntry(int row, int column)\n+    throws IllegalArgumentException {\n+        if (row < 1 || column < 1 || row > this.getRowDimension()\n+        || column > this.getColumnDimension()) {\n+            throw new IllegalArgumentException\n+            (\"matrix entry does not exist\");\n+        }\n+        return data[row - 1][column - 1];\n+    }\n+    \n+    /**\n+     * @param row    row location of entry to be set\n+     * @param column    column location of entry to be set\n+     * @param value  value to set\n+     * @throws IllegalArgumentException if entry does not exist\n+     */\n+    public void setEntry(int row, int column, double value)\n+    throws IllegalArgumentException {\n+        if (row < 1 || column < 1 || row > this.getRowDimension()\n+        || column > this.getColumnDimension()) {\n+            throw new IllegalArgumentException\n+            (\"matrix entry does not exist\");\n+        }\n+        data[row - 1][column - 1] = value;\n+        lu = null;\n+    }\n+    \n+    /**\n+     *\n+     * @return transpose matrix\n+     */\n+    public RealMatrix transpose() {\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n+        double[][] outData = out.getDataRef();\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                outData[col][row] = data[row][col];\n+            }\n+        }\n+        return out;\n+    }   \n+    \n+    /**\n+     * @return inverse matrix\n+     * @throws IllegalArgumentException if this is not invertible\n+     */\n+    public RealMatrix inverse() throws IllegalArgumentException {\n+        return solve(getIdentity(this.getRowDimension()));\n+    }\n+    \n+    /**\n+     * @return determinant\n+     * @throws IllegalArgumentException if matrix is not square\n+     */\n+    public double getDeterminant() throws IllegalArgumentException {\n+        if (!isSquare()) {\n+            throw new IllegalArgumentException(\"matrix is not square\");\n+        }\n+        if (isSingular()) {  // note: this has side effect of attempting LU\n+            return 0d;        //       decomp if lu == null\n+        } else {\n+            double det = (double) parity;\n+            for (int i = 0; i < this.getRowDimension(); i++) {\n+                det *= lu[i][i];\n+            }\n+            return det;\n+        }\n+    }\n+    \n+    /**\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    public boolean isSquare() {\n+        return (this.getColumnDimension() == this.getRowDimension());\n+    }\n+    \n+    /**\n+     * @return true if the matrix is singular\n+     */\n+    public boolean isSingular() {\n+        if (lu == null) {\n+            try {\n+                LUDecompose();\n+                return false;\n+            } catch (IllegalArgumentException ex) {\n+                return true;\n+            }\n+        } else {            // LU decomp must have been successfully performed\n+            return false;   // so the matrix is not singular\n+        }\n+    }\n+    \n+    /**\n+     * @return rowDimension\n+     */\n+    public int getRowDimension() {\n+        return data.length;\n+    }\n+    \n+    /**\n+     * @return columnDimension\n+     */\n+    public int getColumnDimension() {\n+        return data[0].length;\n+    }\n+    \n+    /**\n+     * @return trace\n+     * @throws IllegalArgumentException if the matrix is not square\n+     */\n+    public double getTrace() throws IllegalArgumentException {\n+        if (!isSquare()) {\n+            throw new IllegalArgumentException(\"matrix is not square\");\n+        }\n+        double trace = data[0][0];\n+        for (int i = 1; i < this.getRowDimension(); i++) {\n+            trace += data[i][i];\n+        }\n+        return trace;\n+    }\n+    \n+    /**\n+     * @param v vector to operate on\n+     * @throws IllegalArgumentException if columnDimension != v.length\n+     * @return resulting vector\n+     */\n+    public double[] operate(double[] v) throws IllegalArgumentException {\n+        if (v.length != this.getColumnDimension()) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        double[] out = new double[v.length];\n+        for (int row = 0; row < nRows; row++) {\n+            double sum = 0;\n+            for (int i = 0; i < nCols; i++) {\n+                sum += data[row][i] * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+        return out;      \n+    }\n+    \n+    /**\n+     * @param v vector to premultiply by\n+     * @throws IllegalArgumentException if rowDimension != v.length\n+     * @return resulting matrix\n+     */\n+    public RealMatrix preMultiply(double[] v) throws IllegalArgumentException {\n+        int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        // being a bit lazy here -- probably should implement directly, like\n+        // operate\n+        RealMatrix pm = new RealMatrixImpl(v).transpose();\n+        return pm.multiply(this);     \n+    }\n+    \n+    /**\n+     * @param b  constant vector\n+     * @return   vector of solution values to AX = b, where A is this\n+     * @throws   IllegalArgumentException if rowDimension != b.length or matrix\n+     *           is singular\n+     */\n+    public double[] solve(double[] b) throws IllegalArgumentException {\n+        int nRows = this.getRowDimension();\n+        if (b.length != nRows) {\n+            throw new IllegalArgumentException\n+                (\"constant vector has wrong length\");\n+        }\n+        RealMatrix bMatrix = new RealMatrixImpl(b);\n+        double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n+        double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = solution[row][0];\n+        }\n+        return out;\n+    }\n+       \n+    /**\n+     * Uses LU decomposition, performing the composition if the matrix has\n+     * not been decomposed, or if there have been changes to the matrix since\n+     * the last decomposition.\n+     *\n+     * @param b the constant vector\n+     * @return solution matrix\n+     * @throws IllegalArgumentException if this is singular or dimensions\n+     * do not match.\n+     */\n+    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException {\n+        if (b.getRowDimension() != this.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (this.isSingular()) {  // side effect: compute LU decomp\n+            throw new IllegalArgumentException(\"Matrix is singular.\");\n+        }\n+        \n+        int nCol = this.getColumnDimension();\n+        int nRow = this.getRowDimension();\n+        int nColB = b.getColumnDimension();\n+        int nRowB = b.getRowDimension();\n+        \n+        // Apply permutations to b\n+        double[][] bv = b.getData();\n+        double[][] bp = new double[nRowB][nColB];\n+        for (int row = 0; row < nRowB; row++) {\n+            for (int col = 0; col < nColB; col++) {\n+                bp[row][col] = bv[pivot[row]][col];\n+            }\n+        }\n+        bv = null;\n+        \n+        // Solve LY = b\n+        for (int col = 0; col < nCol; col++) {\n+            for (int i = col + 1; i < nCol; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                }\n+            }\n+        }\n+        \n+        // Solve UX = Y\n+        for (int col = nCol - 1; col >= 0; col--) {\n+            for (int j = 0; j < nColB; j++) {\n+                bp[col][j] /= lu[col][col];\n+            }\n+            for (int i = 0; i < col; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                }\n+            }\n+        }\n+        \n+        RealMatrixImpl outMat = new RealMatrixImpl(bp);\n+        return outMat;\n+    }\n+    \n+    /**\n+     * Computes a new <a href=\"http://www.math.gatech.edu/~bourbaki/\n+     * math2601/Web-notes/2num.pdf\">LU decompostion</a> for this matrix,\n+     * storing the result for use by other methods.\n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/\n+     * people/sd/lectures/nummeth98/linear.htm\">Crout's algortithm</a>,\n+     * with partial pivoting.\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.\n+     *\n+     * @throws IllegalArgumentException if the matrix is singular\n+     */\n+    public void LUDecompose() throws IllegalArgumentException {\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        lu = this.getData();\n+        \n+        // Initialize pivot array and parity\n+        pivot = new int[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            pivot[row] = row;\n+        }\n+        parity = 1;\n+        \n+        // Loop over columns\n+        for (int col = 0; col < nCols; col++) {\n+            \n+            double sum = 0;\n+            \n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= lu[row][i] * lu[i][col];\n+                }\n+                lu[row][col] = sum;\n+            }\n+            \n+            // lower\n+            int max = col; // pivot row\n+            double largest = 0d;\n+            for (int row = col; row < nRows; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= lu[row][i] * lu[i][col];\n+                }\n+                lu[row][col] = sum;\n+                \n+                // maintain best pivot choice\n+                if (Math.abs(sum) > largest) {\n+                    largest = Math.abs(sum);\n+                    max = row;\n+                }\n+            }\n+            \n+            // Singularity check\n+            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n+                lu = null;\n+                throw new IllegalArgumentException(\"matrix is singular\");\n+            }\n+            \n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                for (int i = 0; i < nCols; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[max];\n+                pivot[max] = pivot[col];\n+                pivot[col] = temp;\n+                parity = -parity;\n+            }\n+            \n+            //Divide the lower elements by the \"winning\" diagonal elt.\n+            for (int row = col + 1; row < nRows; row++) {\n+                lu[row][col] /= lu[col][col];\n+            }\n+        }\n+    }\n+    \n+    //------------------------ Protected methods\n+    \n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     */\n+    protected RealMatrix getIdentity(int dimension) {\n+        RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n+        double[][] d = out.getDataRef();\n+        for (int row = 0; row < dimension; row++) {\n+            for (int col = 0; col < dimension; col++) {\n+                d[row][col] = row == col ? 1d : 0d;\n+            }\n+        }\n+        return out;\n+    }\n+    \n+    //------------------------ Private methods\n+    \n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private double[][] copyOut() {\n+        int nRows = this.getRowDimension();\n+        double[][] out =\n+            new double[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     *\n+     * @param in data to copy in\n+     */\n+    private void copyIn(double[][] in) {\n+        int nRows = in.length;\n+        int nCols = in[0].length;\n+        data = new double[nRows][nCols];\n+        System.arraycopy(in, 0, data, 0, in.length);\n+        for (int i = 0; i < nRows ; i++) {\n+            System.arraycopy(in[i], 0, data[i], 0, nCols);\n+        }\n+        lu = null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.stat.Univariate;\n+\n+/**\n+ * Represents an <a href=\"http://random.mat.sbg.ac.at/~ste/dipl/node11.html\">\n+ * empirical probability distribution</a> -- a probability distribution derived\n+ * from observed data without making any assumptions about the functional form\n+ * of the population distribution that the data come from.<p>\n+ * Implementations of this interface maintain data structures, called \n+ * <i>distribution digests</i>, that describe empirical distributions and \n+ * support the following operations: <ul>\n+ * <li>loading the distribution from a file of observed data values</li>\n+ * <li>saving and re-loading distribution digests to/from \"digest files\" </li>\n+ * <li>dividing the input data into \"bin ranges\" and reporting bin frequency\n+ *     counts (data for histogram)</li>\n+ * <li>reporting univariate statistics describing the full set of data values\n+ *     as well as the observations within each bin</li>\n+ * <li>generating random values from the distribution</li>\n+ * </ul>\n+ * Applications can use <code>EmpiricalDistribution</code> implementations to \n+ * build grouped frequnecy histograms representing the input data or to\n+ * generate random values \"like\" those in the input file -- i.e., the values\n+ * generated will follow the distribution of the values in the file.\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ */\n+public interface EmpiricalDistribution {\n+    \n+    /**\n+     * Computes the empirical distribution from the input file\n+     * @param filePath fully qualified name of a file in the local file system\n+     * @throws IOException if an IO error occurs\n+     */\n+    void load(String filePath) throws IOException; \n+    \n+    /**\n+     * Computes the empirical distribution from the input file\n+     * @param file url of the input file\n+     * @throws IOException if an IO error occurs\n+     */\n+    void load(File file) throws IOException;\n+    \n+    /** \n+     * Generates a random value from this distribution<p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    double getNextValue() throws IllegalStateException;  \n+    \n+     \n+    /** \n+     * <p>Returns a Univariate describing this distribution</p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    Univariate getSampleStats();\n+    \n+    /** \n+     * Loads a saved distribution from a file.\n+     * @param file File reference for a file containing a digested distribution\n+     * @throws IOException if an error occurs reading the file\n+     */\n+    void loadDistribution(File file) throws IOException;  \n+    \n+    /** \n+     * Loads a saved distribution from a file.\n+     * @param filePath fully qualified file path for a file \n+     * containing a digested distribution \n+     * @throws IOException if an error occurs reading the file\n+     */\n+    void loadDistribution(String filePath) throws IOException; \n+    \n+    /** \n+     * Saves distribution to a file. Overwrites the file if it exists.\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @param filePath fully qualified file path for the file to be written\n+     * @throws IOException if an error occurs reading the file\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    void saveDistribution(String filePath) throws \n+        IOException,IllegalStateException;\n+    \n+    /** \n+     * Saves distribution to a file. Overwrites the file if it exists.\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @param file File reference for the file to be written\n+     * @throws IOException if an error occurs reading the file\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    void saveDistribution(File file) throws IOException,IllegalStateException;\n+    \n+    /**\n+     * property indicating whether or not the distribution has been loaded\n+     * @return true if the distribution has been loaded\n+     */\n+    boolean isLoaded();  \n+    \n+     /** \n+     * Returns the number of bins\n+     * @return the number of bins.\n+     */\n+    int getBinCount();\n+    \n+    /** \n+     * Returns a list of Univariates containing statistics describing the\n+     * values in each of the bins.  The ArrayList is indexed on the bin number.\n+     * @return ArrayList of bin statistics.\n+     */\n+    ArrayList getBinStats();\n+    \n+    /** \n+     * Returns the array of upper bounds for the bins.  Bins are: <br>\n+     * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n+     *  (upperBounds[binCount-1],max]\n+     * @return array of bin upper bounds\n+     */\n+    double[] getUpperBounds();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import java.util.ArrayList;\n+import java.io.Serializable;\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.stat.Univariate;\n+import org.apache.commons.math.stat.UnivariateImpl;\n+\n+/**\n+ * Implements <code>EmpiricalDistribution</code> interface using \n+ * what amounts to the \n+ * <a href=\"http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html\">\n+ * Variable Kernel Method</a> with Gaussian smoothing:<p>\n+ * <strong>Digesting the input file</strong>\n+ * <ol><li>Pass the file once to compute min and max.</li>  \n+ * <li>Divide the range from min-max into <code>binCount</code> \"bins.\"</li>\n+ * <li>Pass the data file again, computing bin counts and univariate\n+ *     statistics (mean, std dev.) for each of the bins </li>\n+ * <li>Divide the interval (0,1) into subintervals associated with the bins,\n+ *     with the length of a bin's subinterval proportional to its count.</li></ol>\n+ * <strong>Generating random values from the distribution</strong><ol>\n+ * <li>Generate a uniformly distributed value in (0,1) </li>\n+ * <li>Select the subinterval to which the value belongs.\n+ * <li>Generate a random Gaussian value with mean = mean of the associated\n+ *     bin and std dev = std dev of associated bin.</li></ol></p><p>\n+ *<strong>USAGE NOTES:</strong><ul>\n+ *<li>The <code>binCount</code> is set by default to 1000.  A good rule of thumb\n+ *    is to set the bin count to approximately the length of the input file divided\n+ *    by 10.  See TODO: add reference </li>\n+ *<li>The input file <i>must</i> be a plain text file containing one valid numeric\n+ *    entry per line.</li>\n+ * </ol></p>\n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ */\n+public class EmpiricalDistributionImpl implements Serializable,EmpiricalDistribution {\n+\n+    \n+    /** List of Univariate objects characterizing the bins */\n+    private ArrayList binStats = null;\n+    \n+    /** Sample statistics */\n+    Univariate sampleStats = null;\n+    \n+    /** number of bins */\n+    private int binCount = 1000;\n+    \n+    /** is the distribution loaded? */\n+    private boolean loaded = false;\n+    \n+    /** upper bounds of subintervals in (0,1) \"belonging\" to the bins */\n+    private double[] upperBounds = null;\n+    \n+    /** RandomData instance to use in repeated calls to getNext() */\n+    private RandomData randomData = new RandomDataImpl();\n+    \n+    /** \n+     * Creates a new EmpiricalDistribution  with the default bin count\n+     */\n+    public EmpiricalDistributionImpl() {\n+        binStats = new ArrayList();\n+    }\n+    \n+    /** \n+     * Creates a new EmpiricalDistribution  with the specified bin count\n+     * @param binCount number of bins\n+     */\n+    public EmpiricalDistributionImpl(int binCount) {\n+        this.binCount = binCount;\n+        binStats = new ArrayList();\n+    }\n+    \n+    \n+    public void load(String filePath) throws IOException {\n+        File file = new File(filePath);\n+        load(file);\n+    }\n+    \n+     \n+    public void load(File file) throws IOException {\n+        // Pass the file once to get sample stats\n+         BufferedReader in = null;\n+         try {  \n+            in = new BufferedReader(new FileReader(file));\n+            String str = null;\n+            double val = 0.0;\n+            sampleStats = new UnivariateImpl();\n+            while ((str = in.readLine()) != null) {\n+              val = new Double(str).doubleValue();\n+              sampleStats.addValue(val);   \n+            }\n+            in.close();\n+            in = null;\n+         } finally {\n+             if (in != null) try {in.close();} catch (Exception ex) {};\n+         }               \n+        \n+         // Load array of bin upper bounds -- evenly spaced from min - max\n+         double min = sampleStats.getMin();\n+         double max = sampleStats.getMax();\n+         double delta = (max - min)/(new Double(binCount)).doubleValue();\n+         double[] binUpperBounds = new double[binCount];\n+         binUpperBounds[0] = min + delta;\n+         for (int i = 1; i< binCount - 1; i++) {\n+             binUpperBounds[i] = binUpperBounds[i-1] + delta;\n+         }\n+         binUpperBounds[binCount -1] = max;\n+         \n+        // Initialize binStats ArrayList\n+        if (!binStats.isEmpty()) {\n+            binStats.clear();\n+        }\n+        for (int i = 0; i < binCount; i++) {\n+            Univariate stats = new UnivariateImpl();\n+            binStats.add(i,stats);\n+        }\n+         \n+        // Pass the data again, filling data in binStats Array \n+         try {\n+            in = new BufferedReader(new FileReader(file));\n+            String str = null;\n+            double val = 0.0d;\n+            while ((str = in.readLine()) != null) {\n+              val = new Double(str).doubleValue();\n+              \n+              // Find bin and add value to binStats for the bin\n+              boolean found = false;\n+              int i = 0; \n+              while (!found) {\n+                  if (i >= binCount) {\n+                      throw new RuntimeException(\"bin alignment error\");\n+                  }\n+                  if (val <= binUpperBounds[i]) {\n+                      found = true;\n+                      Univariate stats = (Univariate)binStats.get(i);\n+                      stats.addValue(val);\n+                  }\n+                  i++;\n+              }       \n+            }\n+            in.close();\n+            in = null;\n+         } finally {\n+             if (in != null) try {in.close();} catch (Exception ex) {};\n+         }               \n+        \n+         // Assign upperBounds based on bin counts\n+         upperBounds = new double[binCount];\n+         upperBounds[0] = \n+            ((double)((Univariate)binStats.get(0)).getN())/\n+                (double)sampleStats.getN();\n+         for (int i = 1; i < binCount-1; i++) {\n+             upperBounds[i] = upperBounds[i-1] +\n+             ((double)((Univariate)binStats.get(i)).getN())/\n+                (double)sampleStats.getN();\n+         }\n+         upperBounds[binCount-1] = 1.0d;   \n+         \n+         loaded = true;\n+    }\n+    \n+    /** Generates a random value from this distribution */\n+    public double getNextValue() throws IllegalStateException {    \n+        \n+        if (!loaded) {\n+            throw new IllegalStateException(\"distribution not loaded\");\n+        }\n+        \n+        // Start with a uniformly distributed random number in (0,1)\n+        double x = Math.random();\n+       \n+        // Use this to select the bin and generate a Gaussian within the bin\n+        for (int i = 0; i < binCount; i++) {\n+           if (x <= upperBounds[i]) {\n+               Univariate stats = (Univariate)binStats.get(i);\n+               if (stats.getN() > 0) { \n+                   if (stats.getStandardDeviation() > 0) {  // more than one obs \n+                        return randomData.nextGaussian\n+                            (stats.getMean(),stats.getStandardDeviation());\n+                   } else {\n+                       return stats.getMean(); // only one obs in bin\n+                   }\n+               }\n+           }\n+        }\n+        throw new RuntimeException(\"No bin selected\");\n+    }\n+       \n+    public void loadDistribution(String filePath) throws IOException {\n+        throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+    \n+    public void loadDistribution(File file) throws IOException {\n+        throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+       \n+    public void saveDistribution(String filePath) throws \n+        IOException,IllegalStateException {\n+       throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+    \n+    public void saveDistribution(File file) throws \n+        IOException,IllegalStateException {\n+       throw new UnsupportedOperationException(\"Not Implemented yet :-(\");\n+    }\n+        \n+    public Univariate getSampleStats() {\n+        return sampleStats;\n+    }\n+    \n+    public int getBinCount() {\n+        return binCount;\n+    }\n+      \n+    public ArrayList getBinStats() {\n+        return binStats;\n+    }\n+       \n+    public double[] getUpperBounds() {\n+        return upperBounds;\n+    }\n+    \n+    public boolean isLoaded() {\n+        return loaded;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/RandomData.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.random;\n+import java.util.Collection;\n+\n+/**\n+ * Random data generation utilities\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:57 $\n+ */\n+public interface RandomData {      \n+    /**\n+     * Generates a random string of hex characters of length\n+     * <code>len</code>.\n+     * <p>\n+     * The generated string will be random, but not cryptographically \n+     * secure. To generate cryptographically secure strings, use \n+     * <code>nextSecureHexString</code>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     * \n+     * @param len the length of the string to be generated\n+     * @return random string of hex characters of length <code>len</code>  \n+     */\n+    String nextHexString(int len);  \n+    \n+    /**\n+     * Generates a uniformly distributed random integer between \n+     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * <p>\n+     * The generated integer will be random, but not cryptographically secure.\n+     * To generate cryptographically secure integer sequences, use \n+     * <code>nextSecureInt</code>.\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a random integer greater than or equal to <code>lower</code> \n+     * and less than or equal to <code>upper</code>.\n+     */\n+    int nextInt(int lower, int upper);  \n+    \n+    /**\n+     * Generates a uniformly distributed random long integer between\n+     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * <p>\n+     * The generated long integer values will be random, but not \n+     * cryptographically secure.\n+     * To generate cryptographically secure sequences of longs, use \n+     * <code>nextSecureLong</code>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    long nextLong(long lower, long upper);  \n+    \n+    /**\n+     * Generates a random string of hex characters from a secure random \n+     * sequence.\n+     * <p>\n+     * If cryptographic security is not required, \n+     * use <code>nextHexString()</code>.\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     * @param len length of return string\n+     * @return the random hex string\n+     */\n+    String nextSecureHexString(int len);  \n+    \n+    /**\n+     * Generates a uniformly distributed random integer between \n+     * <code>lower</code> and <code>upper</code> (endpoints included) \n+     * from a secure random sequence.\n+     * <p>\n+     * Sequences of integers generated using this method will be \n+     * cryptographically secure. If cryptographic security is not required, \n+     * <code>nextInt</code> should be used instead of this method. \n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://www.wikipedia.org/wiki/\n+     * Cryptographically_secure_pseudo-random_number_generator\">\n+     * Secure Random Sequence</a>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    int nextSecureInt(int lower, int upper);  \n+    \n+    /**\n+     * Generates a random long integer between <code>lower</code>\n+     * and <code>upper</code> (endpoints included).<p>\n+     * Sequences of long values generated using this method will be \n+     * cryptographically secure. If cryptographic security is not required,\n+     * <code>nextLong</code> should be used instead of this method.\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://www.wikipedia.org/wiki/\n+     * Cryptographically_secure_pseudo-random_number_generator\">\n+     * Secure Random Sequence</a>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a long integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    long nextSecureLong(long lower, long upper);  \n+    \n+    /** \n+     * Generates a random value from the Poisson distribution with \n+     * the given mean.\n+     * <p>\n+     * <strong>Definition</strong>: \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda366j.htm\">\n+     * Poisson Distribution</a>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The specified mean <i>must</i> be positive (otherwise an \n+     *     IllegalArgumentException is thrown.)</li>\n+     * </ul>\n+     * @param mean Mean of the distribution\n+     * @return poisson deviate with the specified mean\n+     */\n+    long nextPoisson(double mean);  \n+    \n+    /** \n+     * Generates a random value from the\n+     * Normal (or Gaussian) distribution with the given mean\n+     * and standard deviation.\n+     * <p>\n+     * <strong>Definition</strong>: \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda3661.htm\">\n+     * Normal Distribution</a>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li><code>sigma > 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     * @param mu Mean of the distribution\n+     * @param sigma Standard deviation of the distribution\n+     * @return random value from Gaussian distribution with mean = mu,\n+     * standard deviation = sigma\n+     */\n+    double nextGaussian(double mu, double sigma);  \n+    \n+    /**\n+     * Generates a random value from the exponential distribution\n+     * with expected value = <code>mean</code>.\n+     * <p>\n+     * <strong>Definition</strong>: \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda3667.htm\">\n+     * Exponential Distribution</a>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li><code>mu >= 0</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     * @param mean Mean of the distribution\n+     * @return random value from exponential distribution\n+     */\n+    double nextExponential(double mean);   \n+    \n+    /**\n+     * Generates a uniformly distributed random value from the open interval\n+     * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded).\n+     * <p>\n+     * <strong>Definition</strong>: \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/\n+     * eda/section3/eda3662.htm\">\n+     * Uniform Distribution</a> <code>lower</code> and \n+     * <code>upper - lower</code> are the \n+     * <a href = \"http://www.itl.nist.gov/div898/handbook/eda/\n+     * section3/eda364.htm\">\n+     * location and scale parameters</a>, respectively.\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException \n+     *     is thrown.)</li>\n+     * </ul>\n+     *\n+     * @param lower lower endpoint of the interval of support\n+     * @param upper upper endpoint of the interval of support\n+     * @return uniformly distributed random value between lower\n+     * and upper (exclusive)\n+     */\n+    double nextUniform(double lower, double upper);\n+    \n+    /**\n+     * Generates an integer array of length <code>k</code> whose entries\n+     * are selected randomly, without repetition, from the integers <code>\n+     * 0 through n-1</code> (inclusive). \n+     * <p>\n+     * Generated arrays represent permutations\n+     * of <code>n</code> taken <code>k</code> at a time. \n+     * <p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li> <code>k <= n</code></li>\n+     * <li> <code>n > 0</code> </li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is\n+     * thrown.\n+     * \n+     * @param n domain of the permutation\n+     * @param k size of the permutation\n+     * @return random k-permutation of n \n+     */\n+    int[] nextPermutation(int n, int k);\n+    \n+    /**\n+     * Returns an array of <code>k</code> objects selected randomly\n+     * from the Collection <code>c</code>. \n+     * <p>\n+     * Sampling from <code>c</code>\n+     * is without replacement; but if <code>c</code> contains identical\n+     * objects, the sample may include repeats.  If all elements of <code>\n+     * c</code> are distinct, the resulting object array represents a \n+     * <a href=\"http://rkb.home.cern.ch/rkb/AN16pp/\n+     * node250.html#SECTION0002500000000000000000\">\n+     * Simple Random Sample</a> of size\n+     * <code>k</code> from the elements of <code>c</code>.\n+     * <p>   \n+     * <strong>Preconditions:</strong><ul>\n+     * <li> k must be less than or equal to the size of c </li>\n+     * <li> c must not be empty </li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is\n+     * thrown.\n+     * \n+     * @param c collection to be sampled\n+     * @param k size of the sample\n+     * @return random sample of k elements from c \n+     */\n+    Object[] nextSample(Collection c, int k);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import java.security.MessageDigest;\n+import java.security.SecureRandom;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.util.Random;\n+import java.util.Collection;\n+\n+/**\n+ * Implements the <code>RandomData</code> interface using \n+ * <code>java.util.Random</code> and \n+ * <code>java.util.Random.SecureRandom</code> instances to generate data. \n+ * <p>\n+ * Supports reseeding the underlying \n+ * <a href=\"http://www.wikipedia.org/wiki/Pseudo-random_number_generator\">\n+ * PRNG</a>. The <code>SecurityProvider</code> and <code>Algorithm</code>\n+ * used by the <code>SecureRandom</code> instance can also be reset.\n+ * <p>\n+ * For details on the PRNGs, see the JDK documentation for \n+ * <code>java.util.Random</code> and \n+ * <code>java.util.Random.SecureRandom</code>\n+ * <p>\n+ * <strong>Usage Notes</strong>: <ul>\n+ * <li>\n+ * Instance variables are used to maintain <code>Random</code> and \n+ * <code>SecureRandom</code> instances used in data generation. Therefore,\n+ * to generate a random sequence of values or strings, you should use just\n+ * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n+ * <li>\n+ * The \"secure\" methods are *much* slower.  These should be used only when\n+ * a <a href=\"http://www.wikipedia.org/wiki/\n+ * Cryptographically_secure_pseudo-random_number_generator\"> Secure Random \n+ * Sequence</a> is required.</li>\n+ * <li>\n+ * When a new <code>RandomDataImpl</code> is created, the underlying random\n+ * number generators are <strong>not</strong> intialized.  The first call to a\n+ * data generation method, or to a <code>reSeed()</code> method instantiates\n+ * the appropriate generator.  If you do not explicitly seed the generator, it\n+ * is by default seeded with the current time in milliseconds</li>\n+ * <li>\n+ * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate \n+ * to the corresponding methods on the underlying <code>Random</code> and \n+ * <code>SecureRandom</code> instances.  Therefore, the contracts of these \n+ * methods are as defined in the JDK documentation.  In particular, \n+ * <code>reSeed(long)</code> fully resets the initial state of the non-secure \n+ * random number generator (so that reseeding with a specific value always \n+ * results in the same subsequent random sequence); whereas reSeedSecure(long)\n+ * does <strong>not</strong> reinitialize the secure random number generator \n+ * (so secure sequences started with calls to reseedSecure(long) won't be \n+ * identical).</li></ul>\n+ * \n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:57 $\n+ */\n+public class RandomDataImpl implements RandomData {\n+    \n+    /** underlying random number generator */\n+    private Random rand = null;\n+    \n+    /** underlying secure random number generator */\n+    private SecureRandom secRand = null;\n+    \n+    /**\n+     * Construct a RandomDataImpl.\n+     */\n+    public RandomDataImpl() {\n+    }\n+          \n+    /**\n+     * <strong>Algorithm Description:</strong> hex strings are generated \n+     * using a 2-step process. <ol>\n+     * <li>\n+     * len/2+1 binary bytes are generated using the underlying Random</li>\n+     * <li>\n+     * Each binary byte is translated into 2 hex digits</li></ol>\n+     */\n+    public String nextHexString(int len) {\n+        if (len <= 0) {\n+            throw new IllegalArgumentException(\"length must be positive\");\n+        }\n+            \n+        //Get a random number generator\n+        Random ran = getRan();\n+        \n+        //Initialize output buffer\n+        StringBuffer outBuffer = new StringBuffer();\n+            \n+        //Get int(len/2)+1 random bytes\n+        byte[] randomBytes = new byte[(len / 2) + 1];\n+        ran.nextBytes(randomBytes);\n+ \n+        //Convert each byte to 2 hex digits\n+        for (int i = 0; i < randomBytes.length; i++) {\n+            Integer c = new Integer(randomBytes[i]);\n+                \n+            /* Add 128 to byte value to make interval 0-255 before\n+             * doing hex conversion.\n+             * This guarantees <= 2 hex digits from toHexString()\n+             * toHexString would otherwise add 2^32 to negative arguments.\n+             */\n+             String hex = Integer.toHexString(c.intValue() + 128);\n+                \n+             // Make sure we add 2 hex digits for each byte\n+             if (hex.length() == 1)  {\n+                 hex = \"0\" + hex;\n+             }\n+             outBuffer.append(hex);\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+       \n+    public int nextInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"upper bound must be > lower bound\");\n+        }\n+        Random rand = getRan();\n+        return lower + (int) (rand.nextDouble() * (upper - lower + 1));\n+    }\n+    \n+    public long nextLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+                (\"upper bound must be > lower bound\");\n+        }\n+        Random rand = getRan();\n+        return lower + (long) (rand.nextDouble() * (upper - lower + 1));\n+    }\n+    \n+     /**\n+     * <strong>Algorithm Description:</strong> hex strings are generated in \n+     * 40-byte segments using a 3-step process. <ol>\n+     * <li>\n+     * 20 random bytes are generated using the underlying \n+     * <code>SecureRandom</code>.</li>\n+     * <li>\n+     * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n+     * <li>\n+     * Each byte of the binary digest is converted to 2 hex digits</li></ol>\n+     * <p>\n+     * TODO: find external reference or provide justification for the claim \n+     * that this yields a cryptographically secure sequence of hex strings.\n+     */\n+    public String nextSecureHexString(int len) {\n+        if (len <= 0) {\n+            throw new IllegalArgumentException(\"length must be positive\");\n+        }\n+       \n+       // Get SecureRandom and setup Digest provider\n+       SecureRandom secRan = getSecRan();\n+       MessageDigest alg = null;\n+       try {\n+            alg = MessageDigest.getInstance(\"SHA-1\");\n+       } catch (NoSuchAlgorithmException ex) {\n+           return null; // gulp FIXME? -- this *should* never fail.\n+       }\n+       alg.reset(); \n+       \n+       //Compute number of iterations required (40 bytes each)\n+       int numIter = (len / 40) + 1;\n+       \n+       StringBuffer outBuffer = new StringBuffer();\n+       for (int iter = 1; iter < numIter + 1; iter++) {\n+            byte[] randomBytes = new byte[40];\n+            secRan.nextBytes(randomBytes);\n+            alg.update(randomBytes);\n+    \n+            //Compute hash -- will create 20-byte binary hash\n+            byte hash[] = alg.digest();\n+            \n+            //Loop over the hash, converting each byte to 2 hex digits\n+            for (int i = 0; i < hash.length; i++) {\n+                Integer c = new Integer(hash[i]);\n+        \n+                /* Add 128 to byte value to make interval 0-255\n+                 * This guarantees <= 2 hex digits from toHexString()\n+                 * toHexString would otherwise add 2^32 to negative \n+                 * arguments\n+                 */\n+                String hex = Integer.toHexString(c.intValue() + 128);\n+                    \n+               //Keep strings uniform length -- guarantees 40 bytes\n+                if (hex.length() == 1) {\n+                    hex = \"0\" + hex;\n+                }\n+               outBuffer.append(hex);\n+            }\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+     \n+    public int nextSecureInt(int lower, int upper) {\n+          if (lower >= upper) {\n+              throw new IllegalArgumentException\n+                (\"lower bound must be < upper bound\");\n+          }\n+          SecureRandom sec = getSecRan();\n+          return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+    }\n+     \n+    public long nextSecureLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+            (\"lower bound must be < upper bound\");\n+        }\n+        SecureRandom sec = getSecRan();\n+        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n+    }\n+    \n+    /** \n+     * <strong>Algorithm Description</strong>:\n+     * Uses simulation of a Poisson process using Uniform deviates, as \n+     * described \n+     * <a href =\"http://dmawww.epfl.ch/benarous/Pmmi/interactive/rng7.htm\">\n+     * here</a>\n+     *\n+     */\n+    public long nextPoisson(double mean) {\n+        double p = Math.exp(-mean);\n+        long n = 0;\n+        double r = 1.0d;\n+        Random rand = getRan();\n+        if (mean <= 0) {\n+            throw new IllegalArgumentException(\"Poisson mean must be > 0\");\n+        }\n+        while (true) {\n+            double rnd = rand.nextDouble();\n+            r = r * rnd;\n+            if (r >= p) {\n+                n++;\n+            } else {\n+                return n;\n+            }\n+        }\n+    }\n+    \n+    public double nextGaussian(double mu, double sigma) {\n+        if (sigma <= 0) {\n+            throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n+        }\n+        Random rand = getRan();\n+        return sigma * rand.nextGaussian() + mu;\n+    }\n+    \n+    /**\n+     * <strong>Algorithm Description</strong>:  Uses the \n+     * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> \n+     * Inversion Method</a> to generate exponential from uniform deviates.\n+     */\n+    public double nextExponential(double mean)  {\n+        if (mean < 0.0)  {\n+            throw new IllegalArgumentException\n+                (\"Exponential mean must be >= 0\");\n+        }\n+        Random rand = getRan();\n+        double unif = rand.nextDouble();\n+        while (unif == 0.0d) {\n+            unif = rand.nextDouble();\n+        }\n+        return -mean * Math.log(unif);\n+    }\n+    \n+    /**\n+     * <strong>Algorithm Description</strong>: scales the output of \n+     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n+     * random double if Random.nextDouble() returns 0). \n+     * This is necessary to provide a symmetric output interval \n+     * (both endpoints excluded).\n+     */\n+    public double nextUniform(double lower, double upper) {\n+        if (lower >= upper) {\n+            throw new IllegalArgumentException\n+            (\"lower bound must be <= upper bound\");\n+        }\n+        Random rand = getRan();\n+        double result = lower + rand.nextDouble() * (upper - lower);\n+        while (result == lower) {\n+              result = lower + rand.nextDouble() * (upper - lower);\n+        }\n+        return result;   \n+    }\n+    \n+    /** \n+     * Returns the static Random used to generate random data.\n+     * <p>\n+     * Creates and initializes if null.\n+     * \n+     * @return the static Random used to generate random data\n+     */\n+    private Random getRan() {\n+        if (rand == null) {\n+            rand = new Random();\n+            rand.setSeed(System.currentTimeMillis());\n+        }\n+        return rand;\n+    }\n+    \n+    /** \n+     * Returns the static SecureRandom used to generate secure random data.\n+     * <p>\n+     * Creates and initializes if null.\n+     *\n+     * @return the static SecureRandom used to generate secure random data\n+     */\n+    private SecureRandom getSecRan() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+            secRand.setSeed(System.currentTimeMillis());\n+        }\n+        return secRand;\n+    }\n+    \n+    /**\n+     * Reseeds the random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     *\n+     * @param seed the seed value to use\n+     */\n+    public void reSeed(long seed) {\n+        if (rand == null) {\n+            rand = new Random();\n+        }\n+        rand.setSeed(seed);\n+    }\n+    \n+    /**\n+     * Reseeds the secure random number generator with the current time\n+     * in milliseconds. \n+     * <p> \n+     * Will create and initialize if null.\n+     */\n+    public void reSeedSecure() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(System.currentTimeMillis());\n+    }\n+    \n+    /**\n+     * Reseeds the secure random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     *\n+     * @param seed the seed value to use\n+     */\n+    public void reSeedSecure(long seed) {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(seed);\n+    }\n+    \n+    /**\n+     * Reseeds the random number generator with the current time\n+     * in milliseconds.\n+     */\n+    public void reSeed() {\n+        if (rand == null) {\n+            rand = new Random();\n+        }\n+        rand.setSeed(System.currentTimeMillis());\n+    }\n+    \n+    /**\n+     * Sets the PRNG algorithm for the underlying SecureRandom instance\n+     * using the Security Provider API, as defined in \n+     * <a href=\"http://java.sun.com/j2se/1.3/docs/guide/security/\n+     * CryptoSpec.html#AppA\">\n+     * Java Cryptography Architecture API Specification & Reference.</a>\n+     * <p>\n+     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i> \n+     * overhead and may take several seconds to execute.\n+     *\n+     * @param algorithm the name of the PRNG algorithm\n+     * @param provider the name of the provider \n+     * @throws NoSuchAlgorithmException if the specified algorithm \n+     * is not available\n+     * @throws NoSuchProviderException if the specified provider \n+     * is not installed\n+     */\n+    public void setSecureAlgorithm(String algorithm, String provider) \n+        throws NoSuchAlgorithmException, NoSuchProviderException {\n+        secRand = SecureRandom.getInstance(algorithm, provider);\n+    }\n+    \n+    /**\n+     * Uses a 2-cycle permutation shuffle, as described\n+     * <a href=http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html>\n+     * here</a>\n+     *  \n+     */\n+    public int[] nextPermutation(int n, int k) {\n+        if (k > n) {\n+            throw new IllegalArgumentException\n+                (\"permutation k exceeds n\");\n+        }       \n+        if (k == 0) {\n+            throw new IllegalArgumentException\n+                (\"permutation k must be > 0\");\n+        }\n+        \n+        int[] index = getNatural(n);\n+        shuffle(index, n - k);\n+        int[] result = new int[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = index[n - i - 1];\n+        }\n+  \n+        return result;\n+    }\n+    \n+    /**\n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation \n+     * shuffle to generate a random permutation of <code>c.size()</code> and \n+     * then returns the elements whose indexes correspond to the elements of \n+     * the generated permutation.  \n+     * This technique is described, and proven to generate random samples, \n+     * <a href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+     * here</a>\n+     */ \n+    public Object[] nextSample(Collection c, int k) {\n+        int len = c.size();\n+        if (k > len) {\n+            throw new IllegalArgumentException\n+                (\"sample size exceeds collection size\");\n+        }\n+        if (k == 0) {\n+            throw new IllegalArgumentException\n+                (\"sample size must be > 0\");\n+        }\n+            \n+       Object[] objects = c.toArray();\n+       int[] index = nextPermutation(len, k);\n+       Object[] result = new Object[k];\n+       for (int i = 0; i < k; i++) {\n+           result[i] = objects[index[i]];\n+       }  \n+       return result;\n+    }\n+    \n+    //------------------------Private methods----------------------------------\n+    \n+    /** \n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation \n+     * shuffle to randomly re-order the last <code>end</code> elements of list.\n+     * \n+     * @param list list to be shuffled\n+     * @param end element past which shuffling begins\n+     */\n+    private void shuffle(int[] list, int end) {\n+        int target = 0;\n+        for (int i = list.length - 1 ; i >= end; i--) {\n+            if (i == 0) {\n+                target = 0; \n+            } else {\n+                target = nextInt(0, i);\n+            }\n+            int temp = list[target];\n+            list[target] = list[i];\n+            list[i] = temp;\n+        }      \n+    }\n+    \n+    /**\n+     * Returns an array representing n.\n+     *\n+     * @param n the natural number to represent\n+     * @return array with entries = elements of n\n+     */\n+    private int[] getNatural(int n) {\n+        int[] natural = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            natural[i] = i;\n+        }\n+        return natural;\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/random/ValueServer.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.random;\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.File;\n+import java.net.URL;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+\n+/**\n+ * Generates values for use in simulation applications.\n+ * <p>\n+ * How values are generated is determined by the <code>mode</code>\n+ * property. \n+ * <p> \n+ * Supported <code>mode</code> values are: <ul>\n+ * <li> DIGEST_MODE -- uses an empirical distribution </li>\n+ * <li> REPLAY_MODE -- replays data from <code>valuesFile</code></li> \n+ * <li> UNIFORM_MODE -- generates uniformly distributed random values with\n+ *                      mean = <code>mu</code> </li>\n+ * <li> EXPONENTIAL_MODE -- generates exponentially distributed random values\n+ *                         with mean = <code>mu</code></li>\n+ * <li> GAUSSIAN_MODE -- generates Gaussian distributed random values with\n+ *                       mean = <code>mu</code> and \n+ *                       standard deviation = <code>sigma</code></li>\n+ * <li> CONSTANT_MODE -- returns <code>mu</code> every time.</li></ul> \n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ *\n+ */\n+public class ValueServer {\n+    /** mode determines how values are generated */\n+    private int mode = 5;\n+    \n+    /** URI to raw data values  */\n+    private URL valuesFileURL = null;\n+    \n+    /** Mean for use with non-data-driven modes */\n+    private double mu = 0.0;\n+    \n+    /** Standard deviation for use with GAUSSIAN_MODE */\n+    private double sigma = 0.0;\n+    \n+    /** Empirical probability distribution for use with DIGEST_MODE */\n+    private EmpiricalDistribution empiricalDistribution = null;\n+    \n+    /** file pointer for REPLAY_MODE */\n+    private BufferedReader filePointer = null;\n+    \n+    /** RandomDataImpl to use for random data generation */\n+    private RandomDataImpl randomData = new RandomDataImpl();\n+    \n+    // Data generation modes ======================================\n+   \n+    /** Use empirical distribution  */\n+    public static final int DIGEST_MODE = 0;        \n+    \n+    /** Replay data from valuesFilePath */\n+    public static final int REPLAY_MODE = 1;      \n+    \n+    /** Uniform random deviates with mean = mu */\n+    public static final int UNIFORM_MODE = 2;    \n+    \n+    /** Exponential random deviates with mean = mu */\n+    public static final int EXPONENTIAL_MODE = 3;  \n+    \n+    /** Gaussian random deviates with mean = mu, std dev = sigma */\n+    public static final int GAUSSIAN_MODE = 4;  \n+    \n+    /** Always return mu */\n+    public static final int CONSTANT_MODE = 5;   \n+    \n+    /** Creates new ValueServer */\n+    public ValueServer() {\n+    }\n+\n+    /** \n+     * Returns the next generated value, generated according\n+     * to the mode value (see MODE constants). \n+     *\n+     * @return generated value \n+     * @throws IOException in REPLAY_MODE if a file I/O error occurs\n+     */\n+    public double getNext() throws IOException {\n+        switch (mode) {\n+            case DIGEST_MODE: return getNextDigest();\n+            case REPLAY_MODE: return getNextReplay();\n+            case UNIFORM_MODE: return getNextUniform();\n+            case EXPONENTIAL_MODE: return getNextExponential();\n+            case GAUSSIAN_MODE: return getNextGaussian();\n+            case CONSTANT_MODE: return mu;\n+            default: throw new IllegalStateException\n+                       (\"Bad mode: \" + mode);\n+        }\n+    }\n+    \n+    /**\n+     * Fills the input array with values generated using getNext() repeatedly.\n+     *\n+     * @param values array to be filled\n+     * @throws IOException in REPLAY_MODE if a file I/O error occurs\n+     */\n+    public void fill(double[] values) throws IOException {\n+        for (int i = 0; i < values.length; i++) {\n+            values[i] = getNext();\n+        }\n+    }\n+    \n+    /**\n+     * Returns an array of length <code>length</code> with values generated \n+     * using getNext() repeatedly.\n+     *\n+     * @param length length of output array\n+     * @return array of generated values\n+     * @throws IOException in REPLAY_MODE if a file I/O error occurs\n+     */\n+    public double[] fill(int length) throws IOException {\n+        double[] out = new double[length];\n+        for (int i = 0; i < length; i++) {\n+            out[i] = getNext();\n+        }\n+        return out;\n+    }       \n+    \n+    /** \n+     * Computes the empirical distribution using values from the file\n+     * in <code>valuesFilePath</code>, using the default number of bins.\n+     * <p>\n+     * <code>valuesFileURL</code> must exist and be\n+     * readable by *this at runtime.\n+     * <p>\n+     * This method must be called before using <code>getNext()</code>\n+     * with <code>mode = DISGEST_MODE</code>\n+     *\n+     * @throws IOException if an I/O error occurs reading the input file\n+     */\n+    public void computeDistribution() throws IOException {\n+        empiricalDistribution = new EmpiricalDistributionImpl();\n+        empiricalDistribution.load(valuesFileURL.getFile());\n+    }\n+    \n+    /** \n+     * Computes the empirical distribution using values from the file\n+     * in <code>valuesFilePath</code> and <code>binCount</code> bins.\n+     * <p>\n+     * <code>valuesFileURL</code> must exist and be\n+     * readable by *this at runtime.\n+     * <p>\n+     * This method must be called before using <code>getNext()</code>\n+     * with <code>mode = DISGEST_MODE</code>\n+     *\n+     * @param binCount the number of bins used in computing the empirical\n+     * distribution\n+     * @throws IOException if an error occurs reading the input file\n+     */\n+    public void computeDistribution(int binCount) \n+            throws IOException {\n+        empiricalDistribution = new EmpiricalDistributionImpl(binCount);\n+        empiricalDistribution.load(valuesFileURL.getFile());\n+        mu = empiricalDistribution.getSampleStats().getMean();\n+        sigma = empiricalDistribution.getSampleStats().getStandardDeviation();\n+    }\n+    \n+    /** Getter for property mode.\n+     * @return Value of property mode.\n+     */\n+    public int getMode() {\n+        return mode;\n+    }\n+    \n+    /** Setter for property mode.\n+     * @param mode New value of property mode.\n+     */\n+    public void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+    \n+    /** Getter for property valuesFilePath.\n+     * @return Value of property valuesFilePath.\n+     */\n+    public String getValuesFileURL() {\n+        return valuesFileURL.toString();\n+    }\n+    \n+    /** Setter for property valuesFilePath.\n+     * @param url New value of property valuesFilePath.\n+     * @throws MalformedURLException if url is not well formed\n+     */\n+    public void setValuesFileURL(String url) throws MalformedURLException {\n+        this.valuesFileURL = new URL(url);\n+    }\n+    \n+    /** Getter for property empiricalDistribution.\n+     * @return Value of property empiricalDistribution.\n+     */\n+    public EmpiricalDistribution getEmpiricalDistribution() {\n+        return empiricalDistribution;\n+    }    \n+    \n+    /**  \n+     * Opens <code>valuesFilePath</code> to use in REPLAY_MODE.\n+     *\n+     * @throws IOException if an error occurs opening the file\n+     */\n+    public void openReplayFile() throws IOException {\n+        filePointer = new BufferedReader(new FileReader\n+                            (new File(valuesFileURL.getFile())));\n+    }\n+    \n+    /** \n+     * Closes <code>valuesFilePath</code> after use in REPLAY_MODE.\n+     *\n+     * @throws IOException if an error occurs closing the file\n+     */\n+    public void closeReplayFile() throws IOException {\n+        if (filePointer != null) {\n+            filePointer.close();\n+            filePointer = null;\n+        }     \n+    }\n+    \n+    /** Getter for property mu.\n+     * @return Value of property mu.\n+     */\n+    public double getMu() {\n+        return mu;\n+    }\n+    \n+    /** Setter for property mu.\n+     * @param mu New value of property mu.\n+     */\n+    public void setMu(double mu) {\n+        this.mu = mu;\n+    }\n+    \n+    /** Getter for property sigma.\n+     * @return Value of property sigma.\n+     */\n+    public double getSigma() {\n+        return sigma;\n+    }\n+    \n+    /** Setter for property sigma.\n+     * @param sigma New value of property sigma.\n+     */\n+    public void setSigma(double sigma) {\n+        this.sigma = sigma;\n+    }\n+    \n+    //------------- private methods ---------------------------------\n+    \n+    /** \n+     * Gets a random value in DIGEST_MODE.\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Before this method is called, <code>computeDistribution()</code>\n+     * must have completed successfully; otherwise an \n+     * <code>IllegalStateException</code> will be thrown</li></ul>\n+     *\n+     * @return next random value from the empirical distribution digest \n+     */\n+    private double getNextDigest() {\n+        if ((empiricalDistribution == null) ||\n+            (empiricalDistribution.getBinStats().size() == 0)) {\n+            throw new IllegalStateException(\"Digest not initialized\");\n+        }\n+        return empiricalDistribution.getNextValue();     \n+    }\n+    \n+    /**\n+     * Gets next sequential value from the <code>valuesFilePath</code> \n+     * opened by <code>openReplayFile()</code>.\n+     * <p>\n+     * Throws an IOException if <code>filePointer</code> is null or read fails.\n+     * Will wrap around to BOF is EOF is encountered.\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li> openReplayfile() must have completed successfully before \n+     * invoking this method; otherwise an <code>IlleglaStateException</code>\n+     * will be thrown</li></ul>\n+     *\n+     * @return next value from the replay file\n+     * @throws IOException if there is a problem reading from the file\n+     */\n+    private double getNextReplay() throws IOException {\n+        String str = null;\n+        if (filePointer == null) {\n+            throw new IllegalStateException(\"replay file not open\");\n+        }\n+        if ((str = filePointer.readLine()) == null) {\n+            closeReplayFile();\n+            openReplayFile();\n+            str = filePointer.readLine();\n+        }         \n+        return new Double(str).doubleValue();\n+    }\n+    \n+    /** \n+     * Gets a uniformly distributed random value with mean = mu. \n+     *\n+     * @return random uniform value\n+     */\n+    private double getNextUniform() {\n+        return randomData.nextUniform(0, 2 * mu);\n+    }\n+    \n+    /** \n+     * Gets an exponentially distributed random value with mean = mu. \n+     *\n+     * @return random exponential value\n+     */\n+    private double getNextExponential() {\n+        return randomData.nextExponential(mu);    \n+    }\n+    \n+    /** \n+     * Gets a Gaussian distributed random value with mean = mu\n+     * and standard deviation = sigma.\n+     *\n+     * @return random Gaussian value\n+     */\n+    private double getNextGaussian() {\n+        return randomData.nextGaussian(mu, sigma);\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/math/special/Beta.java\n+++ b/src/java/org/apache/commons/math/special/Beta.java\n  */\n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.ContinuedFraction;\n+import org.apache.commons.math.util.ContinuedFraction;\n \n /**\n  * This is a utility class that provides computation methods related to the\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n  */\n package org.apache.commons.math.special;\n \n-import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.analysis.ConvergenceException;\n \n /**\n  * This is a utility class that provides computation methods related to the\n--- a/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n  */\n package org.apache.commons.math.stat;\n \n-import java.util.Iterator;\n import java.util.List;\n-\n import org.apache.commons.beanutils.PropertyUtils;\n \n /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import java.util.Hashtable;\n+import java.util.Enumeration;\n+\n+/** \n+ * Maintains a frequency distribution. <br>\n+ * Accepts int, long or string values, converting\n+ * all to Strings and maintaining frequency counts.\n+ *\n+ * @author Phil Steitz\n+ */\n+\n+public class Frequency {\n+\n+    private String name;\n+\n+    private Hashtable freqTable;\n+\n+    /** instance initializer */\n+    {\n+        freqTable = new Hashtable();\n+    }\n+\n+    public Frequency() {\n+    }\n+\n+    public Frequency(String name) {\n+        this.name = name;\n+    }\n+\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"Value \\t Frequency \\n\");\n+        Enumeration e = freqTable.keys();\n+        Long count = null;\n+        String value = null;\n+        while (e.hasMoreElements()) {\n+            value = (String)e.nextElement();\n+            count = (Long)freqTable.get(value);\n+            outBuffer.append(value);\n+            outBuffer.append(\"\\t\");\n+            outBuffer.append(count.toString());\n+            outBuffer.append(\"\\n\");\n+        }\n+        return outBuffer.toString();\n+    }\n+\n+    public String toXML() {\n+        throw new UnsupportedOperationException(\"not implemented yet\");\n+    }\n+\n+    /** Adds 1 to the frequency count for v */\n+    public void addValue(java.lang.String v) {\n+        insertValue(v);\n+    }\n+\n+    /** Adds 1 to the frequency count for v */\n+    public void addValue(int v) {\n+        insertValue((new Integer(v)).toString());\n+    }\n+\n+    /** Adds 1 to the frequency count for v */\n+    public void addValue(long v) {\n+        insertValue((new Long(v)).toString());\n+    }\n+    \n+    /** Returns the number of values = v */\n+    public long getCount(String v) {\n+        Long ct = (Long)freqTable.get(v);\n+        if (ct == null) {\n+            return 0;\n+        } else {\n+            return ct.longValue();\n+        }\n+    }\n+    \n+    /** Returns the sum of all frequencies */\n+    public long getSumFreq() {\n+        Enumeration e = freqTable.keys();\n+        long count = 0;\n+        String value = null;\n+        while (e.hasMoreElements()) {\n+            value = (String)e.nextElement();\n+            count += ((Long)freqTable.get(value)).longValue();\n+        }\n+        return count;\n+    }\n+    \n+    /** Returns the percentage of values = v */\n+    public double getPct(String v) {\n+        return (new Double(getCount(v))).doubleValue()\n+                   /(new Double(getSumFreq())).doubleValue();\n+    }\n+    \n+    /** Clears the frequency table */\n+    public void clear() {\n+        freqTable.clear();\n+    }\n+        \n+    /** Adds 1 to the frequency count for v */\n+    private void insertValue(String v) {\n+        Long ct = (Long)freqTable.get(v);\n+        if (ct == null) {\n+            Long val = new Long(1);\n+            freqTable.put(v,val);\n+        } else {\n+            freqTable.put(v,(new Long(ct.longValue()+1)));\n+        }\n+    }\n+\n+    /** Getter for property name.\n+     * @return Value of property name.\n+     */\n+    public java.lang.String getName() {\n+        return name;\n+    }    \n+\n+    /** Setter for property name.\n+     * @param name New value of property name.\n+     */\n+    public void setName(java.lang.String name) {\n+        this.name = name;\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n  */\n package org.apache.commons.math.stat;\n \n-import java.util.Iterator;\n import java.util.List;\n \n /**\n--- a/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n  */\n package org.apache.commons.math.stat;\n \n-import org.apache.commons.math.DoubleArray;\n-import org.apache.commons.math.ContractableDoubleArray;\n+import org.apache.commons.math.util.ContractableDoubleArray;\n+import org.apache.commons.math.util.DoubleArray;\n \n /**\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.DoubleArray;\n-import org.apache.commons.math.FixedDoubleArray;\n+import org.apache.commons.math.util.DoubleArray;\n+import org.apache.commons.math.util.FixedDoubleArray;\n \n /**\n  *\n  * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n  * @author Brent Worden\n  * @author <a href=\"mailto:HotFusionMan@Yahoo.com\">Albert Davidson Chou</a>\n- * @version $Revision: 1.14 $ $Date: 2003/06/21 23:38:27 $\n+ * @version $Revision: 1.15 $ $Date: 2003/06/22 03:57:55 $\n  *\n */\n public class UnivariateImpl implements Univariate, Serializable {\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.analysis.ConvergenceException;\n+\n+/**\n+ * Provides a generic means to evaluate continued fractions.  Subclasses simply\n+ * provided the a and b coefficients to evaluate the continued fraction.\n+ * \n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+ * Continued Fraction</a></li>\n+ * </ul>\n+ * \n+ * @author Brent Worden\n+ */\n+public abstract class ContinuedFraction {\n+    /** Maximum allowed numerical error. */\n+    private static final double DEFAULT_EPSILON = 10e-9;\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    protected ContinuedFraction() {\n+        super();\n+    }\n+    \n+    /**\n+     * Access the n-th a coefficient of the continued fraction.  Since a can be\n+     * a function of the evaluation point, x, that is passed in as well.\n+     * @param n the coefficient index to retrieve.\n+     * @param x the evaluation point.\n+     * @return the n-th a coefficient.\n+     */\n+    protected abstract double getA(int n, double x);\n+    \n+    /**\n+     * Access the n-th b coefficient of the continued fraction.  Since b can be\n+     * a function of the evaluation point, x, that is passed in as well.\n+     * @param n the coefficient index to retrieve.\n+     * @param x the evaluation point.\n+     * @return the n-th b coefficient.\n+     */\n+    protected abstract double getB(int n, double x);\n+    \n+    /**\n+     * Evaluates the continued fraction at the value x.\n+     * @param x the evaluation point.\n+     * @return the value of the continued fraction evaluated at x. \n+     */\n+    public double evaluate(double x) {\n+        return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }    \n+    \n+    /**\n+     * Evaluates the continued fraction at the value x.\n+     * @param x the evaluation point.\n+     * @param epsilon maximum error allowed.\n+     * @return the value of the continued fraction evaluated at x. \n+     */\n+    public double evaluate(double x, double epsilon) {\n+        return evaluate(x, epsilon, Integer.MAX_VALUE);\n+    }    \n+    \n+    /**\n+     * Evaluates the continued fraction at the value x.\n+     * @param x the evaluation point.\n+     * @param maxIterations maximum number of convergents\n+     * @return the value of the continued fraction evaluated at x. \n+     */\n+    public double evaluate(double x, int maxIterations) {\n+        return evaluate(x, DEFAULT_EPSILON, maxIterations);\n+    }    \n+    \n+    /**\n+     * Evaluates the continued fraction at the value x.\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>O. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n+     * <a href=\"http://citeseer.nj.nec.com/egecioglu91fast.html\">\n+     * Fast Computation of Continued Fractions</a>, Computers Math. Applic.,\n+     * 21(2--3), 1991, 167--169.</li>\n+     * </ul>\n+     * \n+     * @param x the evaluation point.\n+     * @param epsilon maximum error allowed.\n+     * @param maxIterations maximum number of convergents\n+     * @return the value of the continued fraction evaluated at x. \n+     */\n+    public double evaluate(double x, double epsilon, int maxIterations) {\n+        double[][] f = new double[2][2];\n+        double[][] a = new double[2][2];\n+        double[][] an = new double[2][2];\n+        \n+        a[0][0] = getA(0, x);\n+        a[0][1] = 1.0;\n+        a[1][0] = 1.0;\n+        a[1][1] = 0.0;\n+\n+        return evaluate(1, x, a, an, f, epsilon, maxIterations);\n+    }\n+    \n+    /**\n+     * Evaluates the n-th convergent, fn = pn / qn, for this continued fraction\n+     * at the value x.\n+     * @param n the convergent to compute.\n+     * @param x the evaluation point.\n+     * @param a (n-1)-th convergent matrix.  (Input)\n+     * @param an the n-th coefficient matrix. (Output)\n+     * @param f the n-th convergent matrix. (Output)\n+     * @param epsilon maximum error allowed.\n+     * @param maxIterations maximum number of convergents\n+     * @return the value of the the n-th convergent for this continued fraction\n+     *         evaluated at x. \n+     */\n+    private double evaluate(int n, double x, double[][] a, double[][] an,\n+            double[][] f, double epsilon, int maxIterations) {\n+        double ret;\n+        \n+        // create next matrix\n+        an[0][0] = getA(n, x);\n+        an[0][1] = 1.0;\n+        an[1][0] = getB(n, x);\n+        an[1][1] = 0.0;\n+        \n+        // multiply a and an, save as f\n+        f[0][0] = (a[0][0] * an[0][0]) + (a[0][1] * an[1][0]);\n+        f[0][1] = (a[0][0] * an[0][1]) + (a[0][1] * an[1][1]);\n+        f[1][0] = (a[1][0] * an[0][0]) + (a[1][1] * an[1][0]);\n+        f[1][1] = (a[1][0] * an[0][1]) + (a[1][1] * an[1][1]);\n+        \n+        // determine if we're close enough\n+        if (Math.abs((f[0][0] * f[1][1]) - (f[1][0] * f[0][1])) <\n+                Math.abs(epsilon * f[1][0] * f[1][1])) {\n+            ret = f[0][0] / f[1][0];\n+        } else {\n+            if (n >= maxIterations) {\n+                throw new ConvergenceException(\n+                    \"Continued fraction convergents failed to converge.\");\n+            }\n+            // compute next\n+            ret = evaluate(n + 1, x, f /* new a */, an /* reuse an */,\n+                            a /* new f */, epsilon, maxIterations);\n+        }\n+        \n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>\n+ * A variable length double array implementation and extension of \n+ * ExpandableDoubleArray which automatically handles expanding and\n+ * contracting double arrays.\n+ * </p>\n+ *\n+ * <p>\n+ * This class extends the functionality of ExpandableDoubleArray and\n+ * inherits the expansion parameters from that class.  If a developer\n+ * instantiates a ContractableDoubleArray and only adds values to\n+ * that instance, the behavior of this class is no different from\n+ * the behavior of the super-class ExpandableDoubleArray.  If, on the\n+ * other hand, elements are removed from the array, this implementation\n+ * tests an additional parameter <code>contractionCriteria</code>.  The\n+ * <code>contractionCriteria</code> dictates when this implementation\n+ * will contract the size of the internal storage array to\n+ * the number of elements + 1.  This check is performed after every\n+ * operation that alters the number of elements in the array.\n+ * </p>\n+ *\n+ * <p>\n+ * Note that the contractionCriteria must always be greater than the\n+ * expansionFactor.  If this were not the case (assume a \n+ * contractionCriteria of 1.5f and a expansionFactor of 2.0f) an\n+ * endless series of expansions and contractions would occur.  If the \n+ * length of this array is highly varied over time it is a good idea\n+ * to trade efficient memory usage for performance.  Each time an array\n+ * is expanded or contracted the meaningful portions of the internal\n+ * storage array are copied to a new array and the reference to the \n+ * internal storage array is swapped.\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ContractableDoubleArray \n+    extends ExpandableDoubleArray \n+    implements Serializable {\n+\n+    // The contraction criteria defines the conditions under which this\n+    // object will \"resize\" the internal array to the number of elements\n+    // contained in the element array + 1\n+    protected float contractionCriteria = 2.5f;\n+\n+    /**\n+     * Create an expandable double array with the default initial capacity of \n+     * 16, an expansion factor of 2.00, and a contractionCriteria of 2.5\n+     */\n+    public ContractableDoubleArray() {\n+        super();\n+    }\n+\n+    /**\n+     * Create an expandable double array with the specified initial capacity, \n+     * the defult expansion factor of 2.00, and a contractionCriteria of 2.5\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     */\n+    public ContractableDoubleArray(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Create an expandable double array with the specificed initial capacity \n+     * and expand factor, with a contractionCriteria of 2.5\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     */\n+    public ContractableDoubleArray(int initialCapacity, \n+                                   float expansionFactor) {\n+        this.expansionFactor = expansionFactor;\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+        checkContractExpand(getContractionCriteria(), expansionFactor);\n+    }\n+\n+    /**\n+     * Create an expandable double array with the\n+     * specificed initial capacity, expand factor, and contractionCriteria\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     */\n+    public ContractableDoubleArray(int initialCapacity, \n+                                   float expansionFactor, \n+                                   float contractionCriteria) {\n+        this.contractionCriteria = contractionCriteria;\n+        this.expansionFactor = expansionFactor;\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+        checkContractExpand(contractionCriteria, expansionFactor);\n+    }\n+\n+    /**\n+     * Contracts the storage array to the (size of the element set) + 1 - to \n+     * avoid a zero length array. This function also resets the startIndex to \n+     * zero. \n+     */\n+    public synchronized void contract() {\n+        double[] tempArray = new double[numElements + 1];\n+\n+        // Copy and swap - copy only the element array from the src array.\n+        System.arraycopy(internalArray,startIndex,tempArray,0,numElements);\n+        internalArray = tempArray;\n+\n+        // Reset the start index to zero\n+        startIndex = 0;\n+    }\n+\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @param value to be added to end of array\n+     */\n+    public synchronized void addElement(double value) {\n+        super.addElement(value);\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds an element to the end of this expandable array and \n+     * discards a value from the front of the array.  This method\n+     * has the effect of adding a value to the end of the list\n+     * and discarded an element from the front of the list.\n+     * </p>\n+     *\n+     * <p>\n+     * When an array rolls it actually \"scrolls\" the element array in \n+     * the internal storage array.  An element is added to the end of the\n+     * array, and the first element of the array is discard by incrementing\n+     * the starting index of the element array within the internal\n+     * storage array.  Over time this will create an orphaned prefix\n+     * to the element array within the internal storage array.  If this\n+     * function is called frequently, this orphaned prefix list will\n+     * gradually push the internal storage vs. element storage to\n+     * the contractionCriteria.\n+     * </p>\n+     * \n+     * @return value to be added to end of array\n+     */\n+    public synchronized double addElementRolling(double value) {\n+        double discarded = super.addElementRolling(value);\n+        // Check the contraction criteria\n+        if (shouldContract()) {\n+            contract();\n+        }\n+        return discarded;\n+    }\n+\n+    /**\n+     * Should contract returns true if the ratio of (internal storage length) \n+     * to (number of elements) is larger than the contractionCriteria value.  \n+     * In other words, using the default value of 2.5, if the internal storage\n+     * array provides more than 2.5x the space needed to store numElements, \n+     * then this function returns true\n+     * \n+     * @return true if array satisfies the contraction criteria\n+     */\n+    private synchronized boolean shouldContract() {\n+        boolean shouldContract = false;\n+        if ((internalArray.length / numElements) > contractionCriteria) {\n+            shouldContract = true;\n+        }\n+        return shouldContract;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.ExpandableDoubleArray#setElement(int, double)\n+     */\n+    public synchronized void setElement(int index, double value) {\n+        super.setElement(index, value);\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /**\n+     * Method invokes the super class' setExpansionFactor but first it\n+     * must validate the combination of expansionFactor and \n+     * contractionCriteria.\n+     *\n+     * @see org.apache.commons.math.ExpandableDoubleArray#setExpansionFactor(float)\n+     */\n+    public void setExpansionFactor(float expansionFactor) {\n+        checkContractExpand(getContractionCriteria(), expansionFactor);\n+        super.setExpansionFactor(expansionFactor);\n+    }\n+\n+    /**\n+     * The contraction criteria defines when the internal array will contract \n+     * to store only the number of elements in the element array.  This \n+     * contractionCriteria gaurantees that the internal storage array will \n+     * never exceed this factor more than the space needed to store \n+     * numElements.\n+     * \n+     * @return the contraction criteria used to reclaim memory when array is \n+     *         empty\n+     */\n+    public float getContractionCriteria() {\n+        return contractionCriteria;\n+    }\n+\n+    /**\n+     * Sets the contraction criteria for this ExpandContractDoubleArray. \n+     * \n+     * @param contractionCriteria contraction criteria\n+     */\n+    public void setContractionCriteria(float contractionCriteria) {\n+        checkContractExpand(contractionCriteria, getExpansionFactor());\n+\n+        this.contractionCriteria = contractionCriteria;\n+    }\n+\n+    /**\n+     * Checks the expansion factor and the contraction criteria and throws an \n+     * IllegalArgumentException if the contractionCriteria is less than the \n+     * expansionCriteria\n+     * \n+     * @param expansionFactor \n+     * @param contractionCritera\n+     */\n+    protected void checkContractExpand(float contractionCritera, \n+                                        float expansionFactor) {\n+\n+        if (contractionCritera < expansionFactor) {\n+            String msg = \"Contraction criteria can never be smaller than \" +\n+                \"the expansion factor.  This would lead to a never ending \" +\n+                \"loop of expansion and contraction as a newly expanded \" +\n+                \"internal storage array would immediately satisfy the \" +\n+                \"criteria for contraction\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        if (contractionCriteria <= 1.0) {\n+            String msg = \"The contraction criteria must be a number larger \" +\n+                \"than one.  If the contractionCriteria is less than or \" +\n+                \"equal to one an endless loop of contraction and expansion \" +\n+                \"would ensue as an internalArray.length == numElements \" +\n+                \"would satisfy the contraction criteria\";\n+            throw new IllegalArgumentException(msg); \n+        }\n+\n+        if (expansionFactor < 1.0) {\n+            String msg = \"The expansion factor must be a number greater \" +\n+                \"than 1.0\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.ExpandableDoubleArray#discardFrontElements(int)\n+     */\n+    public synchronized void discardFrontElements(int i) {\n+        super.discardFrontElements(i);\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/DoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+\n+/**\n+ * Provides a single interface for dealing with various flavors\n+ * of double arrays.  This arrays framework follows the model of the\n+ * Collections API by allowing a user to select from a number of \n+ * array implementations with support for various storage mechanisms\n+ * such as automatic expansion, contraction, and array \"rolling\".\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public interface DoubleArray {\n+\n+    /**\n+     * Returns the number of elements currently in the array.  Please note\n+     * that this is different from the length of the internal storage array.  \n+     * @return number of elements\n+     */\n+    int getNumElements();\n+\n+    /**\n+     * Returns the element at the specified index.  Note that if an\n+     * out of bounds index is supplied a ArrayIndexOutOfBoundsException \n+     * will be thrown.\n+     * \n+     * @param index index to fetch a value from\n+     * @return value stored at the specified index\n+     *\n+     */\n+    double getElement(int index);\n+\n+    /**\n+     * Sets the element at the specified index.  This method will expand the \n+     * internal storage array to accomodate the insertion of a value at an \n+     * index beyond the current capacity.\n+     * @param index index to store a value in\n+     * @param value value to store at the specified index\n+     */\n+    void setElement(int index, double value);\n+\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @param value to be added to end of array\n+     */\n+    void addElement(double value);\n+\n+    /**\n+     * Adds an element and moves the window of elements up one.  This\n+     * has the effect of a FIFO.  when you \"roll\" the array an element is \n+     * removed from the array.  The return value of this function is the \n+     * discarded double.\n+     * \n+     * @param value the value to be added to the array\n+     * @return the value which has been discarded or \"pushed\" out of the array\n+     *         by this rolling insert.\n+     */\n+    double addElementRolling(double value);\n+\n+    /**\n+     * Returns a double[] of elements\n+     *\n+     * @return all elements added to the array\n+     */\n+    double[] getElements();\n+\n+    /**\n+     * Clear the double array\n+     */\n+    void clear();\n+\n+    /**\n+     * Discards values from the front of the list.  This function removes n \n+     * elements from the front of the array.\n+     * \n+     *@param i number of elements to discard from the front of the array.\n+     */\n+    void discardFrontElements(int i);\n+\n+    /**\n+     * Returns the minimum value stored in this array\n+     *\n+     * @return minimum value contained in this array\n+     */\n+    double getMin();\n+\n+    /**\n+     * Returns the maximum value stored in this array\n+     *\n+     * @return maximum value contained in this array\n+     */\n+    double getMax();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>\n+ * A DoubleArray implementation which automatically expands\n+ * an internal double array to handle an array of arbitrary length.  This \n+ * implementation of DoubleArray is provided to support scenarios in\n+ * which the ultimate length of an array is unknown, and the \n+ * developer can control the expansion process through the\n+ * <code>initialCapacity</code> and <code>expansionFactor</code> \n+ * parameters.\n+ * </p>\n+ *\n+ * <p>\n+ * This implementation also allows a developer to:\n+ * <ul>\n+ *  <li>Resize an array via <code>setNumElements(int)</code></li>\n+ *  <li>Discard elements from the front of an array via\n+ *      <code>discardFrontElements(int)</code></li>\n+ *  <li>Find the minimum and maximum values stored in this array</li>\n+ * </ul>\n+ * </p>\n+ *\n+ * <p>\n+ * The initialCapacity parameter sets the capacity of the initial\n+ * storage array, and the expansionFactor is the factor by which\n+ * the current storage capacity is multiplied each time the internal\n+ * array needs to be expanded.  <b>Please note</b> that the length of the \n+ * internal storage array has nothing to do with the number of elements \n+ * currently stored in this array.  If one creates an instance of this\n+ * class with an initialCapacity of \"2\" and an expansion factor of \"2\", and\n+ * then adds 3546 elements to the array, this implementation will need to\n+ * expand the array 10 times - first from 2 -> 4. then 4 -> 8, 8 -> 16,\n+ * and so on until we reach 4096 which is sufficient to hold 3546 elements.\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ExpandableDoubleArray implements Serializable, DoubleArray {\n+\n+    // TODO: expansionFactor is valuable, by if I only need storage\n+    // for 1025 items and I use the default settings, I'll end up\n+    // with enough storage for 2048 elements.  Maybe this implementation\n+    // should have flags for incremental growth - (i.e. when expanding, only\n+    // increase storage by a constant size - 100, 200 ) ?\n+\n+    // This is the internal storage array.\n+    protected double[] internalArray;\n+\n+    // Number of elements in the array\n+    protected int numElements = 0;\n+\n+    // Keeps track of a starting index\n+    protected int startIndex = 0;\n+\n+    // The initial capacity of the array. \n+    // Initial capacity is not exposed as a property as it is only meaningful\n+    // when passed to a constructor.\n+    protected int initialCapacity = 16;\n+\n+    // The expand factor of the array.  When the array need to be expanded, \n+    // the new array size will be internalArray.length * expandFactor \n+    protected float expansionFactor = 2.0f;\n+\n+    /**\n+     * Create an expandable double array with the\n+     * default initial capactiy of 16 and an expansion factor of 2.00\n+     */\n+    public ExpandableDoubleArray() {\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * Create an expandable double array with the\n+     * specified initial capacity and the defult expansion factor of 2.00\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     */\n+    public ExpandableDoubleArray(int initialCapacity) {\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[this.initialCapacity];\n+    }\n+\n+    /**\n+     * Create an expandable double array with the\n+     * specificed initial capacity and expand factor.\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     */\n+    public ExpandableDoubleArray(int initialCapacity, float expansionFactor) {\n+        setInitialCapacity(initialCapacity);\n+        setExpansionFactor(expansionFactor);\n+        this.initialCapacity = initialCapacity;\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * The expansion factor controls the size of a new aray when an array \n+     * needs to be expanded. When a value is inserted into a full array, the \n+     * new array size is calculated as the current array size times this \n+     * expansion factor.  The default expansion factor is 2.0\n+     * \n+     * @return the expansion factor of this expandable double array\n+     */\n+    public float getExpansionFactor() {\n+        return expansionFactor;\n+    }\n+\n+    /**\n+     * Sets the expansion factor for this expandable double array.  \n+     * The expansion factor will affect the next expansion of this array.\n+     * \n+     * @param expansionFactor the expansion factor of this array\n+     */\n+    public void setExpansionFactor(float expansionFactor) {\n+\n+        // The expansion factor *must* be larger than 1.0, otherwise we'll \n+        // have an inconsistency upon expansion we'll start shrinking which \n+        // will lead to ArrayIndexOutOfBound exceptions.\n+        if (expansionFactor > 1.0) {\n+            this.expansionFactor = expansionFactor;\n+        } else {\n+            String msg = \"The expansion factor must be a number greater \" +\n+                \"than 1.0\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n+    /**\n+     * Sets the initial capacity\n+     * \n+     * @param initialCapacity\n+     */\n+    public void setInitialCapacity(int initialCapacity) {\n+        if (initialCapacity > 0) {\n+            this.initialCapacity = initialCapacity;\n+        } else {\n+            String msg = \"The initial capacity supplied: \" + initialCapacity +\n+                \"must be a positive integer\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n+    /**\n+     * Returns the internal storage array\n+     * \n+     * @return the internal storage array used by this object\n+     */\n+    protected double[] getValues() {\n+        return (internalArray);\n+    }\n+\n+    /**\n+     * Returns the number of elements currently in the array.  Please note\n+     * that this is different from the length of the internal storage array.  \n+     * @return number of elements\n+     */\n+    public int getNumElements() {\n+        return (numElements);\n+    }\n+\n+    /**\n+     * This function allows you to control the number of elements contained \n+     * in this array, and can be used to \"throw\" out the last n values in an \n+     * array.  This feature is mainly targetted at the subclasses of this \n+     * array class.  Note that this function will also expand the internal \n+     * array as needed.\n+     * \n+     * @param i a new number of elements\n+     */\n+    public synchronized void setNumElements(int i) {\n+\n+        // If index is negative thrown an error\n+        if (i <  0) {\n+            String msg = \"Number of elements must be zero or a positive \" +\n+                \"integer\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        // Test the new num elements, check to see if the array needs to be \n+        // expanded to accomodate this new number of elements\n+        if ((startIndex + i) > internalArray.length) {\n+            expandTo(startIndex + i);\n+        }\n+\n+        // Set the new number of elements to new value\n+        numElements = i;\n+    }\n+\n+    /**\n+     * Returns the element at the specified index\n+     * \n+     * @param index index to fetch a value from\n+     * @return value stored at the specified index\n+     */\n+    public double getElement(int index) {\n+        double value = Double.NaN;\n+        if (index >= numElements) {\n+            String msg = \"The index specified: \" + index + \n+                \" is larger than the current number of elements\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else if (index >= 0) {\n+            value = internalArray[startIndex + index];\n+        } else {\n+            String msg = \"Elements cannot be retrieved from a negative \" +\n+                \"array index\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Sets the element at the specified index.  This method will expand the \n+     * internal storage array to accomodate the insertion of a value at an \n+     * index beyond the current capacity.\n+     *\n+     * @param index index to store a value in\n+     * @param value value to store at the specified index\n+     */\n+    public synchronized void setElement(int index, double value) {\n+\t\t\n+\t\tif (index < 0) {\n+            String msg = \"Cannot set an element at a negative index\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        }\n+\n+        if ((startIndex + index) >= internalArray.length) {\n+            expandTo(startIndex + (index + 1));\n+            numElements = index + 1;\n+        }\n+        internalArray[startIndex + index] = value;\n+    }\n+\n+    /**\n+     * Expands the internal storage array to the specified size.\n+     * \n+     * @param size Size of the new internal storage array\n+     */\n+    private synchronized void expandTo(int size) {\n+        double[] tempArray = new double[size];\n+        // Copy and swap\n+        System.arraycopy(internalArray,0,tempArray,0,internalArray.length);\n+        internalArray = tempArray;\n+    }\n+\n+    /**\n+     * Expands the internal storage array using the expansion factor\n+     */\n+    protected synchronized void expand() {\n+\n+\t\t// notice the use of Math.ceil(), this gaurantees that we will always \n+        // have an array of at least currentSize + 1.   Assume that the \n+        // current initial capacity is 1 and the expansion factor\n+\t\t// is 1.000000000000000001.  The newly calculated size will be \n+        // rounded up to 2 after the multiplication is performed.\n+        int newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n+        double[] tempArray = new double[newSize];\n+\n+        // Copy and swap\n+        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n+        internalArray = tempArray;\n+    }\n+\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @param value value to be added to end of array\n+     */\n+    public synchronized void addElement(double value) {\n+        numElements++;\n+        if ((startIndex + numElements) > internalArray.length) {\n+            expand();\n+        }\n+        internalArray[startIndex + (numElements - 1)] = value;\n+    }\n+\n+    /**\n+     * Adds an element and moves the window of elements up one.  This\n+     * has the effect of a FIFO.  when you \"roll\" the array an element is \n+     * removed from the array.  The return value of this function is the \n+     * discarded double.\n+     * \n+     * @return the value which has been discarded or \"pushed\" out of the array\n+     * \t  by this rolling insert.\n+     */\n+    public synchronized double addElementRolling(double value) {\n+        double discarded = internalArray[startIndex];\n+\n+        if ((startIndex + (numElements+1)) > internalArray.length) {\n+            expand();\n+        }\n+        // Increment the start index\n+        startIndex += 1;\n+\n+        // Add the new value\n+        internalArray[startIndex + (numElements - 1)] = value;\n+\n+        return discarded;\n+    }\n+\n+    /**\n+     * Notice the package scope on this method.   This method is simply here \n+     * for the JUnit test, it allows us check if the expansion is working \n+     * properly after a number of expansions.  This is not meant to be a part \n+     * of the public interface of this class.\n+     * \n+     * @return the length of the internal storage array.\n+     */\n+    int getInternalLength() {\n+        return (internalArray.length);\n+    }\n+\t\n+    /**\n+     * Clear the array, reset the size to the initialCapacity and the number \n+     * of elements to zero.\n+     */\n+    public synchronized void clear() {\n+        numElements = 0;\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * Discards values from the front of the list.  This function removes n \n+     * elements from the front of the array.\n+     * \n+     * @param i number of elements to discard from the front of the array.\n+     */\n+    public synchronized void discardFrontElements(int i) {\n+\n+        if (i > numElements) {\n+            String msg = \"Cannot discard more elements than are\" +\n+                \"contained in this array.\";\n+            throw new IllegalArgumentException(msg);\n+        } else if (i < 0) {\n+            String msg = \"Cannot discard a negative number of elements.\";\n+            throw new IllegalArgumentException(msg);\n+        } else {\n+            // \"Subtract\" this number of discarded from numElements \n+            numElements -= i;\n+            startIndex += i;\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getElements()\n+     */\n+    public double[] getElements() {\n+        double[] elementArray = new double[numElements];\n+        System.arraycopy(internalArray, startIndex, \n+                         elementArray, 0, numElements);\n+        return elementArray;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getMax()\n+     */\n+    public double getMax() {\n+        double max = internalArray[startIndex];\n+\t\t\n+        for (int i = startIndex + 1; i < (numElements + startIndex); i++) {\n+            if (internalArray[i] > max) {\n+                max = internalArray[i];\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.DoubleArray#getMin()\n+     */\n+    public double getMin() {\n+        double min = internalArray[startIndex];\n+\n+        for (int i = startIndex + 1; i < (numElements + startIndex); i++) {\n+            if (internalArray[i] < min) {\n+                min = internalArray[i];\n+            }\n+        }\n+\n+        return min;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+\n+/**\n+ * <p>\n+ * Provides an implementation of the DoubleArray with a maximum number of\n+ * elements.  Creating an array implementation with an upper limit on the\n+ * number of elements allows us to support a more efficient \"rolling\" \n+ * mechanism to support addElementRoling(double). Please note that this\n+ * implementation will not preserve the order of the values supplied to\n+ * this array, calling getValues() will return an array of indeterminate\n+ * order.\n+ * </p>\n+ * \n+ * <p>\n+ * Values are added to this array by calling addElement(double) or \n+ * addElementRolling(double).  If addElement(double) is called on \n+ * an array that already contains the maximum number of elements, an\n+ * ArrayIndexOutOfBoundsException will be thrown to reflect an attempt to\n+ * add a value beyond the boundaries of the fixed length array - in this\n+ * respect a FixedDoubleArray can be considered \"full\".  Calling \n+ * addElementRolling(double) on an array which contains the maximum\n+ * number of elements will cause the array to overwrite the \"oldest\"\n+ * value in the array.\n+ * </p>\n+ *\n+ * <p>\n+ * This class is called FixedDoubleArray not because it is of a fixed size.\n+ * The name is appropriate because the internal storage array remains \n+ * \"fixed\" in memory, this implementation will never allocate, or copy\n+ * the internal storage array to a new array instance.\n+ * </p>\n+ *\n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class FixedDoubleArray implements DoubleArray {\n+\n+    // This is the internal storage array.  This array is assigned\n+    // a known fixed size in the constructor.\n+    double[] internalArray;\n+\n+    // Size determined the number of elements in the array at\n+    // any given time. When an array is created is maxElements\n+    // of 100, it is of size 0, and size increases as values are\n+    // added.\n+    int size = 0;\n+\n+    // This index points to the location of the next update.  Next\n+    // add, cycles from 0 to (maxElement-1)\n+    int nextAdd = 0;\n+\n+    // The maximum number of elements in the FixedDoubleArray\n+    int maxElements = 0;\n+\n+    /**\n+     * Create a fixed array for double primitives which can hold up to\n+     * <code>maxElements</codec> doubles.  This implementation of \n+     * DoubleArray was created to provide a more \"performance-oriented\"\n+     * in-place rolling mechanism for calculations which need to\n+     * operate on a rolling window of values.\n+     *\n+     * @param maxElements the maximum number of elements this \n+     *        FixeddoubleArray may contain.\n+     */\n+    public FixedDoubleArray(int maxElements) {\n+        this.maxElements = maxElements;\n+        internalArray = new double[maxElements];\n+    }\n+\n+    /**\n+     * Retrieves the current size of the array.\n+     * @see org.apache.commons.math.DoubleArray#getNumElements()\n+     */\n+    public int getNumElements() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns the element value at the specified index.  Please note that\n+     * the size of the element array is not directly related to the \n+     * maximum number of elements which this array can contain.  One can\n+     * create an instance of FixedDoubleArray with a maximum of\n+     * ten elements, add three items, and get any items from index 0 to index\n+     * 2 - trying to retrieve an element outside of the current element\n+     * array will throw an ArrayIndexOutOfBoundsException.\n+     *\n+     * @see org.apache.commons.math.DoubleArray#getElement(int)\n+     */\n+    public double getElement(int index) {\n+        if (index > (size-1)) {\n+            String msg = \"Attempted to retrieve an element outside of \" +\n+                \"the element array\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else {\n+\t    // Return the element requested, if the index supplied\n+\t    // is negative this statement may also throw an\n+\t    // ArrayIndexOutOfBoundException.\n+            return internalArray[index];\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the element at the specified index to the value supplied.\n+     * </p>\n+     *\n+     * <p>Implementation Notes:\n+     * <ul>\n+     *  This implementation will not expand the array to the specified\n+     *  size.  Unlike the expandable double array implementation calling\n+     *  setElement(10, 3.0) on an array with 5 elements will throw an\n+     *  ArrayIndexOutOfBoundsException.\n+     * </ul>\n+     * <ul>\n+     *  The number of elements in an array corresponds to the number\n+     *  of elements that have been added to this FixedDoubleArray.  This\n+     *  is not the same as the maximum number of elements which can be\n+     *  contained in this array.  A FixedDoubleArray instance can be\n+     *  created with a maximum upper limit of 10 elements, until 10\n+     *  elements have been added to this array, the size of the array\n+     *  reflects the number of elements added.\n+     * </ul>\n+     * </p>\n+     *\n+     * @see org.apache.commons.math.DoubleArray#setElement(int, double)\n+     */\n+    public void setElement(int index, double value) {\n+        if (index > (size-1)) {\n+            String msg = \"Attempted to set an element outside of\" +\n+\t\t\t\t\"the element array\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+        } else {\n+            internalArray[index] = value;\n+        }\n+    }\n+\n+    /** \n+     * Add an element to the current array, testing to see if \n+     * this array has already met or exceeded the maximum number\n+     * of elements\n+     *\n+     * @see org.apache.commons.math.DoubleArray#addElement(double)\n+     */\n+    public void addElement(double value) {\n+        if (size < internalArray.length) {\n+            size++;\n+\n+            internalArray[nextAdd] = value;\n+\n+\t    // Incremenet nextAdd and then modulo it against maxElements\n+\t    // this has the effect of repeatedly \"cycling\" nextAdd\n+\t    // between 0 and (maxElements-1) endlessly.\n+            nextAdd++;\n+            nextAdd = nextAdd % (maxElements);\n+\n+        } else {\n+\t    // If the array has ALREADY reached the maximum size allowable,\n+\t    // we throw an ArrayIndexOutOfBoundsException - the end-user\n+\t    // is trying to add an element beyond the boundaries of the\n+\t    // fixed array.\n+            String msg = \"Attempted to add a value to an array of fixed \" +\n+                \"size, please use addElementRolling to avoid this exception\";\n+            throw new ArrayIndexOutOfBoundsException(msg);\n+\t}\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds an element by \"rolling\" the new value into the current array \n+     * while discarding the element which was added <code>maxElement</code>\n+     * add operations ago.  The value replaced is returned from this \n+     * method.  Until an array contains the maximum number of element, this\n+     * method has the same result as the addElement(double) operation.  Once\n+     * the maximum number of elements has been reached this implementation\n+     * inserts the new values starting at index 0 of the internal storage \n+     * array.  This allows for efficient rolling, but prevents us from \n+     * preserving the order of the added values.\n+     * </p>\n+     *\n+     * <p>\n+     * <b>Note:</b> This function will return <code>Double.NaN</code> if\n+     * no value has been discarded in this roll.  This can happen when\n+     * the array has not met the size limitation introduced in the \n+     * constructor.\n+     * </p>\n+     *\n+     * @return Returns the value which a has been \"removed\" from the \n+     *         database.  <b>Important:</b> If the element array has\n+     *         not reached the maximum size, then it is possible that\n+     *         no element will be discarded from a given roll.  In this\n+     *         case this method will return a <code>Double.NaN</code> value.\n+     *\n+     * @see org.apache.commons.math.DoubleArray#addElementRolling(double)\n+     */\n+    public double addElementRolling(double value) {\n+\n+\t// Create the discarded primitive.  If no element is\n+\t// discarded by this roll, this method will return a\n+\t// Double.NaN value.\n+\tdouble discarded = Double.NaN;\n+\n+        if (size < internalArray.length) {\n+            size++;\n+        } else {\n+\t    // If we've reached the length of the internal\n+\t    // storage array, we have to start \"discarding\"\n+\t    // values from the original array.\n+\n+\t    // Obtain the value discarded by this overwrite\n+\t    discarded = internalArray[nextAdd];\n+\t}\n+\n+        internalArray[nextAdd] = value;\n+\n+\t// nextAdd cycles between 0 and (maxElements-1).\n+        nextAdd++;\n+        nextAdd = nextAdd % maxElements;\t\n+\n+        // but we return the value which was \"replaced\"\n+        return (discarded);\t\t\n+    }\n+\n+    /**\n+     * Provides an array of double[] which contain the\n+     * number of elements added to this array.  This  \n+     * method will return an array from zero to maxElements in length.\n+     * \n+     * @return The array of elements added to this DoubleArray\n+     *         implementation.\n+     * @see org.apache.commons.math.DoubleArray#getElements()\n+     */\n+    public double[] getElements() {\n+        double[] copy = new double[size];\n+        System.arraycopy(internalArray, 0, copy, 0, size);\n+        return copy;\n+    }\n+\n+    /**\n+     * Clear the array - drop all the data and start with a blank\n+     * internal array.  This implementation takes care of\n+     * setting the size of the array back to zero, and reinitializing\n+     * the internal storage array.\n+     *\n+     * @see org.apache.commons.math.DoubleArray#clear()\n+     */\n+    public void clear() {\n+        size = 0;\n+        nextAdd = 0;\n+        internalArray = new double[maxElements];\n+    }\n+\n+    /**\n+     * This method is not implemented in this implemetnation of\n+     * DoubleArray.  Until the size of the element array meets the\n+     * maxElements condition introduced in the constructor this is\n+     * a regular array.  When the size of the array is at a maximum\n+     * this array starts to function more as a circular list of \n+     * double primitives.  In a circular \"rolling\" data structure it\n+     * make little sense to allow people to \"drop\" objects from the\n+     * \"front\". \n+     *\n+     * @param i number of elements to discard.\n+     *\n+     * @see org.apache.commons.math.DoubleArray#discardFrontElements(int)\n+     */\n+    public void discardFrontElements(int i) {\n+        // TODO: AH! implemented there is not concept of \"front\"\n+        // in an array that discards values when rolling.....  anyone?\n+        String msg = \"Discarding front element not supported in \" +\n+            \"FixedDoubleArray\";\n+        throw new RuntimeException(msg);\n+    }\n+\n+    /**\n+     * Retrieves the minimum double value contained in this array.\n+     *\n+     * @return The number less than all other numbers in this \n+     *         array.\n+     * @see org.apache.commons.math.DoubleArray#getMin()\n+     */\n+    public double getMin() {\n+        double min = internalArray[0];\n+        for (int i = 1; i < size; i++) {\n+            if (internalArray[i] < min) {\n+                min = internalArray[i];\n+            }\n+        }\n+        return min;\n+    }\n+\n+    /**\n+     * Retrieves the maximum double value contained in this array.\n+     * \n+     * @return The number greater than all other numbers in this\n+     *         array.\n+     * @see org.apache.commons.math.DoubleArray#getMax()\n+     */\n+    public double getMax() {\n+        double max = internalArray[0];\n+        for (int i = 1; i < size; i++) {\n+            if (internalArray[i] > max) {\n+                max = internalArray[i];\n+            }\n+        }\n+        return max;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+/**\n+ * Some useful additions to the built-in functions in lang.Math<p>\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:56 $\n+ */\n+public class MathUtils {\n+\n+    /**\n+     * For a double precision value x, this method returns +1.0 if x >= 0\n+     * and -1.0 if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a double\n+     * @return +1.0 or -1.0, depending on the the sign of x\n+     */\n+    public static double sign( double x ) {\n+        if ( x >= 0.0 ) {\n+            return 1.0 ;\n+        } else {\n+            return -1.0 ;\n+        }\n+    }\n+\n+    /**\n+     * For a float value x, this method returns +1.0F if x >= 0\n+     * and -1.0F if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a float\n+     * @return +1.0F or -1.0F, depending on the the sign of x\n+     */\n+    public static float sign( float x ) {\n+        if ( x >= 0.0F ) {\n+            return 1.0F ;\n+        } else {\n+            return -1.0F ;\n+        }\n+    }\n+\n+    /**\n+     * For a byte value x, this method returns (byte)(+1) if x >= 0\n+     * and (byte)(-1) if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a byte\n+     * @return (byte)(+1) or (byte)(-1), depending on the the sign of x\n+     */\n+    public static byte sign( byte x ) {\n+        if ( x >= (byte)0 ) {\n+            return (byte)1 ;\n+        } else {\n+            return (byte)(-1) ;\n+        }\n+    }\n+\n+    /**\n+     * For a short value x, this method returns (short)(+1) if x >= 0\n+     * and (short)(-1) if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a short\n+     * @return (short)(+1) or (short)(-1), depending on the the sign of x\n+     */\n+    public static short sign( short x ) {\n+        if ( x >= (short)0 ) {\n+            return (short)1 ;\n+        } else {\n+            return (short)(-1) ;\n+        }\n+    }\n+\n+    /**\n+     * For an int value x, this method returns +1 if x >= 0\n+     * and -1 if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, an int\n+     * @return +1 or -1, depending on the the sign of x\n+     */\n+    public static int sign( int x ) {\n+        if ( x >= 0 ) {\n+            return 1 ;\n+        } else {\n+            return -1 ;\n+        }\n+    }\n+ \n+    /**\n+     * For a long value x, this method returns +1L if x >= 0\n+     * and -1L if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a long\n+     * @return +1L or -1L, depending on the the sign of x\n+     */\n+    public static long sign( long x ) {\n+        if ( x >= 0L ) {\n+            return 1L ;\n+        } else {\n+            return -1L ;\n+        }\n+    }\n+   /**\n+    * Returns an exact representation of the\n+    * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n+    * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n+    * the number of <code>k</code>-element subsets that can be selected from\n+    * an <code>n</code>-element set.\n+    * <p>\n+    * <Strong>Preconditions</strong>:<ul>\n+    * <li> <code>0 < k <= n </code> (otherwise \n+    * <li> <code>0 < k <= n </code> (otherwise\n+    *      <code>IllegalArgumentException</code> is thrown)</li>\n+    * <li> The result is small enough to fit into a <code>long</code>.  The \n+    *      largest value of <code>n</code> for which all coefficients are \n+    *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value \n+    * <li> The result is small enough to fit into a <code>long</code>.  The\n+    *      largest value of <code>n</code> for which all coefficients are\n+    *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n+    *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n+    *      </code> is thrown.</li>\n+    * </ul>\n+    * \n+    *\n+    * @param n the size of the set\n+    * @param k the size of the subsets to be counted\n+    * @return <code>n choose k</code>\n+    */\n+    public static long binomialCoefficient(int n, int k) {     \n+        if (n < k) {\n+            throw new IllegalArgumentException\n+                (\"must have n >= k for binomial coefficient (n,k)\");\n+        }\n+        if (n <= 0)  {\n+            throw new IllegalArgumentException\n+                (\"must have n > 0 for binomial coefficient (n,k)\");\n+        }\n+        if ((n == k) || (k == 0)) {\n+            return 1;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+\n+        long result = Math.round(binomialCoefficientDouble(n, k));\n+        if (result == Long.MAX_VALUE) {\n+            throw new ArithmeticException\n+                (\"result too large to represent in a long integer\");\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a <code>double</code> representation of the\n+     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n+     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n+     * the number of <code>k</code>-element subsets that can be selected from\n+     * an <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:<ul>\n+     * <li> <code>0 < k <= n </code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>.\n+     *      The largest value of <code>n</code> for which all coefficients are\n+     *      < Double.MAX_VALUE is 1029.  If the computed value exceeds\n+     *      Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n+     * </ul>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return <code>n choose k</code>\n+     */\n+    public static double binomialCoefficientDouble(int n, int k) {\n+        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + .5);\n+    }\n+\n+    /**\n+     * Returns the natural <code>log</code> of the\n+     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n+     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n+     * the number of <code>k</code>-element subsets that can be selected from\n+     * an <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:<ul>\n+     * <li> <code>0 < k <= n </code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * </ul>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return <code>n choose k</code>\n+     */\n+    public static double binomialCoefficientLog(int n, int k) {\n+        if (n < k) {\n+            throw new IllegalArgumentException\n+                (\"must have n >= k for binomial coefficient (n,k)\");\n+        }\n+        if (n <= 0)  {\n+            throw new IllegalArgumentException\n+                (\"must have n > 0 for binomial coefficient (n,k)\");\n+        }\n+        if ((n == k) || (k == 0)) {\n+            return 0;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return Math.log((double) n);\n+        }\n+        double logSum = 0;\n+\n+        // n!/k!\n+        for (int i = k + 1; i <= n; i++) {\n+            logSum += Math.log((double) i);\n+        }\n+\n+        // divide by (n-k)!\n+        for (int i = 2; i <= n - k; i++) {\n+            logSum -= Math.log((double) i);\n+        }\n+\n+        return logSum;\n+    }\n+\n+    /**\n+     * Returns <code>n</code>\n+     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * Factorial</a>, or <code>n!</code>,\n+     * the product of the numbers <code>1,...,n</code>.\n+     * <p>\n+     * <Strong>Preconditions</strong>:<ul>\n+     * <li> <code>n > 0</code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>long</code>.  The\n+     *      largest value of <code>n</code> for which <code>n!</code>\n+     *      < Long.MAX_VALUE</code> is 20.  If the computed value\n+     *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n+     *      </code> is thrown.</li>\n+     * </ul>\n+     *\n+     * @param n argument\n+     * @return <code>n!</code>\n+     */\n+    public static long factorial(int n) {\n+        long result = Math.round(factorialDouble(n));\n+        if (result == Long.MAX_VALUE) {\n+            throw new ArithmeticException\n+                (\"result too large to represent in a long integer\");\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns <code>n</code>\n+     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * Factorial</a>, or <code>n!</code>,\n+     * the product of the numbers <code>1,...,n</code>, as as\n+     * <code>double</code>.\n+     * <p>\n+     * <Strong>Preconditions</strong>:<ul>\n+     * <li> <code>n > 0</code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>.  The\n+     *      largest value of <code>n</code> for which <code>n!</code>\n+     *      < Double.MAX_VALUE</code> is 170.  If the computed value exceeds\n+     *      Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n+     * </ul>\n+     *\n+     * @param n argument\n+     * @return <code>n!</code>\n+     */\n+    public static double factorialDouble(int n) {\n+        if (n <= 0)  {\n+            throw new IllegalArgumentException\n+                (\"must have n > 0 for n!\");\n+        }\n+        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+    }\n+\n+   /**\n+     * Returns the natural <code>log</code> of <code>n</code>\n+     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * Factorial</a>, or <code>n!</code>,\n+     * the product of the numbers <code>1,...,n</code>, as as\n+     * <code>double</code>.\n+     * <p>\n+     * <Strong>Preconditions</strong>:<ul>\n+     * <li> <code>n > 0</code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * </ul>\n+     *\n+     * @param n argument\n+     * @return <code>n!</code>\n+     */\n+    public static double factorialLog(int n) {\n+        if (n <= 0)  {\n+            throw new IllegalArgumentException\n+                (\"must have n > 0 for n!\");\n+        }\n+        double logSum = 0;\n+        for (int i = 2; i <= n; i++) {\n+            logSum += Math.log((double) i);\n+        }\n+        return logSum;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link RealMatrixImpl} class.\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:57 $\n+ */\n+\n+public final class RealMatrixImplTest extends TestCase {\n+    \n+    private double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    private double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    private double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    private double[] testDataRow1 = {1d,2d,3d};\n+    private double[] testDataCol3 = {3d,3d,8d};\n+    private double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    private double[][] preMultTest = {{8,12,33}};\n+    private double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    private double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    private double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    private double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    private double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    private double[][] singular = { {2d,3d}, {2d,3d} };\n+    private double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    private double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    private double[] testVector = {1,2,3};\n+    private double[] testVector2 = {1,2,3,4};\n+    private double entryTolerance = 10E-16;\n+    private double normTolerance = 10E-14;\n+    \n+    public RealMatrixImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {\n+        \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RealMatrixImplTest.class);\n+        suite.setName(\"RealMatrixImpl Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        m2.setData(m.getData());\n+        assertClose(\"getData\",m2,m,entryTolerance);\n+        // no dangling reference...\n+        m2.setEntry(1,1,2000d);\n+        RealMatrixImpl m3 = new RealMatrixImpl(testData);\n+        assertClose(\"no getData side effect\",m,m3,entryTolerance);\n+        m3 = (RealMatrixImpl) m.copy();\n+        double[][] stompMe = {{1d,2d,3d}};\n+        m3.setDataRef(stompMe);\n+        assertClose(\"no copy side effect\",m,new RealMatrixImpl(testData),\n+            entryTolerance);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n+        RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);\n+        double[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        try {\n+            RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);\n+        assertClose(\"m-n = m + -n\",m.subtract(m2),\n+            m2.scalarMultiply(-1d).add(m),entryTolerance);        \n+        try {\n+            RealMatrix a = m.subtract(new RealMatrixImpl(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test multiply */\n+     public void testMultiply() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n+        RealMatrixImpl identity = new RealMatrixImpl(id);\n+        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n+        assertClose(\"inverse multiply\",m.multiply(mInv),\n+            identity,entryTolerance);\n+        assertClose(\"inverse multiply\",mInv.multiply(m),\n+            identity,entryTolerance);\n+        assertClose(\"identity multiply\",m.multiply(identity),\n+            m,entryTolerance);\n+        assertClose(\"identity multiply\",identity.multiply(mInv),\n+            mInv,entryTolerance);\n+        assertClose(\"identity multiply\",m2.multiply(identity),\n+            m2,entryTolerance); \n+        try {\n+            RealMatrix a = m.multiply(new RealMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }   \n+        \n+    /** test isSingular */\n+    public void testIsSingular() {\n+        RealMatrixImpl m = new RealMatrixImpl(singular);\n+        assertTrue(\"singular\",m.isSingular());\n+        m = new RealMatrixImpl(bigSingular);\n+        assertTrue(\"big singular\",m.isSingular());\n+        m = new RealMatrixImpl(id);\n+        assertTrue(\"identity nonsingular\",!m.isSingular());\n+        m = new RealMatrixImpl(testData);\n+        assertTrue(\"testData nonsingular\",!m.isSingular());\n+    }\n+        \n+    /** test inverse */\n+    public void testInverse() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n+        assertClose(\"inverse\",mInv,m.inverse(),normTolerance);\n+        assertClose(\"inverse^2\",m,m.inverse().inverse(),10E-12);\n+    }\n+    \n+    /** test solve */\n+    public void testSolve() {\n+        RealMatrixImpl m = new RealMatrixImpl(testData);\n+        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n+        // being a bit slothful here -- actually testing that X = A^-1 * B\n+        assertClose(\"inverse-operate\",mInv.operate(testVector),\n+            m.solve(testVector),normTolerance);\n+        try {\n+            double[] x = m.solve(testVector2);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }       \n+        RealMatrix bs = new RealMatrixImpl(bigSingular);\n+        try {\n+            RealMatrix a = bs.solve(bs);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            RealMatrix a = m.solve(bs);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test determinant */\n+    public void testDeterminant() {       \n+        RealMatrix m = new RealMatrixImpl(bigSingular);\n+        assertEquals(\"singular determinant\",0,m.getDeterminant(),0);\n+        m = new RealMatrixImpl(detData);\n+        assertEquals(\"nonsingular test\",-3d,m.getDeterminant(),normTolerance);\n+        try {\n+            double a = new RealMatrixImpl(testData2).getDeterminant();\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test trace */\n+    public void testTrace() {\n+        RealMatrix m = new RealMatrixImpl(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace(),entryTolerance);\n+        m = new RealMatrixImpl(testData2);\n+        try {\n+            double x = m.getTrace();\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        assertClose(\"scalar add\",new RealMatrixImpl(testDataPlus2),\n+            m.scalarAdd(2d),entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        RealMatrix m = new RealMatrixImpl(id);\n+        double[] x = m.operate(testVector);\n+        assertClose(\"identity operate\",testVector,x,entryTolerance);\n+        m = new RealMatrixImpl(bigSingular);\n+        try {\n+            x = m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        RealMatrix m = new RealMatrixImpl(testData); \n+        assertClose(\"inverse-transpose\",m.inverse().transpose(),\n+            m.transpose().inverse(),normTolerance);\n+        m = new RealMatrixImpl(testData2);\n+        RealMatrix mt = new RealMatrixImpl(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+    \n+    /** test preMultiply */\n+    public void testPremultiply() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        RealMatrix mp = new RealMatrixImpl(preMultTest);\n+        assertClose(\"premultiply\",m.preMultiply(testVector),mp,normTolerance);\n+        m = new RealMatrixImpl(bigSingular);\n+        try {\n+            RealMatrix x = m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testGetVectors() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        assertClose(\"get row\",m.getRow(1),testDataRow1,entryTolerance);\n+        assertClose(\"get col\",m.getColumn(3),testDataCol3,entryTolerance);\n+        try {\n+            double[] x = m.getRow(10);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double[] x = m.getColumn(-1);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testEntryMutators() {\n+        RealMatrix m = new RealMatrixImpl(testData);\n+        assertEquals(\"get entry\",m.getEntry(1,2),2d,entryTolerance);\n+        m.setEntry(1,2,100d);\n+        assertEquals(\"get entry\",m.getEntry(1,2),100d,entryTolerance);\n+        try {\n+            double x = m.getEntry(0,2);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            m.setEntry(1,4,200d);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+        \n+    \n+    //--------------- -----------------Private methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n+    private void assertClose(String msg, RealMatrix m, RealMatrix n,\n+        double tolerance) {\n+        assertTrue(msg,m.subtract(n).getNorm() < tolerance);\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    private void assertClose(String msg, double[] m, double[] n,\n+        double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", \n+                m[i],n[i],tolerance);\n+        }\n+    }\n+    \n+    /** Useful for debugging */\n+    private void dumpMatrix(RealMatrix m) {\n+          for (int i = 0; i < m.getRowDimension(); i++) {\n+              String os = \"\";\n+              for (int j = 0; j < m.getColumnDimension(); j++) {\n+                  os += m.getEntry(i+1, j+1) + \" \";\n+              }\n+              System.out.println(os);\n+          }\n+    }\n+        \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import java.io.File;\n+import java.net.URL;\n+\n+import org.apache.commons.math.stat.Univariate;\n+import org.apache.commons.math.stat.UnivariateImpl;\n+\n+/**\n+ * Test cases for the EmpiricalDistribution class\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:56 $\n+ */\n+\n+public final class EmpiricalDistributionTest extends TestCase {\n+\n+    private EmpiricalDistribution empiricalDistribution = null;\n+    private File file = null;\n+    \n+    public EmpiricalDistributionTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        empiricalDistribution = new EmpiricalDistributionImpl(100);\n+        URL url = getClass().getResource(\"testData.txt\");\n+        file = new File(url.getFile());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);\n+        suite.setName(\"EmpiricalDistribution Tests\");\n+        return suite;\n+    }\n+\n+    /**\n+     * Test EmpiricalDistrbution.load() using sample data file.<br> \n+     * Check that the sampleCount, mu and sigma match data in \n+     * the sample data file.\n+     */\n+    public void testLoad() throws Exception {\n+        empiricalDistribution.load(file);   \n+        // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n+        // Make sure that loaded distribution matches this\n+        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);\n+        //TODO: replace with statistical tests\n+        assertEquals\n+            (empiricalDistribution.getSampleStats().getMean(),\n+                5.069831575018909,10E-7);\n+        assertEquals\n+          (empiricalDistribution.getSampleStats().getStandardDeviation(),\n+                1.0173699343977738,10E-7);\n+    }\n+    \n+    /** \n+      * Generate 1000 random values and make sure they look OK.<br>\n+      * Note that there is a non-zero (but very small) probability that\n+      * these tests will fail even if the code is working as designed.\n+      */\n+    public void testNext() throws Exception {\n+        tstGen(0.1);\n+    }\n+    \n+    /**\n+      * Make sure exception thrown if digest getNext is attempted\n+      * before loading empiricalDistribution.\n+     */\n+    public void testNexFail() {\n+        try {\n+            empiricalDistribution.getNextValue();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {;}\n+    }\n+    \n+    /**\n+     * Make sure we can handle a grid size that is too fine\n+     */\n+    public void testGridTooFine() throws Exception {\n+        empiricalDistribution = new EmpiricalDistributionImpl(10000);\n+        tstGen(0.1);    \n+    }\n+    \n+    /**\n+     * How about too fat?\n+     */\n+    public void testGridTooFat() throws Exception {\n+        empiricalDistribution = new EmpiricalDistributionImpl(1);\n+        tstGen(5); // ridiculous tolerance; but ridiculous grid size\n+                   // really just checking to make sure we do not bomb\n+    }\n+    \n+    private void tstGen(double tolerance)throws Exception {\n+        empiricalDistribution.load(file);   \n+        Univariate stats = new UnivariateImpl();\n+        for (int i = 1; i < 1000; i++) {\n+            stats.addValue(empiricalDistribution.getNextValue());\n+        }\n+        //TODO: replace these with statistical tests -- refactor as necessary\n+        assertEquals(\"mean\", stats.getMean(),5.069831575018909,tolerance);\n+        assertEquals\n+         (\"std dev\", stats.getStandardDeviation(),1.0173699343977738,tolerance);\n+    }\n+        \n+        \n+       \n+        \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution. \n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import java.security.NoSuchProviderException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.HashSet;\n+\n+import org.apache.commons.math.stat.Frequency;\n+import org.apache.commons.math.stat.TestStatisticImpl;\n+import org.apache.commons.math.stat.Univariate;\n+import org.apache.commons.math.stat.UnivariateImpl;\n+\n+/**\n+ * Test cases for the RandomData class.\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:56 $\n+ */\n+\n+public final class RandomDataTest extends TestCase {\n+\n+    public RandomDataTest(String name) {\n+        super(name);\n+    }\n+\n+    private long smallSampleSize = 1000;\n+    private double[] expected = {250,250,250,250};\n+    private int largeSampleSize = 10000;\n+    private int tolerance = 50;\n+    private String[] hex = \n+        {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"}; \n+    private RandomDataImpl randomData = new RandomDataImpl(); \n+    private TestStatisticImpl testStatistic = new TestStatisticImpl();\n+    \n+    \n+    public void setUp() { \n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomDataTest.class);\n+        suite.setName(\"RandomData Tests\");\n+        return suite;\n+    }\n+\n+    /** test dispersion and failure modes for nextInt() */\n+    public void testNextInt() {\n+        try {\n+            int x = randomData.nextInt(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Frequency freq = new Frequency();\n+        int value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextInt(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** test dispersion and failure modes for nextLong() */\n+    public void testNextLong() {\n+       try {\n+            long x = randomData.nextLong(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+       Frequency freq = new Frequency();\n+       long value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextLong(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** test dispersion and failure modes for nextSecureLong() */\n+    public void testNextSecureLong() {\n+        try {\n+            long x = randomData.nextSecureLong(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Frequency freq = new Frequency();\n+        long value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextSecureLong(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** test dispersion and failure modes for nextSecureInt() */\n+    public void testNextSecureInt() {\n+        try {\n+            long x = randomData.nextSecureInt(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Frequency freq = new Frequency();\n+        int value = 0;\n+        for (int i=0;i<smallSampleSize;i++) {\n+            value = randomData.nextSecureInt(0,3);\n+            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n+            freq.addValue(value);  \n+        }\n+        double[] observed = new double[4];\n+        for (int i=0; i<4; i++) {\n+            String iString = new Integer(i).toString();\n+            observed[i] = freq.getCount(iString);\n+        } \n+        \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n+         * Change to 11.34 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 16.27);    \n+    }\n+    \n+    /** \n+     * Make sure that empirical distribution of random Poisson(4)'s \n+     * has P(X <= 5) close to actual cumulative Poisson probablity\n+     * and that nextPoisson fails when mean is non-positive\n+     * TODO: replace with statistical test, adding test stat to TestStatistic\n+     */\n+    public void testNextPoisson() {\n+        try {\n+            long x = randomData.nextPoisson(0);\n+            fail(\"zero mean -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Frequency f = new Frequency();\n+        long v = 0;\n+        for (int i = 0; i<largeSampleSize; i++) {\n+            try {\n+                f.addValue(randomData.nextPoisson(4.0d));\n+            } catch (Exception ex) {\n+                fail(ex.getMessage());\n+            }\n+        }\n+        long cumFreq = f.getCount(\"0\") + f.getCount(\"1\") + f.getCount(\"2\") + \n+                        f.getCount(\"3\") + f.getCount(\"4\") + f.getCount(\"5\");\n+        long sumFreq = f.getSumFreq();\n+        double cumPct = \n+            new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();\n+        assertEquals(\"cum Poisson(4)\",cumPct,0.7851,0.2);\n+        try {\n+            long x = randomData.nextPoisson(-1);\n+            fail(\"negative mean supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            long x = randomData.nextPoisson(0);\n+            fail(\"0 mean supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        \n+    }\n+    \n+    /** test dispersion and failute modes for nextHex() */\n+    public void testNextHex() {\n+        try {\n+            String x = randomData.nextHexString(-1);\n+            fail(\"negative length supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            String x = randomData.nextHexString(0);\n+            fail(\"zero length supplied -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        String hexString = randomData.nextHexString(3);\n+        if (hexString.length() != 3) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextHexString(1);\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextHexString(0);\n+            fail(\"zero length requested -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }      \n+        Frequency f = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextHexString(100);\n+            if (hexString.length() != 100) {\n+                fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j,j+1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        double[] observed = new double[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double)smallSampleSize*100/(double)16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001\n+         * Change to 30.58 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 37.70);    \n+    }\n+    \n+    /** test dispersion and failute modes for nextHex() */\n+    public void testNextSecureHex() {\n+        try {\n+            String x = randomData.nextSecureHexString(-1);\n+            fail(\"negative length -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            String x = randomData.nextSecureHexString(0);\n+            fail(\"zero length -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        String hexString = randomData.nextSecureHexString(3);\n+        if (hexString.length() != 3) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextSecureHexString(1);\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextSecureHexString(0);\n+            fail(\"zero length requested -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        if (hexString.length() != 1) {\n+                fail(\"incorrect length for generated string\");\n+        }      \n+        Frequency f = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextSecureHexString(100);\n+            if (hexString.length() != 100) {\n+                fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j,j+1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        double[] observed = new double[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double)smallSampleSize*100/(double)16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001\n+         * Change to 30.58 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 37.70);    \n+    }\n+    \n+    /** test failure modes and dispersion of nextUniform() */  \n+    public void testNextUniform() {    \n+        try {\n+            double x = randomData.nextUniform(4,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = randomData.nextUniform(3,3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        double[] expected = new double[] {500,500};\n+        double[] observed = new double[] {0,0};\n+        double lower = -1d;\n+        double upper = 20d;\n+        double midpoint = (lower + upper)/2d;\n+        double result = 0;\n+        for (int i = 0; i < 1000; i++) {\n+            result = randomData.nextUniform(lower,upper);\n+            if ((result == lower) || (result == upper)) {\n+                fail(\"generated value equal to an endpoint: \" + result);\n+            } \n+            if (result < midpoint) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n+         * Change to 6.64 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 10.83);  \n+    }\n+    \n+    /** test failure modes and distribution of nextGaussian() */  \n+    public void testNextGaussian() { \n+        try {\n+            double x = randomData.nextGaussian(0,0);\n+            fail(\"zero sigma -- IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        Univariate u = new UnivariateImpl();\n+        for (int i = 0; i<largeSampleSize; i++) {\n+            u.addValue(randomData.nextGaussian(0,1));\n+        }\n+        double xbar = u.getMean();\n+        double s = u.getStandardDeviation();\n+        double n = (double) u.getN(); \n+        /* t-test at .001-level TODO: replace with externalized t-test, with\n+         * test statistic defined in TestStatistic\n+         */\n+        assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);\n+    }\n+    \n+    /** test failure modes and distribution of nextExponential() */  \n+    public void testNextExponential() {\n+        try {\n+            double x = randomData.nextExponential(-1);\n+            fail(\"negative mean -- expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        assertEquals(\"0 mean\", 0,randomData.nextExponential(0),10E-8); \n+        long cumFreq = 0;\n+        double v = 0;\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            v = randomData.nextExponential(1);\n+            assertTrue(\"exponential deviate postive\", v > 0);\n+            if (v < 2) cumFreq++;\n+        }\n+        /* TODO: Replace with a statistical test, with statistic added to\n+         * TestStatistic.  Check below compares observed cumulative distribution\n+         * evaluated at 2 with exponential CDF \n+         */\n+        assertEquals(\"exponential cumulative distribution\",\n+            (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);\n+    } \n+    \n+    /** test reseeding, algorithm/provider games */\n+    public void testConfig() throws NoSuchProviderException, \n+      NoSuchAlgorithmException{\n+        randomData.reSeed(1000);\n+        double v = randomData.nextUniform(0,1);\n+        randomData.reSeed();\n+        assertTrue(\"different seeds\", \n+            Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);\n+        randomData.reSeed(1000);\n+        assertEquals(\"same seeds\",v,randomData.nextUniform(0,1),10E-12);\n+        randomData.reSeedSecure(1000);\n+        String hex = randomData.nextSecureHexString(40);\n+        randomData.reSeedSecure();\n+        assertTrue(\"different seeds\",\n+            !hex.equals(randomData.nextSecureHexString(40)));\n+        randomData.reSeedSecure(1000);\n+        assertTrue(\"same seeds\",\n+            !hex.equals(randomData.nextSecureHexString(40))); \n+        \n+        /* remove this test back soon,\n+         * since it takes about 4 seconds */\n+         \n+        randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\");\n+        assertTrue(\"different seeds\",\n+            !hex.equals(randomData.nextSecureHexString(40)));\n+        try {\n+            randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n+            fail(\"expecting NoSuchAlgorithmException\");\n+        } catch (NoSuchAlgorithmException ex) {\n+            ;\n+        }\n+        \n+        try {\n+            randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n+            fail(\"expecting NoSuchProviderException\");\n+        } catch (NoSuchProviderException ex) {\n+            ;\n+        } \n+        \n+        // test reseeding without first using the generators\n+        RandomDataImpl rd = new RandomDataImpl();\n+        rd.reSeed(100);\n+        double ret = rd.nextLong(1,2);\n+        RandomDataImpl rd2 = new RandomDataImpl();\n+        rd2.reSeedSecure(2000);\n+        ret = rd2.nextSecureLong(1,2);\n+        rd = new RandomDataImpl();\n+        rd.reSeed();\n+        ret = rd.nextLong(1,2);\n+        rd2 = new RandomDataImpl();\n+        rd2.reSeedSecure();\n+        ret = rd2.nextSecureLong(1,2);\n+    }\n+    \n+    /** tests for nextSample() sampling from Collection */\n+    public void testNextSample() {\n+       Object[][] c = {{\"0\",\"1\"},{\"0\",\"2\"},{\"0\",\"3\"},{\"0\",\"4\"},{\"1\",\"2\"},\n+                        {\"1\",\"3\"},{\"1\",\"4\"},{\"2\",\"3\"},{\"2\",\"4\"},{\"3\",\"4\"}};\n+       double[] observed = {0,0,0,0,0,0,0,0,0,0};\n+       double[] expected = {100,100,100,100,100,100,100,100,100,100};\n+       \n+       HashSet cPop = new HashSet();  //{0,1,2,3,4}\n+       for (int i = 0; i < 5; i++) {\n+           cPop.add(Integer.toString(i));\n+       }\n+       \n+       Object[] sets = new Object[10]; // 2-sets from 5\n+       for (int i = 0; i < 10; i ++) {\n+           HashSet hs = new HashSet();\n+           hs.add(c[i][0]);\n+           hs.add(c[i][1]);\n+           sets[i] = hs;\n+       }\n+       \n+       for (int i = 0; i < 1000; i ++) {\n+           Object[] cSamp = randomData.nextSample(cPop,2);\n+           observed[findSample(sets,cSamp)]++;\n+       }\n+       \n+        /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001\n+         * Change to 21.67 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 27.88);  \n+       \n+       // Make sure sample of size = size of collection returns same collection\n+       HashSet hs = new HashSet();\n+       hs.add(\"one\");\n+       Object[] one = randomData.nextSample(hs,1);\n+       String oneString = (String) one[0];\n+       if ((one.length != 1) || !oneString.equals(\"one\")){\n+           fail(\"bad sample for set size = 1, sample size = 1\");\n+       }\n+       \n+       // Make sure we fail for sample size > collection size\n+       try {\n+           one = randomData.nextSample(hs,2);\n+           fail(\"sample size > set size, expecting IllegalArgumentException\");\n+       } catch (IllegalArgumentException ex) {\n+           ;\n+       }\n+       \n+       // Make sure we fail for empty collection\n+       try {\n+           hs = new HashSet();\n+           one = randomData.nextSample(hs,0);\n+           fail(\"n = k = 0, expecting IllegalArgumentException\");\n+       } catch (IllegalArgumentException ex) {\n+           ;\n+       }\n+    }\n+    \n+    private int findSample(Object[] u, Object[] samp) {\n+        int result = -1;\n+        for (int i = 0; i < u.length; i++) {\n+            HashSet set = (HashSet) u[i];\n+            HashSet sampSet = new HashSet();\n+            for (int j = 0; j < samp.length; j++) {\n+                sampSet.add(samp[j]);\n+            }\n+            if (set.equals(sampSet)) {                 \n+               return i;\n+           }\n+        }\n+        fail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n+        return -1;\n+    }\n+    \n+    /** tests for nextPermutation */\n+    public void testNextPermutation() {\n+         int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};\n+         double[] observed = {0,0,0,0,0,0,};\n+         double[] expected = {100,100,100,100,100,100};\n+         \n+         for (int i = 0; i < 600; i++) {\n+             int[] perm = randomData.nextPermutation(3,3);\n+             observed[findPerm(p,perm)]++;\n+         }  \n+         \n+        /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001\n+         * Change to 15.09 for alpha = .01\n+         */\n+        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+            testStatistic.chiSquare(expected,observed) < 20.52); \n+         \n+         // Check size = 1 boundary case\n+         int[] perm = randomData.nextPermutation(1,1);\n+         if ((perm.length != 1) || (perm[0] != 0)){\n+           fail(\"bad permutation for n = 1, sample k = 1\");\n+           \n+        // Make sure we fail for k size > n \n+        try {\n+           perm = randomData.nextPermutation(2,3);\n+           fail(\"permutation k > n, expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+           ;\n+        }\n+           \n+        // Make sure we fail for n = 0\n+        try {\n+           perm = randomData.nextPermutation(0,0);\n+           fail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+           ;\n+        }\n+           \n+        \n+       }\n+         \n+    }\n+    \n+    private int findPerm(int[][] p, int[] samp) {\n+        int result = -1;\n+        for (int i = 0; i < p.length; i++) {\n+            boolean good = true;\n+            for (int j = 0; j < samp.length; j++) {\n+                if (samp[j] != p[i][j]) {\n+                    good = false;\n+                }\n+            }\n+            if (good)  {\n+                return i;\n+            }\n+        }        \n+        fail(\"permutation not found\");\n+        return -1;\n+    }\n+                \n+                       \n+            \n+        \n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/random/ValueServerTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import java.net.URL;\n+\n+import org.apache.commons.math.stat.Univariate;\n+import org.apache.commons.math.stat.UnivariateImpl;\n+ \n+/**\n+ * Test cases for the ValueServer class.\n+ *\n+ * @author  Phil Steitz\n+ * @version $Revision: 1.1 $\n+ */\n+\n+public final class ValueServerTest extends TestCase {\n+\n+    private ValueServer vs = new ValueServer();\n+    \n+    public ValueServerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        vs.setMode(ValueServer.DIGEST_MODE);\n+        try {\n+            URL url = getClass().getResource(\"testData.txt\");\n+            vs.setValuesFileURL(url.toExternalForm()); \n+        } catch (Exception ex) {\n+            fail(\"malformed test URL\");\n+        }\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ValueServerTest.class);\n+        suite.setName(\"ValueServer Tests\");\n+        return suite;\n+    }\n+\n+   \n+    /** \n+      * Generate 1000 random values and make sure they look OK.<br>\n+      * Note that there is a non-zero (but very small) probability that\n+      * these tests will fail even if the code is working as designed.\n+      */\n+    public void testNextDigest() throws Exception{\n+        double next = 0.0;\n+        double tolerance = 0.1;\n+        vs.computeDistribution();\n+        assertTrue(\"empirical distribution property\", \n+            vs.getEmpiricalDistribution() != null);\n+        Univariate stats = new UnivariateImpl();\n+        for (int i = 1; i < 1000; i++) {\n+            next = vs.getNext();\n+            stats.addValue(next);\n+        }    \n+        assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n+        assertEquals\n+         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(), \n+            tolerance);\n+        \n+        vs.computeDistribution(500);\n+        stats = new UnivariateImpl();\n+        for (int i = 1; i < 1000; i++) {\n+            next = vs.getNext();\n+            stats.addValue(next);\n+        }    \n+        assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n+        assertEquals\n+         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(), \n+            tolerance);\n+        \n+    }\n+    \n+    /**\n+      * Make sure exception thrown if digest getNext is attempted\n+      * before loading empiricalDistribution.\n+      */\n+    public void testNextDigestFail() throws Exception {\n+        try {\n+            vs.getNext();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {;}\n+    }\n+    \n+    /**\n+      * Make sure exception thrown if nextReplay() is attempted\n+      * before opening replay file.\n+      */\n+    public void testNextReplayFail() throws Exception {\n+        try {\n+            vs.setMode(ValueServer.REPLAY_MODE);\n+            vs.getNext();\n+            fail(\"Expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {;}\n+    }\n+    \n+    /**\n+     * Test ValueServer REPLAY_MODE using values in testData file.<br> \n+     * Check that the values 1,2,1001,1002 match data file values 1 and 2.\n+     * the sample data file.\n+     */\n+    public void testReplay() throws Exception {\n+        double firstDataValue = 4.038625496201205;\n+        double secondDataValue = 3.6485326248346936;\n+        double tolerance = 10E-15;\n+        double compareValue = 0.0d;\n+        vs.setMode(ValueServer.REPLAY_MODE);\n+        vs.openReplayFile();\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,secondDataValue,tolerance);\n+        for (int i = 3; i < 1001; i++) {\n+           compareValue = vs.getNext();\n+        }\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,firstDataValue,tolerance);\n+        compareValue = vs.getNext();\n+        assertEquals(compareValue,secondDataValue,tolerance);\n+        vs.closeReplayFile();\n+        // make sure no NPE\n+        vs.closeReplayFile();\n+    }\n+    \n+    /** \n+     * Test other ValueServer modes\n+     */\n+    public void testModes() throws Exception {\n+        vs.setMode(ValueServer.CONSTANT_MODE);\n+        vs.setMu(0);\n+        assertEquals(\"constant mode test\",vs.getMu(),vs.getNext(),Double.MIN_VALUE);\n+        vs.setMode(ValueServer.UNIFORM_MODE);\n+        vs.setMu(2);\n+        double val = vs.getNext();\n+        assertTrue(val > 0 && val < 4);\n+        vs.setSigma(1);\n+        vs.setMode(ValueServer.GAUSSIAN_MODE);\n+        val = vs.getNext();\n+        assertTrue(\"gaussian value close enough to mean\",\n+            val < vs.getMu() + 100*vs.getSigma());\n+        vs.setMode(ValueServer.EXPONENTIAL_MODE);\n+        val = vs.getNext();\n+        assertTrue(val > 0);\n+        try {\n+            vs.setMode(1000);\n+            vs.getNext();\n+            fail(\"bad mode, expecting IllegalStateException\");\n+        } catch (IllegalStateException ex) {\n+            ;\n+        }\n+    }\n+    \n+    /**\n+     * Test fill\n+     */\n+    public void testFill() throws Exception {\n+        vs.setMode(ValueServer.CONSTANT_MODE);\n+        vs.setMu(2);\n+        double[] val = new double[5];\n+        vs.fill(val);\n+        for (int i = 0; i < 5; i++) {\n+            assertEquals(\"fill test in place\",2,val[i],Double.MIN_VALUE);\n+        }\n+        double v2[] = vs.fill(3);\n+        for (int i = 0; i < 3; i++) {\n+            assertEquals(\"fill test in place\",2,v2[i],Double.MIN_VALUE);\n+        }\n+    }\n+    \n+    /**\n+     * Test getters to make Clover happy\n+     */\n+    public void testProperties() throws Exception {\n+        vs.setMode(ValueServer.CONSTANT_MODE);\n+        assertEquals(\"mode test\",ValueServer.CONSTANT_MODE,vs.getMode());\n+        vs.setValuesFileURL(\"http://www.apache.org\");\n+        String s = vs.getValuesFileURL();\n+        assertEquals(\"valuesFileURL test\",\"http://www.apache.org\",s);\n+    }\n+        \n+        \n+        \n+        \n+        \n+        \n+}\n--- a/src/test/org/apache/commons/math/stat/BeanListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/BeanListUnivariateImplTest.java\n  * Test cases for the {@link BeanListUnivariateImpl} class.\n  *\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $\n+ * @version $Revision: 1.2 $ $Date: 2003/06/22 03:57:53 $\n  */\n \n public final class BeanListUnivariateImplTest extends TestCase {\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);\n-        suite.setName(\"Freq Tests\");\n+        suite.setName(\"Frequency Tests\");\n         return suite;\n     }\n     \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/FrequencyTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Frequency} class.\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:53 $\n+ */\n+\n+public final class FrequencyTest extends TestCase {\n+    private long oneL = 1;\n+    private long twoL = 2;\n+    private int oneI = 1;\n+    private int twoI = 2;\n+    private String oneS = \"1\";\n+    private String twoS = \"2\";\n+    private double tolerance = 10E-15;\n+    \n+    public FrequencyTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {  \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FrequencyTest.class);\n+        suite.setName(\"Frequency Tests\");\n+        return suite;\n+    }\n+    \n+    /** test freq counts */\n+    public void testCounts() {\n+        Frequency f = new Frequency(\"test counts\"); \n+        assertEquals(\"total count\",0,f.getSumFreq());\n+        f.addValue(oneL);\n+        f.addValue(twoL);\n+        f.addValue(oneS);\n+        f.addValue(oneI);\n+        assertEquals(\"one frequency count\",3,f.getCount(\"1\"));\n+        assertEquals(\"two frequency count\",1,f.getCount(\"2\"));\n+        assertEquals(\"foo frequency count\",0,f.getCount(\"foo\"));\n+        assertEquals(\"total count\",4,f.getSumFreq());\n+        f.clear();\n+        assertEquals(\"total count\",0,f.getSumFreq());\n+    }     \n+    \n+    /** test pcts */\n+    public void testPcts() {\n+        Frequency f = new Frequency(\"test counts\"); \n+        f.addValue(oneL);\n+        f.addValue(twoL);\n+        f.addValue(oneI);\n+        f.addValue(twoI);\n+        f.addValue(\"foo\");\n+        f.addValue(\"foo\");\n+        f.addValue(\"foo\");\n+        f.addValue(\"foo\");\n+        assertEquals(\"one pct\",0.25,f.getPct(\"1\"),tolerance);\n+        assertEquals(\"two pct\",0.25,f.getPct(\"2\"),tolerance);\n+        assertEquals(\"foo pct\",0.5,f.getPct(\"foo\"),tolerance);\n+        assertEquals(\"bar pct\",0,f.getPct(\"bar\"),tolerance);\n+    }      \n+}\n+\n--- a/src/test/org/apache/commons/math/stat/ListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/ListUnivariateImplTest.java\n  * Test cases for the {@link Univariate} class.\n  *\n  * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n- * @version $Revision: 1.3 $ $Date: 2003/06/21 23:38:27 $\n+ * @version $Revision: 1.4 $ $Date: 2003/06/22 03:57:53 $\n  */\n \n public final class ListUnivariateImplTest extends TestCase {\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite(ListUnivariateImplTest.class);\n-        suite.setName(\"Freq Tests\");\n+        suite.setName(\"Frequency Tests\");\n         return suite;\n     }\n     \n--- a/src/test/org/apache/commons/math/stat/StoreUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/StoreUnivariateImplTest.java\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n-import org.apache.commons.math.RandomDataImpl;\n-import org.apache.commons.math.RandomData;\n+\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n \n /**\n  * Test cases for the {@link Univariate} class.\n  *\n  * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n- * @version $Revision: 1.3 $ $Date: 2003/06/21 23:02:51 $\n+ * @version $Revision: 1.4 $ $Date: 2003/06/22 03:57:53 $\n  */\n \n public final class StoreUnivariateImplTest extends TestCase {\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite(StoreUnivariateImplTest.class);\n-        suite.setName(\"Freq Tests\");\n+        suite.setName(\"Frequency Tests\");\n         return suite;\n     }\n     \n--- a/src/test/org/apache/commons/math/stat/UnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/UnivariateImplTest.java\n  *\n  * @author Phil Steitz\n  * @author Tim Obrien\n- * @version $Revision: 1.3 $ $Date: 2003/06/21 23:38:27 $\n+ * @version $Revision: 1.4 $ $Date: 2003/06/22 03:57:53 $\n  */\n \n public final class UnivariateImplTest extends TestCase {\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite(UnivariateImplTest.class);\n-        suite.setName(\"Freq Tests\");\n+        suite.setName(\"Frequency Tests\");\n         return suite;\n     }\n     \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/ContinuedFractionTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Brent Worden\n+ */\n+public class ContinuedFractionTest extends TestCase {\n+\t/**\n+\t * Constructor for ContinuedFractionTest.\n+\t * @param name\n+\t */\n+\tpublic ContinuedFractionTest(String name) {\n+\t\tsuper(name);\n+\t}\n+\n+\tpublic void testGoldenRation(){\n+        ContinuedFraction cf = new ContinuedFraction() {\n+\t\t\tpublic double getA(int n, double x) {\n+\t\t\t\treturn 1.0;\n+\t\t\t}\n+\n+\t\t\tpublic double getB(int n, double x) {\n+\t\t\t\treturn 1.0;\n+\t\t\t}\n+\t\t};\n+        double gr = cf.evaluate(0.0, 10e-9);\n+        assertEquals(1.61803399, gr, 10e-9);\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/ContractableDoubleArrayTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ContractableDoubleArrayTest extends ExpandableDoubleArrayTest {\n+\n+\tpublic ContractableDoubleArrayTest(String name) {\n+\t\tsuper( name );\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#setUp()\n+\t */\n+\tprotected void setUp() throws Exception {\n+\t\tda = new ContractableDoubleArray();\n+\t\tra = new ContractableDoubleArray();\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public abstract class DoubleArrayAbstractTest extends TestCase {\n+\n+\tprotected DoubleArray da = null;\n+\n+\t// Array used to test rolling\n+\tprotected DoubleArray ra = null;\n+\n+\tpublic DoubleArrayAbstractTest(String name) {\n+\t\tsuper(name);\n+\t}\n+\n+\tpublic void testAdd1000() {\n+\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tda.addElement(i);\n+\t\t}\n+\n+\t\tassertEquals(\n+\t\t\t\"Number of elements should be equal to 1000 after adding 1000 values\",\n+\t\t\t1000,\n+\t\t\tda.getNumElements());\n+\n+\t\tassertEquals(\n+\t\t\t\"The element at the 56th index should be 56\",\n+\t\t\t56.0,\n+\t\t\tda.getElement(56),\n+\t\t\tDouble.MIN_VALUE);\n+\n+\t}\n+\n+\tpublic void testGetValues() {\n+\t\tdouble[] controlArray = { 2.0, 4.0, 6.0 };\n+\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(4.0);\n+\t\tda.addElement(6.0);\n+\t\tdouble[] testArray = da.getElements();\n+\n+\t\tfor (int i = 0; i < da.getNumElements(); i++) {\n+\t\t\tassertEquals(\n+\t\t\t\t\"The testArray values should equal the controlArray values, index i: \"\n+\t\t\t\t\t+ i\n+\t\t\t\t\t+ \" does not match\",\n+\t\t\t\ttestArray[i],\n+\t\t\t\tcontrolArray[i],\n+\t\t\t\tDouble.MIN_VALUE);\n+\t\t}\n+\n+\t}\n+\n+\tpublic void testAddElementRolling() {\n+\t\tra.addElement(0.5);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElement(1.0);\n+\t\tra.addElementRolling(2.0);\n+\n+\t\tassertEquals(\n+\t\t\t\"There should be 6 elements in the eda\",\n+\t\t\t6,\n+\t\t\tra.getNumElements());\n+\t\tassertEquals(\n+\t\t\t\"The max element should be 2.0\",\n+\t\t\t2.0,\n+\t\t\tra.getMax(),\n+\t\t\tDouble.MIN_VALUE);\n+\t\tassertEquals(\n+\t\t\t\"The min element should be 1.0\",\n+\t\t\t1.0,\n+\t\t\tra.getMin(),\n+\t\t\tDouble.MIN_VALUE);\n+\n+\t\tfor (int i = 0; i < 1024; i++) {\n+\t\t\tra.addElementRolling(i);\n+\t\t}\n+\n+\t\tassertEquals(\n+\t\t\t\"We just inserted 1024 rolling elements, num elements should still be 6\",\n+\t\t\t6,\n+\t\t\tra.getNumElements());\n+\t}\n+\n+\tpublic void testMinMax() {\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(22.0);\n+\t\tda.addElement(-2.0);\n+\t\tda.addElement(21.0);\n+\t\tda.addElement(22.0);\n+\t\tda.addElement(42.0);\n+\t\tda.addElement(62.0);\n+\t\tda.addElement(22.0);\n+\t\tda.addElement(122.0);\n+\t\tda.addElement(1212.0);\n+\n+\t\tassertEquals(\"Min should be -2.0\", -2.0, da.getMin(), Double.MIN_VALUE);\n+\t\tassertEquals(\n+\t\t\t\"Max should be 1212.0\",\n+\t\t\t1212.0,\n+\t\t\tda.getMax(),\n+\t\t\tDouble.MIN_VALUE);\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/ExpandableDoubleArrayTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class ExpandableDoubleArrayTest extends DoubleArrayAbstractTest {\n+\n+\tpublic ExpandableDoubleArrayTest(String name) {\n+\t\tsuper( name );\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#setUp()\n+\t */\n+\tprotected void setUp() throws Exception {\n+\t\tda = new ExpandableDoubleArray();\n+\t\tra = new ExpandableDoubleArray();\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#tearDown()\n+\t */\n+\tprotected void tearDown() throws Exception {\n+\t\tda = null;\n+\t\tra = null;\n+\t}\n+\t\n+\t\n+\t/** TEST NORMAL OPERATIONS - calling super class test and then checking internal\n+\t *   storage **/\n+\t\n+\t\n+\tpublic void testSetElementArbitraryExpansion() {\n+\t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n+\t\t\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(4.0);\n+\t\tda.addElement(6.0);\n+\t\tda.setElement(1, 3.0);\n+\t\t\n+\t\t// Expand the array arbitrarily to 1000 items\n+\t\tda.setElement(1000, 3.4);\n+\n+\t\tassertEquals( \"The number of elements should now be 1001, it isn't\", da.getNumElements(), 1001);\n+\t\t\n+\t\tassertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n+\t\t\t\t\t\t\tda.getElement( 760 ), Double.MIN_VALUE );\n+\t\t\n+\t\tassertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000), Double.MIN_VALUE );\n+\t\tassertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0), Double.MIN_VALUE);\t\t\n+\t\t\n+\t}\n+\t\t\n+\tpublic void testAdd1000() {\n+\t\tsuper.testAdd1000();\n+\t\tassertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n+\t\t\t\"16 and an expansion factor of 2.0\",\n+\t\t\t\t\t\t\t1024, ((ExpandableDoubleArray) da).getInternalLength());\n+\t}\n+\t\n+\tpublic void testAddElementRolling() {\n+\t\tsuper.testAddElementRolling();\n+\t}\n+\n+\tpublic void testSetNumberOfElements() {\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tassertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n+\t\t\n+\t\t((ExpandableDoubleArray) da).setNumElements( 3 );\n+\t\tassertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n+\t\t\n+\t\ttry {\n+\t\t\t((ExpandableDoubleArray) da).setNumElements( -3 );\n+\t\t\tfail( \"Setting number of elements to negative should've thrown an exception\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\n+\t\t((ExpandableDoubleArray) da).setNumElements(1024);\n+\t\tassertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n+\t\tassertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n+\t\t\t\t\n+\t}\n+\n+\t/** TESTS WHICH FOCUS ON ExpandableSpecific internal storage */\n+\n+\tpublic void testWithInitialCapacity() {\n+\n+\t\tExpandableDoubleArray eDA2 = new ExpandableDoubleArray(2);\n+\t\tassertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n+\n+\t\tint iterations = (int) Math.pow(2.0, 15.0);\n+\n+\t\tfor( int i = 0; i < iterations; i++) {\n+\t\t\teDA2.addElement( i );\n+\t\t}\n+\t\t\n+\t\tassertEquals(\"Number of elements should be equal to 2^15\", (int) Math.pow(2.0, 15.0), eDA2.getNumElements());\n+\t\t\n+\t\teDA2.addElement( 2.0 );\n+\t\t\n+\t\tassertEquals(\"Number of elements should be equals to 2^15 + 1\",\n+\t\t        ( (int) Math.pow(2.0, 15.0) + 1 ), eDA2.getNumElements() );\n+\t}\n+\n+\tpublic void testWithInitialCapacityAndExpansionFactor() {\n+\n+\t\tExpandableDoubleArray eDA3 = new ExpandableDoubleArray(3, 3.0f);\n+\t\tassertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n+\n+\t\tint iterations = (int) Math.pow(3.0, 7.0);\n+\n+\t\tfor( int i = 0; i < iterations; i++) {\n+\t\t\teDA3.addElement( i );\n+\t\t}\n+\t\t\n+\t\tassertEquals(\"Number of elements should be equal to 3^7\", (int) Math.pow(3.0, 7.0), eDA3.getNumElements());\n+\t\t\n+\t\teDA3.addElement( 2.0 );\n+\t\t\n+\t\tassertEquals(\"Number of elements should be equals to 3^7 + 1\",\n+\t\t\t( (int) Math.pow(3.0, 7.0) + 1 ), eDA3.getNumElements() );\n+\t\t\t\t\t\t   \n+\t\tassertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n+\t}\n+\t\n+\tpublic void testDiscard() {\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(2.0);\n+\t\tassertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+\t\t\n+\t\tda.discardFrontElements(5);\n+\t\tassertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n+\t\t\n+\t\ttry {\n+\t\t\tda.discardFrontElements(-1);\n+\t\t\tfail( \"Trying to discard a negative number of element is not allowed\");\n+\t\t} catch( Exception e ){\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tda.discardFrontElements( 10000 );\n+\t\t\tfail( \"You can't discard more elements than the array contains\");\n+\t\t} catch( Exception e ){\n+\t\t}\n+\t\t\n+\t}\n+\t\t\n+\t/** TEST ERROR CONDITIONS **/\n+\n+\tpublic void testIllegalInitialCapacity() {\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(-3, 2.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the initialCapacity was negative, if it didn't then\" +\n+\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(0, 2.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the initialCapacity was ZERO if it didn't then\" +\n+\t\t\t\t\" the range checking of initialCapacity is not working properly\" );\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t}\n+\t\n+\tpublic void testIllegalExpansionFactor() {\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.66f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for 0.66 which would shrink the array instead of expand the array\");\n+\t\t} catch( IllegalArgumentException iae ) {\n+\t\t}\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.0f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for 0.0\");\n+\t\t} catch( IllegalArgumentException iae) {\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tExpandableDoubleArray eDA = new ExpandableDoubleArray(3, -4.35f);\n+\t\t\tfail( \"That constructor should have thrown an IllegalArgumentException because \" +\n+\t\t\t\t\"the expansionFactor for -4.35\");\n+\t\t} catch( IllegalArgumentException iae) {\n+\t\t}\n+\t}\n+\t\n+\tpublic void testSetOutOfBounds() {\n+\t\t\ttry {\n+\t\t\t\tda.setElement( -1, 2.0);\n+\t\t\t\tfail( \"Cannot set a negative index\");\t\n+\t\t\t} catch( Exception e ){\n+\t\t\t}\n+\t}\n+\t\n+\tpublic void testGetOutOfBounds() {\n+\t\ttry {\n+\t\t\tda.getElement(10000);\n+\t\t\tfail( \"Cannot get an element that is larger than the number of elements\");\n+\t\t} catch( Exception e ) {\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tda.getElement(-3);\n+\t\t\tfail(\"Cannot get a negative index\");\n+\t\t} catch( Exception e ){\n+\t\t}\n+\t}\n+\t\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/FixedDoubleArrayTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+\n+/**\n+ * This class contains test cases for the ExpandableDoubleArray.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public class FixedDoubleArrayTest extends DoubleArrayAbstractTest {\n+\n+\tpublic FixedDoubleArrayTest(String name) {\n+\t\tsuper( name );\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#setUp()\n+\t */\n+\tprotected void setUp() throws Exception {\n+\t\tda = new FixedDoubleArray(4000);\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see junit.framework.TestCase#tearDown()\n+\t */\n+\tprotected void tearDown() throws Exception {\n+\t\tda = null;\n+\t}\n+\t\n+\t\n+\t/** TEST NORMAL OPERATIONS - calling super class test and then checking internal\n+\t *   storage **/\n+\t\n+\tpublic void testAddElementRolling() {\n+\t\tra = new FixedDoubleArray(6);\n+\n+\t\tsuper.testAddElementRolling();\n+\t\t\n+\t\tassertEquals( \"FixedDoubleArray should have 6 size internal storage\", \n+\t\t\t\t\t\t\t\t6, ((FixedDoubleArray) ra).internalArray.length);\t\t\n+\t}\n+\t\n+\tpublic void testExceedingElements() {\n+\t\t\n+\t\tfor( int i = 0; i < 3999; i++) {\n+\t\t\tda.addElement( 1.0 );\n+\t\t}\n+\n+\t\tda.addElement( 1.0 );\n+\t\t\n+\t\ttry {\n+\t\t\tda.addElement( 2.0 );\n+\t\t\tfail( \" Adding more than 4000 elements should cause an exception \");\n+\t\t} catch( Exception e ) {\n+\t\t}\n+\t\t\n+\t\tda.addElementRolling(2.0);\n+\t\tassertEquals( \"This is the first rolling add, the first element should be 2.0\",\n+\t\t\t\t\t\t\t\t2.0, da.getElement(0), Double.MIN_VALUE);\n+\t}\n+\t\n+\tpublic void testGetExceeding() {\n+\t\ttry {\n+\t\t\tda.getElement(100);\n+\t\t\tfail( \"I haven't added 100 elements to the list yet, trying to getElement(100) should \" +\n+\t\t\t\t\"thrown an error\");\n+\t\t} catch (Exception e ){ \n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic void testSetElement() {\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\t\n+\t\tda.setElement( 2, 4.0 );\n+\t\tassertEquals( \"Index 2 should be 4.0\", 4.0, da.getElement(2), Double.MIN_VALUE);\n+\t\t\n+\t\ttry {\n+\t\t\tda.setElement(2000, 45.0);\n+\t\t\tfail( \"The array does not contain 2000 elements yet, setting this element should\" +\n+\t\t\t\t\" cause an excpetion\");\n+\t\t} catch(Exception e) {\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic void testOnlyRolling() {\n+\t\tfor( int i = 0; i < 8000; i++) {\n+\t\t\tda.addElementRolling( i );\n+\t\t}\n+\t\t\n+\t\tassertEquals( \"The 2000th element should equal 6000\",\n+\t\t\t6000.0, da.getElement(2000), Double.MIN_VALUE);\n+\t}\n+\t\n+\tpublic void testClear() {\n+\t\tfor( int i = 0; i < 10; i++) {\n+\t\t\tda.addElementRolling(1.0);\n+\t\t}\n+\t\t\n+\t\tassertEquals( \"There should be ten elements in the array\",\n+\t\t\t\t\t\t\t\t10, da.getNumElements() );\n+\t\t\n+\t\tda.clear();\n+\n+\t\tassertEquals( \"There should be zero elements in the array\",\n+\t\t\t\t\t\t\t\t0, da.getNumElements() );\n+\n+\t\tfor( int i = 0; i < 10; i++) {\n+\t\t\tda.addElementRolling(1.0);\n+\t\t}\n+\t\t\n+\t\tassertEquals( \"There should be ten elements in the array\",\n+\t\t\t\t\t\t\t\t10, da.getNumElements() );\n+\t\t\t\t\n+\t}\n+\t\n+\tpublic void testDiscardFront() {\n+\t\ttry {\n+\t\t\tda.discardFrontElements( 2 );\n+\t\t\tfail( \"Discard front elements should throw an exception\");\n+\t\t} catch( Exception e ) {\n+\t\t}\n+\t}\n+\t\t\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.util;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the MathUtils class.\n+ *\n+ * @author Phil Steitz\n+ * @version $Revision: 1.1 $ $Date: 2003/06/22 03:57:55 $\n+ */\n+\n+public final class MathUtilsTest extends TestCase {\n+\n+    public MathUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MathUtilsTest.class);\n+        suite.setName(\"MathUtils Tests\");\n+        return suite;\n+    }\n+    \n+    public void testBinomialCoefficient() {\n+        long[] bcoef5 = {1,5,10,10,5,1};\n+        long[] bcoef6 = {1,6,15,20,15,6,1};\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(\"5 choose \" + i, bcoef5[i], \n+                MathUtils.binomialCoefficient(5,i));\n+        }\n+        for (int i = 0; i < 7; i++) {\n+            assertEquals(\"6 choose \" + i, bcoef6[i], \n+                MathUtils.binomialCoefficient(6,i));\n+        }\n+        \n+        for (int n = 1; n < 10; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), \n+                    MathUtils.binomialCoefficient(n, k));\n+                assertEquals(n + \" choose \" + k,(double) binomialCoefficient(n, k), \n+                    MathUtils.binomialCoefficientDouble(n, k),Double.MIN_VALUE);\n+                assertEquals(n + \" choose \" + k,\n+                    Math.log((double) binomialCoefficient(n, k)), \n+                    MathUtils.binomialCoefficientLog(n, k),10E-12);\n+            }\n+        }\n+      \n+      /* \n+       * Takes a long time for recursion to unwind, but succeeds \n+       * and yields exact value = 2,333,606,220\n+        \n+        assertEquals(MathUtils.binomialCoefficient(34,17),\n+            binomialCoefficient(34,17));\n+       */\n+    }\n+    \n+    public void testBinomialCoefficientFail() {\n+        try {\n+            long x = MathUtils.binomialCoefficient(0,0);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            long x = MathUtils.binomialCoefficient(4,5);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = MathUtils.binomialCoefficientDouble(0,0);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = MathUtils.binomialCoefficientDouble(4,5);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = MathUtils.binomialCoefficientLog(0,0);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = MathUtils.binomialCoefficientLog(4,5);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            long x = MathUtils.binomialCoefficient(67,34);\n+            fail (\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            ;\n+        }\n+        double x = MathUtils.binomialCoefficientDouble(1030,515);\n+        assertTrue(\"expecting infinite binomial coefficient\",\n+            Double.isInfinite(x));\n+    }\n+\n+    public void testFactorial() {\n+        for (int i = 1; i < 10; i++) {\n+            assertEquals(i + \"! \",factorial(i),MathUtils.factorial(i));\n+            assertEquals(i + \"! \",(double)factorial(i),\n+                MathUtils.factorialDouble(i),Double.MIN_VALUE);\n+            assertEquals(i + \"! \",Math.log((double)factorial(i)),\n+                MathUtils.factorialLog(i),10E-12);\n+        }\n+    }\n+\n+    public void testFactorialFail() {\n+        try {\n+            long x = MathUtils.factorial(0);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = MathUtils.factorialDouble(0);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = MathUtils.factorialLog(0);\n+            fail (\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = MathUtils.factorial(21);\n+            fail (\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            ;\n+        }\n+        assertTrue(\"expecting infinite factorial value\",\n+            Double.isInfinite(MathUtils.factorialDouble(171)));\n+\n+    }\n+\n+\n+    /**\n+     * Exact recursive implementation to test against\n+     */\n+    private long binomialCoefficient(int n, int k) {\n+        if ((n == k) || (k == 0)) {\n+            return 1;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        return binomialCoefficient(n - 1, k - 1) +\n+            binomialCoefficient(n - 1, k);\n+    }\n+\n+    /**\n+     * Finds the largest values of n for which binomialCoefficient and\n+     * binomialCoefficientDouble will return values that fit in a long, double,\n+     * resp.  Remove comments around test below to get this in test-report\n+     *\n+        public void testLimits() {\n+            findBinomialLimits();\n+        }\n+     */\n+\n+    private void findBinomialLimits() {\n+        /**\n+         * will kick out 66 as the limit for long\n+         */\n+        boolean foundLimit = false;\n+        int test = 10;\n+        while (!foundLimit) {\n+            try {\n+                double x = MathUtils.binomialCoefficient(test, test / 2);\n+            } catch (ArithmeticException ex) {\n+                foundLimit = true;\n+                System.out.println\n+                    (\"largest n for binomialCoefficient = \" + (test - 1) );\n+            }\n+            test++;\n+        }\n+\n+       /**\n+        * will kick out 1029 as the limit for double\n+        */\n+        foundLimit = false;\n+        test = 10;\n+        while (!foundLimit) {\n+            double x = MathUtils.binomialCoefficientDouble(test, test / 2);\n+            if (Double.isInfinite(x)) {\n+                foundLimit = true;\n+                System.out.println\n+                    (\"largest n for binomialCoefficientD = \" + (test - 1) );\n+            }\n+            test++;\n+        }\n+    }\n+\n+    /**\n+     * Finds the largest values of n for which factiorial and\n+     * factorialDouble will return values that fit in a long, double,\n+     * resp.  Remove comments around test below to get this in test-report\n+\n+        public void testFactiorialLimits() {\n+            findFactorialLimits();\n+        }\n+     */\n+\n+    private void findFactorialLimits() {\n+        /**\n+         * will kick out 20 as the limit for long\n+         */\n+        boolean foundLimit = false;\n+        int test = 10;\n+        while (!foundLimit) {\n+            try {\n+                double x = MathUtils.factorial(test);\n+            } catch (ArithmeticException ex) {\n+                foundLimit = true;\n+                System.out.println\n+                    (\"largest n for factorial = \" + (test - 1) );\n+            }\n+            test++;\n+        }\n+\n+       /**\n+        * will kick out 170 as the limit for double\n+        */\n+        foundLimit = false;\n+        test = 10;\n+        while (!foundLimit) {\n+            double x = MathUtils.factorialDouble(test);\n+            if (Double.isInfinite(x)) {\n+                foundLimit = true;\n+                System.out.println\n+                    (\"largest n for factorialDouble = \" + (test - 1) );\n+            }\n+            test++;\n+        }\n+    }\n+\n+\n+    /**\n+     * Exact direct multiplication implementation to test against\n+     */\n+    private long factorial(int n) {\n+        long result = 1;\n+        for (int i = 2; i <= n; i++) {\n+            result *= i;\n+        }\n+        return result;\n+    }\n+\n+\n+    public void testSignDouble() {\n+        double delta = 0.0 ;\n+        assertEquals( 1.0, MathUtils.sign( 2.0 ), delta ) ;\n+        assertEquals( -1.0, MathUtils.sign( -2.0 ), delta ) ;\n+    }\n+\n+\n+    public void testSignFloat() {\n+        float delta = 0.0F ;\n+        assertEquals( 1.0F, MathUtils.sign( 2.0F ), delta ) ;\n+        assertEquals( -1.0F, MathUtils.sign( -2.0F ), delta ) ;\n+    }\n+\n+\n+    public void testSignByte() {\n+        assertEquals( (byte)1, MathUtils.sign( (byte)2 ) ) ;\n+        assertEquals( (byte)(-1), MathUtils.sign( (byte)(-2) ) ) ;\n+    }\n+\n+\n+    public void testSignShort() {\n+        assertEquals( (short)1, MathUtils.sign( (short)2 ) ) ;\n+        assertEquals( (short)(-1), MathUtils.sign( (short)(-2) ) ) ;\n+    }\n+\n+\n+    public void testSignInt() {\n+        assertEquals( (int)1, MathUtils.sign( (int)(2) ) ) ;\n+        assertEquals( (int)(-1), MathUtils.sign( (int)(-2) ) ) ;\n+    }\n+\n+\n+    public void testSignLong() {\n+        assertEquals( 1L, MathUtils.sign( 2L ) ) ;\n+        assertEquals( -1L, MathUtils.sign( -2L ) ) ;\n+    }\n+}", "timestamp": 1056254277, "metainfo": ""}