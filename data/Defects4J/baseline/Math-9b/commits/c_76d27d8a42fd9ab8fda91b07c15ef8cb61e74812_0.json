{"sha": "76d27d8a42fd9ab8fda91b07c15ef8cb61e74812", "log": "changed public fields to private and added accessors  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n         // evaluate the cost at all non-evaluated simplex points\n         for (int i = 0; i < simplex.length; ++i) {\n             PointCostPair pair = simplex[i];\n-            if (Double.isNaN(pair.cost)) {\n-                simplex[i] = new PointCostPair(pair.point, evaluateCost(pair.point));\n+            if (Double.isNaN(pair.getCost())) {\n+                simplex[i] = new PointCostPair(pair.getPoint(), evaluateCost(pair.getPoint()));\n             }\n         }\n \n     protected void replaceWorstPoint(PointCostPair pointCostPair) {\n         int n = simplex.length - 1;\n         for (int i = 0; i < n; ++i) {\n-            if (simplex[i].cost > pointCostPair.cost) {\n+            if (simplex[i].getCost() > pointCostPair.getCost()) {\n                 PointCostPair tmp = simplex[i];\n                 simplex[i]        = pointCostPair;\n                 pointCostPair     = tmp;\n             } else if (o2 == null) {\n                 return -1;\n             }\n-            double cost1 = ((PointCostPair) o1).cost;\n-            double cost2 = ((PointCostPair) o2).cost;\n+            double cost1 = ((PointCostPair) o1).getCost();\n+            double cost2 = ((PointCostPair) o2).getCost();\n             return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);\n         }\n     };\n--- a/src/java/org/apache/commons/math/optimization/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiDirectional.java\n \n       // save the original vertex\n       PointCostPair[] original = simplex;\n-      double originalCost = original[0].cost;\n+      double originalCost = original[0].getCost();\n \n       // perform a reflection step\n       double reflectedCost = evaluateNewSimplex(original, 1.0);\n   private double evaluateNewSimplex(PointCostPair[] original, double coeff)\n     throws CostException {\n \n-    double[] xSmallest = original[0].point;\n+    double[] xSmallest = original[0].getPoint();\n     int n = xSmallest.length;\n \n     // create the linearly transformed simplex\n     simplex = new PointCostPair[n + 1];\n     simplex[0] = original[0];\n     for (int i = 1; i <= n; ++i) {\n-      double[] xOriginal    = original[i].point;\n+      double[] xOriginal    = original[i].getPoint();\n       double[] xTransformed = new double[n];\n       for (int j = 0; j < n; ++j) {\n         xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n \n     // evaluate it\n     evaluateSimplex();\n-    return simplex[0].cost;\n+    return simplex[0].getCost();\n \n   }\n \n--- a/src/java/org/apache/commons/math/optimization/NelderMead.java\n+++ b/src/java/org/apache/commons/math/optimization/NelderMead.java\n     int n = simplex.length - 1;\n \n     // interesting costs\n-    double   smallest      = simplex[0].cost;\n-    double   secondLargest = simplex[n-1].cost;\n-    double   largest       = simplex[n].cost;\n-    double[] xLargest      = simplex[n].point;\n+    double   smallest      = simplex[0].getCost();\n+    double   secondLargest = simplex[n-1].getCost();\n+    double   largest       = simplex[n].getCost();\n+    double[] xLargest      = simplex[n].getPoint();\n \n     // compute the centroid of the best vertices\n     // (dismissing the worst point at index n)\n     double[] centroid = new double[n];\n     for (int i = 0; i < n; ++i) {\n-      double[] x = simplex[i].point;\n+      double[] x = simplex[i].getPoint();\n       for (int j = 0; j < n; ++j) {\n         centroid[j] += x[j];\n       }\n       }\n \n       // perform a shrink\n-      double[] xSmallest = simplex[0].point;\n+      double[] xSmallest = simplex[0].getPoint();\n       for (int i = 1; i < simplex.length; ++i) {\n-        double[] x = simplex[i].point;\n+        double[] x = simplex[i].getPoint();\n         for (int j = 0; j < n; ++j) {\n           x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n         }\n--- a/src/java/org/apache/commons/math/optimization/PointCostPair.java\n+++ b/src/java/org/apache/commons/math/optimization/PointCostPair.java\n     this.cost = cost;\n   }\n \n+  /** Get the point.\n+   * @return the stored point\n+   */\n+  public double[] getPoint() {\n+      return point;\n+  }\n+\n+  /** Get the cost.\n+   * @return the stored cost\n+   */\n+  public double getCost() {\n+      return cost;\n+  }\n+\n   /** Point coordinates. */\n-  public final double[] point;\n+  private final double[] point;\n \n   /** Cost associated to the point. */\n-  public final double cost;\n+  private final double cost;\n \n }\n--- a/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n+++ b/src/test/org/apache/commons/math/optimization/MultiDirectionalTest.java\n                                        });\n \n     assertTrue(count > 60);\n-    assertTrue(optimum.cost > 0.01);\n+    assertTrue(optimum.getCost() > 0.01);\n \n   }\n \n                                        new double[] {  3.0, -1.0, 0.0, 1.0 },\n                                        new double[] {  4.0,  0.0, 1.0, 2.0 });\n     assertTrue(count > 850);\n-    assertTrue(optimum.cost > 0.015);\n+    assertTrue(optimum.getCost() > 0.015);\n \n   }\n \n     public boolean converged(PointCostPair[] simplex) {\n       PointCostPair smallest = simplex[0];\n       PointCostPair largest  = simplex[simplex.length - 1];\n-      return (largest.cost - smallest.cost) < threshold;\n+      return (largest.getCost() - smallest.getCost()) < threshold;\n     }\n \n     private double threshold;\n--- a/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n+++ b/src/test/org/apache/commons/math/optimization/NelderMeadTest.java\n \n     assertTrue(count > 700);\n     assertTrue(count < 800);\n-    assertEquals(0.0, optimum.cost, 5.0e-5);\n-    assertEquals(1.0, optimum.point[0], 0.01);\n-    assertEquals(1.0, optimum.point[1], 0.01);\n+    assertEquals(0.0, optimum.getCost(), 5.0e-5);\n+    assertEquals(1.0, optimum.getPoint()[0], 0.01);\n+    assertEquals(1.0, optimum.getPoint()[1], 0.01);\n \n     PointCostPair[] minima = nm.getMinima();\n     assertEquals(10, minima.length);\n             }\n         } else {\n             if (i > 0) {\n-                assertTrue(minima[i-1].cost <= minima[i].cost);\n+                assertTrue(minima[i-1].getCost() <= minima[i].getCost());\n             }\n         }\n     }\n                                               new UniformRandomGenerator(rg));\n     optimum =\n         nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg);\n-    assertEquals(0.0, optimum.cost, 2.0e-4);\n+    assertEquals(0.0, optimum.getCost(), 2.0e-4);\n     optimum =\n         nm.minimizes(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3);\n-    assertEquals(0.0, optimum.cost, 3.0e-5);\n+    assertEquals(0.0, optimum.getCost(), 3.0e-5);\n \n   }\n \n                    new double[] {  4.0,  0.0, 1.0, 2.0 },\n                    1, 1642738l);\n     assertTrue(count < 150);\n-    assertEquals(0.0, optimum.cost, 6.0e-4);\n-    assertEquals(0.0, optimum.point[0], 0.07);\n-    assertEquals(0.0, optimum.point[1], 0.07);\n-    assertEquals(0.0, optimum.point[2], 0.07);\n-    assertEquals(0.0, optimum.point[3], 0.07);\n+    assertEquals(0.0, optimum.getCost(), 6.0e-4);\n+    assertEquals(0.0, optimum.getPoint()[0], 0.07);\n+    assertEquals(0.0, optimum.getPoint()[1], 0.07);\n+    assertEquals(0.0, optimum.getPoint()[2], 0.07);\n+    assertEquals(0.0, optimum.getPoint()[3], 0.07);\n \n   }\n \n     public boolean converged(PointCostPair[] simplex) {\n       PointCostPair smallest = simplex[0];\n       PointCostPair largest  = simplex[simplex.length - 1];\n-      return (largest.cost - smallest.cost) < threshold;\n+      return (largest.getCost() - smallest.getCost()) < threshold;\n     }\n \n     private double threshold;", "timestamp": 1200850218, "metainfo": ""}