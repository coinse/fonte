{"sha": "dbefec8360f55ad230df9ac1c345aca80121f147", "log": "Added missing @since tags.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionNewtonForm.java\n        return evaluate(a, c, z);\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * {@inheritDoc}\n+     * @since 3.1\n+     */\n     public DerivativeStructure value(final DerivativeStructure t) {\n         verifyInputArray(a, c);\n \n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/LaguerreSolver.java\n      * @throws NullArgumentException if the {@code coefficients} is\n      * {@code null}.\n      * @throws NoDataException if the {@code coefficients} array is empty.\n+     * @since 3.1\n      */\n     public Complex[] solveAllComplex(double[] coefficients,\n                                      double initial)\n      * @throws NullArgumentException if the {@code coefficients} is\n      * {@code null}.\n      * @throws NoDataException if the {@code coefficients} array is empty.\n+     * @since 3.1\n      */\n     public Complex solveComplex(double[] coefficients,\n                                 double initial)\n--- a/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n implements IntegerDistribution, Serializable {\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n+\n      /**\n       * RandomData instance used to generate samples from the distribution.\n       * @deprecated As of 3.1, to be removed in 4.0. Please use the\n       */\n     @Deprecated\n     protected final RandomDataImpl randomData = new RandomDataImpl();\n-    /** RNG instance used to generate samples from the distribution. */\n+\n+    /**\n+     * RNG instance used to generate samples from the distribution.\n+     * @since 3.1\n+     */\n     protected final RandomGenerator random;\n \n     /**\n     }\n     /**\n      * @param rng Random number generator.\n+     * @since 3.1\n      */\n     protected AbstractIntegerDistribution(RandomGenerator rng) {\n         random = rng;\n--- a/src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java\n       */\n     @Deprecated\n     protected RandomDataImpl randomData = new RandomDataImpl();\n-    /** RNG instance used to generate samples from the distribution. */\n+\n+    /**\n+     * RNG instance used to generate samples from the distribution.\n+     * @since 3.1\n+     */\n     protected final RandomGenerator random;\n+\n     /** Solver absolute accuracy for inverse cumulative computation */\n     private double solverAbsoluteAccuracy = SOLVER_DEFAULT_ABSOLUTE_ACCURACY;\n \n     }\n     /**\n      * @param rng Random number generator.\n+     * @since 3.1\n      */\n     protected AbstractRealDistribution(RandomGenerator rng) {\n         random = rng;\n      * {@inheritDoc}\n      *\n      * @return zero.\n+     * @since 3.1\n      */\n     public double probability(double x) {\n         return 0d;\n--- a/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n      * Returns the shape parameter of {@code this} distribution.\n      *\n      * @return the shape parameter\n+     * @since 3.1\n      */\n     public double getShape() {\n         return shape;\n      * Returns the scale parameter of {@code this} distribution.\n      *\n      * @return the scale parameter\n+     * @since 3.1\n      */\n     public double getScale() {\n         return scale;\n--- a/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n      * @param shape Shape parameter of this distribution.\n      * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n      * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n+     * @since 3.1\n      */\n     public LogNormalDistribution(RandomGenerator rng,\n                                  double scale,\n--- a/src/main/java/org/apache/commons/math3/exception/NotANumberException.java\n+++ b/src/main/java/org/apache/commons/math3/exception/NotANumberException.java\n /**\n  * Exception to be thrown when a number is not a number.\n  *\n- * @since 3.0\n+ * @since 3.1\n  * @version $Id$\n  */\n public class NotANumberException extends MathIllegalNumberException {\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n      * Add a {@link Collection} of chromosomes to this {@link Population}.\n      * @param chromosomeColl a {@link Collection} of chromosomes\n      * @throws NumberIsTooLargeException if the population would exceed the population limit when\n-     *   adding this chromosome\n+     * adding this chromosome\n+     * @since 3.1\n      */\n     public void addChromosomes(final Collection<Chromosome> chromosomeColl) throws NumberIsTooLargeException {\n         if (chromosomes.size() + chromosomeColl.size() > populationLimit) {\n     /**\n      * Access the list of chromosomes.\n      * @return the list of chromosomes\n+     * @since 3.1\n      */\n     protected List<Chromosome> getChromosomeList() {\n         return chromosomes;\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/oned/Interval.java\n      * belong to the boundary\n      * @return a code representing the point status: either {@link\n      * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n+     * @since 3.1\n      */\n     public Location checkPoint(final double point, final double tolerance) {\n         if (point < lower - tolerance || point > upper + tolerance) {\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java\n      *\n      * @param p to check\n      * @return distance between the instance and the point\n+     * @since 3.1\n      */\n     public double distance(final Vector2D p) {\n         return FastMath.abs(getOffset(p));\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n      * @param hyperplaneThickness tolerance below which points are considered to\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param vertices vertices of the simple loop boundary\n+     * @since 3.1\n      */\n     public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices) {\n         super(verticesToTree(hyperplaneThickness, vertices));\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Segment.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Segment.java\n      *\n      * @param p to check\n      * @return distance between the instance and the point\n+     * @since 3.1\n      */\n     public double distance(final Vector2D p) {\n         final double deltaX = end.getX() - start.getX();\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n      * @throws MaxCountExceededException if the algorithm fails to converge.\n      * @throws MathArithmeticException if the decomposition of a general matrix\n      * results in a matrix with zero norm\n+     * @since 3.1\n      */\n     public EigenDecomposition(final RealMatrix matrix)\n         throws MathArithmeticException {\n      * @param main Main diagonal of the symmetric tridiagonal form.\n      * @param secondary Secondary of the tridiagonal form.\n      * @throws MaxCountExceededException if the algorithm fails to converge.\n+     * @since 3.1\n      */\n     public EigenDecomposition(final double[] main, final double[] secondary) {\n         isSymmetric = true;\n      * @return the square-root of the matrix.\n      * @throws MathUnsupportedOperationException if the matrix is not\n      * symmetric or not positive definite.\n+     * @since 3.1\n      */\n     public RealMatrix getSquareRoot() {\n         if (!isSymmetric) {\n--- a/src/main/java/org/apache/commons/math3/linear/JacobiPreconditioner.java\n+++ b/src/main/java/org/apache/commons/math3/linear/JacobiPreconditioner.java\n      * P = diag(1 / &radic;A<sub>11</sub>, 1 / &radic;A<sub>22</sub>, &hellip;).\n      *\n      * @return the square root of {@code this} preconditioner\n+     * @since 3.1\n      */\n     public RealLinearOperator sqrt() {\n         final RealVector sqrtDiag = diag.map(new Sqrt());", "timestamp": 1355553918, "metainfo": ""}