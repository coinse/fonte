{"sha": "189717fd10f468e2d0a40bc94369fca5b3d1ec41", "log": "added a clustering package with an implementation of k-means++ JIRA: MATH-266  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/clustering/Cluster.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Cluster holding a set of {@link Clusterable} points.\n+ * @param <T> the type of points that can be clustered\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class Cluster<T extends Clusterable<T>> implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1741417096265465690L;\n+\n+    /** The points contained in this cluster. */\n+    final List<T> points;\n+\n+    /** Center of the cluster. */\n+    final T center;\n+\n+    /**\n+     * Build a cluster centered at a specified point.\n+     * @param center the point which is to be the center of this cluster\n+     */\n+    public Cluster(final T center) {\n+        this.center = center;\n+        points = new ArrayList<T>();\n+    }\n+\n+    /**\n+     * Add a point to this cluster.\n+     * @param point point to add\n+     */\n+    public void addPoint(final T point) {\n+        points.add(point);\n+    }\n+\n+    /**\n+     * Get the points contained in the cluster.\n+     * @return points contained in the cluster\n+     */\n+    public List<T> getPoints() {\n+        return points;\n+    }\n+\n+    /**\n+     * Get the point chosen to be the center of this cluster.\n+     * @return chosen cluster center\n+     */\n+    public T getCenter() {\n+        return center;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/clustering/Clusterable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+/**\n+ * Interface for points that can be clustered together.\n+ * @param <T> the type of point that can be clustered\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface Clusterable<T> extends Serializable {\n+\n+    /**\n+     * Returns the distance from the given point.\n+     * \n+     * @param p the point to compute the distance from\n+     * @return the distance from the given point\n+     */\n+    double distanceFrom(T p);\n+\n+    /**\n+     * Returns the centroid of the given Collection of points.\n+     * \n+     * @param p the Collection of points to compute the centroid of\n+     * @return the centroid of the given Collection of Points\n+     */\n+    T centroidOf(Collection<T> p);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * A simple implementation of {@link Clusterable} for points with integer coordinates.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EuclideanIntegerPoint implements Clusterable<EuclideanIntegerPoint> {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 3946024775784901369L;\n+\n+    /** Point coordinates. */\n+    private final int[] point;\n+\n+    /**\n+     * @param point the n-dimensional point in integer space\n+     */\n+    public EuclideanIntegerPoint(final int[] point) {\n+        this.point = point;\n+    }\n+\n+    /**\n+     * Returns the n-dimensional point in integer space\n+     */\n+    public int[] getPoint() {\n+        return point;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceFrom(final EuclideanIntegerPoint p) {\n+        return MathUtils.distance(point, p.getPoint());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public EuclideanIntegerPoint centroidOf(final Collection<EuclideanIntegerPoint> points) {\n+        int[] centroid = new int[getPoint().length];\n+        for (EuclideanIntegerPoint p : points) {\n+            for (int i = 0; i < centroid.length; i++) {\n+                centroid[i] += p.getPoint()[i];\n+            }\n+        }\n+        for (int i = 0; i < centroid.length; i++) {\n+            centroid[i] /= points.size();\n+        }\n+        return new EuclideanIntegerPoint(centroid);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(final Object other) {\n+        if (!(other instanceof EuclideanIntegerPoint)) {\n+            return false;\n+        }\n+        final int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint();\n+        if (point.length != otherPoint.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < point.length; i++) {\n+            if (point[i] != otherPoint[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 0;\n+        for (Integer i : point) {\n+            hashCode += i.hashCode() * 13 + 7;\n+        }\n+        return hashCode;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+\n+/**\n+ * Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.\n+ * @see <a href=\"http://en.wikipedia.org/wiki/K-means%2B%2B\">K-means++ (wikipedia)</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n+\n+    /** Random generator for choosing initial centers. */\n+    private final Random random;\n+\n+    /** Build a clusterer.\n+     * @param random random generator to use for choosing initial centers\n+     */\n+    public KMeansPlusPlusClusterer(final Random random) {\n+        this.random = random;\n+    }\n+\n+    /**\n+     * Runs the K-means++ clustering algorithm.\n+     * \n+     * @param points the points to cluster\n+     * @param k the number of clusters to split the data into\n+     * @param maxIterations the maximum number of iterations to run the algorithm\n+     *     for.  If negative, no maximum will be used\n+     * @return a list of clusters containing the points\n+     */\n+    public List<Cluster<T>> cluster(final Collection<T> points,\n+                                    final int k, final int maxIterations) {\n+        // create the initial clusters\n+        List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\n+        assignPointsToClusters(clusters, points);\n+\n+        // iterate through updating the centers until we're done\n+        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; \n+        for (int count = 0; count < max; count++) {\n+            boolean clusteringChanged = false;\n+            List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n+            for (final Cluster<T> cluster : clusters) {\n+                final T newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\n+                if (!newCenter.equals(cluster.getCenter())) {\n+                    clusteringChanged = true;\n+                }\n+                newClusters.add(new Cluster<T>(newCenter));\n+            }\n+            if (!clusteringChanged) {\n+                return clusters;\n+            }\n+            assignPointsToClusters(newClusters, points);\n+            clusters = newClusters;\n+        }\n+        return clusters;\n+    }\n+\n+    /**\n+     * Adds the given points to the closest {@link Cluster}.\n+     * \n+     * @param clusters the {@link Cluster}s to add the points to\n+     * @param points the points to add to the given {@link Cluster}s\n+     */\n+    private static <T extends Clusterable<T>> void\n+        assignPointsToClusters(final Collection<Cluster<T>> clusters, final Collection<T> points) {\n+        for (final T p : points) {\n+            Cluster<T> cluster = getNearestCluster(clusters, p);\n+            cluster.addPoint(p);\n+        }\n+    }\n+\n+    /**\n+     * Use K-means++ to choose the initial centers.\n+     * \n+     * @param points the points to choose the initial centers from\n+     * @param k the number of centers to choose\n+     * @param random random generator to use\n+     * @return the initial centers\n+     */\n+    private static <T extends Clusterable<T>> List<Cluster<T>>\n+        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n+\n+        final List<T> pointSet = new ArrayList<T>(points);\n+        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n+\n+        // Choose one center uniformly at random from among the data points.\n+        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n+        resultSet.add(new Cluster<T>(firstPoint));\n+\n+        final double[] dx2 = new double[pointSet.size()];\n+        while (resultSet.size() < k) {\n+            // For each data point x, compute D(x), the distance between x and \n+            // the nearest center that has already been chosen.\n+            int sum = 0;\n+            for (int i = 0; i < pointSet.size(); i++) {\n+                final T p = pointSet.get(i);\n+                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n+                final double d = p.distanceFrom(nearest.getCenter());\n+                sum += d * d;\n+                dx2[i] = sum;\n+            }\n+\n+            // Add one new data point as a center. Each point x is chosen with\n+            // probability proportional to D(x)2\n+            final double r = random.nextDouble() * sum;\n+            for (int i = 0 ; i < dx2.length; i++) {\n+                if (dx2[i] >= r) {\n+                    final T p = pointSet.remove(i);\n+                    resultSet.add(new Cluster<T>(p));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return resultSet;\n+\n+    }\n+\n+    /**\n+     * Returns the nearest {@link Cluster} to the given point\n+     * \n+     * @param clusters the {@link Cluster}s to search\n+     * @param point the point to find the nearest {@link Cluster} for\n+     * @return the nearest {@link Cluster} to the given point\n+     */\n+    private static <T extends Clusterable<T>> Cluster<T>\n+        getNearestCluster(final Collection<Cluster<T>> clusters, final T point) {\n+        double minDistance = Double.MAX_VALUE;\n+        Cluster<T> minCluster = null;\n+        for (final Cluster<T> c : clusters) {\n+            final double distance = point.distanceFrom(c.getCenter());\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                minCluster = c;\n+            }\n+        }\n+        return minCluster;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.junit.Test;\n+\n+public class KMeansPlusPlusClustererTest {\n+\n+    @Test\n+    public void dimension2() {\n+        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer =\n+            new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l));\n+        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n+\n+                // first expected cluster\n+                new EuclideanIntegerPoint(new int[] { -15,  3 }),\n+                new EuclideanIntegerPoint(new int[] { -15,  4 }),\n+                new EuclideanIntegerPoint(new int[] { -15,  5 }),\n+                new EuclideanIntegerPoint(new int[] { -14,  3 }),\n+                new EuclideanIntegerPoint(new int[] { -14,  5 }),\n+                new EuclideanIntegerPoint(new int[] { -13,  3 }),\n+                new EuclideanIntegerPoint(new int[] { -13,  4 }),\n+                new EuclideanIntegerPoint(new int[] { -13,  5 }),\n+\n+                // second expected cluster\n+                new EuclideanIntegerPoint(new int[] { -1,  0 }),\n+                new EuclideanIntegerPoint(new int[] { -1, -1 }),\n+                new EuclideanIntegerPoint(new int[] {  0, -1 }),\n+                new EuclideanIntegerPoint(new int[] {  1, -1 }),\n+                new EuclideanIntegerPoint(new int[] {  1, -2 }),\n+\n+                // third expected cluster\n+                new EuclideanIntegerPoint(new int[] { 13,  3 }),\n+                new EuclideanIntegerPoint(new int[] { 13,  4 }),\n+                new EuclideanIntegerPoint(new int[] { 14,  4 }),\n+                new EuclideanIntegerPoint(new int[] { 14,  7 }),\n+                new EuclideanIntegerPoint(new int[] { 16,  5 }),\n+                new EuclideanIntegerPoint(new int[] { 16,  6 }),\n+                new EuclideanIntegerPoint(new int[] { 17,  4 }),\n+                new EuclideanIntegerPoint(new int[] { 17,  7 })\n+\n+        };\n+        List<Cluster<EuclideanIntegerPoint>> clusters =\n+            transformer.cluster(Arrays.asList(points), 3, 10);\n+\n+        assertEquals(3, clusters.size());\n+        boolean cluster1Found = false;\n+        boolean cluster2Found = false;\n+        boolean cluster3Found = false;\n+        for (Cluster<EuclideanIntegerPoint> cluster : clusters) {\n+            int[] center = cluster.getCenter().getPoint();\n+            if (center[0] < 0) {\n+                cluster1Found = true;\n+                assertEquals(8, cluster.getPoints().size());\n+                assertEquals(-14, center[0]);\n+                assertEquals( 4, center[1]);\n+            } else if (center[1] < 0) {\n+                cluster2Found = true;\n+                assertEquals(5, cluster.getPoints().size());\n+                assertEquals( 0, center[0]);\n+                assertEquals(-1, center[1]);\n+            } else {\n+                cluster3Found = true;\n+                assertEquals(8, cluster.getPoints().size());\n+                assertEquals(15, center[0]);\n+                assertEquals(5, center[1]);\n+            }\n+        }\n+        assertTrue(cluster1Found);\n+        assertTrue(cluster2Found);\n+        assertTrue(cluster3Found);\n+\n+    }\n+\n+}", "timestamp": 1241292891, "metainfo": ""}