{"sha": "768f5bea53ba6ce8492f4728fca1ed64dc51781c", "log": "In package o.a.c.m.transform, created enum DctNormalization to be passed to the constructor of FastCosineTransformer (instead of boolean parameter). Made constructor public, and removed factory methods. See MATH-743  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/DctNormalization.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+/**\n+ * This enumeration defines the various types of normalizations that can be\n+ * applied to discrete cosine transforms (DCT). The exact definition of these\n+ * normalizations is detailed below.\n+ *\n+ * @see FastCosineTransformer\n+ * @version $Id Revision$\n+ * @since 3.0\n+ */\n+public enum DctNormalization {\n+    /**\n+     * <p>\n+     * Should be passed to the constructor of {@link FastCosineTransformer}\n+     * to use the <em>standard</em> normalization convention.  The standard\n+     * DCT-I normalization convention is defined as follows\n+     * <ul>\n+     * <li>forward transform:\n+     * y<sub>n</sub> = (1/2) [x<sub>0</sub> + (-1)<sup>n</sup>x<sub>N-1</sub>]\n+     * + &sum;<sub>k=1</sub><sup>N-2</sup>\n+     * x<sub>k</sub> cos[&pi; nk / (N - 1)],</li>\n+     * <li>inverse transform:\n+     * x<sub>k</sub> = [1 / (N - 1)] [y<sub>0</sub>\n+     * + (-1)<sup>k</sup>y<sub>N-1</sub>]\n+     * + [2 / (N - 1)] &sum;<sub>n=1</sub><sup>N-2</sup>\n+     * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n+     * </ul>\n+     * where N is the size of the data sample.\n+     * </p>\n+     */\n+    STANDARD_DCT_I,\n+\n+    /**\n+     * <p>\n+     * Should be passed to the constructor of {@link FastCosineTransformer}\n+     * to use the <em>orthogonal</em> normalization convention. The orthogonal\n+     * DCT-I normalization convention is defined as follows\n+     * <ul>\n+     * <li>forward transform:\n+     * y<sub>n</sub> = [2(N - 1)]<sup>-1/2</sup> [x<sub>0</sub>\n+     * + (-1)<sup>n</sup>x<sub>N-1</sub>]\n+     * + [2 / (N - 1)]<sup>1/2</sup> &sum;<sub>k=1</sub><sup>N-2</sup>\n+     * x<sub>k</sub> cos[&pi; nk / (N - 1)],</li>\n+     * <li>inverse transform:\n+     * x<sub>k</sub> = [2(N - 1)]<sup>-1/2</sup> [y<sub>0</sub>\n+     * + (-1)<sup>k</sup>y<sub>N-1</sub>]\n+     * + [2 / (N - 1)]<sup>1/2</sup> &sum;<sub>n=1</sub><sup>N-2</sup>\n+     * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n+     * </ul>\n+     * which makes the transform orthogonal. N is the size of the data sample.\n+     */\n+    ORTHOGONAL_DCT_I;\n+}\n--- a/src/main/java/org/apache/commons/math/transform/DftNormalization.java\n+++ b/src/main/java/org/apache/commons/math/transform/DftNormalization.java\n public enum DftNormalization {\n     /**\n      * <p>\n-     * Should be passed to the constructor of e.g.\n-     * {@link FastFourierTransformer} to use the <em>standard</em> normalization\n-     * convention. This normalization convention is defined as follows\n+     * Should be passed to the constructor of {@link FastFourierTransformer}\n+     * to use the <em>standard</em> normalization convention. This normalization\n+     * convention is defined as follows\n      * <ul>\n      * <li>forward transform: y<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup>\n      * x<sub>k</sub> exp(-2&pi;i n k / N),</li>\n \n     /**\n      * <p>\n-     * Should be passed to the constructor of e.g.\n-     * {@link FastFourierTransformer} to use the <em>unitary</em> normalization\n-     * convention. This normalization convention is defined as follows\n+     * Should be passed to the constructor of {@link FastFourierTransformer}\n+     * to use the <em>unitary</em> normalization convention. This normalization\n+     * convention is defined as follows\n      * <ul>\n      * <li>forward transform: y<sub>n</sub> = (1 / &radic;N)\n      * &sum;<sub>k=0</sub><sup>N-1</sup> x<sub>k</sub>\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  * <p>\n  * There are several variants of the discrete cosine transform. The present\n  * implementation corresponds to DCT-I, with various normalization conventions,\n- * which are described below.\n+ * which are specified by the parameter {@link DctNormalization}.\n  * </p>\n- * <h3><a id=\"standard\">Standard DCT-I</a></h3>\n- * <p>\n- * The standard normalization convention is defined as follows\n- * <ul>\n- * <li>forward transform:\n- * y<sub>n</sub> = (1/2) [x<sub>0</sub> + (-1)<sup>n</sup>x<sub>N-1</sub>]\n- * + &sum;<sub>k=1</sub><sup>N-2</sup>\n- * x<sub>k</sub> cos[&pi; nk / (N - 1)],</li>\n- * <li>inverse transform:\n- * x<sub>k</sub> = [1 / (N - 1)] [y<sub>0</sub>\n- * + (-1)<sup>k</sup>y<sub>N-1</sub>]\n- * + [2 / (N - 1)] &sum;<sub>n=1</sub><sup>N-2</sup>\n- * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n- * </ul>\n- * where N is the size of the data sample.\n- * </p>\n- * <p> {@link RealTransformer}s following this convention are returned by the\n- * factory method {@link #create()}.\n- * </p>\n- * <h3><a id=\"orthogonal\">Orthogonal DCT-I</a></h3>\n- * <p>\n- * The orthogonal normalization convention is defined as follows\n- * <ul>\n- * <li>forward transform:\n- * y<sub>n</sub> = [2(N - 1)]<sup>-1/2</sup> [x<sub>0</sub>\n- * + (-1)<sup>n</sup>x<sub>N-1</sub>]\n- * + [2 / (N - 1)]<sup>1/2</sup> &sum;<sub>k=1</sub><sup>N-2</sup>\n- * x<sub>k</sub> cos[&pi; nk / (N - 1)],</li>\n- * <li>inverse transform:\n- * x<sub>k</sub> = [2(N - 1)]<sup>-1/2</sup> [y<sub>0</sub>\n- * + (-1)<sup>k</sup>y<sub>N-1</sub>]\n- * + [2 / (N - 1)]<sup>1/2</sup> &sum;<sub>n=1</sub><sup>N-2</sup>\n- * y<sub>n</sub> cos[&pi; nk / (N - 1)],</li>\n- * </ul>\n- * which makes the transform orthogonal. N is the size of the data sample.\n- * </p>\n- * <p> {@link RealTransformer}s following this convention are returned by the\n- * factory method {@link #createOrthogonal()}.\n- * </p>\n- * <h3>Link with the DFT, and assumptions on the layout of the data set</h3>\n  * <p>\n  * DCT-I is equivalent to DFT of an <em>even extension</em> of the data series.\n  * More precisely, if x<sub>0</sub>, &hellip;, x<sub>N-1</sub> is the data set\n  * (N&nbsp;=&nbsp;2<sup>n</sup>&nbsp;+&nbsp;1). Besides, it implicitly assumes\n  * that the sampled function is even.\n  * </p>\n- * <p>As of version 2.0 this no longer implements Serializable.</p>\n  *\n  * @version $Id$\n  * @since 1.2\n public class FastCosineTransformer implements RealTransformer, Serializable {\n \n     /** Serializable version identifier. */\n-    static final long serialVersionUID = 20120211L;\n+    static final long serialVersionUID = 20120212L;\n \n-    /**\n-     * {@code true} if the orthogonal version of the DCT should be used.\n-     *\n-     * @see #create()\n-     * @see #createOrthogonal()\n-     */\n-    private final boolean orthogonal;\n+    /** The type of DCT to be performed. */\n+    private final DctNormalization normalization;\n \n     /**\n      * Creates a new instance of this class, with various normalization\n      * conventions.\n      *\n-     * @param orthogonal {@code false} if the DCT is <em>not</em> to be scaled,\n-     * {@code true} if it is to be scaled so as to make the transform\n-     * orthogonal.\n-     * @see #create()\n-     * @see #createOrthogonal()\n+     * @param normalization the type of normalization to be applied to the\n+     * transformed data\n      */\n-    private FastCosineTransformer(final boolean orthogonal) {\n-        this.orthogonal = orthogonal;\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns a new instance of this class. The returned transformer uses the\n-     * <a href=\"#standard\">standard normalizing conventions</a>.\n-     * </p>\n-     *\n-     * @return a new DCT transformer, with standard normalizing conventions\n-     */\n-    public static FastCosineTransformer create() {\n-        return new FastCosineTransformer(false);\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns a new instance of this class. The returned transformer uses the\n-     * <a href=\"#orthogonal\">orthogonal normalizing conventions</a>.\n-     * </p>\n-     *\n-     * @return a new DCT transformer, with orthogonal normalizing conventions\n-     */\n-    public static FastCosineTransformer createOrthogonal() {\n-        return new FastCosineTransformer(true);\n+    public FastCosineTransformer(final DctNormalization normalization) {\n+        this.normalization = normalization;\n     }\n \n     /**\n      */\n     public double[] transform(final double[] f, final TransformType type) {\n         if (type == TransformType.FORWARD) {\n-            if (orthogonal) {\n+            if (normalization == DctNormalization.ORTHOGONAL_DCT_I) {\n                 final double s = FastMath.sqrt(2.0 / (f.length - 1));\n                 return TransformUtils.scaleArray(fct(f), s);\n             }\n             return fct(f);\n         }\n         final double s2 = 2.0 / (f.length - 1);\n-        final double s1 = orthogonal ? FastMath.sqrt(s2) : s2;\n+        final double s1;\n+        if (normalization == DctNormalization.ORTHOGONAL_DCT_I) {\n+            s1 = FastMath.sqrt(s2);\n+        } else {\n+            s1 = s2;\n+        }\n         return TransformUtils.scaleArray(fct(f), s1);\n     }\n \n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n public final class FastCosineTransformerTest\n     extends RealTransformerAbstractTest {\n \n-    private final boolean standard;\n+    private DctNormalization normalization;\n \n     private final int[] invalidDataSize;\n \n \n     private final int[] validDataSize;\n \n-    public FastCosineTransformerTest(final boolean standard) {\n-        this.standard = standard;\n+    public FastCosineTransformerTest(final DctNormalization normalization) {\n+        this.normalization = normalization;\n         this.validDataSize = new int[] {\n             2, 3, 5, 9, 17, 33, 65, 129\n         };\n      */\n     @Parameters\n     public static Collection<Object[]> data() {\n-        final Object[][] data = new Boolean[][] {\n-            {\n-                Boolean.TRUE\n-            }, {\n-                Boolean.FALSE\n-            }\n-        };\n+        final DctNormalization[] normalization = DctNormalization.values();\n+        final Object[][] data = new DctNormalization[normalization.length][1];\n+        for (int i = 0; i < normalization.length; i++){\n+            data[i][0] = normalization[i];\n+        }\n         return Arrays.asList(data);\n     }\n \n     @Override\n     RealTransformer createRealTransformer() {\n-        if (standard) {\n-            return FastCosineTransformer.create();\n-        } else {\n-            return FastCosineTransformer.createOrthogonal();\n-        }\n+        return new FastCosineTransformer(normalization);\n     }\n \n     @Override\n         }\n         final double s;\n         if (type == TransformType.FORWARD) {\n-            s = standard ? 1.0 : FastMath.sqrt(2.0 / (n - 1.0));\n+            if (normalization == DctNormalization.STANDARD_DCT_I) {\n+                s = 1.0;\n+            } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) {\n+                s = FastMath.sqrt(2.0 / (n - 1.0));\n+            } else {\n+                throw new MathIllegalStateException();\n+            }\n         } else if (type == TransformType.INVERSE) {\n-            s = standard ? 2.0 / (n - 1.0) : FastMath.sqrt(2.0 / (n - 1.0));\n+            if (normalization == DctNormalization.STANDARD_DCT_I) {\n+                s = 2.0 / (n - 1.0);\n+            } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) {\n+                s = FastMath.sqrt(2.0 / (n - 1.0));\n+            } else {\n+                throw new MathIllegalStateException();\n+            }\n         } else {\n             /*\n              * Should never occur. This clause is a safeguard in case other\n     /** Test of transformer for the ad hoc data. */\n     @Test\n     public void testAdHocData() {\n-        FastCosineTransformer transformer = FastCosineTransformer.create();\n+        FastCosineTransformer transformer;\n+        transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I);\n         double result[], tolerance = 1E-12;\n \n         double x[] = {\n \n         TransformUtils.scaleArray(x, FastMath.sqrt(0.5 * (x.length - 1)));\n \n-        transformer = FastCosineTransformer.createOrthogonal();\n+        transformer = new FastCosineTransformer(DctNormalization.ORTHOGONAL_DCT_I);\n         result = transformer.transform(y, TransformType.FORWARD);\n         for (int i = 0; i < result.length; i++) {\n             Assert.assertEquals(x[i], result[i], tolerance);\n     public void testParameters()\n         throws Exception {\n         UnivariateFunction f = new SinFunction();\n-        FastCosineTransformer transformer = FastCosineTransformer.create();\n+        FastCosineTransformer transformer;\n+        transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I);\n \n         try {\n             // bad interval\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        FastCosineTransformer transformer = FastCosineTransformer.create();\n+        FastCosineTransformer transformer;\n+        transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I);\n         double min, max, result[], tolerance = 1E-12;\n         int N = 9;\n ", "timestamp": 1329059895, "metainfo": ""}