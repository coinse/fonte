{"sha": "34b67820de002100899910042b36d9821fbec924", "log": "Unnecessary casts  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n         // y is the most significant 10 bits of the mantissa\n         //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n         //double epsilon = (x - y) / y;\n-        double epsilon = (double)(bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n+        double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n \n         double lnza = 0.0;\n         double lnzb = 0.0;\n             double xb = ab;\n \n             /* Need a more accurate epsilon, so adjust the division. */\n-            double numer = (double)(bits & 0x3ffffffffffL);\n+            double numer = (bits & 0x3ffffffffffL);\n             double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n             aa = numer - xa*denom - xb * denom;\n             xb += aa / denom;\n             return x*y;\n         }\n \n-        return (double) y;\n+        return y;\n     }\n \n     /** Get the smallest whole number larger than x.\n      * @return exponent for d in IEEE754 representation, without bias\n      */\n     public static int getExponent(final float f) {\n-        return (int) ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n+        return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n     }\n \n }", "timestamp": 1296588942, "metainfo": ""}