{"sha": "f36be8e8b7371fb8814456b6c095866aa802de78", "log": "fixed an error leading the simplex solver to compute the right solution but return another one JIRA: MATH-286  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n+        return getBasicRow(col, true);\n+    }\n+\n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRowForSolution(final int col) {\n+        return getBasicRow(col, false);\n+    }\n+    \n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n-        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n+        for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n      * @return current solution\n      */\n     protected RealPointValuePair getSolution() {\n-        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-        Integer basicRow =\n-            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n-        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n-        Set<Integer> basicRows = new HashSet<Integer>();\n-        for (int i = 0; i < coefficients.length; i++) {\n-            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n-            if (basicRows.contains(basicRow)) {\n-                // if multiple variables can take a given value \n-                // then we choose the first and set the rest equal to 0\n-                coefficients[i] = 0;\n-            } else {\n-                basicRows.add(basicRow);\n-                coefficients[i] =\n-                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n-                    (restrictToNonNegative ? 0 : mostNegative);\n-            }\n-        }\n+      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n+      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n+      Set<Integer> basicRows = new HashSet<Integer>();\n+      for (int i = 0; i < coefficients.length; i++) {\n+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n+          if (basicRows.contains(basicRow)) {\n+              // if multiple variables can take a given value \n+              // then we choose the first and set the rest equal to 0\n+              coefficients[i] = 0;\n+          } else {\n+              basicRows.add(basicRow);\n+              coefficients[i] =\n+                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n+                  (restrictToNonNegative ? 0 : mostNegative);\n+          }\n+      }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n      */\n     protected final int getRhsOffset() {\n         return getWidth() - 1;\n+    }\n+    \n+    /**\n+     * Returns the offset of the extra decision variable added when there is a\n+     * negative decision variable in the original problem.\n+     * @return the offset of x-\n+     */\n+    protected final int getNegativeDecisionVariableOffset() {\n+      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n         assertEquals(1.0, solution.getPoint()[1], .0000001);\n         assertEquals(1.0, solution.getPoint()[2], .0000001);\n         assertEquals(3.0, solution.getValue(), .0000001);\n-      }\n-\n+    }\n+\n+    @Test\n+    public void testMath286() throws OptimizationException {\n+      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.2, 0.3 }, 0 );\n+      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+      constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 23.0));\n+\n+      RealPointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MAXIMIZE, true);\n+      assertEquals(6.9, solution.getValue(), .0000001);\n+    }\n+    \n     @Test\n     public void testSimplexSolver() throws OptimizationException {\n         LinearObjectiveFunction f =", "timestamp": 1250896062, "metainfo": ""}