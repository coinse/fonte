{"sha": "f5c5faf71661dc286a7fc867ab0da72866b79216", "log": "simplified tests added new tests  ", "commit": "\n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n package org.apache.commons.math.linear;\n \n+import java.util.Random;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n     /** test dimensions */\n     public void testDimensions() {\n-        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n-        QRDecomposition qr = new QRDecompositionImpl(matrix);\n-        assertEquals(\"3x3 Q size\", qr.getQ().getRowDimension(), 3);\n-        assertEquals(\"3x3 Q size\", qr.getQ().getColumnDimension(), 3);\n-        assertEquals(\"3x3 R size\", qr.getR().getRowDimension(), 3);\n-        assertEquals(\"3x3 R size\", qr.getR().getColumnDimension(), 3);\n-\n-        matrix = MatrixUtils.createRealMatrix(testData4x3);\n-        qr = new QRDecompositionImpl(matrix);\n-        assertEquals(\"4x3 Q size\", qr.getQ().getRowDimension(), 4);\n-        assertEquals(\"4x3 Q size\", qr.getQ().getColumnDimension(), 4);\n-        assertEquals(\"4x3 R size\", qr.getR().getRowDimension(), 4);\n-        assertEquals(\"4x3 R size\", qr.getR().getColumnDimension(), 3);\n-\n-        matrix = MatrixUtils.createRealMatrix(testData3x4);\n-        qr = new QRDecompositionImpl(matrix);\n-        assertEquals(\"3x4 Q size\", qr.getQ().getRowDimension(), 3);\n-        assertEquals(\"3x4 Q size\", qr.getQ().getColumnDimension(), 3);\n-        assertEquals(\"3x4 R size\", qr.getR().getRowDimension(), 3);\n-        assertEquals(\"3x4 R size\", qr.getR().getColumnDimension(), 4);\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        checkDimension(createTestMatrix(r, p, q));\n+        checkDimension(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkDimension(RealMatrix m) {\n+        int rows = m.getRowDimension();\n+        int columns = m.getColumnDimension();\n+        QRDecomposition qr = new QRDecompositionImpl(m);\n+        assertEquals(rows,    qr.getQ().getRowDimension());\n+        assertEquals(rows,    qr.getQ().getColumnDimension());\n+        assertEquals(rows,    qr.getR().getRowDimension());\n+        assertEquals(columns, qr.getR().getColumnDimension());        \n     }\n \n     /** test A = QR */\n     public void testAEqualQR() {\n-        RealMatrix A = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n-        QRDecomposition qr = new QRDecompositionImpl(A);\n-        RealMatrix Q = qr.getQ();\n-        RealMatrix R = qr.getR();\n-        double norm = Q.multiply(R).subtract(A).getNorm();\n-        assertEquals(\"3x3 nonsingular A = QR\", 0, norm, normTolerance);\n-\n-        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n-        qr = new QRDecompositionImpl(matrix);\n-        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n-        assertEquals(\"3x3 singular A = QR\", 0, norm, normTolerance);\n-\n-        matrix = MatrixUtils.createRealMatrix(testData3x4);\n-        qr = new QRDecompositionImpl(matrix);\n-        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n-        assertEquals(\"3x4 A = QR\", 0, norm, normTolerance);\n-\n-        matrix = MatrixUtils.createRealMatrix(testData4x3);\n-        qr = new QRDecompositionImpl(matrix);\n-        norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n-        assertEquals(\"4x3 A = QR\", 0, norm, normTolerance);\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        checkAEqualQR(createTestMatrix(r, p, q));\n+\n+        checkAEqualQR(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkAEqualQR(RealMatrix m) {\n+        QRDecomposition qr = new QRDecompositionImpl(m);\n+        double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm();\n+        assertEquals(0, norm, normTolerance);\n     }\n \n     /** test the orthogonality of Q */\n     public void testQOrthogonal() {\n-        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n-        RealMatrix q  = new QRDecompositionImpl(matrix).getQ();\n-        RealMatrix qT = new QRDecompositionImpl(matrix).getQT();\n-        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);\n-        double norm = qT.multiply(q).subtract(eye).getNorm();\n-        assertEquals(\"3x3 nonsingular Q'Q = I\", 0, norm, normTolerance);\n-\n-        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n-        q  = new QRDecompositionImpl(matrix).getQ();\n-        qT = new QRDecompositionImpl(matrix).getQT();\n-        eye = MatrixUtils.createRealIdentityMatrix(3);\n-        norm = qT.multiply(q).subtract(eye).getNorm();\n-        assertEquals(\"3x3 singular Q'Q = I\", 0, norm, normTolerance);\n-\n-        matrix = MatrixUtils.createRealMatrix(testData3x4);\n-        q  = new QRDecompositionImpl(matrix).getQ();\n-        qT = new QRDecompositionImpl(matrix).getQT();\n-        eye = MatrixUtils.createRealIdentityMatrix(3);\n-        norm = qT.multiply(q).subtract(eye).getNorm();\n-        assertEquals(\"3x4 Q'Q = I\", 0, norm, normTolerance);\n-\n-        matrix = MatrixUtils.createRealMatrix(testData4x3);\n-        q  = new QRDecompositionImpl(matrix).getQ();\n-        qT = new QRDecompositionImpl(matrix).getQT();\n-        eye = MatrixUtils.createRealIdentityMatrix(4);\n-        norm = qT.multiply(q).subtract(eye).getNorm();\n-        assertEquals(\"4x3 Q'Q = I\", 0, norm, normTolerance);\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        checkQOrthogonal(createTestMatrix(r, p, q));\n+\n+        checkQOrthogonal(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkQOrthogonal(RealMatrix m) {\n+        QRDecomposition qr = new QRDecompositionImpl(m);\n+        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());\n+        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();\n+        assertEquals(0, norm, normTolerance);\n     }\n \n     /** test that R is upper triangular */\n     public void testRUpperTriangular() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n-        RealMatrix R = new QRDecompositionImpl(matrix).getR();\n-        for (int i = 0; i < R.getRowDimension(); i++)\n-            for (int j = 0; j < i; j++)\n-                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n-                        entryTolerance);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n \n         matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n-        R = new QRDecompositionImpl(matrix).getR();\n-        for (int i = 0; i < R.getRowDimension(); i++)\n-            for (int j = 0; j < i; j++)\n-                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n-                        entryTolerance);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n \n         matrix = MatrixUtils.createRealMatrix(testData3x4);\n-        R = new QRDecompositionImpl(matrix).getR();\n-        for (int i = 0; i < R.getRowDimension(); i++)\n-            for (int j = 0; j < i; j++)\n-                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n-                        entryTolerance);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n \n         matrix = MatrixUtils.createRealMatrix(testData4x3);\n-        R = new QRDecompositionImpl(matrix).getR();\n-        for (int i = 0; i < R.getRowDimension(); i++)\n-            for (int j = 0; j < i; j++)\n-                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n-                        entryTolerance);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new QRDecompositionImpl(matrix).getR());\n+\n+    }\n+\n+    private void checkUpperTriangular(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            private static final long serialVersionUID = -7685630069569815930L;\n+            public void visit(int row, int column, double value) {\n+                if (column < row) {\n+                    assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n     }\n \n     /** test that H is trapezoidal */\n     public void testHTrapezoidal() {\n         RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n-        RealMatrix H = new QRDecompositionImpl(matrix).getH();\n-        for (int i = 0; i < H.getRowDimension(); i++)\n-            for (int j = i + 1; j < H.getColumnDimension(); j++)\n-                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n \n         matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n-        H = new QRDecompositionImpl(matrix).getH();\n-        for (int i = 0; i < H.getRowDimension(); i++)\n-            for (int j = i + 1; j < H.getColumnDimension(); j++)\n-                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n \n         matrix = MatrixUtils.createRealMatrix(testData3x4);\n-        H = new QRDecompositionImpl(matrix).getH();\n-        for (int i = 0; i < H.getRowDimension(); i++)\n-            for (int j = i + 1; j < H.getColumnDimension(); j++)\n-                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n \n         matrix = MatrixUtils.createRealMatrix(testData4x3);\n-        H = new QRDecompositionImpl(matrix).getH();\n-        for (int i = 0; i < H.getRowDimension(); i++)\n-            for (int j = i + 1; j < H.getColumnDimension(); j++)\n-                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n-\n-    }\n-\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new QRDecompositionImpl(matrix).getH());\n+\n+    }\n+\n+    private void checkTrapezoidal(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            private static final long serialVersionUID = -43649044361860701L;\n+            public void visit(int row, int column, double value) {\n+                if (column > row) {\n+                    assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n     /** test matrices values */\n     public void testMatricesValues() {\n         QRDecomposition qr =\n         \n     }\n \n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n+            private static final long serialVersionUID = -556118291433400034L;\n+            public double visit(int row, int column, double value)\n+                throws MatrixVisitorException {\n+                return 2.0 * r.nextDouble() - 1.0;\n+            }\n+        });\n+        return m;\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRSolverTest.java\n \n package org.apache.commons.math.linear;\n \n+import java.util.Random;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n public class QRSolverTest extends TestCase {\n     double[][] testData3x3NonSingular = { \n-            { 12, -51, 4 }, \n-            { 6, 167, -68 },\n-            { -4, 24, -41 }, };\n+            { 12, -51,   4 }, \n+            {  6, 167, -68 },\n+            { -4,  24, -41 }\n+    };\n \n     double[][] testData3x3Singular = { \n-            { 1, 4, 7, }, \n-            { 2, 5, 8, },\n-            { 3, 6, 9, }, };\n+            { 1, 2,  2 }, \n+            { 2, 4,  6 },\n+            { 4, 8, 12 }\n+    };\n \n     double[][] testData3x4 = { \n-            { 12, -51, 4, 1 }, \n-            { 6, 167, -68, 2 },\n-            { -4, 24, -41, 3 }, };\n+            { 12, -51,   4, 1 }, \n+            {  6, 167, -68, 2 },\n+            { -4,  24, -41, 3 }\n+    };\n \n     double[][] testData4x3 = { \n-            { 12, -51, 4, }, \n-            { 6, 167, -68, },\n-            { -4, 24, -41, }, \n-            { -5, 34, 7, }, };\n+            { 12, -51,   4 }, \n+            {  6, 167, -68 },\n+            { -4,  24, -41 }, \n+            { -5,  34,   7 }\n+    };\n \n     public QRSolverTest(String name) {\n         super(name);\n \n     /** test rank */\n     public void testRank() {\n-        QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)));\n+        DecompositionSolver solver =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n         assertTrue(solver.isNonSingular());\n \n-        solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)));\n+        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n         assertFalse(solver.isNonSingular());\n \n-        solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)));\n-        assertFalse(solver.isNonSingular());\n-\n-        solver = new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)));\n+        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x4)).getSolver();\n+        assertTrue(solver.isNonSingular());\n+\n+        solver = new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData4x3)).getSolver();\n         assertTrue(solver.isNonSingular());\n \n     }\n \n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n-        QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)));\n+        DecompositionSolver solver =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             solver.solve(b);\n \n     /** test solve rank errors */\n     public void testSolveRankErrors() {\n-        QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)));\n+        DecompositionSolver solver =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n         try {\n             solver.solve(b);\n \n     /** test solve */\n     public void testSolve() {\n-        QRSolver solver =\n-            new QRSolver(new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular)));\n+        QRDecomposition decomposition =\n+            new QRDecompositionImpl(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+        DecompositionSolver solver = decomposition.getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n         });\n         });\n \n         // using RealMatrix\n-        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm());\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n+            final double[] x = solver.solve(b.getColumn(i));\n+            final double error = new RealVectorImpl(x).subtract(xRef.getColumnVector(i)).getNorm();\n+            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n         }\n \n         // using RealVectorImpl\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n+            final RealVector x = solver.solve(b.getColumnVector(i));\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n         }\n \n         // using RealVector with an alternate implementation\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             RealVectorImplTest.RealVectorTestImpl v =\n                 new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n-                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-    }\n-\n+            final RealVector x = solver.solve(v);\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+    }\n+\n+    public void testOverdetermined() {\n+        final Random r    = new Random(5559252868205245l);\n+        int          p    = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, DenseRealMatrix.BLOCK_SIZE + 3);\n+\n+        // build a perturbed system: A.X + noise = B\n+        RealMatrix b = a.multiply(xRef);\n+        final double noise = 0.001;\n+        b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+            private static final long serialVersionUID = 3533849820776962636L;\n+            public double visit(int row, int column, double value) {\n+                return value * (1.0 + noise * (2 * r.nextDouble() - 1));\n+            }\n+        });\n+\n+        // despite perturbation, the least square solution should be pretty good\n+        RealMatrix x = new QRDecompositionImpl(a).getSolver().solve(b);\n+        assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);\n+\n+    }\n+\n+    public void testUnderdetermined() {\n+        final Random r    = new Random(42185006424567123l);\n+        int          p    = (5 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (7 * DenseRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, DenseRealMatrix.BLOCK_SIZE + 3);\n+        RealMatrix   b    = a.multiply(xRef);\n+        RealMatrix   x = new QRDecompositionImpl(a).getSolver().solve(b);\n+\n+        // too many equations, the system cannot be solved at all\n+        assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);\n+\n+        // the last unknown should have been set to 0\n+        assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm());\n+\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n+            private static final long serialVersionUID = -556118291433400034L;\n+            public double visit(int row, int column, double value)\n+                throws MatrixVisitorException {\n+                return 2.0 * r.nextDouble() - 1.0;\n+            }\n+        });\n+        return m;\n+    }\n }", "timestamp": 1231092530, "metainfo": ""}