{"sha": "20786a617657c0c20315005c621052a2735dfe67", "log": "Ported numerics improvements in commons lang Fraction implementation. Added utility methods for overflow-checked integer arithmetic and improved gcd method in MathUtils.   ", "commit": "\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n  */\n package org.apache.commons.math.fraction;\n \n+import java.math.BigInteger;\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.util.MathUtils;\n \n      * reduced to lowest terms.\n      * @param num the numerator.\n      * @param den the denominator.\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n      */\n     public Fraction(int num, int den) {\n         super();\n+        if (den == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (den < 0) {\n+            if (num == Integer.MIN_VALUE ||\n+                    den == Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            num = -num;\n+            den = -den;\n+        }\n         this.numerator = num;\n         this.denominator = den;\n         reduce();\n             ret = negate();\n         }\n         return ret;        \n-    }\n-    \n-    /**\n-     * Return the sum of this fraction and the given fraction.  The returned\n-     * fraction is reduced to lowest terms.\n-     *\n-     * @param rhs the other fraction.\n-     * @return the fraction sum in lowest terms.\n-     */\n-    public Fraction add(Fraction rhs) {\n-        int den = MathUtils.lcm(denominator, rhs.denominator);\n-        int num = (numerator * (den / denominator)) +\n-            (rhs.numerator * (den / rhs.denominator));\n-        return new Fraction(num, den);\n     }\n     \n     /**\n         }\n         \n         return ret;\n-    }\n-\n-    /**\n-     * Return the quotient of this fraction and the given fraction.  The\n-     * returned fraction is reduced to lowest terms.\n-     * @param rhs the other fraction.\n-     * @return the fraction quotient in lowest terms.\n-     */\n-    public Fraction divide(Fraction rhs) {\n-        return multiply(rhs.reciprocal());\n     }\n     \n     /**\n     }\n     \n     /**\n-     * Return the product of this fraction and the given fraction.  The returned\n-     * fraction is reduced to lowest terms.\n-     * @param rhs the other fraction.\n-     * @return the fraction product in lowest terms.\n-     */\n-    public Fraction multiply(Fraction rhs) {\n-        return new Fraction(numerator * rhs.numerator, \n-                denominator * rhs.denominator);\n-    }\n-    \n-    /**\n      * Return the additive inverse of this fraction.\n      * @return the negation of this fraction.\n      */\n     public Fraction negate() {\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: too large to negate\");\n+        }\n         return new Fraction(-numerator, denominator);\n     }\n \n     }\n     \n     /**\n-     * Return the difference between this fraction and the given fraction.  The\n-     * returned fraction is reduced to lowest terms.\n-     * @param rhs the other fraction.\n-     * @return the fraction difference in lowest terms.\n-     */\n-    public Fraction subtract(Fraction rhs) {\n-        return add(rhs.negate());\n+     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n+     * The algorithm follows Knuth, 4.5.1.</p>\n+     *\n+     * @param fraction  the fraction to add, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction add(Fraction fraction) {\n+        return addSub(fraction, true /* add */);\n+    }\n+\n+    /**\n+     * <p>Subtracts the value of another fraction from the value of this one, \n+     * returning the result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to subtract, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    public Fraction subtract(Fraction fraction) {\n+        return addSub(fraction, false /* subtract */);\n+    }\n+\n+    /** \n+     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n+     * \n+     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param isAdd true to add, false to subtract\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    private Fraction addSub(Fraction fraction, boolean isAdd) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        // zero is identity for addition.\n+        if (numerator == 0) {\n+            return isAdd ? fraction : fraction.negate();\n+        }\n+        if (fraction.numerator == 0) {\n+            return this;\n+        }     \n+        // if denominators are randomly distributed, d1 will be 1 about 61%\n+        // of the time.\n+        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n+        if (d1==1) {\n+            // result is ( (u*v' +/- u'v) / u'v')\n+            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n+            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n+            return new Fraction\n+                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n+                 MathUtils.subAndCheck(uvp, upv),\n+                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n+        }\n+        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n+        // exercise 7.  we're going to use a BigInteger.\n+        // t = u(v'/d1) +/- v(u'/d1)\n+        BigInteger uvp = BigInteger.valueOf(numerator)\n+        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n+        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+        .multiply(BigInteger.valueOf(denominator/d1));\n+        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        // but d2 doesn't need extra precision because\n+        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n+        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n+\n+        // result is (t/d2) / (u'/d1)(v'/d2)\n+        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        if (w.bitLength() > 31) {\n+            throw new ArithmeticException\n+            (\"overflow: numerator too large after multiply\");\n+        }\n+        return new Fraction (w.intValue(), \n+                MathUtils.mulAndCheck(denominator/d1, \n+                        fraction.denominator/d2));\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the \n+     * result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction multiply(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (numerator == 0 || fraction.numerator == 0) {\n+            return ZERO;\n+        }\n+        // knuth 4.5.1\n+        // make sure we don't overflow unless the result *must* overflow.\n+        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n+        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n+        return getReducedFraction\n+        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n+                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another.</p>\n+     *\n+     * @param fraction  the fraction to divide by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the fraction to divide by is zero\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction divide(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (fraction.numerator == 0) {\n+            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n+        }\n+        return multiply(fraction.reciprocal());\n+    }\n+    \n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance, with the numerator and denominator reduced\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     */\n+    public static Fraction getReducedFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (numerator==0) {\n+            return ZERO; // normalize zero.\n+        }\n+        // allow 2^k/-2^31 as a valid fraction (where k>0)\n+        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n+            numerator/=2; denominator/=2;\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        // simplify fraction.\n+        int gcd = MathUtils.gcd(numerator, denominator);\n+        numerator /= gcd;\n+        denominator /= gcd;\n+        return new Fraction(numerator, denominator);\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n     }\n \n     /**\n-     * Returns the greatest common divisor between two integer values.\n-     * @param a the first integer value.\n-     * @param b the second integer value.\n-     * @return the greatest common divisor between a and b.\n-     */\n-    public static int gcd(int a, int b) {\n-        int ret;\n-        \n-        if (a == 0) {\n-            ret = Math.abs(b);\n-        } else if (b == 0) {\n-            ret = Math.abs(a);\n-        } else if (a < 0) {\n-            ret = gcd(-a, b);\n-        } else if (b < 0) {\n-            ret = gcd(a, -b);\n-        } else {\n-            int r = 0;\n-            while(b > 0){\n-                r = a % b;\n-                a = b;\n-                b = r;\n+     * <p>Gets the greatest common divisor of the absolute value of\n+     * two numbers, using the \"binary gcd\" method which avoids\n+     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).</p>\n+     *\n+     * @param u  a non-zero number\n+     * @param v  a non-zero number\n+     * @return the greatest common divisor, never zero\n+     */\n+    public static int gcd(int u, int v) {\n+        if (u * v == 0) {\n+            return (Math.abs(u) + Math.abs(v));\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u>0) { u=-u; } // make u negative\n+        if (v>0) { v=-v; } // make v negative\n+        // B1. [Find power of 2]\n+        int k=0;\n+        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n+            u/=2; v/=2; k++; // cast out twos.\n+        }\n+        if (k==31) {\n+            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        //     one is odd.\n+        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t&1)==0) { // while t is even..\n+                t/=2; // cast out twos\n             }\n-            ret = a;\n-        }\n-        return ret;\n+            // B5 [reset max(u,v)]\n+            if (t>0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u)/2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t!=0);\n+        return -u*(1<<k); // gcd is u*2^k\n+    }\n+\n+    /** \n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     *                             an int\n+     */\n+    public static int mulAndCheck(int x, int y) {\n+        long m = ((long)x)*((long)y);\n+        if (m < Integer.MIN_VALUE ||\n+                m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /** \n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    public static int addAndCheck(int x, int y) {\n+        long s = (long)x+(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+                s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /** \n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    public static int subAndCheck(int x, int y) {\n+        long s = (long)x-(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+                s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n     }\n }\n--- a/src/test/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/org/apache/commons/math/fraction/FractionTest.java\n         assertFraction(10, 21, c.abs());\n     }\n     \n+    public void testReciprocal() {\n+        Fraction f = null;\n+        \n+        f = new Fraction(50, 75);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = new Fraction(4, 3);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        f = new Fraction(-15, 47);\n+        f = f.reciprocal();\n+        assertEquals(-47, f.getNumerator());\n+        assertEquals(15, f.getDenominator());\n+        \n+        f = new Fraction(0, 3);\n+        try {\n+            f = f.reciprocal();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // large values\n+        f = new Fraction(Integer.MAX_VALUE, 1);\n+        f = f.reciprocal();\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+    }\n+    \n+    public void testNegate() {\n+        Fraction f = null;\n+        \n+        f = new Fraction(50, 75);\n+        f = f.negate();\n+        assertEquals(-2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = new Fraction(-50, 75);\n+        f = f.negate();\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+\n+        // large values\n+        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        f = new Fraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.negate();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n     public void testAdd() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n         assertFraction(7, 6, a.add(b));\n         assertFraction(7, 6, b.add(a));\n         assertFraction(4, 3, b.add(b));\n+        \n+        Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n+        Fraction f2 = Fraction.ONE;\n+        Fraction f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = new Fraction(-1, 13*13*2*2);\n+        f2 = new Fraction(-2, 13*17*2);\n+        f = f1.add(f2);\n+        assertEquals(13*13*17*2*2, f.getDenominator());\n+        assertEquals(-17 - 2*13*2, f.getNumerator());\n+        \n+        try {\n+            f.add(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = new Fraction(1,32768*3);\n+        f2 = new Fraction(1,59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = new Fraction(Integer.MIN_VALUE, 3);\n+        f2 = new Fraction(1,3);\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        try {\n+            f = f.add(Fraction.ONE); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = new Fraction(Integer.MIN_VALUE, 5);\n+        f2 = new Fraction(-1,5);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(3,327680);\n+        f2 = new Fraction(2,59049);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n     }\n     \n     public void testDivide() {\n         assertFraction(3, 4, a.divide(b));\n         assertFraction(4, 3, b.divide(a));\n         assertFraction(1, 1, b.divide(b));\n+        \n+        Fraction f1 = new Fraction(3, 5);\n+        Fraction f2 = Fraction.ZERO;\n+        try {\n+            Fraction f = f1.divide(f2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(0, 5);\n+        f2 = new Fraction(2, 7);\n+        Fraction f = f1.divide(f2);\n+        assertSame(Fraction.ZERO, f);\n+        \n+        f1 = new Fraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.divide(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = new Fraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f1);  \n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = new Fraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.divide(null);\n+            fail(\"IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = new Fraction(1, Integer.MAX_VALUE);\n+            f = f1.divide(f1.reciprocal());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f1 = new Fraction(1, -Integer.MAX_VALUE);\n+            f = f1.divide(f1.reciprocal());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n     }\n     \n     public void testMultiply() {\n         assertFraction(1, 3, a.multiply(b));\n         assertFraction(1, 3, b.multiply(a));\n         assertFraction(4, 9, b.multiply(b));\n+        \n+        Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);\n+        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        Fraction f = f1.multiply(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.multiply(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n     }\n     \n     public void testSubtract() {\n         assertFraction(-1, 6, a.subtract(b));\n         assertFraction(1, 6, b.subtract(a));\n         assertFraction(0, 1, b.subtract(b));\n+        \n+        Fraction f = new Fraction(1,1);\n+        try {\n+            f.subtract(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        Fraction f1 = new Fraction(1,32768*3);\n+        Fraction f2 = new Fraction(1,59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = new Fraction(Integer.MIN_VALUE, 3);\n+        f2 = new Fraction(1,3).negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f1 = new Fraction(1, Integer.MAX_VALUE);\n+            f2 = new Fraction(1, Integer.MAX_VALUE - 1);\n+            f = f1.subtract(f2);\n+            fail(\"expecting ArithmeticException\");  //should overflow\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = new Fraction(Integer.MIN_VALUE, 5);\n+        f2 = new Fraction(1,5);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(Integer.MIN_VALUE, 1);\n+            f = f.subtract(Fraction.ONE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(Integer.MAX_VALUE, 1);\n+            f = f.subtract(Fraction.ONE.negate());\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(3,327680);\n+        f2 = new Fraction(2,59049);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n     }\n }\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n         return suite;\n     }\n     \n+    public void testAddAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        assertEquals(big, MathUtils.addAndCheck(big, 0));\n+        try {\n+            int res = MathUtils.addAndCheck(big, 1);\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            int res = MathUtils.addAndCheck(bigNeg, -1);\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testMulAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        assertEquals(big, MathUtils.mulAndCheck(big, 1));\n+        try {\n+            int res = MathUtils.mulAndCheck(big, 2);\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            int res = MathUtils.mulAndCheck(bigNeg, 2);\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testSubAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        assertEquals(big, MathUtils.subAndCheck(big, 0));\n+        try {\n+            int res = MathUtils.subAndCheck(big, -1);\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            int res = MathUtils.subAndCheck(bigNeg, 1);\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n     public void testBinomialCoefficient() {\n         long[] bcoef5 = {1,5,10,10,5,1};\n         long[] bcoef6 = {1,6,15,20,15,6,1};", "timestamp": 1115183699, "metainfo": ""}