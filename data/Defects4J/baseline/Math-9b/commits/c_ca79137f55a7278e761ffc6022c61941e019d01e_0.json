{"sha": "ca79137f55a7278e761ffc6022c61941e019d01e", "log": "Collection of patches to initial Mantissa sources: - Fixed a problem when switching functions triggered derivatives   discontinuities - Removed methods and classes that were deprecated in Mantissa   and do not need to be preserved in commons-math as backward compatibility   is not a problem for this newly integrated code - Changed Vector3D and Rotation to immutable classes for ease of use - Improved some javadoc in class Rotation JIRA: MATH-161 Submitted (with patches) by Luc Maisonobe   ", "commit": "\n--- a/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n     { \"dimensions mismatch: ODE problem has dimension {0},\"\n     + \" state vector has dimension {1}\",\n       \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\"\n-    + \" et le vecteur d'\\u00e9tat ({1})\" },\n+    + \" et le vecteur d''\\u00e9tat ({1})\" },\n     { \"too small integration interval: length = {0}\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/geometry/ImmutableVector3D.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/ImmutableVector3D.java\n-// Licensed to the Apache Software Foundation (ASF) under one\n-// or more contributor license agreements.  See the NOTICE file\n-// distributed with this work for additional information\n-// regarding copyright ownership.  The ASF licenses this file\n-// to you under the Apache License, Version 2.0 (the\n-// \"License\"); you may not use this file except in compliance\n-// with the License.  You may obtain a copy of the License at\n-// \n-//   http://www.apache.org/licenses/LICENSE-2.0\n-// \n-// Unless required by applicable law or agreed to in writing,\n-// software distributed under the License is distributed on an\n-// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-// KIND, either express or implied.  See the License for the\n-// specific language governing permissions and limitations\n-// under the License.\n-\n-package org.spaceroots.mantissa.geometry;\n-\n-/**\n- * This class implements immutable vectors in a three-dimensional space.\n-\n- * @version $Id: ImmutableVector3D.java 1705 2006-09-17 19:57:39Z luc $\n- * @author L. Maisonobe\n-\n- */\n-\n-public class ImmutableVector3D\n-  extends Vector3D {\n-\n-  /** Simple constructor.\n-   * Build a vector from its coordinates\n-   * @param x abscissa\n-   * @param y ordinate\n-   * @param z height\n-   */\n-  public ImmutableVector3D(double x, double y, double z) {\n-    super(x, y, z);\n-    computeNorm();\n-  }\n-\n-  /** Simple constructor.\n-   * Build a vector from its azimuthal coordinates\n-   * @param alpha azimuth around Z\n-   *              (0 is +X, PI/2 is +Y, PI is -X and 3PI/2 is -Y)\n-   * @param delta elevation above (XY) plane, from -PI to +PI\n-   */\n-  public ImmutableVector3D(double alpha, double delta) {\n-    super(alpha, delta);\n-    computeNorm();\n-  }\n-\n-  /** Copy constructor.\n-   * Build a copy of a vector\n-   * @param v vector to copy\n-   */\n-  public ImmutableVector3D(Vector3D v) {\n-    super(v);\n-    computeNorm();\n-  }\n-\n-  /** Multiplicative constructor\n-   * Build a vector from another one and a scale factor. \n-   * The vector built will be a * u\n-   * @param a scale factor\n-   * @param u base (unscaled) vector\n-   */\n-  public ImmutableVector3D(double a, Vector3D u) {\n-    super(a, u);\n-    computeNorm();\n-  }\n-\n-  /** Linear constructor\n-   * Build a vector from two other ones and corresponding scale factors.\n-   * The vector built will be a * u +  b * v\n-   * @param a first scale factor\n-   * @param u first base (unscaled) vector\n-   * @param b second scale factor\n-   * @param v second base (unscaled) vector\n-   */\n-  public ImmutableVector3D(double a, Vector3D u, double b, Vector3D v) {\n-    super(a, u, b, v);\n-    computeNorm();\n-  }\n-\n-  /** Set the abscissa of the vector.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param x new abscissa for the vector\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void setX(double x) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Set the ordinate of the vector.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param y new ordinate for the vector\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void setY(double y) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Set the height of the vector.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param z new height for the vector\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void setZ(double z) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Set all coordinates of the vector.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param x new abscissa for the vector\n-   * @param y new ordinate for the vector\n-   * @param z new height for the vector\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void setCoordinates(double x, double y, double z) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Compute the norm once and for all. */\n-  private void computeNorm() {\n-    norm = Math.sqrt(x * x + y * y + z * z);\n-  }\n-\n-  /** Get the norm for the vector.\n-   * @return euclidian norm for the vector\n-   */\n-  public double getNorm() {\n-    return norm;\n-  }\n-\n-  /** Add a vector to the instance.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param v vector to add\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void addToSelf(Vector3D v) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Subtract a vector from the instance.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param v vector to subtract\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void subtractFromSelf(Vector3D v) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Normalize the instance.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void normalizeSelf() {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Revert the instance.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void negateSelf() {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Multiply the instance by a scalar\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param a scalar by which the instance should be multiplied\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void multiplySelf(double a) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Reinitialize internal state from the specified array slice data.\n-   * This method should not be called for immutable vectors, it always\n-   * throws an <code>UnsupportedOperationException</code> exception\n-   * @param start start index in the array\n-   * @param array array holding the data to extract\n-   * @exception UnsupportedOperationException thrown in every case\n-   */\n-  public void mapStateFromArray(int start, double[] array) {\n-    throw new UnsupportedOperationException(\"vector is immutable\");\n-  }\n-\n-  /** Norm of the vector. */\n-  private double norm;\n-\n-  private static final long serialVersionUID = 5377895850033895270L;\n-\n-}\n--- a/src/mantissa/src/org/spaceroots/mantissa/geometry/Rotation.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/Rotation.java\n \n package org.spaceroots.mantissa.geometry;\n \n-import org.spaceroots.mantissa.utilities.ArraySliceMappable;\n import java.io.Serializable;\n \n /**\n \n  * <p>Rotations can be represented by several different mathematical\n  * entities (matrices, axe and angle, Cardan or Euler angles,\n- * quaternions). This class is an higher level abstraction, more\n- * user-oriented and hiding this implementation detail. Well, for the\n+ * quaternions). This class presents an higher level abstraction, more\n+ * user-oriented and hiding this implementation details. Well, for the\n  * curious, we use quaternions for the internal representation. The\n  * user can build a rotation from any of these representations, and\n  * any of these representations can be retrieved from a\n  * <code>Rotation</code> instance (see the various constructors and\n  * getters). In addition, a rotation can also be built implicitely\n- * from a set of vectors before and after it has been applied. This\n- * means that this class can be used to compute transformations from\n- * one representation to another one. For example, extracting a set of\n- * Cardan angles from a rotation matrix can be done using one single\n- * line of code:</p>\n+ * from a set of vectors and their image.</p>\n+ * <p>This implies that this class can be used to transform one\n+ * representation into another one. For example, converting a rotation\n+ * matrix into a set of Cardan angles from can be done using the\n+ * followong single line of code:</p>\n  * <pre>\n  * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);\n  * </pre>\n- * <p>Focus is more oriented on what a rotation <em>do</em>. Once it\n- * has been built, and regardless of its representation, a rotation is\n- * an <em>operator</em> which basically transforms three dimensional\n- * {@link Vector3D vectors} into other three dimensional {@link\n- * Vector3D vectors}. Depending on the application, the meaning of\n- * these vectors can vary. For example in an attitude simulation tool,\n- * you will often consider the vector is fixed and you transform its\n- * coordinates in one frame into its coordinates in another frame. In\n- * this case, the rotation implicitely defines the relation between\n- * the two frames. Another example could be a telescope control application,\n- * where the rotation would transform the sighting direction at rest\n- * into the desired observing direction. In this case the frame is the\n- * same (probably a topocentric one) and the raw and transformed\n- * vectors are different. In many case, both approaches will be\n- * combined, in our telescope example, we will probably also need to\n- * transform the observing direction in the topocentric frame into the\n- * observing direction in inertial frame taking into account the\n- * observatory location and the earth rotation.</p>\n-\n- * <p>These examples show that a rotation is what the user wants it to\n- * be, so this class does not push the user towards one specific\n- * definition and hence does not provide methods like\n- * <code>projectVectorIntoDestinationFrame</code> or\n- * <code>computeTransformedDirection</code>. It provides simpler and\n- * more generic methods: {@link #applyTo(Vector3D) applyTo(Vector3D)}\n- * and {@link #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n-\n- * <p>Since a rotation is basically a vectorial operator, several\n- * rotations can be composed together and the composite operation\n- * <code>r = r1 o r2</code> (which means that for each vector\n- * <code>u</code>, <code>r(u) = r1(r2(u))</code>) is also a\n- * rotation. Hence we can consider that in addition to vectors, a\n- * rotation can be applied to other rotations (or to itself). With our\n- * previous notations, we would say we can apply <code>r1</code> to\n- * <code>r2</code> and the result we get is <code>r = r1 o\n- * r2</code>. For this purpose, the class provides the methods: {@link\n- * #applyTo(Rotation) applyTo(Rotation)} and {@link\n- * #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n+ * <p>Focus is oriented on what a rotation <em>do</em> rather than on its\n+ * underlying representation. Once it has been built, and regardless of its\n+ * internal representation, a rotation is an <em>operator</em> which basically\n+ * transforms three dimensional {@link Vector3D vectors} into other three\n+ * dimensional {@link Vector3D vectors}. Depending on the application, the\n+ * meaning of these vectors may vary and the semantics of the rotation also.</p>\n+ * <p>For example in an spacecraft attitude simulation tool, users will often\n+ * consider the vectors are fixed (say the Earth direction for example) and the\n+ * rotation transforms the coordinates coordinates of this vector in inertial\n+ * frame into the coordinates of the same vector in satellite frame. In this\n+ * case, the rotation implicitely defines the relation between the two frames.\n+ * Another example could be a telescope control application, where the rotation\n+ * would transform the sighting direction at rest into the desired observing\n+ * direction when the telescope is pointed towards an object of interest. In this\n+ * case the rotation transforms the directionf at rest in a topocentric frame\n+ * into the sighting direction in the same topocentric frame. In many case, both\n+ * approaches will be combined, in our telescope example, we will probably also\n+ * need to transform the observing direction in the topocentric frame into the\n+ * observing direction in inertial frame taking into account the observatory\n+ * location and the Earth rotation.</p>\n+\n+ * <p>These examples show that a rotation is what the user wants it to be, so this\n+ * class does not push the user towards one specific definition and hence does not\n+ * provide methods like <code>projectVectorIntoDestinationFrame</code> or\n+ * <code>computeTransformedDirection</code>. It provides simpler and more generic\n+ * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link\n+ * #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n+\n+ * <p>Since a rotation is basically a vectorial operator, several rotations can be\n+ * composed together and the composite operation <code>r = r<sub>1</sub> o\n+ * r<sub>2</sub></code> (which means that for each vector <code>u</code>,\n+ * <code>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</code>) is also a rotation. Hence\n+ * we can consider that in addition to vectors, a rotation can be applied to other\n+ * rotations as well (or to itself). With our previous notations, we would say we\n+ * can apply <code>r<sub>1</sub></code> to <code>r<sub>2</sub></code> and the result\n+ * we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the\n+ * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and\n+ * {@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n+\n+ * <p>Rotations are guaranteed to be immutable objects.</p>\n \n  * @version $Id: Rotation.java 1705 2006-09-17 19:57:39Z luc $\n  * @author L. Maisonobe\n \n  */\n \n-public class Rotation\n-  implements ArraySliceMappable, Serializable {\n+public class Rotation implements Serializable {\n \n   /** Build the identity rotation.\n    */\n     q1 = 0;\n     q2 = 0;\n     q3 = 0;\n-  }\n-\n-  /** Build a rotation from the quaternion coordinates.\n-   * @param q0 scalar part of the quaternion\n-   * @param q1 first coordinate of the vectorial part of the quaternion\n-   * @param q2 second coordinate of the vectorial part of the quaternion\n-   * @param q3 third coordinate of the vectorial part of the quaternion\n-   * @deprecated since Mantissa 6.3, this method as been deprecated as it\n-   * does not properly handles non-normalized quaternions, it should be\n-   * replaced by {@link #Rotation(double, double, double, double, boolean)}\n-   */\n-  public Rotation(double q0, double q1, double q2, double q3) {\n-    this.q0 = q0;\n-    this.q1 = q1;\n-    this.q2 = q2;\n-    this.q3 = q3;\n   }\n \n   /** Build a rotation from the quaternion coordinates.\n    * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n    * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n    * the constructor can normalize it in a preprocessing step.</p>\n-   * <p>This method replaces the {@link #Rotation(double, double,\n-   * double, double) constructor using only 4 doubles} which was deprecated\n-   * as of version 6.3 of Mantissa.</p>\n    * @param q0 scalar part of the quaternion\n    * @param q1 first coordinate of the vectorial part of the quaternion\n    * @param q2 second coordinate of the vectorial part of the quaternion\n   /** Build a rotation from a 3X3 matrix.\n \n    * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n-   * (which are matrices for which m.mT = I) with real\n+   * (which are matrices for which m.m<sup>T</sup> = I) with real\n    * coefficients. The module of the determinant of unit matrices is\n    * 1, among the orthogonal 3X3 matrices, only the ones having a\n    * positive determinant (+1) are rotation matrices.</p>\n \n   /** Build the rotation that transforms a pair of vector into another pair.\n \n-   * <p>Except for possible scale factors, if the instance were\n-   * applied to the pair (u1, u2) it will produce the pair (v1,\n-   * v2).</p>\n-\n-   * <p>If the angular separation between u1 and u2 is not the same as\n-   * the angular separation between v1 and v2, then a corrected v2'\n-   * will be used rather than v2, the corrected vector will be in the\n-   * (v1, v2) plane.</p>\n+   * <p>Except for possible scale factors, if the instance were applied to\n+   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n+   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n+\n+   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n+   * not the same as the angular separation between v<sub>1</sub> and\n+   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n+   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n+   * v<sub>2</sub>) plane.</p>\n \n    * @param u1 first vector of the origin pair\n    * @param u2 second vector of the origin pair\n    * rotations are three successive rotations around the canonical\n    * axes X, Y and Z, the first and last rotations beeing around the\n    * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n-   * YZY, ZXZ and ZYZ), the most popular one being ZXZ. Beware that\n-   * many people routinely use the term Euler angles even for what\n-   * really are Cardan angles (this confusion is especially widespread\n-   * in the aerospace business where Roll, Pitch and Yaw angles are\n-   * often tagged as Euler angles).</p>\n+   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n+   * <p>Beware that many people routinely use the term Euler angles even\n+   * for what really are Cardan angles (this confusion is especially\n+   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n+   * are often tagged as Euler angles).</p>\n \n    * @param order order of rotations to use\n    * @param alpha1 angle of the first elementary rotation\n    */\n   public Rotation(RotationOrder order,\n                   double alpha1, double alpha2, double alpha3) {\n-\n-    if (order == RotationOrder.XYZ) {\n-\n-      compose(new Rotation(Vector3D.plusI, alpha1),\n-              new Rotation(Vector3D.plusJ, alpha2),\n-              new Rotation(Vector3D.plusK, alpha3));\n-\n-    } else if (order == RotationOrder.XZY) {\n-\n-      compose(new Rotation(Vector3D.plusI, alpha1),\n-              new Rotation(Vector3D.plusK, alpha2),\n-              new Rotation(Vector3D.plusJ, alpha3));\n-\n-    } else if (order == RotationOrder.YXZ) {\n-\n-      compose(new Rotation(Vector3D.plusJ, alpha1),\n-              new Rotation(Vector3D.plusI, alpha2),\n-              new Rotation(Vector3D.plusK, alpha3));\n-\n-    } else if (order == RotationOrder.YZX) {\n-\n-      compose(new Rotation(Vector3D.plusJ, alpha1),\n-              new Rotation(Vector3D.plusK, alpha2),\n-              new Rotation(Vector3D.plusI, alpha3));\n-\n-    } else if (order == RotationOrder.ZXY) {\n-\n-      compose(new Rotation(Vector3D.plusK, alpha1),\n-              new Rotation(Vector3D.plusI, alpha2),\n-              new Rotation(Vector3D.plusJ, alpha3));\n-\n-    } else if (order == RotationOrder.ZYX) {\n-\n-      compose(new Rotation(Vector3D.plusK, alpha1),\n-              new Rotation(Vector3D.plusJ, alpha2),\n-              new Rotation(Vector3D.plusI, alpha3));\n-\n-    } else if (order == RotationOrder.XYX) {\n-\n-      compose(new Rotation(Vector3D.plusI, alpha1),\n-              new Rotation(Vector3D.plusJ, alpha2),\n-              new Rotation(Vector3D.plusI, alpha3));\n-\n-    } else if (order == RotationOrder.XZX) {\n-\n-      compose(new Rotation(Vector3D.plusI, alpha1),\n-              new Rotation(Vector3D.plusK, alpha2),\n-              new Rotation(Vector3D.plusI, alpha3));\n-\n-    } else if (order == RotationOrder.YXY) {\n-\n-      compose(new Rotation(Vector3D.plusJ, alpha1),\n-              new Rotation(Vector3D.plusI, alpha2),\n-              new Rotation(Vector3D.plusJ, alpha3));\n-\n-    } else if (order == RotationOrder.YZY) {\n-\n-      compose(new Rotation(Vector3D.plusJ, alpha1),\n-              new Rotation(Vector3D.plusK, alpha2),\n-              new Rotation(Vector3D.plusJ, alpha3));\n-\n-    } else if (order == RotationOrder.ZXZ) {\n-\n-      compose(new Rotation(Vector3D.plusK, alpha1),\n-              new Rotation(Vector3D.plusI, alpha2),\n-              new Rotation(Vector3D.plusK, alpha3));\n-\n-    } else { // last possibility is ZYZ\n-\n-      compose(new Rotation(Vector3D.plusK, alpha1),\n-              new Rotation(Vector3D.plusJ, alpha2),\n-              new Rotation(Vector3D.plusK, alpha3));\n-\n-    }\n-\n-  }\n-\n-  /** Override the instance by the composition of three rotations.\n-   * @param r1 last (outermost) rotation to compose\n-   * @param r2 intermediate rotation to compose\n-   * @param r3 first (innermost) rotation to compose\n-   */\n-  private void compose(Rotation r1, Rotation r2, Rotation r3) {\n-    Rotation composed = r1.applyTo(r2.applyTo(r3));\n-    q0 = composed.q0;\n-    q1 = composed.q1;\n-    q2 = composed.q2;\n-    q3 = composed.q3;\n+    this(computeRotation(order, alpha1, alpha2, alpha3));\n   }\n \n   /** Copy constructor.\n-   * Build a copy of a rotation\n+   * <p>This constructor is used only for the sake of Cardan/Euler\n+   * angles handling.</p>\n    * @param r rotation to copy\n    */\n-  public Rotation(Rotation r) {\n+  private Rotation(Rotation r) {\n     q0 = r.q0;\n     q1 = r.q1;\n     q2 = r.q2;\n     q3 = r.q3;\n+  }\n+\n+  /** Build a rotation from three Cardan or Euler elementary rotations.\n+   * @param order order of rotations to use\n+   * @param alpha1 angle of the first elementary rotation\n+   * @param alpha2 angle of the second elementary rotation\n+   * @param alpha3 angle of the third elementary rotation\n+   */\n+  public static Rotation computeRotation(RotationOrder order,\n+\t\t                                 double alpha1,\n+\t\t                                 double alpha2,\n+\t\t                                 double alpha3) {\n+    if (order == RotationOrder.XYZ) {\n+      return compose(new Rotation(Vector3D.plusI, alpha1),\n+                     new Rotation(Vector3D.plusJ, alpha2),\n+                     new Rotation(Vector3D.plusK, alpha3));\n+    } else if (order == RotationOrder.XZY) {\n+      return compose(new Rotation(Vector3D.plusI, alpha1),\n+                     new Rotation(Vector3D.plusK, alpha2),\n+                     new Rotation(Vector3D.plusJ, alpha3));\n+    } else if (order == RotationOrder.YXZ) {\n+      return compose(new Rotation(Vector3D.plusJ, alpha1),\n+                     new Rotation(Vector3D.plusI, alpha2),\n+                     new Rotation(Vector3D.plusK, alpha3));\n+    } else if (order == RotationOrder.YZX) {\n+      return compose(new Rotation(Vector3D.plusJ, alpha1),\n+                     new Rotation(Vector3D.plusK, alpha2),\n+                     new Rotation(Vector3D.plusI, alpha3));\n+    } else if (order == RotationOrder.ZXY) {\n+      return compose(new Rotation(Vector3D.plusK, alpha1),\n+                     new Rotation(Vector3D.plusI, alpha2),\n+                     new Rotation(Vector3D.plusJ, alpha3));\n+    } else if (order == RotationOrder.ZYX) {\n+     return compose(new Rotation(Vector3D.plusK, alpha1),\n+                    new Rotation(Vector3D.plusJ, alpha2),\n+                    new Rotation(Vector3D.plusI, alpha3));\n+    } else if (order == RotationOrder.XYX) {\n+     return compose(new Rotation(Vector3D.plusI, alpha1),\n+                    new Rotation(Vector3D.plusJ, alpha2),\n+                    new Rotation(Vector3D.plusI, alpha3));\n+    } else if (order == RotationOrder.XZX) {\n+     return compose(new Rotation(Vector3D.plusI, alpha1),\n+                    new Rotation(Vector3D.plusK, alpha2),\n+                    new Rotation(Vector3D.plusI, alpha3));\n+    } else if (order == RotationOrder.YXY) {\n+     return compose(new Rotation(Vector3D.plusJ, alpha1),\n+                    new Rotation(Vector3D.plusI, alpha2),\n+                    new Rotation(Vector3D.plusJ, alpha3));\n+    } else if (order == RotationOrder.YZY) {\n+     return compose(new Rotation(Vector3D.plusJ, alpha1),\n+                    new Rotation(Vector3D.plusK, alpha2),\n+                    new Rotation(Vector3D.plusJ, alpha3));\n+    } else if (order == RotationOrder.ZXZ) {\n+     return compose(new Rotation(Vector3D.plusK, alpha1),\n+                    new Rotation(Vector3D.plusI, alpha2),\n+                    new Rotation(Vector3D.plusK, alpha3));\n+    } else { // last possibility is ZYZ\n+     return compose(new Rotation(Vector3D.plusK, alpha1),\n+                    new Rotation(Vector3D.plusJ, alpha2),\n+                    new Rotation(Vector3D.plusK, alpha3));\n+    }\n+  }\n+\n+  /** Override the instance by the composition of three rotations.\n+   * @param r3 last (outermost) rotation to compose\n+   * @param r2 intermediate rotation to compose\n+   * @param r1 first (innermost) rotation to compose\n+   */\n+  private static Rotation compose(Rotation r3, Rotation r2, Rotation r1) {\n+    return r3.applyTo(r2.applyTo(r1));\n   }\n \n   /** Revert a rotation.\n    * of the instance\n    */\n   public Rotation revert() {\n-    return new Rotation(-q0, q1, q2, q3);\n+    return new Rotation(-q0, q1, q2, q3, false);\n   }\n \n   /** Get the scalar coordinate of the quaternion.\n   }\n \n   /** Get the angle of the rotation.\n-   * @return angle of the rotation (between 0 and PI)\n+   * @return angle of the rotation (between 0 and &pi;)\n    */\n   public double getAngle() {\n     if ((q0 < -0.1) || (q0 > 0.1)) {\n \n    * <p>The equations show that each rotation can be defined by two\n    * different values of the Cardan or Euler angles set. For example\n-   * if Cardan angles are used, the rotation defined by the angles a1,\n-   * a2 and a3 is the same as the rotation defined by the angles PI +\n-   * a1, PI - a2 and PI + a3. This method implements the following\n-   * arbitrary choices. For Cardan angles, the chosen set is the one\n-   * for which the second angle is between -PI/2 and PI/2 (i.e its\n-   * cosine is positive). For Euler angles, the chosen set is the one\n-   * for which the second angle is between 0 and PI (i.e its sine is\n-   * positive).</p>\n+   * if Cardan angles are used, the rotation defined by the angles\n+   * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n+   * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n+   * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n+   * the following arbitrary choices. For Cardan angles, the chosen\n+   * set is the one for which the second angle is between -&pi;/2 and\n+   * &pi;/2 (i.e its cosine is positive). For Euler angles, the chosen\n+   * set is the one for which the second angle is between 0 and &pi;\n+   * (i.e its sine is positive).</p>\n \n    * <p>Cardan and Euler angle have a very disappointing drawback: all\n    * of them have singularities. This means that if the instance is\n    * rotation order, it will be impossible to retrieve the angles. For\n    * Cardan angles, this is often called gimbal lock. There is\n    * <em>nothing</em> to do to prevent this, it is an intrisic problem\n-   * of Cardan and Euler representation (but not a problem with the\n+   * with Cardan and Euler representation (but not a problem with the\n    * rotation itself, which is perfectly well defined). For Cardan\n    * angles, singularities occur when the second angle is close to\n-   * -PI/2 or +PI/2, for Euler angle singularities occur when the\n-   * second angle is close to 0 or PI, this means that the identity\n-   * rotation is always singular for Euler angles !\n+   * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n+   * second angle is close to 0 or &pi;, this implies that the identity\n+   * rotation is always singular for Euler angles!\n \n    * @param order rotation order to use\n    * @return an array of three angles, in the order specified by the set\n     return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                         r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                         r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n-                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1));\n+                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n   }\n \n   /** Apply the inverse of the instance to another rotation.\n     return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                         -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                         -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n-                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1));\n+                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n   }\n \n   /** Perfect orthogonality on a 3X3 matrix.\n                                           });\n   }\n \n-  public int getStateDimension() {\n-    return 4;\n-  }\n-    \n-  public void mapStateFromArray(int start, double[] array) {\n-    q0 = array[start];\n-    q1 = array[start + 1];\n-    q2 = array[start + 2];\n-    q3 = array[start + 3];\n-  }\n-\n-  public void mapStateToArray(int start, double[] array) {\n-    array[start]     = q0;\n-    array[start + 1] = q1;\n-    array[start + 2] = q2;\n-    array[start + 3] = q3;\n-  }\n-\n   /** Scalar coordinate of the quaternion. */\n-  private double q0;\n+  private final double q0;\n \n   /** First coordinate of the vectorial part of the quaternion. */\n-  private double q1;\n+  private final double q1;\n \n   /** Second coordinate of the vectorial part of the quaternion. */\n-  private double q2;\n+  private final double q2;\n \n   /** Third coordinate of the vectorial part of the quaternion. */\n-  private double q3;\n+  private final double q3;\n \n   private static final long serialVersionUID = 7264384082212242475L;\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/geometry/Vector3D.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/geometry/Vector3D.java\n package org.spaceroots.mantissa.geometry;\n \n import java.io.Serializable;\n-import org.spaceroots.mantissa.utilities.ArraySliceMappable;\n \n \n /** This class implements vectors in a three-dimensional space.\n+ * <p>Vector3D are guaranteed to be immutable objects.</p>\n  * @version $Id: Vector3D.java 1705 2006-09-17 19:57:39Z luc $\n  * @author L. Maisonobe\n  */\n-\n-public class Vector3D\n-  implements ArraySliceMappable, Serializable {\n-\n-  /** First canonical vector (coordinates : 1, 0, 0).\n-   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n-   * hence it can't be changed in any way.\n-   */\n-  public static final Vector3D plusI = new ImmutableVector3D(1, 0, 0);\n-\n-  /** Opposite of the first canonical vector (coordinates : -1, 0, 0).\n-   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n-   * hence it can't be changed in any way.\n-   */\n-  public static final Vector3D minusI = new ImmutableVector3D(-1, 0, 0);\n-\n-  /** Second canonical vector (coordinates : 0, 1, 0).\n-   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n-   * hence it can't be changed in any way.\n-   */\n-  public static final Vector3D plusJ = new ImmutableVector3D(0, 1, 0);\n-\n-  /** Opposite of the second canonical vector (coordinates : 0, -1, 0).\n-   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n-   * hence it can't be changed in any way.\n-   */\n-  public static final Vector3D minusJ = new ImmutableVector3D(0, -1, 0);\n-\n-  /** Third canonical vector (coordinates : 0, 0, 1).\n-   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n-   * hence it can't be changed in any way.\n-   */\n-  public static final Vector3D plusK = new ImmutableVector3D(0, 0, 1);\n-\n-  /** Opposite of the third canonical vector (coordinates : 0, 0, -1).\n-   * This is really an {@link ImmutableVector3D ImmutableVector3D},\n-   * hence it can't be changed in any way.\n-   */\n-  public static final Vector3D minusK = new ImmutableVector3D(0, 0, -1);\n+public class Vector3D implements Serializable {\n+\n+  /** First canonical vector (coordinates : 1, 0, 0). */\n+  public static final Vector3D plusI = new Vector3D(1, 0, 0);\n+\n+  /** Opposite of the first canonical vector (coordinates : -1, 0, 0). */\n+  public static final Vector3D minusI = new Vector3D(-1, 0, 0);\n+\n+  /** Second canonical vector (coordinates : 0, 1, 0). */\n+  public static final Vector3D plusJ = new Vector3D(0, 1, 0);\n+\n+  /** Opposite of the second canonical vector (coordinates : 0, -1, 0). */\n+  public static final Vector3D minusJ = new Vector3D(0, -1, 0);\n+\n+  /** Third canonical vector (coordinates : 0, 0, 1). */\n+  public static final Vector3D plusK = new Vector3D(0, 0, 1);\n+\n+  /** Opposite of the third canonical vector (coordinates : 0, 0, -1). */\n+  public static final Vector3D minusK = new Vector3D(0, 0, -1);\n \n   /** Simple constructor.\n    * Build a null vector.\n    * @param c third scale factor\n    * @param w third base (unscaled) vector\n    */\n-  public Vector3D(double a, Vector3D u,\n-                  double b, Vector3D v,\n+  public Vector3D(double a, Vector3D u, double b, Vector3D v,\n                   double c, Vector3D w) {\n     this.x = a * u.x + b * v.x + c * w.x;\n     this.y = a * u.y + b * v.y + c * w.y;\n     this.z = a * u.z + b * v.z + c * w.z;\n   }\n \n-  /** Copy constructor.\n-   * Build a copy of a vector\n-   * @param v vector to copy\n-   */\n-  public Vector3D(Vector3D v) {\n-    x = v.x;\n-    y = v.y;\n-    z = v.z;\n-  }\n-\n-  /** Reset the instance.\n-   * @param v vector to copy data from\n-   */\n-  public void reset(Vector3D v) {\n-    x = v.x;\n-    y = v.y;\n-    z = v.z;\n+  /** Linear constructor\n+   * Build a vector from four other ones and corresponding scale factors.\n+   * The vector built will be a * t +  b * u + c * v + d * w\n+   * @param a first scale factor\n+   * @param t first base (unscaled) vector\n+   * @param b second scale factor\n+   * @param u second base (unscaled) vector\n+   * @param c third scale factor\n+   * @param v third base (unscaled) vector\n+   * @param d third scale factor\n+   * @param w third base (unscaled) vector\n+   */\n+  public Vector3D(double a, Vector3D t, double b, Vector3D u,\n+                  double c, Vector3D v, double d, Vector3D w) {\n+    this.x = a * t.x + b * u.x + c * v.x + d * w.x;\n+    this.y = a * t.y + b * u.y + c * v.y + d * w.y;\n+    this.z = a * t.z + b * u.z + c * v.z + d * w.z;\n   }\n \n   /** Get the abscissa of the vector.\n     return x;\n   }\n \n-  /** Set the abscissa of the vector.\n-   * @param x new abscissa for the vector\n-   * @see #getX()\n-   * @see #setCoordinates(double, double, double)\n-   */\n-  public void setX(double x) {\n-    this.x = x;\n-  }\n-\n   /** Get the ordinate of the vector.\n    * @return ordinate of the vector\n    * @see #Vector3D(double, double, double)\n     return y;\n   }\n \n-  /** Set the ordinate of the vector.\n-   * @param y new ordinate for the vector\n-   * @see #getY()\n-   * @see #setCoordinates(double, double, double)\n-   */\n-  public void setY(double y) {\n-    this.y = y;\n-  }\n-\n   /** Get the height of the vector.\n    * @return height of the vector\n    * @see #Vector3D(double, double, double)\n     return z;\n   }\n \n-  /** Set the height of the vector.\n-   * @param z new height for the vector\n-   * @see #getZ()\n-   * @see #setCoordinates(double, double, double)\n-   */\n-  public void setZ(double z) {\n-    this.z = z;\n-  }\n-\n-  /** Set all coordinates of the vector.\n-   * @param x new abscissa for the vector\n-   * @param y new ordinate for the vector\n-   * @param z new height for the vector\n-   * @see #Vector3D(double, double, double)\n-   */\n-  public void setCoordinates(double x, double y, double z) {\n-    this.x = x;\n-    this.y = y;\n-    this.z = z;\n-  }\n-\n   /** Get the norm for the vector.\n    * @return euclidian norm for the vector\n    */\n     return Math.asin(z / getNorm());\n   }\n \n-  /** Add a vector to the instance.\n-   * Add a vector to the instance. The instance is changed.\n-   * @param v vector to add\n-   */\n-  public void addToSelf(Vector3D v) {\n-    x += v.x;\n-    y += v.y;\n-    z += v.z;\n-  }\n-\n-  /** Add a scaled vector to the instance.\n-   * Add a scaled vector to the instance. The instance is changed.\n-   * @param factor scale factor to apply to v before adding it\n-   * @param v vector to add\n-   */\n-  public void addToSelf(double factor, Vector3D v) {\n-    x += factor * v.x;\n-    y += factor * v.y;\n-    z += factor * v.z;\n+  /** Normalize a vector.\n+    * @param v vector to normalize\n+   * @return a new vector equal to v / ||v||\n+   * @exception ArithmeticException if the norm of the instance is null\n+   */\n+  public static Vector3D normalize(Vector3D v) {\n+\tdouble norm = v.getNorm();\n+\tif (norm == 0) {\n+      throw new ArithmeticException(\"null norm\");\n+\t}\n+\tdouble inv = 1.0 / norm;\n+\treturn new Vector3D(inv * v.x, inv * v.y, inv * v.z);\n   }\n \n   /** Add two vectors.\n     return new Vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n   }\n \n-  /** Subtract a vector from the instance.\n-   * Subtract a vector from the instance. The instance is changed.\n-   * @param v vector to subtract\n-   */\n-  public void subtractFromSelf(Vector3D v) {\n-    x -= v.x;\n-    y -= v.y;\n-    z -= v.z;\n-  }\n-\n   /** Subtract two vectors.\n    * Subtract two vectors and return the difference as a new vector\n    * @param v1 first vector\n    */\n   public static Vector3D subtract(Vector3D v1, Vector3D v2) {\n     return new Vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n-  }\n-\n-  /** Normalize the instance.\n-   * Divide the instance by its norm in order to have a unit\n-   * vector. The instance is changed.\n-   * @exception ArithmeticException if the norm is null\n-   */\n-  public void normalizeSelf() {\n-    double s = getNorm();\n-    if (s == 0) {\n-      throw new ArithmeticException(\"null norm\");\n-    }\n-    double invNorm = 1 / s;\n-    x *= invNorm;\n-    y *= invNorm;\n-    z *= invNorm;\n   }\n \n   /** Get a vector orthogonal to the instance.\n    * following example shows how to build a frame having the k axis\n    * aligned with the known vector u :\n    * <pre><code>\n-   *   Vector3D k = u;\n-   *   k.normalizeSelf();\n+   *   Vector3D k = Vector3D.normalize(u);\n    *   Vector3D i = k.orthogonal();\n    *   Vector3D j = Vector3D.crossProduct(k, i);\n    * </code></pre></p>\n \n   }\n \n-  /** Revert the instance.\n-   * Replace the instance u by -u\n-   */\n-  public void negateSelf() {\n-    x = -x;\n-    y = -y;\n-    z = -z;\n-  }\n-\n   /** Get the opposite of a vector.\n    * @param u vector to revert\n    * @return a new vector which is -u\n    */\n   public static Vector3D negate(Vector3D u) {\n     return new Vector3D(-u.x, -u.y, -u.z);\n-  }\n-\n-  /** Multiply the instance by a scalar\n-   * Multiply the instance by a scalar. The instance is changed.\n-   * @param a scalar by which the instance should be multiplied\n-   */\n-  public void multiplySelf(double a) {\n-    x *= a;\n-    y *= a;\n-    z *= a;\n   }\n \n   /** Multiply a vector by a scalar\n     return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n   }\n \n-  /** Set the instance to the result of the cross-product of two vectors.\n-   * @param v1 first vector (can be the instance)\n-   * @param v2 second vector (can be the instance)\n-   */\n-  public void setToCrossProduct(Vector3D v1, Vector3D v2) {\n-    double newX = v1.y * v2.z - v1.z * v2.y;\n-    double newY = v1.z * v2.x - v1.x * v2.z;\n-    z = v1.x * v2.y - v1.y * v2.x;\n-    x = newX;\n-    y = newY;\n-  }\n-\n   /** Compute the cross-product of two vectors.\n    * @param v1 first vector\n    * @param v2 second vector\n                         v1.x * v2.y - v1.y * v2.x);\n   }\n \n-  public int getStateDimension() {\n-    return 3;\n-  }\n-    \n-  public void mapStateFromArray(int start, double[] array) {\n-    x = array[start];\n-    y = array[start + 1];\n-    z = array[start + 2];\n-  }\n-\n-  public void mapStateToArray(int start, double[] array) {\n-    array[start]     = x;\n-    array[start + 1] = y;\n-    array[start + 2] = z;\n-  }\n-\n   /** Abscissa. */\n-  protected double x;\n+  private final double x;\n \n   /** Ordinate. */\n-  protected double y;\n+  private final double y;\n \n   /** Height. */\n-  protected double z;\n-\n-   private static final long serialVersionUID = 4115635019045864211L;\n+  private final double z;\n+\n+  private static final long serialVersionUID = 484345009325358136L;\n \n }\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegrator.java\n         interpolator.storeTime(currentT);\n         handler.handleStep(interpolator, lastStep);\n \n-        switchesHandler.reset(currentT, y);\n+        if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+          // some switching function has triggered changes that\n+          // invalidate the derivatives, we need to recompute them\n+          firstStepAlreadyComputed = false;\n+        }\n \n         int optimalIter;\n         if (k == 1) {\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/RungeKuttaFehlbergIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/RungeKuttaFehlbergIntegrator.java\n         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n       }\n \n-      switchesHandler.reset(currentT, y);\n+      if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+        // some switching function has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(currentT, y, yDotK[0]);\n+      }\n \n       if (! lastStep) {\n         // stepsize control for next step\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/RungeKuttaIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/RungeKuttaIntegrator.java\n         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n       }\n \n-      switchesHandler.reset(currentT, y);\n+      if (switchesHandler.reset(currentT, y) && ! lastStep) {\n+        // some switching function has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(currentT, y, yDotK[0]);\n+      }\n \n       if (needUpdate) {\n         // a switching function has changed the step\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchState.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchState.java\n    * beginning of the next step\n    * @param y array were to put the desired state vector at the beginning\n    * of the next step\n-   */\n-  public void reset(double t, double[] y) {\n-    if (pendingEvent) {\n-      if (nextAction == SwitchingFunction.RESET) {\n-        function.resetState(t, y);\n-      }\n-      pendingEvent      = false;\n-      pendingEventTime  = Double.NaN;\n-    }\n+   * @return true if the integrator should reset the derivatives too\n+   */\n+  public boolean reset(double t, double[] y) {\n+\n+    if (! pendingEvent) {\n+      return false;\n+    }\n+\n+    if (nextAction == SwitchingFunction.RESET_STATE) {\n+      function.resetState(t, y);\n+    }\n+    pendingEvent      = false;\n+    pendingEventTime  = Double.NaN;\n+\n+    return (nextAction == SwitchingFunction.RESET_STATE)\n+        || (nextAction == SwitchingFunction.RESET_DERIVATIVES);\n+\n   }\n \n   /** Get the value of the g function at the specified time.\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunction.java\n  * <p>A switching function allows to handle discrete events in\n  * integration problems. These events occur for example when the\n  * integration process should be stopped as some value is reached\n- * (G-stop facility), or when the derivatives has\n- * discontinuities. These events are traditionally defined as\n- * occurring when a <code>g</code> function sign changes.</p>\n+ * (G-stop facility), or when the derivatives have\n+ * discontinuities, or simply when the user wants to monitor some\n+ * states boundaries crossings. These events are traditionally defined\n+ * as occurring when a <code>g</code> function sign changes, hence\n+ * the name <em>switching functions</em>.</p>\n  *\n  * <p>Since events are only problem-dependent and are triggered by the\n  * independant <i>time</i> variable and the state vector, they can\n- * occur at virtually any time. The integrators will take care to\n- * avoid sign changes inside the steps, they will reduce the step size\n- * when such an event is detected in order to put this event exactly\n- * at the end of the current step. This guarantees that step\n- * interpolation (which always has a one step scope) is relevant even\n- * in presence of discontinuities. This is independent from the\n+ * occur at virtually any time, unknown in advance. The integrators will\n+ * take care to avoid sign changes inside the steps, they will reduce\n+ * the step size when such an event is detected in order to put this\n+ * event exactly at the end of the current step. This guarantees that\n+ * step interpolation (which always has a one step scope) is relevant\n+ * even in presence of discontinuities. This is independent from the\n  * stepsize control provided by integrators that monitor the local\n  * error (this feature is available on all integrators, including\n  * fixed step ones).</p>\n    */\n   public static final int STOP = 0;\n \n-  /** Reset indicator.\n+  /** Reset state indicator.\n    * <p>This value should be used as the return value of the {@link\n    * #eventOccurred eventOccurred} method when the integration should\n    * go on after the event ending the current step, with a new state\n-   * vector (which will be retrieved through the {@link #resetState\n+   * vector (which will be retrieved thanks to the {@link #resetState\n    * resetState} method).</p>\n    */\n-  public static final int RESET = 1;\n+  public static final int RESET_STATE = 1;\n+\n+  /** Reset derivatives indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new derivatives\n+   * vector (which will be retrieved thanks to the {@link\n+   * FirstOrderDifferentialEquations#computeDerivatives} method).</p>\n+   */\n+  public static final int RESET_DERIVATIVES = 2;\n \n   /** Continue indicator.\n    * <p>This value should be used as the return value of the {@link\n    * #eventOccurred eventOccurred} method when the integration should go\n    * on after the event ending the current step.</p>\n    */\n-  public static final int CONTINUE = 2;\n+  public static final int CONTINUE = 3;\n \n   /** Compute the value of the switching function.\n \n    * <p>Discrete events are generated when the sign of this function\n    * changes, the integrator will take care to change the stepsize in\n    * such a way these events occur exactly at step boundaries. This\n-   * function must be continuous, as the integrator will need to find\n-   * its roots to locate the events.</p>\n+   * function must be continuous (at least in its roots neighborhood),\n+   * as the integrator will need to find its roots to locate the events.</p>\n \n    * @param t current value of the independant <i>time</i> variable\n    * @param y array containing the current value of the state vector\n    * ending exactly on a sign change of the function, just before the\n    * step handler itself is called. It allows the user to update his\n    * internal data to acknowledge the fact the event has been handled\n-   * (for example setting a flag to switch the derivatives computation\n-   * in case of discontinuity), and it allows to direct the integrator\n-   * to either stop or continue integration, possibly with a reset\n-   * state.</p>\n+   * (for example setting a flag in the {@link\n+   * FirstOrderDifferentialEquations differential equations} to switch\n+   * the derivatives computation in case of discontinuity), or to\n+   * direct the integrator to either stop or continue integration,\n+   * possibly with a reset state or derivatives.</p>\n \n-   * <p>If {@link #STOP} is returned, the step handler will be called\n-   * with the <code>isLast</code> flag of the {@link\n-   * StepHandler#handleStep handleStep} method set to true. If {@link\n-   * #RESET} is returned, the {@link #resetState resetState} method\n-   * will be called once the step handler has finished its task.</p>\n+   * <ul>\n+   *   <li>if {@link #STOP} is returned, the step handler will be called\n+   *   with the <code>isLast</code> flag of the {@link\n+   *   StepHandler#handleStep handleStep} method set to true and the\n+   *   integration will be stopped,</li>\n+   *   <li>if {@link #RESET_STATE} is returned, the {@link #resetState\n+   *   resetState} method will be called once the step handler has\n+   *   finished its task, and the integrator will also recompute the\n+   *   derivatives,</li>\n+   *   <li>if {@link #RESET_DERIVATIVES} is returned, the integrator\n+   *   will recompute the derivatives,\n+   *   <li>if {@link #CONTINUE} is returned, no specific action will\n+   *   be taken (apart from having called this method) and integration\n+   *   will continue.</li>\n+   * </ul>\n \n    * @param t current value of the independant <i>time</i> variable\n    * @param y array containing the current value of the state vector\n    * @return indication of what the integrator should do next, this\n-   * value must be one of {@link #STOP}, {@link #RESET} or {@link\n-   * #CONTINUE}\n+   * value must be one of {@link #STOP}, {@link #RESET_STATE},\n+   * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n    */\n   public int eventOccurred(double t, double[] y);\n   \n \n    * <p>This method is called after the step handler has returned and\n    * before the next step is started, but only when {@link\n-   * #eventOccurred} has itself returned the {@link #RESET}\n+   * #eventOccurred} has itself returned the {@link #RESET_STATE}\n    * indicator. It allows the user to reset the state vector for the\n    * next step, without perturbing the step handler of the finishing\n    * step. If the {@link #eventOccurred} never returns the {@link\n-   * #RESET} indicator, this function will never be called, and it is\n+   * #RESET_STATE} indicator, this function will never be called, and it is\n    * safe to leave its body empty.</p>\n \n    * @param t current value of the independant <i>time</i> variable\n--- a/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunctionsHandler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/ode/SwitchingFunctionsHandler.java\n    * beginning of the next step\n    * @param y array were to put the desired state vector at the beginning\n    * of the next step\n+   * @return true if the integrator should reset the derivatives too\n    */\n-  public void reset(double t, double[] y) {\n+  public boolean reset(double t, double[] y) {\n+    boolean resetDerivatives = false;\n     for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-      ((SwitchState) iter.next()).reset(t, y);\n+      if (((SwitchState) iter.next()).reset(t, y)) {\n+        resetDerivatives = true;\n+      }\n     }\n+    return resetDerivatives;\n   }\n \n   /** Switching functions. */\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/AllTests.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/AllTests.java\n     TestSuite suite = new TestSuite(\"org.spaceroots.mantissa.geometry\"); \n \n     suite.addTest(Vector3DTest.suite());\n-    suite.addTest(ImmutableVector3DTest.suite());\n     suite.addTest(RotationTest.suite());\n \n     return suite; \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/ImmutableVector3DTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/ImmutableVector3DTest.java\n-// Licensed to the Apache Software Foundation (ASF) under one\n-// or more contributor license agreements.  See the NOTICE file\n-// distributed with this work for additional information\n-// regarding copyright ownership.  The ASF licenses this file\n-// to you under the Apache License, Version 2.0 (the\n-// \"License\"); you may not use this file except in compliance\n-// with the License.  You may obtain a copy of the License at\n-// \n-//   http://www.apache.org/licenses/LICENSE-2.0\n-// \n-// Unless required by applicable law or agreed to in writing,\n-// software distributed under the License is distributed on an\n-// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-// KIND, either express or implied.  See the License for the\n-// specific language governing permissions and limitations\n-// under the License.\n-\n-package org.spaceroots.mantissa.geometry;\n-\n-import junit.framework.*;\n-\n-public class ImmutableVector3DTest\n-  extends TestCase {\n-\n-  public ImmutableVector3DTest(String name) {\n-    super(name);\n-  }\n-\n-  public void testCanonical() {\n-    try {\n-      Vector3D.plusK.normalizeSelf();\n-      fail(\"an exception should have been thrown\");\n-    } catch (UnsupportedOperationException uoe) {\n-    } catch (Exception e) {\n-      fail (\"wrong exception caught\");\n-    }\n-  }\n-  \n-  public static Test suite() {\n-    return new TestSuite(ImmutableVector3DTest.class);\n-  }\n-\n-}\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/Vector3DTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/geometry/Vector3DTest.java\n \n     Vector3D v1 = new Vector3D(1, 2, 3);\n     Vector3D v2 = new Vector3D(-3, -2, -1);\n-    v1.subtractFromSelf(v2);\n+    v1 = Vector3D.subtract(v1, v2);\n     checkVector(v1, new Vector3D(4, 4, 4));\n \n     checkVector(Vector3D.subtract(v2, v1), new Vector3D(-7, -6, -5));\n   public void testAdd() {\n     Vector3D v1 = new Vector3D(1, 2, 3);\n     Vector3D v2 = new Vector3D(-3, -2, -1);\n-    v1.addToSelf(v2);\n+    v1 = Vector3D.add(v1, v2);\n     checkVector(v1, new Vector3D(-2, 0, 2));\n \n     checkVector(Vector3D.add(v2, v1), new Vector3D(-5, -2, 1));\n \n   public void testScalarProduct() {\n     Vector3D v = new Vector3D(1, 2, 3);\n-    v.multiplySelf(3);\n+    v = Vector3D.multiply(3, v);\n     checkVector(v, new Vector3D(3, 6, 9));\n \n     checkVector(Vector3D.multiply(0.5, v), new Vector3D(1.5, 3, 4.5));\n   public void testAngularSeparation() {\n     Vector3D v1 = new Vector3D(2, -1, 4);\n \n-    Vector3D  k = v1;\n-    k.normalizeSelf();\n+    Vector3D  k = Vector3D.normalize(v1);\n     Vector3D  i = k.orthogonal();\n \n-    Vector3D v2 = Vector3D.multiply(Math.cos(1.2), k);\n-    v2.addToSelf(Vector3D.multiply(Math.sin(1.2), i));\n+    Vector3D v2 = new Vector3D(Math.cos(1.2), k, Math.sin(1.2), i);\n \n     assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n \n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince853IntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/DormandPrince853IntegratorTest.java\n \n   }\n \n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(DormandPrince853IntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GillIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GillIntegratorTest.java\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n   }\n \n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ = new GillIntegrator(0.3);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(GillIntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegratorTest.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/GraggBulirschStoerIntegratorTest.java\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n   }\n \n+  public void testUnstableDerivative()\n+    throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addSwitchingFunction(stepProblem, 1.0, 1.0e-12);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(GraggBulirschStoerIntegratorTest.class);\n   }\n--- a/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem4.java\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/TestProblem4.java\n     public int eventOccurred(double t, double[] y) {\n       // this sign change is needed because the state will be reset soon\n       sign = -sign;\n-      return SwitchingFunction.RESET;\n+      return SwitchingFunction.RESET_STATE;\n     }\n   \n     public void resetState(double t, double[] y) {", "timestamp": 1164255433, "metainfo": ""}