{"sha": "583dffc0ee383e9b5e1e08c574de10db8270fdb7", "log": "The root solvers now take the function to solve as a parameter to the solve methods, thus allowing to reuse the same solver for different functions.  JIRA:MATH-218  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n       \"taille de vecteur invalide : {0} au lieu de {1} attendue\" },\n     { \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n       \"dimensions incoh\\u00e9rentes : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n-\n-    // org.apache.commons.math.linear.BigMatrixImpl\n-    // org.apache.commons.math.linear.RealMatrixImpl\n     { \"matrix must have at least one row\",\n       \"une matrice doit comporter au moins une ligne\" },\n     { \"matrix must have at least one column\",\n       \"une matrice doit comporter au moins une colonne\" },\n     { \"some rows have length {0} while others have length {1}\",\n       \"certaines ligne ont une longueur de {0} alors que d''autres ont une longueur de {1}\" },\n+\n+    // org.apache.commons.math.linear.BigMatrixImpl\n+    // org.apache.commons.math.linear.RealMatrixImpl\n     { \"row index {0} out of allowed range [{1}, {2}]\",\n       \"index de ligne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n     { \"column index {0} out of allowed range [{1}, {2}]\",\n    { \"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n      \"division par z\\u00e9ro caus\\u00e9e par les abscisses identiques x[{0}] == x[{1}] == {2}\" },\n \n+   // org.apache.commons.math.analysis.UnivariateRealSolverImpl\n+   { \"function to solve cannot be null\",\n+     \"la fonction \\u00e0 r\\u00e9soudre ne peux pas \\u00eatre nulle\" },\n+\n+   // org.apache.commons.math.analysis.LaguerreSolver\n+   { \"function is not polynomial\",\n+     \"la fonction n''est pas p\\u00f4lynomiale\" },\n+\n+   // org.apache.commons.math.analysis.NewtonSolver\n+   { \"function is not differentiable\",\n+     \"la fonction n''est pas diff\\u00e9rentiable\" },\n+\n    // org.apache.commons.math.fraction.Fraction\n    { \"zero denominator in fraction {0}/{1}\",\n      \"d\\u00e9nominateur null dans le nombre rationnel {0}/{1}\" },\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n public class BisectionSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 4963578633786538912L;\n+    private static final long serialVersionUID = 5227509383222989438L;\n \n     /**\n      * Construct a solver for the given function.\n      * \n      * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n      */\n+    @Deprecated\n     public BisectionSolver(UnivariateRealFunction f) {\n         super(f, 100, 1E-6);\n     }\n \n     /**\n-     * Find a zero in the given interval.\n+     * Construct a solver.\n      * \n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @param initial the start value to use (ignored).\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException the maximum iteration count is exceeded \n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     *  the function\n-     * @throws IllegalArgumentException if min is not less than max\n      */\n+    public BisectionSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public double solve(double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-          \n+        return solve(f, min, max);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n         return solve(min, max);\n     }\n-    \n-    /**\n-     * Find a zero root in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if min is not less than max\n-     */\n-    public double solve(double min, double max) throws MaxIterationsExceededException,\n-        FunctionEvaluationException {\n-        \n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+            \n         clearResult();\n         verifyInterval(min,max);\n         double m;\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n public class BrentSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -2136672307739067002L;\n+    private static final long serialVersionUID = 7694577816772532779L;\n \n     /**\n      * Construct a solver for the given function.\n      * \n      * @param f function to solve.\n-     */\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n     public BrentSolver(UnivariateRealFunction f) {\n         super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public BrentSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n     }\n \n     /**\n      * allowed to have endpoints with the same sign if the initial point has\n      * opposite sign function-wise).</p>\n      * \n+     * @param f function to solve.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @param initial the start value to use (must be set to min if no\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(double min, double max, double initial)\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         if (((initial - min) * (max -initial)) < 0) {\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n-            return solve(min, yMin, initial, yInitial, min, yMin);\n+            return solve(f, min, yMin, initial, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(initial, yInitial, max, yMax, initial, yInitial);\n+            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n         // full Brent algorithm starting with provided initial guess\n-        return solve(min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n     \n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, \n         FunctionEvaluationException {\n         \n         clearResult();\n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n-            ret = solve(min, yMin, max, yMax, min, yMin);\n+            ret = solve(f, min, yMin, max, yMax, min, yMin);\n         } else {\n             // either min or max is a root\n             if (yMin == 0.0) {\n         \n     /**\n      * Find a zero starting search according to the three provided points.\n+     * @param f the function to solve\n      * @param x0 old approximation for the root\n      * @param y0 function value at the approximation for the root\n      * @param x1 last calculated approximation for the root\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function \n      */\n-    private double solve(double x0, double y0,\n+    private double solve(final UnivariateRealFunction f,\n+                         double x0, double y0,\n                          double x1, double y1,\n                          double x2, double y2)\n     throws MaxIterationsExceededException, FunctionEvaluationException {\n--- a/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.complex.Complex;\n \n     /** serializable version identifier */\n     private static final long serialVersionUID = -3775334783473775723L;\n \n-    /** polynomial function to solve */\n+    /** polynomial function to solve.\n+     * @deprecated as of 2.0 the function is not stored anymore in the instance\n+     */\n+    @Deprecated\n     private PolynomialFunction p;\n \n     /**\n      *\n      * @param f function to solve\n      * @throws IllegalArgumentException if function is not polynomial\n-     */\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n     public LaguerreSolver(UnivariateRealFunction f) throws\n         IllegalArgumentException {\n-\n         super(f, 100, 1E-6);\n         if (f instanceof PolynomialFunction) {\n-            p = (PolynomialFunction)f;\n+            p = (PolynomialFunction) f;\n         } else {\n-            throw new IllegalArgumentException(\"Function is not polynomial.\");\n-        }\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\", null);\n+        }\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public LaguerreSolver() {\n+        super(100, 1E-6);\n     }\n \n     /**\n      * Returns a copy of the polynomial function.\n      * \n      * @return a fresh copy of the polynomial function\n-     */\n+     * @deprecated as of 2.0 the function is not stored anymore within the instance.\n+     */\n+    @Deprecated\n     public PolynomialFunction getPolynomialFunction() {\n         return new PolynomialFunction(p.getCoefficients());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(p, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(p, min, max, initial);\n     }\n \n     /**\n      * <p>\n      * Requires bracketing condition.</p>\n      * \n+     * @param f function to solve (must be polynomial)\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @param initial the start value to use\n      * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double solve(double min, double max, double initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n \n         // check for zeros before verifying bracketing\n-        if (p.value(min) == 0.0) { return min; }\n-        if (p.value(max) == 0.0) { return max; }\n-        if (p.value(initial) == 0.0) { return initial; }\n-\n-        verifyBracketing(min, max, p);\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n         verifySequence(min, initial, max);\n-        if (isBracketing(min, initial, p)) {\n-            return solve(min, initial);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(f, min, initial);\n         } else {\n-            return solve(initial, max);\n-        }\n+            return solve(f, initial, max);\n+        }\n+\n     }\n \n     /**\n      * another initial value, or, as we did here, call solveAll() to obtain\n      * all roots and pick up the one that we're looking for.</p>\n      *\n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the point at which the function value is zero\n      * function \n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double solve(double min, double max) throws ConvergenceException, \n-        FunctionEvaluationException {\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+\n+        // check function type\n+        if (!(f instanceof PolynomialFunction)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\", null);\n+        }\n \n         // check for zeros before verifying bracketing\n-        if (p.value(min) == 0.0) { return min; }\n-        if (p.value(max) == 0.0) { return max; }\n-        verifyBracketing(min, max, p);\n-\n-        double coefficients[] = p.getCoefficients();\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        double coefficients[] = ((PolynomialFunction) f).getCoefficients();\n         Complex c[] = new Complex[coefficients.length];\n         for (int i = 0; i < coefficients.length; i++) {\n             c[i] = new Complex(coefficients[i], 0.0);\n--- a/src/java/org/apache/commons/math/analysis/MullerSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/MullerSolver.java\n  */\n package org.apache.commons.math.analysis;\n \n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.util.MathUtils;\n public class MullerSolver extends UnivariateRealSolverImpl {\n \n     /** serializable version identifier */\n-    private static final long serialVersionUID = 6552227503458976920L;\n+    private static final long serialVersionUID = 7768903775784754323L;\n \n     /**\n      * Construct a solver for the given function.\n      * \n      * @param f function to solve\n-     */\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n     public MullerSolver(UnivariateRealFunction f) {\n         super(f, 100, 1E-6);\n     }\n \n     /**\n+     * Construct a solver.\n+     */\n+    public MullerSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n      * Find a real root in the given interval with initial value.\n      * <p>\n      * Requires bracketing condition.</p>\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @param initial the start value to use\n      * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double solve(double min, double max, double initial) throws\n-        MaxIterationsExceededException, FunctionEvaluationException {\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         // check for zeros before verifying bracketing\n         if (f.value(min) == 0.0) { return min; }\n         verifyBracketing(min, max, f);\n         verifySequence(min, initial, max);\n         if (isBracketing(min, initial, f)) {\n-            return solve(min, initial);\n+            return solve(f, min, initial);\n         } else {\n-            return solve(initial, max);\n+            return solve(f, initial, max);\n         }\n     }\n \n      * <p>\n      * The formulas here use divided differences directly.</p>\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the point at which the function value is zero\n      * function \n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         // [x0, x2] is the bracketing interval in each iteration\n         // x1 is the last approximation and an interpolation point in (x0, x2)\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function \n      * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve2(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n+     * @deprecated replaced by {@link #solve2(UnivariateRealFunction, double, double)\n+     * since 2.0\n+     */\n+    @Deprecated\n+    public double solve2(final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve2(f, min, max);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * solve2() differs from solve() in the way it avoids complex operations.\n+     * Except for the initial [min, max], solve2() does not require bracketing\n+     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+     * number arises in the computation, we simply use its modulus as real\n+     * approximation.</p>\n+     * <p>\n+     * Because the interval may not be bracketing, bisection alternative is\n+     * not applicable here. However in practice our treatment usually works\n+     * well, especially near real zeros where the imaginary part of complex\n+     * approximation is often negligible.</p>\n+     * <p>\n+     * The formulas here do not use divided differences directly.</p>\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve2(final UnivariateRealFunction f,\n+                         final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         // x2 is the last root approximation\n         // x is the new approximation and new x2 for next round\n--- a/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n \n package org.apache.commons.math.analysis;\n \n-import java.io.IOException;\n-import org.apache.commons.math.FunctionEvaluationException; \n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n public class NewtonSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 2067325783137941016L;\n+    private static final long serialVersionUID = 7579593514004764309L;\n \n-    /** The first derivative of the target function. */\n-    private transient UnivariateRealFunction derivative;\n-    \n     /**\n      * Construct a solver for the given function.\n      * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n      */\n+    @Deprecated\n     public NewtonSolver(DifferentiableUnivariateRealFunction f) {\n         super(f, 100, 1E-6);\n-        derivative = f.derivative();\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public NewtonSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws MaxIterationsExceededException, \n+        FunctionEvaluationException  {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException  {\n+        return solve(f, min, max, startValue);\n     }\n \n     /**\n      * function or derivative\n      * @throws IllegalArgumentException if min is not less than max\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException  {\n-        return solve(min, max, UnivariateRealSolverUtils.midpoint(min, max));\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException  {\n+        return solve(f, min, max, UnivariateRealSolverUtils.midpoint(min, max));\n     }\n \n     /**\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function or derivative\n-     * @throws IllegalArgumentException if startValue is not between min and max\n+     * @throws IllegalArgumentException if startValue is not between min and max or\n+     * if function is not a {@link DifferentiableUnivariateRealFunction} instance\n      */\n-    public double solve(double min, double max, double startValue)\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double startValue)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        \n-        clearResult();\n-        verifySequence(min, startValue, max);\n \n-        double x0 = startValue;\n-        double x1;\n-        \n-        int i = 0;\n-        while (i < maximalIterationCount) {\n-            x1 = x0 - (f.value(x0) / derivative.value(x0));\n-            if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n-                \n-                setResult(x1, i);\n-                return x1;\n+        try {\n+\n+            final UnivariateRealFunction derivative =\n+                ((DifferentiableUnivariateRealFunction) f).derivative();\n+            clearResult();\n+            verifySequence(min, startValue, max);\n+\n+            double x0 = startValue;\n+            double x1;\n+\n+            int i = 0;\n+            while (i < maximalIterationCount) {\n+\n+                x1 = x0 - (f.value(x0) / derivative.value(x0));\n+                if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n+                    setResult(x1, i);\n+                    return x1;\n+                }\n+\n+                x0 = x1;\n+                ++i;\n             }\n-            \n-            x0 = x1;\n-            ++i;\n+\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n+        } catch (ClassCastException cce) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not differentiable\",\n+                                                                      null);\n         }\n-        \n-        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n     \n-    /**\n-     * Custom deserialization to initialize transient deriviate field.\n-     * \n-     * @param in serialized object input stream\n-     * @throws IOException if IO error occurs \n-     * @throws ClassNotFoundException if instantiation error occurs\n-     */\n-    private void readObject(java.io.ObjectInputStream in)\n-    throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        derivative = ((DifferentiableUnivariateRealFunction) f).derivative();\n-    }    \n }\n--- a/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n  */\n package org.apache.commons.math.analysis;\n \n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.util.MathUtils;\n public class RiddersSolver extends UnivariateRealSolverImpl {\n \n     /** serializable version identifier */\n-    private static final long serialVersionUID = -4703139035737911735L;\n+    private static final long serialVersionUID = -1556464494585337088L;\n \n     /**\n      * Construct a solver for the given function.\n      * \n      * @param f function to solve\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n      */\n+    @Deprecated\n     public RiddersSolver(UnivariateRealFunction f) {\n         super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public RiddersSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n     }\n \n     /**\n      * <p>\n      * Requires bracketing condition.</p>\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @param initial the start value to use\n      * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double solve(double min, double max, double initial) throws\n-        MaxIterationsExceededException, FunctionEvaluationException {\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         // check for zeros before verifying bracketing\n         if (f.value(min) == 0.0) { return min; }\n         verifyBracketing(min, max, f);\n         verifySequence(min, initial, max);\n         if (isBracketing(min, initial, f)) {\n-            return solve(min, initial);\n+            return solve(f, min, initial);\n         } else {\n-            return solve(initial, max);\n+            return solve(f, initial, max);\n         }\n     }\n \n      * <p>\n      * Requires bracketing condition.</p>\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the point at which the function value is zero\n      * function \n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         // [x1, x2] is the bracketing interval in each iteration\n         // x3 is the midpoint of [x1, x2]\n--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n \n public class SecantSolver extends UnivariateRealSolverImpl implements Serializable {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 1984971194738974867L;\n+    private static final long serialVersionUID = 2477470651270304246L;\n \n     /**\n      * Construct a solver for the given function.\n      * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n      */\n+    @Deprecated\n     public SecantSolver(UnivariateRealFunction f) {\n         super(f, 100, 1E-6);\n     }\n \n     /**\n+     * Construct a solver.\n+     */\n+    public SecantSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n      * Find a zero in the given interval.\n      * \n+     * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @param initial the start value to use (ignored)\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max, double initial)\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-            \n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n     \n     /**\n      * Find a zero in the given interval.\n+     * @param f the function to solve\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n         \n         clearResult();\n         verifyInterval(min, max);\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n      * function\n      * @throws IllegalArgumentException if min > max or the endpoints do not\n      * satisfy the requirements specified by the solver\n-     */\n+     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double)\n+     * since 2.0\n+     */\n+    @Deprecated\n     double solve(double min, double max) throws ConvergenceException, \n         FunctionEvaluationException;\n \n     /**\n+     * Solve for a zero root in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * \n+     * @param f the function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the solver\n+     * @since 2.0\n+     */\n+    double solve(UnivariateRealFunction f, double min, double max)\n+        throws ConvergenceException, \n+        FunctionEvaluationException;\n+\n+    /**\n      * Solve for a zero in the given interval, start at startValue.\n      * A solver may require that the interval brackets a single zero root.\n      * \n      * function\n      * @throws IllegalArgumentException if min > max or the arguments do not\n      * satisfy the requirements specified by the solver\n-     */\n+     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double, double)\n+     * since 2.0\n+     */\n+    @Deprecated\n     double solve(double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Solve for a zero in the given interval, start at startValue.\n+     * A solver may require that the interval brackets a single zero root.\n+     * \n+     * @param f the function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the solver\n+     * @since 2.0\n+     */\n+    double solve(UnivariateRealFunction f, double min, double max, double startValue)\n         throws ConvergenceException, FunctionEvaluationException;\n \n     /**\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n  * Common usage:<pre>\n  * SolverFactory factory = UnivariateRealSolverFactory.newInstance();</p>\n  *\n- * // create a Brent solver to use with a UnivariateRealFunction f\n- * BrentSolver solver = factory.newBrentSolver(f);\n+ * // create a Brent solver to use\n+ * BrentSolver solver = factory.newBrentSolver();\n  * </pre>\n  *\n  * @version $Revision$ $Date$\n     }\n     \n     /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * Create a new {@link UnivariateRealSolver}.  The\n      * actual solver returned is determined by the underlying factory.\n-     * @param f the function.\n      * @return the new solver.\n      */\n-    public abstract UnivariateRealSolver newDefaultSolver(\n-        UnivariateRealFunction f);\n+    public abstract UnivariateRealSolver newDefaultSolver();\n     \n     /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of the bisection method.\n-     * @param f the function.\n      * @return the new solver.\n      */\n-    public abstract UnivariateRealSolver newBisectionSolver(\n-        UnivariateRealFunction f);\n+    public abstract UnivariateRealSolver newBisectionSolver();\n     \n     /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of the Brent method.\n-     * @param f the function.\n      * @return the new solver.\n      */\n-    public abstract UnivariateRealSolver newBrentSolver(\n-        UnivariateRealFunction f);\n+    public abstract UnivariateRealSolver newBrentSolver();\n     \n     /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of Newton's Method.\n-     * @param f the function.\n      * @return the new solver.\n      */\n-    public abstract UnivariateRealSolver newNewtonSolver(\n-        DifferentiableUnivariateRealFunction f);\n+    public abstract UnivariateRealSolver newNewtonSolver();\n     \n     /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n+     * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of the secant method.\n-     * @param f the function.\n      * @return the new solver.\n      */\n-    public abstract UnivariateRealSolver newSecantSolver(\n-        UnivariateRealFunction f);\n+    public abstract UnivariateRealSolver newSecantSolver();\n+\n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImpl.java\n     public UnivariateRealSolverFactoryImpl() {\n     }\n \n-    /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n-     * actual solver returned is determined by the underlying factory.\n-     * \n-     * This factory returns a {@link BrentSolver} instance.\n-     *\n-     * @param f the function.\n-     * @return the new solver.\n-     */\n-    public UnivariateRealSolver newDefaultSolver(UnivariateRealFunction f) {\n-        return newBrentSolver(f);\n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newDefaultSolver() {\n+        return newBrentSolver();\n     }\n     \n-    /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n-     * solver is an implementation of the bisection method.\n-     * @param f the function.\n-     * @return the new solver.\n-     */\n-    public UnivariateRealSolver newBisectionSolver(UnivariateRealFunction f) {\n-        return new BisectionSolver(f);\n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newBisectionSolver() {\n+        return new BisectionSolver();\n     }\n \n-    /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n-     * solver is an implementation of the Brent method.\n-     * @param f the function.\n-     * @return the new solver.\n-     */\n-    public UnivariateRealSolver newBrentSolver(UnivariateRealFunction f) {\n-        return new BrentSolver(f);\n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newBrentSolver() {\n+        return new BrentSolver();\n     }\n     \n-    /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n-     * solver is an implementation of Newton's Method.\n-     * @param f the function.\n-     * @return the new solver.\n-     */\n-    public UnivariateRealSolver newNewtonSolver(\n-        DifferentiableUnivariateRealFunction f) {\n-        \n-        return new NewtonSolver(f);\n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newNewtonSolver() {\n+        return new NewtonSolver();\n     }\n     \n-    /**\n-     * Create a new {@link UnivariateRealSolver} for the given function.  The\n-     * solver is an implementation of the secant method.\n-     * @param f the function.\n-     * @return the new solver.\n-     */\n-    public UnivariateRealSolver newSecantSolver(UnivariateRealFunction f) {\n-        return new SecantSolver(f);\n+    /** {@inheritDoc} */\n+    public UnivariateRealSolver newSecantSolver() {\n+        return new SecantSolver();\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n     /** The last iteration count. */\n     protected int iterationCount;\n \n-    /** The function to solve. */\n+    /** The function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method. */\n+    @Deprecated\n     protected UnivariateRealFunction f;\n \n     /**\n      * @param defaultMaximalIterationCount maximum number of iterations\n      * @throws IllegalArgumentException if f is null or the \n      * defaultAbsoluteAccuracy is not valid\n-     */\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n     protected UnivariateRealSolverImpl(\n         UnivariateRealFunction f,\n         int defaultMaximalIterationCount,\n         double defaultAbsoluteAccuracy) {\n         \n-        super();\n-        \n         if (f == null) {\n-            throw new IllegalArgumentException(\"function can not be null.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\",\n+                                                                      null);\n         }\n-        \n         this.f = f;\n+\n+        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.defaultRelativeAccuracy = 1E-14;\n+        this.defaultFunctionValueAccuracy = 1E-15;\n+        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * \n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected UnivariateRealSolverImpl(int defaultMaximalIterationCount,\n+                                       double defaultAbsoluteAccuracy) {\n         this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n         this.defaultRelativeAccuracy = 1E-14;\n         this.defaultFunctionValueAccuracy = 1E-15;\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n     public static double solve(UnivariateRealFunction f, double x0, double x1)\n     throws ConvergenceException, FunctionEvaluationException {\n         setup(f);\n-        return factory.newDefaultSolver(f).solve(x0, x1);\n+        return factory.newDefaultSolver().solve(f, x0, x1);\n     }\n \n     /**\n             FunctionEvaluationException {    \n        \n         setup(f);\n-        UnivariateRealSolver solver = factory.newDefaultSolver(f);\n+        UnivariateRealSolver solver = factory.newDefaultSolver();\n         solver.setAbsoluteAccuracy(absoluteAccuracy);\n-        return solver.solve(x0, x1);\n+        return solver.solve(f, x0, x1);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/analysis/BisectionSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/BisectionSolverTest.java\n  * @version $Revision$ $Date$\n  */\n public final class BisectionSolverTest extends TestCase {\n-    /**\n-     *\n-     */\n-    public void testSinZero() throws MathException {\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n         \n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n     }\n \n-    /**\n-     *\n-     */\n-    public void testQuinticZero() throws MathException {\n+    public void testSinZero() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        result = solver.solve(f, 3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+\n+   public void testQuinticZero() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n         double result;\n \n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        result = solver.solve(-0.2, 0.2);\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(-0.1, 0.3);\n+        result = solver.solve(f, -0.1, 0.3);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(-0.3, 0.45);\n+        result = solver.solve(f, -0.3, 0.45);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.3, 0.7);\n+        result = solver.solve(f, 0.3, 0.7);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.2, 0.6);\n+        result = solver.solve(f, 0.2, 0.6);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.05, 0.95);\n+        result = solver.solve(f, 0.05, 0.95);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.85, 1.25);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(0.8, 1.2);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(0.85, 1.75);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(0.55, 1.45);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(0.85, 5);\n+        result = solver.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 5);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         \n         assertEquals(result, solver.getResult(), 0);\n      */\n     public void testSetFunctionValueAccuracy(){\n         double expected = 1.0e-2;    \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         solver.setFunctionValueAccuracy(expected);\n         assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);\n     }        \n      */\n     public void testResetFunctionValueAccuracy(){\n         double newValue = 1.0e-2;    \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         double oldValue = solver.getFunctionValueAccuracy();\n         solver.setFunctionValueAccuracy(newValue);\n         solver.resetFunctionValueAccuracy();\n      */\n     public void testSetAbsoluteAccuracy(){\n         double expected = 1.0e-2; \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         solver.setAbsoluteAccuracy(expected);\n         assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); \n     }        \n      */\n     public void testResetAbsoluteAccuracy(){\n         double newValue = 1.0e-2;       \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         double oldValue = solver.getAbsoluteAccuracy();\n         solver.setAbsoluteAccuracy(newValue);\n         solver.resetAbsoluteAccuracy();\n      */\n     public void testSetMaximalIterationCount(){\n         int expected = 100;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         solver.setMaximalIterationCount(expected);\n         assertEquals(expected, solver.getMaximalIterationCount());\n     }        \n      */\n     public void testResetMaximalIterationCount(){\n         int newValue = 10000;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         int oldValue = solver.getMaximalIterationCount();\n         solver.setMaximalIterationCount(newValue);\n         solver.resetMaximalIterationCount();\n      */\n     public void testSetRelativeAccuracy(){\n         double expected = 1.0e-2;\n-        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         solver.setRelativeAccuracy(expected);\n         assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);\n     }        \n      */\n     public void testResetRelativeAccuracy(){\n         double newValue = 1.0e-2;        \n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new BisectionSolver(f);\n+        UnivariateRealSolver solver = new BisectionSolver();\n         double oldValue = solver.getRelativeAccuracy();\n         solver.setRelativeAccuracy(newValue);\n         solver.resetRelativeAccuracy();\n        UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n        double result;\n        \n-       BisectionSolver solver = new BisectionSolver(f);\n+       BisectionSolver solver = new BisectionSolver();\n        UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);\n        \n-       result = solver.solve(-0.2, 0.2);\n+       result = solver.solve(f, -0.2, 0.2);\n        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(-0.1, 0.3);\n+       assertEquals(solver2.solve(f, -0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, -0.1, 0.3);\n        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(-0.3, 0.45);\n+       assertEquals(solver2.solve(f, -0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, -0.3, 0.45);\n        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.3, 0.7);\n+       assertEquals(solver2.solve(f, -0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.3, 0.7);\n        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.2, 0.6);\n+       assertEquals(solver2.solve(f, 0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.2, 0.6);\n        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.05, 0.95);\n+       assertEquals(solver2.solve(f, 0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.05, 0.95);\n        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.85, 1.25);\n-       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.8, 1.2);\n-       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.85, 1.75);\n-       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.55, 1.45);\n-       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n-       \n-       result = solver.solve(0.85, 5);\n-       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-       assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.85, 1.25);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.8, 1.2);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.85, 1.75);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.55, 1.45);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.85, 5);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.85, 5), result, solver2.getAbsoluteAccuracy());\n        \n        /* Test Reset */\n        double newValue = 1.0e-2;\n        f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n-       solver = new BisectionSolver(f);\n+       solver = new BisectionSolver();\n        \n        double oldValue = solver.getRelativeAccuracy();\n        solver.setRelativeAccuracy(newValue);\n--- a/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n         return suite;\n     }\n \n-    public void testSinZero() throws MathException {\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n         // The sinus function is behaved well around the root at #pi. The second\n         // order derivative is zero, which means linar approximating methods will\n         // still converge quadratically. \n         assertEquals(result, solver.getResult(), 0);\n     }\n \n-    public void testQuinticZero() throws MathException {\n+    public void testSinZero() throws MathException {\n+        // The sinus function is behaved well around the root at #pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically. \n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new BrentSolver();\n+        // Somewhat benign interval. The function is monotone.\n+        result = solver.solve(f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        // Larger and somewhat less benign interval. The function is grows first.\n+        result = solver.solve(f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        solver = new SecantSolver();\n+        result = solver.solve(f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        result = solver.solve(f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        assertEquals(result, solver.getResult(), 0);\n+    }\n+\n+   public void testQuinticZero() throws MathException {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // Around the root of 0 the function is well behaved, with a second derivative\n         // of zero a 0.\n         UnivariateRealFunction f = new QuinticFunction();\n         double result;\n         // Brent-Dekker solver.\n-        UnivariateRealSolver solver = new BrentSolver(f);\n+        UnivariateRealSolver solver = new BrentSolver();\n         // Symmetric bracket around 0. Test whether solvers can handle hitting\n         // the root in the first iteration.\n-        result = solver.solve(-0.2, 0.2);\n+        result = solver.solve(f, -0.2, 0.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         assertTrue(solver.getIterationCount() <= 2);\n         // 1 iterations on i586 JDK 1.4.1.\n         // Asymmetric bracket around 0, just for fun. Contains extremum.\n-        result = solver.solve(-0.1, 0.3);\n+        result = solver.solve(f, -0.1, 0.3);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         // 5 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 6);\n         // Large bracket around 0. Contains two extrema.\n-        result = solver.solve(-0.3, 0.45);\n+        result = solver.solve(f, -0.3, 0.45);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         // 6 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 7);\n         // Benign bracket around 0.5, function is monotonous.\n-        result = solver.solve(0.3, 0.7);\n+        result = solver.solve(f, 0.3, 0.7);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         // 6 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 7);\n         // Less benign bracket around 0.5, contains one extremum.\n-        result = solver.solve(0.2, 0.6);\n+        result = solver.solve(f, 0.2, 0.6);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         // 6 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 7);\n         // Large, less benign bracket around 0.5, contains both extrema.\n-        result = solver.solve(0.05, 0.95);\n+        result = solver.solve(f, 0.05, 0.95);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         assertTrue(solver.getIterationCount() <= 9);\n         // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1\n         // is still a problem.\n-        result = solver.solve(0.85, 1.25);\n+        result = solver.solve(f, 0.85, 1.25);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         // 8 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 9);\n         // Less benign bracket around 1 with extremum.\n-        result = solver.solve(0.8, 1.2);\n+        result = solver.solve(f, 0.8, 1.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         // 8 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 9);\n         // Large bracket around 1. Monotonous.\n-        result = solver.solve(0.85, 1.75);\n+        result = solver.solve(f, 0.85, 1.75);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         // 10 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 11);\n         // Large bracket around 1. Interval contains extremum.\n-        result = solver.solve(0.55, 1.45);\n+        result = solver.solve(f, 0.55, 1.45);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         // 7 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 8);\n         // Very large bracket around 1 for testing fast growth behaviour.\n-        result = solver.solve(0.85, 5);\n+        result = solver.solve(f, 0.85, 5);\n         //System.out.println(\n        //     \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         // 12 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 13);\n         // Secant solver.\n-        solver = new SecantSolver(f);\n-        result = solver.solve(-0.2, 0.2);\n+        solver = new SecantSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         // 1 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 2);\n-        result = solver.solve(-0.1, 0.3);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        // 5 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 6);\n-        result = solver.solve(-0.3, 0.45);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        // 6 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 7);\n-        result = solver.solve(0.3, 0.7);\n+        result = solver.solve(f, -0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        result = solver.solve(f, -0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(f, 0.3, 0.7);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         // 7 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 8);\n-        result = solver.solve(0.2, 0.6);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        // 6 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 7);\n-        result = solver.solve(0.05, 0.95);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        // 8 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 9);\n-        result = solver.solve(0.85, 1.25);\n+        result = solver.solve(f, 0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(f, 0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(f, 0.85, 1.25);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         // 10 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 11);\n-        result = solver.solve(0.8, 1.2);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 8 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 9);\n-        result = solver.solve(0.85, 1.75);\n+        result = solver.solve(f, 0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(f, 0.85, 1.75);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         assertTrue(solver.getIterationCount() <= 15);\n         // The followig is especially slow because the solver first has to reduce\n         // the bracket to exclude the extremum. After that, convergence is rapide.\n-        result = solver.solve(0.55, 1.45);\n+        result = solver.solve(f, 0.55, 1.45);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         // 7 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 8);\n-        result = solver.solve(0.85, 5);\n+        result = solver.solve(f, 0.85, 5);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n     \n     public void testRootEndpoints() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new BrentSolver(f);\n+        UnivariateRealSolver solver = new BrentSolver();\n         \n         // endpoint is root\n-        double result = solver.solve(Math.PI, 4);\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(3, Math.PI);\n+        double result = solver.solve(f, Math.PI, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 3, Math.PI);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n     }\n     \n     public void testBadEndpoints() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new BrentSolver(f);\n+        UnivariateRealSolver solver = new BrentSolver();\n         try {  // bad interval\n-            solver.solve(1, -1);\n+            solver.solve(f, 1, -1);\n             fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {  // no bracket\n-            solver.solve(1, 1.5);\n+            solver.solve(f, 1, 1.5);\n             fail(\"Expecting IllegalArgumentException - non-bracketing\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n     public void testInitialGuess() throws MathException {\n \n         MonitoredFunction f = new MonitoredFunction(new QuinticFunction());\n-        UnivariateRealSolver solver = new BrentSolver(f);\n+        UnivariateRealSolver solver = new BrentSolver();\n         double result;\n \n         // no guess\n-        result = solver.solve(0.6, 7.0);\n+        result = solver.solve(f, 0.6, 7.0);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         int referenceCallsCount = f.getCallsCount();\n         assertTrue(referenceCallsCount >= 13);\n  \n         // invalid guess (it *is* a root, but outside of the range)\n         try {\n-          result = solver.solve(0.6, 7.0, 0.0);\n+          result = solver.solve(f, 0.6, 7.0, 0.0);\n           fail(\"an IllegalArgumentException was expected\");\n         } catch (IllegalArgumentException iae) {\n             // expected behaviour\n  \n         // bad guess\n         f.setCallsCount(0);\n-        result = solver.solve(0.6, 7.0, 0.61);\n+        result = solver.solve(f, 0.6, 7.0, 0.61);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         assertTrue(f.getCallsCount() > referenceCallsCount);\n  \n         // good guess\n         f.setCallsCount(0);\n-        result = solver.solve(0.6, 7.0, 0.999999);\n+        result = solver.solve(f, 0.6, 7.0, 0.999999);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         assertTrue(f.getCallsCount() < referenceCallsCount);\n \n         // perfect guess\n         f.setCallsCount(0);\n-        result = solver.solve(0.6, 7.0, 1.0);\n+        result = solver.solve(f, 0.6, 7.0, 1.0);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         assertEquals(0, solver.getIterationCount());\n         assertEquals(1, f.getCallsCount());\n--- a/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java\n public final class LaguerreSolverTest extends TestCase {\n \n     /**\n-     * Test of solver for the linear function.\n+     * Test deprecated APIs.\n      */\n-    public void testLinearFunction() throws MathException {\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n         double min, max, expected, result, tolerance;\n \n         // p(x) = 4x - 1\n     }\n \n     /**\n+     * Test of solver for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 4x - 1\n+        double coefficients[] = { -1.0, 4.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        min = 0.0; max = 1.0; expected = 0.25;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n      * Test of solver for the quadratic function.\n      */\n     public void testQuadraticFunction() throws MathException {\n         // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)\n         double coefficients[] = { -3.0, 5.0, 2.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n \n         min = 0.0; max = 2.0; expected = 0.5;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -4.0; max = -1.0; expected = -3.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n         // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)\n         double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n \n         min = -2.0; max = 2.0; expected = -1.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -5.0; max = -2.5; expected = -3.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 3.0; max = 6.0; expected = 4.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n \n         // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n         double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n-        PolynomialFunction f = new PolynomialFunction(coefficients);\n-        LaguerreSolver solver = new LaguerreSolver(f);\n+        LaguerreSolver solver = new LaguerreSolver();\n         result = solver.solveAll(coefficients, initial);\n \n         expected = new Complex(0.0, -2.0);\n     public void testParameters() throws Exception {\n         double coefficients[] = { -3.0, 5.0, 2.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n \n         try {\n             // bad interval\n-            solver.solve(1, -1);\n+            solver.solve(f, 1, -1);\n             fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n-            solver.solve(2, 3);\n+            solver.solve(f, 2, 3);\n             fail(\"Expecting IllegalArgumentException - no bracketing\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // bad function\n-            UnivariateRealFunction f2 = new SinFunction();\n-            new LaguerreSolver(f2);\n+            solver.solve(new SinFunction(), -1, 1);\n             fail(\"Expecting IllegalArgumentException - bad function\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n--- a/src/test/org/apache/commons/math/analysis/MullerSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/MullerSolverTest.java\n public final class MullerSolverTest extends TestCase {\n \n     /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated2() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n      * Test of solver for the sine function.\n      */\n     public void testSinFunction() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n+        UnivariateRealSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = Math.PI;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testSinFunction2() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n-        MullerSolver solver = new MullerSolver(f);\n+        MullerSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = Math.PI;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testQuinticFunction() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n+        UnivariateRealSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testQuinticFunction2() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n-        MullerSolver solver = new MullerSolver(f);\n+        MullerSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testExpm1Function() throws MathException {\n         UnivariateRealFunction f = new Expm1Function();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n+        UnivariateRealSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testExpm1Function2() throws MathException {\n         UnivariateRealFunction f = new Expm1Function();\n-        MullerSolver solver = new MullerSolver(f);\n+        MullerSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n+        result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n+        UnivariateRealSolver solver = new MullerSolver();\n \n         try {\n             // bad interval\n-            solver.solve(1, -1);\n+            solver.solve(f, 1, -1);\n             fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n-            solver.solve(2, 3);\n+            solver.solve(f, 2, 3);\n             fail(\"Expecting IllegalArgumentException - no bracketing\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n--- a/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/NewtonSolverTest.java\n  * @version $Revision$ $Date$\n  */\n public final class NewtonSolverTest extends TestCase {\n-    /**\n-     *\n-     */\n-    public void testSinZero() throws MathException {\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n         DifferentiableUnivariateRealFunction f = new SinFunction();\n         double result;\n         \n     }\n \n     /**\n+    *\n+    */\n+   public void testSinZero() throws MathException {\n+       DifferentiableUnivariateRealFunction f = new SinFunction();\n+       double result;\n+       \n+       UnivariateRealSolver solver = new NewtonSolver();\n+       result = solver.solve(f, 3, 4);\n+       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+       result = solver.solve(f, 1, 4);\n+       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+       \n+       //TODO:  create abstract solver test class, move these there\n+       assertEquals(result, solver.getResult(), 0);\n+       assertTrue(solver.getIterationCount() > 0);\n+   }\n+\n+   /**\n      *\n      */\n     public void testQuinticZero() throws MathException {\n         DifferentiableUnivariateRealFunction f = new QuinticFunction();\n         double result;\n \n-        UnivariateRealSolver solver = new BisectionSolver(f);\n-        result = solver.solve(-0.2, 0.2);\n+        UnivariateRealSolver solver = new NewtonSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(-0.1, 0.3);\n+        result = solver.solve(f, -0.1, 0.3);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(-0.3, 0.45);\n+        result = solver.solve(f, -0.3, 0.45);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.3, 0.7);\n+        result = solver.solve(f, 0.3, 0.7);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.2, 0.6);\n+        result = solver.solve(f, 0.2, 0.6);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.05, 0.95);\n+        result = solver.solve(f, 0.05, 0.95);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.85, 1.25);\n+        result = solver.solve(f, 0.85, 1.25);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.8, 1.2);\n+        result = solver.solve(f, 0.8, 1.2);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.85, 1.75);\n+        result = solver.solve(f, 0.85, 1.75);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.55, 1.45);\n+        result = solver.solve(f, 0.55, 1.45);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        result = solver.solve(0.85, 5);\n+        result = solver.solve(f, 0.85, 5);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n     }\n     \n         DifferentiableUnivariateRealFunction f = new QuinticFunction();\n         double result;\n         \n-        NewtonSolver solver = new NewtonSolver(f);\n+        NewtonSolver solver = new NewtonSolver();\n         NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);\n         \n-        result = solver.solve(-0.2, 0.2);\n+        result = solver.solve(f, -0.2, 0.2);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, -0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(-0.1, 0.3);\n+        result = solver.solve(f, -0.1, 0.3);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, -0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(-0.3, 0.45);\n+        result = solver.solve(f, -0.3, 0.45);\n         assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, -0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.3, 0.7);\n+        result = solver.solve(f, 0.3, 0.7);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.2, 0.6);\n+        result = solver.solve(f, 0.2, 0.6);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.05, 0.95);\n+        result = solver.solve(f, 0.05, 0.95);\n         assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.85, 1.25);\n+        result = solver.solve(f, 0.85, 1.25);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.8, 1.2);\n+        result = solver.solve(f, 0.8, 1.2);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.85, 1.75);\n+        result = solver.solve(f, 0.85, 1.75);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.55, 1.45);\n+        result = solver.solve(f, 0.55, 1.45);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n         \n-        result = solver.solve(0.85, 5);\n+        result = solver.solve(f, 0.85, 5);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.85, 5), result, solver2.getAbsoluteAccuracy());\n         \n         /* Test Reset */\n         double newValue = 1.0e-2;\n         f = new QuinticFunction();\n-        solver = new NewtonSolver(f);\n+        solver = new NewtonSolver();\n         \n         double oldValue = solver.getRelativeAccuracy();\n         solver.setRelativeAccuracy(newValue);\n--- a/src/test/org/apache/commons/math/analysis/RiddersSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/RiddersSolverTest.java\n public final class RiddersSolverTest extends TestCase {\n \n     /**\n-     * Test of solver for the sine function.\n+     * Test the deprecated APIs.\n      */\n-    public void testSinFunction() throws MathException {\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new RiddersSolver(f);\n         double min, max, expected, result, tolerance;\n     }\n \n     /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n      * Test of solver for the quintic function.\n      */\n     public void testQuinticFunction() throws MathException {\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n+        UnivariateRealSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testExpm1Function() throws MathException {\n         UnivariateRealFunction f = new Expm1Function();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n+        UnivariateRealSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n+        result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n \n      */\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n+        UnivariateRealSolver solver = new RiddersSolver();\n \n         try {\n             // bad interval\n-            solver.solve(1, -1);\n+            solver.solve(f, 1, -1);\n             fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n-            solver.solve(2, 3);\n+            solver.solve(f, 2, 3);\n             fail(\"Expecting IllegalArgumentException - no bracketing\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n--- a/src/test/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImplTest.java\n+++ b/src/test/org/apache/commons/math/analysis/UnivariateRealSolverFactoryImplTest.java\n     /** solver factory */\n     private UnivariateRealSolverFactory factory;\n     \n-    /** function */\n-    private DifferentiableUnivariateRealFunction function;\n     /**\n      * @throws java.lang.Exception\n      * @see junit.framework.TestCase#tearDown()\n     protected void setUp() throws Exception {\n         super.setUp();\n         factory = new UnivariateRealSolverFactoryImpl();\n-        function = new SinFunction();\n     }\n     \n     /**\n      */\n     protected void tearDown() throws Exception {\n         factory = null;\n-        function = null;\n         super.tearDown();\n     }\n \n-    public void testNewBisectionSolverNull() {\n-        try {\n-            factory.newBisectionSolver(null);\n-            fail();\n-        } catch(IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n     public void testNewBisectionSolverValid() {\n-        UnivariateRealSolver solver = factory.newBisectionSolver(function);\n+        UnivariateRealSolver solver = factory.newBisectionSolver();\n         assertNotNull(solver);\n         assertTrue(solver instanceof BisectionSolver);\n     }\n \n-    public void testNewNewtonSolverNull() {\n-        try {\n-            factory.newNewtonSolver(null);\n-            fail();\n-        } catch(IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n     public void testNewNewtonSolverValid() {\n-        UnivariateRealSolver solver = factory.newNewtonSolver(function);\n+        UnivariateRealSolver solver = factory.newNewtonSolver();\n         assertNotNull(solver);\n         assertTrue(solver instanceof NewtonSolver);\n     }\n \n-    public void testNewBrentSolverNull() {\n-        try {\n-            factory.newBrentSolver(null);\n-            fail();\n-        } catch(IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n     public void testNewBrentSolverValid() {\n-        UnivariateRealSolver solver = factory.newBrentSolver(function);\n+        UnivariateRealSolver solver = factory.newBrentSolver();\n         assertNotNull(solver);\n         assertTrue(solver instanceof BrentSolver);\n     }\n \n-    public void testNewSecantSolverNull() {\n-        try {\n-            factory.newSecantSolver(null);\n-            fail();\n-        } catch(IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-\n     public void testNewSecantSolverValid() {\n-        UnivariateRealSolver solver = factory.newSecantSolver(function);\n+        UnivariateRealSolver solver = factory.newSecantSolver();\n         assertNotNull(solver);\n         assertTrue(solver instanceof SecantSolver);\n     }\n+\n }", "timestamp": 1228681450, "metainfo": ""}