{"sha": "80b1e90b42a34856b61cec628fcea6633d1000cd", "log": "added FastMath and used it everywhere in replacement of java.util.Math the unit tests have not been added yet (waiting for dfp library addition) JIRA: MATH-375  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n \n \n \n         }\n     };\n \n-    /** The {@code Math.pow} method wrapped as a {@link BinaryFunction}. */\n+    /** The {@code FastMath.pow} method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction POW = new BinaryFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double x, double y) {\n-            return Math.pow(x, y);\n+            return FastMath.pow(x, y);\n         }\n     };\n \n-    /** The {@code Math.atan2} method wrapped as a {@link BinaryFunction}. */\n+    /** The {@code FastMath.atan2} method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction ATAN2 = new BinaryFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double x, double y) {\n-            return Math.atan2(x, y);\n+            return FastMath.atan2(x, y);\n         }\n     };\n \n--- a/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n         }\n     };\n \n-    /** The {@code Math.abs} method wrapped as a {@link ComposableFunction}. */\n+    /** The {@code FastMath.abs} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ABS = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.abs(d);\n+            return FastMath.abs(d);\n         }\n     };\n \n         }\n     };\n \n-    /** The {@code Math.sin} method wrapped as a {@link ComposableFunction}. */\n+    /** The {@code FastMath.sin} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SIN = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.sin(d);\n-        }\n-    };\n-\n-    /** The {@code Math.sqrt} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.sin(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.sqrt} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SQRT = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.sqrt(d);\n-        }\n-    };\n-\n-    /** The {@code Math.sinh} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.sqrt(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.sinh} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SINH = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.sinh(d);\n-        }\n-    };\n-\n-    /** The {@code Math.exp} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.sinh(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.exp} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction EXP = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.exp(d);\n-        }\n-    };\n-\n-    /** The {@code Math.expm1} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.exp(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.expm1} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction EXPM1 = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.expm1(d);\n-        }\n-    };\n-\n-    /** The {@code Math.asin} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.expm1(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.asin} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ASIN = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.asin(d);\n-        }\n-    };\n-\n-    /** The {@code Math.atan} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.asin(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.atan} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ATAN = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.atan(d);\n-        }\n-    };\n-\n-    /** The {@code Math.tan} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.atan(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.tan} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction TAN = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.tan(d);\n-        }\n-    };\n-\n-    /** The {@code Math.tanh} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.tan(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.tanh} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction TANH = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.tanh(d);\n-        }\n-    };\n-\n-    /** The {@code Math.cbrt} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.tanh(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.cbrt} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction CBRT = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.cbrt(d);\n-        }\n-    };\n-\n-    /** The {@code Math.ceil} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.cbrt(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.ceil} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction CEIL = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.ceil(d);\n-        }\n-    };\n-\n-    /** The {@code Math.floor} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.ceil(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.floor} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction FLOOR = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.floor(d);\n-        }\n-    };\n-\n-    /** The {@code Math.log} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.floor(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.log} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction LOG = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.log(d);\n-        }\n-    };\n-\n-    /** The {@code Math.log10} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.log(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.log10} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction LOG10 = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.log10(d);\n-        }\n-    };\n-\n-    /** The {@code Math.log1p} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.log10(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.log1p} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction LOG1P = new ComposableFunction () {\n         @Override\n         public double value(double d){\n-            return Math.log1p(d);\n-        }\n-    };\n-\n-    /** The {@code Math.cos} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.log1p(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.cos} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction COS = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.cos(d);\n-        }\n-    };\n-\n-    /** The {@code Math.abs} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.cos(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.abs} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ACOS = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.acos(d);\n-        }\n-    };\n-\n-    /** The {@code Math.cosh} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.acos(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.cosh} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction COSH = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.cosh(d);\n-        }\n-    };\n-\n-    /** The {@code Math.rint} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.cosh(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.rint} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction RINT = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.rint(d);\n-        }\n-    };\n-\n-    /** The {@code Math.signum} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.rint(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.signum} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SIGNUM = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.signum(d);\n-        }\n-    };\n-\n-    /** The {@code Math.ulp} method wrapped as a {@link ComposableFunction}. */\n+            return FastMath.signum(d);\n+        }\n+    };\n+\n+    /** The {@code FastMath.ulp} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ULP = new ComposableFunction() {\n         /** {@inheritDoc} */\n         @Override\n         public double value(double d) {\n-            return Math.ulp(d);\n+            return FastMath.ulp(d);\n         }\n     };\n \n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/Legendre-GaussQuadrature.html\">\n \n     /** Abscissas for the 2 points method. */\n     private static final double[] ABSCISSAS_2 = {\n-        -1.0 / Math.sqrt(3.0),\n-         1.0 / Math.sqrt(3.0)\n+        -1.0 / FastMath.sqrt(3.0),\n+         1.0 / FastMath.sqrt(3.0)\n     };\n \n     /** Weights for the 2 points method. */\n \n     /** Abscissas for the 3 points method. */\n     private static final double[] ABSCISSAS_3 = {\n-        -Math.sqrt(0.6),\n+        -FastMath.sqrt(0.6),\n          0.0,\n-         Math.sqrt(0.6)\n+         FastMath.sqrt(0.6)\n     };\n \n     /** Weights for the 3 points method. */\n \n     /** Abscissas for the 4 points method. */\n     private static final double[] ABSCISSAS_4 = {\n-        -Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0),\n-        -Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0),\n-         Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0),\n-         Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0)\n+        -FastMath.sqrt((15.0 + 2.0 * FastMath.sqrt(30.0)) / 35.0),\n+        -FastMath.sqrt((15.0 - 2.0 * FastMath.sqrt(30.0)) / 35.0),\n+         FastMath.sqrt((15.0 - 2.0 * FastMath.sqrt(30.0)) / 35.0),\n+         FastMath.sqrt((15.0 + 2.0 * FastMath.sqrt(30.0)) / 35.0)\n     };\n \n     /** Weights for the 4 points method. */\n     private static final double[] WEIGHTS_4 = {\n-        (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0,\n-        (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n-        (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n-        (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0\n+        (90.0 - 5.0 * FastMath.sqrt(30.0)) / 180.0,\n+        (90.0 + 5.0 * FastMath.sqrt(30.0)) / 180.0,\n+        (90.0 + 5.0 * FastMath.sqrt(30.0)) / 180.0,\n+        (90.0 - 5.0 * FastMath.sqrt(30.0)) / 180.0\n     };\n \n     /** Abscissas for the 5 points method. */\n     private static final double[] ABSCISSAS_5 = {\n-        -Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0),\n-        -Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0),\n+        -FastMath.sqrt((35.0 + 2.0 * FastMath.sqrt(70.0)) / 63.0),\n+        -FastMath.sqrt((35.0 - 2.0 * FastMath.sqrt(70.0)) / 63.0),\n          0.0,\n-         Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0),\n-         Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0)\n+         FastMath.sqrt((35.0 - 2.0 * FastMath.sqrt(70.0)) / 63.0),\n+         FastMath.sqrt((35.0 + 2.0 * FastMath.sqrt(70.0)) / 63.0)\n     };\n \n     /** Weights for the 5 points method. */\n     private static final double[] WEIGHTS_5 = {\n-        (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0,\n-        (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n+        (322.0 - 13.0 * FastMath.sqrt(70.0)) / 900.0,\n+        (322.0 + 13.0 * FastMath.sqrt(70.0)) / 900.0,\n         128.0 / 225.0,\n-        (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n-        (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0\n+        (322.0 + 13.0 * FastMath.sqrt(70.0)) / 900.0,\n+        (322.0 - 13.0 * FastMath.sqrt(70.0)) / 900.0\n     };\n \n     /** Abscissas for the current method. */\n             final double t = stage(f, min, max, n);\n \n             // estimate error\n-            final double delta = Math.abs(t - oldt);\n+            final double delta = FastMath.abs(t - oldt);\n             final double limit =\n-                Math.max(absoluteAccuracy,\n-                         relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5);\n+                FastMath.max(absoluteAccuracy,\n+                         relativeAccuracy * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n \n             // check convergence\n             if ((i + 1 >= minimalIterationCount) && (delta <= limit)) {\n             }\n \n             // prepare next iteration\n-            double ratio = Math.min(4, Math.pow(delta / limit, 0.5 / abscissas.length));\n-            n = Math.max((int) (ratio * n), n + 1);\n+            double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n+            n = FastMath.max((int) (ratio * n), n + 1);\n             oldt = t;\n \n         }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/RombergIntegration.html\">\n             }\n             final double s = currentRow[i];\n             if (i >= minimalIterationCount) {\n-                final double delta  = Math.abs(s - olds);\n-                final double rLimit = relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;\n+                final double delta  = FastMath.abs(s - olds);\n+                final double rLimit = relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(s, i);\n                     return result;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/SimpsonsRule.html\">\n             final double t = qtrap.stage(f, min, max, i);\n             final double s = (4 * t - oldt) / 3.0;\n             if (i >= minimalIterationCount) {\n-                final double delta = Math.abs(s - olds);\n+                final double delta = FastMath.abs(s - olds);\n                 final double rLimit =\n-                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;\n+                    relativeAccuracy * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(s, i);\n                     return result;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/TrapezoidalRule.html\">\n         for (int i = 1; i <= maximalIterationCount; ++i) {\n             final double t = stage(f, min, max, i);\n             if (i >= minimalIterationCount) {\n-                final double delta = Math.abs(t - oldt);\n+                final double delta = FastMath.abs(t - oldt);\n                 final double rLimit =\n-                    relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5;\n+                    relativeAccuracy * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(t, i);\n                     return result;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n import org.apache.commons.math.exception.util.Localizable;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://en.wikipedia.org/wiki/Local_regression\">\n                 double sumXSquared = 0;\n                 double sumY = 0;\n                 double sumXY = 0;\n-                double denom = Math.abs(1.0 / (xval[edge] - x));\n+                double denom = FastMath.abs(1.0 / (xval[edge] - x));\n                 for (int k = ileft; k <= iright; ++k) {\n                     final double xk   = xval[k];\n                     final double yk   = yval[k];\n                 final double meanXSquared = sumXSquared / sumWeights;\n \n                 final double beta;\n-                if (Math.sqrt(Math.abs(meanXSquared - meanX * meanX)) < accuracy) {\n+                if (FastMath.sqrt(FastMath.abs(meanXSquared - meanX * meanX)) < accuracy) {\n                     beta = 0;\n                 } else {\n                     beta = (meanXY - meanX * meanY) / (meanXSquared - meanX * meanX);\n                 final double alpha = meanY - beta * meanX;\n \n                 res[i] = beta * x + alpha;\n-                residuals[i] = Math.abs(yval[i] - res[i]);\n+                residuals[i] = FastMath.abs(yval[i] - res[i]);\n             }\n \n             // No need to recompute the robustness weights at the last\n             Arrays.sort(sortedResiduals);\n             final double medianResidual = sortedResiduals[n / 2];\n \n-            if (Math.abs(medianResidual) < accuracy) {\n+            if (FastMath.abs(medianResidual) < accuracy) {\n                 break;\n             }\n \n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Interpolating function that implements the\n             final RealVector diff = sd.getKey().subtract(p);\n             final double diffNorm = diff.getNorm();\n \n-            if (Math.abs(diffNorm) < Math.ulp(1d)) {\n+            if (FastMath.abs(diffNorm) < FastMath.ulp(1d)) {\n                 // No need to interpolate, as the interpolation point is\n                 // actually (very close to) one of the sampled points.\n                 return sd.getValue();\n             }\n \n             for (MicrosphereSurfaceElement md : microsphere) {\n-                final double w = Math.pow(diffNorm, -brightnessExponent);\n+                final double w = FastMath.pow(diffNorm, -brightnessExponent);\n                 md.store(cosAngle(diff, md.normal()) * w, sd);\n             }\n \n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Immutable representation of a real polynomial function with real coefficients.\n     public PolynomialFunction add(final PolynomialFunction p) {\n \n         // identify the lowest degree polynomial\n-        final int lowLength  = Math.min(coefficients.length, p.coefficients.length);\n-        final int highLength = Math.max(coefficients.length, p.coefficients.length);\n+        final int lowLength  = FastMath.min(coefficients.length, p.coefficients.length);\n+        final int highLength = FastMath.max(coefficients.length, p.coefficients.length);\n \n         // build the coefficients array\n         double[] newCoefficients = new double[highLength];\n     public PolynomialFunction subtract(final PolynomialFunction p) {\n \n         // identify the lowest degree polynomial\n-        int lowLength  = Math.min(coefficients.length, p.coefficients.length);\n-        int highLength = Math.max(coefficients.length, p.coefficients.length);\n+        int lowLength  = FastMath.min(coefficients.length, p.coefficients.length);\n+        int highLength = FastMath.max(coefficients.length, p.coefficients.length);\n \n         // build the coefficients array\n         double[] newCoefficients = new double[highLength];\n \n         for (int i = 0; i < newCoefficients.length; ++i) {\n             newCoefficients[i] = 0.0;\n-            for (int j = Math.max(0, i + 1 - p.coefficients.length);\n-                 j < Math.min(coefficients.length, i + 1);\n+            for (int j = FastMath.max(0, i + 1 - p.coefficients.length);\n+                 j < FastMath.min(coefficients.length, i + 1);\n                  ++j) {\n                 newCoefficients[i] += coefficients[j] * p.coefficients[i-j];\n             }\n              }\n            }\n \n-           double absAi = Math.abs(coefficients[i]);\n+           double absAi = FastMath.abs(coefficients[i]);\n            if ((absAi - 1) != 0) {\n              s.append(Double.toString(absAi));\n              s.append(' ');\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the representation of a real polynomial function in\n             c[i] = y[i];\n             d[i] = y[i];\n             // find out the abscissa closest to z\n-            final double dist = Math.abs(z - x[i]);\n+            final double dist = FastMath.abs(z - x[i]);\n             if (dist < min_dist) {\n                 nearest = i;\n                 min_dist = dist;\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n import java.util.ArrayList;\n \n import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * A collection of static methods that operate on or return polynomials.\n                                                       final ArrayList<BigFraction> coefficients,\n                                                       final RecurrenceCoefficientsGenerator generator) {\n \n-        final int maxDegree = (int) Math.floor(Math.sqrt(2 * coefficients.size())) - 1;\n+        final int maxDegree = (int) FastMath.floor(FastMath.sqrt(2 * coefficients.size())) - 1;\n         synchronized (PolynomialsUtils.class) {\n             if (degree > maxDegree) {\n                 computeUpToDegree(degree, maxDegree, generator, coefficients);\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">\n                 max = m;\n             }\n \n-            if (Math.abs(max - min) <= absoluteAccuracy) {\n+            if (FastMath.abs(max - min) <= absoluteAccuracy) {\n                 m = UnivariateRealSolverUtils.midpoint(min, max);\n                 setResult(m, i);\n                 return m;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n+        if (FastMath.abs(yMin) <= functionValueAccuracy) {\n             setResult(min, 0);\n             return result;\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n+        if (FastMath.abs(yMax) <= functionValueAccuracy) {\n             setResult(max, 0);\n             return result;\n         }\n         double sign = yMin * yMax;\n         if (sign > 0) {\n             // check if either value is close to a zero\n-            if (Math.abs(yMin) <= functionValueAccuracy) {\n+            if (FastMath.abs(yMin) <= functionValueAccuracy) {\n                 setResult(min, 0);\n                 ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n+            } else if (FastMath.abs(yMax) <= functionValueAccuracy) {\n                 setResult(max, 0);\n                 ret = max;\n             } else {\n \n         int i = 0;\n         while (i < maximalIterationCount) {\n-            if (Math.abs(y2) < Math.abs(y1)) {\n+            if (FastMath.abs(y2) < FastMath.abs(y1)) {\n                 // use the bracket point if is better than last approximation\n                 x0 = x1;\n                 x1 = x2;\n                 y1 = y2;\n                 y2 = y0;\n             }\n-            if (Math.abs(y1) <= functionValueAccuracy) {\n+            if (FastMath.abs(y1) <= functionValueAccuracy) {\n                 // Avoid division by very small values. Assume\n                 // the iteration has converged (the problem may\n                 // still be ill conditioned)\n             }\n             double dx = x2 - x1;\n             double tolerance =\n-                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n-            if (Math.abs(dx) <= tolerance) {\n+                FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy);\n+            if (FastMath.abs(dx) <= tolerance) {\n                 setResult(x1, i);\n                 return result;\n             }\n-            if ((Math.abs(oldDelta) < tolerance) ||\n-                    (Math.abs(y0) <= Math.abs(y1))) {\n+            if ((FastMath.abs(oldDelta) < tolerance) ||\n+                    (FastMath.abs(y0) <= FastMath.abs(y1))) {\n                 // Force bisection.\n                 delta = 0.5 * dx;\n                 oldDelta = delta;\n                 } else {\n                     p = -p;\n                 }\n-                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n-                        p >= Math.abs(0.5 * oldDelta * p1)) {\n+                if (2.0 * p >= 1.5 * dx * p1 - FastMath.abs(tolerance * p1) ||\n+                        p >= FastMath.abs(0.5 * oldDelta * p1)) {\n                     // Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n             x0 = x1;\n             y0 = y1;\n             // Compute new X1, Y1\n-            if (Math.abs(delta) > tolerance) {\n+            if (FastMath.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n             } else if (dx > 0.0) {\n                 x1 = x1 + 0.5 * tolerance;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n      * @return true iff z is the sought-after real zero\n      */\n     protected boolean isRootOK(double min, double max, Complex z) {\n-        double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n+        double tolerance = FastMath.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n         return (isSequence(min, z.getReal(), max)) &&\n-               (Math.abs(z.getImaginary()) <= tolerance ||\n+               (FastMath.abs(z.getImaginary()) <= tolerance ||\n                 z.abs() <= functionValueAccuracy);\n     }\n \n             d2v = d2v.multiply(new Complex(2.0, 0.0));\n \n             // check for convergence\n-            double tolerance = Math.max(relativeAccuracy * z.abs(),\n+            double tolerance = FastMath.max(relativeAccuracy * z.abs(),\n                                         absoluteAccuracy);\n             if ((z.subtract(oldz)).abs() <= tolerance) {\n                 resultComputed = true;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n             final double d012 = (d12 - d01) / (x2 - x0);\n             final double c1 = d01 + (x1 - x0) * d012;\n             final double delta = c1 * c1 - 4 * y1 * d012;\n-            final double xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n-            final double xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n+            final double xplus = x1 + (-2.0 * y1) / (c1 + FastMath.sqrt(delta));\n+            final double xminus = x1 + (-2.0 * y1) / (c1 - FastMath.sqrt(delta));\n             // xplus and xminus are two roots of parabola and at least\n             // one of them should lie in (x0, x2)\n             final double x = isSequence(x0, xplus, x2) ? xplus : xminus;\n             final double y = f.value(x);\n \n             // check for convergence\n-            final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n-            if (Math.abs(x - oldx) <= tolerance) {\n+            final double tolerance = FastMath.max(relativeAccuracy * FastMath.abs(x), absoluteAccuracy);\n+            if (FastMath.abs(x - oldx) <= tolerance) {\n                 setResult(x, i);\n                 return result;\n             }\n-            if (Math.abs(y) <= functionValueAccuracy) {\n+            if (FastMath.abs(y) <= functionValueAccuracy) {\n                 setResult(x, i);\n                 return result;\n             }\n             final double denominator;\n             if (delta >= 0.0) {\n                 // choose a denominator larger in magnitude\n-                double dplus = b + Math.sqrt(delta);\n-                double dminus = b - Math.sqrt(delta);\n-                denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;\n+                double dplus = b + FastMath.sqrt(delta);\n+                double dminus = b - FastMath.sqrt(delta);\n+                denominator = FastMath.abs(dplus) > FastMath.abs(dminus) ? dplus : dminus;\n             } else {\n-                // take the modulus of (B +/- Math.sqrt(delta))\n-                denominator = Math.sqrt(b * b - delta);\n+                // take the modulus of (B +/- FastMath.sqrt(delta))\n+                denominator = FastMath.sqrt(b * b - delta);\n             }\n             if (denominator != 0) {\n                 x = x2 - 2.0 * c * (x2 - x1) / denominator;\n                 }\n             } else {\n                 // extremely rare case, get a random number to skip it\n-                x = min + Math.random() * (max - min);\n+                x = min + FastMath.random() * (max - min);\n                 oldx = Double.POSITIVE_INFINITY;\n             }\n             final double y = f.value(x);\n \n             // check for convergence\n-            final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n-            if (Math.abs(x - oldx) <= tolerance) {\n+            final double tolerance = FastMath.max(relativeAccuracy * FastMath.abs(x), absoluteAccuracy);\n+            if (FastMath.abs(x - oldx) <= tolerance) {\n                 setResult(x, i);\n                 return result;\n             }\n-            if (Math.abs(y) <= functionValueAccuracy) {\n+            if (FastMath.abs(y) <= functionValueAccuracy) {\n                 setResult(x, i);\n                 return result;\n             }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n             while (i < maximalIterationCount) {\n \n                 x1 = x0 - (f.value(x0) / derivative.value(x0));\n-                if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n+                if (FastMath.abs(x1 - x0) <= absoluteAccuracy) {\n                     setResult(x1, i);\n                     return x1;\n                 }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n             // calculate the new root approximation\n             final double x3 = 0.5 * (x1 + x2);\n             final double y3 = f.value(x3);\n-            if (Math.abs(y3) <= functionValueAccuracy) {\n+            if (FastMath.abs(y3) <= functionValueAccuracy) {\n                 setResult(x3, i);\n                 return result;\n             }\n             final double delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n             final double correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n-                                      (x3 - x1) / Math.sqrt(delta);\n+                                      (x3 - x1) / FastMath.sqrt(delta);\n             final double x = x3 - correction;                // correction != 0\n             final double y = f.value(x);\n \n             // check for convergence\n-            final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n-            if (Math.abs(x - oldx) <= tolerance) {\n+            final double tolerance = FastMath.max(relativeAccuracy * FastMath.abs(x), absoluteAccuracy);\n+            if (FastMath.abs(x - oldx) <= tolerance) {\n                 setResult(x, i);\n                 return result;\n             }\n-            if (Math.abs(y) <= functionValueAccuracy) {\n+            if (FastMath.abs(y) <= functionValueAccuracy) {\n                 setResult(x, i);\n                 return result;\n             }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n         double oldDelta = x2 - x1;\n         int i = 0;\n         while (i < maximalIterationCount) {\n-            if (Math.abs(y2) < Math.abs(y1)) {\n+            if (FastMath.abs(y2) < FastMath.abs(y1)) {\n                 x0 = x1;\n                 x1 = x2;\n                 x2 = x0;\n                 y1 = y2;\n                 y2 = y0;\n             }\n-            if (Math.abs(y1) <= functionValueAccuracy) {\n+            if (FastMath.abs(y1) <= functionValueAccuracy) {\n                 setResult(x1, i);\n                 return result;\n             }\n-            if (Math.abs(oldDelta) <\n-                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+            if (FastMath.abs(oldDelta) <\n+                FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n                 setResult(x1, i);\n                 return result;\n             }\n             double delta;\n-            if (Math.abs(y1) > Math.abs(y0)) {\n+            if (FastMath.abs(y1) > FastMath.abs(y0)) {\n                 // Function value increased in last iteration. Force bisection.\n                 delta = 0.5 * oldDelta;\n             } else {\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Utility routines for {@link UnivariateRealSolver} objects.\n         int numIterations = 0 ;\n \n         do {\n-            a = Math.max(a - 1.0, lowerBound);\n-            b = Math.min(b + 1.0, upperBound);\n+            a = FastMath.max(a - 1.0, lowerBound);\n+            b = FastMath.min(b + 1.0, upperBound);\n             fa = function.value(a);\n \n             fb = function.value(b);\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Representation of a Complex number - a number which has both a\n             return Double.POSITIVE_INFINITY;\n         }\n \n-        if (Math.abs(real) < Math.abs(imaginary)) {\n+        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n             if (imaginary == 0.0) {\n-                return Math.abs(real);\n+                return FastMath.abs(real);\n             }\n             double q = real / imaginary;\n-            return Math.abs(imaginary) * Math.sqrt(1 + q * q);\n+            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n         } else {\n             if (real == 0.0) {\n-                return Math.abs(imaginary);\n+                return FastMath.abs(imaginary);\n             }\n             double q = imaginary / real;\n-            return Math.abs(real) * Math.sqrt(1 + q * q);\n+            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n         }\n     }\n \n             return ZERO;\n         }\n \n-        if (Math.abs(c) < Math.abs(d)) {\n+        if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             double denominator = c * q + d;\n             return createComplex((real * q + imaginary) / denominator,\n             return Complex.NaN;\n         }\n \n-        return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n-            -Math.sin(real) * MathUtils.sinh(imaginary));\n+        return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n+            -FastMath.sin(real) * MathUtils.sinh(imaginary));\n     }\n \n     /**\n             return Complex.NaN;\n         }\n \n-        return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n-            MathUtils.sinh(real) * Math.sin(imaginary));\n+        return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n+            MathUtils.sinh(real) * FastMath.sin(imaginary));\n     }\n \n     /**\n             return Complex.NaN;\n         }\n \n-        double expReal = Math.exp(real);\n-        return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n+        double expReal = FastMath.exp(real);\n+        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n     }\n \n     /**\n             return Complex.NaN;\n         }\n \n-        return createComplex(Math.log(abs()),\n-            Math.atan2(imaginary, real));\n+        return createComplex(FastMath.log(abs()),\n+            FastMath.atan2(imaginary, real));\n     }\n \n     /**\n             return Complex.NaN;\n         }\n \n-        return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n-            Math.cos(real) * MathUtils.sinh(imaginary));\n+        return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n+            FastMath.cos(real) * MathUtils.sinh(imaginary));\n     }\n \n     /**\n             return Complex.NaN;\n         }\n \n-        return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n-            MathUtils.cosh(real) * Math.sin(imaginary));\n+        return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),\n+            MathUtils.cosh(real) * FastMath.sin(imaginary));\n     }\n \n     /**\n             return createComplex(0.0, 0.0);\n         }\n \n-        double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n+        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n         if (real >= 0.0) {\n             return createComplex(t, imaginary / (2.0 * t));\n         } else {\n-            return createComplex(Math.abs(imaginary) / (2.0 * t),\n+            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                 MathUtils.indicator(imaginary) * t);\n         }\n     }\n \n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n-        double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n-\n-        return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n+        double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);\n+\n+        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n     }\n \n     /**\n \n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n-        double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n-\n-        return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n+        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);\n+\n+        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n     }\n \n \n      * @return the argument of this complex number\n      */\n     public double getArgument() {\n-        return Math.atan2(getImaginary(), getReal());\n+        return FastMath.atan2(getImaginary(), getReal());\n     }\n \n     /**\n         }\n \n         // nth root of abs -- faster / more accurate to use a solver here?\n-        final double nthRootOfAbs = Math.pow(abs(), 1.0 / n);\n+        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n \n         // Compute nth roots of complex number with k = 0, 1, ... n-1\n         final double nthPhi = getArgument()/n;\n-        final double slice = 2 * Math.PI / n;\n+        final double slice = 2 * FastMath.PI / n;\n         double innerPart = nthPhi;\n         for (int k = 0; k < n ; k++) {\n             // inner part\n-            final double realPart      = nthRootOfAbs *  Math.cos(innerPart);\n-            final double imaginaryPart = nthRootOfAbs *  Math.sin(innerPart);\n+            final double realPart      = nthRootOfAbs *  FastMath.cos(innerPart);\n+            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n             result.add(createComplex(realPart, imaginaryPart));\n             innerPart += slice;\n         }\n--- a/src/main/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexUtils.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Static implementations of common\n             throw MathRuntimeException.createIllegalArgumentException(\n                   LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);\n         }\n-        return new Complex(r * Math.cos(theta), r * Math.sin(theta));\n+        return new Complex(r * FastMath.cos(theta), r * FastMath.sin(theta));\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Base class for continuous distributions.  Default implementations are\n              * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n              * case if density has bounded support and p is 0 or 1).\n              */\n-            if (Math.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n+            if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n                 return lowerBound;\n             }\n-            if (Math.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n+            if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n                 return upperBound;\n             }\n             // Failed bracket convergence was not because of corner solution\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n      * computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n-        return cumulativeProbability((int) Math.floor(x));\n+        return cumulativeProbability((int) FastMath.floor(x));\n     }\n \n     /**\n             throw MathRuntimeException.createIllegalArgumentException(\n                   LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT, x0, x1);\n         }\n-        if (Math.floor(x0) < x0) {\n-            return cumulativeProbability(((int) Math.floor(x0)) + 1,\n-               (int) Math.floor(x1)); // don't want to count mass below x0\n+        if (FastMath.floor(x0) < x0) {\n+            return cumulativeProbability(((int) FastMath.floor(x0)) + 1,\n+               (int) FastMath.floor(x1)); // don't want to count mass below x0\n         } else { // x0 is mathematical integer, so use as is\n-            return cumulativeProbability((int) Math.floor(x0),\n-                (int) Math.floor(x1));\n+            return cumulativeProbability((int) FastMath.floor(x0),\n+                (int) FastMath.floor(x1));\n         }\n     }\n \n      * @return the value of the probability density function at x\n      */\n     public double probability(double x) {\n-        double fl = Math.floor(x);\n+        double fl = FastMath.floor(x);\n         if (fl == x) {\n             return this.probability((int) x);\n         } else {\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the Beta distribution.\n             }\n             return 0;\n         } else {\n-            double logX = Math.log(x);\n-            double log1mX = Math.log1p(-x);\n-            return Math.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);\n+            double logX = FastMath.log(x);\n+            double log1mX = FastMath.log1p(-x);\n+            return FastMath.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * The default implementation of {@link BinomialDistribution}.\n         if (x < 0 || x > numberOfTrials) {\n             ret = 0.0;\n         } else {\n-            ret = Math.exp(SaddlePointExpansion.logBinomialProbability(x,\n+            ret = FastMath.exp(SaddlePointExpansion.logBinomialProbability(x,\n                     numberOfTrials, probabilityOfSuccess,\n                     1.0 - probabilityOfSuccess));\n         }\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Default implementation of\n      * @return CDF evaluted at <code>x</code>.\n      */\n     public double cumulativeProbability(double x) {\n-        return 0.5 + (Math.atan((x - median) / scale) / Math.PI);\n+        return 0.5 + (FastMath.atan((x - median) / scale) / FastMath.PI);\n     }\n \n     /**\n     @Override\n     public double density(double x) {\n         final double dev = x - median;\n-        return (1 / Math.PI) * (scale / (dev * dev + scale * scale));\n+        return (1 / FastMath.PI) * (scale / (dev * dev + scale * scale));\n     }\n \n     /**\n         } else  if (p == 1) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n-            ret = median + scale * Math.tan(Math.PI * (p - .5));\n+            ret = median + scale * FastMath.tan(FastMath.PI * (p - .5));\n         }\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * The default implementation of {@link ExponentialDistribution}.\n         if (x < 0) {\n             return 0;\n         }\n-        return Math.exp(-x / mean) / mean;\n+        return FastMath.exp(-x / mean) / mean;\n     }\n \n     /**\n         if (x <= 0.0) {\n             ret = 0.0;\n         } else {\n-            ret = 1.0 - Math.exp(-x / mean);\n+            ret = 1.0 - FastMath.exp(-x / mean);\n         }\n         return ret;\n     }\n         } else if (p == 1.0) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n-            ret = -mean * Math.log(1.0 - p);\n+            ret = -mean * FastMath.log(1.0 - p);\n         }\n \n         return ret;\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Default implementation of\n     public double density(double x) {\n         final double nhalf = numeratorDegreesOfFreedom / 2;\n         final double mhalf = denominatorDegreesOfFreedom / 2;\n-        final double logx = Math.log(x);\n-        final double logn = Math.log(numeratorDegreesOfFreedom);\n-        final double logm = Math.log(denominatorDegreesOfFreedom);\n-        final double lognxm = Math.log(numeratorDegreesOfFreedom * x + denominatorDegreesOfFreedom);\n-        return Math.exp(nhalf*logn + nhalf*logx - logx + mhalf*logm - nhalf*lognxm -\n+        final double logx = FastMath.log(x);\n+        final double logn = FastMath.log(numeratorDegreesOfFreedom);\n+        final double logm = FastMath.log(denominatorDegreesOfFreedom);\n+        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x + denominatorDegreesOfFreedom);\n+        return FastMath.exp(nhalf*logn + nhalf*logx - logx + mhalf*logm - nhalf*lognxm -\n                mhalf*lognxm - Beta.logBeta(nhalf, mhalf));\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * The default implementation of {@link GammaDistribution}.\n     @Override\n     public double density(double x) {\n         if (x < 0) return 0;\n-        return Math.pow(x / beta, alpha - 1) / beta * Math.exp(-x / beta) / Math.exp(Gamma.logGamma(alpha));\n+        return FastMath.pow(x / beta, alpha - 1) / beta * FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * The default implementation of {@link HypergeometricDistribution}.\n      * @return the lowest domain value of the hypergeometric distribution.\n      */\n     private int getLowerDomain(int n, int m, int k) {\n-        return Math.max(0, m - (n - k));\n+        return FastMath.max(0, m - (n - k));\n     }\n \n     /**\n      * @return the highest domain value of the hypergeometric distribution.\n      */\n     private int getUpperDomain(int m, int k) {\n-        return Math.min(k, m);\n+        return FastMath.min(k, m);\n     }\n \n     /**\n                     populationSize - numberOfSuccesses, p, q);\n             double p3 =\n                 SaddlePointExpansion.logBinomialProbability(sampleSize, populationSize, p, q);\n-            ret = Math.exp(p1 + p2 - p3);\n+            ret = FastMath.exp(p1 + p2 - p3);\n         }\n \n         return ret;\n      * @return PMF for the distribution.\n      */\n     private double probability(int n, int m, int k, int x) {\n-        return Math.exp(MathUtils.binomialCoefficientLog(m, x) +\n+        return FastMath.exp(MathUtils.binomialCoefficientLog(m, x) +\n                MathUtils.binomialCoefficientLog(n - m, k - x) -\n                MathUtils.binomialCoefficientLog(n, k));\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Erf;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Default implementation of\n     private static final long serialVersionUID = 8589540077390120676L;\n \n     /** &sqrt;(2 &pi;) */\n-    private static final double SQRT2PI = Math.sqrt(2 * Math.PI);\n+    private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);\n \n     /** The mean of this distribution. */\n     private double mean = 0;\n      */\n     public double density(double x) {\n         double x0 = x - mean;\n-        return Math.exp(-x0 * x0 / (2 * standardDeviation * standardDeviation)) / (standardDeviation * SQRT2PI);\n+        return FastMath.exp(-x0 * x0 / (2 * standardDeviation * standardDeviation)) / (standardDeviation * SQRT2PI);\n     }\n \n     /**\n     public double cumulativeProbability(double x) throws MathException {\n         try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n-                    (standardDeviation * Math.sqrt(2.0))));\n+                    (standardDeviation * FastMath.sqrt(2.0))));\n         } catch (MaxIterationsExceededException ex) {\n             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n                 return 0.0d;\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * The default implementation of {@link PascalDistribution}.\n         } else {\n             ret = MathUtils.binomialCoefficientDouble(x +\n                   numberOfSuccesses - 1, numberOfSuccesses - 1) *\n-                  Math.pow(probabilityOfSuccess, numberOfSuccesses) *\n-                  Math.pow(1.0 - probabilityOfSuccess, x);\n+                  FastMath.pow(probabilityOfSuccess, numberOfSuccesses) *\n+                  FastMath.pow(1.0 - probabilityOfSuccess, x);\n         }\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implementation for the {@link PoissonDistribution}.\n         mean = p;\n         normal = z;\n         normal.setMean(p);\n-        normal.setStandardDeviation(Math.sqrt(p));\n+        normal.setStandardDeviation(FastMath.sqrt(p));\n     }\n \n     /**\n         if (x < 0 || x == Integer.MAX_VALUE) {\n             ret = 0.0;\n         } else if (x == 0) {\n-            ret = Math.exp(-mean);\n+            ret = FastMath.exp(-mean);\n         } else {\n-            ret = Math.exp(-SaddlePointExpansion.getStirlingError(x) -\n+            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) -\n                   SaddlePointExpansion.getDeviancePart(x, mean)) /\n-                  Math.sqrt(MathUtils.TWO_PI * x);\n+                  FastMath.sqrt(MathUtils.TWO_PI * x);\n         }\n         return ret;\n     }\n      */\n     @Override\n     public int sample() throws MathException {\n-        return (int) Math.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n+        return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/SaddlePointExpansion.java\n+++ b/src/main/java/org/apache/commons/math/distribution/SaddlePointExpansion.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n final class SaddlePointExpansion {\n \n     /** 1/2 * log(2 &#960;). */\n-    private static final double HALF_LOG_2_PI = 0.5 * Math.log(MathUtils.TWO_PI);\n+    private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(MathUtils.TWO_PI);\n \n     /** exact Stirling expansion error for certain values. */\n     private static final double[] EXACT_STIRLING_ERRORS = { 0.0, /* 0.0 */\n         double ret;\n         if (z < 15.0) {\n             double z2 = 2.0 * z;\n-            if (Math.floor(z2) == z2) {\n+            if (FastMath.floor(z2) == z2) {\n                 ret = EXACT_STIRLING_ERRORS[(int) z2];\n             } else {\n-                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * Math.log(z) +\n+                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) +\n                       z - HALF_LOG_2_PI;\n             }\n         } else {\n      */\n     static double getDeviancePart(double x, double mu) {\n         double ret;\n-        if (Math.abs(x - mu) < 0.1 * (x + mu)) {\n+        if (FastMath.abs(x - mu) < 0.1 * (x + mu)) {\n             double d = x - mu;\n             double v = d / (x + mu);\n             double s1 = v * d;\n             }\n             ret = s1;\n         } else {\n-            ret = x * Math.log(x / mu) + mu - x;\n+            ret = x * FastMath.log(x / mu) + mu - x;\n         }\n         return ret;\n     }\n             if (p < 0.1) {\n                 ret = -getDeviancePart(n, n * q) - n * p;\n             } else {\n-                ret = n * Math.log(q);\n+                ret = n * FastMath.log(q);\n             }\n         } else if (x == n) {\n             if (q < 0.1) {\n                 ret = -getDeviancePart(n, n * p) - n * q;\n             } else {\n-                ret = n * Math.log(p);\n+                ret = n * FastMath.log(p);\n             }\n         } else {\n             ret = getStirlingError(n) - getStirlingError(x) -\n                   getStirlingError(n - x) - getDeviancePart(x, n * p) -\n                   getDeviancePart(n - x, n * q);\n             double f = (MathUtils.TWO_PI * x * (n - x)) / n;\n-            ret = -0.5 * Math.log(f) + ret;\n+            ret = -0.5 * FastMath.log(f) + ret;\n         }\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Default implementation of\n     public double density(double x) {\n         final double n = degreesOfFreedom;\n         final double nPlus1Over2 = (n + 1) / 2;\n-        return Math.exp(Gamma.logGamma(nPlus1Over2) - 0.5 * (Math.log(Math.PI) + Math.log(n)) -\n-                Gamma.logGamma(n/2) - nPlus1Over2 * Math.log(1 + x * x /n));\n+        return FastMath.exp(Gamma.logGamma(nPlus1Over2) - 0.5 * (FastMath.log(FastMath.PI) + FastMath.log(n)) -\n+                Gamma.logGamma(n/2) - nPlus1Over2 * FastMath.log(1 + x * x /n));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Default implementation of\n         if (x <= 0.0) {\n             ret = 0.0;\n         } else {\n-            ret = 1.0 - Math.exp(-Math.pow(x / scale, shape));\n+            ret = 1.0 - FastMath.exp(-FastMath.pow(x / scale, shape));\n         }\n         return ret;\n     }\n         }\n \n         final double xscale = x / scale;\n-        final double xscalepow = Math.pow(xscale, shape - 1);\n+        final double xscalepow = FastMath.pow(xscale, shape - 1);\n \n         /*\n-         * Math.pow(x / scale, shape) =\n-         * Math.pow(xscale, shape) =\n-         * Math.pow(xscale, shape - 1) * xscale\n+         * FastMath.pow(x / scale, shape) =\n+         * FastMath.pow(xscale, shape) =\n+         * FastMath.pow(xscale, shape - 1) * xscale\n          */\n         final double xscalepowshape = xscalepow * xscale;\n \n-        return (shape / scale) * xscalepow * Math.exp(-xscalepowshape);\n+        return (shape / scale) * xscalepow * FastMath.exp(-xscalepowshape);\n     }\n \n     /**\n         } else  if (p == 1) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n-            ret = scale * Math.pow(-Math.log(1.0 - p), 1.0 / shape);\n+            ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);\n         }\n         return ret;\n     }\n     @Override\n     protected double getInitialDomain(double p) {\n         // use median\n-        return Math.pow(scale * Math.log(2.0), 1.0 / shape);\n+        return FastMath.pow(scale * FastMath.log(2.0), 1.0 / shape);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implementation for the {@link ZipfDistribution}.\n             return 0.0;\n         }\n \n-        return (1.0 / Math.pow(x, exponent)) / generalizedHarmonic(numberOfElements, exponent);\n+        return (1.0 / FastMath.pow(x, exponent)) / generalizedHarmonic(numberOfElements, exponent);\n \n     }\n \n     private double generalizedHarmonic(final int n, final double m) {\n         double value = 0;\n         for (int k = n; k > 0; --k) {\n-            value += 1.0 / Math.pow(k, m);\n+            value += 1.0 / FastMath.pow(k, m);\n         }\n         return value;\n     }\n--- a/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Base class for implementing estimators.\n         int index = 0;\n         for (int i = 0; i < rows; i++) {\n             WeightedMeasurement wm = measurements[i];\n-            double factor = -Math.sqrt(wm.getWeight());\n+            double factor = -FastMath.sqrt(wm.getWeight());\n             for (int j = 0; j < cols; ++j) {\n                 jacobian[index++] = factor * wm.getPartial(parameters[j]);\n             }\n         for (int i = 0; i < rows; i++, index += cols) {\n             WeightedMeasurement wm = measurements[i];\n             double residual = wm.getResidual();\n-            residuals[i] = Math.sqrt(wm.getWeight()) * residual;\n+            residuals[i] = FastMath.sqrt(wm.getWeight()) * residual;\n             cost += wm.getWeight() * residual * residual;\n         }\n-        cost = Math.sqrt(cost);\n+        cost = FastMath.sqrt(cost);\n \n     }\n \n             double residual = wm[i].getResidual();\n             criterion += wm[i].getWeight() * residual * residual;\n         }\n-        return Math.sqrt(criterion / wm.length);\n+        return FastMath.sqrt(criterion / wm.length);\n     }\n \n     /**\n                     m, p);\n         }\n         double[] errors = new double[problem.getUnboundParameters().length];\n-        final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n+        final double c = FastMath.sqrt(getChiSquare(problem) / (m - p));\n         double[][] covar = getCovariances(problem);\n         for (int i = 0; i < errors.length; ++i) {\n-            errors[i] = Math.sqrt(covar[i][i]) * c;\n+            errors[i] = FastMath.sqrt(covar[i][i]) * c;\n         }\n         return errors;\n     }\n--- a/src/main/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements a solver for estimation problems.\n      * to improve the criterion anymore\n      * @param steadyStateThreshold steady state detection threshold, the\n      * problem has converged has reached a steady state if\n-     * <code>Math.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n+     * <code>FastMath.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n      * J<sub>n</sub> &times convergence</code>, where <code>J<sub>n</sub></code>\n      * and <code>J<sub>n-1</sub></code> are the current and preceding criterion\n      * values (square sum of the weighted residuals of considered measurements).\n      * Set the steady state detection threshold.\n      * <p>\n      * The problem has converged has reached a steady state if\n-     * <code>Math.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n+     * <code>FastMath.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n      * J<sub>n</sub> &times convergence</code>, where <code>J<sub>n</sub></code>\n      * and <code>J<sub>n-1</sub></code> are the current and preceding criterion\n      * values (square sum of the weighted residuals of considered measurements).\n             updateResidualsAndCost();\n \n         } while ((getCostEvaluations() < 2) ||\n-                 (Math.abs(previous - cost) > (cost * steadyStateThreshold) &&\n-                  (Math.abs(cost) > convergence)));\n+                 (FastMath.abs(previous - cost) > (cost * steadyStateThreshold) &&\n+                  (FastMath.abs(cost) > convergence)));\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n import java.util.Arrays;\n \n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n     initializeEstimate(problem);\n \n     // arrays shared with the other private methods\n-    solvedCols  = Math.min(rows, cols);\n+    solvedCols  = FastMath.min(rows, cols);\n     diagR       = new double[cols];\n     jacNorm     = new double[cols];\n     beta        = new double[cols];\n           xNorm  += xk * xk;\n           diag[k] = dk;\n         }\n-        xNorm = Math.sqrt(xNorm);\n+        xNorm = FastMath.sqrt(xNorm);\n \n         // initialize the step bound delta\n         delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n               sum += jacobian[index] * residuals[i];\n               index += cols;\n             }\n-            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n+            maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * cost));\n           }\n         }\n       }\n \n       // rescale if necessary\n       for (int j = 0; j < cols; ++j) {\n-        diag[j] = Math.max(diag[j], jacNorm[j]);\n+        diag[j] = FastMath.max(diag[j], jacNorm[j]);\n       }\n \n       // inner loop\n           double s = diag[pj] * lmDir[pj];\n           lmNorm  += s * s;\n         }\n-        lmNorm = Math.sqrt(lmNorm);\n+        lmNorm = FastMath.sqrt(lmNorm);\n \n         // on the first iteration, adjust the initial step bound.\n         if (firstIteration) {\n-          delta = Math.min(delta, lmNorm);\n+          delta = FastMath.min(delta, lmNorm);\n         }\n \n         // evaluate the function at x + p and calculate its norm\n           if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n             tmp = 0.1;\n           }\n-          delta = tmp * Math.min(delta, 10.0 * lmNorm);\n+          delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n           lmPar /= tmp;\n         } else if ((lmPar == 0) || (ratio >= 0.75)) {\n           delta = 2 * lmNorm;\n             double xK = diag[k] * parameters[k].getEstimate();\n             xNorm    += xK * xK;\n           }\n-          xNorm = Math.sqrt(xNorm);\n+          xNorm = FastMath.sqrt(xNorm);\n         } else {\n           // failed iteration, reset the previous values\n           cost = previousCost;\n         }\n \n         // tests for convergence.\n-        if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+        if (((FastMath.abs(actRed) <= costRelativeTolerance) &&\n              (preRed <= costRelativeTolerance) &&\n              (ratio <= 2.0)) ||\n              (delta <= parRelativeTolerance * xNorm)) {\n \n         // tests for termination and stringent tolerances\n         // (2.2204e-16 is the machine epsilon for IEEE754)\n-        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n+        if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n           throw new EstimationException(\"cost relative tolerance is too small ({0}),\" +\n                                         \" no further reduction in the\" +\n                                         \" sum of squares is possible\",\n       work1[pj] = s;\n       dxNorm += s * s;\n     }\n-    dxNorm = Math.sqrt(dxNorm);\n+    dxNorm = FastMath.sqrt(dxNorm);\n     double fp = dxNorm - delta;\n     if (fp <= 0.1 * delta) {\n       lmPar = 0;\n       sum /= diag[pj];\n       sum2 += sum * sum;\n     }\n-    double gNorm = Math.sqrt(sum2);\n+    double gNorm = FastMath.sqrt(sum2);\n     double paru = gNorm / delta;\n     if (paru == 0) {\n       // 2.2251e-308 is the smallest positive real for IEE754\n-      paru = 2.2251e-308 / Math.min(delta, 0.1);\n+      paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n     }\n \n     // if the input par lies outside of the interval (parl,paru),\n     // set par to the closer endpoint\n-    lmPar = Math.min(paru, Math.max(lmPar, parl));\n+    lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n     if (lmPar == 0) {\n       lmPar = gNorm / dxNorm;\n     }\n \n       // evaluate the function at the current value of lmPar\n       if (lmPar == 0) {\n-        lmPar = Math.max(2.2251e-308, 0.001 * paru);\n-      }\n-      double sPar = Math.sqrt(lmPar);\n+        lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n+      }\n+      double sPar = FastMath.sqrt(lmPar);\n       for (int j = 0; j < solvedCols; ++j) {\n         int pj = permutation[j];\n         work1[pj] = sPar * diag[pj];\n         work3[pj] = s;\n         dxNorm += s * s;\n       }\n-      dxNorm = Math.sqrt(dxNorm);\n+      dxNorm = FastMath.sqrt(dxNorm);\n       double previousFP = fp;\n       fp = dxNorm - delta;\n \n       // if the function is small enough, accept the current value\n       // of lmPar, also test for the exceptional cases where parl is zero\n-      if ((Math.abs(fp) <= 0.1 * delta) ||\n+      if ((FastMath.abs(fp) <= 0.1 * delta) ||\n           ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n         return;\n       }\n \n       // depending on the sign of the function, update parl or paru.\n       if (fp > 0) {\n-        parl = Math.max(parl, lmPar);\n+        parl = FastMath.max(parl, lmPar);\n       } else if (fp < 0) {\n-        paru = Math.min(paru, lmPar);\n+        paru = FastMath.min(paru, lmPar);\n       }\n \n       // compute an improved estimate for lmPar\n-      lmPar = Math.max(parl, lmPar + correction);\n+      lmPar = FastMath.max(parl, lmPar + correction);\n \n     }\n   }\n           final double sin;\n           final double cos;\n           double rkk = jacobian[k * cols + pk];\n-          if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n+          if (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\n             final double cotan = rkk / lmDiag[k];\n-            sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n+            sin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\n             cos   = sin * cotan;\n           } else {\n             final double tan = lmDiag[k] / rkk;\n-            cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n+            cos = 1.0 / FastMath.sqrt(1.0 + tan * tan);\n             sin = cos * tan;\n           }\n \n         double akk = jacobian[index];\n         norm2 += akk * akk;\n       }\n-      jacNorm[k] = Math.sqrt(norm2);\n+      jacNorm[k] = FastMath.sqrt(norm2);\n     }\n \n     // transform the matrix column after column\n       // choose alpha such that Hk.u = alpha ek\n       int    kDiag = k * cols + pk;\n       double akk   = jacobian[kDiag];\n-      double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n+      double alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\n       double betak = 1.0 / (ak2 - akk * alpha);\n       beta[pk]     = betak;\n \n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Representation of a rational number without any overflow. This class is\n         throws FractionConversionException {\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n-        long a0 = (long) Math.floor(r0);\n+        long a0 = (long) FastMath.floor(r0);\n         if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n         // check for (almost) integer arguments, which should not go\n         // to iterations.\n-        if (Math.abs(a0 - value) < epsilon) {\n+        if (FastMath.abs(a0 - value) < epsilon) {\n             numerator = BigInteger.valueOf(a0);\n             denominator = BigInteger.ONE;\n             return;\n         do {\n             ++n;\n             final double r1 = 1.0 / (r0 - a0);\n-            final long a1 = (long) Math.floor(r1);\n+            final long a1 = (long) FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n             if ((p2 > overflow) || (q2 > overflow)) {\n \n             final double convergent = (double) p2 / (double) q2;\n             if ((n < maxIterations) &&\n-                (Math.abs(convergent - value) > epsilon) &&\n+                (FastMath.abs(convergent - value) > epsilon) &&\n                 (q2 < maxDenominator)) {\n                 p0 = p1;\n                 p1 = p2;\n      * @return <tt>this<sup>exponent</sup></tt>.\n      */\n     public double pow(final double exponent) {\n-        return Math.pow(numerator.doubleValue(),   exponent) /\n-               Math.pow(denominator.doubleValue(), exponent);\n+        return FastMath.pow(numerator.doubleValue(),   exponent) /\n+               FastMath.pow(denominator.doubleValue(), exponent);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Representation of a rational number.\n     {\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n-        long a0 = (long)Math.floor(r0);\n+        long a0 = (long)FastMath.floor(r0);\n         if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n         // check for (almost) integer arguments, which should not go\n         // to iterations.\n-        if (Math.abs(a0 - value) < epsilon) {\n+        if (FastMath.abs(a0 - value) < epsilon) {\n             this.numerator = (int) a0;\n             this.denominator = 1;\n             return;\n         do {\n             ++n;\n             double r1 = 1.0 / (r0 - a0);\n-            long a1 = (long)Math.floor(r1);\n+            long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n             if ((p2 > overflow) || (q2 > overflow)) {\n             }\n \n             double convergent = (double)p2 / (double)q2;\n-            if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                 p0 = p1;\n                 p1 = p2;\n                 q0 = q1;\n--- a/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n \n import java.util.Collections;\n import java.util.List;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Population of chromosomes which uses elitism (certain percentace of the best\n         Collections.sort(oldChromosomes);\n \n         // index of the last \"not good enough\" chromosome\n-        int boundIndex = (int) Math.ceil((1.0 - this.getElitismRate()) * oldChromosomes.size());\n+        int boundIndex = (int) FastMath.ceil((1.0 - this.getElitismRate()) * oldChromosomes.size());\n         for (int i=boundIndex; i<oldChromosomes.size(); i++) {\n             nextGeneration.addChromosome(oldChromosomes.get(i));\n         }\n--- a/src/main/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Rotation.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements rotations in a three-dimensional space.\n \n     if (needsNormalization) {\n       // normalization preprocessing\n-      double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n+      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n       q0 *= inv;\n       q1 *= inv;\n       q2 *= inv;\n     }\n \n     double halfAngle = -0.5 * angle;\n-    double coeff = Math.sin(halfAngle) / norm;\n-\n-    q0 = Math.cos (halfAngle);\n+    double coeff = FastMath.sin(halfAngle) / norm;\n+\n+    q0 = FastMath.cos (halfAngle);\n     q1 = coeff * axis.getX();\n     q2 = coeff * axis.getY();\n     q3 = coeff * axis.getZ();\n     double s = ort[0][0] + ort[1][1] + ort[2][2];\n     if (s > -0.19) {\n       // compute q0 and deduce q1, q2 and q3\n-      q0 = 0.5 * Math.sqrt(s + 1.0);\n+      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n       double inv = 0.25 / q0;\n       q1 = inv * (ort[1][2] - ort[2][1]);\n       q2 = inv * (ort[2][0] - ort[0][2]);\n       s = ort[0][0] - ort[1][1] - ort[2][2];\n       if (s > -0.19) {\n         // compute q1 and deduce q0, q2 and q3\n-        q1 = 0.5 * Math.sqrt(s + 1.0);\n+        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n         double inv = 0.25 / q1;\n         q0 = inv * (ort[1][2] - ort[2][1]);\n         q2 = inv * (ort[0][1] + ort[1][0]);\n         s = ort[1][1] - ort[0][0] - ort[2][2];\n         if (s > -0.19) {\n           // compute q2 and deduce q0, q1 and q3\n-          q2 = 0.5 * Math.sqrt(s + 1.0);\n+          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n           double inv = 0.25 / q2;\n           q0 = inv * (ort[2][0] - ort[0][2]);\n           q1 = inv * (ort[0][1] + ort[1][0]);\n         } else {\n           // compute q3 and deduce q0, q1 and q2\n           s = ort[2][2] - ort[0][0] - ort[1][1];\n-          q3 = 0.5 * Math.sqrt(s + 1.0);\n+          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n           double inv = 0.25 / q3;\n           q0 = inv * (ort[0][1] - ort[1][0]);\n           q1 = inv * (ort[0][2] + ort[2][0]);\n   double u2z = u2.getZ();\n \n   // normalize v1 in order to have (v1'|v1') = (u1|u1)\n-  double coeff = Math.sqrt (u1u1 / v1v1);\n+  double coeff = FastMath.sqrt (u1u1 / v1v1);\n   double v1x   = coeff * v1.getX();\n   double v1y   = coeff * v1.getY();\n   double v1z   = coeff * v1.getZ();\n   double v1v2   = Vector3D.dotProduct(v1, v2);\n   double coeffU = u1u2 / u1u1;\n   double coeffV = v1v2 / u1u1;\n-  double beta   = Math.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n+  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n   double alpha  = coeffU - beta * coeffV;\n   double v2x    = alpha * v1x + beta * v2.getX();\n   double v2y    = alpha * v1y + beta * v2.getY();\n   }\n \n   // compute the vectorial part\n-  c = Math.sqrt(c);\n+  c = FastMath.sqrt(c);\n   double inv = 1.0 / (c + c);\n   q1 = inv * k.getX();\n   q2 = inv * k.getY();\n     } else {\n       // general case: (u, v) defines a plane, we select\n       // the shortest possible rotation: axis orthogonal to this plane\n-      q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));\n+      q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n       double coeff = 1.0 / (2.0 * q0 * normProduct);\n       q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());\n       q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());\n     if (squaredSine == 0) {\n       return new Vector3D(1, 0, 0);\n     } else if (q0 < 0) {\n-      double inverse = 1 / Math.sqrt(squaredSine);\n+      double inverse = 1 / FastMath.sqrt(squaredSine);\n       return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n     }\n-    double inverse = -1 / Math.sqrt(squaredSine);\n+    double inverse = -1 / FastMath.sqrt(squaredSine);\n     return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n   }\n \n    */\n   public double getAngle() {\n     if ((q0 < -0.1) || (q0 > 0.1)) {\n-      return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n+      return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n     } else if (q0 < 0) {\n-      return 2 * Math.acos(-q0);\n-    }\n-    return 2 * Math.acos(q0);\n+      return 2 * FastMath.acos(-q0);\n+    }\n+    return 2 * FastMath.acos(q0);\n   }\n \n   /** Get the Cardan or Euler angles corresponding to the instance.\n         throw new CardanEulerSingularityException(true);\n       }\n       return new double[] {\n-        Math.atan2(-(v1.getY()), v1.getZ()),\n-        Math.asin(v2.getZ()),\n-        Math.atan2(-(v2.getY()), v2.getX())\n+        FastMath.atan2(-(v1.getY()), v1.getZ()),\n+        FastMath.asin(v2.getZ()),\n+        FastMath.atan2(-(v2.getY()), v2.getX())\n       };\n \n     } else if (order == RotationOrder.XZY) {\n         throw new CardanEulerSingularityException(true);\n       }\n       return new double[] {\n-        Math.atan2(v1.getZ(), v1.getY()),\n-       -Math.asin(v2.getY()),\n-        Math.atan2(v2.getZ(), v2.getX())\n+        FastMath.atan2(v1.getZ(), v1.getY()),\n+       -FastMath.asin(v2.getY()),\n+        FastMath.atan2(v2.getZ(), v2.getX())\n       };\n \n     } else if (order == RotationOrder.YXZ) {\n         throw new CardanEulerSingularityException(true);\n       }\n       return new double[] {\n-        Math.atan2(v1.getX(), v1.getZ()),\n-       -Math.asin(v2.getZ()),\n-        Math.atan2(v2.getX(), v2.getY())\n+        FastMath.atan2(v1.getX(), v1.getZ()),\n+       -FastMath.asin(v2.getZ()),\n+        FastMath.atan2(v2.getX(), v2.getY())\n       };\n \n     } else if (order == RotationOrder.YZX) {\n         throw new CardanEulerSingularityException(true);\n       }\n       return new double[] {\n-        Math.atan2(-(v1.getZ()), v1.getX()),\n-        Math.asin(v2.getX()),\n-        Math.atan2(-(v2.getZ()), v2.getY())\n+        FastMath.atan2(-(v1.getZ()), v1.getX()),\n+        FastMath.asin(v2.getX()),\n+        FastMath.atan2(-(v2.getZ()), v2.getY())\n       };\n \n     } else if (order == RotationOrder.ZXY) {\n         throw new CardanEulerSingularityException(true);\n       }\n       return new double[] {\n-        Math.atan2(-(v1.getX()), v1.getY()),\n-        Math.asin(v2.getY()),\n-        Math.atan2(-(v2.getX()), v2.getZ())\n+        FastMath.atan2(-(v1.getX()), v1.getY()),\n+        FastMath.asin(v2.getY()),\n+        FastMath.atan2(-(v2.getX()), v2.getZ())\n       };\n \n     } else if (order == RotationOrder.ZYX) {\n         throw new CardanEulerSingularityException(true);\n       }\n       return new double[] {\n-        Math.atan2(v1.getY(), v1.getX()),\n-       -Math.asin(v2.getX()),\n-        Math.atan2(v2.getY(), v2.getZ())\n+        FastMath.atan2(v1.getY(), v1.getX()),\n+       -FastMath.asin(v2.getX()),\n+        FastMath.atan2(v2.getY(), v2.getZ())\n       };\n \n     } else if (order == RotationOrder.XYX) {\n         throw new CardanEulerSingularityException(false);\n       }\n       return new double[] {\n-        Math.atan2(v1.getY(), -v1.getZ()),\n-        Math.acos(v2.getX()),\n-        Math.atan2(v2.getY(), v2.getZ())\n+        FastMath.atan2(v1.getY(), -v1.getZ()),\n+        FastMath.acos(v2.getX()),\n+        FastMath.atan2(v2.getY(), v2.getZ())\n       };\n \n     } else if (order == RotationOrder.XZX) {\n         throw new CardanEulerSingularityException(false);\n       }\n       return new double[] {\n-        Math.atan2(v1.getZ(), v1.getY()),\n-        Math.acos(v2.getX()),\n-        Math.atan2(v2.getZ(), -v2.getY())\n+        FastMath.atan2(v1.getZ(), v1.getY()),\n+        FastMath.acos(v2.getX()),\n+        FastMath.atan2(v2.getZ(), -v2.getY())\n       };\n \n     } else if (order == RotationOrder.YXY) {\n         throw new CardanEulerSingularityException(false);\n       }\n       return new double[] {\n-        Math.atan2(v1.getX(), v1.getZ()),\n-        Math.acos(v2.getY()),\n-        Math.atan2(v2.getX(), -v2.getZ())\n+        FastMath.atan2(v1.getX(), v1.getZ()),\n+        FastMath.acos(v2.getY()),\n+        FastMath.atan2(v2.getX(), -v2.getZ())\n       };\n \n     } else if (order == RotationOrder.YZY) {\n         throw new CardanEulerSingularityException(false);\n       }\n       return new double[] {\n-        Math.atan2(v1.getZ(), -v1.getX()),\n-        Math.acos(v2.getY()),\n-        Math.atan2(v2.getZ(), v2.getX())\n+        FastMath.atan2(v1.getZ(), -v1.getX()),\n+        FastMath.acos(v2.getY()),\n+        FastMath.atan2(v2.getZ(), v2.getX())\n       };\n \n     } else if (order == RotationOrder.ZXZ) {\n         throw new CardanEulerSingularityException(false);\n       }\n       return new double[] {\n-        Math.atan2(v1.getX(), -v1.getY()),\n-        Math.acos(v2.getZ()),\n-        Math.atan2(v2.getX(), v2.getY())\n+        FastMath.atan2(v1.getX(), -v1.getY()),\n+        FastMath.acos(v2.getZ()),\n+        FastMath.atan2(v2.getX(), v2.getY())\n       };\n \n     } else { // last possibility is ZYZ\n         throw new CardanEulerSingularityException(false);\n       }\n       return new double[] {\n-        Math.atan2(v1.getY(), v1.getX()),\n-        Math.acos(v2.getZ()),\n-        Math.atan2(v2.getY(), -v2.getX())\n+        FastMath.atan2(v1.getY(), v1.getX()),\n+        FastMath.acos(v2.getZ()),\n+        FastMath.atan2(v2.getY(), -v2.getX())\n       };\n \n     }\n             corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n \n       // convergence test\n-      if (Math.abs(fn1 - fn) <= threshold)\n+      if (FastMath.abs(fn1 - fn) <= threshold)\n         return o;\n \n       // prepare next iteration\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements vectors in a three-dimensional space.\n    * @see #getDelta()\n    */\n   public Vector3D(double alpha, double delta) {\n-    double cosDelta = Math.cos(delta);\n-    this.x = Math.cos(alpha) * cosDelta;\n-    this.y = Math.sin(alpha) * cosDelta;\n-    this.z = Math.sin(delta);\n+    double cosDelta = FastMath.cos(delta);\n+    this.x = FastMath.cos(alpha) * cosDelta;\n+    this.y = FastMath.sin(alpha) * cosDelta;\n+    this.z = FastMath.sin(delta);\n   }\n \n   /** Multiplicative constructor\n    * @return L<sub>1</sub> norm for the vector\n    */\n   public double getNorm1() {\n-    return Math.abs(x) + Math.abs(y) + Math.abs(z);\n+    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n   }\n \n   /** Get the L<sub>2</sub> norm for the vector.\n    * @return euclidian norm for the vector\n    */\n   public double getNorm() {\n-    return Math.sqrt (x * x + y * y + z * z);\n+    return FastMath.sqrt (x * x + y * y + z * z);\n   }\n \n   /** Get the square of the norm for the vector.\n    * @return L<sub>&infin;</sub> norm for the vector\n    */\n   public double getNormInf() {\n-    return Math.max(Math.max(Math.abs(x), Math.abs(y)), Math.abs(z));\n+    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n   }\n \n   /** Get the azimuth of the vector.\n    * @see #Vector3D(double, double)\n    */\n   public double getAlpha() {\n-    return Math.atan2(y, x);\n+    return FastMath.atan2(y, x);\n   }\n \n   /** Get the elevation of the vector.\n    * @see #Vector3D(double, double)\n    */\n   public double getDelta() {\n-    return Math.asin(z / getNorm());\n+    return FastMath.asin(z / getNorm());\n   }\n \n   /** Add a vector to the instance.\n     }\n \n     if ((x >= -threshold) && (x <= threshold)) {\n-      double inverse  = 1 / Math.sqrt(y * y + z * z);\n+      double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n       return new Vector3D(0, inverse * z, -inverse * y);\n     } else if ((y >= -threshold) && (y <= threshold)) {\n-      double inverse  = 1 / Math.sqrt(x * x + z * z);\n+      double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n       return new Vector3D(-inverse * z, 0, inverse * x);\n     }\n-    double inverse  = 1 / Math.sqrt(x * x + y * y);\n+    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n     return new Vector3D(inverse * y, -inverse * x, 0);\n \n   }\n       // the vectors are almost aligned, compute using the sine\n       Vector3D v3 = crossProduct(v1, v2);\n       if (dot >= 0) {\n-        return Math.asin(v3.getNorm() / normProduct);\n+        return FastMath.asin(v3.getNorm() / normProduct);\n       }\n-      return Math.PI - Math.asin(v3.getNorm() / normProduct);\n+      return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n     }\n \n     // the vectors are sufficiently separated to use the cosine\n-    return Math.acos(dot / normProduct);\n+    return FastMath.acos(dot / normProduct);\n \n   }\n \n    * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n    */\n   public static double distance1(Vector3D v1, Vector3D v2) {\n-    final double dx = Math.abs(v2.x - v1.x);\n-    final double dy = Math.abs(v2.y - v1.y);\n-    final double dz = Math.abs(v2.z - v1.z);\n+    final double dx = FastMath.abs(v2.x - v1.x);\n+    final double dy = FastMath.abs(v2.y - v1.y);\n+    final double dz = FastMath.abs(v2.z - v1.z);\n     return dx + dy + dz;\n   }\n \n     final double dx = v2.x - v1.x;\n     final double dy = v2.y - v1.y;\n     final double dz = v2.z - v1.z;\n-    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n+    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n   }\n \n   /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n    * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n    */\n   public static double distanceInf(Vector3D v1, Vector3D v2) {\n-    final double dx = Math.abs(v2.x - v1.x);\n-    final double dy = Math.abs(v2.y - v1.y);\n-    final double dz = Math.abs(v2.z - v1.z);\n-    return Math.max(Math.max(dx, dy), dz);\n+    final double dx = FastMath.abs(v2.x - v1.x);\n+    final double dy = FastMath.abs(v2.y - v1.y);\n+    final double dz = FastMath.abs(v2.z - v1.z);\n+    return FastMath.max(FastMath.max(dx, dy), dz);\n   }\n \n   /** Compute the square of the distance between two vectors.\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Basic implementation of RealMatrix methods regardless of the underlying storage.\n \n             /** {@inheritDoc} */\n             public void visit(final int row, final int column, final double value) {\n-                columnSum += Math.abs(value);\n+                columnSum += FastMath.abs(value);\n                 if (row == endRow) {\n-                    maxColSum = Math.max(maxColSum, columnSum);\n+                    maxColSum = FastMath.max(maxColSum, columnSum);\n                     columnSum = 0;\n                 }\n             }\n \n             /** {@inheritDoc} */\n             public double end() {\n-                return Math.sqrt(sum);\n+                return FastMath.sqrt(sum);\n             }\n \n         });\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import org.apache.commons.math.analysis.ComposableFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class provides default basic implementations for many methods in the\n             final double diff = e.getValue() - v.getEntry(e.getIndex());\n             d += diff * diff;\n         }\n-        return Math.sqrt(d);\n+        return FastMath.sqrt(d);\n     }\n \n     /** {@inheritDoc} */\n             final double value = e.getValue();\n             sum += value * value;\n         }\n-        return Math.sqrt(sum);\n+        return FastMath.sqrt(sum);\n     }\n \n     /** {@inheritDoc} */\n         Iterator<Entry> it = sparseIterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n-            norm += Math.abs(e.getValue());\n+            norm += FastMath.abs(e.getValue());\n         }\n         return norm;\n     }\n         Iterator<Entry> it = sparseIterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n-            norm = Math.max(norm, Math.abs(e.getValue()));\n+            norm = FastMath.max(norm, FastMath.abs(e.getValue()));\n         }\n         return norm;\n     }\n         Iterator<Entry> it = iterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n-            d += Math.abs(e.getValue() - v.getEntry(e.getIndex()));\n+            d += FastMath.abs(e.getValue() - v.getEntry(e.getIndex()));\n         }\n         return d;\n     }\n         Iterator<Entry> it = iterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n-            d += Math.abs(e.getValue() - v[e.getIndex()]);\n+            d += FastMath.abs(e.getValue() - v[e.getIndex()]);\n         }\n         return d;\n     }\n         Iterator<Entry> it = iterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n-            d = Math.max(Math.abs(e.getValue() - v.getEntry(e.getIndex())), d);\n+            d = FastMath.max(FastMath.abs(e.getValue() - v.getEntry(e.getIndex())), d);\n         }\n         return d;\n     }\n         Iterator<Entry> it = iterator();\n         Entry e;\n         while (it.hasNext() && (e = it.next()) != null) {\n-            d = Math.max(Math.abs(e.getValue() - v[e.getIndex()]), d);\n+            d = FastMath.max(FastMath.abs(e.getValue() - v[e.getIndex()]), d);\n         }\n         return d;\n     }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements the {@link RealVector} interface with a double array.\n     @Override\n     public RealVector mapPowToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.pow(data[i], d);\n+            data[i] = FastMath.pow(data[i], d);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapExpToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.exp(data[i]);\n+            data[i] = FastMath.exp(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapExpm1ToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.expm1(data[i]);\n+            data[i] = FastMath.expm1(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapLogToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.log(data[i]);\n+            data[i] = FastMath.log(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapLog10ToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.log10(data[i]);\n+            data[i] = FastMath.log10(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapLog1pToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.log1p(data[i]);\n+            data[i] = FastMath.log1p(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapCoshToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.cosh(data[i]);\n+            data[i] = FastMath.cosh(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapSinhToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.sinh(data[i]);\n+            data[i] = FastMath.sinh(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapTanhToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.tanh(data[i]);\n+            data[i] = FastMath.tanh(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapCosToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.cos(data[i]);\n+            data[i] = FastMath.cos(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapSinToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.sin(data[i]);\n+            data[i] = FastMath.sin(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapTanToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.tan(data[i]);\n+            data[i] = FastMath.tan(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapAcosToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.acos(data[i]);\n+            data[i] = FastMath.acos(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapAsinToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.asin(data[i]);\n+            data[i] = FastMath.asin(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapAtanToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.atan(data[i]);\n+            data[i] = FastMath.atan(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapAbsToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.abs(data[i]);\n+            data[i] = FastMath.abs(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapSqrtToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.sqrt(data[i]);\n+            data[i] = FastMath.sqrt(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapCbrtToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.cbrt(data[i]);\n+            data[i] = FastMath.cbrt(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapCeilToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.ceil(data[i]);\n+            data[i] = FastMath.ceil(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapFloorToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.floor(data[i]);\n+            data[i] = FastMath.floor(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapRintToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.rint(data[i]);\n+            data[i] = FastMath.rint(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapSignumToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.signum(data[i]);\n+            data[i] = FastMath.signum(data[i]);\n         }\n         return this;\n     }\n     @Override\n     public RealVector mapUlpToSelf() {\n         for (int i = 0; i < data.length; i++) {\n-            data[i] = Math.ulp(data[i]);\n+            data[i] = FastMath.ulp(data[i]);\n         }\n         return this;\n     }\n         for (double a : data) {\n             sum += a * a;\n         }\n-        return Math.sqrt(sum);\n+        return FastMath.sqrt(sum);\n     }\n \n     /** {@inheritDoc} */\n     public double getL1Norm() {\n         double sum = 0;\n         for (double a : data) {\n-            sum += Math.abs(a);\n+            sum += FastMath.abs(a);\n         }\n         return sum;\n     }\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max = Math.max(max, Math.abs(a));\n+            max = FastMath.max(max, FastMath.abs(a));\n         }\n         return max;\n     }\n                 final double delta = data[i] - v.getEntry(i);\n                 sum += delta * delta;\n             }\n-            return Math.sqrt(sum);\n+            return FastMath.sqrt(sum);\n         }\n     }\n \n             final double delta = data[i] - v[i];\n             sum += delta * delta;\n         }\n-        return Math.sqrt(sum);\n+        return FastMath.sqrt(sum);\n     }\n \n    /**\n             double sum = 0;\n             for (int i = 0; i < data.length; ++i) {\n                 final double delta = data[i] - v.getEntry(i);\n-                sum += Math.abs(delta);\n+                sum += FastMath.abs(delta);\n             }\n             return sum;\n         }\n         double sum = 0;\n         for (int i = 0; i < data.length; ++i) {\n             final double delta = data[i] - v[i];\n-            sum += Math.abs(delta);\n+            sum += FastMath.abs(delta);\n         }\n         return sum;\n     }\n             double max = 0;\n             for (int i = 0; i < data.length; ++i) {\n                 final double delta = data[i] - v.getEntry(i);\n-                max = Math.max(max, Math.abs(delta));\n+                max = FastMath.max(max, FastMath.abs(delta));\n             }\n             return max;\n         }\n         double max = 0;\n         for (int i = 0; i < data.length; ++i) {\n             final double delta = data[i] - v[i];\n-            max = Math.max(max, Math.abs(delta));\n+            max = FastMath.max(max, FastMath.abs(delta));\n         }\n         return max;\n     }\n--- a/src/main/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n+++ b/src/main/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.util.FastMath;\n+\n \n /**\n  * Class transforming any matrix to bi-diagonal shape.\n \n         final int m = matrix.getRowDimension();\n         final int n = matrix.getColumnDimension();\n-        final int p = Math.min(m, n);\n+        final int p = FastMath.min(m, n);\n         householderVectors = matrix.getData();\n         main      = new double[p];\n         secondary = new double[p - 1];\n                 xNormSqr += c * c;\n             }\n             final double[] hK = householderVectors[k];\n-            final double a = (hK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            final double a = (hK[k] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n             main[k] = a;\n             if (a != 0.0) {\n                 hK[k] -= a;\n                     final double c = hK[j];\n                     xNormSqr += c * c;\n                 }\n-                final double b = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                final double b = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n                 secondary[k] = b;\n                 if (b != 0.0) {\n                     hK[k + 1] -= b;\n                 final double c = hK[j];\n                 xNormSqr += c * c;\n             }\n-            final double a = (hK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            final double a = (hK[k] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n             main[k] = a;\n             if (a != 0.0) {\n                 hK[k] -= a;\n                     final double c = householderVectors[i][k];\n                     xNormSqr += c * c;\n                 }\n-                final double b = (hKp1[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                final double b = (hKp1[k] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n                 secondary[k] = b;\n                 if (b != 0.0) {\n                     hKp1[k] -= b;\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Cache-friendly implementation of FieldMatrix using a flat arrays to store\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n-            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n \n                 // allocate new block\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n-            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n                 blocks[blockIndex] = buildArray(field, iHeight * jWidth);\n                 ++blockIndex;\n                     final T[] outBlock = out.blocks[blockIndex];\n                     final T[] tBlock   = blocks[blockIndex];\n                     final int      pStart   = iBlock * BLOCK_SIZE;\n-                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n-                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     int k = 0;\n                     for (int p = pStart; p < pEnd; ++p) {\n                         for (int q = qStart; q < qEnd; ++q) {\n                     final T[] outBlock = out.blocks[blockIndex];\n                     final T[] tBlock   = blocks[blockIndex];\n                     final int      pStart   = iBlock * BLOCK_SIZE;\n-                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n-                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     int k = 0;\n                     for (int p = pStart; p < pEnd; ++p) {\n                         for (int q = qStart; q < qEnd; ++q) {\n             for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n \n                 final int pStart = iBlock * BLOCK_SIZE;\n-                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n \n                 for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n \n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n \n                     // select current block\n                     final T[] outBlock = out.blocks[blockIndex];\n         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n \n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n \n             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                 final int jWidth = out.blockWidth(jBlock);\n \n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             int regularPos   = 0;\n             int lastPos      = 0;\n             for (int p = pStart; p < pEnd; ++p) {\n         for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n             final int iHeight  = blockHeight(iBlock);\n             final int firstRow = iBlock * BLOCK_SIZE;\n-            final int iStart   = Math.max(row,    firstRow);\n-            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+            final int iStart   = FastMath.max(row,    firstRow);\n+            final int iEnd     = FastMath.min(endRow + 1, firstRow + iHeight);\n \n             for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n                 final int jWidth      = blockWidth(jBlock);\n                 final int firstColumn = jBlock * BLOCK_SIZE;\n-                final int jStart      = Math.max(column,    firstColumn);\n-                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jStart      = FastMath.max(column,    firstColumn);\n+                final int jEnd        = FastMath.min(endColumn + 1, firstColumn + jWidth);\n                 final int jLength     = jEnd - jStart;\n \n                 // handle one block, row by row\n                 final T[] outBlock = out.blocks[blockIndex];\n                 final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                 final int      pStart   = iBlock * BLOCK_SIZE;\n-                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                 final int      qStart   = jBlock * BLOCK_SIZE;\n-                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n                     final int lInc = pEnd - pStart;\n         // perform multiplication block-wise, to ensure good cache behavior\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final T[] block  = blocks[iBlock * blockColumns + jBlock];\n                 final int      qStart = jBlock * BLOCK_SIZE;\n-                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int      qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n                     T sum = zero;\n             final int jWidth3 = jWidth2 + jWidth;\n             final int jWidth4 = jWidth3 + jWidth;\n             final int qStart = jBlock * BLOCK_SIZE;\n-            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n             for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n                 final T[] block  = blocks[iBlock * blockColumns + jBlock];\n                 final int      pStart = iBlock * BLOCK_SIZE;\n-                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                final int      pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n                 for (int q = qStart; q < qEnd; ++q) {\n                     int k = q - qStart;\n                     T sum = zero;\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - pStart) * jWidth;\n                     for (int q = qStart; q < qEnd; ++q) {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - pStart) * jWidth;\n                     for (int q = qStart; q < qEnd; ++q) {\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int q0     = jBlock * BLOCK_SIZE;\n-                    final int qStart = Math.max(startColumn, q0);\n-                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final int qStart = FastMath.max(startColumn, q0);\n+                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - p0) * jWidth + qStart - q0;\n                     for (int q = qStart; q < qEnd; ++q) {\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int q0     = jBlock * BLOCK_SIZE;\n-                    final int qStart = Math.max(startColumn, q0);\n-                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final int qStart = FastMath.max(startColumn, q0);\n+                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - p0) * jWidth + qStart - q0;\n                     for (int q = qStart; q < qEnd; ++q) {\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final T[] block = blocks[blockIndex];\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final T[] block = blocks[blockIndex];\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                 final int jWidth = blockWidth(jBlock);\n                 final int q0     = jBlock * BLOCK_SIZE;\n-                final int qStart = Math.max(startColumn, q0);\n-                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final int qStart = FastMath.max(startColumn, q0);\n+                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final T[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n                     int k = (p - p0) * jWidth + qStart - q0;\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                 final int jWidth = blockWidth(jBlock);\n                 final int q0     = jBlock * BLOCK_SIZE;\n-                final int qStart = Math.max(startColumn, q0);\n-                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final int qStart = FastMath.max(startColumn, q0);\n+                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final T[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n                     int k = (p - p0) * jWidth + qStart - q0;\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Cache-friendly implementation of RealMatrix using a flat arrays to store\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n-            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n \n                 // allocate new block\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n-            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n                 blocks[blockIndex] = new double[iHeight * jWidth];\n                 ++blockIndex;\n                     final double[] outBlock = out.blocks[blockIndex];\n                     final double[] tBlock   = blocks[blockIndex];\n                     final int      pStart   = iBlock * BLOCK_SIZE;\n-                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n-                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     int k = 0;\n                     for (int p = pStart; p < pEnd; ++p) {\n                         for (int q = qStart; q < qEnd; ++q) {\n                     final double[] outBlock = out.blocks[blockIndex];\n                     final double[] tBlock   = blocks[blockIndex];\n                     final int      pStart   = iBlock * BLOCK_SIZE;\n-                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n-                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     int k = 0;\n                     for (int p = pStart; p < pEnd; ++p) {\n                         for (int q = qStart; q < qEnd; ++q) {\n             for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n \n                 final int pStart = iBlock * BLOCK_SIZE;\n-                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n \n                 for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n \n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n \n                     // select current block\n                     final double[] outBlock = out.blocks[blockIndex];\n         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n \n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n \n             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                 final int jWidth = out.blockWidth(jBlock);\n \n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             int regularPos   = 0;\n             int lastPos      = 0;\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int j = 0; j < jWidth; ++j) {\n                     double sum = 0;\n                     for (int i = 0; i < iHeight; ++i) {\n-                        sum += Math.abs(block[i * jWidth + j]);\n+                        sum += FastMath.abs(block[i * jWidth + j]);\n                     }\n                     colSums[j] += sum;\n                 }\n             }\n             for (int j = 0; j < jWidth; ++j) {\n-                maxColSum = Math.max(maxColSum, colSums[j]);\n+                maxColSum = FastMath.max(maxColSum, colSums[j]);\n             }\n         }\n         return maxColSum;\n                 sum2 += entry * entry;\n             }\n         }\n-        return Math.sqrt(sum2);\n+        return FastMath.sqrt(sum2);\n     }\n \n     /** {@inheritDoc} */\n         for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n             final int iHeight  = blockHeight(iBlock);\n             final int firstRow = iBlock * BLOCK_SIZE;\n-            final int iStart   = Math.max(row,    firstRow);\n-            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+            final int iStart   = FastMath.max(row,    firstRow);\n+            final int iEnd     = FastMath.min(endRow + 1, firstRow + iHeight);\n \n             for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n                 final int jWidth      = blockWidth(jBlock);\n                 final int firstColumn = jBlock * BLOCK_SIZE;\n-                final int jStart      = Math.max(column,    firstColumn);\n-                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jStart      = FastMath.max(column,    firstColumn);\n+                final int jEnd        = FastMath.min(endColumn + 1, firstColumn + jWidth);\n                 final int jLength     = jEnd - jStart;\n \n                 // handle one block, row by row\n                 final double[] outBlock = out.blocks[blockIndex];\n                 final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                 final int      pStart   = iBlock * BLOCK_SIZE;\n-                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                 final int      qStart   = jBlock * BLOCK_SIZE;\n-                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n                     final int lInc = pEnd - pStart;\n         // perform multiplication block-wise, to ensure good cache behavior\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final double[] block  = blocks[iBlock * blockColumns + jBlock];\n                 final int      qStart = jBlock * BLOCK_SIZE;\n-                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int      qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n                     double sum = 0;\n             final int jWidth3 = jWidth2 + jWidth;\n             final int jWidth4 = jWidth3 + jWidth;\n             final int qStart = jBlock * BLOCK_SIZE;\n-            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n             for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n                 final double[] block  = blocks[iBlock * blockColumns + jBlock];\n                 final int      pStart = iBlock * BLOCK_SIZE;\n-                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                final int      pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n                 for (int q = qStart; q < qEnd; ++q) {\n                     int k = q - qStart;\n                     double sum = 0;\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - pStart) * jWidth;\n                     for (int q = qStart; q < qEnd; ++q) {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - pStart) * jWidth;\n                     for (int q = qStart; q < qEnd; ++q) {\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int q0     = jBlock * BLOCK_SIZE;\n-                    final int qStart = Math.max(startColumn, q0);\n-                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final int qStart = FastMath.max(startColumn, q0);\n+                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - p0) * jWidth + qStart - q0;\n                     for (int q = qStart; q < qEnd; ++q) {\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int q0     = jBlock * BLOCK_SIZE;\n-                    final int qStart = Math.max(startColumn, q0);\n-                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final int qStart = FastMath.max(startColumn, q0);\n+                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - p0) * jWidth + qStart - q0;\n                     for (int q = qStart; q < qEnd; ++q) {\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final double[] block = blocks[blockIndex];\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final double[] block = blocks[blockIndex];\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                 final int jWidth = blockWidth(jBlock);\n                 final int q0     = jBlock * BLOCK_SIZE;\n-                final int qStart = Math.max(startColumn, q0);\n-                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final int qStart = FastMath.max(startColumn, q0);\n+                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final double[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n                     int k = (p - p0) * jWidth + qStart - q0;\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n-            final int pStart = Math.max(startRow, p0);\n-            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pStart = FastMath.max(startRow, p0);\n+            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                 final int jWidth = blockWidth(jBlock);\n                 final int q0     = jBlock * BLOCK_SIZE;\n-                final int qStart = Math.max(startColumn, q0);\n-                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final int qStart = FastMath.max(startColumn, q0);\n+                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final double[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n                     int k = (p - p0) * jWidth + qStart - q0;\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n                 final double lIJ = lI[j];\n                 final double lJI = lJ[i];\n                 final double maxDelta =\n-                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n-                if (Math.abs(lIJ - lJI) > maxDelta) {\n+                    relativeSymmetryThreshold * FastMath.max(FastMath.abs(lIJ), FastMath.abs(lJI));\n+                if (FastMath.abs(lIJ - lJI) > maxDelta) {\n                     throw new NotSymmetricMatrixException();\n                 }\n                 lJ[i] = 0;\n                 throw new NotPositiveDefiniteMatrixException();\n             }\n \n-            ltI[i] = Math.sqrt(ltI[i]);\n+            ltI[i] = FastMath.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];\n \n             for (int q = order - 1; q > i; --q) {\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Calculates the eigen decomposition of a real <strong>symmetric</strong>\n             for (int j = i + 1; j < columns; ++j) {\n                 final double mij = matrix.getEntry(i, j);\n                 final double mji = matrix.getEntry(j, i);\n-                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math\n+                if (FastMath.abs(mij - mji) > (FastMath.max(FastMath.abs(mij), Math\n                         .abs(mji)) * eps)) {\n                     return false;\n                 }\n         // Determine the largest main and secondary value in absolute term.\n         double maxAbsoluteValue=0.0;\n         for (int i = 0; i < n; i++) {\n-            if (Math.abs(realEigenvalues[i])>maxAbsoluteValue) {\n-                maxAbsoluteValue=Math.abs(realEigenvalues[i]);\n-            }\n-            if (Math.abs(e[i])>maxAbsoluteValue) {\n-                maxAbsoluteValue=Math.abs(e[i]);\n+            if (FastMath.abs(realEigenvalues[i])>maxAbsoluteValue) {\n+                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n+            }\n+            if (FastMath.abs(e[i])>maxAbsoluteValue) {\n+                maxAbsoluteValue=FastMath.abs(e[i]);\n             }\n         }\n         // Make null any main and secondary value too small to be significant\n         if (maxAbsoluteValue!=0.0) {\n             for (int i=0; i < n; i++) {\n-                if (Math.abs(realEigenvalues[i])<=MathUtils.EPSILON*maxAbsoluteValue) {\n+                if (FastMath.abs(realEigenvalues[i])<=MathUtils.EPSILON*maxAbsoluteValue) {\n                     realEigenvalues[i]=0.0;\n                 }\n-                if (Math.abs(e[i])<=MathUtils.EPSILON*maxAbsoluteValue) {\n+                if (FastMath.abs(e[i])<=MathUtils.EPSILON*maxAbsoluteValue) {\n                     e[i]=0.0;\n                 }\n             }\n             int m;\n             do {\n                 for (m = j; m < n - 1; m++) {\n-                    double delta = Math.abs(realEigenvalues[m]) + Math.abs(realEigenvalues[m + 1]);\n-                    if (Math.abs(e[m]) + delta == delta) {\n+                    double delta = FastMath.abs(realEigenvalues[m]) + FastMath.abs(realEigenvalues[m + 1]);\n+                    if (FastMath.abs(e[m]) + delta == delta) {\n                         break;\n                     }\n                 }\n                                 new MaxIterationsExceededException(maxIter));\n                     its++;\n                     double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n-                    double t = Math.sqrt(1 + q * q);\n+                    double t = FastMath.sqrt(1 + q * q);\n                     if (q < 0.0) {\n                         q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\n                     } else {\n                     for (i = m - 1; i >= j; i--) {\n                         double p = s * e[i];\n                         double h = c * e[i];\n-                        if (Math.abs(p) >= Math.abs(q)) {\n+                        if (FastMath.abs(p) >= FastMath.abs(q)) {\n                             c = q / p;\n-                            t = Math.sqrt(c * c + 1.0);\n+                            t = FastMath.sqrt(c * c + 1.0);\n                             e[i + 1] = p * t;\n                             s = 1.0 / t;\n                             c = c * s;\n                         } else {\n                             s = p / q;\n-                            t = Math.sqrt(s * s + 1.0);\n+                            t = FastMath.sqrt(s * s + 1.0);\n                             e[i + 1] = q * t;\n                             c = 1.0 / t;\n                             s = s * c;\n         // Determine the largest eigen value in absolute term.\n         maxAbsoluteValue=0.0;\n         for (int i = 0; i < n; i++) {\n-            if (Math.abs(realEigenvalues[i])>maxAbsoluteValue) {\n-                maxAbsoluteValue=Math.abs(realEigenvalues[i]);\n+            if (FastMath.abs(realEigenvalues[i])>maxAbsoluteValue) {\n+                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n             }\n         }\n         // Make null any eigen value too small to be significant\n         if (maxAbsoluteValue!=0.0) {\n             for (int i=0; i < n; i++) {\n-                if (Math.abs(realEigenvalues[i])<MathUtils.EPSILON*maxAbsoluteValue) {\n+                if (FastMath.abs(realEigenvalues[i])<MathUtils.EPSILON*maxAbsoluteValue) {\n                     realEigenvalues[i]=0.0;\n                 }\n             }\n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Calculates the LUP-decomposition of a square matrix.\n                 luRow[col] = sum;\n \n                 // maintain best permutation choice\n-                if (Math.abs(sum) > largest) {\n-                    largest = Math.abs(sum);\n+                if (FastMath.abs(sum) > largest) {\n+                    largest = FastMath.abs(sum);\n                     max = row;\n                 }\n             }\n \n             // Singularity check\n-            if (Math.abs(lu[max][col]) < singularityThreshold) {\n+            if (FastMath.abs(lu[max][col]) < singularityThreshold) {\n                 singular = true;\n                 return;\n             }\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.\n      * @since 2.1\n      */\n     protected boolean isDefaultValue(double value) {\n-        return Math.abs(value) < epsilon;\n+        return FastMath.abs(value) < epsilon;\n     }\n \n     /** {@inheritDoc} */\n                 res += value * value;\n             }\n         }\n-        return Math.sqrt(res);\n+        return FastMath.sqrt(res);\n     }\n \n     /** {@inheritDoc} */\n             double delta = entries.get(i) - v[i];\n             res += delta * delta;\n         }\n-        return Math.sqrt(res);\n+        return FastMath.sqrt(res);\n     }\n \n     /** {@inheritDoc} */\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n             max += delta;\n         }\n         iter = v.getEntries().iterator();\n             iter.advance();\n             int key = iter.key();\n             if (!entries.containsKey(key)) {\n-                double delta = Math.abs(iter.value());\n-                max +=  Math.abs(delta);\n+                double delta = FastMath.abs(iter.value());\n+                max +=  FastMath.abs(delta);\n             }\n         }\n         return max;\n         checkVectorDimensions(v.length);\n         double max = 0;\n         for (int i = 0; i < v.length; i++) {\n-            double delta = Math.abs(getEntry(i) - v[i]);\n+            double delta = FastMath.abs(getEntry(i) - v[i]);\n             max += delta;\n         }\n         return max;\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n             if (delta > max) {\n                 max = delta;\n             }\n         checkVectorDimensions(v.length);\n         double max = 0;\n         for (int i = 0; i < v.length; i++) {\n-            double delta = Math.abs(getEntry(i) - v[i]);\n+            double delta = FastMath.abs(getEntry(i) - v[i]);\n             if (delta > max) {\n                 max = delta;\n             }\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n         final int m = matrix.getRowDimension();\n         final int n = matrix.getColumnDimension();\n         qrt = matrix.transpose().getData();\n-        rDiag = new double[Math.min(m, n)];\n+        rDiag = new double[FastMath.min(m, n)];\n         cachedQ  = null;\n         cachedQT = null;\n         cachedR  = null;\n          * reflectors by repeating the following operations to each minor\n          * A(minor,minor) of A:\n          */\n-        for (int minor = 0; minor < Math.min(m, n); minor++) {\n+        for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n \n             final double[] qrtMinor = qrt[minor];\n \n                 final double c = qrtMinor[row];\n                 xNormSqr += c * c;\n             }\n-            final double a = (qrtMinor[minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            final double a = (qrtMinor[minor] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n             rDiag[minor] = a;\n \n             if (a != 0.0) {\n             cachedR = MatrixUtils.createRealMatrix(m, n);\n \n             // copy the diagonal from rDiag and the upper triangle of qr\n-            for (int row = Math.min(m, n) - 1; row >= 0; row--) {\n+            for (int row = FastMath.min(m, n) - 1; row >= 0; row--) {\n                 cachedR.setEntry(row, row, rDiag[row]);\n                 for (int col = row + 1; col < n; col++) {\n                     cachedR.setEntry(row, col, qrt[col][row]);\n              * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in\n              * succession to the result\n              */\n-            for (int minor = m - 1; minor >= Math.min(m, n); minor--) {\n+            for (int minor = m - 1; minor >= FastMath.min(m, n); minor--) {\n                 cachedQT.setEntry(minor, minor, 1.0);\n             }\n \n-            for (int minor = Math.min(m, n)-1; minor >= 0; minor--){\n+            for (int minor = FastMath.min(m, n)-1; minor >= 0; minor--){\n                 final double[] qrtMinor = qrt[minor];\n                 cachedQT.setEntry(minor, minor, 1.0);\n                 if (qrtMinor[minor] != 0.0) {\n             final int m = qrt[0].length;\n             cachedH = MatrixUtils.createRealMatrix(m, n);\n             for (int i = 0; i < m; ++i) {\n-                for (int j = 0; j < Math.min(i + 1, n); ++j) {\n+                for (int j = 0; j < FastMath.min(i + 1, n); ++j) {\n                     cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);\n                 }\n             }\n             final double[] y = b.clone();\n \n             // apply Householder transforms to solve Q.y = b\n-            for (int minor = 0; minor < Math.min(m, n); minor++) {\n+            for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n \n                 final double[] qrtMinor = qrt[minor];\n                 double dotProduct = 0;\n \n             for (int kBlock = 0; kBlock < cBlocks; ++kBlock) {\n                 final int kStart = kBlock * blockSize;\n-                final int kEnd   = Math.min(kStart + blockSize, columns);\n+                final int kEnd   = FastMath.min(kStart + blockSize, columns);\n                 final int kWidth = kEnd - kStart;\n \n                 // get the right hand side vector\n                 b.copySubMatrix(0, m - 1, kStart, kEnd - 1, y);\n \n                 // apply Householder transforms to solve Q.y = b\n-                for (int minor = 0; minor < Math.min(m, n); minor++) {\n+                for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n                     final double[] qrtMinor = qrt[minor];\n                     final double factor     = 1.0 / (rDiag[minor] * qrtMinor[minor]);\n \n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Calculates the compact Singular Value Decomposition of a matrix.\n             cachedV = eigenDecomposition.getV().getSubMatrix(0,n-1,0,p-1);\n         }\n         for (int i = 0; i < p; i++) {\n-            singularValues[i] = Math.sqrt(Math.abs(singularValues[i]));\n+            singularValues[i] = FastMath.sqrt(FastMath.abs(singularValues[i]));\n         }\n         // Up to this point, U and V are computed independently of each other.\n         // There still a sign indetermination of each column of, say, U.\n     /** {@inheritDoc} */\n     public int getRank() throws IllegalStateException {\n \n-        final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);\n+        final double threshold = FastMath.max(m, n) * FastMath.ulp(singularValues[0]);\n \n         for (int i = singularValues.length - 1; i >= 0; --i) {\n             if (singularValues[i] > threshold) {\n--- a/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+++ b/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n \n import java.util.Arrays;\n \n+import org.apache.commons.math.util.FastMath;\n+\n \n /**\n  * Class transforming a symmetrical matrix to tridiagonal shape.\n                 final double c = hK[j];\n                 xNormSqr += c * c;\n             }\n-            final double a = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            final double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n             secondary[k] = a;\n             if (a != 0.0) {\n                 // apply Householder transform from left and right simultaneously\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.events.EventState;\n import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Base class managing common boilerplate for all integrators.\n                     LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, ode.getDimension(), y.length);\n         }\n \n-        if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+        if (FastMath.abs(t - t0) <= 1.0e-12 * FastMath.max(FastMath.abs(t0), FastMath.abs(t))) {\n             throw new IntegratorException(\n                     LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n-                    Math.abs(t - t0));\n+                    FastMath.abs(t - t0));\n         }\n \n     }\n         }\n         newManager.addEventHandler(new EndTimeChecker(endTime),\n                                    Double.POSITIVE_INFINITY,\n-                                   Math.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),\n+                                   FastMath.ulp(FastMath.max(FastMath.abs(startTime), FastMath.abs(endTime))),\n                                    100);\n         return newManager;\n     }\n--- a/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class stores all information provided by an ODE integrator\n       final double previous = lastInterpolator.getPreviousTime();\n       final double step = current - previous;\n       final double gap = model.getInitialTime() - current;\n-      if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n+      if (FastMath.abs(gap) > 1.0e-3 * FastMath.abs(step)) {\n         throw MathRuntimeException.createIllegalArgumentException(\n-              LocalizedFormats.HOLE_BETWEEN_MODELS_TIME_RANGES, Math.abs(gap));\n+              LocalizedFormats.HOLE_BETWEEN_MODELS_TIME_RANGES, FastMath.abs(gap));\n       }\n \n     }\n         final StepInterpolator sMed = steps.get(iMed);\n         final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n \n-        if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {\n+        if ((FastMath.abs(tMed - tMin) < 1e-6) || (FastMath.abs(tMax - tMed) < 1e-6)) {\n           // too close to the bounds, we estimate using a simple dichotomy\n           index = iMed;\n         } else {\n                                     (dt1 * dt3 * d13) * iMed +\n                                     (dt1 * dt2 * d12) * iMin) /\n                                    (d12 * d23 * d13);\n-          index = (int) Math.rint(iLagrange);\n+          index = (int) FastMath.rint(iLagrange);\n         }\n \n         // force the next size reduction to be at least one tenth\n-        final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n-        final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n+        final int low  = FastMath.max(iMin + 1, (9 * iMin + iMax) / 10);\n+        final int high = FastMath.min(iMax - 1, (iMin + 9 * iMax) / 10);\n         if (index < low) {\n           index = low;\n         } else if (index > high) {\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class is the base class for multistep integrators for Ordinary\n         // set the default values of the algorithm control parameters\n         setSafety(0.9);\n         setMinReduction(0.2);\n-        setMaxGrowth(Math.pow(2.0, -exp));\n+        setMaxGrowth(FastMath.pow(2.0, -exp));\n \n     }\n \n         // set the default values of the algorithm control parameters\n         setSafety(0.9);\n         setMinReduction(0.2);\n-        setMaxGrowth(Math.pow(2.0, -exp));\n+        setMaxGrowth(FastMath.pow(2.0, -exp));\n \n     }\n \n      * @return grow/shrink factor for next step\n      */\n     protected double computeStepGrowShrinkFactor(final double error) {\n-        return Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n+        return FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n     }\n \n     /** Transformer used to convert the first step to Nordsieck representation. */\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n /** This class handles the state for one {@link EventHandler\n  * event handler} during integration steps.\n                       final double convergence, final int maxIterationCount) {\n         this.handler           = handler;\n         this.maxCheckInterval  = maxCheckInterval;\n-        this.convergence       = Math.abs(convergence);\n+        this.convergence       = FastMath.abs(convergence);\n         this.maxIterationCount = maxIterationCount;\n \n         // some dummy values ...\n \n             forward = interpolator.isForward();\n             final double t1 = interpolator.getCurrentTime();\n-            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n+            final int    n  = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(t1 - t0) / maxCheckInterval));\n             final double h  = (t1 - t0) / n;\n \n             double ta = t0;\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n-                    if ((Math.abs(root - ta) <= convergence) &&\n-                         (Math.abs(root - previousEventTime) <= convergence)) {\n+                    if ((FastMath.abs(root - ta) <= convergence) &&\n+                         (FastMath.abs(root - previousEventTime) <= convergence)) {\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n                     } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n+                               (FastMath.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                        if (pendingEvent && (FastMath.abs(t1 - pendingEventTime) <= convergence)) {\n                             // we were already waiting for this event which was\n                             // found during a previous call for a step that was\n                             // rejected, this step must now be accepted since it\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n                 // evaluate error using the last term of the Taylor expansion\n                 error = 0;\n                 for (int i = 0; i < mainSetDimension; ++i) {\n-                    final double yScale = Math.abs(y[i]);\n+                    final double yScale = FastMath.abs(y[i]);\n                     final double tol = (vecAbsoluteTolerance == null) ?\n                                        (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                                        (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n                     final double ratio  = nordsieck.getEntry(lastRow, i) / tol;\n                     error += ratio * ratio;\n                 }\n-                error = Math.sqrt(error / mainSetDimension);\n+                error = FastMath.sqrt(error / mainSetDimension);\n \n                 if (error <= 1.0) {\n \n                     interpolatorTmp.storeTime(stepEnd);\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n-                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                        if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n                             // we cannot simply truncate the step, reject the current computation\n                             // and let the loop compute another state with the truncated step.\n                             // it is so small (much probably exactly 0 due to limited accuracy)\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n                     interpolatorTmp.storeTime(stepEnd);\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n-                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                        if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n                             // we cannot simply truncate the step, reject the current computation\n                             // and let the loop compute another state with the truncated step.\n                             // it is so small (much probably exactly 0 due to limited accuracy)\n             for (int i = 0; i < after.length; ++i) {\n                 after[i] += previous[i] + scaled[i];\n                 if (i < mainSetDimension) {\n-                    final double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\n+                    final double yScale = FastMath.max(FastMath.abs(previous[i]), FastMath.abs(after[i]));\n                     final double tol = (vecAbsoluteTolerance == null) ?\n                                        (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                                        (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n                 }\n             }\n \n-            return Math.sqrt(error / mainSetDimension);\n+            return FastMath.sqrt(error / mainSetDimension);\n \n         }\n     }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n import org.apache.commons.math.ode.ExtendedFirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This abstract class holds the common part of all adaptive\n \n     super(name);\n \n-    this.minStep     = Math.abs(minStep);\n-    this.maxStep     = Math.abs(maxStep);\n+    this.minStep     = FastMath.abs(minStep);\n+    this.maxStep     = FastMath.abs(maxStep);\n     this.initialStep = -1.0;\n \n     this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n     }\n \n     double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n-               1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n+               1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));\n     if (! forward) {\n       h = -h;\n     }\n       ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n       yDDotOnScale += ratio * ratio;\n     }\n-    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n+    yDDotOnScale = FastMath.sqrt(yDDotOnScale) / h;\n \n     // step size is computed such that\n     // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n-    final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n+    final double maxInv2 = FastMath.max(FastMath.sqrt(yDotOnScale2), yDDotOnScale);\n     final double h1 = (maxInv2 < 1.0e-15) ?\n-                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n-                      Math.pow(0.01 / maxInv2, 1.0 / order);\n-    h = Math.min(100.0 * Math.abs(h), h1);\n-    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n+                      FastMath.max(1.0e-6, 0.001 * FastMath.abs(h)) :\n+                      FastMath.pow(0.01 / maxInv2, 1.0 / order);\n+    h = FastMath.min(100.0 * FastMath.abs(h), h1);\n+    h = FastMath.max(h, 1.0e-12 * FastMath.abs(t0));  // avoids cancellation when computing t1 - t0\n     if (h < getMinStep()) {\n       h = getMinStep();\n     }\n     throws IntegratorException {\n \n       double filteredH = h;\n-      if (Math.abs(h) < minStep) {\n+      if (FastMath.abs(h) < minStep) {\n           if (acceptSmall) {\n               filteredH = forward ? minStep : -minStep;\n           } else {\n               throw new IntegratorException(\n                       LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,\n-                      minStep, Math.abs(h));\n+                      minStep, FastMath.abs(h));\n           }\n       }\n \n   /** Reset internal state to dummy values. */\n   protected void resetInternalState() {\n     stepStart = Double.NaN;\n-    stepSize  = Math.sqrt(minStep * maxStep);\n+    stepSize  = FastMath.sqrt(minStep * maxStep);\n   }\n \n   /** Get the minimal step.\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n  */\n \n package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n                               E4 * yDotK[3][j] +  E5 * yDotK[4][j] +\n                               E6 * yDotK[5][j] +  E7 * yDotK[6][j];\n \n-        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+        final double yScale = FastMath.max(FastMath.abs(y0[j]), FastMath.abs(y1[j]));\n         final double tol = (vecAbsoluteTolerance == null) ?\n                            (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                                (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n \n     }\n \n-    return Math.sqrt(error / mainSetDimension);\n+    return FastMath.sqrt(error / mainSetDimension);\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n  */\n \n package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n \n   /** Time steps Butcher array. */\n   private static final double[] STATIC_C = {\n-    (12.0 - 2.0 * Math.sqrt(6.0)) / 135.0, (6.0 - Math.sqrt(6.0)) / 45.0, (6.0 - Math.sqrt(6.0)) / 30.0,\n-    (6.0 + Math.sqrt(6.0)) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n+    (12.0 - 2.0 * FastMath.sqrt(6.0)) / 135.0, (6.0 - FastMath.sqrt(6.0)) / 45.0, (6.0 - FastMath.sqrt(6.0)) / 30.0,\n+    (6.0 + FastMath.sqrt(6.0)) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n     6.0/7.0, 1.0, 1.0\n   };\n \n   private static final double[][] STATIC_A = {\n \n     // k2\n-    {(12.0 - 2.0 * Math.sqrt(6.0)) / 135.0},\n+    {(12.0 - 2.0 * FastMath.sqrt(6.0)) / 135.0},\n \n     // k3\n-    {(6.0 - Math.sqrt(6.0)) / 180.0, (6.0 - Math.sqrt(6.0)) / 60.0},\n+    {(6.0 - FastMath.sqrt(6.0)) / 180.0, (6.0 - FastMath.sqrt(6.0)) / 60.0},\n \n     // k4\n-    {(6.0 - Math.sqrt(6.0)) / 120.0, 0.0, (6.0 - Math.sqrt(6.0)) / 40.0},\n+    {(6.0 - FastMath.sqrt(6.0)) / 120.0, 0.0, (6.0 - FastMath.sqrt(6.0)) / 40.0},\n \n     // k5\n-    {(462.0 + 107.0 * Math.sqrt(6.0)) / 3000.0, 0.0,\n-     (-402.0 - 197.0 * Math.sqrt(6.0)) / 1000.0, (168.0 + 73.0 * Math.sqrt(6.0)) / 375.0},\n+    {(462.0 + 107.0 * FastMath.sqrt(6.0)) / 3000.0, 0.0,\n+     (-402.0 - 197.0 * FastMath.sqrt(6.0)) / 1000.0, (168.0 + 73.0 * FastMath.sqrt(6.0)) / 375.0},\n \n     // k6\n-    {1.0 / 27.0, 0.0, 0.0, (16.0 + Math.sqrt(6.0)) / 108.0, (16.0 - Math.sqrt(6.0)) / 108.0},\n+    {1.0 / 27.0, 0.0, 0.0, (16.0 + FastMath.sqrt(6.0)) / 108.0, (16.0 - FastMath.sqrt(6.0)) / 108.0},\n \n     // k7\n-    {19.0 / 512.0, 0.0, 0.0, (118.0 + 23.0 * Math.sqrt(6.0)) / 1024.0,\n-     (118.0 - 23.0 * Math.sqrt(6.0)) / 1024.0, -9.0 / 512.0},\n+    {19.0 / 512.0, 0.0, 0.0, (118.0 + 23.0 * FastMath.sqrt(6.0)) / 1024.0,\n+     (118.0 - 23.0 * FastMath.sqrt(6.0)) / 1024.0, -9.0 / 512.0},\n \n     // k8\n-    {13772.0 / 371293.0, 0.0, 0.0, (51544.0 + 4784.0 * Math.sqrt(6.0)) / 371293.0,\n-     (51544.0 - 4784.0 * Math.sqrt(6.0)) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},\n+    {13772.0 / 371293.0, 0.0, 0.0, (51544.0 + 4784.0 * FastMath.sqrt(6.0)) / 371293.0,\n+     (51544.0 - 4784.0 * FastMath.sqrt(6.0)) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},\n \n     // k9\n     {58656157643.0 / 93983540625.0, 0.0, 0.0,\n-     (-1324889724104.0 - 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n-     (-1324889724104.0 + 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n+     (-1324889724104.0 - 318801444819.0 * FastMath.sqrt(6.0)) / 626556937500.0,\n+     (-1324889724104.0 + 318801444819.0 * FastMath.sqrt(6.0)) / 626556937500.0,\n      96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,\n      -165125654.0 / 3796875.0},\n \n     // k10\n     {8909899.0 / 18653125.0, 0.0, 0.0,\n-     (-4521408.0 - 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n-     (-4521408.0 + 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n+     (-4521408.0 - 1137963.0 * FastMath.sqrt(6.0)) / 2937500.0,\n+     (-4521408.0 + 1137963.0 * FastMath.sqrt(6.0)) / 2937500.0,\n      96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,\n      -4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},\n \n     // k11\n     {-20401265806.0 / 21769653311.0, 0.0, 0.0,\n-     (354216.0 + 94326.0 * Math.sqrt(6.0)) / 112847.0,\n-     (354216.0 - 94326.0 * Math.sqrt(6.0)) / 112847.0,\n+     (354216.0 + 94326.0 * FastMath.sqrt(6.0)) / 112847.0,\n+     (354216.0 - 94326.0 * FastMath.sqrt(6.0)) / 112847.0,\n      -43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,\n      14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,\n      -1477884375.0 / 485066827.0},\n \n     // k12\n     {39815761.0 / 17514443.0, 0.0, 0.0,\n-     (-3457480.0 - 960905.0 * Math.sqrt(6.0)) / 551636.0,\n-     (-3457480.0 + 960905.0 * Math.sqrt(6.0)) / 551636.0,\n+     (-3457480.0 - 960905.0 * FastMath.sqrt(6.0)) / 551636.0,\n+     (-3457480.0 + 960905.0 * FastMath.sqrt(6.0)) / 551636.0,\n      -844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,\n      -2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,\n      226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},\n                              E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +\n                              E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];\n \n-      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double yScale = FastMath.max(FastMath.abs(y0[j]), FastMath.abs(y1[j]));\n       final double tol = (vecAbsoluteTolerance == null) ?\n                          (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                          (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n       den = 1.0;\n     }\n \n-    return Math.abs(h) * error1 / Math.sqrt(mainSetDimension * den);\n+    return FastMath.abs(h) * error1 / FastMath.sqrt(mainSetDimension * den);\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements the common part of all embedded Runge-Kutta\n           final double[] scale = new double[mainSetDimension];\n           if (vecAbsoluteTolerance == null) {\n               for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n               }\n             } else {\n               for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n               }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n           interpolator.storeTime(stepStart + stepSize);\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n-              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+              if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n                   // we cannot simply truncate the step, reject the current computation\n                   // and let the loop compute another state with the truncated step.\n                   // it is so small (much probably exactly 0 due to limited accuracy)\n         } else {\n           // reject the step and attempt to reduce error by stepsize control\n           final double factor =\n-              Math.min(maxGrowth,\n-                       Math.max(minReduction, safety * Math.pow(error, exp)));\n+              FastMath.min(maxGrowth,\n+                       FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n           hNew = filterStep(stepSize * factor, forward, false);\n         }\n \n           stepSize = filterStep(stepSize, forward, true);\n \n         // stepsize control for next step\n-        final double factor = Math.min(maxGrowth,\n-                                       Math.max(minReduction,\n-                                                safety * Math.pow(error, exp)));\n+        final double factor = FastMath.min(maxGrowth,\n+                                       FastMath.max(minReduction,\n+                                                safety * FastMath.pow(error, exp)));\n         final double  scaledH    = stepSize * factor;\n         final double  nextT      = stepStart + scaledH;\n         final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n  */\n \n package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n   /** Internal weights Butcher array. */\n   private static final double[][] STATIC_A = {\n     { 1.0 / 2.0 },\n-    { (Math.sqrt(2.0) - 1.0) / 2.0, (2.0 - Math.sqrt(2.0)) / 2.0 },\n-    { 0.0, -Math.sqrt(2.0) / 2.0, (2.0 + Math.sqrt(2.0)) / 2.0 }\n+    { (FastMath.sqrt(2.0) - 1.0) / 2.0, (2.0 - FastMath.sqrt(2.0)) / 2.0 },\n+    { 0.0, -FastMath.sqrt(2.0) / 2.0, (2.0 + FastMath.sqrt(2.0)) / 2.0 }\n   };\n \n   /** Propagation weights Butcher array. */\n   private static final double[] STATIC_B = {\n-    1.0 / 6.0, (2.0 - Math.sqrt(2.0)) / 6.0, (2.0 + Math.sqrt(2.0)) / 6.0, 1.0 / 6.0\n+    1.0 / 6.0, (2.0 - FastMath.sqrt(2.0)) / 6.0, (2.0 + FastMath.sqrt(2.0)) / 6.0, 1.0 / 6.0\n   };\n \n   /** Simple constructor.\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n \n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements a step interpolator for the Gill fourth\n   extends RungeKuttaStepInterpolator {\n \n     /** First Gill coefficient. */\n-    private static final double TWO_MINUS_SQRT_2 = 2 - Math.sqrt(2.0);\n+    private static final double TWO_MINUS_SQRT_2 = 2 - FastMath.sqrt(2.0);\n \n     /** Second Gill coefficient. */\n-    private static final double TWO_PLUS_SQRT_2 = 2 + Math.sqrt(2.0);\n+    private static final double TWO_PLUS_SQRT_2 = 2 + FastMath.sqrt(2.0);\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -107804074496313322L;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements a Gragg-Bulirsch-Stoer integrator for\n   private void rescale(final double[] y1, final double[] y2, final double[] scale) {\n     if (vecAbsoluteTolerance == null) {\n       for (int i = 0; i < scale.length; ++i) {\n-        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        final double yi = FastMath.max(FastMath.abs(y1[i]), FastMath.abs(y2[i]));\n         scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n       }\n     } else {\n       for (int i = 0; i < scale.length; ++i) {\n-        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        final double yi = FastMath.max(FastMath.abs(y1[i]), FastMath.abs(y2[i]));\n         scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n       }\n     }\n           final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n           deltaNorm += ratio * ratio;\n         }\n-        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {\n+        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {\n           return false;\n         }\n       }\n     // initial order selection\n     final double tol =\n         (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n-    final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);\n-    int targetIter = Math.max(1,\n-                              Math.min(sequence.length - 2,\n-                                       (int) Math.floor(0.5 - 0.6 * log10R)));\n+    final double log10R = FastMath.log(FastMath.max(1.0e-10, tol)) / FastMath.log(10.0);\n+    int targetIter = FastMath.max(1,\n+                              FastMath.min(sequence.length - 2,\n+                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));\n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator = null;\n     if (denseOutput || (! eventsHandlersManager.isEmpty())) {\n                        yTmp)) {\n \n           // the stability check failed, we reduce the global step\n-          hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n+          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n           reject = true;\n           loop   = false;\n \n             // estimate the error at the end of the step.\n             error = 0;\n             for (int j = 0; j < mainSetDimension; ++j) {\n-              final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];\n+              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];\n               error += e * e;\n             }\n-            error = Math.sqrt(error / mainSetDimension);\n+            error = FastMath.sqrt(error / mainSetDimension);\n \n             if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n               // error is too big, we reduce the global step\n-              hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n+              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));\n               reject = true;\n               loop   = false;\n             } else {\n \n-              maxError = Math.max(4 * error, 1.0);\n+              maxError = FastMath.max(4 * error, 1.0);\n \n               // compute optimal stepsize for this order\n               final double exp = 1.0 / (2 * k + 1);\n-              double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n-              final double pow = Math.pow(stepControl3, exp);\n-              fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n-              optimalStep[k]     = Math.abs(filterStep(stepSize * fac, forward, true));\n+              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);\n+              final double pow = FastMath.pow(stepControl3, exp);\n+              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));\n+              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));\n               costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n \n               // check convergence\n \n           // derivative at middle point of the step\n           final int l2 = l / 2;\n-          double factor = Math.pow(0.5 * sequence[l2], l);\n+          double factor = FastMath.pow(0.5 * sequence[l2], l);\n           int middleIndex = fk[l2].length / 2;\n           for (int i = 0; i < y0.length; ++i) {\n             yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n           }\n           for (int j = 1; j <= k - l2; ++j) {\n-            factor = Math.pow(0.5 * sequence[j + l2], l);\n+            factor = FastMath.pow(0.5 * sequence[j + l2], l);\n             middleIndex = fk[l2+j].length / 2;\n             for (int i = 0; i < y0.length; ++i) {\n               diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n           if (useInterpolationError) {\n             // use the interpolation error to limit stepsize\n             final double interpError = gbsInterpolator.estimateError(scale);\n-            hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n+            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),\n                                                 0.01));\n             if (interpError > 10.0) {\n               hNew = hInt;\n             interpolator.storeTime(stepStart + stepSize);\n             if (eventsHandlersManager.evaluateStep(interpolator)) {\n                 final double dt = eventsHandlersManager.getEventTime() - stepStart;\n-                if (Math.abs(dt) > Math.ulp(stepStart)) {\n+                if (FastMath.abs(dt) > FastMath.ulp(stepStart)) {\n                     // reject the step to match exactly the next switch time\n-                    hNew = Math.abs(dt);\n+                    hNew = FastMath.abs(dt);\n                     reject = true;\n                 }\n             }\n           if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n             optimalIter = k-1;\n           } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n-            optimalIter = Math.min(k+1, sequence.length - 2);\n+            optimalIter = FastMath.min(k+1, sequence.length - 2);\n           }\n         } else {\n           optimalIter = k - 1;\n             optimalIter = k - 2;\n           }\n           if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n-            optimalIter = Math.min(k, sequence.length - 2);\n+            optimalIter = FastMath.min(k, sequence.length - 2);\n           }\n         }\n \n         if (previousRejected) {\n           // after a rejected step neither order nor stepsize\n           // should increase\n-          targetIter = Math.min(optimalIter, k);\n-          hNew = Math.min(Math.abs(stepSize), optimalStep[targetIter]);\n+          targetIter = FastMath.min(optimalIter, k);\n+          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);\n         } else {\n           // stepsize control\n           if (optimalIter <= k) {\n \n       }\n \n-      hNew = Math.min(hNew, hInt);\n+      hNew = FastMath.min(hNew, hInt);\n       if (! forward) {\n         hNew = -hNew;\n       }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements an interpolator for the Gragg-Bulirsch-Stoer\n         for (int i = 0; i < errfac.length; ++i) {\n           final int ip5 = i + 5;\n           errfac[i] = 1.0 / (ip5 * ip5);\n-          final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);\n+          final double e = 0.5 * FastMath.sqrt (((double) (i + 1)) / ip5);\n           for (int j = 0; j <= i; ++j) {\n             errfac[i] *= e / (j + 1);\n           }\n         final double e = polynoms[currentDegree][i] / scale[i];\n         error += e * e;\n       }\n-      error = Math.sqrt(error / scale.length) * errfac[currentDegree - 5];\n+      error = FastMath.sqrt(error / scale.length) * errfac[currentDegree - 5];\n     }\n     return error;\n   }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n  */\n \n package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n         errSum += STATIC_E[l] * yDotK[l][j];\n       }\n \n-      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double yScale = FastMath.max(FastMath.abs(y0[j]), FastMath.abs(y1[j]));\n       final double tol = (vecAbsoluteTolerance == null) ?\n                          (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                          (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n \n     }\n \n-    return Math.sqrt(error / mainSetDimension);\n+    return FastMath.sqrt(error / mainSetDimension);\n \n   }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements the common part of all fixed step Runge-Kutta\n     this.a          = a;\n     this.b          = b;\n     this.prototype  = prototype;\n-    this.step       = Math.abs(step);\n+    this.step       = FastMath.abs(step);\n   }\n \n   /** {@inheritDoc} */\n         interpolator.storeTime(stepStart + stepSize);\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n-            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+            if (FastMath.abs(dt) <= FastMath.ulp(stepStart)) {\n                 // we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n--- a/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n \n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements an interpolator for integrators using Nordsieck representation.\n         for (int i = nData.length - 1; i >= 0; --i) {\n             final int order = i + 2;\n             final double[] nDataI = nData[i];\n-            final double power = Math.pow(normalizedAbscissa, order);\n+            final double power = FastMath.pow(normalizedAbscissa, order);\n             for (int j = 0; j < nDataI.length; ++j) {\n                 final double d = nDataI[j] * power;\n                 stateVariation[j]          += d;\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n package org.apache.commons.math.ode.sampling;\n \n import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class wraps an object implementing {@link FixedStepHandler}\n      * @param handler fixed time step handler to wrap\n      */\n     public StepNormalizer(final double h, final FixedStepHandler handler) {\n-        this.h       = Math.abs(h);\n+        this.h       = FastMath.abs(h);\n         this.handler = handler;\n         reset();\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n  * Optimization algorithms find the input point set that either {@link GoalType\n  * maximize or minimize} an objective function.\n  * This interface is mainly intended to enforce the internal coherence of\n- * Commons-Math. Users of the API are advised to base their code on\n+ * Commons-FastMath. Users of the API are advised to base their code on\n  * {@link MultivariateRealOptimizer} or on\n  * {@link DifferentiableMultivariateRealOptimizer}.\n  * @param <T> the type of the objective function to be optimized\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Special implementation of the {@link UnivariateRealOptimizer} interface adding\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                 optima[i]       = optimizer.optimize(f, goalType,\n-                                                     Math.min(bound1, bound2),\n-                                                     Math.max(bound1, bound2));\n+                                                     FastMath.min(bound1, bound2),\n+                                                     FastMath.max(bound1, bound2));\n                 optimaValues[i] = optimizer.getFunctionValue();\n             } catch (FunctionEvaluationException fee) {\n                 optima[i]       = Double.NaN;\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n         final double[] p        = previous.getPoint();\n         final double[] c        = current.getPoint();\n         for (int i = 0; i < p.length; ++i) {\n-            final double difference = Math.abs(p[i] - c[i]);\n-            final double size       = Math.max(Math.abs(p[i]), Math.abs(c[i]));\n+            final double difference = FastMath.abs(p[i] - c[i]);\n+            final double size       = FastMath.max(FastMath.abs(p[i]), FastMath.abs(c[i]));\n             if ((difference > (size * relativeThreshold)) && (difference > absoluteThreshold)) {\n                 return false;\n             }\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n                              final RealPointValuePair current) {\n         final double p          = previous.getValue();\n         final double c          = current.getValue();\n-        final double difference = Math.abs(p - c);\n-        final double size       = Math.max(Math.abs(p), Math.abs(c));\n+        final double difference = FastMath.abs(p - c);\n+        final double size       = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n         return (difference <= (size * relativeThreshold)) || (difference <= absoluteThreshold);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n         for (int i = 0; i < p.length; ++i) {\n             final double pi         = p[i];\n             final double ci         = c[i];\n-            final double difference = Math.abs(pi - ci);\n-            final double size       = Math.max(Math.abs(pi), Math.abs(ci));\n+            final double difference = FastMath.abs(pi - ci);\n+            final double size       = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n             if ((difference > (size * relativeThreshold)) &&\n                 (difference > absoluteThreshold)) {\n                 return false;\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n         for (int i = 0; i < p.length; ++i) {\n             final double pi         = p[i];\n             final double ci         = c[i];\n-            final double difference = Math.abs(pi - ci);\n-            final double size       = Math.max(Math.abs(pi), Math.abs(ci));\n+            final double difference = FastMath.abs(pi - ci);\n+            final double size       = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n             if ((difference > (size * relativeThreshold)) &&\n                 (difference > absoluteThreshold)) {\n                 return false;\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicCoefficientsGuesser.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicCoefficientsGuesser.java\n \n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.util.FastMath;\n \n /** This class guesses harmonic coefficients from a sample.\n \n         if ((c1 / c2 < 0.0) || (c2 / c3 < 0.0)) {\n             throw new OptimizationException(LocalizedFormats.UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS);\n         }\n-        a     = Math.sqrt(c1 / c2);\n-        omega = Math.sqrt(c2 / c3);\n+        a     = FastMath.sqrt(c1 / c2);\n+        omega = FastMath.sqrt(c2 / c3);\n \n     }\n \n             final double currentYPrime = (currentY - previousY) / (currentX - previousX);\n \n             double   omegaX = omega * currentX;\n-            double   cosine = Math.cos(omegaX);\n-            double   sine   = Math.sin(omegaX);\n+            double   cosine = FastMath.cos(omegaX);\n+            double   sine   = FastMath.sin(omegaX);\n             fcMean += omega * currentY * cosine - currentYPrime *   sine;\n             fsMean += omega * currentY *   sine + currentYPrime * cosine;\n \n         }\n \n-        phi = Math.atan2(-fsMean, fcMean);\n+        phi = FastMath.atan2(-fsMean, fcMean);\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.util.FastMath;\n \n /** This class implements a curve fitting specialized for sinusoids.\n  * <p>Harmonic fitting is a very simple case of curve fitting. The\n             final double a     = parameters[0];\n             final double omega = parameters[1];\n             final double phi   = parameters[2];\n-            return a * Math.cos(omega * x + phi);\n+            return a * FastMath.cos(omega * x + phi);\n         }\n \n         /** {@inheritDoc} */\n             final double omega = parameters[1];\n             final double phi   = parameters[2];\n             final double alpha = omega * x + phi;\n-            final double cosAlpha = Math.cos(alpha);\n-            final double sinAlpha = Math.sin(alpha);\n+            final double cosAlpha = FastMath.cos(alpha);\n+            final double sinAlpha = FastMath.sin(alpha);\n             return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFunction.java\n package org.apache.commons.math.optimization.fitting;\n \n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n /** Harmonic function of the form <code>f (t) = a cos (&omega; t + &phi;)</code>.\n  * @version $Revision$ $Date$\n \n     /** {@inheritDoc} */\n     public double value(double x) {\n-        return a * Math.cos(omega * x + phi);\n+        return a * FastMath.cos(omega * x + phi);\n     }\n \n     /** {@inheritDoc} */\n     public HarmonicFunction derivative() {\n-        return new HarmonicFunction(a * omega, omega, phi + Math.PI / 2);\n+        return new HarmonicFunction(a * omega, omega, phi + FastMath.PI / 2);\n     }\n \n     /** Get the amplitude a.\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.optimization.VectorialConvergenceChecker;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Base class for implementing least squares optimizers.\n         }\n         for (int i = 0; i < rows; i++) {\n             final double[] ji = weightedResidualJacobian[i];\n-            double wi = Math.sqrt(residualsWeights[i]);\n+            double wi = FastMath.sqrt(residualsWeights[i]);\n             for (int j = 0; j < cols; ++j) {\n                 //ji[j] *=  -1.0;\n                 weightedResidualJacobian[i][j] = -ji[j]*wi;\n         int index = 0;\n         for (int i = 0; i < rows; i++) {\n             final double residual = targetValues[i] - objective[i];\n-            weightedResiduals[i]= residual*Math.sqrt(residualsWeights[i]);\n+            weightedResiduals[i]= residual*FastMath.sqrt(residualsWeights[i]);\n             cost += residualsWeights[i] * residual * residual;\n             index += cols;\n         }\n-        cost = Math.sqrt(cost);\n+        cost = FastMath.sqrt(cost);\n \n     }\n \n      * @return RMS value\n      */\n     public double getRMS() {\n-        return Math.sqrt(getChiSquare() / rows);\n+        return FastMath.sqrt(getChiSquare() / rows);\n     }\n \n     /**\n                     rows, cols);\n         }\n         double[] errors = new double[cols];\n-        final double c = Math.sqrt(getChiSquare() / (rows - cols));\n+        final double c = FastMath.sqrt(getChiSquare() / (rows - cols));\n         double[][] covar = getCovariances();\n         for (int i = 0; i < errors.length; ++i) {\n-            errors[i] = Math.sqrt(covar[i][i]) * c;\n+            errors[i] = FastMath.sqrt(covar[i][i]) * c;\n         }\n         return errors;\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n  * This base class handles the boiler-plate methods associated to thresholds\n  * settings, iterations and evaluations counting.\n  * This class is mainly intended to enforce the internal coherence of\n- * Commons-Math.\n+ * Commons-FastMath.\n  * A class that implements an optimization algorithm should inherit from\n  * {@link AbstractScalarOptimizer} or from\n  * {@link AbstractScalarDifferentiableOptimizer}.\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n         // arrays shared with the other private methods\n-        solvedCols  = Math.min(rows, cols);\n+        solvedCols  = FastMath.min(rows, cols);\n         diagR       = new double[cols];\n         jacNorm     = new double[cols];\n         beta        = new double[cols];\n                     xNorm  += xk * xk;\n                     diag[k] = dk;\n                 }\n-                xNorm = Math.sqrt(xNorm);\n+                xNorm = FastMath.sqrt(xNorm);\n \n                 // initialize the step bound delta\n                 delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n                         for (int i = 0; i <= j; ++i) {\n                             sum += weightedResidualJacobian[i][pj] * qtf[i];\n                         }\n-                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n+                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * cost));\n                     }\n                 }\n             }\n \n             // rescale if necessary\n             for (int j = 0; j < cols; ++j) {\n-                diag[j] = Math.max(diag[j], jacNorm[j]);\n+                diag[j] = FastMath.max(diag[j], jacNorm[j]);\n             }\n \n             // inner loop\n                     double s = diag[pj] * lmDir[pj];\n                     lmNorm  += s * s;\n                 }\n-                lmNorm = Math.sqrt(lmNorm);\n+                lmNorm = FastMath.sqrt(lmNorm);\n                 // on the first iteration, adjust the initial step bound.\n                 if (firstIteration) {\n-                    delta = Math.min(delta, lmNorm);\n+                    delta = FastMath.min(delta, lmNorm);\n                 }\n \n                 // evaluate the function at x + p and calculate its norm\n                         if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                             tmp = 0.1;\n                         }\n-                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n+                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                         lmPar /= tmp;\n                 } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                     delta = 2 * lmNorm;\n                         double xK = diag[k] * point[k];\n                         xNorm    += xK * xK;\n                     }\n-                    xNorm = Math.sqrt(xNorm);\n+                    xNorm = FastMath.sqrt(xNorm);\n                     current = new VectorialPointValuePair(point, objective);\n \n                     // tests for convergence.\n                     oldObj    = tmpVec;\n                 }\n                 if (checker==null) {\n-                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+                    if (((FastMath.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm)) {\n                 }\n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n-                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n+                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                     throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                             costRelativeTolerance);\n                 } else if (delta <= 2.2204e-16 * xNorm) {\n             work1[pj] = s;\n             dxNorm += s * s;\n         }\n-        dxNorm = Math.sqrt(dxNorm);\n+        dxNorm = FastMath.sqrt(dxNorm);\n         double fp = dxNorm - delta;\n         if (fp <= 0.1 * delta) {\n             lmPar = 0;\n             sum /= diag[pj];\n             sum2 += sum * sum;\n         }\n-        double gNorm = Math.sqrt(sum2);\n+        double gNorm = FastMath.sqrt(sum2);\n         double paru = gNorm / delta;\n         if (paru == 0) {\n             // 2.2251e-308 is the smallest positive real for IEE754\n-            paru = 2.2251e-308 / Math.min(delta, 0.1);\n+            paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n         }\n \n         // if the input par lies outside of the interval (parl,paru),\n         // set par to the closer endpoint\n-        lmPar = Math.min(paru, Math.max(lmPar, parl));\n+        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n         if (lmPar == 0) {\n             lmPar = gNorm / dxNorm;\n         }\n \n             // evaluate the function at the current value of lmPar\n             if (lmPar == 0) {\n-                lmPar = Math.max(2.2251e-308, 0.001 * paru);\n-            }\n-            double sPar = Math.sqrt(lmPar);\n+                lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n+            }\n+            double sPar = FastMath.sqrt(lmPar);\n             for (int j = 0; j < solvedCols; ++j) {\n                 int pj = permutation[j];\n                 work1[pj] = sPar * diag[pj];\n                 work3[pj] = s;\n                 dxNorm += s * s;\n             }\n-            dxNorm = Math.sqrt(dxNorm);\n+            dxNorm = FastMath.sqrt(dxNorm);\n             double previousFP = fp;\n             fp = dxNorm - delta;\n \n             // if the function is small enough, accept the current value\n             // of lmPar, also test for the exceptional cases where parl is zero\n-            if ((Math.abs(fp) <= 0.1 * delta) ||\n+            if ((FastMath.abs(fp) <= 0.1 * delta) ||\n                     ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                 return;\n             }\n \n             // depending on the sign of the function, update parl or paru.\n             if (fp > 0) {\n-                parl = Math.max(parl, lmPar);\n+                parl = FastMath.max(parl, lmPar);\n             } else if (fp < 0) {\n-                paru = Math.min(paru, lmPar);\n+                paru = FastMath.min(paru, lmPar);\n             }\n \n             // compute an improved estimate for lmPar\n-            lmPar = Math.max(parl, lmPar + correction);\n+            lmPar = FastMath.max(parl, lmPar + correction);\n \n         }\n     }\n                     final double sin;\n                     final double cos;\n                     double rkk = weightedResidualJacobian[k][pk];\n-                    if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n+                    if (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\n                         final double cotan = rkk / lmDiag[k];\n-                        sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n+                        sin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\n                         cos   = sin * cotan;\n                     } else {\n                         final double tan = lmDiag[k] / rkk;\n-                        cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n+                        cos = 1.0 / FastMath.sqrt(1.0 + tan * tan);\n                         sin = cos * tan;\n                     }\n \n                 double akk = weightedResidualJacobian[i][k];\n                 norm2 += akk * akk;\n             }\n-            jacNorm[k] = Math.sqrt(norm2);\n+            jacNorm[k] = FastMath.sqrt(norm2);\n         }\n \n         // transform the matrix column after column\n \n             // choose alpha such that Hk.u = alpha ek\n             double akk   = weightedResidualJacobian[k][pk];\n-            double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n+            double alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\n             double betak = 1.0 / (ak2 - akk * alpha);\n             beta[pk]     = betak;\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Non-linear conjugate gradient optimizer.\n         throws FunctionEvaluationException, OptimizationException {\n         final double yA = f.value(a);\n         double yB = yA;\n-        for (double step = h; step < Double.MAX_VALUE; step *= Math.max(2, yA / yB)) {\n+        for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\n             final double b = a + step;\n             yB = f.value(b);\n             if (yA * yB <= 0) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements Richard Brent's algorithm (from his book \"Algorithms for\n     /**\n      * Golden section.\n      */\n-    private static final double GOLDEN_SECTION = 0.5 * (3 - Math.sqrt(5));\n+    private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n \n     /**\n      * Construct a solver.\n \n         while (true) {\n             double m = 0.5 * (a + b);\n-            final double tol1 = eps * Math.abs(x) + t;\n+            final double tol1 = eps * FastMath.abs(x) + t;\n             final double tol2 = 2 * tol1;\n \n             // Check stopping criterion.\n-            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n+            if (FastMath.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n                 double u = 0;\n \n-                if (Math.abs(e) > tol1) { // Fit parabola.\n+                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                     r = (x - w) * (fx - fv);\n                     q = (x - v) * (fx - fw);\n                     p = (x - v) * q - (x - w) * r;\n \n                     if (p > q * (a - x) &&\n                         p < q * (b - x) &&\n-                        Math.abs(p) < Math.abs(0.5 * q * r)) {\n+                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                         // Parabolic interpolation step.\n                         d = p / q;\n                         u = x + d;\n                 }\n \n                 // Update by at least \"tol1\".\n-                if (Math.abs(d) < tol1) {\n+                if (FastMath.abs(d) < tol1) {\n                     if (d >= 0) {\n                         u = x + tol1;\n                     } else {\n--- a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Abstract class implementing the {@link  RandomGenerator} interface.\n             s = v1 * v1 + v2 * v2;\n         }\n         if (s != 0) {\n-            s = Math.sqrt(-2 * Math.log(s) / s);\n+            s = FastMath.sqrt(-2 * FastMath.log(s) / s);\n         }\n         cachedNormalDeviate = v2 * s;\n         return v1 * s;\n--- a/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n package org.apache.commons.math.random;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.util.FastMath;\n \n /** Base class for random number generators that generates bits streams.\n \n             // generate a new pair of gaussian numbers\n             final double x = nextDouble();\n             final double y = nextDouble();\n-            final double alpha = 2 * Math.PI * x;\n-            final double r      = Math.sqrt(-2 * Math.log(y));\n-            random       = r * Math.cos(alpha);\n-            nextGaussian = r * Math.sin(alpha);\n+            final double alpha = 2 * FastMath.PI * x;\n+            final double r      = FastMath.sqrt(-2 * FastMath.log(y));\n+            random       = r * FastMath.cos(alpha);\n+            nextGaussian = r * FastMath.sin(alpha);\n         } else {\n             // use the second element of the pair already generated\n             random = nextGaussian;\n--- a/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * A {@link RandomVectorGenerator} that generates vectors with with\n             } else {\n \n                 // transform the matrix\n-                double sqrt = Math.sqrt(c[ir][ir]);\n+                double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[rank][rank] = sqrt;\n                 double inverse = 1 / sqrt;\n                 for (int i = rank + 1; i < order; ++i) {\n--- a/src/main/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements <code>EmpiricalDistribution</code> interface.  This implementation\n      * @return the index of the bin containing the value\n      */\n     private int findBin(double value) {\n-        return Math.min(\n-                Math.max((int) Math.ceil((value- min) / delta) - 1, 0),\n+        return FastMath.min(\n+                FastMath.max((int) FastMath.ceil((value- min) / delta) - 1, 0),\n                 binCount - 1);\n         }\n \n         }\n \n         // Start with a uniformly distributed random number in (0,1)\n-        double x = Math.random();\n+        double x = FastMath.random();\n \n         // Use this to select the bin and generate a Gaussian within the bin\n         for (int i = 0; i < binCount; i++) {\n--- a/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n+++ b/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.util.FastMath;\n+\n \n /** This class implements a powerful pseudo-random number generator\n  * developed by Makoto Matsumoto and Takuji Nishimura during\n         int i = 1;\n         int j = 0;\n \n-        for (int k = Math.max(N, seed.length); k != 0; k--) {\n+        for (int k = FastMath.max(N, seed.length); k != 0; k--) {\n             long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n             long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n             long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.WeibullDistributionImpl;\n import org.apache.commons.math.distribution.ZipfDistributionImpl;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n \n         final double pivot = 40.0d;\n         if (mean < pivot) {\n-            double p = Math.exp(-mean);\n+            double p = FastMath.exp(-mean);\n             long n = 0;\n             double r = 1.0d;\n             double rnd = 1.0d;\n             }\n             return n;\n         } else {\n-            final double lambda = Math.floor(mean);\n+            final double lambda = FastMath.floor(mean);\n             final double lambdaFractional = mean - lambda;\n-            final double logLambda = Math.log(lambda);\n+            final double logLambda = FastMath.log(lambda);\n             final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);\n             final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n-            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));\n+            final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1));\n             final double halfDelta = delta / 2;\n             final double twolpd = 2 * lambda + delta;\n-            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);\n-            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);\n+            final double a1 = FastMath.sqrt(FastMath.PI * twolpd) * FastMath.exp(1 / 8 * lambda);\n+            final double a2 = (twolpd / delta) * FastMath.exp(-delta * (1 + delta) / twolpd);\n             final double aSum = a1 + a2 + 1;\n             final double p1 = a1 / aSum;\n             final double p2 = a2 / aSum;\n                 final double u = nextUniform(0.0, 1);\n                 if (u <= p1) {\n                     final double n = nextGaussian(0d, 1d);\n-                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;\n+                    x = n * FastMath.sqrt(lambda + halfDelta) - 0.5d;\n                     if (x > delta || x < -lambda) {\n                         continue;\n                     }\n-                    y = x < 0 ? Math.floor(x) : Math.ceil(x);\n+                    y = x < 0 ? FastMath.floor(x) : FastMath.ceil(x);\n                     final double e = nextExponential(1d);\n                     v = -e - (n * n / 2) + c1;\n                 } else {\n                         break;\n                     } else {\n                         x = delta + (twolpd / delta) * nextExponential(1d);\n-                        y = Math.ceil(x);\n+                        y = FastMath.ceil(x);\n                         v = -nextExponential(1d) - delta * (x + 1) / twolpd;\n                     }\n                 }\n         while (unif == 0.0d) {\n             unif = generator.nextDouble();\n         }\n-        return -mean * Math.log(unif);\n+        return -mean * FastMath.log(unif);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/random/UniformRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UniformRandomGenerator.java\n \n package org.apache.commons.math.random;\n \n+import org.apache.commons.math.util.FastMath;\n+\n /**\n  * This class implements a normalized uniform random generator.\n  * <p>Since it is a normalized random generator, it generates values\n     private static final long serialVersionUID = 1569292426375546027L;\n \n     /** Square root of three. */\n-    private static final double SQRT3 = Math.sqrt(3.0);\n+    private static final double SQRT3 = FastMath.sqrt(3.0);\n \n     /** Underlying generator. */\n     private final RandomGenerator generator;\n--- a/src/main/java/org/apache/commons/math/random/UnitSphereRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UnitSphereRandomVectorGenerator.java\n  */\n \n package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n             }\n         } while (normSq > 1);\n \n-        final double f = 1 / Math.sqrt(normSq);\n+        final double f = 1 / FastMath.sqrt(normSq);\n         for (int i = 0; i < dimension; i++) {\n             v[i] *= f;\n         }\n--- a/src/main/java/org/apache/commons/math/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math/special/Beta.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.ContinuedFraction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This is a utility class that provides computation methods related to the\n                     return 1.0;\n                 }\n             };\n-            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -\n-                Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n+            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\n+                FastMath.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n                 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n         }\n \n--- a/src/main/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.util.ContinuedFraction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This is a utility class that provides computation methods related to the\n     };\n \n     /** Avoid repeated computation of log of 2 PI in logGamma */\n-    private static final double HALF_LOG_2_PI = 0.5 * Math.log(2.0 * Math.PI);\n+    private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(2.0 * FastMath.PI);\n \n     // limits for switching algorithm in digamma\n     /** C limit. */\n             sum = sum + LANCZOS[0];\n \n             double tmp = x + g + .5;\n-            ret = ((x + .5) * Math.log(tmp)) - tmp +\n-                HALF_LOG_2_PI + Math.log(sum / x);\n+            ret = ((x + .5) * FastMath.log(tmp)) - tmp +\n+                HALF_LOG_2_PI + FastMath.log(sum / x);\n         }\n \n         return ret;\n             double n = 0.0; // current element index\n             double an = 1.0 / a; // n-th element in the series\n             double sum = an; // partial sum\n-            while (Math.abs(an/sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n+            while (FastMath.abs(an/sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n                 // compute next element in the series\n                 n = n + 1.0;\n                 an = an * (x / (a + n));\n             } else if (Double.isInfinite(sum)) {\n                 ret = 1.0;\n             } else {\n-                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n+                ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum;\n             }\n         }\n \n             };\n \n             ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n-            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n+            ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n         }\n \n         return ret;\n             //            1       1        1         1\n             // log(x) -  --- - ------ + ------- - -------\n             //           2 x   12 x^2   120 x^4   252 x^6\n-            return Math.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n+            return FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n         }\n \n         return digamma(x + 1) - 1 / x;\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.stat.regression.SimpleRegression;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Computes Pearson's product-moment correlation coefficients for pairs of arrays\n         for (int i = 0; i < nVars; i++) {\n             for (int j = 0; j < nVars; j++) {\n                 double r = correlationMatrix.getEntry(i, j);\n-                out[i][j] = Math.sqrt((1 - r * r) /(nObs - 2));\n+                out[i][j] = FastMath.sqrt((1 - r * r) /(nObs - 2));\n             }\n         }\n         return new BlockRealMatrix(out);\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n-                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n+                    double t = FastMath.abs(r * FastMath.sqrt((nObs - 2)/(1 - r * r)));\n                     out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                 }\n             }\n         int nVars = covarianceMatrix.getColumnDimension();\n         RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n         for (int i = 0; i < nVars; i++) {\n-            double sigma = Math.sqrt(covarianceMatrix.getEntry(i, i));\n+            double sigma = FastMath.sqrt(covarianceMatrix.getEntry(i, i));\n             outMatrix.setEntry(i, i, 1d);\n             for (int j = 0; j < i; j++) {\n                 double entry = covarianceMatrix.getEntry(i, j) /\n-                       (sigma * Math.sqrt(covarianceMatrix.getEntry(j, j)));\n+                       (sigma * FastMath.sqrt(covarianceMatrix.getEntry(j, j)));\n                 outMatrix.setEntry(i, j, entry);\n                 outMatrix.setEntry(j, i, entry);\n             }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n import org.apache.commons.math.util.ResizableDoubleArray;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n         double stdDev = Double.NaN;\n         if (getN() > 0) {\n             if (getN() > 1) {\n-                stdDev = Math.sqrt(getVariance());\n+                stdDev = FastMath.sqrt(getVariance());\n             } else {\n                 stdDev = 0.0;\n             }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * <p>Computes summary statistics for a stream of n-tuples added using the\n         } else {\n             RealMatrix matrix = covarianceImpl.getResult();\n             for (int i = 0; i < k; ++i) {\n-                stdDev[i] = Math.sqrt(matrix.getEntry(i, i));\n+                stdDev[i] = FastMath.sqrt(matrix.getEntry(i, i));\n             }\n         }\n         return stdDev;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n package org.apache.commons.math.stat.descriptive;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n      * @return Returns the standard deviation\n      */\n     public double getStandardDeviation() {\n-        return Math.sqrt(variance);\n+        return FastMath.sqrt(variance);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * <p>\n         double stdDev = Double.NaN;\n         if (getN() > 0) {\n             if (getN() > 1) {\n-                stdDev = Math.sqrt(getVariance());\n+                stdDev = FastMath.sqrt(getVariance());\n             } else {\n                 stdDev = 0.0;\n             }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n     @Override\n     public double getResult() {\n         if (sumOfLogs.getN() > 0) {\n-            return Math.exp(sumOfLogs.getResult() / sumOfLogs.getN());\n+            return FastMath.exp(sumOfLogs.getResult() / sumOfLogs.getN());\n         } else {\n             return Double.NaN;\n         }\n     @Override\n     public double evaluate(\n         final double[] values, final int begin, final int length) {\n-        return Math.exp(\n+        return FastMath.exp(\n             sumOfLogs.evaluate(values, begin, length) / length);\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n             Variance variance = new Variance();\n             variance.incrementAll(values, begin, length);\n             double mean = variance.moment.m1;\n-            double stdDev = Math.sqrt(variance.getResult());\n+            double stdDev = FastMath.sqrt(variance.getResult());\n \n             // Sum the ^4 of the distance from the mean divided by the\n             // standard deviation\n             double accum3 = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n-                accum3 += Math.pow(values[i] - mean, 4.0);\n+                accum3 += FastMath.pow(values[i] - mean, 4.0);\n             }\n-            accum3 /= Math.pow(stdDev, 4.0d);\n+            accum3 /= FastMath.pow(stdDev, 4.0d);\n \n             // Get N\n             double n0 = length;\n             double coefficientOne =\n                 (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));\n             double termTwo =\n-                (3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3));\n+                (3 * FastMath.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3));\n \n             // Calculate kurtosis\n             kurt = (coefficientOne * accum3) - termTwo;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n import java.io.Serializable;\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Computes the skewness of the available values.\n         } else {\n             double n0 = moment.getN();\n             return  (n0 * moment.m3) /\n-            ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);\n+            ((n0 - 1) * (n0 -2) * FastMath.sqrt(variance) * variance);\n         }\n     }\n \n                 final double d = values[i] - m;\n                 accum3 += d * d * d;\n             }\n-            accum3 /= variance * Math.sqrt(variance);\n+            accum3 /= variance * FastMath.sqrt(variance);\n \n             // Get N\n             double n0 = length;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n import java.io.Serializable;\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Computes the sample standard deviation.  The standard deviation\n      */\n     @Override\n     public double getResult() {\n-        return Math.sqrt(variance.getResult());\n+        return FastMath.sqrt(variance.getResult());\n     }\n \n     /**\n      */\n     @Override\n     public double evaluate(final double[] values)  {\n-        return Math.sqrt(variance.evaluate(values));\n+        return FastMath.sqrt(variance.evaluate(values));\n     }\n \n     /**\n      */\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length)  {\n-       return Math.sqrt(variance.evaluate(values, begin, length));\n+       return FastMath.sqrt(variance.evaluate(values, begin, length));\n     }\n \n     /**\n      */\n     public double evaluate(final double[] values, final double mean,\n             final int begin, final int length)  {\n-        return Math.sqrt(variance.evaluate(values, mean, begin, length));\n+        return FastMath.sqrt(variance.evaluate(values, mean, begin, length));\n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is null\n      */\n     public double evaluate(final double[] values, final double mean)  {\n-        return Math.sqrt(variance.evaluate(values, mean));\n+        return FastMath.sqrt(variance.evaluate(values, mean));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Provides percentile computation.\n         }\n         double n = length;\n         double pos = p * (n + 1) / 100;\n-        double fpos = Math.floor(pos);\n+        double fpos = FastMath.floor(pos);\n         int intPos = (int) fpos;\n         double dif = pos - fpos;\n         double[] sorted = new double[length];\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.WeightedEvaluation;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Returns the product of the available values.\n         if (test(values, weights, begin, length)) {\n             product = 1.0;\n             for (int i = begin; i < begin + length; i++) {\n-                product *= Math.pow(values[i], weights[i]);\n+                product *= FastMath.pow(values[i], weights[i]);\n             }\n         }\n         return product;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n import java.io.Serializable;\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Returns the sum of the natural logs for this collection of values.\n      */\n     @Override\n     public void increment(final double d) {\n-        value += Math.log(d);\n+        value += FastMath.log(d);\n         n++;\n     }\n \n         if (test(values, begin, length)) {\n             sumLog = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n-                sumLog += Math.log(values[i]);\n+                sumLog += FastMath.log(values[i]);\n             }\n         }\n         return sumLog;\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements Chi-Square test statistics defined in the\n         }\n         double ratio = 1.0d;\n         boolean rescale = false;\n-        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n+        if (FastMath.abs(sumExpected - sumObserved) > 10E-6) {\n             ratio = sumObserved / sumExpected;\n             rescale = true;\n         }\n         // Compare and compute weight only if different\n         unequalCounts = countSum1 != countSum2;\n         if (unequalCounts) {\n-            weight = Math.sqrt((double) countSum1 / (double) countSum2);\n+            weight = FastMath.sqrt((double) countSum1 / (double) countSum2);\n         }\n         // Compute ChiSquare statistic\n         double sumSq = 0.0d;\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.StatUtils;\n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements t-test statistics defined in the {@link TTest} interface.\n      * @return t test statistic\n      */\n     protected double t(double m, double mu, double v, double n) {\n-        return (m - mu) / Math.sqrt(v / n);\n+        return (m - mu) / FastMath.sqrt(v / n);\n     }\n \n     /**\n      */\n     protected double t(double m1, double m2,  double v1, double v2, double n1,\n             double n2)  {\n-            return (m1 - m2) / Math.sqrt((v1 / n1) + (v2 / n2));\n+            return (m1 - m2) / FastMath.sqrt((v1 / n1) + (v2 / n2));\n     }\n \n     /**\n     protected double homoscedasticT(double m1, double m2,  double v1,\n             double v2, double n1, double n2)  {\n             double pooledVariance = ((n1  - 1) * v1 + (n2 -1) * v2 ) / (n1 + n2 - 2);\n-            return (m1 - m2) / Math.sqrt(pooledVariance * (1d / n1 + 1d / n2));\n+            return (m1 - m2) / FastMath.sqrt(pooledVariance * (1d / n1 + 1d / n2));\n     }\n \n     /**\n      */\n     protected double tTest(double m, double mu, double v, double n)\n     throws MathException {\n-        double t = Math.abs(t(m, mu, v, n));\n+        double t = FastMath.abs(t(m, mu, v, n));\n         distribution.setDegreesOfFreedom(n - 1);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n     protected double tTest(double m1, double m2, double v1, double v2,\n             double n1, double n2)\n     throws MathException {\n-        double t = Math.abs(t(m1, m2, v1, v2, n1, n2));\n+        double t = FastMath.abs(t(m1, m2, v1, v2, n1, n2));\n         double degreesOfFreedom = 0;\n         degreesOfFreedom = df(v1, v2, n1, n2);\n         distribution.setDegreesOfFreedom(degreesOfFreedom);\n     protected double homoscedasticTTest(double m1, double m2, double v1,\n             double v2, double n1, double n2)\n     throws MathException {\n-        double t = Math.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));\n+        double t = FastMath.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));\n         double degreesOfFreedom = n1 + n2 - 2;\n         distribution.setDegreesOfFreedom(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n--- a/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n import org.apache.commons.math.random.RandomData;\n import org.apache.commons.math.random.RandomDataImpl;\n import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.util.FastMath;\n \n \n /**\n                 break;\n             case RANDOM:    // Fill with random integral values in [c, c + length - 1]\n                 Iterator<Integer> iterator = tiesTrace.iterator();\n-                long f = Math.round(c);\n+                long f = FastMath.round(c);\n                 while (iterator.hasNext()) {\n                     ranks[iterator.next()] =\n                         randomData.nextLong(f, f + length - 1);\n             case SEQUENTIAL:  // Fill sequentially from c to c + length - 1\n                 // walk and fill\n                 iterator = tiesTrace.iterator();\n-                f = Math.round(c);\n+                f = FastMath.round(c);\n                 int i = 0;\n                 while (iterator.hasNext()) {\n                     ranks[iterator.next()] = f + i++;\n--- a/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Abstract base class for implementations of MultipleLinearRegression.\n         int length = betaVariance[0].length;\n         double[] result = new double[length];\n         for (int i = 0; i < length; i++) {\n-            result[i] = Math.sqrt(sigma * betaVariance[i][i]);\n+            result[i] = FastMath.sqrt(sigma * betaVariance[i][i]);\n         }\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Estimates an ordinary least squares regression model\n         if (n < 2) {\n             return Double.NaN; //not enough data\n         }\n-        if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {\n+        if (FastMath.abs(sumXX) < 10 * Double.MIN_VALUE) {\n             return Double.NaN; //not enough variation in x\n         }\n         return sumXY / sumXX;\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n+        return FastMath.max(0d, sumYY - sumXY * sumXY / sumXX);\n     }\n \n     /**\n      */\n     public double getR() {\n         double b1 = getSlope();\n-        double result = Math.sqrt(getRSquare());\n+        double result = FastMath.sqrt(getRSquare());\n         if (b1 < 0) {\n             result = -result;\n         }\n      * @return standard error associated with intercept estimate\n      */\n     public double getInterceptStdErr() {\n-        return Math.sqrt(\n+        return FastMath.sqrt(\n             getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));\n     }\n \n      * @return standard error associated with slope estimate\n      */\n     public double getSlopeStdErr() {\n-        return Math.sqrt(getMeanSquareError() / sumXX);\n+        return FastMath.sqrt(getMeanSquareError() / sumXX);\n     }\n \n     /**\n      */\n     public double getSignificance() throws MathException {\n         return 2d * (1.0 - distribution.cumulativeProbability(\n-                    Math.abs(getSlope()) / getSlopeStdErr()));\n+                    FastMath.abs(getSlope()) / getSlopeStdErr()));\n     }\n \n     // ---------------------Private methods-----------------------------------\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n      */\n     public double[] transform2(double f[]) throws IllegalArgumentException {\n \n-        double scaling_coefficient = Math.sqrt(2.0 / (f.length-1));\n+        double scaling_coefficient = FastMath.sqrt(2.0 / (f.length-1));\n         return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);\n     }\n \n         throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n-        double scaling_coefficient = Math.sqrt(2.0 / (n-1));\n+        double scaling_coefficient = FastMath.sqrt(2.0 / (n-1));\n         return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);\n     }\n \n         double t1 = 0.5 * (f[0] - f[n]);   // temporary variable for transformed[1]\n         for (int i = 1; i < (n >> 1); i++) {\n             final double a = 0.5 * (f[i] + f[n-i]);\n-            final double b = Math.sin(i * Math.PI / n) * (f[i] - f[n-i]);\n-            final double c = Math.cos(i * Math.PI / n) * (f[i] - f[n-i]);\n+            final double b = FastMath.sin(i * FastMath.PI / n) * (f[i] - f[n-i]);\n+            final double c = FastMath.cos(i * FastMath.PI / n) * (f[i] - f[n-i]);\n             x[i] = a - b;\n             x[n-i] = a + b;\n             t1 += c;\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/FastFourierTransform.html\">\n     public Complex[] transform2(double f[])\n         throws IllegalArgumentException {\n \n-        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n         return scaleArray(fft(f, false), scaling_coefficient);\n     }\n \n         throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n-        double scaling_coefficient = 1.0 / Math.sqrt(n);\n+        double scaling_coefficient = 1.0 / FastMath.sqrt(n);\n         return scaleArray(fft(data, false), scaling_coefficient);\n     }\n \n         throws IllegalArgumentException {\n \n         roots.computeOmega(f.length);\n-        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n         return scaleArray(fft(f), scaling_coefficient);\n     }\n \n     public Complex[] inversetransform2(double f[])\n         throws IllegalArgumentException {\n \n-        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n         return scaleArray(fft(f, true), scaling_coefficient);\n     }\n \n         throws FunctionEvaluationException, IllegalArgumentException {\n \n         double data[] = sample(f, min, max, n);\n-        double scaling_coefficient = 1.0 / Math.sqrt(n);\n+        double scaling_coefficient = 1.0 / FastMath.sqrt(n);\n         return scaleArray(fft(data, true), scaling_coefficient);\n     }\n \n         throws IllegalArgumentException {\n \n         roots.computeOmega(-f.length);    // pass negative argument\n-        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n         return scaleArray(fft(f), scaling_coefficient);\n     }\n \n         isForward = n > 0;\n \n         // avoid repetitive calculations\n-        final int absN = Math.abs(n);\n+        final int absN = FastMath.abs(n);\n \n         if (absN == omegaCount) {\n             return;\n         }\n \n         // calculate everything from scratch, for both forward and inverse versions\n-        final double t    = 2.0 * Math.PI / absN;\n-        final double cosT = Math.cos(t);\n-        final double sinT = Math.sin(t);\n+        final double t    = 2.0 * FastMath.PI / absN;\n+        final double cosT = FastMath.cos(t);\n+        final double sinT = FastMath.sin(t);\n         omegaReal             = new double[absN];\n         omegaImaginaryForward = new double[absN];\n         omegaImaginaryInverse = new double[absN];\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n      */\n     public double[] transform2(double f[]) throws IllegalArgumentException {\n \n-        double scaling_coefficient = Math.sqrt(2.0 / f.length);\n+        double scaling_coefficient = FastMath.sqrt(2.0 / f.length);\n         return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);\n     }\n \n \n         double data[] = FastFourierTransformer.sample(f, min, max, n);\n         data[0] = 0.0;\n-        double scaling_coefficient = Math.sqrt(2.0 / n);\n+        double scaling_coefficient = FastMath.sqrt(2.0 / n);\n         return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);\n     }\n \n         x[0] = 0.0;\n         x[n >> 1] = 2.0 * f[n >> 1];\n         for (int i = 1; i < (n >> 1); i++) {\n-            final double a = Math.sin(i * Math.PI / n) * (f[i] + f[n-i]);\n+            final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n-i]);\n             final double b = 0.5 * (f[i] - f[n-i]);\n             x[i]     = a + b;\n             x[n - i] = a - b;\n--- a/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n                 double scaleFactor = 1d;\n                 double lastScaleFactor = 1d;\n                 final int maxPower = 5;\n-                final double scale = Math.max(a,b);\n+                final double scale = FastMath.max(a,b);\n                 if (scale <= 0) {  // Can't scale\n                     throw new ConvergenceException(\n                             LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                   LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                   x);\n             }\n-            relativeError = Math.abs(r / c - 1.0);\n+            relativeError = FastMath.abs(r / c - 1.0);\n \n             // prepare for next iteration\n             c = p2 / q2;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+/**\n+ * Faster, more accurate, portable alternative to StrictMath.\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class FastMath {\n+\n+    /** Archimede's constant PI, ratio of circle circumference to diameter. */\n+    public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n+\n+    /** Napier's constant e, base of the natural logarithm. */\n+    public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;\n+\n+    /** Exponential evaluated at integer values,\n+     * exp(x) =  expIntTableA[x + 750] + expIntTableB[x+750].\n+     */\n+    private static final double EXP_INT_TABLE_A[] = new double[1500];\n+\n+    /** Exponential evaluated at integer values,\n+     * exp(x) =  expIntTableA[x + 750] + expIntTableB[x+750]\n+     */\n+    private static final double EXP_INT_TABLE_B[] = new double[1500];\n+\n+    /** Exponential over the range of 0 - 1 in increments of 2^-10\n+     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n+     */\n+    private static final double EXP_FRAC_TABLE_A[] = new double[1025];\n+\n+    /** Exponential over the range of 0 - 1 in increments of 2^-10\n+     * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n+     */\n+    private static final double EXP_FRAC_TABLE_B[] = new double[1025];\n+\n+    /** Factorial table, for Taylor series expansions. */\n+    private static final double FACT[] = new double[20];\n+\n+    /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n+    private static final double LN_MANT[][] = new double[1024][];\n+\n+    /** log(2) (high bits). */\n+    private static final double LN_2_A = 0.693147063255310059;\n+\n+    /** log(2) (low bits). */\n+    private static final double LN_2_B = 1.17304635250823482e-7;\n+\n+    /** Coefficients for slowLog. */\n+    private static final double LN_SPLIT_COEF[][] = {\n+        {2.0, 0.0},\n+        {0.6666666269302368, 3.9736429850260626E-8},\n+        {0.3999999761581421, 2.3841857910019882E-8},\n+        {0.2857142686843872, 1.7029898543501842E-8},\n+        {0.2222222089767456, 1.3245471311735498E-8},\n+        {0.1818181574344635, 2.4384203044354907E-8},\n+        {0.1538461446762085, 9.140260083262505E-9},\n+        {0.13333332538604736, 9.220590270857665E-9},\n+        {0.11764700710773468, 1.2393345855018391E-8},\n+        {0.10526403784751892, 8.251545029714408E-9},\n+        {0.0952233225107193, 1.2675934823758863E-8},\n+        {0.08713622391223907, 1.1430250008909141E-8},\n+        {0.07842259109020233, 2.404307984052299E-9},\n+        {0.08371849358081818, 1.176342548272881E-8},\n+        {0.030589580535888672, 1.2958646899018938E-9},\n+        {0.14982303977012634, 1.225743062930824E-8},\n+    };\n+\n+    /** Coefficients for log, when input 0.99 < x < 1.01. */\n+    private static final double LN_QUICK_COEF[][] = {\n+        {1.0, 5.669184079525E-24},\n+        {-0.25, -0.25},\n+        {0.3333333134651184, 1.986821492305628E-8},\n+        {-0.25, -6.663542893624021E-14},\n+        {0.19999998807907104, 1.1921056801463227E-8},\n+        {-0.1666666567325592, -7.800414592973399E-9},\n+        {0.1428571343421936, 5.650007086920087E-9},\n+        {-0.12502530217170715, -7.44321345601866E-11},\n+        {0.11113807559013367, 9.219544613762692E-9},\n+    };\n+\n+    /** Coefficients for log in the range of 1.0 < x < 1.0 + 2^-10. */\n+    private static final double LN_HI_PREC_COEF[][] = {\n+        {1.0, -6.032174644509064E-23},\n+        {-0.25, -0.25},\n+        {0.3333333134651184, 1.9868161777724352E-8},\n+        {-0.2499999701976776, -2.957007209750105E-8},\n+        {0.19999954104423523, 1.5830993332061267E-10},\n+        {-0.16624879837036133, -2.6033824355191673E-8}\n+    };\n+\n+    /** Sine table (high bits). */\n+    private static final double SINE_TABLE_A[] = new double[14];\n+\n+    /** Sine table (low bits). */\n+    private static final double SINE_TABLE_B[] = new double[14];\n+\n+    /** Cosine table (high bits). */\n+    private static final double COSINE_TABLE_A[] = new double[14];\n+\n+    /** Cosine table (low bits). */\n+    private static final double COSINE_TABLE_B[] = new double[14];\n+\n+    /** Tangent table, used by atan() (high bits). */\n+    private static final double TANGENT_TABLE_A[] = new double[14];\n+\n+    /** Tangent table, used by atan() (low bits). */\n+    private static final double TANGENT_TABLE_B[] = new double[14];\n+\n+    /** Bits of 1/(2*pi), need for reducePayneHanek(). */\n+    private static long RECIP_2PI[] = new long[] {\n+        (0x28be60dbL << 32) | 0x9391054aL,\n+        (0x7f09d5f4L << 32) | 0x7d4d3770L,\n+        (0x36d8a566L << 32) | 0x4f10e410L,\n+        (0x7f9458eaL << 32) | 0xf7aef158L,\n+        (0x6dc91b8eL << 32) | 0x909374b8L,\n+        (0x01924bbaL << 32) | 0x82746487L,\n+        (0x3f877ac7L << 32) | 0x2c4a69cfL,\n+        (0xba208d7dL << 32) | 0x4baed121L,\n+        (0x3a671c09L << 32) | 0xad17df90L,\n+        (0x4e64758eL << 32) | 0x60d4ce7dL,\n+        (0x272117e2L << 32) | 0xef7e4a0eL,\n+        (0xc7fe25ffL << 32) | 0xf7816603L,\n+        (0xfbcbc462L << 32) | 0xd6829b47L,\n+        (0xdb4d9fb3L << 32) | 0xc9f2c26dL,\n+        (0xd3d18fd9L << 32) | 0xa797fa8bL,\n+        (0x5d49eeb1L << 32) | 0xfaf97c5eL,\n+        (0xcf41ce7dL << 32) | 0xe294a4baL,\n+         0x9afed7ecL << 32  };\n+\n+    /** Bits of pi/4, need for reducePayneHanek(). */\n+    private static long PI_O_4_BITS[] = new long[] {\n+        (0xc90fdaa2L << 32) | 0x2168c234L,\n+        (0xc4c6628bL << 32) | 0x80dc1cd1L };\n+\n+    /** Eighthes.\n+     * This is used by sinQ, because its faster to do a table lookup than\n+     * a multiply in this time-critical routine\n+     */\n+    private static final double EIGHTHES[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};\n+\n+    // Initialize tables\n+    static {\n+        int i;\n+\n+        // Generate an array of factorials\n+        FACT[0] = 1.0;\n+        for (i = 1; i < 20; i++) {\n+            FACT[i] = FACT[i-1] * i;\n+        }\n+\n+        double tmp[] = new double[2];\n+        double recip[] = new double[2];\n+\n+        // Populate expIntTable\n+        for (i = 0; i < 750; i++) {\n+            expint(i, tmp);\n+            EXP_INT_TABLE_A[i+750] = tmp[0];\n+            EXP_INT_TABLE_B[i+750] = tmp[1];\n+\n+            if (i != 0) {\n+                // Negative integer powers\n+                splitReciprocal(tmp, recip);\n+                EXP_INT_TABLE_A[750-i] = recip[0];\n+                EXP_INT_TABLE_B[750-i] = recip[1];\n+            }\n+        }\n+\n+        // Populate expFracTable\n+        for (i = 0; i < 1025; i++) {\n+            slowexp(i/1024.0, tmp);\n+            EXP_FRAC_TABLE_A[i] = tmp[0];\n+            EXP_FRAC_TABLE_B[i] = tmp[1];\n+        }\n+\n+        // Populate lnMant table\n+        for (i = 0; i < 1024; i++) {\n+            double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n+            LN_MANT[i] = slowLog(d);\n+        }\n+\n+        // Build the sine and cosine tables\n+        buildSinCosTables();\n+    }\n+\n+    /**\n+     * Private Constructor\n+     */\n+    private FastMath() {\n+    }\n+\n+    /** Compute the arc cosine of a number.\n+     * @param a number on which evaluation is done\n+     * @return arc cosine of a\n+     */\n+    public static double acos(final double a) {\n+        return Math.acos(a);\n+    }\n+\n+    /** Compute the arc sine of a number.\n+     * @param a number on which evaluation is done\n+     * @return arc sine of a\n+     */\n+    public static double asin(final double a) {\n+        return Math.asin(a);\n+    }\n+\n+    /** Compute the square root of a number.\n+     * @param a number on which evaluation is done\n+     * @return square root of a\n+     */\n+    public static double sqrt(final double a) {\n+        return Math.sqrt(a);\n+    }\n+\n+    /** Compute the cubic root of a number.\n+     * @param a number on which evaluation is done\n+     * @return cubic root of a\n+     */\n+    public static double cbrt(final double a) {\n+        return Math.cbrt(a);\n+    }\n+\n+    /** Compute the hyperbolic cosine of a number.\n+     * @param a number on which evaluation is done\n+     * @return hyperbolic cosine of a\n+     */\n+    public static double cosh(final double a) {\n+        return 0.5 * (FastMath.exp(a) + FastMath.exp(-a));\n+    }\n+\n+    /** Compute the hyperbolic sine of a number.\n+     * @param a number on which evaluation is done\n+     * @return hyperbolic sine of a\n+     */\n+    public static double sinh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absSinh;\n+        if (a > 0.3) {\n+            absSinh = 0.5 * (FastMath.exp(a) - FastMath.exp(-a));\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.05) {\n+                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 * (1 + a2 * (1 + a2 / 110) / 72) / 42) / 20) / 6);\n+            } else {\n+                absSinh = a * (1 + a2 * (1 + a2  * (1 + a2 / 42) / 20) / 6);\n+            }\n+        }\n+\n+        return negative ? -absSinh : absSinh;\n+\n+    }\n+\n+    /** Compute the hyperbolic tangent of a number.\n+     * @param a number on which evaluation is done\n+     * @return hyperbolic tangent of a\n+     */\n+    public static double tanh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absTanh;\n+        if (a > 0.074) {\n+            final double twoA = 2 * a;\n+            absTanh = FastMath.expm1(twoA) / (FastMath.exp(twoA) + 1);\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.016) {\n+                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * (17 - a2 * (62 - a2 * 1382 / 55 ) / 9) / 21) / 5) / 3);\n+            } else {\n+                absTanh = a * (1 - a2 * (1 - a2 * (2 - a2 * 17 / 21) / 5) / 3);\n+            }\n+        }\n+\n+        return negative ? -absTanh : absTanh;\n+\n+    }\n+\n+    /** Compute the inverse hyperbolic cosine of a number.\n+     * @param a number on which evaluation is done\n+     * @return inverse hyperbolic cosine of a\n+     */\n+    public static double acosh(final double a) {\n+        return FastMath.log(a + FastMath.sqrt(a * a - 1));\n+    }\n+\n+    /** Compute the inverse hyperbolic sine of a number.\n+     * @param a number on which evaluation is done\n+     * @return inverse hyperbolic sine of a\n+     */\n+    public static double asinh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absAsinh;\n+        if (a > 0.167) {\n+            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.097) {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n+            } else if (a > 0.036) {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n+            } else if (a > 0.0036) {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);\n+            } else {\n+                absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);\n+            }\n+        }\n+\n+        return negative ? -absAsinh : absAsinh;\n+\n+    }\n+\n+    /** Compute the inverse hyperbolic tangent of a number.\n+     * @param a number on which evaluation is done\n+     * @return inverse hyperbolic tangent of a\n+     */\n+    public static double atanh(double a) {\n+\n+        boolean negative = false;\n+        if (a < 0) {\n+            negative = true;\n+            a = -a;\n+        }\n+\n+        double absAtanh;\n+        if (a > 0.15) {\n+            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n+        } else {\n+            final double a2 = a * a;\n+            if (a > 0.087) {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));\n+            } else if (a > 0.031) {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));\n+            } else if (a > 0.003) {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));\n+            } else {\n+                absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));\n+            }\n+        }\n+\n+        return negative ? -absAtanh : absAtanh;\n+\n+    }\n+\n+    /** Compute the signum of a number.\n+     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n+     * @param a number on which evaluation is done\n+     * @return -1, 0, +1 or NaN depending on sign of a\n+     */\n+    public static double signum(final double a) {\n+        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));\n+    }\n+\n+    /** Compute next number towards positive infinity.\n+     * @param a number to which neighbor should be computed\n+     * @return neighbor of a towards positive infinity\n+     */\n+    public static double nextUp(final double a) {\n+        return nextAfter(a, Double.POSITIVE_INFINITY);\n+    }\n+\n+    /** Returns a pseudo-random number between 0.0 and 1.0.\n+     * @return a random number between 0.0 and 1.0\n+     */\n+    public static double random() {\n+        return Math.random();\n+    }\n+\n+    /**\n+     * Exponential function.\n+     *\n+     * Computes exp(x), function result is nearly rounded.   It will be correctly\n+     * rounded to the theoretical value for 99.9% of input values, otherwise it will\n+     * have a 1 UPL error.\n+     *\n+     * Method:\n+     *    Lookup intVal = exp(int(x))\n+     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n+     *    Compute z as the exponential of the remaining bits by a polynomial minus one\n+     *    exp(x) = intVal * fracVal * (1 + z)\n+     *\n+     * Accuracy:\n+     *    Calculation is done with 63 bits of precision, so result should be correctly\n+     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n+     *\n+     * @param x   a double\n+     * @return double e<sup>x</sup>\n+     */\n+    public static double exp(double x) {\n+        return exp(x, 0.0, null);\n+    }\n+\n+    /**\n+     * Internal helper method for exponential function.\n+     * @param x original argument of the exponential function\n+     * @param extra extra bits of precision on input (To Be Confirmed)\n+     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n+     * @return exp(x)\n+     */\n+    private static double exp(double x, double extra, double[] hiPrec) {\n+        double intPartA;\n+        double intPartB;\n+        int intVal;\n+\n+        /* Lookup exp(floor(x)).\n+         * intPartA will have the upper 22 bits, intPartB will have the lower\n+         * 52 bits.\n+         */\n+        if (x < 0.0) {\n+            intVal = (int) -x;\n+\n+            if (intVal > 746) {\n+                return 0.0;\n+            }\n+\n+            if (intVal > 709) {\n+                /* This will produce a subnormal output */\n+                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n+                if (hiPrec != null) {\n+                    hiPrec[0] /= 285040095144011776.0;\n+                    hiPrec[1] /= 285040095144011776.0;\n+                }\n+                return result;\n+            }\n+\n+            if (intVal == 709) {\n+                /* exp(1.494140625) is nearly a machine number... */\n+                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n+                if (hiPrec != null) {\n+                    hiPrec[0] /= 4.455505956692756620;\n+                    hiPrec[1] /= 4.455505956692756620;\n+                }\n+                return result;\n+            }\n+\n+            intVal++;\n+\n+            intPartA = EXP_INT_TABLE_A[750-intVal];\n+            intPartB = EXP_INT_TABLE_B[750-intVal];\n+\n+            intVal = -intVal;\n+        } else {\n+            intVal = (int) x;\n+\n+            if (intVal > 709) {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+\n+            intPartA = EXP_INT_TABLE_A[750+intVal];\n+            intPartB = EXP_INT_TABLE_B[750+intVal];\n+        }\n+\n+        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n+         * x and look up the exp function of it.\n+         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n+         */\n+        final int intFrac = (int) ((x - intVal) * 1024.0);\n+        final double fracPartA = EXP_FRAC_TABLE_A[intFrac];\n+        final double fracPartB = EXP_FRAC_TABLE_B[intFrac];\n+\n+        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n+         * has a value in the range 0 <= epsilon < 2^-10.\n+         * Do the subtraction from x as the last step to avoid possible loss of percison.\n+         */\n+        final double epsilon = x - (intVal + intFrac / 1024.0);\n+\n+        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n+       full double precision (52 bits).  Since z < 2^-10, we will have\n+       62 bits of precision when combined with the contant 1.  This will be\n+       used in the last addition below to get proper rounding. */\n+\n+        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n+       is less than 0.5 ULP */\n+        double z = 0.04168701738764507;\n+        z = z * epsilon + 0.1666666505023083;\n+        z = z * epsilon + 0.5000000000042687;\n+        z = z * epsilon + 1.0;\n+        z = z * epsilon + -3.940510424527919E-20;\n+\n+        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n+       expansion.\n+       tempA is exact since intPartA and intPartB only have 22 bits each.\n+       tempB will have 52 bits of precision.\n+         */\n+        double tempA = intPartA * fracPartA;\n+        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n+\n+        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n+       important.  For accuracy add by increasing size.  tempA is exact and\n+       much larger than the others.  If there are extra bits specified from the\n+       pow() function, use them. */\n+        final double tempC = tempB + tempA;\n+        final double result;\n+        if (extra != 0.0) {\n+            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n+        } else {\n+            result = tempC*z + tempB + tempA;\n+        }\n+\n+        if (hiPrec != null) {\n+            // If requesting high precision\n+            hiPrec[0] = tempA;\n+            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n+        }\n+\n+        return result;\n+    }\n+\n+    /** Compute exp(x) - 1\n+     * @param x number to compute shifted exponential\n+     * @return exp(x) - 1\n+     */\n+    public static double expm1(double x) {\n+        if (x != x || x == 0.0) { // NaN or zero\n+            return x;\n+        }\n+\n+        if (x <= -1.0 || x >= 1.0) {\n+            // If not between +/- 1.0\n+            //return exp(x) - 1.0;\n+            double hiPrec[] = new double[2];\n+            exp(x, 0.0, hiPrec);\n+            if (x > 0.0) {\n+                return -1.0 + hiPrec[0] + hiPrec[1];\n+            } else {\n+                final double ra = -1.0 + hiPrec[0];\n+                double rb = -(ra + 1.0 - hiPrec[0]);\n+                rb += hiPrec[1];\n+                return ra + rb;\n+            }\n+        }\n+\n+        double baseA;\n+        double baseB;\n+        double epsilon;\n+        boolean negative = false;\n+\n+        if (x < 0.0) {\n+            x = -x;\n+            negative = true;\n+        }\n+\n+        {\n+            int intFrac = (int) (x * 1024.0);\n+            double tempA = EXP_FRAC_TABLE_A[intFrac] - 1.0;\n+            double tempB = EXP_FRAC_TABLE_B[intFrac];\n+\n+            double temp = tempA + tempB;\n+            tempB = -(temp - tempA - tempB);\n+            tempA = temp;\n+\n+            temp = tempA * 1073741824.0;\n+            baseA = tempA + temp - temp;\n+            baseB = tempB + (tempA - baseA);\n+\n+            epsilon = x - intFrac/1024.0;\n+        }\n+\n+\n+        /* Compute expm1(epsilon) */\n+        double zb = 0.008336750013465571;\n+        zb = zb * epsilon + 0.041666663879186654;\n+        zb = zb * epsilon + 0.16666666666745392;\n+        zb = zb * epsilon + 0.49999999999999994;\n+        zb = zb * epsilon;\n+        zb = zb * epsilon;\n+\n+        double za = epsilon;\n+        double temp = za + zb;\n+        zb = -(temp - za - zb);\n+        za = temp;\n+\n+        temp = za * 1073741824.0;\n+        temp = za + temp - temp;\n+        zb += za - temp;\n+        za = temp;\n+\n+        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */\n+        double ya = za * baseA;\n+        //double yb = za*baseB + zb*baseA + zb*baseB;\n+        temp = ya + za * baseB;\n+        double yb = -(temp - ya - za * baseB);\n+        ya = temp;\n+\n+        temp = ya + zb * baseA;\n+        yb += -(temp - ya - zb * baseA);\n+        ya = temp;\n+\n+        temp = ya + zb * baseB;\n+        yb += -(temp - ya - zb*baseB);\n+        ya = temp;\n+\n+        //ya = ya + za + baseA;\n+        //yb = yb + zb + baseB;\n+        temp = ya + baseA;\n+        yb += -(temp - baseA - ya);\n+        ya = temp;\n+\n+        temp = ya + za;\n+        //yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);\n+        yb += -(temp - ya - za);\n+        ya = temp;\n+\n+        temp = ya + baseB;\n+        //yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);\n+        yb += -(temp - ya - baseB);\n+        ya = temp;\n+\n+        temp = ya + zb;\n+        //yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);\n+        yb += -(temp - ya - zb);\n+        ya = temp;\n+\n+        if (negative) {\n+            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n+            double denom = 1.0 + ya;\n+            double denomr = 1.0 / denom;\n+            double denomb = -(denom - 1.0 - ya) + yb;\n+            double ratio = ya * denomr;\n+            temp = ratio * 1073741824.0;\n+            final double ra = ratio + temp - temp;\n+            double rb = ratio - ra;\n+\n+            temp = denom * 1073741824.0;\n+            za = denom + temp - temp;\n+            zb = denom - za;\n+\n+            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n+\n+            // f(x) = x/1+x\n+            // Compute f'(x)\n+            // Product rule:  d(uv) = du*v + u*dv\n+            // Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))\n+            // d(1/x) = -1/(x*x)\n+            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))\n+            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))\n+\n+            // Adjust for yb\n+            rb += yb * denomr;                      // numerator\n+            rb += -ya * denomb * denomr * denomr;   // denominator\n+\n+            // negate\n+            ya = -ra;\n+            yb = -rb;\n+        }\n+\n+        return ya + yb;\n+    }\n+\n+    /**\n+     *  For x between 0 and 1, returns exp(x), uses extended precision\n+     *  @param x argument of exponential\n+     *  @param result placeholder where to place exp(x) split in two terms\n+     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n+     *  @return exp(x)\n+     */\n+    private static double slowexp(final double x, final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = 19; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0];\n+            ys[1] = as[1];\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0];\n+            ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /** Compute split[0], split[1] such that their sum is equal to d,\n+     * and split[0] has its 30 least significant bits as zero.\n+     * @param d number to split\n+     * @param split placeholder where to place the result\n+     */\n+    private static void split(final double d, final double split[]) {\n+        if (d < 8e298 && d > -8e298) {\n+            final double a = d * 1073741824.0;\n+            split[0] = (d + a) - a;\n+            split[1] = d - split[0];\n+        } else {\n+            final double a = d * 9.31322574615478515625E-10;\n+            split[0] = (d + a - d) * 1073741824.0;\n+            split[1] = d - split[0];\n+        }\n+    }\n+\n+    /** Recompute a split.\n+     * @param a input/out array containing the split, changed\n+     * on output\n+     */\n+    private static void resplit(final double a[]) {\n+        final double c = a[0] + a[1];\n+        final double d = -(c - a[0] - a[1]);\n+\n+        if (c < 8e298 && c > -8e298) {\n+            double z = c * 1073741824.0;\n+            a[0] = (c + z) - z;\n+            a[1] = c - a[0] + d;\n+        } else {\n+            double z = c * 9.31322574615478515625E-10;\n+            a[0] = (c + z - c) * 1073741824.0;\n+            a[1] = c - a[0] + d;\n+        }\n+    }\n+\n+    /** Multiply two numbers in split form.\n+     * @param a first term of multiplication\n+     * @param b second term of multiplication\n+     * @param ans placeholder where to put the result\n+     */\n+    private static void splitMult(double a[], double b[], double ans[]) {\n+        ans[0] = a[0] * b[0];\n+        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n+\n+        /* Resplit */\n+        resplit(ans);\n+    }\n+\n+    /** Add two numbers in split form.\n+     * @param a first term of addition\n+     * @param b second term of addition\n+     * @param ans placeholder where to put the result\n+     */\n+    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n+        ans[0] = a[0] + b[0];\n+        ans[1] = a[1] + b[1];\n+\n+        resplit(ans);\n+    }\n+\n+    /** Compute the reciprocal of in.  Use the following algorithm.\n+     *  in = c + d.\n+     *  want to find x + y such that x+y = 1/(c+d) and x is much\n+     *  larger than y and x has several zero bits on the right.\n+     *\n+     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n+     *  Use following identity to compute (a+b)/(c+d)\n+     *\n+     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n+     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n+     *  This will be close to the right answer, but there will be\n+     *  some rounding in the calculation of X.  So by carefully\n+     *  computing 1 - (c+d)(x+y) we can compute an error and\n+     *  add that back in.   This is done carefully so that terms\n+     *  of similar size are subtracted first.\n+     *  @param in initial number, in split form\n+     *  @param result placeholder where to put the result\n+     */\n+    private static void splitReciprocal(final double in[], final double result[]) {\n+        final double b = 1.0/4194304.0;\n+        final double a = 1.0 - b;\n+\n+        if (in[0] == 0.0) {\n+            in[0] = in[1];\n+            in[1] = 0.0;\n+        }\n+\n+        result[0] = a / in[0];\n+        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n+\n+        if (result[1] != result[1]) { // can happen if result[1] is NAN\n+            result[1] = 0.0;\n+        }\n+\n+        /* Resplit */\n+        resplit(result);\n+\n+        for (int i = 0; i < 2; i++) {\n+            /* this may be overkill, probably once is enough */\n+            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n+            result[1] * in[0] - result[1] * in[1];\n+            /*err = 1.0 - err; */\n+            err = err * (result[0] + result[1]);\n+            /*printf(\"err = %16e\\n\", err); */\n+            result[1] += err;\n+        }\n+    }\n+\n+    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n+     * @param a first term of the multiplication\n+     * @param b second term of the multiplication\n+     * @param result placeholder where to put the result\n+     */\n+    private static void quadMult(final double a[], final double b[], final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double zs[] = new double[2];\n+\n+        /* a[0] * b[0] */\n+        split(a[0], xs);\n+        split(b[0], ys);\n+        splitMult(xs, ys, zs);\n+\n+        result[0] = zs[0];\n+        result[1] = zs[1];\n+\n+        /* a[0] * b[1] */\n+        split(b[1], ys);\n+        splitMult(xs, ys, zs);\n+\n+        double tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+\n+        /* a[1] * b[0] */\n+        split(a[1], xs);\n+        split(b[0], ys);\n+        splitMult(xs, ys, zs);\n+\n+        tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+\n+        /* a[1] * b[0] */\n+        split(a[1], xs);\n+        split(b[1], ys);\n+        splitMult(xs, ys, zs);\n+\n+        tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+    }\n+\n+    /** Compute exp(p) for a integer p in extended precision.\n+     * @param p integer whose exponential is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * @return exp(p) in standard precision (equal to result[0] + result[1])\n+     */\n+    private static double expint(int p, final double result[]) {\n+        //double x = M_E;\n+        final double xs[] = new double[2];\n+        final double as[] = new double[2];\n+        final double ys[] = new double[2];\n+        //split(x, xs);\n+        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n+        //xs[0] = 2.71827697753906250000;\n+        //xs[1] = 4.85091998273542816811e-06;\n+        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n+        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n+\n+        /* E */\n+        xs[0] = 2.718281828459045;\n+        xs[1] = 1.4456468917292502E-16;\n+\n+        split(1.0, ys);\n+\n+        while (p > 0) {\n+            if ((p & 1) != 0) {\n+                quadMult(ys, xs, as);\n+                ys[0] = as[0]; ys[1] = as[1];\n+            }\n+\n+            quadMult(xs, xs, as);\n+            xs[0] = as[0]; xs[1] = as[1];\n+\n+            p >>= 1;\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+\n+            resplit(result);\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+\n+    /**\n+     * Natural logarithm.\n+     *\n+     * @param x   a double\n+     * @return log(x)\n+     */\n+    public static double log(final double x) {\n+        return log(x, null);\n+    }\n+\n+    /**\n+     * Internal helper method for natural logarithm function.\n+     * @param x original argument of the natural logarithm function\n+     * @param hiPrec extra bits of precision on output (To Be Confirmed)\n+     * @return log(x)\n+     */\n+    private static double log(final double x, final double[] hiPrec) {\n+        long bits = Double.doubleToLongBits(x);\n+\n+        /* Handle special cases of negative input, and NaN */\n+        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n+            if (x != 0.0) {\n+                if (hiPrec != null) {\n+                    hiPrec[0] = Double.NaN;\n+                }\n+\n+                return Double.NaN;\n+            }\n+        }\n+\n+        /* Handle special cases of Positive infinity. */\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (hiPrec != null) {\n+                hiPrec[0] = Double.POSITIVE_INFINITY;\n+            }\n+\n+            return Double.POSITIVE_INFINITY;\n+        }\n+\n+        /* Extract the exponent */\n+        int exp = (int)(bits >> 52)-1023;\n+\n+        if ((bits & 0x7ff0000000000000L) == 0) {\n+            // Subnormal!\n+            if (x == 0) {\n+                // Zero\n+                if (hiPrec != null) {\n+                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n+                }\n+\n+                return Double.NEGATIVE_INFINITY;\n+            }\n+\n+            /* Normalize the subnormal number. */\n+            bits <<= 1;\n+            while ( (bits & 0x0010000000000000L) == 0) {\n+                exp--;\n+                bits <<= 1;\n+            }\n+        }\n+\n+\n+        if (exp == -1 || exp == 0) {\n+            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n+                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n+           polynomial expansion in higer precision. */\n+\n+               /* Compute x - 1.0 and split it */\n+                double xa = x - 1.0;\n+                double xb = xa - x + 1.0;\n+                double tmp = xa * 1073741824.0;\n+                double aa = xa + tmp - tmp;\n+                double ab = xa - aa;\n+                xa = aa;\n+                xb = ab;\n+\n+                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n+                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n+\n+                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n+                    /* Multiply a = y * x */\n+                    aa = ya * xa;\n+                    ab = ya * xb + yb * xa + yb * xb;\n+                    /* split, so now y = a */\n+                    tmp = aa * 1073741824.0;\n+                    ya = aa + tmp - tmp;\n+                    yb = aa - ya + ab;\n+\n+                    /* Add  a = y + lnQuickCoef */\n+                    aa = ya + LN_QUICK_COEF[i][0];\n+                    ab = yb + LN_QUICK_COEF[i][1];\n+                    /* Split y = a */\n+                    tmp = aa * 1073741824.0;\n+                    ya = aa + tmp - tmp;\n+                    yb = aa - ya + ab;\n+                }\n+\n+                /* Multiply a = y * x */\n+                aa = ya * xa;\n+                ab = ya * xb + yb * xa + yb * xb;\n+                /* split, so now y = a */\n+                tmp = aa * 1073741824.0;\n+                ya = aa + tmp - tmp;\n+                yb = aa - ya + ab;\n+\n+                if (hiPrec != null) {\n+                    hiPrec[0] = ya;\n+                    hiPrec[1] = yb;\n+                }\n+\n+                return ya + yb;\n+            }\n+        }\n+\n+        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n+        double lnm[] = LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n+\n+        /*\n+    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n+\n+    epsilon -= 1.0;\n+         */\n+\n+        // y is the most significant 10 bits of the mantissa\n+        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n+        //double epsilon = (x - y) / y;\n+        double epsilon = (double)(bits & 0x3ffffffffffL) / (4503599627370496.0 + (bits & 0x000ffc0000000000L));\n+\n+        double lnza = 0.0;\n+        double lnzb = 0.0;\n+\n+        if (hiPrec != null) {\n+            /* split epsilon -> x */\n+            double tmp = epsilon * 1073741824.0;\n+            double aa = epsilon + tmp - tmp;\n+            double ab = epsilon - aa;\n+            double xa = aa;\n+            double xb = ab;\n+\n+            /* Need a more accurate epsilon, so adjust the division. */\n+            double numer = (double)(bits & 0x3ffffffffffL);\n+            double denom = 4503599627370496.0 + (bits & 0x000ffc0000000000L);\n+            aa = numer - xa*denom - xb * denom;\n+            xb += aa / denom;\n+\n+            /* Remez polynomial evaluation */\n+            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n+            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n+\n+            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n+                /* Multiply a = y * x */\n+                aa = ya * xa;\n+                ab = ya * xb + yb * xa + yb * xb;\n+                /* split, so now y = a */\n+                tmp = aa * 1073741824.0;\n+                ya = aa + tmp - tmp;\n+                yb = aa - ya + ab;\n+\n+                /* Add  a = y + lnHiPrecCoef */\n+                aa = ya + LN_HI_PREC_COEF[i][0];\n+                ab = yb + LN_HI_PREC_COEF[i][1];\n+                /* Split y = a */\n+                tmp = aa * 1073741824.0;\n+                ya = aa + tmp - tmp;\n+                yb = aa - ya + ab;\n+            }\n+\n+            /* Multiply a = y * x */\n+            aa = ya * xa;\n+            ab = ya * xb + yb * xa + yb * xb;\n+\n+            /* split, so now lnz = a */\n+            /*\n+      tmp = aa * 1073741824.0;\n+      lnza = aa + tmp - tmp;\n+      lnzb = aa - lnza + ab;\n+             */\n+            lnza = aa + ab;\n+            lnzb = -(lnza - aa - ab);\n+        } else {\n+            /* High precision not required.  Eval Remez polynomial\n+         using standard double precision */\n+            lnza = -0.16624882440418567;\n+            lnza = lnza * epsilon + 0.19999954120254515;\n+            lnza = lnza * epsilon + -0.2499999997677497;\n+            lnza = lnza * epsilon + 0.3333333333332802;\n+            lnza = lnza * epsilon + -0.5;\n+            lnza = lnza * epsilon + 1.0;\n+            lnza = lnza * epsilon;\n+        }\n+\n+        /* Relative sizes:\n+         * lnzb     [0, 2.33E-10]\n+         * lnm[1]   [0, 1.17E-7]\n+         * ln2B*exp [0, 1.12E-4]\n+         * lnza      [0, 9.7E-4]\n+         * lnm[0]   [0, 0.692]\n+         * ln2A*exp [0, 709]\n+         */\n+\n+        /* Compute the following sum:\n+         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n+         */\n+\n+        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n+        double a = LN_2_A*exp;\n+        double b = 0.0;\n+        double c = a+lnm[0];\n+        double d = -(c-a-lnm[0]);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + lnza;\n+        d = -(c - a - lnza);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + LN_2_B*exp;\n+        d = -(c - a - LN_2_B*exp);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + lnm[1];\n+        d = -(c - a - lnm[1]);\n+        a = c;\n+        b = b + d;\n+\n+        c = a + lnzb;\n+        d = -(c - a - lnzb);\n+        a = c;\n+        b = b + d;\n+\n+        if (hiPrec != null) {\n+            hiPrec[0] = a;\n+            hiPrec[1] = b;\n+        }\n+\n+        return a + b;\n+    }\n+\n+    /** Compute log(1 + x).\n+     * @param x a number\n+     * @return log(1 + x)\n+     */\n+    public static double log1p(final double x) {\n+        double xpa = 1.0 + x;\n+        double xpb = -(xpa - 1.0 - x);\n+\n+        if (x>1e-6 || x<-1e-6) {\n+            double hiPrec[] = new double[2];\n+\n+            log(xpa, hiPrec);\n+\n+            /* Do a taylor series expansion around xpa */\n+            /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */\n+            double fx1 = xpb/xpa;\n+\n+            double epsilon = 0.5 * fx1 + 1.0;\n+            epsilon = epsilon * fx1;\n+\n+            return epsilon + hiPrec[1] + hiPrec[0];\n+        }\n+\n+        /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */\n+        double y = x * 0.333333333333333 - 0.5;\n+        y = y * x + 1.0;\n+        y = y * x;\n+\n+        return y;\n+    }\n+\n+    /** Compute the base 10 logarithm.\n+     * @param x a number\n+     * @return log10(x)\n+     */\n+    public static double log10(final double x) {\n+        final double hiPrec[] = new double[2];\n+\n+        log(x, hiPrec);\n+\n+        final double tmp = hiPrec[0] * 1073741824.0;\n+        final double lna = hiPrec[0] + tmp - tmp;\n+        final double lnb = hiPrec[0] - lna + hiPrec[1];\n+\n+        final double rln10a = 0.4342944622039795;\n+        final double rln10b = 1.9699272335463627E-8;\n+\n+        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n+    }\n+\n+    /**\n+     * Power function.  Compute x^y.\n+     *\n+     * @param x   a double\n+     * @param y   a double\n+     * @return double\n+     */\n+    public static double pow(double x, double y) {\n+        final double lns[] = new double[2];\n+\n+        if (y == 0.0) {\n+            return 1.0;\n+        }\n+\n+        /* Handle special case x<0 */\n+        if (x < 0) {\n+            if (y == (long) y) {\n+                // If y is an integer\n+                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n+            } else {\n+                return Double.NaN;\n+            }\n+        }\n+\n+        if (x == 0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if ((bits & 0x8000000000000000L) != 0) {\n+                // -zero\n+                if (y < 0 && y == (long)y)\n+                    return Double.NEGATIVE_INFINITY;\n+            }\n+\n+            if (y < 0) {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+            if (y > 0) {\n+                return 0.0;\n+            }\n+\n+            return Double.NaN;\n+        }\n+\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (y < 0.0) {\n+                return 0.0;\n+            } else {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n+\n+        if (y == Double.POSITIVE_INFINITY) {\n+            if (x * x > 1.0) {\n+                return Double.POSITIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n+\n+        if (y == Double.NEGATIVE_INFINITY) {\n+            if (x*x < 1.0) {\n+                return Double.NEGATIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n+\n+        /* Split y into ya and yb such that y = ya+yb */\n+        double tmp1 = y * 1073741824.0;\n+        final double ya = y + tmp1 - tmp1;\n+        final double yb = y - ya;\n+\n+        /* Compute ln(x) */\n+        log(x, lns);\n+        double lna = lns[0];\n+        double lnb = lns[1];\n+\n+        /* resplit lns */\n+        tmp1 = lna * 1073741824.0;\n+        final double tmp2 = lna + tmp1 - tmp1;\n+        lnb += lna - tmp2;\n+        lna = tmp2;\n+\n+        // y*ln(x) = (aa+ab)\n+        final double aa = lna * ya;\n+        final double ab = lna * yb + lnb * ya + lnb * yb;\n+\n+        lna = aa+ab;\n+        lnb = -(lna - aa - ab);\n+\n+        double z = 1.0 / 120.0;\n+        z = z * lnb + (1.0 / 24.0);\n+        z = z * lnb + (1.0 / 6.0);\n+        z = z * lnb + 0.5;\n+        z = z * lnb + 1.0;\n+        z = z * lnb;\n+\n+        final double result = exp(lna, z, null);\n+        //result = result + result * z;\n+        return result;\n+    }\n+\n+    /** xi in the range of [1, 2].\n+     *                                3        5        7\n+     *      x+1           /          x        x        x          \\\n+     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n+     *      1-x           \\          3        5        7          /\n+     *\n+     * So, compute a Remez approximation of the following function\n+     *\n+     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n+     *\n+     * This will be an even function with only positive coefficents.\n+     * x is in the range [0 - 1/3].\n+     *\n+     * Transform xi for input to the above function by setting\n+     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n+     * the result is multiplied by x.\n+     * @param xi number from which log is requested\n+     * @return log(xi)\n+     */\n+    private static double[] slowLog(double xi) {\n+        double x[] = new double[2];\n+        double x2[] = new double[2];\n+        double y[] = new double[2];\n+        double a[] = new double[2];\n+\n+        split(xi, x);\n+\n+        /* Set X = (x-1)/(x+1) */\n+        x[0] += 1.0;\n+        resplit(x);\n+        splitReciprocal(x, a);\n+        x[0] -= 2.0;\n+        resplit(x);\n+        splitMult(x, a, y);\n+        x[0] = y[0];\n+        x[1] = y[1];\n+\n+        /* Square X -> X2*/\n+        splitMult(x, x, x2);\n+\n+\n+        //x[0] -= 1.0;\n+        //resplit(x);\n+\n+        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n+        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n+\n+        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n+            splitMult(y, x2, a);\n+            y[0] = a[0];\n+            y[1] = a[1];\n+            splitAdd(y, LN_SPLIT_COEF[i], a);\n+            y[0] = a[0];\n+            y[1] = a[1];\n+        }\n+\n+        splitMult(y, x, a);\n+        y[0] = a[0];\n+        y[1] = a[1];\n+\n+        return y;\n+    }\n+\n+    /**\n+     * For x between 0 and pi/4 compute sine.\n+     * @param x number from which sine is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * @return sin(x)\n+     */\n+    private static double slowSin(final double x, final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = 19; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+\n+            if ( (i & 1) == 0) {\n+                continue;\n+            }\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            if ( (i & 2) != 0 ) {\n+                facts[0] = -facts[0];\n+                facts[1] = -facts[1];\n+            }\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /**\n+     *  For x between 0 and pi/4 compute cosine\n+     * @param x number from which cosine is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * @return cos(x)\n+     */\n+    private static double slowCos(final double x, final double result[]) {\n+\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = 19; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+\n+            if ( (i & 1) != 0) {\n+                continue;\n+            }\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            if ( (i & 2) != 0 ) {\n+                facts[0] = -facts[0];\n+                facts[1] = -facts[1];\n+            }\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /** Build the sine and cosine tables.\n+     */\n+    private static void buildSinCosTables() {\n+        final double result[] = new double[2];\n+\n+        /* Use taylor series for 0 <= x <= 6/8 */\n+        for (int i = 0; i < 7; i++) {\n+            double x = i / 8.0;\n+\n+            slowSin(x, result);\n+            SINE_TABLE_A[i] = result[0];\n+            SINE_TABLE_B[i] = result[1];\n+\n+            slowCos(x, result);\n+            COSINE_TABLE_A[i] = result[0];\n+            COSINE_TABLE_B[i] = result[1];\n+        }\n+\n+        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n+        for (int i = 7; i < 14; i++) {\n+            double xs[] = new double[2];\n+            double ys[] = new double[2];\n+            double as[] = new double[2];\n+            double bs[] = new double[2];\n+            double temps[] = new double[2];\n+\n+            if ( (i & 1) == 0) {\n+                // Even, use double angle\n+                xs[0] = SINE_TABLE_A[i/2];\n+                xs[1] = SINE_TABLE_B[i/2];\n+                ys[0] = COSINE_TABLE_A[i/2];\n+                ys[1] = COSINE_TABLE_B[i/2];\n+\n+                /* compute sine */\n+                splitMult(xs, ys, result);\n+                SINE_TABLE_A[i] = result[0] * 2.0;\n+                SINE_TABLE_B[i] = result[1] * 2.0;\n+\n+                /* Compute cosine */\n+                splitMult(ys, ys, as);\n+                splitMult(xs, xs, temps);\n+                temps[0] = -temps[0];\n+                temps[1] = -temps[1];\n+                splitAdd(as, temps, result);\n+                COSINE_TABLE_A[i] = result[0];\n+                COSINE_TABLE_B[i] = result[1];\n+            } else {\n+                xs[0] = SINE_TABLE_A[i/2];\n+                xs[1] = SINE_TABLE_B[i/2];\n+                ys[0] = COSINE_TABLE_A[i/2];\n+                ys[1] = COSINE_TABLE_B[i/2];\n+                as[0] = SINE_TABLE_A[i/2+1];\n+                as[1] = SINE_TABLE_B[i/2+1];\n+                bs[0] = COSINE_TABLE_A[i/2+1];\n+                bs[1] = COSINE_TABLE_B[i/2+1];\n+\n+                /* compute sine */\n+                splitMult(xs, bs, temps);\n+                splitMult(ys, as, result);\n+                splitAdd(result, temps, result);\n+                SINE_TABLE_A[i] = result[0];\n+                SINE_TABLE_B[i] = result[1];\n+\n+                /* Compute cosine */\n+                splitMult(ys, bs, result);\n+                splitMult(xs, as, temps);\n+                temps[0] = -temps[0];\n+                temps[1] = -temps[1];\n+                splitAdd(result, temps, result);\n+                COSINE_TABLE_A[i] = result[0];\n+                COSINE_TABLE_B[i] = result[1];\n+            }\n+        }\n+\n+        /* Compute tangent = sine/cosine */\n+        for (int i = 0; i < 14; i++) {\n+            double xs[] = new double[2];\n+            double ys[] = new double[2];\n+            double as[] = new double[2];\n+\n+            as[0] = COSINE_TABLE_A[i];\n+            as[1] = COSINE_TABLE_B[i];\n+\n+            splitReciprocal(as, ys);\n+\n+            xs[0] = SINE_TABLE_A[i];\n+            xs[1] = SINE_TABLE_B[i];\n+\n+            splitMult(xs, ys, as);\n+\n+            TANGENT_TABLE_A[i] = as[0];\n+            TANGENT_TABLE_B[i] = as[1];\n+        }\n+\n+    }\n+\n+    /**\n+     *  Computes sin(x) - x, where |x| < 1/16.\n+     *  Use a Remez polynomial approximation.\n+     *  @param x a number smaller than 1/16\n+     *  @return sin(x) - x\n+     */\n+    private static double polySine(final double x)\n+    {\n+        double x2 = x*x;\n+\n+        double p = 2.7553817452272217E-6;\n+        p = p * x2 + -1.9841269659586505E-4;\n+        p = p * x2 + 0.008333333333329196;\n+        p = p * x2 + -0.16666666666666666;\n+        //p *= x2;\n+        //p *= x;\n+        p = p * x2 * x;\n+\n+        return p;\n+    }\n+\n+    /**\n+     *  Computes cos(x) - 1, where |x| < 1/16.\n+     *  Use a Remez polynomial approximation.\n+     *  @param x a number smaller than 1/16\n+     *  @return cos(x) - 1\n+     */\n+    private static double polyCosine(double x) {\n+        double x2 = x*x;\n+\n+        double p = 2.479773539153719E-5;\n+        p = p * x2 + -0.0013888888689039883;\n+        p = p * x2 + 0.041666666666621166;\n+        p = p * x2 + -0.49999999999999994;\n+        p *= x2;\n+\n+        return p;\n+    }\n+\n+    /**\n+     *  Compute sine over the first quadrant (0 < x < pi/2).\n+     *  Use combination of table lookup and rational polynomial expansion.\n+     *  @param xa number from which sine is requested\n+     *  @param xb extra bits for x (may be 0.0)\n+     *  @return sin(xa + xb)\n+     */\n+    private static double sinQ(double xa, double xb) {\n+        int idx = (int) ((xa * 8.0) + 0.5);\n+        final double epsilon = xa - EIGHTHES[idx]; //idx*0.125;\n+\n+        // Table lookups\n+        final double sintA = SINE_TABLE_A[idx];\n+        final double sintB = SINE_TABLE_B[idx];\n+        final double costA = COSINE_TABLE_A[idx];\n+        final double costB = COSINE_TABLE_B[idx];\n+\n+        // Polynomial eval of sin(epsilon), cos(epsilon)\n+        double sinEpsA = epsilon;\n+        double sinEpsB = polySine(epsilon);\n+        final double cosEpsA = 1.0;\n+        final double cosEpsB = polyCosine(epsilon);\n+\n+        // Split epsilon   xa + xb = x\n+        final double temp = sinEpsA * 1073741824.0;\n+        double temp2 = (sinEpsA + temp) - temp;\n+        sinEpsB +=  sinEpsA - temp2;\n+        sinEpsA = temp2;\n+\n+        /* Compute sin(x) by angle addition formula */\n+        double result;\n+\n+        /* Compute the following sum:\n+         *\n+         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+         *\n+         * Ranges of elements\n+         *\n+         * xxxtA   0            PI/2\n+         * xxxtB   -1.5e-9      1.5e-9\n+         * sinEpsA -0.0625      0.0625\n+         * sinEpsB -6e-11       6e-11\n+         * cosEpsA  1.0\n+         * cosEpsB  0           -0.0625\n+         *\n+         */\n+\n+        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+\n+        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n+        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n+        double a = 0;\n+        double b = 0;\n+\n+        double t = sintA;\n+        double c = a + t;\n+        double d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        t = costA * sinEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        b = b + sintA * cosEpsB + costA * sinEpsB;\n+        /*\n+    t = sintA*cosEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = costA*sinEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+         */\n+\n+        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n+        /*\n+    t = sintB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = costB*sinEpsA;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = sintB*cosEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+\n+    t = costB*sinEpsB;\n+    c = a + t;\n+    d = -(c - a - t);\n+    a = c;\n+    b = b + d;\n+         */\n+\n+        if (xb != 0.0) {\n+            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n+                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n+            c = a + t;\n+            d = -(c - a - t);\n+            a = c;\n+            b = b + d;\n+        }\n+\n+        result = a + b;\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Compute cosine in the first quadrant by subtracting input from PI/2 and\n+     * then calling sinQ.  This is more accurate as the input approaches PI/2.\n+     *  @param xa number from which cosine is requested\n+     *  @param xb extra bits for x (may be 0.0)\n+     *  @return cos(xa + xb)\n+     */\n+    private static double cosQ(double xa, double xb) {\n+        final double pi2a = 1.5707963267948966;\n+        final double pi2b = 6.123233995736766E-17;\n+\n+        final double a = pi2a - xa;\n+        double b = -(a - pi2a + xa);\n+        b += pi2b - xb;\n+\n+        return sinQ(a, b);\n+    }\n+\n+    /**\n+     *  Compute tangent (or cotangent) over the first quadrant.   0 < x < pi/2\n+     *  Use combination of table lookup and rational polynomial expansion.\n+     *  @param xa number from which sine is requested\n+     *  @param xb extra bits for x (may be 0.0)\n+     *  @param cotanFlag if true, compute the cotangent instead of the tangent\n+     *  @return tan(xa+xb) (or cotangent, depending on cotanFlag)\n+     */\n+    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n+\n+        int idx = (int) ((xa * 8.0) + 0.5);\n+        final double epsilon = xa - EIGHTHES[idx]; //idx*0.125;\n+\n+        // Table lookups\n+        final double sintA = SINE_TABLE_A[idx];\n+        final double sintB = SINE_TABLE_B[idx];\n+        final double costA = COSINE_TABLE_A[idx];\n+        final double costB = COSINE_TABLE_B[idx];\n+\n+        // Polynomial eval of sin(epsilon), cos(epsilon)\n+        double sinEpsA = epsilon;\n+        double sinEpsB = polySine(epsilon);\n+        final double cosEpsA = 1.0;\n+        final double cosEpsB = polyCosine(epsilon);\n+\n+        // Split epsilon   xa + xb = x\n+        double temp = sinEpsA * 1073741824.0;\n+        double temp2 = (sinEpsA + temp) - temp;\n+        sinEpsB +=  sinEpsA - temp2;\n+        sinEpsA = temp2;\n+\n+        /* Compute sin(x) by angle addition formula */\n+\n+        /* Compute the following sum:\n+         *\n+         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+         *\n+         * Ranges of elements\n+         *\n+         * xxxtA   0            PI/2\n+         * xxxtB   -1.5e-9      1.5e-9\n+         * sinEpsA -0.0625      0.0625\n+         * sinEpsB -6e-11       6e-11\n+         * cosEpsA  1.0\n+         * cosEpsB  0           -0.0625\n+         *\n+         */\n+\n+        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n+        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+\n+        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n+        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n+        double a = 0;\n+        double b = 0;\n+\n+        // Compute sine\n+        double t = sintA;\n+        double c = a + t;\n+        double d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        t = costA*sinEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        b = b + sintA*cosEpsB + costA*sinEpsB;\n+        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n+\n+        double sina = a + b;\n+        double sinb = -(sina - a - b);\n+\n+        // Compute cosine\n+\n+        a = b = c = d = 0.0;\n+\n+        t = costA*cosEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        t = -sintA*sinEpsA;\n+        c = a + t;\n+        d = -(c - a - t);\n+        a = c;\n+        b = b + d;\n+\n+        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n+        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n+\n+        double cosa = a + b;\n+        double cosb = -(cosa - a - b);\n+\n+        if (cotanFlag) {\n+            double tmp;\n+            tmp = cosa; cosa = sina; sina = tmp;\n+            tmp = cosb; cosb = sinb; sinb = tmp;\n+        }\n+\n+\n+        /* estimate and correct, compute 1.0/(cosa+cosb) */\n+        /*\n+    double est = (sina+sinb)/(cosa+cosb);\n+    double err = (sina - cosa*est) + (sinb - cosb*est);\n+    est += err/(cosa+cosb);\n+    err = (sina - cosa*est) + (sinb - cosb*est);\n+         */\n+\n+        // f(x) = 1/x,   f'(x) = -1/x^2\n+\n+        double est = sina/cosa;\n+\n+        /* Split the estimate to get more accurate read on division rounding */\n+        temp = est * 1073741824.0;\n+        double esta = (est + temp) - temp;\n+        double estb =  est - esta;\n+\n+        temp = cosa * 1073741824.0;\n+        double cosaa = (cosa + temp) - temp;\n+        double cosab =  cosa - cosaa;\n+\n+        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n+        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n+        err += sinb/cosa;                     // Change in est due to sinb\n+        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n+\n+        if (xb != 0.0) {\n+            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n+            // Approximate impact of xb\n+            double xbadj = xb + est*est*xb;\n+            if (cotanFlag) {\n+                xbadj = -xbadj;\n+            }\n+\n+            err += xbadj;\n+        }\n+\n+        return est+err;\n+    }\n+\n+    /** Reduce the input argument using the Payne and Hanek method.\n+     *  This is good for all inputs 0.0 < x < inf\n+     *  Output is remainder after dividing by PI/2\n+     *  The result array should contain 3 numbers.\n+     *  result[0] is the integer portion, so mod 4 this gives the quadrant.\n+     *  result[1] is the upper bits of the remainder\n+     *  result[2] is the lower bits of the remainder\n+     *\n+     * @param x number to reduce\n+     * @param result placeholder where to put the result\n+     */\n+    private static void reducePayneHanek(double x, double result[])\n+    {\n+        /* Convert input double to bits */\n+        long inbits = Double.doubleToLongBits(x);\n+        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n+\n+        /* Convert to fixed point representation */\n+        inbits &= 0x000fffffffffffffL;\n+        inbits |= 0x0010000000000000L;\n+\n+        /* Normalize input to be between 0.5 and 1.0 */\n+        exponent++;\n+        inbits <<= 11;\n+\n+        /* Based on the exponent, get a shifted copy of recip2pi */\n+        long shpi0;\n+        long shpiA;\n+        long shpiB;\n+        int idx = exponent >> 6;\n+        int shift = exponent - (idx << 6);\n+\n+        if (shift != 0) {\n+            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n+            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n+            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n+            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n+        } else {\n+            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n+            shpiA = RECIP_2PI[idx];\n+            shpiB = RECIP_2PI[idx+1];\n+        }\n+\n+        /* Multiply input by shpiA */\n+        long a = inbits >>> 32;\n+        long b = inbits & 0xffffffffL;\n+\n+        long c = shpiA >>> 32;\n+        long d = shpiA & 0xffffffffL;\n+\n+        long ac = a * c;\n+        long bd = b * d;\n+        long bc = b * c;\n+        long ad = a * d;\n+\n+        long prodB = bd + (ad << 32);\n+        long prodA = ac + (ad >>> 32);\n+\n+        boolean bita = (bd & 0x8000000000000000L) != 0;\n+        boolean bitb = (ad & 0x80000000L ) != 0;\n+        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prodA++;\n+        }\n+\n+        bita = (prodB & 0x8000000000000000L) != 0;\n+        bitb = (bc & 0x80000000L ) != 0;\n+\n+        prodB = prodB + (bc << 32);\n+        prodA = prodA + (bc >>> 32);\n+\n+        bitsum = (prodB & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prodA++;\n+        }\n+\n+        /* Multiply input by shpiB */\n+        c = shpiB >>> 32;\n+        d = shpiB & 0xffffffffL;\n+        ac = a * c;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        /* Collect terms */\n+        ac = ac + ((bc + ad) >>> 32);\n+\n+        bita = (prodB & 0x8000000000000000L) != 0;\n+        bitb = (ac & 0x8000000000000000L ) != 0;\n+        prodB += ac;\n+        bitsum = (prodB & 0x8000000000000000L) != 0;\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prodA++;\n+        }\n+\n+        /* Multiply by shpi0 */\n+        c = shpi0 >>> 32;\n+        d = shpi0 & 0xffffffffL;\n+\n+        bd = b * d;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        prodA += bd + ((bc + ad) << 32);\n+\n+        /*\n+         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n+         * PI/2, so use the following steps:\n+         * 1.) multiply by 4.\n+         * 2.) do a fixed point muliply by PI/4.\n+         * 3.) Convert to floating point.\n+         * 4.) Multiply by 2\n+         */\n+\n+        /* This identifies the quadrant */\n+        int intPart = (int)(prodA >>> 62);\n+\n+        /* Multiply by 4 */\n+        prodA <<= 2;\n+        prodA |= prodB >>> 62;\n+        prodB <<= 2;\n+\n+        /* Multiply by PI/4 */\n+        a = prodA >>> 32;\n+        b = prodA & 0xffffffffL;\n+\n+        c = PI_O_4_BITS[0] >>> 32;\n+        d = PI_O_4_BITS[0] & 0xffffffffL;\n+\n+        ac = a * c;\n+        bd = b * d;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        long prod2B = bd + (ad << 32);\n+        long prod2A = ac + (ad >>> 32);\n+\n+        bita = (bd & 0x8000000000000000L) != 0;\n+        bitb = (ad & 0x80000000L ) != 0;\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        bita = (prod2B & 0x8000000000000000L) != 0;\n+        bitb = (bc & 0x80000000L ) != 0;\n+\n+        prod2B = prod2B + (bc << 32);\n+        prod2A = prod2A + (bc >>> 32);\n+\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        /* Multiply input by pio4bits[1] */\n+        c = PI_O_4_BITS[1] >>> 32;\n+        d = PI_O_4_BITS[1] & 0xffffffffL;\n+        ac = a * c;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        /* Collect terms */\n+        ac = ac + ((bc + ad) >>> 32);\n+\n+        bita = (prod2B & 0x8000000000000000L) != 0;\n+        bitb = (ac & 0x8000000000000000L ) != 0;\n+        prod2B += ac;\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        /* Multiply inputB by pio4bits[0] */\n+        a = prodB >>> 32;\n+        b = prodB & 0xffffffffL;\n+        c = PI_O_4_BITS[0] >>> 32;\n+        d = PI_O_4_BITS[0] & 0xffffffffL;\n+        ac = a * c;\n+        bc = b * c;\n+        ad = a * d;\n+\n+        /* Collect terms */\n+        ac = ac + ((bc + ad) >>> 32);\n+\n+        bita = (prod2B & 0x8000000000000000L) != 0;\n+        bitb = (ac & 0x8000000000000000L ) != 0;\n+        prod2B += ac;\n+        bitsum = (prod2B & 0x8000000000000000L) != 0;\n+        /* Carry */\n+        if ( (bita && bitb) ||\n+                ((bita || bitb) && !bitsum) ) {\n+            prod2A++;\n+        }\n+\n+        /* Convert to double */\n+        double tmpA = (prod2A >>> 12) / 4503599627370496.0;  // High order 52 bits\n+        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / 4503599627370496.0 / 4503599627370496.0; // Low bits\n+\n+        double sumA = tmpA + tmpB;\n+        double sumB = -(sumA - tmpA - tmpB);\n+\n+        /* Multiply by PI/2 and return */\n+        result[0] = intPart;\n+        result[1] = sumA * 2.0;\n+        result[2] = sumB * 2.0;\n+    }\n+\n+    /**\n+     *  Sine function.\n+     *  @param x a number\n+     *  @return sin(x)\n+     */\n+    public static double sin(double x) {\n+        boolean negative = false;\n+        int quadrant = 0;\n+        double xa;\n+        double xb = 0.0;\n+\n+        /* Take absolute value of the input */\n+        xa = x;\n+        if (x < 0) {\n+            negative = true;\n+            xa = -xa;\n+        }\n+\n+        /* Check for zero and negative zero */\n+        if (xa == 0.0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if (bits < 0) {\n+                return -0.0;\n+            }\n+            return 0.0;\n+        }\n+\n+        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n+            return Double.NaN;\n+        }\n+\n+        /* Perform any argument reduction */\n+        if (xa > 3294198.0) {\n+            // PI * (2**20)\n+            // Argument too big for CodyWaite reduction.  Must use\n+            // PayneHanek.\n+            double reduceResults[] = new double[3];\n+            reducePayneHanek(xa, reduceResults);\n+            quadrant = ((int) reduceResults[0]) & 3;\n+            xa = reduceResults[1];\n+            xb = reduceResults[2];\n+        } else if (xa > 1.5707963267948966) {\n+            /* Inline the Cody/Waite reduction for performance */\n+\n+            // Estimate k\n+            //k = (int)(xa / 1.5707963267948966);\n+            int k = (int)(xa * 0.6366197723675814);\n+\n+            // Compute remainder\n+            double remA;\n+            double remB;\n+            while (true) {\n+                double a = -k * 1.570796251296997;\n+                remA = xa + a;\n+                remB = -(remA - xa - a);\n+\n+                a = -k * 7.549789948768648E-8;\n+                double b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                a = -k * 6.123233995736766E-17;\n+                b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                if (remA > 0.0)\n+                    break;\n+\n+                // Remainder is negative, so decrement k and try again.\n+                // This should only happen if the input is very close\n+                // to an even multiple of pi/2\n+                k--;\n+            }\n+            quadrant = k & 3;\n+            xa = remA;\n+            xb = remB;\n+        }\n+\n+        if (negative) {\n+            quadrant ^= 2;  // Flip bit 1\n+        }\n+\n+        switch (quadrant) {\n+            case 0:\n+                return sinQ(xa, xb);\n+            case 1:\n+                return cosQ(xa, xb);\n+            case 2:\n+                return -sinQ(xa, xb);\n+            case 3:\n+                return -cosQ(xa, xb);\n+            default:\n+                return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     *  Cosine function\n+     *  @param x a number\n+     *  @return cos(x)\n+     */\n+    public static double cos(double x) {\n+        int quadrant = 0;\n+\n+        /* Take absolute value of the input */\n+        double xa = x;\n+        if (x < 0) {\n+            xa = -xa;\n+        }\n+\n+        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n+            return Double.NaN;\n+        }\n+\n+        /* Perform any argument reduction */\n+        double xb = 0;\n+        if (xa > 3294198.0) {\n+            // PI * (2**20)\n+            // Argument too big for CodyWaite reduction.  Must use\n+            // PayneHanek.\n+            double reduceResults[] = new double[3];\n+            reducePayneHanek(xa, reduceResults);\n+            quadrant = ((int) reduceResults[0]) & 3;\n+            xa = reduceResults[1];\n+            xb = reduceResults[2];\n+        } else if (xa > 1.5707963267948966) {\n+            /* Inline the Cody/Waite reduction for performance */\n+\n+            // Estimate k\n+            //k = (int)(xa / 1.5707963267948966);\n+            int k = (int)(xa * 0.6366197723675814);\n+\n+            // Compute remainder\n+            double remA;\n+            double remB;\n+            while (true) {\n+                double a = -k * 1.570796251296997;\n+                remA = xa + a;\n+                remB = -(remA - xa - a);\n+\n+                a = -k * 7.549789948768648E-8;\n+                double b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                a = -k * 6.123233995736766E-17;\n+                b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                if (remA > 0.0)\n+                    break;\n+\n+                // Remainder is negative, so decrement k and try again.\n+                // This should only happen if the input is very close\n+                // to an even multiple of pi/2\n+                k--;\n+            }\n+            quadrant = k & 3;\n+            xa = remA;\n+            xb = remB;\n+        }\n+\n+        //if (negative)\n+        //  quadrant = (quadrant + 2) % 4;\n+\n+        switch (quadrant) {\n+            case 0:\n+                return cosQ(xa, xb);\n+            case 1:\n+                return -sinQ(xa, xb);\n+            case 2:\n+                return -cosQ(xa, xb);\n+            case 3:\n+                return sinQ(xa, xb);\n+            default:\n+                return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     *   Tangent function\n+     *  @param x a number\n+     *  @return tan(x)\n+     */\n+    public static double tan(double x) {\n+        boolean negative = false;\n+        int quadrant = 0;\n+\n+        /* Take absolute value of the input */\n+        double xa = x;\n+        if (x < 0) {\n+            negative = true;\n+            xa = -xa;\n+        }\n+\n+        /* Check for zero and negative zero */\n+        if (xa == 0.0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if (bits < 0) {\n+                return -0.0;\n+            }\n+            return 0.0;\n+        }\n+\n+        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n+            return Double.NaN;\n+        }\n+\n+        /* Perform any argument reduction */\n+        double xb = 0;\n+        if (xa > 3294198.0) {\n+            // PI * (2**20)\n+            // Argument too big for CodyWaite reduction.  Must use\n+            // PayneHanek.\n+            double reduceResults[] = new double[3];\n+            reducePayneHanek(xa, reduceResults);\n+            quadrant = ((int) reduceResults[0]) & 3;\n+            xa = reduceResults[1];\n+            xb = reduceResults[2];\n+        } else if (xa > 1.5707963267948966) {\n+            /* Inline the Cody/Waite reduction for performance */\n+\n+            // Estimate k\n+            //k = (int)(xa / 1.5707963267948966);\n+            int k = (int)(xa * 0.6366197723675814);\n+\n+            // Compute remainder\n+            double remA;\n+            double remB;\n+            while (true) {\n+                double a = -k * 1.570796251296997;\n+                remA = xa + a;\n+                remB = -(remA - xa - a);\n+\n+                a = -k * 7.549789948768648E-8;\n+                double b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                a = -k * 6.123233995736766E-17;\n+                b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                if (remA > 0.0)\n+                    break;\n+\n+                // Remainder is negative, so decrement k and try again.\n+                // This should only happen if the input is very close\n+                // to an even multiple of pi/2\n+                k--;\n+            }\n+            quadrant = k & 3;\n+            xa = remA;\n+            xb = remB;\n+        }\n+\n+        if (xa > 1.5) {\n+            // Accurracy suffers between 1.5 and PI/2\n+            final double pi2a = 1.5707963267948966;\n+            final double pi2b = 6.123233995736766E-17;\n+\n+            final double a = pi2a - xa;\n+            double b = -(a - pi2a + xa);\n+            b += pi2b - xb;\n+\n+            xa = a;\n+            xb = b;\n+            quadrant ^= 1;\n+            negative ^= true;\n+        }\n+\n+        double result;\n+        if ((quadrant & 1) == 0) {\n+            result = tanQ(xa, xb, false);\n+        } else {\n+            result = -tanQ(xa, xb, true);\n+        }\n+\n+        if (negative) {\n+            result = -result;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Arctangent function\n+     *  @param x a number\n+     *  @return atan(x)\n+     */\n+    public static double atan(double x) {\n+        return atan(x, 0.0, false);\n+    }\n+\n+    /** Internal helper function to compute arctangent.\n+     * @param xa number from which arctangent is requested\n+     * @param xb extra bits for x (may be 0.0)\n+     * @param leftPlane if true, result angle must be put in the left half plane\n+     * @return atan(xa + xb) (or angle shifted by &pi; if leftPlane is true)\n+     */\n+    private static double atan(double xa, double xb, boolean leftPlane) {\n+        boolean negate = false;\n+        boolean recip = false;\n+        int idx;\n+\n+        if (xa < 0) {\n+            // negative\n+            xa = -xa;\n+            xb = -xb;\n+            negate = true;\n+        }\n+\n+        if (xa > 1.633123935319537E16) { // Very large input\n+            return (negate ^ leftPlane) ? (-Math.PI/2.0) : (Math.PI/2.0);\n+        }\n+\n+        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\n+        if (xa < 1.0) {\n+            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n+        } else {\n+            double temp = 1.0/xa;\n+            idx = (int) (-((-1.7168146928204136 * temp * temp + 8.0) * temp) + 13.07);\n+        }\n+        double epsA = xa - TANGENT_TABLE_A[idx];\n+        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n+        epsB += xb - TANGENT_TABLE_B[idx];\n+\n+        double temp = epsA + epsB;\n+        epsB = -(temp - epsA - epsB);\n+        epsA = temp;\n+\n+        /* Compute eps = eps / (1.0 + xa*tangent) */\n+        temp = xa * 1073741824.0;\n+        double ya = xa + temp - temp;\n+        double yb = xb + xa - ya;\n+        xa = ya;\n+        xb += yb;\n+\n+        //if (idx > 8 || idx == 0)\n+        if (idx == 0) {\n+            /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n+            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n+            double denom = 1.0 / (1.0 + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n+            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\n+            ya = epsA * denom;\n+            yb = epsB * denom;\n+        } else {\n+            double temp2 = xa * TANGENT_TABLE_A[idx];\n+            double za = 1.0 + temp2;\n+            double zb = -(za - 1.0 - temp2);\n+            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n+            temp = za + temp2;\n+            zb += -(temp - za - temp2);\n+            za = temp;\n+\n+            zb += xb * TANGENT_TABLE_B[idx];\n+            ya = epsA / za;\n+\n+            temp = ya * 1073741824.0;\n+            final double yaa = (ya + temp) - temp;\n+            final double yab = ya - yaa;\n+\n+            temp = za * 1073741824.0;\n+            final double zaa = (za + temp) - temp;\n+            final double zab = za - zaa;\n+\n+            /* Correct for rounding in division */\n+            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n+\n+            yb += -epsA * zb / za / za;\n+            yb += epsB / za;\n+        }\n+\n+\n+        epsA = ya;\n+        epsB = yb;\n+\n+        /* Evaluate polynomial */\n+        double epsA2 = epsA*epsA;\n+\n+        /*\n+    yb = -0.09001346640161823;\n+    yb = yb * epsA2 + 0.11110718400605211;\n+    yb = yb * epsA2 + -0.1428571349122913;\n+    yb = yb * epsA2 + 0.19999999999273194;\n+    yb = yb * epsA2 + -0.33333333333333093;\n+    yb = yb * epsA2 * epsA;\n+         */\n+\n+        yb = 0.07490822288864472;\n+        yb = yb * epsA2 + -0.09088450866185192;\n+        yb = yb * epsA2 + 0.11111095942313305;\n+        yb = yb * epsA2 + -0.1428571423679182;\n+        yb = yb * epsA2 + 0.19999999999923582;\n+        yb = yb * epsA2 + -0.33333333333333287;\n+        yb = yb * epsA2 * epsA;\n+\n+\n+        ya = epsA;\n+\n+        temp = ya + yb;\n+        yb = -(temp - ya - yb);\n+        ya = temp;\n+\n+        /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\n+        yb += epsB / (1.0 + epsA * epsA);\n+\n+        double result;\n+        double resultb;\n+        if (recip) {\n+            final double pi2a = 1.5707963267948966;\n+            final double pi2b = 6.123233995736766E-17;\n+\n+            double za = pi2a - ya;\n+            double zb = -(za - pi2a + ya);\n+            temp = za - EIGHTHES[idx];\n+            zb += -(temp - za + EIGHTHES[idx]);\n+            za = temp;\n+\n+            zb += pi2b - yb;\n+            ya = za;\n+            yb = zb;\n+\n+            result = yb + ya;\n+            resultb = -(result - yb - ya);\n+        } else {\n+            //result = yb + eighths[idx] + ya;\n+            double za = EIGHTHES[idx] + ya;\n+            double zb = -(za - EIGHTHES[idx] - ya);\n+            temp = za + yb;\n+            zb += -(temp - za - yb);\n+            za = temp;\n+\n+            result = za + zb;\n+            resultb = -(result - za - zb);\n+        }\n+\n+        if (leftPlane) {\n+            // Result is in the left plane\n+            final double pia = 1.5707963267948966*2.0;\n+            final double pib = 6.123233995736766E-17*2.0;\n+\n+            final double za = pia - result;\n+            double zb = -(za - pia + result);\n+            zb += pib - resultb;\n+\n+            result = za + zb;\n+            resultb = -(result - za - zb);\n+        }\n+\n+\n+        if (negate ^ leftPlane) {\n+            result = -result;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Two arguments arctangent function\n+     * @param y ordinate\n+     * @param x abscissa\n+     * @return phase angle of point (x,y) between -&pi; and &pi;\n+     */\n+    public static double atan2(double y, double x) {\n+        if (x !=x || y != y) {\n+            return Double.NaN;\n+        }\n+\n+        if (y == 0.0) {\n+            double result = x*y;\n+            double invx = 1.0/x;\n+            double invy = 1.0/y;\n+\n+            if (invx == 0.0) { // X is infinite\n+                return 0.0;\n+            }\n+\n+            if (result != result) { // y must be infinite\n+                return x/y;\n+            }\n+\n+            if (x < 0.0 || invx < 0.0) {\n+                if (y < 0.0 || invy < 0.0) {\n+                    return -Math.PI;\n+                } else {\n+                    return Math.PI;\n+                }\n+            } else {\n+                return result;\n+            }\n+        }\n+\n+        if (y == Double.POSITIVE_INFINITY) {\n+            if (x == Double.POSITIVE_INFINITY) {\n+                return Math.PI/4.0;\n+            }\n+\n+            if (x == Double.NEGATIVE_INFINITY) {\n+                return Math.PI*3.0/4.0;\n+            }\n+\n+            return Math.PI/2.0;\n+        }\n+\n+        if (y == Double.NEGATIVE_INFINITY) {\n+            if (x == Double.POSITIVE_INFINITY) {\n+                return -Math.PI/4.0;\n+            }\n+\n+            if (x == Double.NEGATIVE_INFINITY) {\n+                return -Math.PI*3.0/4.0;\n+            }\n+\n+            return -Math.PI/2.0;\n+        }\n+\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (y > 0.0 || 1/y > 0.0) {\n+                return 0.0;\n+            }\n+\n+            if (y < 0.0 || 1/y < 0.0) {\n+                return -0.0;\n+            }\n+        }\n+\n+        if (x == Double.NEGATIVE_INFINITY)\n+        {\n+            if (y > 0.0 || 1/y > 0.0) {\n+                return Math.PI;\n+            }\n+\n+            if (y < 0.0 || 1/y < 0.0) {\n+                return -Math.PI;\n+            }\n+        }\n+\n+        if (x == 0) {\n+            if (y > 0.0 || 1/y > 0.0) {\n+                return Math.PI/2.0;\n+            }\n+\n+            if (y < 0.0 || 1/y < 0.0) {\n+                return -Math.PI/2.0;\n+            }\n+        }\n+\n+        if (x > 8e298 || x < -8e298) { // This would cause split of x to fail\n+            x *= 9.31322574615478515625E-10;\n+            y *= 9.31322574615478515625E-10;\n+        }\n+\n+        // Split y\n+        double temp = x * 1073741824.0;\n+        final double xa = x + temp - temp;\n+        final double xb = x - xa;\n+\n+        // Compute ratio r = x/y\n+        final double r = y/x;\n+        temp = r * 1073741824.0;\n+        double ra = r + temp - temp;\n+        double rb = r - ra;\n+\n+        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n+\n+        temp = ra + rb;\n+        rb = -(temp - ra - rb);\n+        ra = temp;\n+\n+        // Call atan\n+        double result = atan(ra, rb, x < 0);\n+\n+        return result;\n+    }\n+\n+    /**\n+     *  Convert degrees to radians, with error of less than 0.5 ULP\n+     *  @param x angle in degrees\n+     *  @return x converted into radians\n+     */\n+    public static double toRadians(double x)\n+    {\n+        final double facta = 0.01745329052209854;\n+        final double factb = 1.997844754509471E-9;\n+\n+        double temp = x * 1073741824.0;\n+        double xa = x + temp - temp;\n+        double xb = x - xa;\n+\n+        return xb * factb + xb * facta + xa * factb + xa * facta;\n+    }\n+\n+    /**\n+     *  Convert radians to degrees, with error of less than 0.5 ULP\n+     *  @param x angle in radians\n+     *  @return x converted into degrees\n+     */\n+    public static double toDegrees(double x)\n+    {\n+        final double facta = 57.2957763671875;\n+        final double factb = 3.145894820876798E-6;\n+\n+        double temp = x * 1073741824.0;\n+        double xa = x + temp - temp;\n+        double xb = x - xa;\n+\n+        return xb * factb + xb * facta + xa * factb + xa * facta;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static int abs(final int x) {\n+        return (x < 0) ? -x : x;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static long abs(final long x) {\n+        return (x < 0l) ? -x : x;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static float abs(final float x) {\n+        return (x < 0.0f) ? -x : x;\n+    }\n+\n+    /**\n+     * Absolute value.\n+     * @param x number from which absolute value is requested\n+     * @return abs(x)\n+     */\n+    public static double abs(double x) {\n+        return (x < 0.0) ? -x : x;\n+    }\n+\n+    /**\n+     * Compute least significant bit (Unit in Last Position) for a number.\n+     * @param x number from which ulp is requested\n+     * @return ulp(x)\n+     */\n+\n+    public static double ulp(double x) {\n+        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n+    }\n+\n+    /**\n+     * Get the next machine representable number after a number, moving\n+     * in the direction of another number.\n+     * <p>\n+     * If <code>direction</code> is greater than or equal to<code>d</code>,\n+     * the smallest machine representable number strictly greater than\n+     * <code>d</code> is returned; otherwise the largest representable number\n+     * strictly less than <code>d</code> is returned.</p>\n+     * <p>\n+     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n+     *\n+     * @param d base number\n+     * @param direction (the only important thing is whether\n+     * direction is greater or smaller than d)\n+     * @return the next machine representable number in the specified direction\n+     */\n+    public static double nextAfter(double d, double direction) {\n+\n+        // handling of some important special cases\n+        if (Double.isNaN(d) || Double.isInfinite(d)) {\n+            return d;\n+        } else if (d == 0) {\n+            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n+        }\n+        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n+        // are handled just as normal numbers\n+\n+        // split the double in raw components\n+        long bits     = Double.doubleToLongBits(d);\n+        long sign     = bits & 0x8000000000000000L;\n+        long exponent = bits & 0x7ff0000000000000L;\n+        long mantissa = bits & 0x000fffffffffffffL;\n+\n+        if (d * (direction - d) >= 0) {\n+            // we should increase the mantissa\n+            if (mantissa == 0x000fffffffffffffL) {\n+                return Double.longBitsToDouble(sign |\n+                                               (exponent + 0x0010000000000000L));\n+            } else {\n+                return Double.longBitsToDouble(sign |\n+                                               exponent | (mantissa + 1));\n+            }\n+        } else {\n+            // we should decrease the mantissa\n+            if (mantissa == 0L) {\n+                return Double.longBitsToDouble(sign |\n+                                               (exponent - 0x0010000000000000L) |\n+                                               0x000fffffffffffffL);\n+            } else {\n+                return Double.longBitsToDouble(sign |\n+                                               exponent | (mantissa - 1));\n+            }\n+        }\n+\n+    }\n+\n+    /** Get the largest whole number smaller than x.\n+     * @param x number from which floor is requested\n+     * @return a double number f such that f is an integer f <= x < f + 1.0\n+     */\n+    public static double floor(double x) {\n+        long y;\n+\n+        if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {\n+            return x;\n+        }\n+\n+        y = (long) x;\n+        if (x < 0) {\n+            y--;\n+        }\n+\n+        return (double) y;\n+    }\n+\n+    /** Get the smallest whole number larger than x.\n+     * @param x number from which ceil is requested\n+     * @return a double number c such that c is an integer c - 1.0 < x <= c\n+     */\n+    public static double ceil(double x) {\n+        double y;\n+\n+        y = floor(x);\n+        if (y == x) {\n+            return y;\n+        }\n+\n+        return y + 1.0;\n+    }\n+\n+    /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n+     * @param x number from which nearest whole number is requested\n+     * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5\n+     */\n+    public static double rint(double x) {\n+        double y = floor(x);\n+        double d = x - y;\n+\n+        if (d > 0.5) {\n+            return y+1.0;\n+        }\n+        if (d < 0.5) {\n+            return y;\n+        }\n+\n+        /* half way, round to even */\n+        long z = (long) y;\n+        return (z & 1) == 0 ? y : y + 1.0;\n+    }\n+\n+    /** Get the closest long to x.\n+     * @param x number from which closest long is requested\n+     * @return closest long to x\n+     */\n+    public static long round(double x) {\n+        return (long) floor(x + 0.5);\n+    }\n+\n+    /** Get the closest int to x.\n+     * @param x number from which closest int is requested\n+     * @return closest int to x\n+     */\n+    public static int round(final float x) {\n+        return Math.round(x);\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static int min(final int a, final int b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static long min(final long a, final long b) {\n+        return (a <= b) ? a : b;\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static float min(final float a, final float b) {\n+        return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n+    }\n+\n+    /** Compute the minimum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return a if a is lesser or equal to b, b otherwise\n+     */\n+    public static double min(final double a, final double b) {\n+        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static int max(final int a, final int b) {\n+        return (a <= b) ? b : a;\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static long max(final long a, final long b) {\n+        return (a <= b) ? b : a;\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static float max(final float a, final float b) {\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+    }\n+\n+    /** Compute the maximum of two values\n+     * @param a first value\n+     * @param b second value\n+     * @return b if a is lesser or equal to b, a otherwise\n+     */\n+    public static double max(final double a, final double b) {\n+        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      * 2 &pi;.\n      * @since 2.1\n      */\n-    public static final double TWO_PI = 2 * Math.PI;\n+    public static final double TWO_PI = 2 * FastMath.PI;\n \n     /** -1.0 cast as a byte. */\n     private static final byte  NB = (byte)-1;\n              result *= (double)(n - k + i) / (double)i;\n         }\n \n-        return Math.floor(result + 0.5);\n+        return FastMath.floor(result + 0.5);\n     }\n \n     /**\n             return 0;\n         }\n         if ((k == 1) || (k == n - 1)) {\n-            return Math.log(n);\n+            return FastMath.log(n);\n         }\n \n         /*\n          * return the log of the exact value\n          */\n         if (n < 67) {\n-            return Math.log(binomialCoefficient(n,k));\n+            return FastMath.log(binomialCoefficient(n,k));\n         }\n \n         /*\n          * overflow binomialCoefficientDouble\n          */\n         if (n < 1030) {\n-            return Math.log(binomialCoefficientDouble(n, k));\n+            return FastMath.log(binomialCoefficientDouble(n, k));\n         }\n \n         if (k > n / 2) {\n \n         // n!/(n-k)!\n         for (int i = n - k + 1; i <= n; i++) {\n-            logSum += Math.log(i);\n+            logSum += FastMath.log(i);\n         }\n \n         // divide by k!\n         for (int i = 2; i <= k; i++) {\n-            logSum -= Math.log(i);\n+            logSum -= FastMath.log(i);\n         }\n \n         return logSum;\n      * @return hyperbolic cosine of x\n      */\n     public static double cosh(double x) {\n-        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n+        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n     }\n \n     /**\n      * @return {@code true} if the values are equal or within range of each other.\n      */\n     public static boolean equals(double x, double y, double eps) {\n-        return equals(x, y, 1) || Math.abs(y - x) <= eps;\n+        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n     }\n \n     /**\n      * or both are NaN.\n      */\n     public static boolean equalsIncludingNaN(double x, double y, double eps) {\n-        return equalsIncludingNaN(x, y) || (Math.abs(y - x) <= eps);\n+        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n     }\n \n     /**\n             yInt = SGN_MASK - yInt;\n         }\n \n-        final boolean isEqual = Math.abs(xInt - yInt) <= maxUlps;\n+        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n \n         return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n     }\n         if (n < 21) {\n             return factorial(n);\n         }\n-        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);\n     }\n \n     /**\n                   n);\n         }\n         if (n < 21) {\n-            return Math.log(factorial(n));\n+            return FastMath.log(factorial(n));\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n-            logSum += Math.log(i);\n+            logSum += FastMath.log(i);\n         }\n         return logSum;\n     }\n                         LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                         p, q);\n             }\n-            return Math.abs(u) + Math.abs(v);\n+            return FastMath.abs(u) + FastMath.abs(v);\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n                         LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                         p, q);\n             }\n-            return Math.abs(u) + Math.abs(v);\n+            return FastMath.abs(u) + FastMath.abs(v);\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^63, while positive numbers can only be as large as 2^63-1\n         if (a==0 || b==0){\n             return 0;\n         }\n-        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n+        int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n         if (lcm == Integer.MIN_VALUE) {\n             throw MathRuntimeException.createArithmeticException(\n                 LocalizedFormats.LCM_OVERFLOW_32_BITS,\n         if (a==0 || b==0){\n             return 0;\n         }\n-        long lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n+        long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n         if (lcm == Long.MIN_VALUE){\n             throw MathRuntimeException.createArithmeticException(\n                 LocalizedFormats.LCM_OVERFLOW_64_BITS,\n      * @since 1.2\n      */\n     public static double log(double base, double x) {\n-        return Math.log(x)/Math.log(base);\n+        return FastMath.log(x)/FastMath.log(base);\n     }\n \n     /**\n      * direction is greater or smaller than d)\n      * @return the next machine representable number in the specified direction\n      * @since 1.2\n-     */\n+     * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\n+     */\n+    @Deprecated\n     public static double nextAfter(double d, double direction) {\n-\n-        // handling of some important special cases\n-        if (Double.isNaN(d) || Double.isInfinite(d)) {\n-                return d;\n-        } else if (d == 0) {\n-                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n-        }\n-        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n-        // are handled just as normal numbers\n-\n-        // split the double in raw components\n-        long bits     = Double.doubleToLongBits(d);\n-        long sign     = bits & 0x8000000000000000L;\n-        long exponent = bits & 0x7ff0000000000000L;\n-        long mantissa = bits & 0x000fffffffffffffL;\n-\n-        if (d * (direction - d) >= 0) {\n-                // we should increase the mantissa\n-                if (mantissa == 0x000fffffffffffffL) {\n-                        return Double.longBitsToDouble(sign |\n-                                        (exponent + 0x0010000000000000L));\n-                } else {\n-                        return Double.longBitsToDouble(sign |\n-                                        exponent | (mantissa + 1));\n-                }\n-        } else {\n-                // we should decrease the mantissa\n-                if (mantissa == 0L) {\n-                        return Double.longBitsToDouble(sign |\n-                                        (exponent - 0x0010000000000000L) |\n-                                        0x000fffffffffffffL);\n-                } else {\n-                        return Double.longBitsToDouble(sign |\n-                                        exponent | (mantissa - 1));\n-                }\n-        }\n-\n+        return FastMath.nextAfter(d, direction);\n     }\n \n     /**\n      * <p>This method has three main uses:</p>\n      * <ul>\n      *   <li>normalize an angle between 0 and 2&pi;:<br/>\n-     *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>\n+     *       <code>a = MathUtils.normalizeAngle(a, FastMath.PI);</code></li>\n      *   <li>normalize an angle between -&pi; and +&pi;<br/>\n      *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>\n      *   <li>compute the angle between two defining angular positions:<br>\n      * @since 1.2\n      */\n      public static double normalizeAngle(double a, double center) {\n-         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n+         return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n      }\n \n      /**\n      */\n     public static float round(float x, int scale, int roundingMethod) {\n         float sign = indicator(x);\n-        float factor = (float)Math.pow(10.0f, scale) * sign;\n+        float factor = (float)FastMath.pow(10.0f, scale) * sign;\n         return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n     }\n \n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n-                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             } else {\n-                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_DOWN :\n-            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             break;\n         case BigDecimal.ROUND_FLOOR :\n             if (sign == -1) {\n-                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             } else {\n-                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_HALF_DOWN : {\n             unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n-            double fraction = unscaled - Math.floor(unscaled);\n+            double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction > 0.5) {\n-                unscaled = Math.ceil(unscaled);\n+                unscaled = FastMath.ceil(unscaled);\n             } else {\n-                unscaled = Math.floor(unscaled);\n+                unscaled = FastMath.floor(unscaled);\n             }\n             break;\n         }\n         case BigDecimal.ROUND_HALF_EVEN : {\n-            double fraction = unscaled - Math.floor(unscaled);\n+            double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction > 0.5) {\n-                unscaled = Math.ceil(unscaled);\n+                unscaled = FastMath.ceil(unscaled);\n             } else if (fraction < 0.5) {\n-                unscaled = Math.floor(unscaled);\n+                unscaled = FastMath.floor(unscaled);\n             } else {\n                 // The following equality test is intentional and needed for rounding purposes\n-                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n+                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math\n                     .floor(unscaled) / 2.0)) { // even\n-                    unscaled = Math.floor(unscaled);\n+                    unscaled = FastMath.floor(unscaled);\n                 } else { // odd\n-                    unscaled = Math.ceil(unscaled);\n+                    unscaled = FastMath.ceil(unscaled);\n                 }\n             }\n             break;\n         }\n         case BigDecimal.ROUND_HALF_UP : {\n             unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n-            double fraction = unscaled - Math.floor(unscaled);\n+            double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction >= 0.5) {\n-                unscaled = Math.ceil(unscaled);\n+                unscaled = FastMath.ceil(unscaled);\n             } else {\n-                unscaled = Math.floor(unscaled);\n+                unscaled = FastMath.floor(unscaled);\n             }\n             break;\n         }\n         case BigDecimal.ROUND_UNNECESSARY :\n-            if (unscaled != Math.floor(unscaled)) {\n+            if (unscaled != FastMath.floor(unscaled)) {\n                 throw new ArithmeticException(\"Inexact result from rounding\");\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n-            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n             throw MathRuntimeException.createIllegalArgumentException(\n      * @return hyperbolic sine of x\n      */\n     public static double sinh(double x) {\n-        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n+        return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;\n     }\n \n     /**\n     public static double distance1(double[] p1, double[] p2) {\n         double sum = 0;\n         for (int i = 0; i < p1.length; i++) {\n-            sum += Math.abs(p1[i] - p2[i]);\n+            sum += FastMath.abs(p1[i] - p2[i]);\n         }\n         return sum;\n     }\n     public static int distance1(int[] p1, int[] p2) {\n       int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          sum += Math.abs(p1[i] - p2[i]);\n+          sum += FastMath.abs(p1[i] - p2[i]);\n       }\n       return sum;\n     }\n             final double dp = p1[i] - p2[i];\n             sum += dp * dp;\n         }\n-        return Math.sqrt(sum);\n+        return FastMath.sqrt(sum);\n     }\n \n     /**\n           final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n-      return Math.sqrt(sum);\n+      return FastMath.sqrt(sum);\n     }\n \n     /**\n     public static double distanceInf(double[] p1, double[] p2) {\n         double max = 0;\n         for (int i = 0; i < p1.length; i++) {\n-            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n+            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n         }\n         return max;\n     }\n     public static int distanceInf(int[] p1, int[] p2) {\n         int max = 0;\n         for (int i = 0; i < p1.length; i++) {\n-            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n+            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n         }\n         return max;\n     }\n     }\n     return norm;\n }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n         if (expectedSize == 0) {\n             return 1;\n         }\n-        final int capacity   = (int) Math.ceil(expectedSize / LOAD_FACTOR);\n+        final int capacity   = (int) FastMath.ceil(expectedSize / LOAD_FACTOR);\n         final int powerOfTwo = Integer.highestOneBit(capacity);\n         if (powerOfTwo == capacity) {\n             return capacity;\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n         if (expectedSize == 0) {\n             return 1;\n         }\n-        final int capacity   = (int) Math.ceil(expectedSize / LOAD_FACTOR);\n+        final int capacity   = (int) FastMath.ceil(expectedSize / LOAD_FACTOR);\n         final int powerOfTwo = Integer.highestOneBit(capacity);\n         if (powerOfTwo == capacity) {\n             return capacity;\n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      */\n     protected synchronized void expand() {\n \n-        // notice the use of Math.ceil(), this guarantees that we will always\n+        // notice the use of FastMath.ceil(), this guarantees that we will always\n         // have an array of at least currentSize + 1.   Assume that the\n         // current initial capacity is 1 and the expansion factor\n         // is 1.000000000000000001.  The newly calculated size will be\n         // rounded up to 2 after the multiplication is performed.\n         int newSize = 0;\n         if (expansionMode == MULTIPLICATIVE_MODE) {\n-            newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n+            newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);\n         } else {\n-            newSize = internalArray.length + Math.round(expansionFactor);\n+            newSize = internalArray.length + FastMath.round(expansionFactor);\n         }\n         double[] tempArray = new double[newSize];\n \n--- a/src/test/java/org/apache/commons/math/ArgumentOutsideDomainExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/ArgumentOutsideDomainExceptionTest.java\n \n import java.util.Locale;\n \n+import org.apache.commons.math.util.FastMath;\n+\n import junit.framework.TestCase;\n \n /**\n public class ArgumentOutsideDomainExceptionTest extends TestCase {\n \n     public void testConstructor(){\n-        ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0);\n+        ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(FastMath.PI, 10.0, 20.0);\n         assertNull(ex.getCause());\n         assertNotNull(ex.getMessage());\n         assertTrue(ex.getMessage().indexOf(\"3.14\") > 0);\n-        assertEquals(Math.PI, ex.getArgument()[0], 0);\n+        assertEquals(FastMath.PI, ex.getArgument()[0], 0);\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n \n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Revision$ $Date$\n         } else if (expected == 0.0) {\n             Assert.assertEquals(msg, actual, expected, relativeError);\n         } else {\n-            double absError = Math.abs(expected) * relativeError;\n+            double absError = FastMath.abs(expected) * relativeError;\n             Assert.assertEquals(msg, expected, actual, absError);\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n \n     @Test\n     public void testAtan2() throws FunctionEvaluationException {\n-        Assert.assertEquals(Math.PI / 4, BinaryFunction.ATAN2.value(1, 1), 1.0e-15);\n-        Assert.assertEquals(-Math.PI / 4, BinaryFunction.ATAN2.value(-1, 1), 1.0e-15);\n+        Assert.assertEquals(FastMath.PI / 4, BinaryFunction.ATAN2.value(1, 1), 1.0e-15);\n+        Assert.assertEquals(-FastMath.PI / 4, BinaryFunction.ATAN2.value(-1, 1), 1.0e-15);\n     }\n \n     @Test\n     public void testFix1st() throws FunctionEvaluationException {\n         ComposableFunction f = BinaryFunction.POW.fix1stArgument(2);\n         for (double x = 0.0; x < 1.0; x += 0.01) {\n-            Assert.assertEquals(Math.pow(2.0, x), f.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.pow(2.0, x), f.value(x), 1.0e-15);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n \n         ComposableFunction f1 = sqrt.of(abs.of(expm1.of(cbrt.of(tanh).of(id))));\n         for (double x = 0.1; x < 0.9; x += 0.01) {\n-            Assert.assertEquals(Math.sqrt(Math.abs(Math.expm1(Math.cbrt(Math.tanh(x))))),\n+            Assert.assertEquals(FastMath.sqrt(FastMath.abs(FastMath.expm1(FastMath.cbrt(FastMath.tanh(x))))),\n                                 f1.value(x), 1.0e-15);\n         }\n \n         ComposableFunction f2 = cosh.of(sinh.of(tanh.of(ceil.postCompose(log.postCompose(cosh)))));\n         for (double x = 0.1; x < 12.9; x += 1.0) {\n-            Assert.assertEquals(Math.cosh(Math.sinh(Math.tanh(Math.cosh(Math.log(Math.ceil(x)))))),\n+            Assert.assertEquals(FastMath.cosh(FastMath.sinh(FastMath.tanh(FastMath.cosh(FastMath.log(FastMath.ceil(x)))))),\n                                 f2.value(x), 1.0e-15);\n         }\n \n         ComposableFunction f3 = cos.of(sin.of(tan.of(acos.of(asin.of(log10.of(log.of(ulp)))))));\n         for (double x = 1.0e16; x < 1.0e17; x += 1.0e16) {\n-            Assert.assertEquals(Math.cos(Math.sin(Math.tan(Math.acos(Math.asin(Math.log10(Math.log(Math.ulp(x)))))))),\n+            Assert.assertEquals(FastMath.cos(FastMath.sin(FastMath.tan(FastMath.acos(FastMath.asin(FastMath.log10(FastMath.log(FastMath.ulp(x)))))))),\n                                 f3.value(x), 1.0e-15);\n         }\n \n         ComposableFunction f4 = atan.of(exp.of(negate.of(floor)));\n         for (double x = 1.1; x < 10.2; x += 1.0) {\n-            Assert.assertEquals(Math.atan(Math.exp(-Math.floor(x))),\n+            Assert.assertEquals(FastMath.atan(FastMath.exp(-FastMath.floor(x))),\n                                 f4.value(x), 1.0e-15);\n         }\n \n         ComposableFunction f =\n             ComposableFunction.COS.combine(ComposableFunction.ASIN, BinaryFunction.POW);\n         for (double x = 0.1; x < 0.9; x += 0.01) {\n-            Assert.assertEquals(Math.pow(Math.cos(x), Math.asin(x)), f.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.pow(FastMath.cos(x), FastMath.asin(x)), f.value(x), 1.0e-15);\n         }\n \n     }\n         ComposableFunction f5 = ComposableFunction.COS.multiply(5);\n         ComposableFunction f6 = ComposableFunction.COS.divide(ComposableFunction.SIN);\n         for (double x = 0.1; x < 0.9; x += 0.01) {\n-            Assert.assertEquals(Math.cos(x) + 3, f1.value(x), 1.0e-15);\n-            Assert.assertEquals(Math.cos(x) + Math.sin(x), f2.value(x), 1.0e-15);\n-            Assert.assertEquals(Math.cos(x) - Math.sin(x), f3.value(x), 1.0e-15);\n-            Assert.assertEquals(Math.cos(x) * Math.sin(x), f4.value(x), 1.0e-15);\n-            Assert.assertEquals(Math.cos(x) * 5, f5.value(x), 1.0e-15);\n-            Assert.assertEquals(Math.cos(x) / Math.sin(x), f6.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.cos(x) + 3, f1.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.cos(x) + FastMath.sin(x), f2.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.cos(x) - FastMath.sin(x), f3.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.cos(x) * FastMath.sin(x), f4.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.cos(x) * 5, f5.value(x), 1.0e-15);\n+            Assert.assertEquals(FastMath.cos(x) / FastMath.sin(x), f6.value(x), 1.0e-15);\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n+++ b/src/test/java/org/apache/commons/math/analysis/Expm1Function.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Auxillary class for testing purposes.\n public class Expm1Function implements DifferentiableUnivariateRealFunction {\n \n     public double value(double x) throws FunctionEvaluationException {\n-        // Math.expm1() is available in jdk 1.5 but not in jdk 1.4.2.\n-        return Math.exp(x) - 1.0;\n+        // FastMath.expm1() is available in jdk 1.5 but not in jdk 1.4.2.\n+        return FastMath.exp(x) - 1.0;\n     }\n \n     public UnivariateRealFunction derivative() {\n         return new UnivariateRealFunction() {\n             public double value(double x) throws FunctionEvaluationException {\n-                return Math.exp(x);\n+                return FastMath.exp(x);\n             }\n         };\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Auxillary class for testing solvers.\n      * @see org.apache.commons.math.UnivariateRealFunction#value(double)\n      */\n     public double value(double x) throws FunctionEvaluationException {\n-        return Math.sin(x);\n+        return FastMath.sin(x);\n     }\n \n     /* First derivative of sinus function\n     public UnivariateRealFunction derivative() {\n         return new UnivariateRealFunction() {\n             public double value(double x) throws FunctionEvaluationException {\n-                return Math.cos(x);\n+                return FastMath.cos(x);\n             }\n         };\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegratorTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n         integrator.setMaximalIterationCount(15);\n         double min, max, expected, result, tolerance;\n \n-        min = 0; max = Math.PI; expected = 2;\n-        tolerance = Math.max(integrator.getAbsoluteAccuracy(),\n-                             Math.abs(expected * integrator.getRelativeAccuracy()));\n+        min = 0; max = FastMath.PI; expected = 2;\n+        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n+                             FastMath.abs(expected * integrator.getRelativeAccuracy()));\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n-        min = -Math.PI/3; max = 0; expected = -0.5;\n-        tolerance = Math.max(integrator.getAbsoluteAccuracy(),\n-                Math.abs(expected * integrator.getRelativeAccuracy()));\n+        min = -FastMath.PI/3; max = 0; expected = -0.5;\n+        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n+                FastMath.abs(expected * integrator.getRelativeAccuracy()));\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n                     PolynomialFunction p = new PolynomialFunction(coeff);\n                     double result    = integrator.integrate(p, -5.0, 15.0);\n                     double reference = exactIntegration(p, -5.0, 15.0);\n-                    assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + Math.abs(reference)));\n+                    assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));\n                 }\n             }\n \n--- a/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n         UnivariateRealIntegrator integrator = new RombergIntegrator();\n         double min, max, expected, result, tolerance;\n \n-        min = 0; max = Math.PI; expected = 2;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        min = 0; max = FastMath.PI; expected = 2;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n-        min = -Math.PI/3; max = 0; expected = -0.5;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        min = -FastMath.PI/3; max = 0; expected = -0.5;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = 1; expected = -1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n         UnivariateRealIntegrator integrator = new SimpsonIntegrator();\n         double min, max, expected, result, tolerance;\n \n-        min = 0; max = Math.PI; expected = 2;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        min = 0; max = FastMath.PI; expected = 2;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n-        min = -Math.PI/3; max = 0; expected = -0.5;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        min = -FastMath.PI/3; max = 0; expected = -0.5;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = 1; expected = -1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n         UnivariateRealIntegrator integrator = new TrapezoidIntegrator();\n         double min, max, expected, result, tolerance;\n \n-        min = 0; max = Math.PI; expected = 2;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        min = 0; max = FastMath.PI; expected = 2;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n-        min = -Math.PI/3; max = 0; expected = -0.5;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        min = -FastMath.PI/3; max = 0; expected = -0.5;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = 0; max = 1; expected = -1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0; max = 0.5; expected = 11.0/768;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n-        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n         result = integrator.integrate(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n \n         // 6 interpolating points on interval [0, 2*PI]\n         int n = 6;\n-        double min = 0.0, max = 2 * Math.PI;\n+        double min = 0.0, max = 2 * FastMath.PI;\n         x = new double[n];\n         y = new double[n];\n         for (int i = 0; i < n; i++) {\n         double derivativebound = 1.0;\n         UnivariateRealFunction p = interpolator.interpolate(x, y);\n \n-        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n \n-        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n     }\n \n             x[i] = min + i * (max - min) / n;\n             y[i] = f.value(x[i]);\n         }\n-        double derivativebound = Math.E;\n+        double derivativebound = FastMath.E;\n         UnivariateRealFunction p = interpolator.interpolate(x, y);\n \n         z = 0.0; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n \n         z = 0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n \n         z = -0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LoessInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n         double fitResidualSum = 0;\n \n         for(int i = 0; i < numPoints; ++i) {\n-            double expected = Math.sin(xval[i]);\n+            double expected = FastMath.sin(xval[i]);\n             double noisy = yval[i];\n             double fit = res[i];\n \n-            noisyResidualSum += Math.pow(noisy - expected, 2);\n-            fitResidualSum += Math.pow(fit - expected, 2);\n+            noisyResidualSum += FastMath.pow(noisy - expected, 2);\n+            fitResidualSum += FastMath.pow(fit - expected, 2);\n         }\n \n         Assert.assertTrue(fitResidualSum < noisyResidualSum);\n             double[] res = li.smooth(xval, yval);\n \n             for (int j = 1; j < res.length; ++j) {\n-                variances[i] += Math.pow(res[j] - res[j-1], 2);\n+                variances[i] += FastMath.pow(res[j] - res[j-1], 2);\n             }\n         }\n \n             double[] res = li.smooth(xval, yval);\n \n             for (int j = 1; j < res.length; ++j) {\n-                variances[i] += Math.abs(res[j] - res[j-1]);\n+                variances[i] += FastMath.abs(res[j] - res[j-1]);\n             }\n         }\n \n     }\n \n     private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) {\n-        double dx = 2 * Math.PI / xval.length;\n+        double dx = 2 * FastMath.PI / xval.length;\n         double x = 0;\n         for(int i = 0; i < xval.length; ++i) {\n             xval[i] = x;\n-            yval[i] = Math.sin(x) + (2 * Math.random() - 1) * ynoise;\n-            x += dx * (1 + (2 * Math.random() - 1) * xnoise);\n+            yval[i] = FastMath.sin(x) + (2 * FastMath.random() - 1) * ynoise;\n+            x += dx * (1 + (2 * FastMath.random() - 1) * xnoise);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n         c[1] = 0;\n         expected = f.value(c);\n         result = p.value(c);\n-        Assert.assertEquals(\"On sample point\", expected, result, Math.ulp(1d));\n+        Assert.assertEquals(\"On sample point\", expected, result, FastMath.ulp(1d));\n \n         c[0] = 0 + 1e-5;\n         c[1] = 1 - 1e-5;\n         c[1] = 0;\n         expected = f.value(c);\n         result = p.value(c);\n-        Assert.assertEquals(\"On sample point\", expected, result, Math.ulp(1d));\n+        Assert.assertEquals(\"On sample point\", expected, result, FastMath.ulp(1d));\n \n         c[0] = 2 + 1e-5;\n         c[1] = 2 - 1e-5;\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n \n         // 6 interpolating points on interval [0, 2*PI]\n         int n = 6;\n-        double min = 0.0, max = 2 * Math.PI;\n+        double min = 0.0, max = 2 * FastMath.PI;\n         x = new double[n];\n         y = new double[n];\n         for (int i = 0; i < n; i++) {\n         double derivativebound = 1.0;\n         UnivariateRealFunction p = interpolator.interpolate(x, y);\n \n-        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        z = FastMath.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n \n-        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n     }\n \n             x[i] = min + i * (max - min) / n;\n             y[i] = f.value(x[i]);\n         }\n-        double derivativebound = Math.E;\n+        double derivativebound = FastMath.E;\n         UnivariateRealFunction p = interpolator.interpolate(x, y);\n \n         z = 0.0; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n \n         z = 0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n \n         z = -0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        tolerance = FastMath.abs(derivativebound * partialerror(x, z));\n         assertEquals(expected, result, tolerance);\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n         BivariateRealFunction f = new BivariateRealFunction() {\n                 public double value(double x, double y) {\n                     return 2 * x - 3 * y + 5\n-                        + ((int) (Math.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);\n+                        + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);\n                 }\n             };\n \n         BivariateRealFunction f = new BivariateRealFunction() {\n                 public double value(double x, double y) {\n                     return 2 * x * x - 3 * y * y + 4 * x * y - 5\n-                        + ((int) (Math.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);\n+                        + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1);\n                 }\n             };\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n import org.apache.commons.math.exception.NonMonotonousSequenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n         double x[] =\n             {\n                 0.0,\n-                Math.PI / 6d,\n-                Math.PI / 2d,\n-                5d * Math.PI / 6d,\n-                Math.PI,\n-                7d * Math.PI / 6d,\n-                3d * Math.PI / 2d,\n-                11d * Math.PI / 6d,\n-                2.d * Math.PI };\n+                FastMath.PI / 6d,\n+                FastMath.PI / 2d,\n+                5d * FastMath.PI / 6d,\n+                FastMath.PI,\n+                7d * FastMath.PI / 6d,\n+                3d * FastMath.PI / 2d,\n+                11d * FastMath.PI / 6d,\n+                2.d * FastMath.PI };\n         double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };\n         UnivariateRealInterpolator i = new SplineInterpolator();\n         UnivariateRealFunction f = i.interpolate(x, y);\n         TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);\n \n         //Check interpolation\n-        Assert.assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);\n-        Assert.assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);\n+        Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(FastMath.PI/4d),interpolationTolerance);\n+        Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(3d*FastMath.PI/4d),interpolationTolerance);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n         // Function values\n         TrivariateRealFunction f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return a * Math.cos(omega * z - kx * x - ky * y);\n+                    return a * FastMath.cos(omega * z - kx * x - ky * y);\n                 }\n             };\n         \n         double[][][] dFdX = new double[xval.length][yval.length][zval.length];\n         TrivariateRealFunction dFdX_f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return a * Math.sin(omega * z - kx * x - ky * y) * kx;\n+                    return a * FastMath.sin(omega * z - kx * x - ky * y) * kx;\n                 }\n             };\n         for (int i = 0; i < xval.length; i++) {\n         double[][][] dFdY = new double[xval.length][yval.length][zval.length];\n         TrivariateRealFunction dFdY_f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return a * Math.sin(omega * z - kx * x - ky * y) * ky;\n+                    return a * FastMath.sin(omega * z - kx * x - ky * y) * ky;\n                 }\n             };\n         for (int i = 0; i < xval.length; i++) {\n         double[][][] dFdZ = new double[xval.length][yval.length][zval.length];\n         TrivariateRealFunction dFdZ_f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return -a * Math.sin(omega * z - kx * x - ky * y) * omega;\n+                    return -a * FastMath.sin(omega * z - kx * x - ky * y) * omega;\n                 }\n             };\n         for (int i = 0; i < xval.length; i++) {\n         double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length];\n         TrivariateRealFunction d2FdXdY_f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return -a * Math.cos(omega * z - kx * x - ky * y) * kx * ky;\n+                    return -a * FastMath.cos(omega * z - kx * x - ky * y) * kx * ky;\n                 }\n             };\n         for (int i = 0; i < xval.length; i++) {\n         double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length];\n         TrivariateRealFunction d2FdXdZ_f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return a * Math.cos(omega * z - kx * x - ky * y) * kx * omega;\n+                    return a * FastMath.cos(omega * z - kx * x - ky * y) * kx * omega;\n                 }\n             };\n         for (int i = 0; i < xval.length; i++) {\n         double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length];\n         TrivariateRealFunction d2FdYdZ_f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return a * Math.cos(omega * z - kx * x - ky * y) * ky * omega;\n+                    return a * FastMath.cos(omega * z - kx * x - ky * y) * ky * omega;\n                 }\n             };\n         for (int i = 0; i < xval.length; i++) {\n         double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length];\n         TrivariateRealFunction d3FdXdYdZ_f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return a * Math.sin(omega * z - kx * x - ky * y) * kx * ky * omega;\n+                    return a * FastMath.sin(omega * z - kx * x - ky * y) * kx * ky * omega;\n                 }\n             };\n         for (int i = 0; i < xval.length; i++) {\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.TrivariateRealFunction;\n import org.junit.Assert;\n import org.junit.Test;\n         // Function values\n         TrivariateRealFunction f = new TrivariateRealFunction() {\n                 public double value(double x, double y, double z) {\n-                    return a * Math.cos(omega * z - kx * x - ky * y);\n+                    return a * FastMath.cos(omega * z - kx * x - ky * y);\n                 }\n             };\n         \n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n // commons-math\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n // junit\n import junit.framework.TestCase;\n \n         assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );\n \n         // compare g' = h\n-        assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance );\n-        assertEquals( g.derivative().value(Math.E),  h.value(Math.E),  tolerance );\n+        assertEquals( g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance );\n+        assertEquals( g.derivative().value(FastMath.E),  h.value(FastMath.E),  tolerance );\n \n     }\n \n         assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );\n \n         // compare g' = h\n-        assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance );\n-        assertEquals( g.derivative().value(Math.E),  h.value(Math.E),  tolerance );\n+        assertEquals( g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance );\n+        assertEquals( g.derivative().value(FastMath.E),  h.value(FastMath.E),  tolerance );\n     }\n \n     public void checkPolynomial(PolynomialFunction p, String reference) {\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n  */\n package org.apache.commons.math.analysis.polynomials;\n \n+import org.apache.commons.math.util.FastMath;\n+\n import junit.framework.TestCase;\n \n /**\n         for (int k = 0; k < 12; ++k) {\n             PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k);\n             for (double x = -1.0; x <= 1.0; x += 0.02) {\n-                assertTrue(k + \" \" + Tk.value(x), Math.abs(Tk.value(x)) < (1.0 + 1.0e-12));\n+                assertTrue(k + \" \" + Tk.value(x), FastMath.abs(Tk.value(x)) < (1.0 + 1.0e-12));\n             }\n         }\n     }\n         for (int i = 0; i < l40.length; ++i) {\n             if (i % 2 == 0) {\n                 double ci = numerators[i / 2] / denominator;\n-                assertEquals(ci, l40[i], Math.abs(ci) * 1.0e-15);\n+                assertEquals(ci, l40[i], FastMath.abs(ci) * 1.0e-15);\n             } else {\n                 assertEquals(0.0, l40[i], 0.0);\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n \n         UnivariateRealSolver solver = new BisectionSolver(f);\n         result = solver.solve(3, 4);\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(1, 4);\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n     }\n \n     public void testSinZero() throws MathException {\n \n         UnivariateRealSolver solver = new BisectionSolver();\n         result = solver.solve(f, 3, 4);\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 1, 4);\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n     }\n \n    public void testQuinticZero() throws MathException {\n     public void testMath369() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new BisectionSolver();\n-        assertEquals(Math.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n+        assertEquals(FastMath.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Testcase for UnivariateRealSolver.\n         result = solver.solve(3, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 4 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 5);\n         // Larger and somewhat less benign interval. The function is grows first.\n         result = solver.solve(1, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 5 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 6);\n         solver = new SecantSolver(f);\n         result = solver.solve(3, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 4 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 5);\n         result = solver.solve(1, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 5 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 6);\n         assertEquals(result, solver.getResult(), 0);\n         result = solver.solve(f, 3, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 4 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 5);\n         // Larger and somewhat less benign interval. The function is grows first.\n         result = solver.solve(f, 1, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 5 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 6);\n         solver = new SecantSolver();\n         result = solver.solve(f, 3, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 4 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 5);\n         result = solver.solve(f, 1, 4);\n         //System.out.println(\n         //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n         // 5 iterations on i586 JDK 1.4.1.\n         assertTrue(solver.getIterationCount() <= 6);\n         assertEquals(result, solver.getResult(), 0);\n         UnivariateRealSolver solver = new BrentSolver();\n \n         // endpoint is root\n-        double result = solver.solve(f, Math.PI, 4);\n-        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(f, 3, Math.PI);\n-        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(f, Math.PI, 4, 3.5);\n-        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n-\n-        result = solver.solve(f, 3, Math.PI, 3.07);\n-        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n+        double result = solver.solve(f, FastMath.PI, 4);\n+        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 3, FastMath.PI);\n+        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, FastMath.PI, 4, 3.5);\n+        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 3, FastMath.PI, 3.07);\n+        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.util.FastMath;\n+\n import junit.framework.TestCase;\n \n /**\n         UnivariateRealSolver solver = new LaguerreSolver(f);\n \n         min = 0.0; max = 1.0; expected = 0.25;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         UnivariateRealSolver solver = new LaguerreSolver();\n \n         min = 0.0; max = 1.0; expected = 0.25;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         UnivariateRealSolver solver = new LaguerreSolver();\n \n         min = 0.0; max = 2.0; expected = 0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -4.0; max = -1.0; expected = -3.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         UnivariateRealSolver solver = new LaguerreSolver();\n \n         min = -2.0; max = 2.0; expected = -1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -5.0; max = -2.5; expected = -3.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 3.0; max = 6.0; expected = 4.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         result = solver.solveAll(coefficients, initial);\n \n         expected = new Complex(0.0, -2.0);\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n         TestUtils.assertContains(result, expected, tolerance);\n \n         expected = new Complex(0.0, 2.0);\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n         TestUtils.assertContains(result, expected, tolerance);\n \n-        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        expected = new Complex(0.5, 0.5 * FastMath.sqrt(3.0));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n         TestUtils.assertContains(result, expected, tolerance);\n \n         expected = new Complex(-1.0, 0.0);\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n         TestUtils.assertContains(result, expected, tolerance);\n \n-        expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        expected = new Complex(0.5, -0.5 * FastMath.sqrt(3.0));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n         TestUtils.assertContains(result, expected, tolerance);\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n         UnivariateRealSolver solver = new MullerSolver(f);\n         double min, max, expected, result, tolerance;\n \n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        min = 3.0; max = 4.0; expected = FastMath.PI;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         UnivariateRealSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        min = 3.0; max = 4.0; expected = FastMath.PI;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         MullerSolver solver = new MullerSolver();\n         double min, max, expected, result, tolerance;\n \n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        min = 3.0; max = 4.0; expected = FastMath.PI;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve2(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.util.FastMath;\n \n \n import junit.framework.TestCase;\n \n         UnivariateRealSolver solver = new NewtonSolver(f);\n         result = solver.solve(3, 4);\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(1, 4);\n-        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         assertEquals(result, solver.getResult(), 0);\n         assertTrue(solver.getIterationCount() > 0);\n \n        UnivariateRealSolver solver = new NewtonSolver();\n        result = solver.solve(f, 3, 4);\n-       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+       assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n        result = solver.solve(f, 1, 4);\n-       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+       assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n        assertEquals(result, solver.getResult(), 0);\n        assertTrue(solver.getIterationCount() > 0);\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n         UnivariateRealSolver solver = new RiddersSolver(f);\n         double min, max, expected, result, tolerance;\n \n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        min = 3.0; max = 4.0; expected = FastMath.PI;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         UnivariateRealSolver solver = new RiddersSolver();\n         double min, max, expected, result, tolerance;\n \n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        min = 3.0; max = 4.0; expected = FastMath.PI;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n         assertEquals(expected, result, tolerance);\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Revision$ $Date$\n \n     public void testSolveSin() throws MathException {\n         double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);\n-        assertEquals(Math.PI, x, 1.0e-4);\n+        assertEquals(FastMath.PI, x, 1.0e-4);\n     }\n \n     public void testSolveAccuracyNull()  throws MathException {\n         double accuracy = 1.0e-6;\n         double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n                 4.0, accuracy);\n-        assertEquals(Math.PI, x, accuracy);\n+        assertEquals(FastMath.PI, x, accuracy);\n     }\n \n     public void testSolveNoRoot() throws MathException {\n--- a/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n import java.util.Locale;\n \n import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n \n     public void testFormatNumber() {\n         CompositeFormat cf = ComplexFormat.getInstance(getLocale());\n-        Double pi = Double.valueOf(Math.PI);\n+        Double pi = Double.valueOf(FastMath.PI);\n         String text = cf.format(pi);\n         assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n     }\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n package org.apache.commons.math.complex;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n import java.util.List;\n \n     private double inf = Double.POSITIVE_INFINITY;\n     private double neginf = Double.NEGATIVE_INFINITY;\n     private double nan = Double.NaN;\n-    private double pi = Math.PI;\n+    private double pi = FastMath.PI;\n     private Complex oneInf = new Complex(1, inf);\n     private Complex oneNegInf = new Complex(1, neginf);\n     private Complex infOne = new Complex(inf, 1);\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(0.936812, -2.30551);\n         TestUtils.assertEquals(expected, z.acos(), 1.0e-5);\n-        TestUtils.assertEquals(new Complex(Math.acos(0), 0),\n+        TestUtils.assertEquals(new Complex(FastMath.acos(0), 0),\n                 Complex.ZERO.acos(), 1.0e-12);\n     }\n \n             for (int j =0; j < 11; j++) {\n                 theta += pi /12;\n                 Complex z = ComplexUtils.polar2Complex(r, theta);\n-                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);\n+                Complex sqrtz = ComplexUtils.polar2Complex(FastMath.sqrt(r), theta / 2);\n                 TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12);\n             }\n         }\n         assertEquals(0.0, z.getArgument(), 1.0e-12);\n \n         z = new Complex(1, 1);\n-        assertEquals(Math.PI/4, z.getArgument(), 1.0e-12);\n+        assertEquals(FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n         z = new Complex(0, 1);\n-        assertEquals(Math.PI/2, z.getArgument(), 1.0e-12);\n+        assertEquals(FastMath.PI/2, z.getArgument(), 1.0e-12);\n \n         z = new Complex(-1, 1);\n-        assertEquals(3 * Math.PI/4, z.getArgument(), 1.0e-12);\n+        assertEquals(3 * FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n         z = new Complex(-1, 0);\n-        assertEquals(Math.PI, z.getArgument(), 1.0e-12);\n+        assertEquals(FastMath.PI, z.getArgument(), 1.0e-12);\n \n         z = new Complex(-1, -1);\n-        assertEquals(-3 * Math.PI/4, z.getArgument(), 1.0e-12);\n+        assertEquals(-3 * FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n         z = new Complex(0, -1);\n-        assertEquals(-Math.PI/2, z.getArgument(), 1.0e-12);\n+        assertEquals(-FastMath.PI/2, z.getArgument(), 1.0e-12);\n \n         z = new Complex(1, -1);\n-        assertEquals(-Math.PI/4, z.getArgument(), 1.0e-12);\n+        assertEquals(-FastMath.PI/4, z.getArgument(), 1.0e-12);\n \n     }\n \n      * Verify atan2-style handling of infinite parts\n      */\n     public void testGetArgumentInf() {\n-        assertEquals(Math.PI/4, infInf.getArgument(), 1.0e-12);\n-        assertEquals(Math.PI/2, oneInf.getArgument(), 1.0e-12);\n+        assertEquals(FastMath.PI/4, infInf.getArgument(), 1.0e-12);\n+        assertEquals(FastMath.PI/2, oneInf.getArgument(), 1.0e-12);\n         assertEquals(0.0, infOne.getArgument(), 1.0e-12);\n-        assertEquals(Math.PI/2, zeroInf.getArgument(), 1.0e-12);\n+        assertEquals(FastMath.PI/2, zeroInf.getArgument(), 1.0e-12);\n         assertEquals(0.0, infZero.getArgument(), 1.0e-12);\n-        assertEquals(Math.PI, negInfOne.getArgument(), 1.0e-12);\n-        assertEquals(-3.0*Math.PI/4, negInfNegInf.getArgument(), 1.0e-12);\n-        assertEquals(-Math.PI/2, oneNegInf.getArgument(), 1.0e-12);\n+        assertEquals(FastMath.PI, negInfOne.getArgument(), 1.0e-12);\n+        assertEquals(-3.0*FastMath.PI/4, negInfNegInf.getArgument(), 1.0e-12);\n+        assertEquals(-FastMath.PI/2, oneNegInf.getArgument(), 1.0e-12);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n package org.apache.commons.math.complex;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n     private double inf = Double.POSITIVE_INFINITY;\n     private double negInf = Double.NEGATIVE_INFINITY;\n     private double nan = Double.NaN;\n-    private double pi = Math.PI;\n+    private double pi = FastMath.PI;\n \n     private Complex negInfInf = new Complex(negInf, inf);\n     private Complex infNegInf = new Complex(inf, negInf);\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n  */\n \n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for CauchyDistribution.\n \n     public void testMedian() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        double expected = Math.random();\n+        double expected = FastMath.random();\n         distribution.setMedian(expected);\n         assertEquals(expected, distribution.getMedian(), 0.0);\n     }\n \n     public void testScale() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        double expected = Math.random();\n+        double expected = FastMath.random();\n         distribution.setScale(expected);\n         assertEquals(expected, distribution.getScale(), 0.0);\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Abstract base class for {@link ContinuousDistribution} tests.\n                  (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);\n \n             // check that P(a < X < b) = P(X < b) - P(X < a)\n-            double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n-            double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n+            double upper = FastMath.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n+            double lower = FastMath.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n             double diff = distribution.cumulativeProbability(upper) -\n                 distribution.cumulativeProbability(lower);\n             double direct = distribution.cumulativeProbability(lower, upper);\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for ExponentialDistribution.\n         assertEquals(0.0, d1.density(-1e-9));\n         assertEquals(1.0, d1.density(0.0));\n         assertEquals(0.0, d1.density(1000.0));\n-        assertEquals(Math.exp(-1), d1.density(1.0));\n-        assertEquals(Math.exp(-2), d1.density(2.0));\n+        assertEquals(FastMath.exp(-1), d1.density(1.0));\n+        assertEquals(FastMath.exp(-2), d1.density(2.0));\n \n         ExponentialDistribution d2 = new ExponentialDistributionImpl(3);\n         assertEquals(1/3.0, d2.density(0.0));\n--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n                            cumulativeTestPoints[i],\n                            cumulativeTestPoints[i + 1]),\n                    distribution.cumulativeProbability(arg, arg2), tolerance);\n-                arg = arg - Math.random();\n-                arg2 = arg2 + Math.random();\n+                arg = arg - FastMath.random();\n+                arg2 = arg2 + FastMath.random();\n                 assertEquals(\"Inconsistent probability for discrete range \" +\n                         \"[ \" + arg + \",\" + arg2 + \" ]\",\n                    distribution.cumulativeProbability(\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for NormalDistribution.\n     }\n \n     public void testSetMean() throws Exception {\n-        double mu = Math.random();\n+        double mu = FastMath.random();\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n         distribution.setMean(mu);\n         verifyQuantiles();\n     }\n \n     public void testSetStandardDeviation() throws Exception {\n-        double sigma = 0.1d + Math.random();\n+        double sigma = 0.1d + FastMath.random();\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n         distribution.setStandardDeviation(sigma);\n         assertEquals(sigma, distribution.getStandardDeviation(), 0);\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * <code>PoissonDistributionTest</code>\n             double x = mean * 2.0;\n             double dx = x / 10.0;\n             double p = Double.NaN;\n-            double sigma = Math.sqrt(mean);\n+            double sigma = FastMath.sqrt(mean);\n             while (x >= 0) {\n                 try {\n                     p = dist.cumulativeProbability(x);\n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n  */\n \n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for WeibullDistribution.\n \n     public void testAlpha() {\n         WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        double expected = Math.random();\n+        double expected = FastMath.random();\n         distribution.setShape(expected);\n         assertEquals(expected, distribution.getShape(), 0.0);\n     }\n \n     public void testBeta() {\n         WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        double expected = Math.random();\n+        double expected = FastMath.random();\n         distribution.setScale(expected);\n         assertEquals(expected, distribution.getScale(), 0.0);\n     }\n--- a/src/test/java/org/apache/commons/math/estimation/EstimatedParameterTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/EstimatedParameterTest.java\n package org.apache.commons.math.estimation;\n \n import org.apache.commons.math.estimation.EstimatedParameter;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n   }\n \n   private void checkValue(double value, double expected) {\n-    assertTrue(Math.abs(value - expected) < 1.0e-10);\n+    assertTrue(FastMath.abs(value - expected) < 1.0e-10);\n   }\n \n }\n--- a/src/test/java/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n \n import java.util.ArrayList;\n import java.util.HashSet;\n+\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n       GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-10, 1.0e-10);\n       estimator.estimate(circle);\n       double rms = estimator.getRMS(circle);\n-      assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);\n+      assertEquals(1.768262623567235,  FastMath.sqrt(circle.getM()) * rms,  1.0e-10);\n       assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);\n       assertEquals(96.07590211815305, circle.getX(),      1.0e-10);\n       assertEquals(48.13516790438953, circle.getY(),      1.0e-10);\n       public double getCenterDistance() {\n         double dx = px - circle.cx.getEstimate();\n         double dy = py - circle.cy.getEstimate();\n-        return Math.sqrt(dx * dx + dy * dy);\n+        return FastMath.sqrt(dx * dx + dy * dy);\n       }\n \n       public double getPartialDiX() {\n--- a/src/test/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n \n import java.util.ArrayList;\n import java.util.HashSet;\n+\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n     double initialCost = estimator.getRMS(problem);\n     estimator.estimate(problem);\n     assertTrue(estimator.getRMS(problem) < initialCost);\n-    assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6);\n+    assertTrue(FastMath.sqrt(m.length) * estimator.getRMS(problem) > 0.6);\n     try {\n         estimator.getCovariances(problem);\n         fail(\"an exception should have been thrown\");\n       assertTrue(estimator.getCostEvaluations() < 10);\n       assertTrue(estimator.getJacobianEvaluations() < 10);\n       double rms = estimator.getRMS(circle);\n-      assertEquals(1.768262623567235,  Math.sqrt(circle.getM()) * rms,  1.0e-10);\n+      assertEquals(1.768262623567235,  FastMath.sqrt(circle.getM()) * rms,  1.0e-10);\n       assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10);\n       assertEquals(96.07590211815305, circle.getX(),      1.0e-10);\n       assertEquals(48.13516790438953, circle.getY(),      1.0e-10);\n       double cx = circle.getX();\n       double cy = circle.getY();\n       double  r = circle.getRadius();\n-      for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n-          circle.addPoint(cx + r * Math.cos(d), cy + r * Math.sin(d));\n+      for (double d= 0; d < 2 * FastMath.PI; d += 0.01) {\n+          circle.addPoint(cx + r * FastMath.cos(d), cy + r * FastMath.sin(d));\n       }\n       estimator = new LevenbergMarquardtEstimator();\n       estimator.estimate(circle);\n       public double getCenterDistance() {\n         double dx = px - circle.cx.getEstimate();\n         double dy = py - circle.cy.getEstimate();\n-        return Math.sqrt(dx * dx + dy * dy);\n+        return FastMath.sqrt(dx * dx + dy * dy);\n       }\n \n       public double getPartialDiX() {\n--- a/src/test/java/org/apache/commons/math/estimation/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/MinpackTest.java\n import org.apache.commons.math.estimation.EstimationProblem;\n import org.apache.commons.math.estimation.LevenbergMarquardtEstimator;\n import org.apache.commons.math.estimation.WeightedMeasurement;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n \n   public void testMinpackRosenbrok() {\n     minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n-                                       Math.sqrt(24.2)), false);\n+                                       FastMath.sqrt(24.2)), false);\n     minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },\n-                                       Math.sqrt(1795769.0)), false);\n+                                       FastMath.sqrt(1795769.0)), false);\n     minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },\n-                                       11.0 * Math.sqrt(169000121.0)), false);\n+                                       11.0 * FastMath.sqrt(169000121.0)), false);\n   }\n \n   public void testMinpackHelicalValley() {\n   private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n     LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n     estimator.setMaxCostEval(100 * (function.getN() + 1));\n-    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n-    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+    estimator.setCostRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n+    estimator.setParRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n     estimator.setOrthoTolerance(2.22044604926e-16);\n     assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));\n     try {\n \n     public boolean checkTheoreticalStartCost(double rms) {\n       double threshold = costAccuracy * (1.0 + theoreticalStartCost);\n-      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;\n+      return FastMath.abs(FastMath.sqrt(m) * rms - theoreticalStartCost) <= threshold;\n     }\n \n     public boolean checkTheoreticalMinCost(double rms) {\n       double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n-     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n+     return FastMath.abs(FastMath.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n     }\n \n     public boolean checkTheoreticalMinParams() {\n         for (int i = 0; i < theoreticalMinParams.length; ++i) {\n           double mi = theoreticalMinParams[i];\n           double vi = parameters[i].getEstimate();\n-          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n+          if (FastMath.abs(mi - vi) > (paramsAccuracy * (1.0 + FastMath.abs(mi)))) {\n             return false;\n           }\n         }\n \n     public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n       super(m, buildArray(n, x0),\n-            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),\n-            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n+            FastMath.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),\n+            FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n             null);\n     }\n \n       double x2 = parameters[1].getEstimate();\n       double tmpSquare = x1 * x1 + x2 * x2;\n       double tmp1 = twoPi * tmpSquare;\n-      double tmp2 = Math.sqrt(tmpSquare);\n+      double tmp2 = FastMath.sqrt(tmpSquare);\n       return new double[][] {\n         {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },\n         { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },\n       if (x1 == 0) {\n         tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n       } else {\n-        tmp1 = Math.atan(x2 / x1) / twoPi;\n+        tmp1 = FastMath.atan(x2 / x1) / twoPi;\n         if (x1 < 0) {\n           tmp1 += 0.5;\n         }\n       }\n-      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);\n+      double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2);\n       return new double[] {\n         10.0 * (x3 - 10 * tmp1),\n         10.0 * (tmp2 - 1),\n       };\n     }\n \n-    private static final double twoPi = 2.0 * Math.PI;\n+    private static final double twoPi = 2.0 * FastMath.PI;\n \n   }\n \n       };\n     }\n \n-    private static final double sqrt5  = Math.sqrt( 5.0);\n-    private static final double sqrt10 = Math.sqrt(10.0);\n+    private static final double sqrt5  = FastMath.sqrt( 5.0);\n+    private static final double sqrt10 = FastMath.sqrt(10.0);\n \n   }\n \n       for (int i = 0; i < m; ++i) {\n         double temp = 5.0 * (i + 1) + 45.0 + x3;\n         double tmp1 = x2 / temp;\n-        double tmp2 = Math.exp(tmp1);\n+        double tmp2 = FastMath.exp(tmp1);\n         double tmp3 = x1 * tmp2 / temp;\n         jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };\n       }\n       double x3 = parameters[2].getEstimate();\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n-        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n+        f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n       }\n      return f;\n     }\n       for (int i = 0; i < m; ++i) {\n         double tmp = (i + 1) / 10.0;\n         jacobian[i] = new double[] {\n-          -tmp * Math.exp(-tmp * x1),\n-           tmp * Math.exp(-tmp * x2),\n-          Math.exp(-i - 1) - Math.exp(-tmp)\n+          -tmp * FastMath.exp(-tmp * x1),\n+           tmp * FastMath.exp(-tmp * x2),\n+          FastMath.exp(-i - 1) - FastMath.exp(-tmp)\n         };\n       }\n       return jacobian;\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double tmp = (i + 1) / 10.0;\n-        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)\n-             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;\n+        f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2)\n+             + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3;\n       }\n       return f;\n     }\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double t = i + 1;\n-        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };\n+        jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) };\n       }\n       return jacobian;\n     }\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = i + 1;\n-        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);\n+        f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2);\n       }\n       return f;\n     }\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = (i + 1) / 5.0;\n-        double ti   = Math.sin(temp);\n-        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n-        double tmp2 = x3 + ti   * x4 - Math.cos(temp);\n+        double ti   = FastMath.sin(temp);\n+        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);\n+        double tmp2 = x3 + ti   * x4 - FastMath.cos(temp);\n         jacobian[i] = new double[] {\n           2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2\n         };\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = (i + 1) / 5.0;\n-        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n-        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);\n+        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);\n+        double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp);\n         f[i] = tmp1 * tmp1 + tmp2 * tmp2;\n       }\n       return f;\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = 10.0 * i;\n-        double tmp1 = Math.exp(-temp * x4);\n-        double tmp2 = Math.exp(-temp * x5);\n+        double tmp1 = FastMath.exp(-temp * x4);\n+        double tmp2 = FastMath.exp(-temp * x5);\n         jacobian[i] = new double[] {\n           -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2\n         };\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = 10.0 * i;\n-        double tmp1 = Math.exp(-temp * x4);\n-        double tmp2 = Math.exp(-temp * x5);\n+        double tmp1 = FastMath.exp(-temp * x4);\n+        double tmp2 = FastMath.exp(-temp * x5);\n         f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);\n       }\n       return f;\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = i / 10.0;\n-        double tmp1 = Math.exp(-x05 * temp);\n-        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n-        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n-        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        double tmp1 = FastMath.exp(-x05 * temp);\n+        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));\n         jacobian[i] = new double[] {\n           -tmp1,\n           -tmp2,\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = i / 10.0;\n-        double tmp1 = Math.exp(-x05 * temp);\n-        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n-        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n-        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        double tmp1 = FastMath.exp(-x05 * temp);\n+        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));\n         f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);\n       }\n       return f;\n--- a/src/test/java/org/apache/commons/math/estimation/WeightedMeasurementTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/WeightedMeasurementTest.java\n \n import org.apache.commons.math.estimation.EstimatedParameter;\n import org.apache.commons.math.estimation.WeightedMeasurement;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n   }\n \n   private void checkValue(double value, double expected) {\n-   assertTrue(Math.abs(value - expected) < 1.0e-10);\n+   assertTrue(FastMath.abs(value - expected) < 1.0e-10);\n   }\n \n   private double theoretical() {\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n import java.text.ParseException;\n import java.util.Locale;\n \n+import org.apache.commons.math.util.FastMath;\n+\n import junit.framework.TestCase;\n \n public class BigFractionFormatTest extends TestCase {\n             improperFormat.parse(\"167213075789791382630275400487886041651764456874403\" +\n                                  \" / \" +\n                                  \"53225575123090058458126718248444563466137046489291\");\n-        assertEquals(Math.PI, f1.doubleValue(), 0.0);\n+        assertEquals(FastMath.PI, f1.doubleValue(), 0.0);\n         BigFraction f2 =\n             properFormat.parse(\"3 \" +\n                                \"7536350420521207255895245742552351253353317406530\" +\n                                \" / \" +\n                                \"53225575123090058458126718248444563466137046489291\");\n-        assertEquals(Math.PI, f2.doubleValue(), 0.0);\n+        assertEquals(FastMath.PI, f2.doubleValue(), 0.0);\n         assertEquals(f1, f2);\n         BigDecimal pi =\n             new BigDecimal(\"3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068\");\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionTest.java\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n         try {\n             // the golden ratio is notoriously a difficult number for continuous\n             // fraction\n-            new BigFraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25);\n+            new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);\n             fail(\"an exception should have been thrown\");\n         } catch (ConvergenceException ce) {\n             // expected behavior\n     public void testSerial() throws FractionConversionException {\n         BigFraction[] fractions = {\n             new BigFraction(3, 4), BigFraction.ONE, BigFraction.ZERO,\n-            new BigFraction(17), new BigFraction(Math.PI, 1000),\n+            new BigFraction(17), new BigFraction(FastMath.PI, 1000),\n             new BigFraction(-5, 2)\n         };\n         for (BigFraction fraction : fractions) {\n--- a/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n import java.text.ParseException;\n import java.util.Locale;\n \n+import org.apache.commons.math.util.FastMath;\n+\n import junit.framework.TestCase;\n \n public class FractionFormatTest extends TestCase {\n     }\n \n     public void testDoubleFormat() {\n-        assertEquals(\"355 / 113\", improperFormat.format(Math.PI));\n+        assertEquals(\"355 / 113\", improperFormat.format(FastMath.PI));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n     public void testGoldenRatio() {\n         try {\n             // the golden ratio is notoriously a difficult number for continuous fraction\n-            new Fraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25);\n+            new Fraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25);\n             fail(\"an exception should have been thrown\");\n         } catch (ConvergenceException ce) {\n             // expected behavior\n     public void testSerial() throws FractionConversionException {\n         Fraction[] fractions = {\n             new Fraction(3, 4), Fraction.ONE, Fraction.ZERO,\n-            new Fraction(17), new Fraction(Math.PI, 1000),\n+            new Fraction(17), new Fraction(FastMath.PI, 1000),\n             new Fraction(-5, 2)\n         };\n         for (Fraction fraction : fractions) {\n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n /**\n                 int value = decoded.get(i);\n                 if (value != i) {\n                     // bad position found\n-                    res += Math.abs(value - i);\n+                    res += FastMath.abs(value - i);\n                 }\n             }\n             // the most fitted chromosome is the one with minimal error\n--- a/src/test/java/org/apache/commons/math/geometry/RotationTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/RotationTest.java\n import org.apache.commons.math.geometry.Rotation;\n import org.apache.commons.math.geometry.RotationOrder;\n import org.apache.commons.math.geometry.Vector3D;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n import junit.framework.*;\n \n   public void testAxisAngle() {\n \n-    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);\n+    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3);\n     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);\n     checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);\n     checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);\n-    double s = 1 / Math.sqrt(3);\n+    double s = 1 / FastMath.sqrt(3);\n     checkVector(r.getAxis(), new Vector3D(s, s, s));\n-    checkAngle(r.getAngle(), 2 * Math.PI / 3);\n-\n-    try {\n-      new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3);\n+    checkAngle(r.getAngle(), 2 * FastMath.PI / 3);\n+\n+    try {\n+      new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3);\n       fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException e) {\n     } catch (Exception e) {\n       fail(\"unexpected exception\");\n     }\n \n-    r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI);\n+    r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI);\n     checkVector(r.getAxis(), new Vector3D(0, 0, -1));\n-    checkAngle(r.getAngle(), 0.5 * Math.PI);\n-\n-    r = new Rotation(Vector3D.PLUS_J, Math.PI);\n+    checkAngle(r.getAngle(), 0.5 * FastMath.PI);\n+\n+    r = new Rotation(Vector3D.PLUS_J, FastMath.PI);\n     checkVector(r.getAxis(), Vector3D.PLUS_J);\n-    checkAngle(r.getAngle(), Math.PI);\n+    checkAngle(r.getAngle(), FastMath.PI);\n \n     checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);\n \n     Rotation r = new Rotation(u, v);\n     checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));\n \n-    checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);\n+    checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI);\n \n     try {\n         new Rotation(u, Vector3D.ZERO);\n     } else {\n       checkVector(axis, Vector3D.MINUS_K);\n     }\n-    checkAngle(r.getAngle(), Math.PI);\n-\n-    double sqrt = Math.sqrt(2) / 2;\n+    checkAngle(r.getAngle(), FastMath.PI);\n+\n+    double sqrt = FastMath.sqrt(2) / 2;\n     r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,\n                      new Vector3D(0.5, 0.5,  sqrt),\n                      new Vector3D(0.5, 0.5, -sqrt));\n     double d21 = m2[2][1] - m3[2][1];\n     double d22 = m2[2][2] - m3[2][2];\n \n-    assertTrue(Math.abs(d00) < 6.0e-6);\n-    assertTrue(Math.abs(d01) < 6.0e-6);\n-    assertTrue(Math.abs(d02) < 6.0e-6);\n-    assertTrue(Math.abs(d10) < 6.0e-6);\n-    assertTrue(Math.abs(d11) < 6.0e-6);\n-    assertTrue(Math.abs(d12) < 6.0e-6);\n-    assertTrue(Math.abs(d20) < 6.0e-6);\n-    assertTrue(Math.abs(d21) < 6.0e-6);\n-    assertTrue(Math.abs(d22) < 6.0e-6);\n-\n-    assertTrue(Math.abs(d00) > 4.0e-7);\n-    assertTrue(Math.abs(d01) > 4.0e-7);\n-    assertTrue(Math.abs(d02) > 4.0e-7);\n-    assertTrue(Math.abs(d10) > 4.0e-7);\n-    assertTrue(Math.abs(d11) > 4.0e-7);\n-    assertTrue(Math.abs(d12) > 4.0e-7);\n-    assertTrue(Math.abs(d20) > 4.0e-7);\n-    assertTrue(Math.abs(d21) > 4.0e-7);\n-    assertTrue(Math.abs(d22) > 4.0e-7);\n+    assertTrue(FastMath.abs(d00) < 6.0e-6);\n+    assertTrue(FastMath.abs(d01) < 6.0e-6);\n+    assertTrue(FastMath.abs(d02) < 6.0e-6);\n+    assertTrue(FastMath.abs(d10) < 6.0e-6);\n+    assertTrue(FastMath.abs(d11) < 6.0e-6);\n+    assertTrue(FastMath.abs(d12) < 6.0e-6);\n+    assertTrue(FastMath.abs(d20) < 6.0e-6);\n+    assertTrue(FastMath.abs(d21) < 6.0e-6);\n+    assertTrue(FastMath.abs(d22) < 6.0e-6);\n+\n+    assertTrue(FastMath.abs(d00) > 4.0e-7);\n+    assertTrue(FastMath.abs(d01) > 4.0e-7);\n+    assertTrue(FastMath.abs(d02) > 4.0e-7);\n+    assertTrue(FastMath.abs(d10) > 4.0e-7);\n+    assertTrue(FastMath.abs(d11) > 4.0e-7);\n+    assertTrue(FastMath.abs(d12) > 4.0e-7);\n+    assertTrue(FastMath.abs(d20) > 4.0e-7);\n+    assertTrue(FastMath.abs(d21) > 4.0e-7);\n+    assertTrue(FastMath.abs(d22) > 4.0e-7);\n \n     for (int i = 0; i < 3; ++i) {\n       for (int j = 0; j < 3; ++j) {\n                      + m3[i][1] * m3[j][1]\n                      + m3[i][2] * m3[j][2];\n         if (i == j) {\n-          assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10);\n+          assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);\n         } else {\n-          assertTrue(Math.abs(m3tm3) < 1.0e-10);\n+          assertTrue(FastMath.abs(m3tm3) < 1.0e-10);\n         }\n       }\n     }\n                       { 0.0, -1.0,  0.0 },\n                       { 0.0,  0.0, -1.0 } };\n     r = new Rotation(m4, 1.0e-7);\n-    checkAngle(r.getAngle(), Math.PI);\n+    checkAngle(r.getAngle(), FastMath.PI);\n \n     try {\n       double[][] m5 = { { 0.0, 0.0, 1.0 },\n       RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n     };\n \n-    double[] singularCardanAngle = { Math.PI / 2, -Math.PI / 2 };\n+    double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };\n     for (int i = 0; i < CardanOrders.length; ++i) {\n       for (int j = 0; j < singularCardanAngle.length; ++j) {\n         Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);\n             RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n           };\n \n-    double[] singularEulerAngle = { 0, Math.PI };\n+    double[] singularEulerAngle = { 0, FastMath.PI };\n     for (int i = 0; i < EulerOrders.length; ++i) {\n       for (int j = 0; j < singularEulerAngle.length; ++j) {\n         Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);\n     Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n       for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n-          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n-                                    Math.sin(lambda) * Math.cos(phi),\n-                                    Math.sin(phi));\n+          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(phi));\n           r.applyInverseTo(r.applyTo(u));\n           checkVector(u, r.applyInverseTo(r.applyTo(u)));\n           checkVector(u, r.applyTo(r.applyInverseTo(u)));\n     r = Rotation.IDENTITY;\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n       for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n-          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n-                                    Math.sin(lambda) * Math.cos(phi),\n-                                    Math.sin(phi));\n+          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(phi));\n           checkVector(u, r.applyInverseTo(r.applyTo(u)));\n           checkVector(u, r.applyTo(r.applyInverseTo(u)));\n       }\n     }\n \n-    r = new Rotation(Vector3D.PLUS_K, Math.PI);\n+    r = new Rotation(Vector3D.PLUS_K, FastMath.PI);\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n       for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n-          Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n-                                    Math.sin(lambda) * Math.cos(phi),\n-                                    Math.sin(phi));\n+          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(phi));\n           checkVector(u, r.applyInverseTo(r.applyTo(u)));\n           checkVector(u, r.applyTo(r.applyInverseTo(u)));\n       }\n--- a/src/test/java/org/apache/commons/math/geometry/Vector3DTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DTest.java\n package org.apache.commons.math.geometry;\n \n import org.apache.commons.math.geometry.Vector3D;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n   }\n \n   public void testConstructors() {\n-      double r = Math.sqrt(2) /2;\n-      checkVector(new Vector3D(2, new Vector3D(Math.PI / 3, -Math.PI / 4)),\n-                  r, r * Math.sqrt(3), -2 * r);\n+      double r = FastMath.sqrt(2) /2;\n+      checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)),\n+                  r, r * FastMath.sqrt(3), -2 * r);\n       checkVector(new Vector3D(2, Vector3D.PLUS_I,\n                               -3, Vector3D.MINUS_K),\n                   2, 0, 3);\n \n   public void testCoordinates() {\n     Vector3D v = new Vector3D(1, 2, 3);\n-    assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);\n-    assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);\n-    assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);\n+    assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12);\n+    assertTrue(FastMath.abs(v.getY() - 2) < 1.0e-12);\n+    assertTrue(FastMath.abs(v.getZ() - 3) < 1.0e-12);\n   }\n \n   public void testNorm1() {\n \n   public void testNorm() {\n       assertEquals(0.0, Vector3D.ZERO.getNorm());\n-      assertEquals(Math.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);\n+      assertEquals(FastMath.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);\n     }\n \n   public void testNormInf() {\n       Vector3D v1 = new Vector3D(1, -2, 3);\n       Vector3D v2 = new Vector3D(-4, 2, 0);\n       assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n-      assertEquals(Math.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);\n+      assertEquals(FastMath.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);\n       assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12);\n   }\n \n     Vector3D v1 = new Vector3D(2, 1, -4);\n     Vector3D v2 = new Vector3D(3, 1, -1);\n \n-    assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);\n+    assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);\n \n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n     checkVector(v3, 3, -10, -1);\n \n-    assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);\n-    assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);\n+    assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);\n+    assertTrue(FastMath.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);\n \n   }\n \n \n     assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);\n     assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);\n-    assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);\n+    assertEquals(FastMath.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);\n     assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);\n     assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);\n-    assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);\n+    assertEquals(FastMath.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);\n \n     Vector3D u = new Vector3D(-1, 1, -1);\n-    assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);\n-    assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10);\n+    assertEquals(3 * FastMath.PI /4, u.getAlpha(), 1.0e-10);\n+    assertEquals(-1.0 / FastMath.sqrt(3), FastMath.sin(u.getDelta()), 1.0e-10);\n \n   }\n \n \n     Vector3D  k = v1.normalize();\n     Vector3D  i = k.orthogonal();\n-    Vector3D v2 = k.scalarMultiply(Math.cos(1.2)).add(i.scalarMultiply(Math.sin(1.2)));\n-\n-    assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n+    Vector3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));\n+\n+    assertTrue(FastMath.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n import junit.framework.TestCase;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.linear.RealVector.Entry;\n+import org.apache.commons.math.util.FastMath;\n \n import java.util.Iterator;\n import java.util.Random;\n         @Override\n         public RealVector mapPowToSelf(double d) {\n             for(int i=0; i<values.length; i++) {\n-                values[i] = Math.pow(values[i], d);\n+                values[i] = FastMath.pow(values[i], d);\n             }\n             return this;\n         }\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link Array2DRowRealMatrix} class.\n     public void testFrobeniusNorm() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2);\n-        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n-        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData Frobenius norm\", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n \n      /** test m-n = m + -n */\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link ArrayRealVector} class.\n \n         v.setEntry(0, 0);\n         assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));\n-        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));\n         assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));\n \n         assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n--- a/src/test/java/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n import org.apache.commons.math.linear.BiDiagonalTransformer;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n                 { 2.0, 3.0, 4.0 },\n                 { 3.0, 5.0, 7.0 }\n             }));\n-       final double s3  = Math.sqrt(3.0);\n-       final double s14 = Math.sqrt(14.0);\n-       final double s1553 = Math.sqrt(1553.0);\n+       final double s3  = FastMath.sqrt(3.0);\n+       final double s14 = FastMath.sqrt(14.0);\n+       final double s1553 = FastMath.sqrt(1553.0);\n        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n            {  -1.0 / s14,  5.0 / (s3 * s14),  1.0 / s3 },\n            {  -2.0 / s14, -4.0 / (s3 * s14),  1.0 / s3 },\n     public void testMatricesValues() {\n        BiDiagonalTransformer transformer =\n             new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare));\n-       final double s17 = Math.sqrt(17.0);\n+       final double s17 = FastMath.sqrt(17.0);\n         RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n                 {  -8 / (5 * s17), 19 / (5 * s17) },\n                 { -19 / (5 * s17), -8 / (5 * s17) }\n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link BlockRealMatrix} class.\n     public void testFrobeniusNorm() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m2 = new BlockRealMatrix(testData2);\n-        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n-        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData Frobenius norm\", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n \n      /** test m-n = m + -n */\n--- a/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n public class EigenDecompositionImplTest extends TestCase {\n         });\n         EigenDecomposition ed = new EigenDecompositionImpl(indefinite, MathUtils.SAFE_MIN);\n         checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);\n-        double isqrt3 = 1/Math.sqrt(3.0);\n+        double isqrt3 = 1/FastMath.sqrt(3.0);\n         checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);\n-        double isqrt2 = 1/Math.sqrt(2.0);\n+        double isqrt2 = 1/FastMath.sqrt(2.0);\n         checkEigenVector((new double[] {0.0,-isqrt2,-isqrt2}), ed, 1E-12);\n-        double isqrt6 = 1/Math.sqrt(6.0);\n+        double isqrt6 = 1/FastMath.sqrt(6.0);\n         checkEigenVector((new double[] {2*isqrt6,-isqrt6,isqrt6}), ed, 1E-12);\n     }\n     /**\n        boolean found = false;\n        int i = 0;\n        while (!found && i < searchArray.length) {\n-           if (Math.abs(value - searchArray[i]) < tolerance) {\n+           if (FastMath.abs(value - searchArray[i]) < tolerance) {\n                found = true;\n            }\n            i++;\n             while (matching && j < searchMatrix.getRowDimension()) {\n                 double colEntry = searchMatrix.getEntry(j, i);\n                 // Use the first entry where both are non-zero as scalar\n-                if (Math.abs(multiplier - 1.0) <= Math.ulp(1.0) && Math.abs(colEntry) > 1E-14\n-                        && Math.abs(column[j]) > 1e-14) {\n+                if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14\n+                        && FastMath.abs(column[j]) > 1e-14) {\n                     multiplier = colEntry / column[j];\n                 }\n-                if (Math.abs(column[j] * multiplier - colEntry) > tolerance) {\n+                if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) {\n                     matching = false;\n                 }\n                 j++;\n                 for (final double dataIJ : dataI) {\n                     norm2 += dataIJ * dataIJ;\n                 }\n-                final double inv = 1.0 / Math.sqrt(norm2);\n+                final double inv = 1.0 / FastMath.sqrt(norm2);\n                 for (int j = 0; j < size; ++j) {\n                     dataI[j] *= inv;\n                 }\n     public static RealMatrix createDiagonalMatrix(final double[] diagonal,\n                                                   final int rows, final int columns) {\n         final double[][] dData = new double[rows][columns];\n-        for (int i = 0; i < Math.min(rows, columns); ++i) {\n+        for (int i = 0; i < FastMath.min(rows, columns); ++i) {\n             dData[i][i] = diagonal[i];\n         }\n         return MatrixUtils.createRealMatrix(dData);\n--- a/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link RealMatrixImpl} class.\n     public void testFrobeniusNorm() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n-        assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n-        assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData Frobenius norm\", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n+        assertEquals(\"testData2 Frobenius norm\", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n \n      /** test m-n = m + -n */\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link OpenMapRealVector} class.\n \n         v.setEntry(0, 0);\n         assertEquals(v, new OpenMapRealVector(new double[] { 0, 1, 2 }));\n-        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));\n         assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2, 3 }));\n \n     }\n--- a/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n package org.apache.commons.math.linear;\n \n import java.util.Arrays;\n+\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n                                 { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }\n                             },\n                             new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },\n-                            new double[] { -Math.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });\n+                            new double[] { -FastMath.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });\n     }\n \n     public void testMatricesValues3() {\n--- a/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n public class ContinuousOutputModelTest\n   extends TestCase {\n       FirstOrderIntegrator integ1 =\n           new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);\n       integ1.addStepHandler(cm1);\n-      integ1.integrate(problem, Math.PI, new double[] { -1.0, 0.0 },\n+      integ1.integrate(problem, FastMath.PI, new double[] { -1.0, 0.0 },\n                        0, new double[2]);\n \n       // integrate backward from 2&pi; to &pi;\n       FirstOrderIntegrator integ2 =\n           new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);\n       integ2.addStepHandler(cm2);\n-      integ2.integrate(problem, 2.0 * Math.PI, new double[] { 1.0, 0.0 },\n-                       Math.PI, new double[2]);\n+      integ2.integrate(problem, 2.0 * FastMath.PI, new double[] { 1.0, 0.0 },\n+                       FastMath.PI, new double[2]);\n \n       // merge the two half circles\n       ContinuousOutputModel cm = new ContinuousOutputModel();\n       cm.append(cm1);\n \n       // check circle\n-      assertEquals(2.0 * Math.PI, cm.getInitialTime(), 1.0e-12);\n+      assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12);\n       assertEquals(0, cm.getFinalTime(), 1.0e-12);\n       assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12);\n-      for (double t = 0; t < 2.0 * Math.PI; t += 0.1) {\n+      for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) {\n           cm.setInterpolatedTime(t);\n           double[] y = cm.getInterpolatedState();\n-          assertEquals(Math.cos(t), y[0], 1.0e-7);\n-          assertEquals(Math.sin(t), y[1], 1.0e-7);\n+          assertEquals(FastMath.cos(t), y[0], 1.0e-7);\n+          assertEquals(FastMath.sin(t), y[1], 1.0e-7);\n       }\n \n   }\n   }\n \n   public void checkValue(double value, double reference) {\n-    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+    assertTrue(FastMath.abs(value - reference) < 1.0e-10);\n   }\n \n   @Override\n--- a/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.SecondOrderDifferentialEquations;\n import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n     double previousError = Double.NaN;\n     for (int i = 0; i < 10; ++i) {\n \n-      double step  = Math.pow(2.0, -(i + 1));\n+      double step  = FastMath.pow(2.0, -(i + 1));\n       double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step)\n-                   - Math.sin(4.0);\n+                   - FastMath.sin(4.0);\n       if (i > 0) {\n-        assertTrue(Math.abs(error) < Math.abs(previousError));\n+        assertTrue(FastMath.abs(error) < FastMath.abs(previousError));\n       }\n       previousError = error;\n \n   public void testSmallStep()\n     throws DerivativeException, IntegratorException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4)\n-                   - Math.sin(4.0);\n-    assertTrue(Math.abs(error) < 1.0e-10);\n+                   - FastMath.sin(4.0);\n+    assertTrue(FastMath.abs(error) < 1.0e-10);\n   }\n \n   public void testBigStep()\n     throws DerivativeException, IntegratorException {\n     double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5)\n-                   - Math.sin(4.0);\n-    assertTrue(Math.abs(error) > 0.1);\n+                   - FastMath.sin(4.0);\n+    assertTrue(FastMath.abs(error) > 0.1);\n   }\n \n   private static class Equations\n                                             double step)\n   throws DerivativeException, IntegratorException {\n     double[] y0 = new double[2];\n-    y0[0] = Math.sin(omega * t0);\n-    y0[1] = omega * Math.cos(omega * t0);\n+    y0[0] = FastMath.sin(omega * t0);\n+    y0[1] = omega * FastMath.cos(omega * t0);\n     ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step);\n     double[] y = new double[2];\n     i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y);\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem1.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem1.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class is used in the junit tests for the ODE integrators.\n \n   @Override\n   public double[] computeTheoreticalState(double t) {\n-    double c = Math.exp (t0 - t);\n+    double c = FastMath.exp (t0 - t);\n     for (int i = 0; i < n; ++i) {\n       y[i] = c * y0[i];\n     }\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem2.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem2.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class is used in the junit tests for the ODE integrators.\n   @Override\n   public double[] computeTheoreticalState(double t) {\n     double t2 = t * t;\n-    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);\n+    double c = t2 + 2 * (FastMath.exp (-0.5 * t2) - 1);\n     for (int i = 0; i < n; ++i) {\n       y[i] = c;\n     }\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem3.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem3.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class is used in the junit tests for the ODE integrators.\n   public TestProblem3(double e) {\n     super();\n     this.e = e;\n-    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };\n+    double[] y0 = { 1 - e, 0, 0, FastMath.sqrt((1+e)/(1-e)) };\n     setInitialConditions(0.0, y0);\n     setFinalConditions(20.0);\n     double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };\n \n     // current radius\n     double r2 = y[0] * y[0] + y[1] * y[1];\n-    double invR3 = 1 / (r2 * Math.sqrt(r2));\n+    double invR3 = 1 / (r2 * FastMath.sqrt(r2));\n \n     // compute the derivatives\n     yDot[0] = y[2];\n     double E = t;\n     double d = 0;\n     double corr = 999.0;\n-    for (int i = 0; (i < 50) && (Math.abs(corr) > 1.0e-12); ++i) {\n-      double f2  = e * Math.sin(E);\n+    for (int i = 0; (i < 50) && (FastMath.abs(corr) > 1.0e-12); ++i) {\n+      double f2  = e * FastMath.sin(E);\n       double f0  = d - f2;\n-      double f1  = 1 - e * Math.cos(E);\n+      double f1  = 1 - e * FastMath.cos(E);\n       double f12 = f1 + f1;\n       corr  = f0 * f12 / (f1 * f12 - f0 * f2);\n       d -= corr;\n       E = t + d;\n     }\n \n-    double cosE = Math.cos(E);\n-    double sinE = Math.sin(E);\n+    double cosE = FastMath.cos(E);\n+    double sinE = FastMath.sin(E);\n \n     y[0] = cosE - e;\n-    y[1] = Math.sqrt(1 - e * e) * sinE;\n+    y[1] = FastMath.sqrt(1 - e * e) * sinE;\n     y[2] = -sinE / (1 - e * cosE);\n-    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);\n+    y[3] = FastMath.sqrt(1 - e * e) * cosE / (1 - e * cosE);\n \n     return y;\n   }\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n package org.apache.commons.math.ode;\n \n import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class is used in the junit tests for the ODE integrators.\n   public TestProblem4() {\n     super();\n     a = 1.2;\n-    double[] y0 = { Math.sin(a), Math.cos(a) };\n+    double[] y0 = { FastMath.sin(a), FastMath.cos(a) };\n     setInitialConditions(0.0, y0);\n     setFinalConditions(15);\n     double[] errorScale = { 1.0, 0.0 };\n \n   @Override\n   public double[] computeTheoreticalState(double t) {\n-    double sin = Math.sin(t + a);\n-    double cos = Math.cos(t + a);\n-    y[0] = Math.abs(sin);\n+    double sin = FastMath.sin(t + a);\n+    double cos = FastMath.cos(t + a);\n+    y[0] = FastMath.abs(sin);\n     y[1] = (sin >= 0) ? cos : -cos;\n     return y;\n   }\n--- a/src/test/java/org/apache/commons/math/ode/TestProblemHandler.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemHandler.java\n import org.apache.commons.math.ode.ODEIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class is used to handle steps for the test problems\n     throws DerivativeException {\n \n     double start = integrator.getCurrentStepStart();\n-    if (Math.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {\n+    if (FastMath.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {\n         // multistep integrators do not handle the first steps themselves\n         // so we have to make sure the integrator we look at has really started its work\n         if (!Double.isNaN(expectedStepStart)) {\n-            maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));\n+            maxTimeError = FastMath.max(maxTimeError, FastMath.abs(start - expectedStepStart));\n         }\n         expectedStepStart = start + integrator.getCurrentSignedStepsize();\n     }\n       double[] interpolatedY = interpolator.getInterpolatedState();\n       double[] theoreticalY  = problem.computeTheoreticalState(cT);\n       for (int i = 0; i < interpolatedY.length; ++i) {\n-        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);\n-        lastError = Math.max(error, lastError);\n+        double error = FastMath.abs(interpolatedY[i] - theoreticalY[i]);\n+        lastError = FastMath.max(error, lastError);\n       }\n       lastTime = cT;\n     }\n \n       // update the errors\n       for (int i = 0; i < interpolatedY.length; ++i) {\n-        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);\n-        maxValueError = Math.max(error, maxValueError);\n+        double error = errorScale[i] * FastMath.abs(interpolatedY[i] - theoreticalY[i]);\n+        maxValueError = FastMath.max(error, maxValueError);\n       }\n     }\n   }\n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n         Assert.assertTrue(residualsP0.getStandardDeviation() < 0.004);\n         Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 0.04);\n         Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);\n-        Assert.assertTrue(residualsP1.getStandardDeviation() > 0.006);\n-        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.007);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() > 0.007);\n+        Assert.assertTrue(residualsP1.getStandardDeviation() < 0.008);\n     }\n \n     @Test\n         Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n         double[][] dydy0 = new double[2][2];\n         double[][] dydp  = new double[2][3];\n-        double t = 18 * Math.PI;\n+        double t = 18 * FastMath.PI;\n         FirstOrderIntegratorWithJacobians extInt =\n             new FirstOrderIntegratorWithJacobians(integ, circle);\n         extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);\n         final Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n         double[][] dydy0 = new double[2][2];\n         double[][] dydp  = new double[2][3];\n-        double t = 18 * Math.PI;\n+        double t = 18 * FastMath.PI;\n         final FirstOrderIntegratorWithJacobians extInt =\n             new FirstOrderIntegratorWithJacobians(integ, circle);\n         extInt.addStepHandler(new StepHandlerWithJacobians() {\n         final Circle circle = new Circle(y, 1.0, 1.0, 0.1);\n         double[][] dydy0 = new double[2][2];\n         double[][] dydp  = new double[2][3];\n-        double t = 18 * Math.PI;\n+        double t = 18 * FastMath.PI;\n         final FirstOrderIntegratorWithJacobians extInt =\n             new FirstOrderIntegratorWithJacobians(integ, circle);\n         extInt.addEventHandler(new EventHandlerWithJacobians() {\n             }\n         }, 10.0, 1.0e-10, 1000);\n         double stopTime = extInt.integrate(0, y, circle.exactDyDp(0), t, y, dydy0, dydp);\n-        Assert.assertTrue(stopTime < 5.0 * Math.PI);\n+        Assert.assertTrue(stopTime < 5.0 * FastMath.PI);\n     }\n \n     private static class Brusselator implements ParameterizedODE, ODEWithJacobians {\n         }\n \n         public double[] exactY(double t) {\n-            double cos = Math.cos(omega * t);\n-            double sin = Math.sin(omega * t);\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n             double dx0 = y0[0] - cx;\n             double dy0 = y0[1] - cy;\n             return new double[] {\n         }\n \n         public double[][] exactDyDy0(double t) {\n-            double cos = Math.cos(omega * t);\n-            double sin = Math.sin(omega * t);\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n             return new double[][] {\n                 { cos, -sin },\n                 { sin,  cos }\n         }\n \n         public double[][] exactDyDp(double t) {\n-            double cos = Math.cos(omega * t);\n-            double sin = Math.sin(omega * t);\n+            double cos = FastMath.cos(omega * t);\n+            double sin = FastMath.sin(omega * t);\n             double dx0 = y0[0] - cx;\n             double dy0 = y0[1] - cy;\n             return new double[][] {\n         }\n \n         public double[] exactYDot(double t) {\n-            double oCos = omega * Math.cos(omega * t);\n-            double oSin = omega * Math.sin(omega * t);\n+            double oCos = omega * FastMath.cos(omega * t);\n+            double oSin = omega * FastMath.sin(omega * t);\n             double dx0 = y0[0] - cx;\n             double dy0 = y0[1] - cy;\n             return new double[] {\n         }\n \n         public double[][] exactDyDy0Dot(double t) {\n-            double oCos = omega * Math.cos(omega * t);\n-            double oSin = omega * Math.sin(omega * t);\n+            double oCos = omega * FastMath.cos(omega * t);\n+            double oSin = omega * FastMath.sin(omega * t);\n             return new double[][] {\n                 { -oSin, -oCos },\n                 {  oCos, -oSin }\n         }\n \n         public double[][] exactDyDpDot(double t) {\n-            double cos  = Math.cos(omega * t);\n-            double sin  = Math.sin(omega * t);\n+            double cos  = FastMath.cos(omega * t);\n+            double sin  = FastMath.sin(omega * t);\n             double oCos = omega * cos;\n             double oSin = omega * sin;\n             double dx0  = y0[0] - cx;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n import org.apache.commons.math.ode.TestProblem5;\n import org.apache.commons.math.ode.TestProblem6;\n import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class AdamsBashforthIntegratorTest {\n             TestProblem1 pb = new TestProblem1();\n             double minStep = 0;\n             double maxStep = pb.getFinalTime() - pb.getInitialTime();\n-            double scalAbsoluteTolerance = Math.pow(10.0, i);\n+            double scalAbsoluteTolerance = FastMath.pow(10.0, i);\n             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n             FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep,\n     public void backward() throws DerivativeException, IntegratorException {\n \n         TestProblem5 pb = new TestProblem5();\n-        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n         FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     @Test\n     public void polynomial() throws DerivativeException, IntegratorException {\n         TestProblem6 pb = new TestProblem6();\n-        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n         for (int nSteps = 1; nSteps < 8; ++nSteps) {\n             AdamsBashforthIntegrator integ =\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n import org.apache.commons.math.ode.TestProblem5;\n import org.apache.commons.math.ode.TestProblem6;\n import org.apache.commons.math.ode.TestProblemHandler;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class AdamsMoultonIntegratorTest {\n             TestProblem1 pb = new TestProblem1();\n             double minStep = 0;\n             double maxStep = pb.getFinalTime() - pb.getInitialTime();\n-            double scalAbsoluteTolerance = Math.pow(10.0, i);\n+            double scalAbsoluteTolerance = FastMath.pow(10.0, i);\n             double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n             FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep,\n     public void backward() throws DerivativeException, IntegratorException {\n \n         TestProblem5 pb = new TestProblem5();\n-        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n         FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n     @Test\n     public void polynomial() throws DerivativeException, IntegratorException {\n         TestProblem6 pb = new TestProblem6();\n-        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+        double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n         for (int nSteps = 1; nSteps < 7; ++nSteps) {\n             AdamsMoultonIntegrator integ =\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n public class ClassicalRungeKuttaIntegratorTest\n   extends TestCase {\n       double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n       Assert.assertEquals(tEvent, finalT, 5.0e-6);\n       for (int i = 0; i < y.length; ++i) {\n-          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n       }\n \n       integrator.addEventHandler(new EventHandler() {\n       finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n       Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n       for (int i = 0; i < y.length; ++i) {\n-          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n       }\n \n   }\n       for (int i = 4; i < 10; ++i) {\n \n         TestProblemAbstract pb = problems[k].copy();\n-        double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < Math.abs(previousError));\n+          assertTrue(error < FastMath.abs(previousError));\n         }\n         previousError = error;\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     throws DerivativeException, IntegratorException {\n \n     TestProblem5 pb = new TestProblem5();\n-    double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n     TestProblemHandler handler = new TestProblemHandler(pb, integ);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n \n     TestProblemAbstract pb = new TestProblem5();\n     double minStep = 1.25;\n-    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+    double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n     double scalAbsoluteTolerance = 6.0e-4;\n     double scalRelativeTolerance = 6.0e-4;\n \n       if (isLast) {\n         lastSeen = true;\n         double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();\n-        assertTrue(Math.abs(h) < minStep);\n+        assertTrue(FastMath.abs(h) < minStep);\n       }\n     }\n \n       TestProblem1 pb = new TestProblem1();\n       double minStep = 0;\n       double maxStep = pb.getFinalTime() - pb.getInitialTime();\n-      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalAbsoluteTolerance = FastMath.pow(10.0, i);\n       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n       EmbeddedRungeKuttaIntegrator integ =\n     public void handleStep(StepInterpolator interpolator,\n                            boolean isLast) {\n \n-      double step = Math.abs(interpolator.getCurrentTime()\n+      double step = FastMath.abs(interpolator.getCurrentTime()\n                              - interpolator.getPreviousTime());\n       if (firstTime) {\n-        minStep   = Math.abs(step);\n+        minStep   = FastMath.abs(step);\n         maxStep   = minStep;\n         firstTime = false;\n       } else {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class DormandPrince54StepInterpolatorTest {\n               StepInterpolator cloned = interpolator.copy();\n               double tA = cloned.getPreviousTime();\n               double tB = cloned.getCurrentTime();\n-              double halfStep = Math.abs(tB - tA) / 2;\n+              double halfStep = FastMath.abs(tB - tA) / 2;\n               assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n               assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n               for (int i = 0; i < 10; ++i) {\n                   double t = (i * tB + (9 - i) * tA) / 9;\n                   interpolator.setInterpolatedTime(t);\n-                  assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                  assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                   cloned.setInterpolatedTime(t);\n                   assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                   double[] referenceState = interpolator.getInterpolatedState();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n import org.apache.commons.math.ode.sampling.DummyStepHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n       double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n       Assert.assertEquals(tEvent, finalT, 5.0e-6);\n       for (int i = 0; i < y.length; ++i) {\n-          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n       }\n \n       integrator.setInitialStepSize(60.0);\n       finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n       Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n       for (int i = 0; i < y.length; ++i) {\n-          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n+          Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n       }\n \n   }\n       TestProblem1 pb = new TestProblem1();\n       double minStep = 0;\n       double maxStep = pb.getFinalTime() - pb.getInitialTime();\n-      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalAbsoluteTolerance = FastMath.pow(10.0, i);\n       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n       FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n     public void handleStep(StepInterpolator interpolator,\n                            boolean isLast) {\n \n-      double step = Math.abs(interpolator.getCurrentTime()\n+      double step = FastMath.abs(interpolator.getCurrentTime()\n                              - interpolator.getPreviousTime());\n       if (firstTime) {\n-        minStep   = Math.abs(step);\n+        minStep   = FastMath.abs(step);\n         maxStep   = minStep;\n         firstTime = false;\n       } else {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class DormandPrince853StepInterpolatorTest {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n-            double halfStep = Math.abs(tB - tA) / 2;\n+            double halfStep = FastMath.abs(tB - tA) / 2;\n             assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n             assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n             for (int i = 0; i < 10; ++i) {\n                 double t = (i * tB + (9 - i) * tA) / 9;\n                 interpolator.setInterpolatedTime(t);\n-                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                 cloned.setInterpolatedTime(t);\n                 assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                 double[] referenceState = interpolator.getInterpolatedState();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n import org.apache.commons.math.ode.nonstiff.EulerIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n public class EulerIntegratorTest\n   extends TestCase {\n \n         TestProblemAbstract pb  = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * Math.pow(2.0, -i);\n+          * FastMath.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new EulerIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < Math.abs(previousError));\n+          assertTrue(error < FastMath.abs(previousError));\n         }\n         previousError = error;\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n       throws DerivativeException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n-      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n       FirstOrderIntegrator integ = new EulerIntegrator(step);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n import org.apache.commons.math.ode.TestProblem3;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class EulerStepInterpolatorTest {\n \n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n     interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);\n+      assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10);\n     }\n \n     interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n     result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n \n     interpolator.setInterpolatedTime(0.1);\n     double[] result = interpolator.getInterpolatedState();\n-    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);\n-    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);\n-    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);\n+    assertTrue(FastMath.abs(result[0] - 0.1) < 1.0e-10);\n+    assertTrue(FastMath.abs(result[1] - 1.2) < 1.0e-10);\n+    assertTrue(FastMath.abs(result[2] + 2.2) < 1.0e-10);\n \n     interpolator.setInterpolatedTime(0.5);\n     result = interpolator.getInterpolatedState();\n-    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);\n-    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);\n-    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);\n+    assertTrue(FastMath.abs(result[0] - 0.5) < 1.0e-10);\n+    assertTrue(FastMath.abs(result[1] - 2.0) < 1.0e-10);\n+    assertTrue(FastMath.abs(result[2] + 3.0) < 1.0e-10);\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n public class GillIntegratorTest\n   extends TestCase {\n \n         TestProblemAbstract pb = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * Math.pow(2.0, -i);\n+          * FastMath.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new GillIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n \n         double error = handler.getMaximalValueError();\n         if (i > 5) {\n-          assertTrue(error < Math.abs(previousError));\n+          assertTrue(error < FastMath.abs(previousError));\n         }\n         previousError = error;\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n       throws DerivativeException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n-      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n       FirstOrderIntegrator integ = new GillIntegrator(step);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n \n     try {\n       TestProblem5 pb  = new TestProblem5();\n-      double minStep   = 0.1 * Math.abs(pb.getFinalTime() - pb.getInitialTime());\n-      double maxStep   = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double minStep   = 0.1 * FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep   = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n       double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };\n       double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };\n \n       TestProblem1 pb     = new TestProblem1();\n       double minStep      = 0;\n       double maxStep      = pb.getFinalTime() - pb.getInitialTime();\n-      double absTolerance = Math.pow(10.0, i);\n+      double absTolerance = FastMath.pow(10.0, i);\n       double relTolerance = absTolerance;\n \n       FirstOrderIntegrator integ =\n     public void handleStep(StepInterpolator interpolator,\n                            boolean isLast) {\n \n-      double step = Math.abs(interpolator.getCurrentTime()\n+      double step = FastMath.abs(interpolator.getCurrentTime()\n                              - interpolator.getPreviousTime());\n       if (firstTime) {\n-        minStep   = Math.abs(step);\n+        minStep   = FastMath.abs(step);\n         maxStep   = minStep;\n         firstTime = false;\n       } else {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class GraggBulirschStoerStepInterpolatorTest {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n-            double halfStep = Math.abs(tB - tA) / 2;\n+            double halfStep = FastMath.abs(tB - tA) / 2;\n             assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n             assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n             for (int i = 0; i < 10; ++i) {\n                 double t = (i * tB + (9 - i) * tA) / 9;\n                 interpolator.setInterpolatedTime(t);\n-                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                 cloned.setInterpolatedTime(t);\n                 assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                 double[] referenceState = interpolator.getInterpolatedState();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n import org.apache.commons.math.ode.events.EventHandler;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n public class HighamHall54IntegratorTest\n   extends TestCase {\n       TestProblem1 pb = new TestProblem1();\n       double minStep = 0;\n       double maxStep = pb.getFinalTime() - pb.getInitialTime();\n-      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalAbsoluteTolerance = FastMath.pow(10.0, i);\n       double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n \n       FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolatorTestUtils;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class HighamHall54StepInterpolatorTest {\n             StepInterpolator cloned = interpolator.copy();\n             double tA = cloned.getPreviousTime();\n             double tB = cloned.getCurrentTime();\n-            double halfStep = Math.abs(tB - tA) / 2;\n+            double halfStep = FastMath.abs(tB - tA) / 2;\n             assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n             assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n             for (int i = 0; i < 10; ++i) {\n                 double t = (i * tB + (9 - i) * tA) / 9;\n                 interpolator.setInterpolatedTime(t);\n-                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n                 cloned.setInterpolatedTime(t);\n                 assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n                 double[] referenceState = interpolator.getInterpolatedState();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n public class MidpointIntegratorTest\n   extends TestCase {\n \n         TestProblemAbstract pb = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * Math.pow(2.0, -i);\n+          * FastMath.pow(2.0, -i);\n         FirstOrderIntegrator integ = new MidpointIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n         integ.addStepHandler(handler);\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < Math.abs(previousError));\n+          assertTrue(error < FastMath.abs(previousError));\n         }\n         previousError = error;\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n       throws DerivativeException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n-      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n       FirstOrderIntegrator integ = new MidpointIntegrator(step);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n \n public class ThreeEighthesIntegratorTest\n   extends TestCase {\n \n         TestProblemAbstract pb = problems[k].copy();\n         double step = (pb.getFinalTime() - pb.getInitialTime())\n-          * Math.pow(2.0, -i);\n+          * FastMath.pow(2.0, -i);\n \n         FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n         TestProblemHandler handler = new TestProblemHandler(pb, integ);\n \n         double error = handler.getMaximalValueError();\n         if (i > 4) {\n-          assertTrue(error < Math.abs(previousError));\n+          assertTrue(error < FastMath.abs(previousError));\n         }\n         previousError = error;\n         assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n       throws DerivativeException, IntegratorException {\n \n       TestProblem5 pb = new TestProblem5();\n-      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+      double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n \n       FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n       TestProblemHandler handler = new TestProblemHandler(pb, integ);\n--- a/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class DummyStepInterpolatorTest {\n \n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+      assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n     interpolator.setInterpolatedTime(0.1);\n     double[] result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n     interpolator.setInterpolatedTime(0.5);\n     result = interpolator.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n     dsi.setInterpolatedTime(0.5);\n     double[] result = dsi.getInterpolatedState();\n     for (int i = 0; i < result.length; ++i) {\n-        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+        assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10);\n     }\n \n   }\n--- a/src/test/java/org/apache/commons/math/ode/sampling/StepInterpolatorTestUtils.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepInterpolatorTestUtils.java\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.TestProblemAbstract;\n+import org.apache.commons.math.util.FastMath;\n \n public class StepInterpolatorTestUtils {\n \n                 final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime());\n                 final double t = interpolator.getCurrentTime() - 300 * h;\n \n-                if (Math.abs(h) < 10 * Math.ulp(t)) {\n+                if (FastMath.abs(h) < 10 * FastMath.ulp(t)) {\n                     return;\n                 }\n \n--- a/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n import org.apache.commons.math.ode.sampling.FixedStepHandler;\n import org.apache.commons.math.ode.sampling.StepNormalizer;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.*;\n \n   }\n \n   public void checkValue(double value, double reference) {\n-    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+    assertTrue(FastMath.abs(value - reference) < 1.0e-10);\n   }\n \n   public void setLastSeen(boolean lastSeen) {\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizerTest.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.univariate.BrentOptimizer;\n import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class MultiStartUnivariateRealOptimizerTest {\n         double[] optima = minimizer.getOptima();\n         double[] optimaValues = minimizer.getOptimaValues();\n         for (int i = 1; i < optima.length; ++i) {\n-            double d = (optima[i] - optima[i-1]) / (2 * Math.PI);\n-            assertTrue (Math.abs(d - Math.rint(d)) < 1.0e-8);\n+            double d = (optima[i] - optima[i-1]) / (2 * FastMath.PI);\n+            assertTrue (FastMath.abs(d - FastMath.rint(d)) < 1.0e-8);\n             assertEquals(-1.0, f.value(optima[i]), 1.0e-10);\n             assertEquals(f.value(optima[i]), optimaValues[i], 1.0e-10);\n         }\n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n           public double value(double[] variables) throws FunctionEvaluationException {\n               final double x = variables[0];\n               final double y = variables[1];\n-              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n+              return ((x == 0) || (y == 0)) ? 0 : (FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y));\n           }\n       };\n \n       public double value(double[] point) {\n           final double x = point[0], y = point[1];\n           final double twoS2 = 2.0 * std * std;\n-          return 1.0 / (twoS2 * Math.PI) * Math.exp(-(x * x + y * y) / twoS2);\n+          return 1.0 / (twoS2 * FastMath.PI) * FastMath.exp(-(x * x + y * y) / twoS2);\n       }\n   }\n \n--- a/src/test/java/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleRealPointChecker;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class NelderMeadTest {\n           public double value(double[] variables) throws FunctionEvaluationException {\n               final double x = variables[0];\n               final double y = variables[1];\n-              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n+              return ((x == 0) || (y == 0)) ? 0 : (FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y));\n           }\n       };\n \n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n                 double c = parameters[2];\n                 double d = parameters[3];\n \n-                return d + ((a - d) / (1 + Math.pow(x / c, b)));\n+                return d + ((a - d) / (1 + FastMath.pow(x / c, b)));\n             }\n \n             public double[] gradient(double x, double[] parameters) {\n                 double d = parameters[3];\n \n                 double[] gradients = new double[4];\n-                double den = 1 + Math.pow(x / c, b);\n+                double den = 1 + FastMath.pow(x / c, b);\n \n                 // derivative with respect to a\n                 gradients[0] = 1 / den;\n \n                 // derivative with respect to b\n                 // in the reported (invalid) issue, there was a sign error here\n-                gradients[1] = -((a - d) * Math.pow(x / c, b) * Math.log(x / c)) / (den * den);\n+                gradients[1] = -((a - d) * FastMath.pow(x / c, b) * FastMath.log(x / c)) / (den * den);\n \n                 // derivative with respect to c\n-                gradients[2] = (b * Math.pow(x / c, b - 1) * (x / (c * c)) * (a - d)) / (den * den);\n+                gradients[2] = (b * FastMath.pow(x / c, b - 1) * (x / (c * c)) * (a - d)) / (den * den);\n \n                 // derivative with respect to d\n                 gradients[3] = 1 - (1 / den);\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n \n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n import org.junit.Test;\n \n         assertEquals(f.getPhase(),     MathUtils.normalizeAngle(fitted.getPhase(), f.getPhase()), 1.0e-13);\n \n         for (double x = -1.0; x < 1.0; x += 0.01) {\n-            assertTrue(Math.abs(f.value(x) - fitted.value(x)) < 1.0e-13);\n+            assertTrue(FastMath.abs(f.value(x) - fitted.value(x)) < 1.0e-13);\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.general.GaussNewtonOptimizer;\n import org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class PolynomialFitterTest {\n             PolynomialFunction fitted = fitter.fit();\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n-                double error = Math.abs(p.value(x) - fitted.value(x)) /\n-                               (1.0 + Math.abs(p.value(x)));\n+                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n+                               (1.0 + FastMath.abs(p.value(x)));\n                 assertEquals(0.0, error, 1.0e-6);\n             }\n \n             PolynomialFunction fitted = fitter.fit();\n \n             for (double x = -1.0; x < 1.0; x += 0.01) {\n-                double error = Math.abs(p.value(x) - fitted.value(x)) /\n-                              (1.0 + Math.abs(p.value(x)));\n-                maxError = Math.max(maxError, error);\n-                assertTrue(Math.abs(error) < 0.1);\n+                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n+                              (1.0 + FastMath.abs(p.value(x)));\n+                maxError = FastMath.max(maxError, error);\n+                assertTrue(FastMath.abs(error) < 0.1);\n             }\n         }\n         assertTrue(maxError > 0.01);\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import org.apache.commons.math.optimization.SimpleVectorialPointChecker;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n             optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n-        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);\n+        assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         assertEquals(69.96016175359975, circle.getRadius(center), 1.0e-10);\n         assertEquals(96.07590209601095, center.x, 1.0e-10);\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n-        assertTrue(Math.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n+        assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n         try {\n             optimizer.getCovariances();\n             fail(\"an exception should have been thrown\");\n         assertTrue(optimizer.getEvaluations() < 10);\n         assertTrue(optimizer.getJacobianEvaluations() < 10);\n         double rms = optimizer.getRMS();\n-        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);\n+        assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * rms,  1.0e-10);\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n         assertEquals(96.07590211815305, center.x,      1.0e-10);\n \n         // add perfect measurements and check errors are reduced\n         double  r = circle.getRadius(center);\n-        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n-            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n+        for (double d= 0; d < 2 * FastMath.PI; d += 0.01) {\n+            circle.addPoint(center.x + r * FastMath.cos(d), center.y + r * FastMath.sin(d));\n         }\n         double[] target = new double[circle.getN()];\n         Arrays.fill(target, 0.0);\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n \n   public void testMinpackRosenbrok() {\n     minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n-                                       Math.sqrt(24.2)), false);\n+                                       FastMath.sqrt(24.2)), false);\n     minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },\n-                                       Math.sqrt(1795769.0)), false);\n+                                       FastMath.sqrt(1795769.0)), false);\n     minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },\n-                                       11.0 * Math.sqrt(169000121.0)), false);\n+                                       11.0 * FastMath.sqrt(169000121.0)), false);\n   }\n \n   public void testMinpackHelicalValley() {\n   private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n       LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n       optimizer.setMaxIterations(100 * (function.getN() + 1));\n-      optimizer.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n-      optimizer.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+      optimizer.setCostRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n+      optimizer.setParRelativeTolerance(FastMath.sqrt(2.22044604926e-16));\n       optimizer.setOrthoTolerance(2.22044604926e-16);\n //      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n       try {\n \n       public void checkTheoreticalMinCost(double rms) {\n           double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n-          assertEquals(theoreticalMinCost, Math.sqrt(m) * rms, threshold);\n+          assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold);\n       }\n \n       public void checkTheoreticalMinParams(VectorialPointValuePair optimum) {\n               for (int i = 0; i < theoreticalMinParams.length; ++i) {\n                   double mi = theoreticalMinParams[i];\n                   double vi = params[i];\n-                  assertEquals(mi, vi, paramsAccuracy * (1.0 + Math.abs(mi)));\n+                  assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi)));\n               }\n           }\n       }\n \n     public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n       super(m, buildArray(n, x0),\n-            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n+            FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n             null);\n     }\n \n       double x2 = variables[1];\n       double tmpSquare = x1 * x1 + x2 * x2;\n       double tmp1 = twoPi * tmpSquare;\n-      double tmp2 = Math.sqrt(tmpSquare);\n+      double tmp2 = FastMath.sqrt(tmpSquare);\n       return new double[][] {\n         {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },\n         { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },\n       if (x1 == 0) {\n         tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n       } else {\n-        tmp1 = Math.atan(x2 / x1) / twoPi;\n+        tmp1 = FastMath.atan(x2 / x1) / twoPi;\n         if (x1 < 0) {\n           tmp1 += 0.5;\n         }\n       }\n-      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);\n+      double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2);\n       return new double[] {\n         10.0 * (x3 - 10 * tmp1),\n         10.0 * (tmp2 - 1),\n       };\n     }\n \n-    private static final double twoPi = 2.0 * Math.PI;\n+    private static final double twoPi = 2.0 * FastMath.PI;\n \n   }\n \n       };\n     }\n \n-    private static final double sqrt5  = Math.sqrt( 5.0);\n-    private static final double sqrt10 = Math.sqrt(10.0);\n+    private static final double sqrt5  = FastMath.sqrt( 5.0);\n+    private static final double sqrt10 = FastMath.sqrt(10.0);\n \n   }\n \n       for (int i = 0; i < m; ++i) {\n         double temp = 5.0 * (i + 1) + 45.0 + x3;\n         double tmp1 = x2 / temp;\n-        double tmp2 = Math.exp(tmp1);\n+        double tmp2 = FastMath.exp(tmp1);\n         double tmp3 = x1 * tmp2 / temp;\n         jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };\n       }\n       double x3 = variables[2];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n-        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n+        f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n       }\n      return f;\n     }\n       for (int i = 0; i < m; ++i) {\n         double tmp = (i + 1) / 10.0;\n         jacobian[i] = new double[] {\n-          -tmp * Math.exp(-tmp * x1),\n-           tmp * Math.exp(-tmp * x2),\n-          Math.exp(-i - 1) - Math.exp(-tmp)\n+          -tmp * FastMath.exp(-tmp * x1),\n+           tmp * FastMath.exp(-tmp * x2),\n+          FastMath.exp(-i - 1) - FastMath.exp(-tmp)\n         };\n       }\n       return jacobian;\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double tmp = (i + 1) / 10.0;\n-        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)\n-             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;\n+        f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2)\n+             + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3;\n       }\n       return f;\n     }\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double t = i + 1;\n-        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };\n+        jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) };\n       }\n       return jacobian;\n     }\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = i + 1;\n-        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);\n+        f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2);\n       }\n       return f;\n     }\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = (i + 1) / 5.0;\n-        double ti   = Math.sin(temp);\n-        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n-        double tmp2 = x3 + ti   * x4 - Math.cos(temp);\n+        double ti   = FastMath.sin(temp);\n+        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);\n+        double tmp2 = x3 + ti   * x4 - FastMath.cos(temp);\n         jacobian[i] = new double[] {\n           2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2\n         };\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = (i + 1) / 5.0;\n-        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n-        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);\n+        double tmp1 = x1 + temp * x2 - FastMath.exp(temp);\n+        double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp);\n         f[i] = tmp1 * tmp1 + tmp2 * tmp2;\n       }\n       return f;\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = 10.0 * i;\n-        double tmp1 = Math.exp(-temp * x4);\n-        double tmp2 = Math.exp(-temp * x5);\n+        double tmp1 = FastMath.exp(-temp * x4);\n+        double tmp2 = FastMath.exp(-temp * x5);\n         jacobian[i] = new double[] {\n           -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2\n         };\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = 10.0 * i;\n-        double tmp1 = Math.exp(-temp * x4);\n-        double tmp2 = Math.exp(-temp * x5);\n+        double tmp1 = FastMath.exp(-temp * x4);\n+        double tmp2 = FastMath.exp(-temp * x5);\n         f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);\n       }\n       return f;\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = i / 10.0;\n-        double tmp1 = Math.exp(-x05 * temp);\n-        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n-        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n-        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        double tmp1 = FastMath.exp(-x05 * temp);\n+        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));\n         jacobian[i] = new double[] {\n           -tmp1,\n           -tmp2,\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = i / 10.0;\n-        double tmp1 = Math.exp(-x05 * temp);\n-        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n-        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n-        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        double tmp1 = FastMath.exp(-x05 * temp);\n+        double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11));\n         f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);\n       }\n       return f;\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n /**\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         }\n-        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n+        assertEquals(3 * FastMath.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n         assertTrue(minimizer.getIterationCount() <= 50);\n-        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n+        assertEquals(3 * FastMath.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n         assertTrue(minimizer.getIterationCount() <= 50);\n         assertTrue(minimizer.getEvaluations()    <= 100);\n         assertTrue(minimizer.getEvaluations()    >=  15);\n         final double medianIter = stat[1].getPercentile(50);\n         final double medianEval = stat[2].getPercentile(50);\n         assertTrue(meanOptValue > -0.27195612812 && meanOptValue < -0.27195612811);\n-        assertEquals(medianIter, 17, Math.ulp(1d));\n-        assertEquals(medianEval, 18, Math.ulp(1d));\n+        assertEquals(medianIter, 17, FastMath.ulp(1d));\n+        assertEquals(medianEval, 18, FastMath.ulp(1d));\n     }\n \n     @Test\n         solver.setRelativeAccuracy(1e-8);\n \n         // endpoint is minimum\n-        double result = solver.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5);\n-        assertEquals(3 * Math.PI / 2, result, 10 * solver.getRelativeAccuracy());\n+        double result = solver.optimize(f, GoalType.MINIMIZE, 3 * FastMath.PI / 2, 5);\n+        assertEquals(3 * FastMath.PI / 2, result, 10 * solver.getRelativeAccuracy());\n \n-        result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2);\n-        assertEquals(3 * Math.PI / 2, result, 10 * solver.getRelativeAccuracy());\n+        result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * FastMath.PI / 2);\n+        assertEquals(3 * FastMath.PI / 2, result, 10 * solver.getRelativeAccuracy());\n     }\n }\n--- a/src/test/java/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n+import org.apache.commons.math.util.FastMath;\n \n public class CorrelatedRandomVectorGeneratorTest\n extends TestCase {\n \n         for (int i = 0; i < 10; i++) {\n             double[] generated = sg.nextVector();\n-            assertTrue(Math.abs(generated[0] - 1) > 0.1);\n+            assertTrue(FastMath.abs(generated[0] - 1) > 0.1);\n         }\n \n     }\n             for (int j = 0; j <= i; ++j) {\n                 assertEquals(covariance.getEntry(i, j),\n                         estimatedCovariance.getEntry(i, j),\n-                        0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j])));\n+                        0.1 * (1.0 + FastMath.abs(mean[i])) * (1.0 + FastMath.abs(mean[j])));\n             }\n         }\n \n--- a/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n+++ b/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class MersenneTwisterTest {\n             sample.addValue(mt.nextDouble());\n         }\n         assertEquals(0.5, sample.getMean(), 0.02);\n-        assertEquals(1.0 / (2.0 * Math.sqrt(3.0)),\n+        assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n                      sample.getStandardDeviation(),\n                      0.002);\n     }\n             sample.addValue(mt.nextFloat());\n         }\n         assertEquals(0.5, sample.getMean(), 0.01);\n-        assertEquals(1.0 / (2.0 * Math.sqrt(3.0)),\n+        assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),\n                      sample.getStandardDeviation(),\n                      0.006);\n     }\n                --walk;\n            }\n         }\n-        assertTrue(Math.abs(walk) < 120);\n+        assertTrue(FastMath.abs(walk) < 120);\n     }\n \n     @Test\n                --walk;\n            }\n         }\n-        assertTrue(Math.abs(walk) < 50);\n+        assertTrue(FastMath.abs(walk) < 50);\n     }\n \n     @Test\n                --walk;\n            }\n         }\n-        assertTrue(Math.abs(walk) < 250);\n+        assertTrue(FastMath.abs(walk) < 250);\n     }\n \n     @Test\n         int min = Integer.MAX_VALUE;\n         int max = Integer.MIN_VALUE;\n         for (int c : count) {\n-            min = Math.min(min, c);\n-            max = Math.max(max, c);\n+            min = FastMath.min(min, c);\n+            max = FastMath.max(max, c);\n         }\n         int expected = (100000 * bytes.length) / count.length;\n         assertTrue((expected - 200) < min);\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the RandomData class.\n         while (!widthSufficient) {\n             lowerBinMass = poissonDistribution.cumulativeProbability(lower, lower + binWidth - 1);\n             upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth + 1, upper);\n-            widthSufficient = Math.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;\n+            widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;\n             binWidth++;\n         }\n \n          * t-test at .001-level TODO: replace with externalized t-test, with\n          * test statistic defined in TestStatistic\n          */\n-        assertTrue(Math.abs(xbar) / (s / Math.sqrt(n)) < 3.29);\n+        assertTrue(FastMath.abs(xbar) / (s / FastMath.sqrt(n)) < 3.29);\n     }\n \n     /** test failure modes and distribution of nextExponential() */\n--- a/src/test/java/org/apache/commons/math/special/ErfTest.java\n+++ b/src/test/java/org/apache/commons/math/special/ErfTest.java\n package org.apache.commons.math.special;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n     }\n \n     public void testErf1960() throws MathException {\n-        double x = 1.960 / Math.sqrt(2.0);\n+        double x = 1.960 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.95;\n         assertEquals(expected, actual, 1.0e-5);\n     }\n \n     public void testErf2576() throws MathException {\n-        double x = 2.576 / Math.sqrt(2.0);\n+        double x = 2.576 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.99;\n         assertEquals(expected, actual, 1.0e-5);\n     }\n \n     public void testErf2807() throws MathException {\n-        double x = 2.807 / Math.sqrt(2.0);\n+        double x = 2.807 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.995;\n         assertEquals(expected, actual, 1.0e-5);\n     }\n \n     public void testErf3291() throws MathException {\n-        double x = 3.291 / Math.sqrt(2.0);\n+        double x = 3.291 / FastMath.sqrt(2.0);\n         double actual = Erf.erf(x);\n         double expected = 0.999;\n         assertEquals(expected, actual, 1.0e-5);\n--- a/src/test/java/org/apache/commons/math/special/GammaTest.java\n+++ b/src/test/java/org/apache/commons/math/special/GammaTest.java\n \n import org.apache.commons.math.MathException;\n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n                 -1e+17, -1e+18, -1e+19, -1e+20, -1e+21, -1e+22, -1e+23, -1e+24, -1e+25, -1e+26,\n                 -1e+27, -1e+28, -1e+29, -1e+30};\n         for (double n = 1; n < 30; n++) {\n-            checkRelativeError(String.format(\"Test %.0f: \", n), expected[(int) (n - 1)], Gamma.digamma(Math.pow(10.0, -n)), 1e-8);\n+            checkRelativeError(String.format(\"Test %.0f: \", n), expected[(int) (n - 1)], Gamma.digamma(FastMath.pow(10.0, -n)), 1e-8);\n         }\n     }\n \n     }\n \n     private void checkRelativeError(String msg, double expected, double actual, double tolerance) {\n-        assertEquals(msg, expected, actual, Math.abs(tolerance * actual));\n+        assertEquals(msg, expected, actual, FastMath.abs(tolerance * actual));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link StatUtils} class.\n \n         // test one\n         x = new double[] {two};\n-        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);\n-        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);\n-\n-        // test many\n-        x = new double[] {one, two, two, three};\n-        TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);\n-        TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);\n+        TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(FastMath.log(two), StatUtils.sumLog(x, 0, 1), tolerance);\n+\n+        // test many\n+        x = new double[] {one, two, two, three};\n+        TestUtils.assertEquals(FastMath.log(one) + 2.0 * FastMath.log(two) + FastMath.log(three), StatUtils.sumLog(x), tolerance);\n+        TestUtils.assertEquals(2.0 * FastMath.log(two), StatUtils.sumLog(x, 1, 2), tolerance);\n     }\n \n     public void testMean() {\n             // expected\n         }\n         test = new double[] {2, 4, 6, 8};\n-        assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)),\n+        assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)),\n                 StatUtils.geometricMean(test), Double.MIN_VALUE);\n-        assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)),\n+        assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)),\n                 StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointTest.java\n import java.util.List;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n import org.junit.Test;\n \n public class EuclideanIntegerPointTest {\n     public void testDistance() {\n         EuclideanIntegerPoint e1 = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });\n         EuclideanIntegerPoint e2 = new EuclideanIntegerPoint(new int[] {  1,  0, -1, 1, 1 });\n-        assertEquals(Math.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15);\n+        assertEquals(FastMath.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15);\n         assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15);\n         assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15);\n     }\n--- a/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.util.FastMath;\n \n import junit.framework.TestCase;\n \n         RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors();\n         for (int i = 0; i < 5; i++) {\n             for (int j = 0; j < i; j++) {\n-                double t = Math.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);\n+                double t = FastMath.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j);\n                 double p = 2 * (1 - tDistribution.cumulativeProbability(t));\n                 assertEquals(p, pValues.getEntry(i, j), 10E-15);\n             }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.util.DefaultTransformer;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.NumberTransformer;\n \n /**\n         if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&\n             windowSize < list.size())\n         {\n-            length = list.size() - Math.max(0, list.size() - windowSize);\n+            length = list.size() - FastMath.max(0, list.size() - windowSize);\n         }\n \n         // Create an array to hold all values\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link ListUnivariateImpl} class.\n     private double sumSq = 18;\n     private double sum = 8;\n     private double var = 0.666666666666666666667;\n-    private double std = Math.sqrt(var);\n+    private double std = FastMath.sqrt(var);\n     private double n = 4;\n     private double min = 1;\n     private double max = 3;\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.NumberTransformer;\n import org.apache.commons.math.util.TransformerMap;\n \n     private double sumSq = 18;\n     private double sum = 8;\n     private double var = 0.666666666666666666667;\n-    private double std = Math.sqrt(var);\n+    private double std = FastMath.sqrt(var);\n     private double n = 4;\n     private double min = 1;\n     private double max = 3;\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link MultivariateSummaryStatistics} class.\n         assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10);\n         assertEquals( 2, u.getMean()[0], 1.0e-10);\n         assertEquals( 3, u.getMean()[1], 1.0e-10);\n-        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);\n-        assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);\n+        assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10);\n+        assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10);\n         assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10);\n         assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10);\n         assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for {@link StorelessUnivariateStatistic} classes.\n         StorelessUnivariateStatistic replica = null;\n \n         // Randomly select a portion of testArray to load first\n-        long index = Math.round((Math.random()) * testArray.length);\n+        long index = FastMath.round((FastMath.random()) * testArray.length);\n \n         // Put first half in master and copy master to replica\n         master.incrementAll(testArray, 0, (int) index);\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.util.FastMath;\n /**\n  * Test cases for the {@link SummaryStatistics} class.\n  *\n     private double sumSq = 18;\n     private double sum = 8;\n     private double var = 0.666666666666666666667;\n-    private double std = Math.sqrt(var);\n+    private double std = FastMath.sqrt(var);\n     private double n = 4;\n     private double min = 1;\n     private double max = 3;\n         u.addValue(3);\n         assertEquals(4, u.getMean(), 1E-14);\n         assertEquals(4, u.getSumOfLogs(), 1E-14);\n-        assertEquals(Math.exp(2), u.getGeometricMean(), 1E-14);\n+        assertEquals(FastMath.exp(2), u.getGeometricMean(), 1E-14);\n         u.clear();\n         u.addValue(1);\n         u.addValue(2);\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.random.RandomData;\n import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n     protected double geoMean = 12.070589161633011d;\n \n     protected double var = 10.00235930735931d;\n-    protected double std = Math.sqrt(var);\n+    protected double std = FastMath.sqrt(var);\n     protected double skew = 1.437423729196190d;\n     protected double kurt = 2.377191264804700d;\n \n \n     protected double weightedMean = 12.366995073891626d;\n     protected double weightedVar =   9.974760968886391d;\n-    protected double weightedStd = Math.sqrt(weightedVar);\n+    protected double weightedStd = FastMath.sqrt(weightedVar);\n     protected double weightedProduct = 8517647448765288000000d;\n     protected double weightedSum = 251.05d;\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n         for (int i = 0; i < v.length; i++) {\n             sum += (v[i] - mean) * (v[i] - mean);\n         }\n-        return Math.sqrt(sum / v.length);\n+        return FastMath.sqrt(sum / v.length);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n package org.apache.commons.math.transform;\n \n import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.MathException;\n import junit.framework.TestCase;\n \n             assertEquals(x[i], result[i], tolerance);\n         }\n \n-        FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1)));\n+        FastFourierTransformer.scaleArray(x, FastMath.sqrt(0.5 * (x.length-1)));\n \n         result = transformer.transform2(y);\n         for (int i = 0; i < result.length; i++) {\n         double expected[] = { 0.0, 3.26197262739567, 0.0,\n                              -2.17958042710327, 0.0, -0.648846697642915,\n                               0.0, -0.433545502649478, 0.0 };\n-        min = 0.0; max = 2.0 * Math.PI * N / (N-1);\n+        min = 0.0; max = 2.0 * FastMath.PI * N / (N-1);\n         result = transformer.transform(f, min, max, N);\n         for (int i = 0; i < N; i++) {\n             assertEquals(expected[i], result[i], tolerance);\n         }\n \n-        min = -Math.PI; max = Math.PI * (N+1) / (N-1);\n+        min = -FastMath.PI; max = FastMath.PI * (N+1) / (N-1);\n         result = transformer.transform(f, min, max, N);\n         for (int i = 0; i < N; i++) {\n             assertEquals(-expected[i], result[i], tolerance);\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n \n import org.apache.commons.math.analysis.*;\n import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.MathException;\n import junit.framework.TestCase;\n \n         }\n \n         double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2};\n-        FastFourierTransformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length));\n+        FastFourierTransformer.scaleArray(x2, 1.0 / FastMath.sqrt(x2.length));\n         Complex y2[] = y;\n \n         result = transformer.transform2(y2);\n         Complex result[]; int N = 1 << 8;\n         double min, max, tolerance = 1E-12;\n \n-        min = 0.0; max = 2.0 * Math.PI;\n+        min = 0.0; max = 2.0 * FastMath.PI;\n         result = transformer.transform(f, min, max, N);\n         assertEquals(0.0, result[1].getReal(), tolerance);\n         assertEquals(-(N >> 1), result[1].getImaginary(), tolerance);\n             assertEquals(0.0, result[i].getImaginary(), tolerance);\n         }\n \n-        min = -Math.PI; max = Math.PI;\n+        min = -FastMath.PI; max = FastMath.PI;\n         result = transformer.inversetransform(f, min, max, N);\n         assertEquals(0.0, result[1].getReal(), tolerance);\n         assertEquals(-0.5, result[1].getImaginary(), tolerance);\n--- a/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n package org.apache.commons.math.transform;\n \n import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.MathException;\n import junit.framework.TestCase;\n \n             assertEquals(x[i], result[i], tolerance);\n         }\n \n-        FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0));\n+        FastFourierTransformer.scaleArray(x, FastMath.sqrt(x.length / 2.0));\n \n         result = transformer.transform2(y);\n         for (int i = 0; i < result.length; i++) {\n         FastSineTransformer transformer = new FastSineTransformer();\n         double min, max, result[], tolerance = 1E-12; int N = 1 << 8;\n \n-        min = 0.0; max = 2.0 * Math.PI;\n+        min = 0.0; max = 2.0 * FastMath.PI;\n         result = transformer.transform(f, min, max, N);\n         assertEquals(N >> 1, result[2], tolerance);\n         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n             assertEquals(0.0, result[i], tolerance);\n         }\n \n-        min = -Math.PI; max = Math.PI;\n+        min = -FastMath.PI; max = FastMath.PI;\n         result = transformer.transform(f, min, max, N);\n         assertEquals(-(N >> 1), result[2], tolerance);\n         for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) {\n--- a/src/test/java/org/apache/commons/math/util/BigRealTest.java\n+++ b/src/test/java/org/apache/commons/math/util/BigRealTest.java\n     public void testSerial() {\n         BigReal[] Reals = {\n             new BigReal(3.0), BigReal.ONE, BigReal.ZERO,\n-            new BigReal(17), new BigReal(Math.PI),\n+            new BigReal(17), new BigReal(FastMath.PI),\n             new BigReal(-2.5)\n         };\n         for (BigReal Real : Reals) {\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n             for (int k = 0; k <= n; k++) {\n                 assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));\n                 assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n-                assertEquals(n + \" choose \" + k, Math.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);\n+                assertEquals(n + \" choose \" + k, FastMath.log(binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);\n             }\n         }\n \n                 MathUtils.binomialCoefficient(n[i], k[i]));\n             assertEquals(n[i] + \" choose \" + k[i], expected,\n                 MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);\n-            assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", Math.log(expected),\n+            assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", FastMath.log(expected),\n                 MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);\n         }\n     }\n                     assertEquals(n + \" choose \" + k, 1.,\n                         MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);\n                     assertEquals(n + \" choose \" + k, 1,\n-                        MathUtils.binomialCoefficientLog(n, k) / Math.log(exactResult), 1e-10);\n+                        MathUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10);\n                 }\n             }\n         }\n         exactResult = binomialCoefficient(n, 3);\n         assertEquals(exactResult, ourResult);\n         assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n-        assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / Math.log(exactResult), 1e-10);\n+        assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);\n \n     }\n \n     public void testEqualsWithAllowedUlps() {\n         assertTrue(MathUtils.equals(0.0, -0.0, 1));\n \n-        assertTrue(MathUtils.equals(1.0, 1 + Math.ulp(1d), 1));\n-        assertFalse(MathUtils.equals(1.0, 1 + 2 * Math.ulp(1d), 1));\n-\n-        final double nUp1 = MathUtils.nextAfter(1d, Double.POSITIVE_INFINITY);\n-        final double nnUp1 = MathUtils.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n+        assertTrue(MathUtils.equals(1.0, 1 + FastMath.ulp(1d), 1));\n+        assertFalse(MathUtils.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n+\n+        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n+        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n         assertTrue(MathUtils.equals(1.0, nUp1, 1));\n         assertTrue(MathUtils.equals(nUp1, nnUp1, 1));\n         assertFalse(MathUtils.equals(1.0, nnUp1, 1));\n \n-        assertTrue(MathUtils.equals(0.0, Math.ulp(0d), 1));\n-        assertTrue(MathUtils.equals(0.0, -Math.ulp(0d), 1));\n+        assertTrue(MathUtils.equals(0.0, FastMath.ulp(0d), 1));\n+        assertTrue(MathUtils.equals(0.0, -FastMath.ulp(0d), 1));\n \n         assertTrue(MathUtils.equals(153.0, 153.0, 1));\n \n     public void testEqualsIncludingNaNWithAllowedUlps() {\n         assertTrue(MathUtils.equalsIncludingNaN(0.0, -0.0, 1));\n \n-        assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + Math.ulp(1d), 1));\n-        assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * Math.ulp(1d), 1));\n-\n-        final double nUp1 = MathUtils.nextAfter(1d, Double.POSITIVE_INFINITY);\n-        final double nnUp1 = Math.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n+        assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1));\n+        assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n+\n+        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n+        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n         assertTrue(MathUtils.equalsIncludingNaN(1.0, nUp1, 1));\n         assertTrue(MathUtils.equalsIncludingNaN(nUp1, nnUp1, 1));\n         assertFalse(MathUtils.equalsIncludingNaN(1.0, nnUp1, 1));\n \n-        assertTrue(MathUtils.equalsIncludingNaN(0.0, Math.ulp(0d), 1));\n-        assertTrue(MathUtils.equalsIncludingNaN(0.0, -Math.ulp(0d), 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1));\n \n         assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.0, 1));\n \n         assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n                                      new double[] { Double.NEGATIVE_INFINITY }));\n         assertFalse(MathUtils.equals(new double[] { 1d },\n-                                     new double[] { MathUtils.nextAfter(1d, 2d) }));\n+                                     new double[] { FastMath.nextAfter(1d, 2d) }));\n \n     }\n \n         assertFalse(MathUtils.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },\n                                                  new double[] { Double.NEGATIVE_INFINITY }));\n         assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d },\n-                                                 new double[] { MathUtils.nextAfter(MathUtils.nextAfter(1d, 2d), 2d) }));\n+                                                 new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) }));\n     }\n \n     public void testFactorial() {\n         for (int i = 1; i < 21; i++) {\n             assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n             assertEquals(i + \"! \", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n-            assertEquals(i + \"! \", Math.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);\n+            assertEquals(i + \"! \", FastMath.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);\n         }\n \n         assertEquals(\"0\", 1, MathUtils.factorial(0));\n                                       Double.NEGATIVE_INFINITY, 1d, 0d\n                                     }));\n         assertFalse(MathUtils.hash(new double[] { 1d }) ==\n-                    MathUtils.hash(new double[] { MathUtils.nextAfter(1d, 2d) }));\n+                    MathUtils.hash(new double[] { FastMath.nextAfter(1d, 2d) }));\n         assertFalse(MathUtils.hash(new double[] { 1d }) ==\n                     MathUtils.hash(new double[] { 1d, 1d }));\n     }\n \n     public void testNextAfter() {\n         // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000\n-        assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);\n+        assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0);\n \n         // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe\n-        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);\n+        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);\n \n         // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe\n-        assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);\n+        assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0);\n \n         // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe\n-        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);\n+        assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);\n \n         // 0x4020000000000000 0x404123456789abcd -> 4020000000000001\n-        assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);\n+        assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0);\n \n         // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff\n-        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);\n+        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0);\n \n         // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff\n-        assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);\n+        assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0);\n \n         // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff\n-        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);\n+        assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0);\n \n         // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224\n-        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+        assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n \n         // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224\n-        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+        assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n \n         // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n \n         // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n \n         // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n \n         // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222\n-        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+        assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n \n         // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n+        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n \n         // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n+        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n \n         // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n+        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n \n         // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224\n-        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n+        assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n \n         // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224\n-        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n+        assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n \n         // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222\n-        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n+        assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n \n     }\n \n     public void testNextAfterSpecialCases() {\n-        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));\n-        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));\n-        assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));\n-        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY)));\n-        assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));\n-        assertEquals(Double.MIN_VALUE, MathUtils.nextAfter(0, 1), 0);\n-        assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);\n-        assertEquals(0, MathUtils.nextAfter(Double.MIN_VALUE, -1), 0);\n-        assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE, 1), 0);\n+        assertTrue(Double.isInfinite(FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0)));\n+        assertTrue(Double.isInfinite(FastMath.nextAfter(Double.POSITIVE_INFINITY, 0)));\n+        assertTrue(Double.isNaN(FastMath.nextAfter(Double.NaN, 0)));\n+        assertTrue(Double.isInfinite(FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY)));\n+        assertTrue(Double.isInfinite(FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));\n+        assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0, 1), 0);\n+        assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0, -1), 0);\n+        assertEquals(0, FastMath.nextAfter(Double.MIN_VALUE, -1), 0);\n+        assertEquals(0, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0);\n     }\n \n     public void testScalb() {\n         assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);\n         assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);\n         assertEquals(1.0 / 32.0, MathUtils.scalb(1.0,  -5), 1.0e-15);\n-        assertEquals(Math.PI, MathUtils.scalb(Math.PI, 0), 1.0e-15);\n+        assertEquals(FastMath.PI, MathUtils.scalb(FastMath.PI, 0), 1.0e-15);\n         assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1)));\n         assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1)));\n         assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1)));\n         for (double a = -15.0; a <= 15.0; a += 0.1) {\n             for (double b = -15.0; b <= 15.0; b += 0.2) {\n                 double c = MathUtils.normalizeAngle(a, b);\n-                assertTrue((b - Math.PI) <= c);\n-                assertTrue(c <= (b + Math.PI));\n-                double twoK = Math.rint((a - c) / Math.PI);\n-                assertEquals(c, a - twoK * Math.PI, 1.0e-14);\n+                assertTrue((b - FastMath.PI) <= c);\n+                assertTrue(c <= (b + FastMath.PI));\n+                double twoK = FastMath.rint((a - c) / FastMath.PI);\n+                assertEquals(c, a - twoK * FastMath.PI, 1.0e-14);\n             }\n         }\n     }", "timestamp": 1283119449, "metainfo": ""}