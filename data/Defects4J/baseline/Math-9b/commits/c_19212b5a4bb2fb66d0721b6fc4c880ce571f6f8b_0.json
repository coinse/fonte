{"sha": "19212b5a4bb2fb66d0721b6fc4c880ce571f6f8b", "log": "added a first version of eigen decomposition implementation this version is not finished yet, but it does work when eigenvalues are well separated and is faster than JAMA for dimensions above 100. It still needs work as the MRRR algorithm is not implemented yet (only the basic parts with twisted factorization is there). I continue working on this, but wanted to have a first version committed to let people play with it and as a basis for comparison.  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n  *   been added (in the superinterface),</li>\n  *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n  *   added (in the superinterface),</li>\n- *   <li>a {@link #getVt() getVt} method has been added,</li>\n+ *   <li>a {@link #getVT() getVt} method has been added,</li>\n+ *   <li>a {@link #getEigenvalue(int) getEigenvalue} method to pick up a single\n+ *   eigenvalue has been added,</li>\n+ *   <li>a {@link #getEigenvector(int) getEigenvector} method to pick up a single\n+ *   eigenvector has been added,</li>\n  *   <li>the <code>getRealEigenvalues</code> method has been renamed as {@link\n  *   #getEigenValues() getEigenValues},</li>\n  *   <li>the <code>getImagEigenvalues</code> method has been removed</li>\n      * @exception IllegalStateException if {@link\n      * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getVt() throws IllegalStateException;\n+    RealMatrix getVT() throws IllegalStateException;\n \n     /**\n-     * Returns the eigenvalues of the original matrix.\n-     * @return eigenvalues of the original matrix\n+     * Returns a copy of the eigenvalues of the original matrix.\n+     * @return a copy of the eigenvalues of the original matrix\n      * @exception IllegalStateException if {@link\n      * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getD()\n      */\n-    double[] getEigenValues() throws IllegalStateException;\n+    double[] getEigenvalues() throws IllegalStateException;\n+\n+    /**\n+     * Returns the i<sup>th</sup> eigenvalue of the original matrix.\n+     * @return i<sup>th</sup> eigenvalue of the original matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @exception ArrayIndexOutOfBoundsException if i is not\n+     * @see #getD()\n+     */\n+    double getEigenvalue(int i) throws IllegalStateException;\n+\n+    /**\n+     * Returns a copy of the i<sup>th</sup> eigenvector of the original matrix.\n+     * @return copy of the i<sup>th</sup> eigenvector of the original matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getD()\n+     */\n+    RealVector getEigenvector(int i) throws IllegalStateException;\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #isNonSingular()\n+     */\n+    double getDeterminant() throws IllegalStateException;\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * Calculates the eigen decomposition of a matrix.\n+ * <p>The eigen decomposition of matrix A is a set of two matrices:\n+ * V and D such that A = V &times; D &times; V<sup>T</sup>.\n+ * Let A be an m &times; n matrix, then V is an m &times; m orthogonal matrix\n+ * and D is a m &times; n diagonal matrix.</p>\n+ * <p>This implementation is based on Inderjit Singh Dhillon thesis\n+ * <a href=\"http://www.cs.utexas.edu/users/inderjit/public_papers/thesis.pdf\">A\n+ * New O(n<sup>2</sup>) Algorithm for the Symmetric Tridiagonal Eigenvalue/Eigenvector\n+ * Problem</a>.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EigenDecompositionImpl implements EigenDecomposition {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -8550254713195393577L;\n+\n+    /** Eigenvalues. */\n+    private double[] eigenvalues;\n+\n+    /** Eigenvectors. */\n+    private RealVectorImpl[] eigenvectors;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /** Cached value of D. */\n+    private RealMatrix cachedD;\n+\n+    /** Cached value of Vt. */\n+    private RealMatrix cachedVt;\n+\n+    /**\n+     * Build a new instance.\n+     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n+     * before any of the {@link #getV()}, {@link #getD()}, {@link #getVT()},\n+     * {@link #getEignevalues()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n+     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n+     * called.</p>\n+     * @see #decompose(RealMatrix)\n+     */\n+    public EigenDecompositionImpl() {\n+    }\n+\n+    /**\n+     * Calculates the eigen decomposition of the given matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public EigenDecompositionImpl(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        decompose(matrix);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+\n+        cachedV  = null;\n+        cachedD  = null;\n+        cachedVt = null;\n+\n+        // transform the matrix to tridiagonal\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        final double[] main      = transformer.getMainDiagonalRef();\n+        final double[] secondary = transformer.getSecondaryDiagonalRef();\n+        final int m = main.length;\n+\n+        // pre-compute the square of the secondary diagonal\n+        double[] squaredSecondary = new double[secondary.length];\n+        for (int i = 0; i < squaredSecondary.length; ++i) {\n+            final double s = secondary[i];\n+            squaredSecondary[i] = s * s;\n+        }\n+\n+        // compute the eigenvalues bounds\n+        List<GershgorinCirclesUnion> bounds =\n+            getEigenvaluesBounds(main, secondary);\n+\n+        // TODO this implementation is not finished yet\n+        // the MRRR algorithm is NOT implemented, Gershgorin circles are\n+        // merged together when they could be separated, we only perform blindly\n+        // the basic steps, we search all eigenvalues with an arbitrary\n+        // threshold, we use twisted factorization afterwards with no\n+        // heuristic to speed up the selection of the twist index ...\n+        // The decomposition does work in its current state and seems reasonably\n+        // efficient when eigenvalues are separated. However, it is expected to\n+        // fail in difficult cases and its performances can obviously be improved\n+        // for now, it is slower than JAMA for dimensions below 100 and faster\n+        // for dimensions above 100. The speed gain with respect to JAMA increase\n+        // regularly with dimension\n+\n+        // find eigenvalues using bisection\n+        eigenvalues = new double[m];\n+        final double low  = bounds.get(0).getLow();\n+        final double high = bounds.get(bounds.size() - 1).getHigh();\n+        final double threshold =\n+            1.0e-15 * Math.max(Math.abs(low), Math.abs(high));\n+        findEigenvalues(main, squaredSecondary, low, high, threshold, 0, m);\n+\n+        // find eigenvectors\n+        eigenvectors = new RealVectorImpl[m];\n+        final double[] eigenvector = new double[m];\n+        final double[] lp          = new double[m - 1];\n+        final double[] dp          = new double[m];\n+        final double[] um          = new double[m - 1];\n+        final double[] dm          = new double[m];\n+        final double[] gamma       = new double[m];\n+        for (int i = 0; i < m; ++i) {\n+\n+            // find the eigenvector of the tridiagonal matrix\n+            findEigenvector(eigenvalues[i], eigenvector,\n+                            main, secondary, lp, dp, um, dm, gamma);\n+\n+            // find the eigenvector of the original matrix\n+            eigenvectors[i] =\n+                new RealVectorImpl(transformer.getQ().operate(eigenvector), true);\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getV()\n+        throws InvalidMatrixException {\n+\n+        if (cachedV == null) {\n+            cachedV = getVT().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getD()\n+        throws InvalidMatrixException {\n+\n+        if (cachedD == null) {\n+\n+            checkDecomposed();\n+\n+            final int m = eigenvalues.length;\n+            final double[][] sData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                sData[i][i] = eigenvalues[i];\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedD = new RealMatrixImpl(sData, false);\n+\n+        }\n+        return cachedD;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getVT()\n+        throws InvalidMatrixException {\n+\n+        if (cachedVt == null) {\n+\n+            checkDecomposed();\n+\n+            final double[][] vtData = new double[eigenvectors.length][];\n+            for (int k = 0; k < eigenvectors.length; ++k) {\n+                vtData[k] = eigenvectors[k].getData();\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedVt = new RealMatrixImpl(vtData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedVt;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getEigenvalues()\n+        throws InvalidMatrixException {\n+        checkDecomposed();\n+        return eigenvalues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEigenvalue(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        checkDecomposed();\n+        return eigenvalues[i];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getEigenvector(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        checkDecomposed();\n+        return eigenvectors[i].copy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNonSingular()\n+        throws IllegalStateException {\n+        for (double lambda : eigenvalues) {\n+            if (lambda == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        checkNonSingular();\n+\n+        final int m = eigenvalues.length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] bp = new double[m];\n+        for (int i = 0; i < m; ++i) {\n+            final RealVectorImpl v = eigenvectors[i];\n+            final double s = v.dotProduct(b) / eigenvalues[i];\n+            final double[] vData = v.getDataRef();\n+            for (int j = 0; j < m; ++j) {\n+                bp[j] += s * vData[j];\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+\n+            checkNonSingular();\n+\n+            final int m = eigenvalues.length;\n+            if (b.getDimension() != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+\n+            final double[] bp = new double[m];\n+            for (int i = 0; i < m; ++i) {\n+                final RealVectorImpl v = eigenvectors[i];\n+                final double s = v.dotProduct(b) / eigenvalues[i];\n+                final double[] vData = v.getDataRef();\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j] += s * vData[j];\n+                }\n+            }\n+\n+            return new RealVectorImpl(bp, false);\n+\n+        }\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X such that A &times; X = B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVectorImpl solve(final RealVectorImpl b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        checkNonSingular();\n+\n+        final int m = eigenvalues.length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+        final double[][] bp = new double[m][nColB];\n+        for (int k = 0; k < nColB; ++k) {\n+            for (int i = 0; i < m; ++i) {\n+                final double[] vData = eigenvectors[i].getDataRef();\n+                double s = 0;\n+                for (int j = 0; j < m; ++j) {\n+                    s += vData[j] * b.getEntry(j, k);\n+                }\n+                s /= eigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j][k] += s * vData[j];\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException {\n+\n+        checkNonSingular();\n+        final int m = eigenvalues.length;\n+        final double[][] invData = new double[m][m];\n+\n+        for (int i = 0; i < m; ++i) {\n+            final double[] invI = invData[i];\n+            for (int j = 0; j < m; ++j) {\n+                double invIJ = 0;\n+                for (int k = 0; k < m; ++k) {\n+                    final double[] vK = eigenvectors[k].getDataRef();\n+                    invIJ += vK[i] * vK[j] / eigenvalues[k];\n+                }\n+                invI[j] = invIJ;\n+            }\n+        }\n+        return new RealMatrixImpl(invData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant()\n+        throws IllegalStateException {\n+        double determinant = 1;\n+        for (double lambda : eigenvalues) {\n+            determinant *= lambda;\n+        }\n+        return determinant;\n+    }\n+\n+    /**\n+     * Compute a set of possible bounding intervals for eigenvalues\n+     * of a symmetric tridiagonal matrix.\n+     * <p>The intervals are computed by applying the Gershgorin circle theorem.</p>\n+     * @param main main diagonal\n+     * @param secondary secondary diagonal of the tridiagonal matrix\n+     * @return a collection of disjoint intervals where eigenvalues must lie,\n+     * sorted in increasing order\n+     */\n+    private List<GershgorinCirclesUnion> getEigenvaluesBounds(final double[] main,\n+                                                              final double[] secondary) {\n+\n+        final SortedSet<GershgorinCirclesUnion> rawCircles =\n+            new TreeSet<GershgorinCirclesUnion>();\n+        final int m = main.length;\n+\n+        // compute all the Gershgorin circles independently\n+        rawCircles.add(new GershgorinCirclesUnion(main[0],\n+                                                  Math.abs(secondary[0])));\n+        for (int i = 1; i < m - 1; ++i) {\n+            rawCircles.add(new GershgorinCirclesUnion(main[i],\n+                                                      Math.abs(secondary[i - 1]) +\n+                                                      Math.abs(secondary[i])));\n+        }\n+        rawCircles.add(new GershgorinCirclesUnion(main[m - 1],\n+                                                  Math.abs(secondary[m - 2])));\n+\n+        // combine intersecting circles\n+        final ArrayList<GershgorinCirclesUnion> combined =\n+            new ArrayList<GershgorinCirclesUnion>();\n+        GershgorinCirclesUnion current = null;\n+        for (GershgorinCirclesUnion rawCircle : rawCircles) {\n+            if (current == null) {\n+                current = rawCircle;\n+            } else if (current.intersects(rawCircle)) {\n+                current.swallow(rawCircle);\n+            } else {\n+                combined.add(current);\n+                current = rawCircle;\n+            }\n+        }\n+        if (current != null) {\n+            combined.add(current);\n+        }\n+        \n+        return combined;\n+\n+    }\n+\n+    /** Find eigenvalues in an interval.\n+     * @param main main diagonal of the tridiagonal matrix\n+     * @param squaredSecondary squared secondary diagonal of the tridiagonal matrix\n+     * @param low lower bound of the search interval\n+     * @param high higher bound of the search interval\n+     * @param threshold convergence threshold\n+     * @param iStart index of the first eigenvalue to find\n+     * @param iEnd index one unit past the last eigenvalue to find\n+     */\n+    private void findEigenvalues(final double[] main, final double[] squaredSecondary,\n+                                 final double low, final double high, final double threshold,\n+                                 final int iStart, final int iEnd) {\n+\n+        // use a simple loop to handle tail-recursion cases\n+        double currentLow   = low;\n+        double currentHigh  = high;\n+        int    currentStart = iStart;\n+        while (true) {\n+\n+            final double middle = 0.5 * (currentLow + currentHigh);\n+\n+            if (currentHigh - currentLow < threshold) {\n+                // we have found an elementary interval containing one or more eigenvalues\n+                Arrays.fill(eigenvalues, currentStart, iEnd, middle);\n+                return;\n+            }\n+\n+            // compute the number of eigenvalues below the middle interval point\n+            final int iMiddle = countEigenValues(main, squaredSecondary, middle);\n+            if (iMiddle == currentStart) {\n+                // all eigenvalues are in the upper half of the search interval\n+                // update the interval and iterate\n+                currentLow = middle;\n+            } else if (iMiddle == iEnd) {\n+                // all eigenvalues are in the lower half of the search interval\n+                // update the interval and iterate\n+                currentHigh = middle;                \n+            } else {\n+                // split the interval and search eigenvalues in both sub-intervals\n+                findEigenvalues(main, squaredSecondary, currentLow, middle, threshold,\n+                                currentStart, iMiddle);\n+                currentLow   = middle;\n+                currentStart = iMiddle;\n+            }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Count the number of eigenvalues below a point.\n+     * @param main main diagonal of the tridiagonal matrix\n+     * @param squaredSecondary squared secondary diagonal of the tridiagonal matrix\n+     * @param mu value below which we must count the number of eigenvalues\n+     * @return number of eigenvalues smaller than mu\n+     */\n+    private int countEigenValues(final double[] main, final double[] squaredSecondary,\n+                                 final double mu) {\n+        double ratio = main[0] - mu;\n+        int count = (ratio > 0) ? 0 : 1;\n+        for (int i = 1; i < main.length; ++i) {\n+            ratio = main[i] - squaredSecondary[i - 1] / ratio - mu;\n+            if (ratio <= 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Decompose the shifted tridiagonal matrix A - lambda I as L<sub>+</sub>\n+     * &times; D<sub>+</sub> &times; U<sub>+</sub>.\n+     * <p>A shifted symmetric tridiagonal matrix can be decomposed as\n+     * L<sub>+</sub> &times; D<sub>+</sub> &times; U<sub>+</sub> where L<sub>+</sub>\n+     * is a lower bi-diagonal matrix with unit diagonal, D<sub>+</sub> is a diagonal\n+     * matrix and U<sub>+</sub> is the transpose of L<sub>+</sub>. The '+' indice\n+     * comes from Dhillon's notation since decomposition is done in\n+     * increasing rows order).</p>\n+     * @param main main diagonal of the tridiagonal matrix\n+     * @param secondary secondary diagonal of the tridiagonal matrix\n+     * @param lambda shift to apply to the matrix before decomposing it\n+     * @param r index at which factorization should stop (if r is\n+     * <code>main.length</code>, complete factorization is performed)\n+     * @param lp placeholder where to put the (r-1) first off-diagonal\n+     * elements of the L<sub>+</sub> matrix\n+     * @param dp placeholder where to put the r first diagonal elements\n+     * of the D<sub>+</sub> matrix\n+     */\n+    private void lduDecomposition(final double[] main, final double[] secondary,\n+                                  final double lambda, final int r,\n+                                  final double[] lp, final double[] dp) {\n+        double di = main[0] - lambda;\n+        dp[0] = di;\n+        for (int i = 1; i < r; ++i) {\n+            final double eiM1 = secondary[i - 1];\n+            final double ratio = eiM1 / di;\n+            di = main[i] - lambda - eiM1 * ratio;\n+            lp[i - 1] = ratio;\n+            dp[i] = di;\n+        }\n+    }\n+\n+    /**\n+     * Decompose the shifted tridiagonal matrix A - lambda I as U<sub>-</sub>\n+     * &times; D<sub>-</sub> &times; L<sub>-</sub>.\n+     * <p>A shifted symmetric tridiagonal matrix can be decomposed as\n+     * U<sub>-</sub> &times; D<sub>-</sub> &times; L<sub>-</sub> where U<sub>-</sub>\n+     * is an upper bi-diagonal matrix with unit diagonal, D<sub>-</sub> is a diagonal\n+     * matrix and L<sub>-</sub> is the transpose of U<sub>-</sub>. The '-' indice\n+     * comes from Dhillon's notation since decomposition is done in\n+     * decreasing rows order).</p>\n+     * @param main main diagonal of the tridiagonal matrix\n+     * @param secondary secondary diagonal of the tridiagonal matrix\n+     * @param lambda shift to apply to the matrix before decomposing it\n+     * @param r index at which factorization should stop (if r is 0, complete\n+     * factorization is performed)\n+     * @param um placeholder where to put the m-(r-1) last off-diagonal elements\n+     * of the U<sub>-</sub> matrix, where m is the size of the original matrix\n+     * @param dm placeholder where to put the m-r last diagonal elements\n+     * of the D<sub>-</sub> matrix, where m is the size of the original matrix\n+     */\n+    private void udlDecomposition(final double[] main, final double[] secondary,\n+                                  final double lambda, final int r,\n+                                  final double[] um, final double[] dm) {\n+        final int mM1 = main.length - 1;\n+        double di = main[mM1] - lambda;\n+        dm[mM1] = di;\n+        for (int i = mM1 - 1; i >= r; --i) {\n+            final double ei = secondary[i];\n+            final double ratio = ei / di;\n+            di = main[i] - lambda - ei * ratio;\n+            um[i] = ratio;\n+            dm[i] = di;\n+        }\n+    }\n+\n+    /**\n+     * Find an eigenvector corresponding to an eigenvalue.\n+     * @param eigenvalue eigenvalue for which eigenvector is desired\n+     * @param eigenvector placeholder where to put the eigenvector\n+     * @param main main diagonal of the tridiagonal matrix\n+     * @param secondary secondary diagonal of the tridiagonal matrix\n+     * @param lp placeholder where to put the off-diagonal elements of the\n+     * L<sub>+</sub> matrix\n+     * @param dp placeholder where to put the diagonal elements of the\n+     * D<sub>+</sub> matrix\n+     * @param um placeholder where to put the off-diagonal elements of the\n+     * U<sub>-</sub> matrix\n+     * @param dm placeholder where to put the diagonal elements of the\n+     * D<sub>-</sub> matrix\n+     * @param gamma placeholder where to put the twist elements for all\n+     * possible twist indices\n+     */\n+    private void findEigenvector(final double eigenvalue, final double[] eigenvector,\n+                                 final double[] main, final double[] secondary,\n+                                 final double[] lp, final double[] dp,\n+                                 final double[] um, final double[] dm,\n+                                 final double[] gamma) {\n+\n+        // compute the LDU and UDL decomposition of the\n+        // perfectly shifted tridiagonal matrix\n+        final int m = main.length;\n+        lduDecomposition(main, secondary, eigenvalue, m, lp, dp);\n+        udlDecomposition(main, secondary, eigenvalue, 0, um, dm);\n+\n+        // select the twist index leading to\n+        // the least diagonal element in the twisted factorization\n+        int r = 0;\n+        double g = dp[0] + dm[0] + eigenvalue - main[0];\n+        gamma[0] = g;\n+        double minG = Math.abs(g);\n+        for (int i = 1; i < m; ++i) {\n+            if (i < m - 1) {\n+                g *= dm[i + 1] / dp[i];\n+            } else {\n+                g = dp[m - 1] + dm[m - 1] + eigenvalue - main[m - 1];\n+            }\n+            gamma[i] = g;\n+            final double absG = Math.abs(g);\n+            if (absG < minG) {\n+                r = i;\n+                minG = absG;\n+            }\n+        }\n+\n+        // solve the singular system by ignoring the equation\n+        // at twist index and propagating upwards and downwards\n+        double n2 = 1;\n+        eigenvector[r] = 1;\n+        double z = 1;\n+        for (int i = r - 1; i >= 0; --i) {\n+            z *= -lp[i];\n+            eigenvector[i] = z;\n+            n2 += z * z;\n+        }\n+        z = 1;\n+        for (int i = r + 1; i < m; ++i) {\n+            z *= -um[i-1];\n+            eigenvector[i] = z;\n+            n2 += z * z;\n+        }\n+\n+        // normalize vector\n+        final double inv = 1.0 / Math.sqrt(n2);\n+        for (int i = 0; i < m; ++i) {\n+            eigenvector[i] *= inv;\n+        }\n+\n+    }\n+\n+    /**\n+     * Check if decomposition has been performed.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     */\n+    private void checkDecomposed()\n+        throws IllegalStateException {\n+        if (eigenvalues == null) {\n+            throw new IllegalStateException(\"no matrix have been decomposed yet\");\n+        }\n+    }\n+\n+    /**\n+     * Check if decomposed matrix is non singular.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    private void checkNonSingular()\n+        throws IllegalStateException, InvalidMatrixException {\n+        checkDecomposed();\n+        if (!isNonSingular()) {\n+            throw new IllegalStateException(\"matrix is singular\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/GershgorinCirclesUnion.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/** Class representing a union of Gershgorin circles.\n+ * <p>Gershgorin circles are bounding areas where eigenvalues must lie.\n+ * They are used as starting values for eigen decomposition algorithms.\n+ * In the real case, Gershgorin circles are simple intervals.</p>\n+ * @see EigenDecompositionImpl\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class GershgorinCirclesUnion implements Comparable<GershgorinCirclesUnion> {\n+\n+    /** Lower bound of the interval. */\n+    private double low;\n+\n+    /** Higher bound of the interval. */\n+    private double high;\n+\n+    /** Create a simple Gershgorin circle.\n+     * @param d diagonal element of the current row\n+     * @param sum sum of the absolute values of the off-diagonal elements\n+     * of the current row\n+     */\n+    public GershgorinCirclesUnion(final double d, final double sum) {\n+        low  = d - sum;\n+        high = d + sum;\n+    }\n+\n+    /**\n+     * Get the lower bound of the interval.\n+     * @return lower bound of the interval\n+     */\n+    public double getLow() {\n+        return low;\n+    }\n+\n+    /**\n+     * Get the higher bound of the interval.\n+     * @return higher bound of the interval\n+     */\n+    public double getHigh() {\n+        return high;\n+    }\n+\n+    /**\n+     * Check if a Gershgorin circles union intersects instance.\n+     * @param other Gershgorin circles union to test against instance\n+     * @return true if the other Gershgorin circles union intersects instance\n+     */\n+    public boolean intersects(final GershgorinCirclesUnion other) {\n+        return (other.low <= this.high) && (other.high >= this.low);\n+    }\n+\n+    /**\n+     * Swallow another Gershgorin circles union.\n+     * <p>Swallowing another Gershgorin circles union changes the\n+     * instance such that it contains everything that was formerly in\n+     * either circles union. It is mainly intended for circles unions\n+     * that {@link #intersects(GershgorinCirclesUnion) intersect}\n+     * each other beforehand.</p>\n+     */\n+    public void swallow(final GershgorinCirclesUnion other) {\n+        low  = Math.min(low,  other.low);\n+        high = Math.max(high, other.high);\n+    }\n+\n+    /** Comparator class for sorting intervals. */\n+    public int compareTo(GershgorinCirclesUnion other) {\n+        return Double.compare(low, other.low);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class EigenDecompositionImplTest extends TestCase {\n+\n+    private double[] refValues;\n+    private RealMatrix matrix;\n+\n+    private static final double normTolerance = 1.e-10;\n+\n+    public EigenDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EigenDecompositionImplTest.class);\n+        suite.setName(\"EigenDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        final int m = matrix.getRowDimension();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(m, ed.getV().getRowDimension());\n+        assertEquals(m, ed.getV().getColumnDimension());\n+        assertEquals(m, ed.getD().getColumnDimension());\n+        assertEquals(m, ed.getD().getColumnDimension());\n+        assertEquals(m, ed.getVT().getRowDimension());\n+        assertEquals(m, ed.getVT().getColumnDimension());\n+    }\n+\n+    /** test eigenvalues */\n+    public void testEigenvalues() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        double[] eigenValues = ed.getEigenvalues();\n+        assertEquals(refValues.length, eigenValues.length);\n+        for (int i = 0; i < refValues.length; ++i) {\n+            assertEquals(refValues[i], eigenValues[eigenValues.length - 1 - i], 3.0e-15);\n+        }\n+    }\n+\n+    /** test eigenvectors */\n+    public void testEigenvectors() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        for (int i = 0; i < matrix.getRowDimension(); ++i) {\n+            double lambda = ed.getEigenvalue(i);\n+            RealVector v  = ed.getEigenvector(i);\n+            RealVector mV = matrix.operate(v);\n+            assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);\n+        }\n+    }\n+\n+    /** test A = VDVt */\n+    public void testAEqualVDVt() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        RealMatrix v  = ed.getV();\n+        RealMatrix d  = ed.getD();\n+        RealMatrix vT = ed.getVT();\n+        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test that V is orthogonal */\n+    public void testVOrthogonal() {\n+        RealMatrix v = new EigenDecompositionImpl(matrix).getV();\n+        RealMatrix vTv = v.transpose().multiply(v);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n+        assertEquals(0, vTv.subtract(id).getNorm(), normTolerance);\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            ed.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            ed.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            ed.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        RealMatrix m = new RealMatrixImpl(new double[][] {\n+                { 91,  5, 29, 32, 40, 14 },\n+                {  5, 34, -1,  0,  2, -1 },\n+                { 29, -1, 12,  9, 21,  8 },\n+                { 32,  0,  9, 14,  9,  0 },\n+                { 40,  2, 21,  9, 51, 19 },\n+                { 14, -1,  8,  0, 19, 14 }\n+        });\n+        EigenDecomposition ed = new EigenDecompositionImpl(m);\n+        assertEquals(184041, ed.getDeterminant(), 2.0e-8);\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1561, 269, 188 },\n+                {   69, -21,  70 },\n+                {  739, 108,  63 },\n+                {  324,  86,  59 },\n+                { 1624, 194, 107 },\n+                {  796,  69,  36 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 1,   2, 1 },\n+                { 2,  -1, 2 },\n+                { 4,   2, 3 },\n+                { 8,  -1, 0 },\n+                { 16,  2, 0 },\n+                { 32, -1, 0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, ed.solve(b).subtract(xRef).getNorm(), normTolerance);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(ed.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using RealMatrixImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         ed.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using RealMatrix with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         ed.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+    }\n+\n+    public void setUp() {\n+        refValues = new double[] {\n+                2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n+        };\n+        matrix = createTestMatrix(new Random(35992629946426l), refValues);\n+    }\n+\n+    public void tearDown() {\n+        refValues = null;\n+        matrix    = null;\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {\n+        final RealMatrix v = createOrthogonalMatrix(r, eigenValues.length);\n+        final RealMatrix d = createDiagonalMatrix(eigenValues, eigenValues.length);\n+        return v.multiply(d).multiply(v.transpose());\n+    }\n+\n+    private RealMatrix createOrthogonalMatrix(final Random r, final int size) {\n+        final double[][] data = new double[size][size];\n+        for (int i = 0; i < size; ++i) {\n+            for (int j = 0; j < size; ++j) {\n+                data[i][j] = 2 * r.nextDouble() - 1;\n+            }\n+        }\n+        final RealMatrix m = new RealMatrixImpl(data, false);\n+        return new QRDecompositionImpl(m).getQ();\n+    }\n+\n+    private RealMatrix createDiagonalMatrix(final double[] data, final int rows) {\n+        final double[][] dData = new double[rows][rows];\n+        for (int i = 0; i < data.length; ++i) {\n+            dData[i][i] = data[i];\n+        }\n+        return new RealMatrixImpl(dData, false);\n+    }\n+\n+}", "timestamp": 1223246293, "metainfo": ""}