{"sha": "e2d7bfa1626c1dd1bee8369103198512f70f6ea4", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20496 Submitted by:\tAlbert Davidson Chou   ", "commit": "\n--- a/src/java/org/apache/commons/math/MathUtils.java\n+++ b/src/java/org/apache/commons/math/MathUtils.java\n  * 2. Redistributions in binary form must reproduce the above copyright\n  *    notice, this list of conditions and the following disclaimer in\n  *    the documentation and/or other materials provided with the\n- *    distribution. \n+ *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n  *    any, must include the following acknowlegement:\n  * Some useful additions to the built-in functions in lang.Math<p>\n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.1 $ $Date: 2003/06/04 02:31:13 $\n+ * @version $Revision: 1.2 $ $Date: 2003/06/06 03:07:39 $\n  */\n public class MathUtils {\n \n     /**\n-     * Returns an exact representation of the \n-     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> \n-     * Binomial Coefficient</a>,  \"<code>n choose k</code>\", \n-     * the number of <code>k</code>-element subsets that can be selected from \n-     * an <code>n</code>-element set.\n-     * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n-     * <li> <code>0 < k <= n </code> (otherwise \n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>long</code>.  The \n-     *      largest value of <code>n</code> for which all coefficients are \n-     *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value \n-     *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n-     *      </code> is thrown.</li>\n-     * </ul>\n-     * \n-     * @param n the size of the set\n-     * @param k the size of the subsets to be counted\n-     * @return <code>n choose k</code>\n-     */\n+     * For a double precision value x, this method returns +1.0 if x >= 0\n+     * and -1.0 if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a double\n+     * @return +1.0 or -1.0, depending on the the sign of x\n+     */\n+    public static double sign( double x ) {\n+        if ( x >= 0.0 ) {\n+            return 1.0 ;\n+        } else {\n+            return -1.0 ;\n+        }\n+    }\n+\n+    /**\n+     * For a float value x, this method returns +1.0F if x >= 0\n+     * and -1.0F if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a float\n+     * @return +1.0F or -1.0F, depending on the the sign of x\n+     */\n+    public static float sign( float x ) {\n+        if ( x >= 0.0F ) {\n+            return 1.0F ;\n+        } else {\n+            return -1.0F ;\n+        }\n+    }\n+\n+    /**\n+     * For a byte value x, this method returns (byte)(+1) if x >= 0\n+     * and (byte)(-1) if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a byte\n+     * @return (byte)(+1) or (byte)(-1), depending on the the sign of x\n+     */\n+    public static byte sign( byte x ) {\n+        if ( x >= (byte)0 ) {\n+            return (byte)1 ;\n+        } else {\n+            return (byte)(-1) ;\n+        }\n+    }\n+\n+    /**\n+     * For a short value x, this method returns (short)(+1) if x >= 0\n+     * and (short)(-1) if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a short\n+     * @return (short)(+1) or (short)(-1), depending on the the sign of x\n+     */\n+    public static short sign( short x ) {\n+        if ( x >= (short)0 ) {\n+            return (short)1 ;\n+        } else {\n+            return (short)(-1) ;\n+        }\n+    }\n+\n+    /**\n+     * For an int value x, this method returns +1 if x >= 0\n+     * and -1 if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, an int\n+     * @return +1 or -1, depending on the the sign of x\n+     */\n+    public static int sign( int x ) {\n+        if ( x >= 0 ) {\n+            return 1 ;\n+        } else {\n+            return -1 ;\n+        }\n+    }\n+ \n+    /**\n+     * For a long value x, this method returns +1L if x >= 0\n+     * and -1L if x < 0.\n+     *\n+     * @author Albert Davidson Chou\n+     * @param x the value, a long\n+     * @return +1L or -1L, depending on the the sign of x\n+     */\n+    public static long sign( long x ) {\n+        if ( x >= 0L ) {\n+            return 1L ;\n+        } else {\n+            return -1L ;\n+        }\n+    }\n+   /**\n+    * Returns an exact representation of the\n+    * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n+    * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n+    * the number of <code>k</code>-element subsets that can be selected from\n+    * an <code>n</code>-element set.\n+    * <p>\n+    * <Strong>Preconditions</strong>:<ul>\n+    * <li> <code>0 < k <= n </code> (otherwise \n+    * <li> <code>0 < k <= n </code> (otherwise\n+    *      <code>IllegalArgumentException</code> is thrown)</li>\n+    * <li> The result is small enough to fit into a <code>long</code>.  The \n+    *      largest value of <code>n</code> for which all coefficients are \n+    *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value \n+    * <li> The result is small enough to fit into a <code>long</code>.  The\n+    *      largest value of <code>n</code> for which all coefficients are\n+    *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n+    *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n+    *      </code> is thrown.</li>\n+    * </ul>\n+    * \n+    *\n+    * @param n the size of the set\n+    * @param k the size of the subsets to be counted\n+    * @return <code>n choose k</code>\n+    */\n     public static long binomialCoefficient(int n, int k) {     \n         if (n < k) {\n             throw new IllegalArgumentException\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n-        \n+\n         long result = Math.round(binomialCoefficientDouble(n, k));\n         if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException\n                 (\"result too large to represent in a long integer\");\n         }\n-        return result;   \n-    } \n-    \n-    /**\n-     * Returns a <code>double</code> representation of the \n-     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> \n-     * Binomial Coefficient</a>,  \"<code>n choose k</code>\", \n-     * the number of <code>k</code>-element subsets that can be selected from \n+        return result;\n+    }\n+\n+    /**\n+     * Returns a <code>double</code> representation of the\n+     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n+     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n+     * the number of <code>k</code>-element subsets that can be selected from\n      * an <code>n</code>-element set.\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n-     * <li> <code>0 < k <= n </code> (otherwise \n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>double</code>.  \n-     *      The largest value of <code>n</code> for which all coefficients are \n-     *      < Double.MAX_VALUE is 1029.  If the computed value exceeds \n+     * <li> <code>0 < k <= n </code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>.\n+     *      The largest value of <code>n</code> for which all coefficients are\n+     *      < Double.MAX_VALUE is 1029.  If the computed value exceeds\n      *      Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n      * </ul>\n-     * \n+     *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n      */\n-    public static double binomialCoefficientDouble(int n, int k) {  \n-        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + .5);    \n-    }\n-    \n+    public static double binomialCoefficientDouble(int n, int k) {\n+        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + .5);\n+    }\n+\n     /**\n      * Returns the natural <code>log</code> of the\n-     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> \n-     * Binomial Coefficient</a>,  \"<code>n choose k</code>\", \n-     * the number of <code>k</code>-element subsets that can be selected from \n+     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n+     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n+     * the number of <code>k</code>-element subsets that can be selected from\n      * an <code>n</code>-element set.\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n-     * <li> <code>0 < k <= n </code> (otherwise \n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * </ul>\n-     * \n+     * <li> <code>0 < k <= n </code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * </ul>\n+     *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n         }\n         if ((k == 1) || (k == n - 1)) {\n             return Math.log((double) n);\n-        }    \n-        double logSum = 0; \n-        \n+        }\n+        double logSum = 0;\n+\n         // n!/k!\n         for (int i = k + 1; i <= n; i++) {\n             logSum += Math.log((double) i);\n         }\n-        \n+\n         // divide by (n-k)!\n         for (int i = 2; i <= n - k; i++) {\n             logSum -= Math.log((double) i);\n         }\n-        \n+\n         return logSum;\n     }\n-    \n+\n     /**\n      * Returns <code>n</code>\n-     * <a href=\"http://mathworld.wolfram.com/Factorial.html\"> \n-     * Factorial</a>, or <code>n!</code>,  \n+     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * Factorial</a>, or <code>n!</code>,\n      * the product of the numbers <code>1,...,n</code>.\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n-     * <li> <code>n > 0</code> (otherwise \n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>long</code>.  The \n-     *      largest value of <code>n</code> for which <code>n!</code> \n-     *      < Long.MAX_VALUE</code> is 20.  If the computed value \n+     * <li> <code>n > 0</code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>long</code>.  The\n+     *      largest value of <code>n</code> for which <code>n!</code>\n+     *      < Long.MAX_VALUE</code> is 20.  If the computed value\n      *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n      *      </code> is thrown.</li>\n      * </ul>\n-     * \n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      */\n             throw new ArithmeticException\n                 (\"result too large to represent in a long integer\");\n         }\n-        return result;  \n-    }\n-    \n+        return result;\n+    }\n+\n     /**\n      * Returns <code>n</code>\n-     * <a href=\"http://mathworld.wolfram.com/Factorial.html\"> \n-     * Factorial</a>, or <code>n!</code>,  \n-     * the product of the numbers <code>1,...,n</code>, as as \n+     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * Factorial</a>, or <code>n!</code>,\n+     * the product of the numbers <code>1,...,n</code>, as as\n      * <code>double</code>.\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n-     * <li> <code>n > 0</code> (otherwise \n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>double</code>.  The \n-     *      largest value of <code>n</code> for which <code>n!</code> \n-     *      < Double.MAX_VALUE</code> is 170.  If the computed value exceeds \n+     * <li> <code>n > 0</code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>.  The\n+     *      largest value of <code>n</code> for which <code>n!</code>\n+     *      < Double.MAX_VALUE</code> is 170.  If the computed value exceeds\n      *      Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n      * </ul>\n-     * \n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      */\n             throw new IllegalArgumentException\n                 (\"must have n > 0 for n!\");\n         }\n-        return Math.floor(Math.exp(factorialLog(n)) + 0.5); \n-    }\n-    \n+        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+    }\n+\n    /**\n      * Returns the natural <code>log</code> of <code>n</code>\n-     * <a href=\"http://mathworld.wolfram.com/Factorial.html\"> \n-     * Factorial</a>, or <code>n!</code>,  \n-     * the product of the numbers <code>1,...,n</code>, as as \n+     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * Factorial</a>, or <code>n!</code>,\n+     * the product of the numbers <code>1,...,n</code>, as as\n      * <code>double</code>.\n      * <p>\n      * <Strong>Preconditions</strong>:<ul>\n-     * <li> <code>n > 0</code> (otherwise \n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * </ul>\n-     * \n+     * <li> <code>n > 0</code> (otherwise\n+     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * </ul>\n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      */\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double) i);\n-        }   \n+        }\n         return logSum;\n-    }           \n+    }\n }\n--- a/src/test/org/apache/commons/math/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/MathUtilsTest.java\n  * 2. Redistributions in binary form must reproduce the above copyright\n  *    notice, this list of conditions and the following disclaimer in\n  *    the documentation and/or other materials provided with the\n- *    distribution. \n+ *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n  *    any, must include the following acknowlegement:\n  * Test cases for the MathUtils class.\n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.1 $ $Date: 2003/06/04 02:31:14 $\n+ * @version $Revision: 1.2 $ $Date: 2003/06/06 03:07:39 $\n  */\n \n public final class MathUtilsTest extends TestCase {\n \n     public MathUtilsTest(String name) {\n         super(name);\n-    }   \n-    \n-    public void setUp() { \n+    }\n+\n+    public void setUp() {\n     }\n \n     public static Test suite() {\n             ;\n         }\n         double x = MathUtils.binomialCoefficientDouble(1030,515);\n-        assertTrue(\"expecting infinite binomial coefficient\", \n+        assertTrue(\"expecting infinite binomial coefficient\",\n             Double.isInfinite(x));\n     }\n-    \n+\n     public void testFactorial() {\n         for (int i = 1; i < 10; i++) {\n             assertEquals(i + \"! \",factorial(i),MathUtils.factorial(i));\n                 MathUtils.factorialLog(i),10E-12);\n         }\n     }\n-    \n+\n     public void testFactorialFail() {\n         try {\n             long x = MathUtils.factorial(0);\n         } catch (ArithmeticException ex) {\n             ;\n         }\n-        assertTrue(\"expecting infinite factorial value\", \n+        assertTrue(\"expecting infinite factorial value\",\n             Double.isInfinite(MathUtils.factorialDouble(171)));\n-        \n-    }\n-   \n-    \n-    /** \n+\n+    }\n+\n+\n+    /**\n      * Exact recursive implementation to test against\n      */\n-    private long binomialCoefficient(int n, int k) {     \n+    private long binomialCoefficient(int n, int k) {\n         if ((n == k) || (k == 0)) {\n             return 1;\n         }\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n-        return binomialCoefficient(n - 1, k - 1) + \n+        return binomialCoefficient(n - 1, k - 1) +\n             binomialCoefficient(n - 1, k);\n-    } \n-    \n+    }\n+\n     /**\n      * Finds the largest values of n for which binomialCoefficient and\n      * binomialCoefficientDouble will return values that fit in a long, double,\n             findBinomialLimits();\n         }\n      */\n-    \n+\n     private void findBinomialLimits() {\n         /**\n          * will kick out 66 as the limit for long\n                     (\"largest n for binomialCoefficient = \" + (test - 1) );\n             }\n             test++;\n-        }     \n-        \n+        }\n+\n        /**\n         * will kick out 1029 as the limit for double\n         */\n                     (\"largest n for binomialCoefficientD = \" + (test - 1) );\n             }\n             test++;\n-        } \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Finds the largest values of n for which factiorial and\n      * factorialDouble will return values that fit in a long, double,\n      * resp.  Remove comments around test below to get this in test-report\n-     \n+\n         public void testFactiorialLimits() {\n             findFactorialLimits();\n         }\n      */\n-    \n+\n     private void findFactorialLimits() {\n         /**\n          * will kick out 20 as the limit for long\n                     (\"largest n for factorial = \" + (test - 1) );\n             }\n             test++;\n-        }     \n-        \n+        }\n+\n        /**\n         * will kick out 170 as the limit for double\n         */\n                     (\"largest n for factorialDouble = \" + (test - 1) );\n             }\n             test++;\n-        } \n-    }\n-    \n-    \n-    /** \n+        }\n+    }\n+\n+\n+    /**\n      * Exact direct multiplication implementation to test against\n      */\n-    private long factorial(int n) {     \n+    private long factorial(int n) {\n         long result = 1;\n         for (int i = 2; i <= n; i++) {\n             result *= i;\n         }\n         return result;\n-    } \n- \n-        \n-\n+    }\n+\n+\n+    public void testSignDouble() {\n+        double delta = 0.0 ;\n+        assertEquals( 1.0, MathUtils.sign( 2.0 ), delta ) ;\n+        assertEquals( -1.0, MathUtils.sign( -2.0 ), delta ) ;\n+    }\n+\n+\n+    public void testSignFloat() {\n+        float delta = 0.0F ;\n+        assertEquals( 1.0F, MathUtils.sign( 2.0F ), delta ) ;\n+        assertEquals( -1.0F, MathUtils.sign( -2.0F ), delta ) ;\n+    }\n+\n+\n+    public void testSignByte() {\n+        assertEquals( (byte)1, MathUtils.sign( (byte)2 ) ) ;\n+        assertEquals( (byte)(-1), MathUtils.sign( (byte)(-2) ) ) ;\n+    }\n+\n+\n+    public void testSignShort() {\n+        assertEquals( (short)1, MathUtils.sign( (short)2 ) ) ;\n+        assertEquals( (short)(-1), MathUtils.sign( (short)(-2) ) ) ;\n+    }\n+\n+\n+    public void testSignInt() {\n+        assertEquals( (int)1, MathUtils.sign( (int)(2) ) ) ;\n+        assertEquals( (int)(-1), MathUtils.sign( (int)(-2) ) ) ;\n+    }\n+\n+\n+    public void testSignLong() {\n+        assertEquals( 1L, MathUtils.sign( 2L ) ) ;\n+        assertEquals( -1L, MathUtils.sign( -2L ) ) ;\n+    }\n }", "timestamp": 1054868859, "metainfo": ""}