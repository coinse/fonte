{"sha": "ad6929ea0c89c085422c1e43bb3f763a0e3d25e4", "log": "Merged changes in MATH_1_1 branch to trunk.  This includes revision 232577 through revision 234481.  ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n         if (isNaN()) {\n             return Double.NaN;\n         }\n-        return Math.sqrt(squareSum());       \n+        if (Math.abs(real) < Math.abs(imaginary)) {\n+            if (imaginary == 0.0) {\n+                return Math.abs(real);\n+            }\n+            double q = real / imaginary;\n+            return (Math.abs(imaginary) * Math.sqrt(1 + q*q));\n+        } else {\n+            if (real == 0.0) {\n+                return Math.abs(imaginary);\n+            }\n+            double q = imaginary / real;\n+            return (Math.abs(real) * Math.sqrt(1 + q*q));\n+        }\n     }\n     \n     /**\n         if (isNaN() || rhs.isNaN()) {\n             return NaN;\n         }\n-        \n-        if (Math.abs(rhs.getReal()) < Math.abs(rhs.getImaginary())) {\n-            double q = rhs.getReal() / rhs.getImaginary();\n-            double d = (rhs.getReal() * q) + rhs.getImaginary();\n-            return new Complex(((real * q) + imaginary) / d,\n-                ((imaginary * q) - real) / d);\n+\n+        double c = rhs.getReal();\n+        double d = rhs.getImaginary();\n+        if (c == 0.0 && d == 0.0) {\n+            throw new ArithmeticException(\"Error: division by zero.\");\n+        }\n+\n+        if (Math.abs(c) < Math.abs(d)) {\n+            if (d == 0.0) {\n+                return new Complex(real/c, imaginary/c);\n+            }\n+            double q = c / d;\n+            double denominator = c * q + d;\n+            return new Complex((real * q + imaginary) / denominator,\n+                (imaginary * q - real) / denominator);\n         } else {\n-            double q = rhs.getImaginary() / rhs.getReal();\n-            double d = (rhs.getImaginary() * q) + rhs.getReal();\n-            return new Complex(((imaginary * q) + real) / d,\n-                (imaginary - (real * q)) / d);\n+            if (c == 0.0) {\n+                return new Complex(imaginary/d, -real/c);\n+            }\n+            double q = d / c;\n+            double denominator = d * q + c;\n+            return new Complex((imaginary * q + real) / denominator,\n+                (imaginary - real * q) / denominator);\n         }\n     }\n     \n     }\n     \n     /**\n-     * Return the sum of the squared terms.\n-     *\n-     * @return the square sum.\n-     */\n-    private double squareSum() {\n-        return real * real + imaginary * imaginary;\n-    }\n-    \n-    /**\n      * Return the difference between this complex number and the given complex\n      * number.\n      *\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n         super();\n         if (numberOfSuccesses > populationSize) {\n             throw new IllegalArgumentException(\n-            \"number of successes must be less than or equal to population size\");\n+            \t\"number of successes must be less than or equal to \" +\n+            \t\"population size\");\n         }\n         if (sampleSize > populationSize) {\n             throw new IllegalArgumentException(\n      * For this disbution, X, this method returns P(X &le; x).\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(int x) throws MathException{\n+     */\n+    public double cumulativeProbability(int x) {\n         double ret;\n         \n         int n = getPopulationSize();\n             ret = 0.0;\n         } else if(x >= domain[1]) {\n             ret = 1.0;\n+        } else if (x - domain[0] < domain[1] - x) {\n+            ret = lowerCumulativeProbability(domain[0], x, n, m, k);\n         } else {\n-            ret = 0.0;\n-            for (int i = domain[0]; i <= x; ++i){\n-                ret += probability(n, m, k, i);\n-            }\n+        \tret = 1.0 - upperCumulativeProbability(x + 1, domain[1], n, m, k);\n         }\n         \n         return ret;\n     }\n \n     /**\n+     * For this disbution, X, this method returns P(x0 &le; X &le; x1).  This\n+     * probability is computed by summing the point probabilities for the values\n+     * x0, x0 + 1, x0 + 2, ..., x1, in that order. \n+     * @param x0 the inclusive, lower bound\n+     * @param x1 the inclusive, upper bound\n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return P(x0 &le; X &le; x1). \n+     */\n+    private double lowerCumulativeProbability(\n+        int x0, int x1, int n, int m, int k)\n+    {\n+\t\tdouble ret;\n+\t\tret = 0.0;\n+\t\tfor (int i = x0; i <= x1; ++i) {\n+\t\t\tret += probability(n, m, k, i);\n+\t\t}\n+\t\treturn ret;\n+\t}\n+\n+    /**\n      * For this disbution, X, this method returns P(X = x).\n      * \n      * @param x the value at which the PMF is evaluated.\n         \n         return ret;\n     }\n-\n+    \n     /**\n      * For the disbution, X, defined by the given hypergeometric distribution\n      * parameters, this method returns P(X = x).\n             MathUtils.binomialCoefficientLog(n - m, k - x) -\n             MathUtils.binomialCoefficientLog(n, k));\n     }\n-    \n+\n     /**\n      * Modify the number of successes.\n      * @param num the new number of successes.\n         }\n         populationSize = size;\n     }\n-\n-    /**\n+    \n+\t/**\n      * Modify the sample size.\n      * @param size the new sample size.\n      * @throws IllegalArgumentException if <code>size</code> is negative.\n         }    \n         sampleSize = size;\n     }\n+\n+    /**\n+     * For this disbution, X, this method returns P(X &ge; x).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return upper tail CDF for this distribution. \n+     */\n+\tpublic double upperCumulativeProbability(int x) {\n+    \tdouble ret;\n+    \t\n+        int n = getPopulationSize();\n+        int m = getNumberOfSuccesses();\n+        int k = getSampleSize();\n+\n+        int[] domain = getDomain(n, m, k);\n+        if (x < domain[0]) {\n+            ret = 1.0;\n+        } else if(x >= domain[1]) {\n+            ret = 0.0;\n+        } else if (x - domain[0] < domain[1] - x) {\n+        \tret = 1.0 - lowerCumulativeProbability(domain[0], x - 1, n, m, k);\n+        } else {\n+        \tret = upperCumulativeProbability(x, domain[1], n, m, k);\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * For this disbution, X, this method returns P(x0 &le; X &le; x1).  This\n+     * probability is computed by summing the point probabilities for the values\n+     * x1, x1 - 1, x1 - 2, ..., x0, in that order. \n+     * @param x0 the inclusive, lower bound\n+     * @param x1 the inclusive, upper bound\n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return P(x0 &le; X &le; x1). \n+     */\n+    private double upperCumulativeProbability(\n+    \tint x0, int x1, int n, int m, int k)\n+    {\n+    \tdouble ret = 0.0;\n+    \tfor (int i = x1; i >= x0; --i) {\n+    \t\tret += probability(n, m, k, i);\n+    \t}\n+\t\treturn ret;\n+\t}\n+\n }\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 0.0;\n-        } else if (a > 1.0 && x > a) {\n+        } else if (a >= 1.0 && x > a) {\n             // use regularizedGammaQ because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 1.0;\n-        } else if (x < a || a <= 1.0) {\n+        } else if (x < a || a < 1.0) {\n             // use regularizedGammaP because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n         double sum2 = 0d;\n         double diff = 0d;\n         int n = sample1.length;\n-        if (n < 2) {\n-            throw new IllegalArgumentException(\"Input array lengths must be at least 2.\");\n+        if (n < 2 || n != sample2.length) {\n+            throw new IllegalArgumentException(\"Input array lengths must be equal and at least 2.\");\n         }\n         for (int i = 0; i < n; i++) {\n             diff = sample1[i] - sample2[i];\n--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n     }\n \n     /**\n+     * <p>\n      * Evaluates the continued fraction at the value x.\n+     * </p>\n      * \n-     * The implementation of this method is based on:\n+     * <p>\n+     * The implementation of this method is based on equations 14-17 of:\n      * <ul>\n-     * <li>O. E-gecio-glu, C . K. Koc, J. Rifa i Coma,\n-     * <a href=\"http://citeseer.ist.psu.edu/egecioglu91fast.html\">\n-     * On Fast Computation of Continued Fractions</a>, Computers Math. Applic.,\n-     * 21(2--3), 1991, 167--169.</li>\n+     * <li>\n+     *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n+     *   Resource. <a target=\"_blank\"\n+     *   href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     *   http://mathworld.wolfram.com/ContinuedFraction.html</a>\n+     * </li>\n      * </ul>\n-     * \n+     * The recurrence relationship defined in those equations can result in\n+     * very large intermediate results which can result in numerical overflow.\n+     * As a means to combat these overflow conditions, the intermediate results\n+     * are scaled whenever they threaten to become numerically unstable.\n+     *   \n      * @param x the evaluation point.\n      * @param epsilon maximum error allowed.\n      * @param maxIterations maximum number of convergents\n     public double evaluate(double x, double epsilon, int maxIterations)\n         throws MathException\n     {\n-        double[][] f = new double[2][2];\n-        double[][] a = new double[2][2];\n-        double[][] an = new double[2][2];\n+    \tdouble p0 = 1.0;\n+    \tdouble p1 = getA(0, x);\n+    \tdouble q0 = 0.0;\n+    \tdouble q1 = 1.0;\n+    \tdouble c = p1 / q1;\n+    \tint n = 0;\n+    \tdouble relativeError = Double.MAX_VALUE;\n+    \twhile (n < maxIterations && relativeError > epsilon) {\n+    \t\t++n;\n+    \t\tdouble a = getA(n, x);\n+    \t\tdouble b = getB(n, x);\n+  \t\t\tdouble p2 = a * p1 + b * p0;\n+   \t\t\tdouble q2 = a * q1 + b * q0;\n+   \t\t\tif (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n+   \t\t\t\t// need to scale\n+   \t\t\t\tif (a != 0.0) {\n+   \t\t\t\t\tp2 = p1 + (b / a * p0);\n+   \t\t\t\t\tq2 = q1 + (b / a * q0);\n+   \t\t\t\t} else if (b != 0) {\n+   \t\t\t\t\tp2 = (a / b * p1) + p0;\n+   \t\t\t\t\tq2 = (a / b * q1) + q0;\n+   \t\t\t\t} else {\n+   \t\t\t\t\t// can not scale an convergent is unbounded.\n+   \t\t            throw new ConvergenceException(\n+   \t                \t\"Continued fraction convergents diverged to +/- \" +\n+   \t                \t\"infinity.\");\n+   \t\t\t\t}\n+   \t\t\t}\n+   \t\t\tdouble r = p2 / q2;\n+   \t\t\trelativeError = Math.abs(r / c - 1.0);\n+    \t\t\t\n+   \t\t\t// prepare for next iteration\n+   \t\t\tc = p2 / q2;\n+   \t\t\tp0 = p1;\n+   \t\t\tp1 = p2;\n+   \t\t\tq0 = q1;\n+   \t\t\tq1 = q2;\n+    \t}\n \n-        a[0][0] = getA(0, x);\n-        a[0][1] = 1.0;\n-        a[1][0] = 1.0;\n-        a[1][1] = 0.0;\n-\n-        return evaluate(1, x, a, an, f, epsilon, maxIterations);\n-    }\n-\n-    /**\n-     * Evaluates the n-th convergent, fn = pn / qn, for this continued fraction\n-     * at the value x.\n-     * @param n the convergent to compute.\n-     * @param x the evaluation point.\n-     * @param a (n-1)-th convergent matrix.  (Input)\n-     * @param an the n-th coefficient matrix. (Output)\n-     * @param f the n-th convergent matrix. (Output)\n-     * @param epsilon maximum error allowed.\n-     * @param maxIterations maximum number of convergents\n-     * @return the value of the the n-th convergent for this continued fraction\n-     *         evaluated at x. \n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    private double evaluate(\n-        int n,\n-        double x,\n-        double[][] a,\n-        double[][] an,\n-        double[][] f,\n-        double epsilon,\n-        int maxIterations) throws MathException \n-    {\n-        double ret;\n-\n-        // create next matrix\n-        an[0][0] = getA(n, x);\n-        an[0][1] = 1.0;\n-        an[1][0] = getB(n, x);\n-        an[1][1] = 0.0;\n-\n-        // multiply a and an, save as f\n-        f[0][0] = (a[0][0] * an[0][0]) + (a[0][1] * an[1][0]);\n-        f[0][1] = (a[0][0] * an[0][1]) + (a[0][1] * an[1][1]);\n-        f[1][0] = (a[1][0] * an[0][0]) + (a[1][1] * an[1][0]);\n-        f[1][1] = (a[1][0] * an[0][1]) + (a[1][1] * an[1][1]);\n-\n-        // determine if we're close enough\n-        if (Math.abs((f[0][0] * f[1][1]) - (f[1][0] * f[0][1])) <\n-            Math.abs(epsilon * f[1][0] * f[1][1]))\n-        {\n-            ret = f[0][0] / f[1][0];\n-        } else {\n-            if (n >= maxIterations) {\n-                throw new ConvergenceException(\n-                    \"Continued fraction convergents failed to converge.\");\n-            }\n-            // compute next\n-            ret = evaluate(n + 1, x, f /* new a */\n-            , an /* reuse an */\n-            , a /* new f */\n-            , epsilon, maxIterations);\n+    \tif (n >= maxIterations) {\n+            throw new ConvergenceException(\n+                \"Continued fraction convergents failed to converge.\");\n         }\n \n-        return ret;\n+        return c;\n     }\n }\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n /*\n- * Copyright 2003-2005 The Apache Software Foundation. Licensed under the Apache\n- * License, Version 2.0 (the \"License\"); you may not use this file except in\n- * compliance with the License. You may obtain a copy of the License at\n- * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n- * or agreed to in writing, software distributed under the License is\n- * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the specific language\n- * governing permissions and limitations under the License.\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n \n package org.apache.commons.math.util;\n \n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n- * \n- * @version $Revision$ $Date: 2005-07-30 02:25:26 -0500 (Sat, 30 Jul\n- *          2005) $\n+ * @version $Revision$ $Date$\n  */\n public final class MathUtils {\n \n      * @since 1.1\n      */\n     public static double round(double x, int scale, int roundingMethod) {\n-        double sign = sign(x);\n+        double sign = indicator(x);\n         double factor = Math.pow(10.0, scale) * sign;\n         return roundUnscaled(x * factor, sign, roundingMethod) / factor;\n     }\n      * @since 1.1\n      */\n     public static float round(float x, int scale, int roundingMethod) {\n-        float sign = sign(x);\n+        float sign = indicator(x);\n         float factor = (float)Math.pow(10.0f, scale) * sign;\n         return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n     }\n--- a/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/PoissonDistributionTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n \n /**\n  * <code>PoissonDistributionTest</code>\n         dist.setMean(10.0);\n         assertEquals(10.0, dist.getMean(), 0.0);\n     }\n+    \n+    public void testLargeMeanCumulativeProbability() {\n+    \tPoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);\n+    \tdouble mean = 1.0;\n+    \twhile (mean <= 10000000.0) {\n+    \t\tdist.setMean(mean);\n+    \t\t\n+    \t\tdouble x = mean * 2.0;\n+    \t\tdouble dx = x / 10.0;\n+    \t\twhile (x >= 0) {\n+    \t\t\ttry {\n+    \t\t\t\tdist.cumulativeProbability(x);\n+    \t\t\t} catch (MathException ex) {\n+    \t\t\t\tfail(\"mean of \" + mean + \" and x of \" + x + \" caused \" + ex.getMessage());\n+    \t\t\t}\n+\t\t\t\tx -= dx;\n+    \t\t}\n+    \t\t\n+    \t\tmean *= 10.0;\n+    \t}\n+    }\n+    \n+    public void testLargeMeanInverseCumulativeProbability() {\n+    \tPoissonDistribution dist = DistributionFactory.newInstance().createPoissonDistribution(1.0);\n+    \tdouble mean = 1.0;\n+    \twhile (mean <= 10000000.0) {\n+    \t\tdist.setMean(mean);\n+    \t\t\n+    \t\tdouble p = 0.1;\n+    \t\tdouble dp = p;\n+    \t\twhile (p < 1.0) {\n+    \t\t\ttry {\n+    \t\t\t\tdist.inverseCumulativeProbability(p);\n+    \t\t\t} catch (MathException ex) {\n+    \t\t\t\tfail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n+    \t\t\t}\n+\t\t\t\tp += dp;\n+    \t\t}\n+    \t\t\n+    \t\tmean *= 10.0;\n+    \t}\n+    }\n }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n         RealMatrix lu = m.getLUMatrix();\n         assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);\n         verifyDecomposition(m, lu);\n+        // access LU decomposition on same object to verify caching.\n+        lu = m.getLUMatrix();\n+        assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);\n+        verifyDecomposition(m, lu);\n+\n         m = new RealMatrixImpl(luData);\n         lu = m.getLUMatrix();\n         assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(luDataLUDecomposition), normTolerance);\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n         \n         // null\n         try {\n--- a/src/test/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/org/apache/commons/math/stat/FrequencyTest.java\n import java.io.IOException;\n import java.io.StringReader;\n import java.util.Iterator;\n+\n+import org.apache.commons.math.TestUtils;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n         assertEquals(\"one count\", 3 ,  f.getCount(\"one\"));\n         assertEquals(\"Z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"Z\"), tolerance);\n         assertEquals(\"z cumulative pct -- case insensitive\", 1 ,  f.getCumPct(\"z\"), tolerance);\n+        \n+        f = null;\n+        f = new Frequency();\n+        assertEquals(0L, f.getCount('a'));\n+        assertEquals(0L, f.getCumFreq('b'));\n+        TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0);\n+        TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0);\n+        f.addValue('a');\n+        f.addValue('b');\n+        f.addValue('c');\n+        f.addValue('d');\n+        assertEquals(1L, f.getCount('a'));\n+        assertEquals(2L, f.getCumFreq('b'));\n+        assertEquals(0.25, f.getPct('a'), 0.0);\n+        assertEquals(0.5, f.getCumPct('b'), 0.0);\n     }     \n     \n     /** test pcts */\n--- a/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/StatUtilsTest.java\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n+        try {\n+            StatUtils.varianceDifference(sample1, small, meanDifference);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+        \tdouble[] single = {1.0};\n+            StatUtils.varianceDifference(single, single, meanDifference);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n     }\n     \n     public void testGeometricMean() throws Exception {\n         test = new double[] {2, 4, 6, 8};\n         assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)), \n                 StatUtils.geometricMean(test), Double.MIN_VALUE);\n+        assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)), \n+                StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);\n     }\n }\n--- a/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n         assertEquals(3.75, p.evaluate(d), 1.0e-5);\n         p.setQuantile(50);\n         assertEquals(2.5, p.evaluate(d), 1.0e-5);\n+        \n+        // invalid percentiles\n+        try {\n+        \tp.evaluate(d, 0, d.length, -1.0);\n+        \tfail();\n+        } catch (IllegalArgumentException ex) {\n+        \t// success\n+        }\n+        try {\n+        \tp.evaluate(d, 0, d.length, 101.0);\n+        \tfail();\n+        } catch (IllegalArgumentException ex) {\n+        \t// success\n+        }\n     }\n     \n     public void testNISTExample() {\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n \n import java.math.BigDecimal;\n \n+import org.apache.commons.math.TestUtils;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n+        \n+        // special values\n+        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);\n+        assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);\n+        assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n+        assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n     }\n     \n     public void testRoundDouble() {\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n+        \n+        // special values\n+        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);\n+        assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);\n+        assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);\n+        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);\n     }\n }", "timestamp": 1124764037, "metainfo": ""}