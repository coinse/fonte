{"sha": "fc024205650fd286f407da7fa40cba524a15f7ae", "log": "MATH-471 MathUtils.equals(double, double) does not work properly for floats - add equivalent (float, float) methods and basic tests  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     /** Offset to order signed double numbers lexicographically. */\n     private static final long SGN_MASK = 0x8000000000000000L;\n \n+    /** Offset to order signed double numbers lexicographically. */\n+    private static final int SGN_MASK_FLOAT = 0x80000000;\n+\n     /** All long-representable factorials */\n     private static final long[] FACTORIALS = new long[] {\n                        1l,                  1l,                   2l,\n      */\n     public static double cosh(double x) {\n         return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n+    }\n+\n+    /**\n+     * Returns true iff they are equal as defined by\n+     * {@link #equals(float,float,int) equals(x, y, 1)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal.\n+     */\n+    public static boolean equals(float x, float y) {\n+        return equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or neither is NaN and they are\n+     * equal as defined by {@link #equals(float,float) this method}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other.\n+     */\n+    public static boolean equals(float x, float y, float eps) {\n+        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or are equal or within the range\n+     * of allowed error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other,\n+     * or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, float eps) {\n+        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n+     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n+     * point numbers are considered equal.\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if there are fewer than {@code maxUlps} floating\n+     * point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equals(float x, float y, int maxUlps) {\n+        // Check that \"maxUlps\" is non-negative and small enough so that\n+        // NaN won't compare as equal to anything (except another NaN).\n+        assert maxUlps > 0 && maxUlps < NAN_GAP;\n+\n+        int xInt = Float.floatToIntBits(x);\n+        int yInt = Float.floatToIntBits(y);\n+\n+        // Make lexicographically ordered as a two's-complement integer.\n+        if (xInt < 0) {\n+            xInt = SGN_MASK_FLOAT - xInt;\n+        }\n+        if (yInt < 0) {\n+            yInt = SGN_MASK_FLOAT - yInt;\n+        }\n+\n+        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+\n+        return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or if they are equal as defined\n+     * by {@link #equals(float,float,int) this method}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if both arguments are NaN or if there are less than\n+     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, maxUlps);\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equals(float,float) this method}.\n+     *\n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension\n+     * and equal elements.\n+     */\n+    public static boolean equals(float[] x, float[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equalsIncludingNaN(double,double) this method}.\n+     *\n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension and\n+     * equal elements\n+     */\n+    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equalsIncludingNaN(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         assertFalse(MathUtils.equalsIncludingNaN(152.9374, 153.0000, .0625));\n     }\n \n+    // Tests for floating point equality\n+    public void testFloatEqualsWithAllowedUlps() {\n+        assertTrue(\"+0.0f == -0.0f\",MathUtils.equals(0.0f, -0.0f));\n+        assertTrue(\"+0.0f == -0.0f (1 ulp)\",MathUtils.equals(0.0f, -0.0f, 1));\n+        float oneFloat = 1.0f;\n+        assertTrue(\"1.0f == 1.0f + 1 ulp\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat))));\n+        assertTrue(\"1.0f == 1.0f + 1 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)), 1));\n+        assertFalse(\"1.0f != 1.0f + 2 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)), 1));\n+\n+        assertTrue(MathUtils.equals(153.0f, 153.0f, 1));\n+\n+        // These tests need adjusting for floating point precision\n+//        assertTrue(MathUtils.equals(153.0f, 153.00000000000003f, 1));\n+//        assertFalse(MathUtils.equals(153.0f, 153.00000000000006f, 1));\n+//        assertTrue(MathUtils.equals(153.0f, 152.99999999999997f, 1));\n+//        assertFalse(MathUtils.equals(153f, 152.99999999999994f, 1));\n+//\n+//        assertTrue(MathUtils.equals(-128.0f, -127.99999999999999f, 1));\n+//        assertFalse(MathUtils.equals(-128.0f, -127.99999999999997f, 1));\n+//        assertTrue(MathUtils.equals(-128.0f, -128.00000000000003f, 1));\n+//        assertFalse(MathUtils.equals(-128.0f, -128.00000000000006f, 1));\n+\n+        assertTrue(MathUtils.equals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equals(Double.MAX_VALUE, Float.POSITIVE_INFINITY, 1));\n+\n+        assertTrue(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equals(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 1));\n+\n+        assertFalse(MathUtils.equals(Float.NaN, Float.NaN, 1));\n+\n+        assertFalse(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 100000));\n+    }\n+\n     public void testEqualsWithAllowedUlps() {\n         assertTrue(MathUtils.equals(0.0, -0.0, 1));\n ", "timestamp": 1294887477, "metainfo": ""}