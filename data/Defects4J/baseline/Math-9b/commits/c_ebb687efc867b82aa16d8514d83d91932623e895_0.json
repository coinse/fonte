{"sha": "ebb687efc867b82aa16d8514d83d91932623e895", "log": "specify the field to use for field vectors and field matrices when possible JIRA: MATH-573  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.fraction.BigFractionField;\n import org.apache.commons.math.fraction.FractionConversionException;\n import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n             }\n         }\n \n-        return new Array2DRowFieldMatrix<BigFraction>(Hdata);\n+        return new Array2DRowFieldMatrix<BigFraction>(BigFractionField.getInstance(), Hdata);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n \n     /** {@inheritDoc} */\n     public FieldVector<T> getRowVector(final int row) {\n-        return new ArrayFieldVector<T>(getRow(row), false);\n+        return new ArrayFieldVector<T>(field, getRow(row), false);\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public FieldVector<T> getColumnVector(final int column) {\n-        return new ArrayFieldVector<T>(getColumn(column), false);\n+        return new ArrayFieldVector<T>(field, getColumn(column), false);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     public FieldVector<T> operate(final FieldVector<T> v) {\n         try {\n-            return new ArrayFieldVector<T>(operate(((ArrayFieldVector<T>) v).getDataRef()), false);\n+            return new ArrayFieldVector<T>(field, operate(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n                 out[row] = sum;\n             }\n \n-            return new ArrayFieldVector<T>(out, false);\n+            return new ArrayFieldVector<T>(field, out, false);\n         }\n     }\n \n     /** {@inheritDoc} */\n     public FieldVector<T> preMultiply(final FieldVector<T> v) {\n         try {\n-            return new ArrayFieldVector<T>(preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);\n+            return new ArrayFieldVector<T>(field, preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);\n         } catch (ClassCastException cce) {\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n                 out[col] = sum;\n             }\n \n-            return new ArrayFieldVector<T>(out, false);\n+            return new ArrayFieldVector<T>(field, out, false);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n             }\n         }\n \n-        return new Array2DRowFieldMatrix<T>(outData, false);\n+        return new Array2DRowFieldMatrix<T>(getField(), outData, false);\n \n     }\n \n             }\n         }\n \n-        return new Array2DRowFieldMatrix<T>(outData, false);\n+        return new Array2DRowFieldMatrix<T>(getField(), outData, false);\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n     }\n \n     /**\n+     * Construct a vector from part of a array.\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param d Array.\n+     * @param pos Position of the first entry.\n+     * @param size Number of entries to copy.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws NumberIsTooLargeException if the size of {@code d} is less\n+     * than {@code pos + size}.\n+     */\n+    public ArrayFieldVector(Field<T> field, T[] d, int pos, int size) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (d.length < pos + size) {\n+            throw new NumberIsTooLargeException(pos + size, d.length, true);\n+        }\n+        this.field = field;\n+        data = buildArray(size);\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n      * Construct a vector from another vector, using a deep copy.\n      *\n      * @param v Vector to copy.\n \n     /** {@inheritDoc} */\n     public FieldVector<T> projection(T[] v) {\n-        return projection(new ArrayFieldVector<T>(v, false));\n+        return projection(new ArrayFieldVector<T>(getField(), v, false));\n     }\n \n    /** Find the orthogonal projection of this vector onto another vector.\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n             outIndex += jWidth;\n         }\n \n-        return new ArrayFieldVector<T>(outData, false);\n+        return new ArrayFieldVector<T>(getField(), outData, false);\n     }\n \n     /** {@inheritDoc} */\n             }\n         }\n \n-        return new ArrayFieldVector<T>(outData, false);\n+        return new ArrayFieldVector<T>(getField(), outData, false);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n                     }\n                 }\n \n-                return new ArrayFieldVector<T>(bp, false);\n+                return new ArrayFieldVector<T>(field, bp, false);\n \n             }\n         }\n          * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n         public ArrayFieldVector<T> solve(ArrayFieldVector<T> b) {\n-            return new ArrayFieldVector<T>(solve(b.getDataRef()), false);\n+            return new ArrayFieldVector<T>(field, solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n                 }\n             }\n \n-            return new Array2DRowFieldMatrix<T>(bp, false);\n+            return new Array2DRowFieldMatrix<T>(field, bp, false);\n \n         }\n \n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.fraction.Fraction;\n             Arrays.fill(dRow, zero);\n             dRow[row] = one;\n         }\n-        return new Array2DRowFieldMatrix<T>(d, false);\n+        return new Array2DRowFieldMatrix<T>(field, d, false);\n     }\n \n     /**\n      * @return a data.length FieldVector\n      * @throws NoDataException if {@code data} is empty.\n      * @throws NullArgumentException if {@code data} is {@code null}.\n+     * @throws ZeroException if {@code data} has 0 elements\n      */\n     public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n         if (data == null) {\n             throw new NullArgumentException();\n         }\n-        return new ArrayFieldVector<T>(data, true);\n+        if (data.length == 0) {\n+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n+        }\n+        return new ArrayFieldVector<T>(data[0].getField(), data, true);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n         Assert.assertEquals(5, v2.getDimension());\n         Assert.assertEquals(new Fraction(123, 100), v2.getEntry(4));\n \n-        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(vec1);\n+        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec1);\n         Assert.assertEquals(3, v3.getDimension());\n         Assert.assertEquals(new Fraction(2), v3.getEntry(1));\n \n-        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4, 3, 2);\n+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec4, 3, 2);\n         Assert.assertEquals(2, v4.getDimension());\n         Assert.assertEquals(new Fraction(4), v4.getEntry(0));\n         try {\n--- a/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n     /** test dimensions */\n     @Test\n     public void testDimensions() {\n-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix =\n+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n         FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);\n         Assert.assertEquals(testData.length, LU.getL().getRowDimension());\n         Assert.assertEquals(testData.length, LU.getL().getColumnDimension());\n     @Test\n     public void testNonSquare() {\n         try {\n+            // we don't use FractionField.getInstance() for testing purposes\n             new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n                     { Fraction.ZERO, Fraction.ZERO },\n                     { Fraction.ZERO, Fraction.ZERO },\n     /** test PA = LU */\n     @Test\n     public void testPAEqualLU() {\n-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n         FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         FieldMatrix<Fraction> l = lu.getL();\n         FieldMatrix<Fraction> u = lu.getU();\n         FieldMatrix<Fraction> p = lu.getP();\n         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n \n-        matrix = new Array2DRowFieldMatrix<Fraction>(testDataMinus);\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataMinus);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         l = lu.getL();\n         u = lu.getU();\n         p = lu.getP();\n         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));\n \n-        matrix = new Array2DRowFieldMatrix<Fraction>(singular);\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         Assert.assertFalse(lu.getSolver().isNonSingular());\n         Assert.assertNull(lu.getL());\n         Assert.assertNull(lu.getU());\n         Assert.assertNull(lu.getP());\n \n-        matrix = new Array2DRowFieldMatrix<Fraction>(bigSingular);\n+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular);\n         lu = new FieldLUDecompositionImpl<Fraction>(matrix);\n         Assert.assertFalse(lu.getSolver().isNonSingular());\n         Assert.assertNull(lu.getL());\n     /** test that L is lower triangular with unit diagonal */\n     @Test\n     public void testLLowerTriangular() {\n-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n         FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();\n         for (int i = 0; i < l.getRowDimension(); i++) {\n             Assert.assertEquals(Fraction.ONE, l.getEntry(i, i));\n     /** test that U is upper triangular */\n     @Test\n     public void testUUpperTriangular() {\n-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n         FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();\n         for (int i = 0; i < u.getRowDimension(); i++) {\n             for (int j = 0; j < i; j++) {\n     /** test that P is a permutation matrix */\n     @Test\n     public void testPPermutation() {\n-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);\n+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);\n         FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();\n \n         FieldMatrix<Fraction> ppT = p.multiply(p.transpose());\n     @Test\n     public void testSingular() {\n         FieldLUDecomposition<Fraction> lu =\n-            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));\n         Assert.assertTrue(lu.getSolver().isNonSingular());\n-        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(singular));\n+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular));\n         Assert.assertFalse(lu.getSolver().isNonSingular());\n-        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular));\n         Assert.assertFalse(lu.getSolver().isNonSingular());\n     }\n \n     @Test\n     public void testMatricesValues1() {\n        FieldLUDecomposition<Fraction> lu =\n-            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));\n-        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(2), new Fraction(1), new Fraction(0) },\n                 { new Fraction(1), new Fraction(-2), new Fraction(1) }\n         });\n-        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n                 { new Fraction(1),  new Fraction(2), new Fraction(3) },\n                 { new Fraction(0), new Fraction(1), new Fraction(-3) },\n                 { new Fraction(0),  new Fraction(0), new Fraction(-1) }\n         });\n-        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(0), new Fraction(1), new Fraction(0) },\n                 { new Fraction(0), new Fraction(0), new Fraction(1) }\n     @Test\n     public void testMatricesValues2() {\n        FieldLUDecomposition<Fraction> lu =\n-            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(luData));\n-        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), luData));\n+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(3), new Fraction(1), new Fraction(0) },\n                 { new Fraction(1), new Fraction(0), new Fraction(1) }\n         });\n-        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n                 { new Fraction(2), new Fraction(3), new Fraction(3)    },\n                 { new Fraction(0), new Fraction(-3), new Fraction(-1)  },\n                 { new Fraction(0), new Fraction(0), new Fraction(4) }\n         });\n-        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {\n+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {\n                 { new Fraction(1), new Fraction(0), new Fraction(0) },\n                 { new Fraction(0), new Fraction(0), new Fraction(1) },\n                 { new Fraction(0), new Fraction(1), new Fraction(0) }\n--- a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n     public void testcreateFieldMatrix() {\n         Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),\n                      MatrixUtils.createFieldMatrix(asFraction(testData)));\n-        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix),\n+        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), fractionColMatrix),\n                      MatrixUtils.createFieldMatrix(fractionColMatrix));\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n         SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);\n         assertClose(\"inverse multiply\", m.multiply(mInv), identity,\n                 entryTolerance);\n-        assertClose(\"inverse multiply\", m.multiply(new Array2DRowFieldMatrix<Fraction>(testDataInv)), identity,\n+        assertClose(\"inverse multiply\", m.multiply(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataInv)), identity,\n                     entryTolerance);\n         assertClose(\"inverse multiply\", mInv.multiply(m), identity,\n                 entryTolerance);", "timestamp": 1305465389, "metainfo": ""}