{"sha": "7f836b587389f84806d61880c08f355ca8ff01fb", "log": "MATH-854: in FieldVector and ArrayFieldVector, reverted to r1383770.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n      * @see #ArrayFieldVector(Field, FieldElement[])\n      */\n     public ArrayFieldVector(T[] d)\n-        throws NullArgumentException, ZeroException {\n+            throws NullArgumentException, ZeroException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @see #ArrayFieldVector(FieldElement[])\n      */\n     public ArrayFieldVector(Field<T> field, T[] d)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @see #ArrayFieldVector(Field, FieldElement[], boolean)\n      */\n     public ArrayFieldVector(T[] d, boolean copyArray)\n-        throws NullArgumentException, ZeroException {\n+            throws NullArgumentException, ZeroException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @see #ArrayFieldVector(FieldElement[], boolean)\n      */\n     public ArrayFieldVector(Field<T> field, T[] d, boolean copyArray)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * than {@code pos + size}.\n      */\n     public ArrayFieldVector(T[] d, int pos, int size)\n-        throws NullArgumentException, NumberIsTooLargeException {\n+            throws NullArgumentException, NumberIsTooLargeException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * than {@code pos + size}.\n      */\n     public ArrayFieldVector(Field<T> field, T[] d, int pos, int size)\n-        throws NullArgumentException, NumberIsTooLargeException {\n+            throws NullArgumentException, NumberIsTooLargeException {\n         if (d == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayFieldVector(FieldVector<T> v)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (v == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (v == null) {\n             throw new NullArgumentException();\n         }\n      * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v, boolean deep)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (v == null) {\n             throw new NullArgumentException();\n         }\n      * {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v1, ArrayFieldVector<T> v2)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n      * {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v1, T[] v2)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n      * {@code null}.\n      */\n     public ArrayFieldVector(T[] v1, ArrayFieldVector<T> v2)\n-        throws NullArgumentException {\n+            throws NullArgumentException {\n         if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n      * @see #ArrayFieldVector(Field, FieldElement[], FieldElement[])\n      */\n     public ArrayFieldVector(T[] v1, T[] v2)\n-        throws NullArgumentException, ZeroException {\n+            throws NullArgumentException, ZeroException {\n         if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n      * @see #ArrayFieldVector(FieldElement[], FieldElement[])\n      */\n     public ArrayFieldVector(Field<T> field, T[] v1, T[] v2)\n-        throws NullArgumentException, ZeroException {\n+            throws NullArgumentException, ZeroException {\n         if (v1 == null || v2 == null) {\n             throw new NullArgumentException();\n         }\n         return new ArrayFieldVector<T>(this, true);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> add(FieldVector<T> v)\n         throws DimensionMismatchException {\n         try {\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> subtract(FieldVector<T> v)\n         throws DimensionMismatchException {\n         try {\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     */\n-    public FieldVector<T> mapAdd(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAdd(T d) {\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].add(d);\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     */\n-    public FieldVector<T> mapAddToSelf(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAddToSelf(T d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i].add(d);\n         }\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     */\n-    public FieldVector<T> mapSubtract(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtract(T d) {\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].subtract(d);\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     */\n-    public FieldVector<T> mapSubtractToSelf(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtractToSelf(T d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i].subtract(d);\n         }\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     */\n-    public FieldVector<T> mapMultiply(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiply(T d) {\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].multiply(d);\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     */\n-    public FieldVector<T> mapMultiplyToSelf(T d) throws NullArgumentException {\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiplyToSelf(T d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i].multiply(d);\n         }\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     * @throws MathArithmeticException if {@code d} is zero.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> mapDivide(T d)\n         throws NullArgumentException, MathArithmeticException {\n         if (d == null) {\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NullArgumentException if {@code d} is {@code null}.\n-     * @throws MathArithmeticException if {@code d} is zero.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> mapDivideToSelf(T d)\n         throws NullArgumentException, MathArithmeticException {\n         if (d == null) {\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws MathArithmeticException if {@code d} is zero.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> mapInv() throws MathArithmeticException {\n         T[] out = buildArray(data.length);\n         final T one = field.getOne();\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws MathArithmeticException if {@code d} is zero.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> mapInvToSelf() throws MathArithmeticException {\n         final T one = field.getOne();\n         for (int i = 0; i < data.length; i++) {\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> ebeMultiply(FieldVector<T> v)\n         throws DimensionMismatchException {\n         try {\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}.\n-     * @throws MathArithmeticException if one entry of {@code v} is zero.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> ebeDivide(FieldVector<T> v)\n         throws DimensionMismatchException, MathArithmeticException {\n         try {\n         return data;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}.\n-     */\n-    public T dotProduct(FieldVector<T> v) throws DimensionMismatchException {\n+    /** {@inheritDoc} */\n+    public T dotProduct(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         try {\n             return dotProduct((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n         return dot;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * {@code this}.\n-     * @throws MathArithmeticException if {@code v} is the null vector.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> projection(FieldVector<T> v)\n         throws DimensionMismatchException, MathArithmeticException {\n         return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n         return new ArrayFieldVector<T>(field, out, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws OutOfRangeException if the index is not valid.\n-     * @throws NotPositiveException if the number of elements is not positive.\n-     */\n+    /** {@inheritDoc} */\n     public FieldVector<T> getSubVector(int index, int n)\n         throws OutOfRangeException, NotPositiveException {\n         if (n < 0) {\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws OutOfRangeException if the index is not valid.\n-     */\n+    /** {@inheritDoc} */\n     public void setSubVector(int index, FieldVector<T> v) throws OutOfRangeException {\n         try {\n             try {\n--- a/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n \n /**\n  * Interface defining a field-valued vector with basic algebraic operations.\n     FieldVector<T> copy();\n \n     /**\n-     * Compute the sum of {@code this} and {@code v}. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.DimensionMismatchException} if\n-     * {@code v} is not the same size as {@code this}.\n-     *\n+     * Compute the sum of {@code this} and {@code v}.\n      * @param v vector to be added\n      * @return {@code this + v}\n-     */\n-    FieldVector<T> add(FieldVector<T> v);\n-\n-    /**\n-     * Compute {@code this} minus {@code v}. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.DimensionMismatchException} if\n-     * {@code v} is not the same size as {@code this}\n-     *\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    FieldVector<T> add(FieldVector<T> v) throws DimensionMismatchException;\n+\n+    /**\n+     * Compute {@code this} minus {@code v}.\n      * @param v vector to be subtracted\n      * @return {@code this + v}\n-     */\n-    FieldVector<T> subtract(FieldVector<T> v);\n-\n-    /**\n-     * Map an addition operation to each entry. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.NullArgumentException} if\n-     * {@code d} is {@code null}.\n-     *\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    FieldVector<T> subtract(FieldVector<T> v) throws DimensionMismatchException;\n+\n+    /**\n+     * Map an addition operation to each entry.\n      * @param d value to be added to each entry\n      * @return {@code this + d}\n      */\n     FieldVector<T> mapAdd(T d);\n \n     /**\n-     * Map an addition operation to each entry. The instance <strong>is</strong>\n-     * changed by this method. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.NullArgumentException} if\n-     * {@code d} is {@code null}.\n-     *\n+     * Map an addition operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to be added to each entry\n      * @return for convenience, return {@code this}\n      */\n     FieldVector<T> mapAddToSelf(T d);\n \n     /**\n-     * Map a subtraction operation to each entry. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.NullArgumentException} if\n-     * {@code d} is {@code null}.\n-     *\n+     * Map a subtraction operation to each entry.\n      * @param d value to be subtracted to each entry\n      * @return {@code this - d}\n      */\n     FieldVector<T> mapSubtract(T d);\n \n     /**\n-     * Map a subtraction operation to each entry. The instance\n-     * <strong>is</strong> changed by this method. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.NullArgumentException} if\n-     * {@code d} is {@code null}.\n-     *\n+     * Map a subtraction operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to be subtracted to each entry\n      * @return for convenience, return {@code this}\n      */\n     FieldVector<T> mapSubtractToSelf(T d);\n \n     /**\n-     * Map a multiplication operation to each entry. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.NullArgumentException} if\n-     * {@code d} is {@code null}.\n-     *\n+     * Map a multiplication operation to each entry.\n      * @param d value to multiply all entries by\n      * @return {@code this * d}\n      */\n     FieldVector<T> mapMultiply(T d);\n \n     /**\n-     * Map a multiplication operation to each entry. The instance\n-     * <strong>is</strong> changed by this method. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.NullArgumentException} if\n-     * {@code d} is {@code null}.\n-     *\n+     * Map a multiplication operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to multiply all entries by\n      * @return for convenience, return {@code this}\n      */\n     FieldVector<T> mapMultiplyToSelf(T d);\n \n     /**\n-     * Map a division operation to each entry. Implementations should throw\n-     * <ul>\n-     * <li>{@link org.apache.commons.math3.exception.NullArgumentException} if\n-     *     {@code d} is {@code null},</li>\n-     * <li>{@link org.apache.commons.math3.exception.MathArithmeticException} if\n-     *     {@code d} is zero.</li>\n-     * </ul>\n-     *\n+     * Map a division operation to each entry.\n      * @param d value to divide all entries by\n      * @return {@code this / d}\n-     */\n-    FieldVector<T> mapDivide(T d);\n-\n-    /**\n-     * Map a division operation to each entry. The instance <strong>is</strong>\n-     * changed by this method.\n-     * <ul>\n-     * <li>{@link org.apache.commons.math3.exception.NullArgumentException} if\n-     *     {@code d} is {@code null},</li>\n-     * <li>{@link org.apache.commons.math3.exception.MathArithmeticException} if\n-     *     {@code d} is zero.</li>\n-     * </ul>\n-     *\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws MathArithmeticException if {@code d} is zero.\n+     */\n+    FieldVector<T> mapDivide(T d)\n+        throws NullArgumentException, MathArithmeticException;\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to divide all entries by\n      * @return for convenience, return {@code this}\n-     */\n-    FieldVector<T> mapDivideToSelf(T d);\n-\n-    /**\n-     * Map the 1/x function to each entry. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.MathArithmeticException} if\n-     * one of the entries is zero.\n-     *\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws MathArithmeticException if {@code d} is zero.\n+     */\n+    FieldVector<T> mapDivideToSelf(T d)\n+        throws NullArgumentException, MathArithmeticException;\n+\n+    /**\n+     * Map the 1/x function to each entry.\n      * @return a vector containing the result of applying the function to each\n      * entry.\n-     */\n-    FieldVector<T> mapInv();\n-\n-    /**\n-     * Map the 1/x function to each entry. The instance <strong>is</strong>\n-     * changed by this method. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.MathArithmeticException} if\n-     * one of the entries is zero.\n-     *\n-     * @return for convenience, return {@code this}\n-     */\n-    FieldVector<T> mapInvToSelf();\n-\n-    /**\n-     * Element-by-element multiplication. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.DimensionMismatchException} if\n-     * {@code v} is not the same size as {@code this}.\n-     *\n+     * @throws MathArithmeticException if one of the entries is zero.\n+     */\n+    FieldVector<T> mapInv() throws MathArithmeticException;\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return {@code this}\n+     * @throws MathArithmeticException if one of the entries is zero.\n+     */\n+    FieldVector<T> mapInvToSelf() throws MathArithmeticException;\n+\n+    /**\n+     * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n      * @return a vector containing {@code this[i] * v[i]} for all {@code i}\n-     */\n-    FieldVector<T> ebeMultiply(FieldVector<T> v);\n-\n-    /**\n-     * Element-by-element division. Implementations should throw\n-     * <ul>\n-     * <li>{@link org.apache.commons.math3.exception.DimensionMismatchException}\n-     *     if {@code v} is not the same size as {@code this},</li>\n-     * <li>{@link org.apache.commons.math3.exception.MathArithmeticException}\n-     *     if one entry of {@code v} is zero.\n-     * </li>\n-     * </ul>\n-     *\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws DimensionMismatchException;\n+\n+    /**\n+     * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      * @return a vector containing {@code this[i] / v[i]} for all {@code i}\n-     */\n-    FieldVector<T> ebeDivide(FieldVector<T> v);\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     * @throws MathArithmeticException if one entry of {@code v} is zero.\n+     */\n+    FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws DimensionMismatchException, MathArithmeticException;\n \n     /**\n      * Returns vector entries as a T array.\n      T[] getData();\n \n     /**\n-     * Compute the dot product. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.DimensionMismatchException} if\n-     * {@code v} is not the same size as {@code this}.\n-     *\n+     * Compute the dot product.\n      * @param v vector with which dot product should be computed\n      * @return the scalar dot product of {@code this} and {@code v}\n-     */\n-    T dotProduct(FieldVector<T> v);\n-\n-    /**\n-     * Find the orthogonal projection of this vector onto another vector.\n-     * Implementations should throw\n-     * <ul>\n-     * <li>{@link org.apache.commons.math3.exception.DimensionMismatchException}\n-     *     if {@code v} is not the same size as {@code this},</li>\n-     * <li>{@link org.apache.commons.math3.exception.MathArithmeticException}\n-     *     if {@code v} is the null vector.\n-     * </li>\n-     * </ul>\n-     *\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     */\n+    T dotProduct(FieldVector<T> v) throws DimensionMismatchException;\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n      * @param v vector onto which {@code this} must be projected\n      * @return projection of {@code this} onto {@code v}\n-     */\n-    FieldVector<T> projection(FieldVector<T> v);\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}\n+     * @throws MathArithmeticException if {@code v} is the null vector.\n+     */\n+    FieldVector<T> projection(FieldVector<T> v)\n+        throws DimensionMismatchException, MathArithmeticException;\n \n     /**\n      * Compute the outer product.\n     FieldMatrix<T> outerProduct(FieldVector<T> v);\n \n     /**\n-     * Returns the entry in the specified index. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.OutOfRangeException} if the\n-     * index is not valid.\n+     * Returns the entry in the specified index.\n      *\n      * @param index Index location of entry to be fetched.\n      * @return the vector entry at {@code index}.\n+     * @throws OutOfRangeException if the index is not valid.\n      * @see #setEntry(int, FieldElement)\n      */\n-    T getEntry(int index);\n-\n-    /**\n-     * Set a single element. Implementations should throw\n-     * <ul>\n-     * <li>{@link org.apache.commons.math3.exception.OutOfRangeException} if the\n-     *     index is not valid,</li>\n-     * <li>{@link org.apache.commons.math3.exception.NullArgumentException} if\n-     *     the value is {@code null}.</li>\n-     * </ul>\n-     *\n+    T getEntry(int index) throws OutOfRangeException;\n+\n+    /**\n+     * Set a single element.\n      * @param index element index.\n      * @param value new value for the element.\n+     * @throws OutOfRangeException if the index is not valid.\n      * @see #getEntry(int)\n      */\n-    void setEntry(int index, T value);\n+    void setEntry(int index, T value) throws OutOfRangeException;\n \n     /**\n      * Returns the size of the vector.\n     FieldVector<T> append(T d);\n \n     /**\n-     * Get a subvector from consecutive elements. Implementations should throw\n-     * <ul>\n-     * <li>{@link org.apache.commons.math3.exception.OutOfRangeException} if the\n-     *     index is not valid,</li>\n-     * <li>{@link org.apache.commons.math3.exception.NotPositiveException} if\n-     *     the number of elements is not positive.</li>\n-     * </ul>\n-     *\n+     * Get a subvector from consecutive elements.\n      * @param index index of first element.\n      * @param n number of elements to be retrieved.\n      * @return a vector containing n elements.\n-     */\n-    FieldVector<T> getSubVector(int index, int n);\n-\n-    /**\n-     * Set a set of consecutive elements. Implementations should throw\n-     * {@link org.apache.commons.math3.exception.OutOfRangeException} if the\n-     * index is not valid.\n-     *\n+     * @throws OutOfRangeException if the index is not valid.\n+     * @throws NotPositiveException if the number of elements if not positive.\n+     */\n+    FieldVector<T> getSubVector(int index, int n)\n+        throws OutOfRangeException, NotPositiveException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     */\n-    void setSubVector(int index, FieldVector<T> v);\n+     * @throws OutOfRangeException if the index is not valid.\n+     */\n+    void setSubVector(int index, FieldVector<T> v) throws OutOfRangeException;\n \n     /**\n      * Set all elements to a single value.", "timestamp": 1347562851, "metainfo": ""}