{"sha": "ee88057ba86b543c4f678f8e28b1620c22b19f0f", "log": "Changed return type of nthRoot to List Renamed getPhi to getArgument Changed and documented behavior of nthRoot wrt NaN, infinite components Improved nth root computation Added some test cases  ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n \n import java.io.Serializable;\n import java.util.ArrayList;\n-import java.util.Collection;\n+import java.util.List;\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n     \n     \n     /**\n-     * Compute the angle phi of this complex number.\n-     * @return the angle phi of this complex number\n-     */\n-    public double getPhi() {\n+     * <p>Compute the argument of this complex number.\n+     * </p>\n+     * <p>The argument is the angle phi between the positive real axis and the point\n+     * representing this number in the complex plane. The value returned is between -PI (not inclusive) \n+     * and PI (inclusive), with negative values returned for numbers with negative imaginary parts.\n+     * </p>\n+     * <p>If either real or imaginary part (or both) is NaN, NaN is returned.  Infinite parts are handled\n+     * as java.Math.atan2 handles them, essentially treating finite parts as zero in the presence of\n+     * an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite\n+     * parts.  See the javadoc for java.Math.atan2 for full details.</p>\n+     * \n+     * @return the argument of this complex number\n+     */\n+    public double getArgument() {\n         return Math.atan2(getImaginary(), getReal());\n     }\n     \n     /**\n-     * Compute the n-th root of this complex number.\n-     * <p>\n-     * For a given n it implements the formula: <pre>\n-     * <code> z_k = pow( abs , 1.0/n ) * (cos(phi + k * 2&pi;) + i * (sin(phi + k * 2&pi;)</code></pre></p>\n-     * with <i><code>k=0, 1, ..., n-1</code></i> and <i><code>pow(abs, 1.0 / n)</code></i> is the nth root of the absolute-value.\n-     * <p>\n+     * <p>Computes the n-th roots of this complex number.\n+     * </p>\n+     * <p>The nth roots are defined by the formula: <pre>\n+     * <code> z<sub>k</sub> = abs<sup> 1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))</code></pre>\n+     * for <i><code>k=0, 1, ..., n-1</code></i>, where <code>abs</code> and <code>phi</code> are\n+     * respectively the {@link #abs() modulus} and {@link #getArgument() argument} of this complex number.\n+     * </p>\n+     * <p>If one or both parts of this complex number is NaN, a list with just one element,\n+     *  {@link #NaN} is returned.</p>\n+     * <p>if neither part is NaN, but at least one part is infinite, the result is a one-element\n+     * list containing {@link #INF}.</p>\n      * \n      * @param n degree of root\n-     * @return Collection<Complex> all nth roots of this complex number as a Collection\n-     * @throws IllegalArgumentException if parameter n is negative\n+     * @return List<Complex> all nth roots of this complex number\n+     * @throws IllegalArgumentException if parameter n is less than or equal to 0\n      * @since 2.0\n      */\n-    public Collection<Complex> nthRoot(int n) throws IllegalArgumentException {\n+    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n \n         if (n <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\"cannot compute nth root for null or negative n: {0}\",\n                     new Object[] { n });\n         }\n-\n-        Collection<Complex> result = new ArrayList<Complex>();\n-\n-        // nth root of abs\n+        \n+        List<Complex> result = new ArrayList<Complex>();\n+        \n+        if (isNaN()) {\n+            result.add(Complex.NaN);\n+            return result;\n+        }\n+        \n+        if (isInfinite()) {\n+            result.add(Complex.INF);\n+            return result;\n+        }\n+\n+        // nth root of abs -- faster / more accurate to use a solver here?\n         final double nthRootOfAbs = Math.pow(abs(), 1.0 / n);\n \n         // Compute nth roots of complex number with k = 0, 1, ... n-1\n-        final double phi = getPhi();\n+        final double nthPhi = getArgument()/n;\n+        final double slice = 2 * Math.PI / n;\n+        double innerPart = nthPhi;\n         for (int k = 0; k < n ; k++) {\n             // inner part\n-            final double innerPart     = (phi + k * 2 * Math.PI) / n;\n             final double realPart      = nthRootOfAbs *  Math.cos(innerPart);\n             final double imaginaryPart = nthRootOfAbs *  Math.sin(innerPart);\n             result.add(createComplex(realPart, imaginaryPart));\n+            innerPart += slice;\n         }\n \n         return result;\n-\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n package org.apache.commons.math.complex;\n \n import org.apache.commons.math.TestUtils;\n+\n+import java.util.List;\n \n import junit.framework.TestCase;\n \n      * </code>\n      * </pre>\n      */\n-    public void testNthRoot_cornercase_thirdRoot_realPartEmpty() {\n+    public void testNthRoot_cornercase_thirdRoot_realPartZero() {\n         // complex number with only imaginary part\n         Complex z = new Complex(0,2);\n         // The List holding all third roots\n      * Test cornercases with NaN and Infinity.\n      */\n     public void testNthRoot_cornercase_NAN_Inf() {\n-        // third root of z = 1 + NaN * i\n-        for (Complex c : oneNaN.nthRoot(3)) {\n-            // both parts should be nan\n-            assertEquals(nan, c.getReal());\n-            assertEquals(nan, c.getImaginary());\n-        }\n-        // third root of z = inf + NaN * i\n-        for (Complex c : infNaN.nthRoot(3)) {\n-            // both parts should be nan\n-            assertEquals(nan, c.getReal());\n-            assertEquals(nan, c.getImaginary());\n-        }\n-        // third root of z = neginf + 1 * i\n-        Complex[] zInfOne = negInfOne.nthRoot(2).toArray(new Complex[0]);\n-        // first root\n-        assertEquals(inf, zInfOne[0].getReal());\n-        assertEquals(inf, zInfOne[0].getImaginary());\n-        // second root\n-        assertEquals(neginf, zInfOne[1].getReal());\n-        assertEquals(neginf, zInfOne[1].getImaginary());\n+        // NaN + finite -> NaN\n+        List<Complex> roots = oneNaN.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.NaN, roots.get(0));\n+        \n+        roots = nanZero.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.NaN, roots.get(0));\n+        \n+        // NaN + infinite -> NaN\n+        roots = nanInf.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.NaN, roots.get(0));\n+        \n+        // finite + infinite -> Inf\n+        roots = oneInf.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.INF, roots.get(0));\n+        \n+        // infinite + infinite -> Inf\n+        roots = negInfInf.nthRoot(3);\n+        assertEquals(1,roots.size());\n+        assertEquals(Complex.INF, roots.get(0));\n+    }\n+    \n+    /**\n+     * Test standard values\n+     */\n+    public void testGetArgument() {\n+        Complex z = new Complex(1, 0);\n+        assertEquals(0.0, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(1, 1);\n+        assertEquals(Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(0, 1);\n+        assertEquals(Math.PI/2, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(-1, 1);\n+        assertEquals(3 * Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(-1, 0);\n+        assertEquals(Math.PI, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(-1, -1);\n+        assertEquals(-3 * Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(0, -1);\n+        assertEquals(-Math.PI/2, z.getArgument(), 1.0e-12);\n+        \n+        z = new Complex(1, -1);\n+        assertEquals(-Math.PI/4, z.getArgument(), 1.0e-12);\n+        \n+    }\n+    \n+    /**\n+     * Verify atan2-style handling of infinite parts\n+     */\n+    public void testGetArgumentInf() {\n+        assertEquals(Math.PI/4, infInf.getArgument(), 1.0e-12);\n+        assertEquals(Math.PI/2, oneInf.getArgument(), 1.0e-12);\n+        assertEquals(0.0, infOne.getArgument(), 1.0e-12);\n+        assertEquals(Math.PI/2, zeroInf.getArgument(), 1.0e-12);\n+        assertEquals(0.0, infZero.getArgument(), 1.0e-12);\n+        assertEquals(Math.PI, negInfOne.getArgument(), 1.0e-12);\n+        assertEquals(-3.0*Math.PI/4, negInfNegInf.getArgument(), 1.0e-12);  \n+        assertEquals(-Math.PI/2, oneNegInf.getArgument(), 1.0e-12);        \n+    }\n+    \n+    /**\n+     * Verify that either part NaN results in NaN\n+     */\n+    public void testGetArgumentNaN() {\n+        assertEquals(nan, nanZero.getArgument());\n+        assertEquals(nan, zeroNaN.getArgument());\n+        assertEquals(nan, Complex.NaN.getArgument());  \n     }\n \n }", "timestamp": 1231213589, "metainfo": ""}