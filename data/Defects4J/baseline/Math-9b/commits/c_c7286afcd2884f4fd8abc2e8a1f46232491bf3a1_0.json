{"sha": "c7286afcd2884f4fd8abc2e8a1f46232491bf3a1", "log": "Added random data generation methods to RandomDataImpl for the remaining distributions in the distributions package.  Added a generic nextInversionDeviate method that takes a discrete or continuous distribution as argument and generates a random deviate from the distribution. JIRA: MATH-310  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import java.security.NoSuchProviderException;\n import java.util.Collection;\n \n+import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.distribution.BetaDistributionImpl;\n+import org.apache.commons.math.distribution.BinomialDistributionImpl;\n+import org.apache.commons.math.distribution.CauchyDistributionImpl;\n+import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n+import org.apache.commons.math.distribution.ContinuousDistribution;\n+import org.apache.commons.math.distribution.FDistributionImpl;\n+import org.apache.commons.math.distribution.GammaDistributionImpl;\n+import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n+import org.apache.commons.math.distribution.IntegerDistribution;\n+import org.apache.commons.math.distribution.PascalDistributionImpl;\n+import org.apache.commons.math.distribution.TDistributionImpl;\n+import org.apache.commons.math.distribution.WeibullDistributionImpl;\n+import org.apache.commons.math.distribution.ZipfDistributionImpl;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n  * it any easier to predict subsequent values.</li>\n  * <li>\n  * When a new <code>RandomDataImpl</code> is created, the underlying random\n- * number generators are <strong>not</strong> intialized. If you do not\n+ * number generators are <strong>not</strong> initialized. If you do not\n  * explicitly seed the default non-secure generator, it is seeded with the\n  * current time in milliseconds on first use. The same holds for the secure\n  * generator. If you provide a <code>RandomGenerator</code> to the constructor,\n     }\n \n     /**\n+     * Generates a random value from the {@link BetaDistributionImpl Beta Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param alpha first distribution shape parameter\n+     * @param beta second distribution shape parameter\n+     * @return random value sampled from the beta(alpha, beta) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double nextBeta(double alpha, double beta) throws MathException {\n+        return nextInversionDeviate(new BetaDistributionImpl(alpha, beta));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link BinomialDistributionImpl Binomial Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param numberOfTrials number of trials of the Binomial distribution\n+     * @param probabilityOfSuccess probability of success of the Binomial distribution\n+     * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) throws MathException {\n+        return nextInversionDeviate(new BinomialDistributionImpl(numberOfTrials, probabilityOfSuccess));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link CauchyDistributionImpl Cauchy Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param median the median of the Cauchy distribution\n+     * @param scale the scale parameter of the Cauchy distribution\n+     * @return random value sampled from the Cauchy(median, scale) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double nextCauchy(double median, double scale) throws MathException {\n+        return nextInversionDeviate(new CauchyDistributionImpl(median, scale));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link ChiSquaredDistributionImpl ChiSquare Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param df the degrees of freedom of the ChiSquare distribution\n+     * @return random value sampled from the ChiSquare(df) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double nextChiSquare(double df) throws MathException {\n+        return nextInversionDeviate(new ChiSquaredDistributionImpl(df));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link FDistributionImpl F Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param numeratorDf the numerator degrees of freedom of the F distribution\n+     * @param denominatorDf the denominator degrees of freedom of the F distribution\n+     * @return random value sampled from the F(numeratorDf, denominatorDf) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double nextF(double numeratorDf, double denominatorDf) throws MathException {\n+        return nextInversionDeviate(new FDistributionImpl(numeratorDf, denominatorDf));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link GammaDistributionImpl Gamma Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param shape the median of the Gamma distribution\n+     * @param scale the scale parameter of the Gamma distribution\n+     * @return random value sampled from the Gamma(shape, scale) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double nextGamma(double shape, double scale) throws MathException {\n+        return nextInversionDeviate(new GammaDistributionImpl(shape, scale));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link HypergeometricDistributionImpl Hypergeometric Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param populationSize the population size of the Hypergeometric distribution\n+     * @param numberOfSuccesses number of successes in the population of the Hypergeometric distribution\n+     * @param sampleSize the sample size of the Hypergeometric distribution\n+     * @return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) throws MathException {\n+        return nextInversionDeviate(new HypergeometricDistributionImpl(populationSize, numberOfSuccesses, sampleSize));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link PascalDistributionImpl Pascal Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param r the number of successes of the Pascal distribution\n+     * @param p the probability of success of the Pascal distribution\n+     * @return random value sampled from the Pascal(r, p) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public int nextPascal(int r, double p) throws MathException {\n+        return nextInversionDeviate(new PascalDistributionImpl(r, p));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link TDistributionImpl T Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param df the degrees of freedom of the T distribution\n+     * @return random value from the T(df) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double nextT(double df) throws MathException {\n+        return nextInversionDeviate(new TDistributionImpl(df));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link WeibullDistributionImpl Weibull Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param shape the shape parameter of the Weibull distribution\n+     * @param scale the scale parameter of the Weibull distribution\n+     * @return random value sampled from the Weibull(shape, size) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double nextWeibull(double shape, double scale) throws MathException {\n+        return nextInversionDeviate(new WeibullDistributionImpl(shape, scale));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link ZipfDistributionImpl Zipf Distribution}.\n+     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n+     * to generate random values.\n+     *\n+     * @param numberOfElements the number of elements of the ZipfDistribution\n+     * @param exponent the exponent of the ZipfDistribution\n+     * @return random value sampled from the Zipf(numberOfElements, exponent) distribution\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public int nextZipf(int numberOfElements, double exponent) throws MathException {\n+        return nextInversionDeviate(new ZipfDistributionImpl(numberOfElements, exponent));\n+    }\n+\n+    /**\n      * Returns the RandomGenerator used to generate non-secure random data.\n      * <p>\n      * Creates and initializes a default generator if null.\n             result[i] = objects[index[i]];\n         }\n         return result;\n+    }\n+\n+    /**\n+     * Generate a random deviate from the given distribution using the\n+     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\"> inversion method.</a>\n+     *\n+     * @param distribution Continuous distribution to generate a random value from\n+     * @return a random value sampled from the given distribution\n+     * @throws MathException if an error occurs computing the inverse cumulative distribution function\n+     */\n+    public double nextInversionDeviate(ContinuousDistribution distribution) throws MathException {\n+        return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n+\n+    }\n+\n+    /**\n+     * Generate a random deviate from the given distribution using the\n+     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\"> inversion method.</a>\n+     *\n+     * @param distribution Integer distribution to generate a random value from\n+     * @return a random value sampled from the given distribution\n+     * @throws MathException if an error occurs computing the inverse cumulative distribution function\n+     */\n+    public int nextInversionDeviate(IntegerDistribution distribution) throws MathException {\n+        final double target = nextUniform(0, 1);\n+        final int glb = distribution.inverseCumulativeProbability(target);\n+        if (distribution.cumulativeProbability(glb) == 1.0d) { // No mass above\n+            return glb;\n+        } else {\n+            return glb + 1;\n+        }\n     }\n \n     // ------------------------Private methods----------------------------------\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import junit.framework.AssertionFailedError;\n \n import org.apache.commons.math.RetryTestCase;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.distribution.BetaDistributionImpl;\n+import org.apache.commons.math.distribution.BinomialDistributionImpl;\n+import org.apache.commons.math.distribution.BinomialDistributionTest;\n+import org.apache.commons.math.distribution.CauchyDistributionImpl;\n+import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n+import org.apache.commons.math.distribution.ContinuousDistribution;\n+import org.apache.commons.math.distribution.FDistributionImpl;\n+import org.apache.commons.math.distribution.GammaDistributionImpl;\n+import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n+import org.apache.commons.math.distribution.HypergeometricDistributionTest;\n+import org.apache.commons.math.distribution.PascalDistributionImpl;\n+import org.apache.commons.math.distribution.PascalDistributionTest;\n import org.apache.commons.math.distribution.PoissonDistribution;\n import org.apache.commons.math.distribution.PoissonDistributionImpl;\n+import org.apache.commons.math.distribution.TDistributionImpl;\n+import org.apache.commons.math.distribution.WeibullDistributionImpl;\n+import org.apache.commons.math.distribution.ZipfDistributionImpl;\n+import org.apache.commons.math.distribution.ZipfDistributionTest;\n import org.apache.commons.math.stat.Frequency;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n         randomData = new RandomDataImpl();\n     }\n \n-    protected long smallSampleSize = 1000;\n-    protected double[] expected = { 250, 250, 250, 250 };\n-    protected int largeSampleSize = 10000;\n-    private String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n+    protected final long smallSampleSize = 1000;\n+    protected final double[] expected = { 250, 250, 250, 250 };\n+    protected final int largeSampleSize = 10000;\n+    private final String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n             \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n     protected RandomDataImpl randomData = null;\n-    protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n+    protected final ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n \n     public void testNextIntExtremeValues() {\n         int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         fail(\"permutation not found\");\n         return -1;\n     }\n+    \n+    public void testNextInversionDeviate() throws Exception {\n+        // Set the seed for the default random generator\n+        randomData.reSeed(100);\n+        double[] quantiles = new double[10];\n+        for (int i = 0; i < 10; i++) {\n+            quantiles[i] = randomData.nextUniform(0, 1);\n+        }\n+        // Reseed again so the inversion generator gets the same sequence\n+        randomData.reSeed(100);\n+        BetaDistributionImpl betaDistribution = new BetaDistributionImpl(2, 4);\n+        /*\n+         *  Generate a sequence of deviates using inversion - the distribution function\n+         *  evaluated at the random value from the distribution should match the uniform\n+         *  random value used to generate it, which is stored in the quantiles[] array.\n+         */\n+        for (int i = 0; i < 10; i++) {\n+            double value = randomData.nextInversionDeviate(betaDistribution);\n+            assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9);\n+        } \n+    }\n+    \n+    public void testNextBeta() throws Exception {\n+        double[] quartiles = getDistributionQuartiles(new BetaDistributionImpl(2,5));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextBeta(2, 5);\n+            updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+    }\n+    \n+    public void testNextCauchy() throws Exception {\n+        double[] quartiles = getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextCauchy(1.2, 2.1);\n+            updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+    }\n+    \n+    public void testNextChiSquare() throws Exception {\n+        double[] quartiles = getDistributionQuartiles(new ChiSquaredDistributionImpl(12));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextChiSquare(12);\n+            updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+    }\n+    \n+    public void testNextF() throws Exception {\n+        double[] quartiles = getDistributionQuartiles(new FDistributionImpl(12, 5));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextF(12, 5);\n+            updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+    }\n+    \n+    public void testNextGamma() throws Exception {\n+        double[] quartiles = getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextGamma(4, 2);\n+            updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+    }\n+    \n+    public void testNextT() throws Exception {\n+        double[] quartiles = getDistributionQuartiles(new TDistributionImpl(10));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextT(10);\n+            updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+    }\n+    \n+    public void testNextWeibull() throws Exception {\n+        double[] quartiles = getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextWeibull(1.2, 2.1);\n+            updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+    }\n+    \n+    /**\n+     * Computes the 25th, 50th and 75th percentiles of the given distribution and returns\n+     * these values in an array.\n+     */\n+    private double[] getDistributionQuartiles(ContinuousDistribution distribution) throws Exception {\n+        double[] quantiles = new double[3];\n+        quantiles[0] = distribution.inverseCumulativeProbability(0.25d);\n+        quantiles[1] = distribution.inverseCumulativeProbability(0.5d);\n+        quantiles[2] = distribution.inverseCumulativeProbability(0.75d);\n+        return quantiles;\n+    }\n+    \n+    /**\n+     * Updates observed counts of values in quartiles.\n+     * counts[0] <-> 1st quartile ... counts[3] <-> top quartile\n+     */\n+    private void updateCounts(double value, long[] counts, double[] quantiles) {\n+        if (value < quantiles[0]) {\n+            counts[0]++;\n+        } else if (value > quantiles[2]) {\n+            counts[3]++;\n+        } else if (value > quantiles[1]) {\n+            counts[2]++;\n+        } else {\n+            counts[1]++;\n+        }  \n+    }\n+    \n+    public void testNextBinomial() throws Exception {\n+        BinomialDistributionTest testInstance = new BinomialDistributionTest(\"\");\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        BinomialDistributionImpl distribution = (BinomialDistributionImpl) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextBinomial(distribution.getNumberOfTrials(),\n+                  distribution.getProbabilityOfSuccess());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+    \n+    public void testNextHypergeometric() throws Exception {\n+        HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest(\"\");\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        HypergeometricDistributionImpl distribution = (HypergeometricDistributionImpl) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextHypergeometric(distribution.getPopulationSize(),\n+                  distribution.getNumberOfSuccesses(), distribution.getSampleSize());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+    \n+    public void testNextPascal() throws Exception {\n+        PascalDistributionTest testInstance = new PascalDistributionTest(\"\");\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        PascalDistributionImpl distribution = (PascalDistributionImpl) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextPascal(distribution.getNumberOfSuccesses(), distribution.getProbabilityOfSuccess());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+    \n+    public void testNextZipf() throws Exception {\n+        ZipfDistributionTest testInstance = new ZipfDistributionTest(\"\");\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        ZipfDistributionImpl distribution = (ZipfDistributionImpl) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextZipf(distribution.getNumberOfElements(), distribution.getExponent());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+    \n+    /**\n+     * Eliminates points with zero mass from densityPoints and densityValues parallel\n+     * arrays.  Returns the number of positive mass points and collapses the arrays so\n+     * that the first <returned value> elements of the input arrays represent the positive\n+     * mass points.\n+     */\n+    private int eliminateZeroMassPoints(int[] densityPoints, double[] densityValues) {\n+        int positiveMassCount = 0;\n+        for (int i = 0; i < densityValues.length; i++) {\n+            if (densityValues[i] > 0) {\n+                positiveMassCount++;\n+            }\n+        }\n+        if (positiveMassCount < densityValues.length) {\n+            int[] newPoints = new int[positiveMassCount];\n+            double[] newValues = new double[positiveMassCount];\n+            int j = 0;\n+            for (int i = 0; i < densityValues.length; i++) {\n+                if (densityValues[i] > 0) {\n+                    newPoints[j] = densityPoints[i];\n+                    newValues[j] = densityValues[i];\n+                    j++;\n+                }\n+            }\n+            System.arraycopy(newPoints,0,densityPoints,0,positiveMassCount);\n+            System.arraycopy(newValues,0,densityValues,0,positiveMassCount);\n+        }\n+        return positiveMassCount;\n+    } \n+    \n }", "timestamp": 1275244250, "metainfo": ""}