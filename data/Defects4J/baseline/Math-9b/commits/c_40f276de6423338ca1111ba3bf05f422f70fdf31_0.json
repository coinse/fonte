{"sha": "40f276de6423338ca1111ba3bf05f422f70fdf31", "log": "Removed data mutators from RealMatrix interface and RealMatrixImpl.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n  * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.\n  * \n- * @version $Revision: 1.24 $ $Date: 2004/10/09 22:39:22 $\n+ * @version $Revision: 1.25 $ $Date: 2004/10/12 06:19:50 $\n  */\n public interface RealMatrix {\n \n      * @return    2-dimensional array of entries\n      */\n     double[][] getData();\n-\n-    /**\n-     * Overwrites the underlying data for the matrix with\n-     * a fresh copy of <code>data</code>.\n-     *\n-     * @param  data  2-dimensional array of entries\n-     */\n-    void setData(double[][] data);\n \n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html\">\n     double getEntry(int row, int column) throws MatrixIndexException;\n \n     /**\n-     * Sets the entry in the specified row and column to the specified value.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy \n-     * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.\n-     * \n-     * @param row    row location of entry to be set \n-     * @param column    column location of entry to be set\n-     * @param value  value to set \n-     * @throws MatrixIndexException if the row or column index is not valid\n-     */\n-    void setEntry(int row, int column, double value)\n-        throws MatrixIndexException;\n-\n-    /**\n      * Returns the transpose of this matrix.\n      *\n      * @return transpose matrix\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n \n \n /**\n- * Implementation for RealMatrix using a double[][] array to store entries\n- * and <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+ * Implementation for RealMatrix using a double[][] array to store entries and\n+ * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n  * LU decompostion</a> to support linear system\n  * solution and inverse.\n  * <p>\n  * <p>\n  * <strong>Usage notes</strong>:<br>\n  * <ul><li>\n- * The LU decomposition is stored and reused on subsequent calls.  If matrix\n- * data are modified using any of the public setXxx methods, the saved\n- * decomposition is discarded.  If data are modified via references to the\n- * underlying array obtained using <code>getDataRef()</code>, then the stored\n- * LU decomposition will not be discarded.  In this case, you need to\n- * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n+ * The LU decomposition is cached and reused on subsequent calls.   \n+ * If data are modified via references to the underlying array obtained using\n+ * <code>getDataRef()</code>, then the stored LU decomposition will not be\n+ * discarded.  In this case, you need to explicitly invoke \n+ * <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.</li>\n  * <li>\n  * As specified in the {@link RealMatrix} interface, matrix element indexing\n  * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.</li></ul>\n  *\n- * @version $Revision: 1.32 $ $Date: 2004/10/10 18:00:33 $\n+ * @version $Revision: 1.33 $ $Date: 2004/10/12 06:19:50 $\n  */\n public class RealMatrixImpl implements RealMatrix, Serializable {\n     \n     }\n \n     /**\n-     * Overwrites the underlying data for the matrix\n-     * with a fresh copy of <code>inData</code>.\n-     *\n-     * @param  inData 2-dimensional array of entries\n-     */\n-    public void setData(double[][] inData) {\n-        copyIn(inData);\n-        lu = null;\n-    }\n-\n-    /**\n      * Returns a reference to the underlying data array.\n      * <p>\n      * Does not make a fresh copy of the underlying data.\n      */\n     public double[][] getDataRef() {\n         return data;\n-    }\n-\n-    /**\n-     * Overwrites the underlying data for the matrix\n-     * with a reference to <code>inData</code>.\n-     * <p>\n-     * Does not make a fresh copy of <code>data</code>.\n-     *\n-     * @param  inData 2-dimensional array of entries\n-     */\n-    public void setDataRef(double[][] inData) {\n-        this.data = inData;\n-        lu = null;\n     }\n \n     /**\n             throw new MatrixIndexException(\"matrix entry does not exist\");\n         }\n         return data[row][column];\n-    }\n-\n-    /**\n-     * Sets the entry in the specified row and column to the specified value.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy \n-     * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.\n-     * \n-     * @param row    row location of entry to be set \n-     * @param column    column location of entry to be set\n-     * @param value  value to set \n-     * @throws MatrixIndexException if the row or column index is not valid\n-     */\n-    public void setEntry(int row, int column, double value)\n-        throws MatrixIndexException {\n-        if (!isValidCoordinate(row,column)) {\n-            throw new MatrixIndexException(\"matrix entry does not exist\");\n-        }\n-        data[row][column] = value;\n-        lu = null;\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n /**\n  * Test cases for the {@link RealMatrixImpl} class.\n  *\n- * @version $Revision: 1.19 $ $Date: 2004/10/10 18:01:16 $\n+ * @version $Revision: 1.20 $ $Date: 2004/10/12 06:19:50 $\n  */\n \n public final class RealMatrixImplTest extends TestCase {\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-        RealMatrixImpl m3 = new RealMatrixImpl();\n-        m3.setData(testData);\n     } \n     \n     /** test copy functions */\n     public void testCopyFunctions() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrixImpl m2 = new RealMatrixImpl(testData2);\n-        m2.setData(m.getData());\n-        assertClose(\"getData\",m2,m,entryTolerance);\n-        // no dangling reference...\n-        m2.setEntry(1,1,2000d);\n-        RealMatrixImpl m3 = new RealMatrixImpl(testData);\n-        assertClose(\"no getData side effect\",m,m3,entryTolerance);\n-        m3 = (RealMatrixImpl) m.copy();\n-        double[][] stompMe = {{1d,2d,3d}};\n-        m3.setDataRef(stompMe);\n-        assertClose(\"no copy side effect\",m,new RealMatrixImpl(testData),\n-            entryTolerance);\n+        RealMatrixImpl m2 = new RealMatrixImpl(m.getData());\n+        assertEquals(m2,m);\n     }           \n     \n     /** test add */\n         }\n     }\n     \n-    public void testEntryMutators() {\n+    public void testGetEntry() {\n         RealMatrix m = new RealMatrixImpl(testData);\n         assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n-        m.setEntry(1,2,100d);\n-        assertEquals(\"get entry\",m.getEntry(1,2),100d,entryTolerance);\n-        try {\n-            double x = m.getEntry(-1,2);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n-            ;\n-        }\n-        try {\n-            m.setEntry(1,4,200d);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n-            ;\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n         }\n     }\n         \n         RealMatrix m = new RealMatrixImpl(matrixData);\n         // One more with three rows, two columns\n         double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};\n-        RealMatrix n = new RealMatrixImpl();\n-        n.setData(matrixData2); \n+        RealMatrix n = new RealMatrixImpl(matrixData2);\n         // Now multiply m by n\n         RealMatrix p = m.multiply(n);\n         assertEquals(2, p.getRowDimension());\n     }\n     \n     /** extracts the l  and u matrices from compact lu representation */\n-    protected void splitLU(RealMatrix lu, RealMatrix lower, RealMatrix upper) throws InvalidMatrixException {\n-        if (!lu.isSquare() || !lower.isSquare() || !upper.isSquare() ||\n-                lower.getRowDimension() != upper.getRowDimension() \n-                || lower.getRowDimension() != lu.getRowDimension()) {\n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   \n+        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n+                lowerData.length != upperData.length\n+                || lowerData.length != lu.getRowDimension()) {\n             throw new InvalidMatrixException(\"incorrect dimensions\");\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 if (j < i) {\n-                    lower.setEntry(i, j, lu.getEntry(i, j));\n-                    upper.setEntry(i, j, 0d);\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = 0d;\n                 } else if (i == j) {\n-                    lower.setEntry(i, j, 1d);\n-                    upper.setEntry(i, j, lu.getEntry(i, j));\n+                    lowerData[i][j] = 1d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n                 } else {\n-                    lower.setEntry(i, j, 0d);\n-                    upper.setEntry(i, j, lu.getEntry(i, j));\n+                    lowerData[i][j] = 0d;\n+                    upperData[i][j] = lu.getEntry(i, j);\n                 }   \n             }\n         }\n             throw new IllegalArgumentException(\"dimension mismatch\");\n         }\n         int n = matrix.getRowDimension();\n-        RealMatrix out = new RealMatrixImpl(n, n);\n+        int m = matrix.getColumnDimension();\n+        double out[][] = new double[m][n];\n         for (int i = 0; i < n; i++) {\n-            for (int j = 0; j < n; j++) {\n-                out.setEntry(i, j, matrix.getEntry(permutation[i], j));\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n             }\n         }\n-        return out;\n+        return new RealMatrixImpl(out);\n     }\n     \n     /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */\n     protected void verifyDecomposition(RealMatrix matrix, RealMatrix lu) throws Exception{\n         int n = matrix.getRowDimension();\n-        RealMatrix lower = new RealMatrixImpl(n, n);\n-        RealMatrix upper = new RealMatrixImpl(n, n);\n-        splitLU(lu, lower, upper);\n+        double[][] lowerData = new double[n][n];\n+        double[][] upperData = new double[n][n];\n+        splitLU(lu, lowerData, upperData);\n+        RealMatrix lower =new RealMatrixImpl(lowerData);\n+        RealMatrix upper = new RealMatrixImpl(upperData);\n         int[] permutation = ((RealMatrixImpl) matrix).getPermutation();\n         RealMatrix permuted = permuteRows(matrix, permutation);\n         assertClose(\"lu decomposition does not work\", permuted, lower.multiply(upper), normTolerance);", "timestamp": 1097561990, "metainfo": ""}