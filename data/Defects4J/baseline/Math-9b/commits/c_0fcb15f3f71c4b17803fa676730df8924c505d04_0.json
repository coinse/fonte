{"sha": "0fcb15f3f71c4b17803fa676730df8924c505d04", "log": "JIRA Math-630 First push of PivotingQRDecomposition  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/PivotingQRDecomposition.java\n+/*\n+ * Copyright 2011 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ *\n+ * @author gregsterijevski\n+ */\n+public class PivotingQRDecomposition {\n+\n+    private double[][] qr;\n+    /** The diagonal elements of R. */\n+    private double[] rDiag;\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+    /** Cached value of QT. */\n+    private RealMatrix cachedQT;\n+    /** Cached value of R. */\n+    private RealMatrix cachedR;\n+    /** Cached value of H. */\n+    private RealMatrix cachedH;\n+    /** permutation info */\n+    private int[] permutation;\n+    /** the rank **/\n+    private int rank;\n+    /** vector of column multipliers */\n+    private double[] beta;\n+\n+    public boolean isSingular() {\n+        return rank != qr[0].length;\n+    }\n+\n+    public int getRank() {\n+        return rank;\n+    }\n+\n+    public int[] getOrder() {\n+        return MathUtils.copyOf(permutation);\n+    }\n+\n+    public PivotingQRDecomposition(RealMatrix matrix) throws ConvergenceException {\n+        this(matrix, 1.0e-16, true);\n+    }\n+\n+    public PivotingQRDecomposition(RealMatrix matrix, boolean allowPivot) throws ConvergenceException {\n+        this(matrix, 1.0e-16, allowPivot);\n+    }\n+\n+    public PivotingQRDecomposition(RealMatrix matrix, double qrRankingThreshold,\n+            boolean allowPivot) throws ConvergenceException {\n+        final int rows = matrix.getRowDimension();\n+        final int cols = matrix.getColumnDimension();\n+        qr = matrix.getData();\n+        rDiag = new double[cols];\n+        //final double[] norms = new double[cols];\n+        this.beta = new double[cols];\n+        this.permutation = new int[cols];\n+        cachedQ = null;\n+        cachedQT = null;\n+        cachedR = null;\n+        cachedH = null;\n+\n+        /*- initialize the permutation vector and calculate the norms */\n+        for (int k = 0; k < cols; ++k) {\n+            permutation[k] = k;\n+        }\n+        // transform the matrix column after column\n+        for (int k = 0; k < cols; ++k) {\n+            // select the column with the greatest norm on active components\n+            int nextColumn = -1;\n+            double ak2 = Double.NEGATIVE_INFINITY;\n+            if (allowPivot) {\n+                for (int i = k; i < cols; ++i) {\n+                    double norm2 = 0;\n+                    for (int j = k; j < rows; ++j) {\n+                        final double aki = qr[j][permutation[i]];\n+                        norm2 += aki * aki;\n+                    }\n+                    if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n+                        throw new ConvergenceException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n+                                rows, cols);\n+                    }\n+                    if (norm2 > ak2) {\n+                        nextColumn = i;\n+                        ak2 = norm2;\n+                    }\n+                }\n+            } else {\n+                nextColumn = k;\n+                ak2 = 0.0;\n+                for (int j = k; j < rows; ++j) {\n+                    final double aki = qr[j][k];\n+                    ak2 += aki * aki;\n+                }\n+            }\n+            if (ak2 <= qrRankingThreshold) {\n+                rank = k;\n+                for (int i = rank; i < rows; i++) {\n+                    for (int j = i + 1; j < cols; j++) {\n+                        qr[i][permutation[j]] = 0.0;\n+                    }\n+                }\n+                return;\n+            }\n+            final int pk = permutation[nextColumn];\n+            permutation[nextColumn] = permutation[k];\n+            permutation[k] = pk;\n+\n+            // choose alpha such that Hk.u = alpha ek\n+            final double akk = qr[k][pk];\n+            final double alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\n+            final double betak = 1.0 / (ak2 - akk * alpha);\n+            beta[pk] = betak;\n+\n+            // transform the current column\n+            rDiag[pk] = alpha;\n+            qr[k][pk] -= alpha;\n+\n+            // transform the remaining columns\n+            for (int dk = cols - 1 - k; dk > 0; --dk) {\n+                double gamma = 0;\n+                for (int j = k; j < rows; ++j) {\n+                    gamma += qr[j][pk] * qr[j][permutation[k + dk]];\n+                }\n+                gamma *= betak;\n+                for (int j = k; j < rows; ++j) {\n+                    qr[j][permutation[k + dk]] -= gamma * qr[j][pk];\n+                }\n+            }\n+        }\n+        rank = cols;\n+        return;\n+    }\n+\n+    /**\n+     * Returns the matrix Q of the decomposition.\n+     * <p>Q is an orthogonal matrix</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQ() {\n+        if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n+\n+    /**\n+     * Returns the transpose of the matrix Q of the decomposition.\n+     * <p>Q is an orthogonal matrix</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQT() {\n+        if (cachedQT == null) {\n+\n+            // QT is supposed to be m x m\n+            final int n = qr[0].length;\n+            final int m = qr.length;\n+            cachedQT = MatrixUtils.createRealMatrix(m, m);\n+\n+            /*\n+             * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then\n+             * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in\n+             * succession to the result\n+             */\n+            for (int minor = m - 1; minor >= rank; minor--) {\n+                cachedQT.setEntry(minor, minor, 1.0);\n+            }\n+\n+            for (int minor = rank - 1; minor >= 0; minor--) {\n+                //final double[] qrtMinor = qrt[minor];\n+                final int p_minor = permutation[minor];\n+                cachedQT.setEntry(minor, minor, 1.0);\n+                //if (qrtMinor[minor] != 0.0) {\n+                for (int col = minor; col < m; col++) {\n+                    double alpha = 0.0;\n+                    for (int row = minor; row < m; row++) {\n+                        alpha -= cachedQT.getEntry(col, row) * qr[row][p_minor];\n+                    }\n+                    alpha /= rDiag[p_minor] * qr[minor][p_minor];\n+                    for (int row = minor; row < m; row++) {\n+                        cachedQT.addToEntry(col, row, -alpha * qr[row][p_minor]);\n+                    }\n+                }\n+                //}\n+            }\n+        }\n+        // return the cached matrix\n+        return cachedQT;\n+    }\n+\n+    /**\n+     * Returns the matrix R of the decomposition.\n+     * <p>R is an upper-triangular matrix</p>\n+     * @return the R matrix\n+     */\n+    public RealMatrix getR() {\n+        if (cachedR == null) {\n+            // R is supposed to be m x n\n+            final int n = qr[0].length;\n+            final int m = qr.length;\n+            cachedR = MatrixUtils.createRealMatrix(m, n);\n+            // copy the diagonal from rDiag and the upper triangle of qr\n+            for (int row = rank - 1; row >= 0; row--) {\n+                cachedR.setEntry(row, row, rDiag[permutation[row]]);\n+                for (int col = row + 1; col < n; col++) {\n+                    cachedR.setEntry(row, col, qr[row][permutation[col]]);\n+                }\n+            }\n+        }\n+        // return the cached matrix\n+        return cachedR;\n+    }\n+\n+    public RealMatrix getH() {\n+        if (cachedH == null) {\n+            final int n = qr[0].length;\n+            final int m = qr.length;\n+            cachedH = MatrixUtils.createRealMatrix(m, n);\n+            for (int i = 0; i < m; ++i) {\n+                for (int j = 0; j < FastMath.min(i + 1, n); ++j) {\n+                    final int p_j = permutation[j];\n+                    cachedH.setEntry(i, j, qr[i][p_j] / -rDiag[p_j]);\n+                }\n+            }\n+        }\n+        // return the cached matrix\n+        return cachedH;\n+    }\n+\n+    public RealMatrix getPermutationMatrix() {\n+        RealMatrix rm = MatrixUtils.createRealMatrix(qr[0].length, qr[0].length);\n+        for (int i = 0; i < this.qr[0].length; i++) {\n+            rm.setEntry(permutation[i], i, 1.0);\n+        }\n+        return rm;\n+    }\n+\n+    public DecompositionSolver getSolver() {\n+        return new Solver(qr, rDiag, permutation, rank);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+\n+        /**\n+         * A packed TRANSPOSED representation of the QR decomposition.\n+         * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+         * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+         * from which an explicit form of Q can be recomputed if desired.</p>\n+         */\n+        private final double[][] qr;\n+        /** The diagonal elements of R. */\n+        private final double[] rDiag;\n+        /** The rank of the matrix      */\n+        private final int rank;\n+        /** The permutation matrix      */\n+        private final int[] perm;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param qrt packed TRANSPOSED representation of the QR decomposition\n+         * @param rDiag diagonal elements of R\n+         */\n+        private Solver(final double[][] qr, final double[] rDiag, int[] perm, int rank) {\n+            this.qr = qr;\n+            this.rDiag = rDiag;\n+            this.perm = perm;\n+            this.rank = rank;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            if (qr.length >= qr[0].length) {\n+                return rank == qr[0].length;\n+            } else { //qr.length < qr[0].length\n+                return rank == qr.length;\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b) {\n+            final int n = qr[0].length;\n+            final int m = qr.length;\n+            if (b.getDimension() != m) {\n+                throw new DimensionMismatchException(b.getDimension(), m);\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] x = new double[n];\n+            final double[] y = b.toArray();\n+\n+            // apply Householder transforms to solve Q.y = b\n+            for (int minor = 0; minor < rank; minor++) {\n+                final int m_idx = perm[minor];\n+                double dotProduct = 0;\n+                for (int row = minor; row < m; row++) {\n+                    dotProduct += y[row] * qr[row][m_idx];\n+                }\n+                dotProduct /= rDiag[m_idx] * qr[minor][m_idx];\n+                for (int row = minor; row < m; row++) {\n+                    y[row] += dotProduct * qr[row][m_idx];\n+                }\n+            }\n+            // solve triangular system R.x = y\n+            for (int row = rank - 1; row >= 0; --row) {\n+                final int m_row = perm[row];\n+                y[row] /= rDiag[m_row];\n+                final double yRow = y[row];\n+                //final double[] qrtRow = qrt[row];\n+                x[perm[row]] = yRow;\n+                for (int i = 0; i < row; i++) {\n+                    y[i] -= yRow * qr[i][m_row];\n+                }\n+            }\n+            return new ArrayRealVector(x, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            final int cols = qr[0].length;\n+            final int rows = qr.length;\n+            if (b.getRowDimension() != rows) {\n+                throw new DimensionMismatchException(b.getRowDimension(), rows);\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int columns = b.getColumnDimension();\n+            final int blockSize = BlockRealMatrix.BLOCK_SIZE;\n+            final int cBlocks = (columns + blockSize - 1) / blockSize;\n+            final double[][] xBlocks = BlockRealMatrix.createBlocksLayout(cols, columns);\n+            final double[][] y = new double[b.getRowDimension()][blockSize];\n+            final double[] alpha = new double[blockSize];\n+            //final BlockRealMatrix result = new BlockRealMatrix(cols, columns, xBlocks, false);\n+            for (int kBlock = 0; kBlock < cBlocks; ++kBlock) {\n+                final int kStart = kBlock * blockSize;\n+                final int kEnd = FastMath.min(kStart + blockSize, columns);\n+                final int kWidth = kEnd - kStart;\n+                // get the right hand side vector\n+                b.copySubMatrix(0, rows - 1, kStart, kEnd - 1, y);\n+\n+                // apply Householder transforms to solve Q.y = b\n+                for (int minor = 0; minor < rank; minor++) {\n+                    final int m_idx = perm[minor];\n+                    final double factor = 1.0 / (rDiag[m_idx] * qr[minor][m_idx]);\n+\n+                    Arrays.fill(alpha, 0, kWidth, 0.0);\n+                    for (int row = minor; row < rows; ++row) {\n+                        final double d = qr[row][m_idx];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            alpha[k] += d * yRow[k];\n+                        }\n+                    }\n+                    for (int k = 0; k < kWidth; ++k) {\n+                        alpha[k] *= factor;\n+                    }\n+\n+                    for (int row = minor; row < rows; ++row) {\n+                        final double d = qr[row][m_idx];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yRow[k] += alpha[k] * d;\n+                        }\n+                    }\n+                }\n+\n+                // solve triangular system R.x = y\n+                for (int j = rank - 1; j >= 0; --j) {\n+                    final int jBlock = perm[j] / blockSize; //which block\n+                    final int jStart = jBlock * blockSize;  // idx of top corner of block in my coord\n+                    final double factor = 1.0 / rDiag[perm[j]];\n+                    final double[] yJ = y[j];\n+                    final double[] xBlock = xBlocks[jBlock * cBlocks + kBlock];\n+                    int index = (perm[j] - jStart) * kWidth; //to local (block) coordinates\n+                    for (int k = 0; k < kWidth; ++k) {\n+                        yJ[k] *= factor;\n+                        xBlock[index++] = yJ[k];\n+                    }\n+                    for (int i = 0; i < j; ++i) {\n+                        final double rIJ = qr[i][perm[j]];\n+                        final double[] yI = y[i];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yI[k] -= yJ[k] * rIJ;\n+                        }\n+                    }\n+                }\n+            }\n+            //return result;\n+            return new BlockRealMatrix(cols, columns, xBlocks, false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() {\n+            return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/PivotingQRDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class PivotingQRDecompositionTest {\n+    double[][] testData3x3NonSingular = {\n+            { 12, -51, 4 },\n+            { 6, 167, -68 },\n+            { -4, 24, -41 }, };\n+\n+    double[][] testData3x3Singular = {\n+            { 1, 4, 7, },\n+            { 2, 5, 8, },\n+            { 3, 6, 9, }, };\n+\n+    double[][] testData3x4 = {\n+            { 12, -51, 4, 1 },\n+            { 6, 167, -68, 2 },\n+            { -4, 24, -41, 3 }, };\n+\n+    double[][] testData4x3 = {\n+            { 12, -51, 4, },\n+            { 6, 167, -68, },\n+            { -4, 24, -41, },\n+            { -5, 34, 7, }, };\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() throws ConvergenceException {\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkDimension(createTestMatrix(r, p, q));\n+        checkDimension(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkDimension(RealMatrix m) throws ConvergenceException {\n+        int rows = m.getRowDimension();\n+        int columns = m.getColumnDimension();\n+        PivotingQRDecomposition qr = new PivotingQRDecomposition(m);\n+        Assert.assertEquals(rows,    qr.getQ().getRowDimension());\n+        Assert.assertEquals(rows,    qr.getQ().getColumnDimension());\n+        Assert.assertEquals(rows,    qr.getR().getRowDimension());\n+        Assert.assertEquals(columns, qr.getR().getColumnDimension());\n+    }\n+\n+    /** test A = QR */\n+    @Test\n+    public void testAEqualQR() throws ConvergenceException {\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkAEqualQR(createTestMatrix(r, p, q));\n+\n+        checkAEqualQR(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkAEqualQR(RealMatrix m) throws ConvergenceException {\n+        PivotingQRDecomposition qr = new PivotingQRDecomposition(m);\n+        RealMatrix prod =  qr.getQ().multiply(qr.getR()).multiply(qr.getPermutationMatrix().transpose());\n+        double norm = prod.subtract(m).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test the orthogonality of Q */\n+    @Test\n+    public void testQOrthogonal() throws ConvergenceException{\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkQOrthogonal(createTestMatrix(r, p, q));\n+\n+        checkQOrthogonal(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkQOrthogonal(RealMatrix m) throws ConvergenceException{\n+        PivotingQRDecomposition qr = new PivotingQRDecomposition(m);\n+        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());\n+        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+    }\n+//\n+    /** test that R is upper triangular */\n+    @Test\n+    public void testRUpperTriangular() throws ConvergenceException{\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new PivotingQRDecomposition(matrix).getR());\n+\n+    }\n+\n+    private void checkUpperTriangular(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column < row) {\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+\n+    /** test that H is trapezoidal */\n+    @Test\n+    public void testHTrapezoidal() throws ConvergenceException{\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new PivotingQRDecomposition(matrix).getH());\n+\n+    }\n+\n+    private void checkTrapezoidal(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column > row) {\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+    /** test matrices values */\n+    @Test\n+    public void testMatricesValues() throws ConvergenceException{\n+        PivotingQRDecomposition qr =\n+            new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular),false);\n+        RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n+                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n+                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }\n+        });\n+        RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { -14.0,  -21.0, 14.0 },\n+                {   0.0, -175.0, 70.0 },\n+                {   0.0,    0.0, 35.0 }\n+        });\n+        RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 26.0 / 14.0, 0.0, 0.0 },\n+                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },\n+                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix q = qr.getQ();\n+        Assert.assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n+        RealMatrix qT = qr.getQT();\n+        Assert.assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);\n+        RealMatrix r = qr.getR();\n+        Assert.assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n+        RealMatrix h = qr.getH();\n+        Assert.assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(q == qr.getQ());\n+        Assert.assertTrue(r == qr.getR());\n+        Assert.assertTrue(h == qr.getH());\n+\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n+            @Override\n+            public double visit(int row, int column, double value) {\n+                return 2.0 * r.nextDouble() - 1.0;\n+            }\n+        });\n+        return m;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/PivotingQRSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class PivotingQRSolverTest {\n+    double[][] testData3x3NonSingular = {\n+            { 12, -51,   4 },\n+            {  6, 167, -68 },\n+            { -4,  24, -41 }\n+    };\n+\n+    double[][] testData3x3Singular = {\n+            { 1, 2,  2 },\n+            { 2, 4,  6 },\n+            { 4, 8, 12 }\n+    };\n+\n+    double[][] testData3x4 = {\n+            { 12, -51,   4, 1 },\n+            {  6, 167, -68, 2 },\n+            { -4,  24, -41, 3 }\n+    };\n+\n+    double[][] testData4x3 = {\n+            { 12, -51,   4 },\n+            {  6, 167, -68 },\n+            { -4,  24, -41 },\n+            { -5,  34,   7 }\n+    };\n+\n+    /** test rank */\n+    @Test\n+    public void testRank() throws ConvergenceException {\n+        DecompositionSolver solver =\n+            new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n+        Assert.assertTrue(solver.isNonSingular());\n+\n+        solver = new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n+        Assert.assertFalse(solver.isNonSingular());\n+\n+        solver = new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x4)).getSolver();\n+        Assert.assertTrue(solver.isNonSingular());\n+\n+        solver = new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData4x3)).getSolver();\n+        Assert.assertTrue(solver.isNonSingular());\n+\n+    }\n+\n+    /** test solve dimension errors */\n+    @Test\n+    public void testSolveDimensionErrors() throws ConvergenceException {\n+        DecompositionSolver solver =\n+            new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException iae) {\n+            // expected behavior\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException iae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    /** test solve rank errors */\n+    @Test\n+    public void testSolveRankErrors() throws ConvergenceException {\n+        DecompositionSolver solver =\n+            new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n+        try {\n+            solver.solve(b);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (SingularMatrixException iae) {\n+            // expected behavior\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (SingularMatrixException iae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    /** test solve */\n+    @Test\n+    public void testSolve() throws ConvergenceException {\n+        PivotingQRDecomposition decomposition =\n+            new PivotingQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+        DecompositionSolver solver = decomposition.getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n+        });\n+\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1, 2515 }, { 2, 422 }, { -3, 898 }\n+        });\n+\n+        // using RealMatrix\n+        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-14 * xRef.getNorm());\n+\n+        // using ArrayRealVector\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            final RealVector x = solver.solve(b.getColumnVector(i));\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            Assert.assertEquals(0, error, 3.0e-14 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n+            final RealVector x = solver.solve(v);\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            Assert.assertEquals(0, error, 3.0e-14 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testOverdetermined() throws ConvergenceException {\n+        final Random r    = new Random(5559252868205245l);\n+        int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n+\n+        // build a perturbed system: A.X + noise = B\n+        RealMatrix b = a.multiply(xRef);\n+        final double noise = 0.001;\n+        b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+            @Override\n+            public double visit(int row, int column, double value) {\n+                return value * (1.0 + noise * (2 * r.nextDouble() - 1));\n+            }\n+        });\n+\n+        // despite perturbation, the least square solution should be pretty good\n+        RealMatrix x = new PivotingQRDecomposition(a).getSolver().solve(b);\n+        Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);\n+\n+    }\n+\n+    @Test\n+    public void testUnderdetermined() throws ConvergenceException {\n+        final Random r    = new Random(42185006424567123l);\n+        int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n+        RealMatrix   b    = a.multiply(xRef);\n+        PivotingQRDecomposition pqr = new PivotingQRDecomposition(a);\n+        RealMatrix   x = pqr.getSolver().solve(b);\n+        Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);\n+        int count=0;\n+        for( int i = 0 ; i < q; i++){\n+            if(  x.getRowVector(i).getNorm() == 0.0 ){\n+                ++count;\n+            }\n+        }\n+        Assert.assertEquals(\"Zeroed rows\", q-p, count);\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+                @Override\n+                    public double visit(int row, int column, double value) {\n+                    return 2.0 * r.nextDouble() - 1.0;\n+                }\n+            });\n+        return m;\n+    }\n+}", "timestamp": 1317964877, "metainfo": ""}