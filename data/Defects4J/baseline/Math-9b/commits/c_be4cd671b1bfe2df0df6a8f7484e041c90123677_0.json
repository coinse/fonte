{"sha": "be4cd671b1bfe2df0df6a8f7484e041c90123677", "log": "Fixed a OutOfBoundException in simplex solver when some constraints are tight JIRA: MATH-293  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n     /** Whether to restrict the variables to non-negative values. */\n     private final boolean restrictToNonNegative;\n \n+    /** The variables each column represents */\n+    private final List<String> columnLabels = new ArrayList<String>();\n+\n     /** Simple tableau. */\n     private transient RealMatrix tableau;\n \n         this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                       getConstraintTypeCounts(Relationship.GEQ);\n         this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n+        initializeColumnLabels();\n+    }\n+\n+    protected void initializeColumnLabels() {\n+      if (getNumObjectiveFunctions() == 2) {\n+        columnLabels.add(\"W\");\n+      }\n+      columnLabels.add(\"Z\");\n+      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n+        columnLabels.add(\"x\" + i);\n+      }\n+      if (!restrictToNonNegative) {\n+        columnLabels.add(\"x-\");\n+      }\n+      for (int i = 0; i < getNumSlackVariables(); i++) {\n+        columnLabels.add(\"s\" + i);\n+      }\n+      for (int i = 0; i < getNumArtificialVariables(); i++) {\n+        columnLabels.add(\"a\" + i);\n+      }\n+      columnLabels.add(\"RHS\");\n     }\n \n     /**\n           }\n         }\n \n+        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n+          columnLabels.remove((int) columnsToDrop.get(i));\n+        }\n+\n         this.tableau = new Array2DRowRealMatrix(matrix);\n         this.numArtificialVariables = 0;\n     }\n      * @return current solution\n      */\n     protected RealPointValuePair getSolution() {\n+      int negativeVarColumn = columnLabels.indexOf(\"x-\");\n+      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n+      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n+\n+      Set<Integer> basicRows = new HashSet<Integer>();\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n-      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n-      Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n-          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+          int colIndex = columnLabels.indexOf(\"x\" + i);\n+          if (colIndex < 0) {\n+            coefficients[i] = 0;\n+            continue;\n+          }\n+          Integer basicRow = getBasicRow(colIndex);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n                   (restrictToNonNegative ? 0 : mostNegative);\n           }\n       }\n-        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n+      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n     /**\n     }\n \n     /**\n-     * Returns the offset of the extra decision variable added when there is a\n-     * negative decision variable in the original problem.\n-     * @return the offset of x-\n-     */\n-    protected final int getNegativeDecisionVariableOffset() {\n-      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n-    }\n-\n-    /**\n      * Get the number of decision variables.\n      * <p>\n      * If variables are not restricted to positive values, this will include 1\n      * @see #getNumDecisionVariables()\n      */\n     protected final int getOriginalNumDecisionVariables() {\n-        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n+        return f.getCoefficients().getDimension();\n     }\n \n     /**\n         ois.defaultReadObject();\n         MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n     }\n+\n }\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n         constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0));\n         SimplexSolver solver = new SimplexSolver();\n         solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n+    }\n+\n+    @Test\n+    public void testMath293() throws OptimizationException {\n+      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );\n+      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n+      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));\n+      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));\n+      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0));\n+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0));\n+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0));\n+\n+      SimplexSolver solver = new SimplexSolver();\n+      RealPointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+\n+      Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001);\n+      Assert.assertEquals(0.0, solution1.getPoint()[1], .0001);\n+      Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001);\n+      Assert.assertEquals(0.0, solution1.getPoint()[3], .0001);\n+      Assert.assertEquals(0.0, solution1.getPoint()[4], .0001);\n+      Assert.assertEquals(30.0, solution1.getPoint()[5], .0001);\n+      Assert.assertEquals(40.57143, solution1.getValue(), .0001);\n+\n+      double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1];\n+      double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3];\n+      double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5];\n+\n+      f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 );\n+      constraints = new ArrayList<LinearConstraint>();\n+      constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0));\n+      constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0));\n+      constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA));\n+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB));\n+      constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC));\n+\n+      RealPointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n+      Assert.assertEquals(40.57143, solution2.getValue(), .0001);\n     }\n \n     @Test", "timestamp": 1252570828, "metainfo": ""}