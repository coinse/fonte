{"sha": "4cce86a7a28b1037dc930d094f86854e56c6b3a7", "log": "prepared interface for general eigendecomposition we currently support only symmetric matrices and real eigenvalues Jira issue MATH-235 asks for asymmetric matrices support, which needs an API adaptation. Preparing the interface yet avoids introducing incompatibility later. The current status is explained in javadoc and matrix symmetry is checked at runtime with an InvalidMatrixException triggered if asymmetry is detected.  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n \n /**\n  * An interface to classes that implement an algorithm to calculate the \n- * eigen decomposition of a real symmetric matrix.\n+ * eigen decomposition of a real matrix.\n  * <p>The eigen decomposition of matrix A is a set of two matrices:\n  * V and D such that A = V &times; D &times; V<sup>T</sup>.\n  * A, V and D are all m &times; m matrices.</p>\n  * library, with the following changes:</p>\n  * <ul>\n  *   <li>a {@link #getVT() getVt} method has been added,</li>\n- *   <li>a {@link #getEigenvalue(int) getEigenvalue} method to pick up a single\n- *   eigenvalue has been added,</li>\n+ *   <li>two {@link #getRealEigenvalue(int) getRealEigenvalue} and {@link #getImagEigenvalue(int)\n+ *   getImagEigenvalue} methods to pick up a single eigenvalue have been added,</li>\n  *   <li>a {@link #getEigenvector(int) getEigenvector} method to pick up a single\n  *   eigenvector has been added,</li>\n- *   <li>the <code>getRealEigenvalues</code> method has been renamed as {@link\n- *   #getEigenValues() getEigenValues},</li>\n- *   <li>the <code>getImagEigenvalues</code> method has been removed</li>\n  *   <li>a {@link #getDeterminant() getDeterminant} method has been added.</li>\n  *   <li>a {@link #getSolver() getSolver} method has been added.</li>\n  * </ul>\n     RealMatrix getV();\n \n     /**\n-     * Returns the diagonal matrix D of the decomposition. \n-     * <p>D is a diagonal matrix.</p>\n-     * <p>The values on the diagonal are the eigenvalues of the original matrix.</p>\n+     * Returns the block diagonal matrix D of the decomposition. \n+     * <p>D is a block diagonal matrix.</p>\n+     * <p>Real eigenvalues are on the diagonal while complex values are on\n+     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.</p>\n      * @return the D matrix\n      * @see #getEigenValues()\n      */\n     RealMatrix getVT();\n \n     /**\n-     * Returns a copy of the eigenvalues of the original matrix.\n-     * @return a copy of the eigenvalues of the original matrix\n+     * Returns a copy of the real parts of the eigenvalues of the original matrix.\n+     * @return a copy of the real parts of the eigenvalues of the original matrix\n      * @see #getD()\n+     * @see #getRealEigenvalue(int)\n+     * @see #getImagEigenvalues()\n      */\n-    double[] getEigenvalues();\n+    double[] getRealEigenvalues();\n \n     /**\n-     * Returns the i<sup>th</sup> eigenvalue of the original matrix.\n+     * Returns the real part of the i<sup>th</sup> eigenvalue of the original matrix.\n      * @param i index of the eigenvalue (counting from 0)\n-     * @return i<sup>th</sup> eigenvalue of the original matrix\n+     * @return real part of the i<sup>th</sup> eigenvalue of the original matrix\n      * @see #getD()\n+     * @see #getRealEigenvalues()\n+     * @see #getImagEigenvalue(int)\n      */\n-    double getEigenvalue(int i);\n+    double getRealEigenvalue(int i);\n+\n+    /**\n+     * Returns a copy of the imaginary parts of the eigenvalues of the original matrix.\n+     * @return a copy of the imaginary parts of the eigenvalues of the original matrix\n+     * @see #getD()\n+     * @see #getImagEigenvalue(int)\n+     * @see #getRealEigenvalues()\n+     */\n+    double[] getImagEigenvalues();\n+\n+    /**\n+     * Returns the imaginary part of the i<sup>th</sup> eigenvalue of the original matrix.\n+     * @param i index of the eigenvalue (counting from 0)\n+     * @return imaginary part of the i<sup>th</sup> eigenvalue of the original matrix\n+     * @see #getD()\n+     * @see #getImagEigenvalues()\n+     * @see #getRealEigenvalue(int)\n+     */\n+    double getImagEigenvalue(int i);\n \n     /**\n      * Returns a copy of the i<sup>th</sup> eigenvector of the original matrix.\n     double getDeterminant();\n \n     /**\n-     * Get a solver for A &times; X = B.\n+     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n      * @return a solver\n      */\n     DecompositionSolver getSolver();\n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n \n /**\n  * Calculates the eigen decomposition of a <strong>symmetric</strong> matrix.\n- * <p>The eigen decomposition of symmetric matrix A is a set of two matrices:\n+ * <p>The eigen decomposition of matrix A is a set of two matrices:\n  * V and D such that A = V D V<sup>T</sup>. A, V and D are all m &times; m\n  * matrices.</p>\n+ * <p>As of 2.0, this class supports only <strong>symmetric</strong> matrices,\n+ * and hence computes only real realEigenvalues. This implies the D matrix returned by\n+ * {@link #getD()} is always diagonal and the imaginary values returned {@link\n+ * #getImagEigenvalue(int)} and {@link #getImagEigenvalues()} are always null.</p>\n  * <p>When called with a {@link RealMatrix} argument, this implementation only uses\n  * the upper part of the matrix, the part below the diagonal is not accessed at all.</p>\n  * <p>Eigenvalues are computed as soon as the matrix is decomposed, but eigenvectors\n     /** Shift ratio with respect to dMin used when tType == 6. */\n     private double g;\n \n-    /** Eigenvalues. */\n-    private double[] eigenvalues;\n+    /** Real part of the realEigenvalues. */\n+    private double[] realEigenvalues;\n+\n+    /** Imaginary part of the realEigenvalues. */\n+    private double[] imagEigenvalues;\n \n     /** Eigenvectors. */\n     private RealVectorImpl[] eigenvectors;\n     public EigenDecompositionImpl(final RealMatrix matrix,\n                                   final double splitTolerance)\n         throws InvalidMatrixException {\n-        this.splitTolerance = splitTolerance;\n-        transformToTridiagonal(matrix);\n-        decompose();\n+        if (isSymmetric(matrix)) {\n+            this.splitTolerance = splitTolerance;\n+            transformToTridiagonal(matrix);\n+            decompose();\n+        } else {\n+            // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported\n+            // see issue https://issues.apache.org/jira/browse/MATH-235\n+            throw new InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\",\n+                                             null);\n+        }\n     }\n \n     /**\n     }\n \n     /**\n+     * Check if a matrix is symmetric.\n+     * @param matrix matrix to check\n+     * @return true if matrix is symmetric\n+     */\n+    private boolean isSymmetric(final RealMatrix matrix) {\n+        final int rows    = matrix.getRowDimension();\n+        final int columns = matrix.getColumnDimension();\n+        final double eps  = 10 * rows * columns * MathUtils.EPSILON;\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = i + 1; j < columns; ++j) {\n+                final double mij = matrix.getEntry(i, j);\n+                final double mji = matrix.getEntry(j, i);\n+                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * eps)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n      * Decompose a tridiagonal symmetric matrix. \n      * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n      * if algorithm fails to converge\n         // compute the Gershgorin circles\n         computeGershgorinCircles();\n \n-        // find all the eigenvalues\n+        // find all the realEigenvalues\n         findEigenvalues();\n \n         // we will search for eigenvectors only if required\n         throws InvalidMatrixException {\n         if (cachedD == null) {\n             // cache the matrix for subsequent calls\n-            cachedD = MatrixUtils.createRealDiagonalMatrix(eigenvalues);\n+            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n         }\n         return cachedD;\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public double[] getEigenvalues()\n+    public double[] getRealEigenvalues()\n         throws InvalidMatrixException {\n-        return eigenvalues.clone();\n+        return realEigenvalues.clone();\n     }\n \n     /** {@inheritDoc} */\n-    public double getEigenvalue(final int i)\n+    public double getRealEigenvalue(final int i)\n         throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n-        return eigenvalues[i];\n+        return realEigenvalues[i];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getImagEigenvalues()\n+        throws InvalidMatrixException {\n+        return imagEigenvalues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getImagEigenvalue(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        return imagEigenvalues[i];\n     }\n \n     /** {@inheritDoc} */\n      */\n     public double getDeterminant() {\n         double determinant = 1;\n-        for (double lambda : eigenvalues) {\n+        for (double lambda : realEigenvalues) {\n             determinant *= lambda;\n         }\n         return determinant;\n         if (eigenvectors == null) {\n             findEigenVectors();\n         }\n-        return new Solver(eigenvalues, eigenvectors);\n+        return new Solver(realEigenvalues, eigenvectors);\n     }\n \n     /** Specialized solver. */\n \n         /**\n          * Build a solver from decomposed matrix.\n-         * @param eigenvalues eigenvalues\n+         * @param realEigenvalues realEigenvalues\n          * @param eigenvectors eigenvectors\n          */\n         private Solver(final double[] eigenvalues, final RealVectorImpl[] eigenvectors) {\n     }\n \n     /**\n-     * Find the eigenvalues.\n+     * Find the realEigenvalues.\n      * @exception InvalidMatrixException if a block cannot be diagonalized\n      */\n     private void findEigenvalues()\n         // compute splitting points\n         List<Integer> splitIndices = computeSplits();\n \n-        // find eigenvalues in each block\n-        eigenvalues = new double[main.length];\n+        // find realEigenvalues in each block\n+        realEigenvalues = new double[main.length];\n+        imagEigenvalues = new double[main.length];\n         int begin = 0;\n         for (final int end : splitIndices) {\n             final int n = end - begin;\n                 // apply general dqd/dqds method\n                 processGeneralBlock(n);\n \n-                // extract eigenvalues\n+                // extract realEigenvalues\n                 if (chooseLeft) {\n                     for (int i = 0; i < n; ++i) {\n-                        eigenvalues[begin + i] = lambda + work[4 * i];\n+                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                     }\n                 } else {\n                     for (int i = 0; i < n; ++i) {\n-                        eigenvalues[begin + i] = lambda - work[4 * i];\n+                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                     }                    \n                 }\n \n             begin = end;\n         }\n \n-        // sort the eigenvalues in decreasing order\n-        Arrays.sort(eigenvalues);\n-        for (int i = 0, j = eigenvalues.length - 1; i < j; ++i, --j) {\n-            final double tmp = eigenvalues[i];\n-            eigenvalues[i] = eigenvalues[j];\n-            eigenvalues[j] = tmp;\n+        // sort the realEigenvalues in decreasing order\n+        Arrays.sort(realEigenvalues);\n+        for (int i = 0, j = realEigenvalues.length - 1; i < j; ++i, --j) {\n+            final double tmp = realEigenvalues[i];\n+            realEigenvalues[i] = realEigenvalues[j];\n+            realEigenvalues[j] = tmp;\n         }\n \n     }\n      * @param index index of the first row of the block\n      */\n     private void process1RowBlock(final int index) {\n-        eigenvalues[index] = main[index];\n-    }\n-\n-    /**\n-     * Find eigenvalues in a block with 2 rows.\n+        realEigenvalues[index] = main[index];\n+    }\n+\n+    /**\n+     * Find realEigenvalues in a block with 2 rows.\n      * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n      * @param index index of the first row of the block\n      * @exception InvalidMatrixException if characteristic polynomial cannot be solved\n         }\n \n         final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n-        eigenvalues[index]     = largestRoot;\n-        eigenvalues[index + 1] = p / largestRoot;\n-\n-    }\n-\n-    /**\n-     * Find eigenvalues in a block with 3 rows.\n+        realEigenvalues[index]     = largestRoot;\n+        realEigenvalues[index + 1] = p / largestRoot;\n+\n+    }\n+\n+    /**\n+     * Find realEigenvalues in a block with 3 rows.\n      * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n      * @param index index of the first row of the block\n      * @exception InvalidMatrixException if diagonal elements are not positive\n         final double delta    = q * q * q + r * r;\n         if (delta >= 0) {\n             // in fact, there are solutions to the equation, but in the context\n-            // of symmetric eigenvalues problem, there should be three distinct\n+            // of symmetric realEigenvalues problem, there should be three distinct\n             // real roots, so we throw an error if this condition is not met\n             throw new InvalidMatrixException(\"cannot solve degree {0} equation\", new Object[] { 3 });           \n         }\n             z0 = z1;\n             z1 = t;\n         }\n-        eigenvalues[index]     = z0;\n-        eigenvalues[index + 1] = z1;\n-        eigenvalues[index + 2] = z2;\n-\n-    }\n-\n-    /**\n-     * Find eigenvalues using dqd/dqds algorithms.\n+        realEigenvalues[index]     = z0;\n+        realEigenvalues[index + 1] = z1;\n+        realEigenvalues[index + 2] = z2;\n+\n+    }\n+\n+    /**\n+     * Find realEigenvalues using dqd/dqds algorithms.\n      * <p>This implementation is based on Beresford N. Parlett\n      * and Osni A. Marques paper <a\n      * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n \n         g = 0.0;\n \n-        // step 1: accepting eigenvalues\n+        // step 1: accepting realEigenvalues\n         int deflatedEnd = end;\n         for (boolean deflating = true; deflating;) {\n \n                 (work[k - 9] <= TOLERANCE_2 * sigma) ||\n                 (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n \n-                // two eigenvalues found, deflate array\n+                // two realEigenvalues found, deflate array\n                 if (work[k - 3] > work[k - 7]) {\n                     final double tmp = work[k - 3];\n                     work[k - 3] = work[k - 7];\n                 deflatedEnd -= 2;\n             } else {\n \n-                // no more eigenvalues found, we need to iterate\n+                // no more realEigenvalues found, we need to iterate\n                 deflating = false;\n \n             }\n     }\n \n     /**\n-     * Compute an interval containing all eigenvalues of a block.\n+     * Compute an interval containing all realEigenvalues of a block.\n      * @param index index of the first row of the block\n      * @param n number of rows of the block\n-     * @return an interval containing the eigenvalues\n+     * @return an interval containing the realEigenvalues\n      */\n     private double[] eigenvaluesRange(final int index, final int n) {\n \n     }\n \n     /**\n-     * Count the number of eigenvalues below a point.\n-     * @param t value below which we must count the number of eigenvalues\n+     * Count the number of realEigenvalues below a point.\n+     * @param t value below which we must count the number of realEigenvalues\n      * @param index index of the first row of the block\n      * @param n number of rows of the block\n-     * @return number of eigenvalues smaller than t\n+     * @return number of realEigenvalues smaller than t\n      */\n     private int countEigenValues(final double t, final int index, final int n) {\n         double ratio = main[index] - t;\n      * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n      * @param start start index\n      * @param end end index\n-     * @param deflated number of eigenvalues just deflated\n+     * @param deflated number of realEigenvalues just deflated\n      */\n     private void computeShiftIncrement(final int start, final int end, final int deflated) {\n \n         int nn = 4 * end + pingPong - 1;\n         switch (deflated) {\n \n-        case 0 : // no eigenvalues deflated. \n+        case 0 : // no realEigenvalues deflated. \n             if (dMin == dN || dMin == dN1) {\n \n                 double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n             }\n             break;\n \n-        case 2 : // two eigenvalues deflated. use dMin2, dN2 for dMin and dN.\n+        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n \n             // cases 10 and 11.\n             if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { \n             }\n             break;\n \n-        default : // case 12, more than two eigenvalues deflated. no information.\n+        default : // case 12, more than two realEigenvalues deflated. no information.\n             tau   = 0.0;\n             tType = -12;\n         }\n \n         // compute eigenvectors\n         for (int i = 0; i < m; ++i) {\n-            eigenvectors[i] = findEigenvector(eigenvalues[i], d, l);\n+            eigenvectors[i] = findEigenvector(realEigenvalues[i], d, l);\n         }\n \n     }\n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(1.5, ed.getEigenvalue(0), 1.0e-15);\n+        assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);\n     }\n \n     public void testDimension2() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n-                    {       59.0, 12.0 },\n-                    { Double.NaN, 66.0 }\n+                    { 59.0, 12.0 },\n+                    { 12.0, 66.0 }\n             });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(75.0, ed.getEigenvalue(0), 1.0e-15);\n-        assertEquals(50.0, ed.getEigenvalue(1), 1.0e-15);\n+        assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);\n     }\n \n     public void testDimension3() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n-                                   {    39632.0,    -4824.0, -16560.0 },\n-                                   { Double.NaN,     8693.0,   7920.0 },\n-                                   { Double.NaN, Double.NaN,  17300.0 }\n+                                   {  39632.0, -4824.0, -16560.0 },\n+                                   {  -4824.0,  8693.0,   7920.0 },\n+                                   { -16560.0,  7920.0,  17300.0 }\n                                });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(50000.0, ed.getEigenvalue(0), 3.0e-11);\n-        assertEquals(12500.0, ed.getEigenvalue(1), 3.0e-11);\n-        assertEquals( 3125.0, ed.getEigenvalue(2), 3.0e-11);\n+        assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);\n+        assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);\n+        assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);\n     }\n \n     public void testDimension4WithSplit() {\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] {\n-                                   {      0.784,     -0.288,       0.000,  0.000 },\n-                                   { Double.NaN,      0.616,       0.000,  0.000 },\n-                                   { Double.NaN, Double.NaN,       0.164, -0.048 },\n-                                   { Double.NaN, Double.NaN,  Double.NaN,  0.136 }\n+                                   {  0.784, -0.288,  0.000,  0.000 },\n+                                   { -0.288,  0.616,  0.000,  0.000 },\n+                                   {  0.000,  0.000,  0.164, -0.048 },\n+                                   {  0.000,  0.000, -0.048,  0.136 }\n                                });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n-        assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n-        assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n-        assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n+        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n     }\n \n     public void testDimension4WithoutSplit() {\n                                    { -0.2976,  0.1152, -0.1344,  0.3872 }\n                                });\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n-        assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n-        assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n-        assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n+        assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n     }\n \n     /** test a matrix already in tridiagonal form. */\n             new EigenDecompositionImpl(t.getMainDiagonalRef(),\n                                        t.getSecondaryDiagonalRef(),\n                                        MathUtils.SAFE_MIN);\n-        double[] eigenValues = ed.getEigenvalues();\n+        double[] eigenValues = ed.getRealEigenvalues();\n         assertEquals(ref.length, eigenValues.length);\n         for (int i = 0; i < ref.length; ++i) {\n             assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);\n     /** test eigenvalues */\n     public void testEigenvalues() {\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-        double[] eigenValues = ed.getEigenvalues();\n+        double[] eigenValues = ed.getRealEigenvalues();\n         assertEquals(refValues.length, eigenValues.length);\n         for (int i = 0; i < refValues.length; ++i) {\n             assertEquals(refValues[i], eigenValues[i], 3.0e-15);\n         Arrays.sort(bigValues);\n         EigenDecomposition ed =\n             new EigenDecompositionImpl(createTestMatrix(r, bigValues), MathUtils.SAFE_MIN);\n-        double[] eigenValues = ed.getEigenvalues();\n+        double[] eigenValues = ed.getRealEigenvalues();\n         assertEquals(bigValues.length, eigenValues.length);\n         for (int i = 0; i < bigValues.length; ++i) {\n             assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n     public void testEigenvectors() {\n         EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         for (int i = 0; i < matrix.getRowDimension(); ++i) {\n-            double lambda = ed.getEigenvalue(i);\n+            double lambda = ed.getRealEigenvalue(i);\n             RealVector v  = ed.getEigenvector(i);\n             RealVector mV = matrix.operate(v);\n             assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);\n         double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n         RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n         EigenDecomposition ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);\n-        assertEquals(diagonal[0], ed.getEigenvalue(3), 2.0e-15);\n-        assertEquals(diagonal[1], ed.getEigenvalue(2), 2.0e-15);\n-        assertEquals(diagonal[2], ed.getEigenvalue(1), 2.0e-15);\n-        assertEquals(diagonal[3], ed.getEigenvalue(0), 2.0e-15);\n+        assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);\n+        assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);\n+        assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);\n+        assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);\n     }\n \n     /**\n      */\n     protected void checkEigenValues(double[] targetValues,\n             EigenDecomposition ed, double tolerance) {\n-        double[] observed = ed.getEigenvalues();\n+        double[] observed = ed.getRealEigenvalues();\n         for (int i = 0; i < observed.length; i++) {\n             assertTrue(isIncludedValue(observed[i], targetValues, tolerance));\n             assertTrue(isIncludedValue(targetValues[i], observed, tolerance));", "timestamp": 1230027238, "metainfo": ""}