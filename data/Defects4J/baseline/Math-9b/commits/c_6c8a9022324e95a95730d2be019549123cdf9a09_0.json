{"sha": "6c8a9022324e95a95730d2be019549123cdf9a09", "log": "MATH-894 Added new enum type to replace the integers used to represent the expansion mode. Deprecated methods and contructor that use the old representation.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math3/util/ResizableDoubleArray.java\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.MathInternalError;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n  * <code>numElements + 1.</code>  The determination of when the internal\n  * storage array is \"too large\" depends on the <code>expansionMode</code> and\n  * <code>contractionFactor</code> properties.  If  the <code>expansionMode</code>\n- * is <code>MULTIPLICATIVE_MODE</code>, contraction is triggered when the\n+ * is <code>MULTIPLICATIVE</code>, contraction is triggered when the\n  * ratio between storage array length and <code>numElements</code> exceeds\n  * <code>contractionFactor.</code>  If the <code>expansionMode</code>\n- * is <code>ADDITIVE_MODE,</code> the number of excess storage locations\n+ * is <code>ADDITIVE</code>, the number of excess storage locations\n  * is compared to <code>contractionFactor.</code>\n  * </p>\n  * <p>\n  * @version $Id$\n  */\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n-    /** Additive expansion mode. */\n+    /** Additive expansion mode.\n+     * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n+     */\n+    @Deprecated\n     public static final int ADDITIVE_MODE = 1;\n-    /** Multiplicative expansion mode. */\n+    /** Multiplicative expansion mode.\n+     * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n+     */\n+    @Deprecated\n     public static final int MULTIPLICATIVE_MODE = 0;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -3485529955529426875L;\n      * Determines whether array expansion by <code>expansionFactor</code>\n      * is additive or multiplicative.\n      */\n-    private int expansionMode = MULTIPLICATIVE_MODE;\n+    private ExpansionMode expansionMode = ExpansionMode.MULTIPLICATIVE;\n \n     /**\n      * The initial capacity of the array.  Initial capacity is not exposed as a\n      * </code>\n      */\n     private int startIndex = 0;\n+\n+    /**\n+     * Specification of expansion algorithm.\n+     */\n+    public static enum ExpansionMode {\n+        /** Multiplicative expansion mode. */\n+        MULTIPLICATIVE,\n+        /** Additive expansion mode. */\n+        ADDITIVE\n+    }\n \n     /**\n      * Create a ResizableArray with default properties.\n     /**\n      * <p>\n      * Create a ResizableArray with the specified properties.</p>\n-    * <p>\n+     * <p>\n      * Throws IllegalArgumentException if the following conditions are\n      * not met:\n      * <ul>\n      * @param contractionCriteria the contraction Criteria\n      * @param expansionMode  the expansion mode\n      * @throws MathIllegalArgumentException if parameters are not valid\n+     * @deprecated As of 3.1. Please use\n+     * {@link #ResizableDoubleArray(int,float,float,ExpansionMode,double[])}\n+     * instead.\n      */\n     public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n             float contractionCriteria, int expansionMode) throws MathIllegalArgumentException {\n-        this.expansionFactor = expansionFactor;\n+        this(initialCapacity,\n+             expansionFactor,\n+             contractionCriteria,\n+             expansionMode == ADDITIVE_MODE ?\n+             ExpansionMode.ADDITIVE :\n+             ExpansionMode.MULTIPLICATIVE,\n+             null);\n+        // XXX Just ot retain the expected failure in a unit test.\n+        // With the new \"enum\", that test will become obsolete.\n+        setExpansionMode(expansionMode);\n+    }\n+\n+    /**\n+     * Create a ResizableArray with the specified properties.\n+     * <br/>\n+     * Throws MathIllegalArgumentException if the following conditions are\n+     * not met:\n+     * <ul>\n+     *  <li>{@code initialCapacity > 0}</li>\n+     *  <li>{@code expansionFactor > 1}</li>\n+     *  <li>{@code contractionFactor >= expansionFactor}</li>\n+     * </ul>\n+     *\n+     * @param initialCapacity Initial size of the internal storage array.\n+     * @param expansionFactor The array will be expanded based on this\n+     * parameter.\n+     * @param contractionCriteria Contraction criteria.\n+     * @param expansionMode Expansion mode.\n+     * @param data Initial contents of the array.\n+     * @throws MathIllegalArgumentException if parameters are not valid.\n+     */\n+    public ResizableDoubleArray(int initialCapacity,\n+                                float expansionFactor,\n+                                float contractionCriteria,\n+                                ExpansionMode expansionMode,\n+                                double ... data)\n+        throws MathIllegalArgumentException {\n+\n+        setExpansionFactor(expansionFactor);\n         setContractionCriteria(contractionCriteria);\n+        setExpansionMode(expansionMode);\n         setInitialCapacity(initialCapacity);\n-        setExpansionMode(expansionMode);\n         internalArray = new double[initialCapacity];\n+        numElements = 0;\n+        startIndex = 0;\n+\n+        if (data != null) {\n+            addElements(data);\n+        }\n     }\n \n     /**\n         // is 1.000000000000000001.  The newly calculated size will be\n         // rounded up to 2 after the multiplication is performed.\n         int newSize = 0;\n-        if (expansionMode == MULTIPLICATIVE_MODE) {\n+        if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\n             newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);\n         } else {\n             newSize = internalArray.length + FastMath.round(expansionFactor);\n     }\n \n     /**\n-     * The <code>expansionMode</code> determines whether the internal storage\n-     * array grows additively (ADDITIVE_MODE) or multiplicatively\n-     * (MULTIPLICATIVE_MODE) when it is expanded.\n-     *\n-     * @return Returns the expansionMode.\n+     * The expansion mode determines whether the internal storage\n+     * array grows additively or multiplicatively when it is expanded.\n+     *\n+     * @return the expansion mode.\n+     * @deprecated As of 3.1. Return value to be changed to\n+     * {@link ExpansionMode} in 4.0.\n      */\n     public int getExpansionMode() {\n-        return expansionMode;\n+        switch (expansionMode) {\n+        case MULTIPLICATIVE:\n+            return MULTIPLICATIVE_MODE;\n+        case ADDITIVE:\n+            return ADDITIVE_MODE;\n+        default:\n+            throw new MathInternalError(); // Should never happen.\n+        }\n     }\n \n     /**\n      *\n      * @param expansionMode The expansionMode to set.\n      * @throws MathIllegalArgumentException if the specified mode value is not valid.\n-     */\n+     * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\n+     */\n+    @Deprecated\n     public void setExpansionMode(int expansionMode)\n         throws MathIllegalArgumentException {\n         if (expansionMode != MULTIPLICATIVE_MODE &&\n                                                    ADDITIVE_MODE, \"ADDITIVE_MODE\");\n         }\n         synchronized(this) {\n-            this.expansionMode = expansionMode;\n-        }\n+            if (expansionMode == MULTIPLICATIVE_MODE) {\n+                setExpansionMode(ExpansionMode.MULTIPLICATIVE);\n+            } else if (expansionMode == ADDITIVE_MODE) {\n+                setExpansionMode(ExpansionMode.ADDITIVE);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets the {@link ExpansionMode expansion mode}.\n+     *\n+     * @param expansionMode Expansion mode to use for resizing the array.\n+     */\n+    public void setExpansionMode(ExpansionMode expansionMode) {\n+        this.expansionMode = expansionMode;\n     }\n \n     /**\n      * @return true if array satisfies the contraction criteria\n      */\n     private synchronized boolean shouldContract() {\n-        if (expansionMode == MULTIPLICATIVE_MODE) {\n+        if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\n             return (internalArray.length / ((float) numElements)) > contractionCriteria;\n         } else {\n             return (internalArray.length - numElements) > contractionCriteria;\n         final int[] hashData = new int[7];\n         hashData[0] = new Float(expansionFactor).hashCode();\n         hashData[1] = new Float(contractionCriteria).hashCode();\n-        hashData[2] = expansionMode;\n+        hashData[2] = expansionMode.hashCode();\n         hashData[3] = Arrays.hashCode(internalArray);\n         hashData[4] = initialCapacity;\n         hashData[5] = numElements;", "timestamp": 1352821824, "metainfo": ""}