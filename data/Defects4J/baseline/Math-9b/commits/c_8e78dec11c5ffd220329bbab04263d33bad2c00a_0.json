{"sha": "8e78dec11c5ffd220329bbab04263d33bad2c00a", "log": "Fixed implementation, improved documentation.   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n import java.io.Serializable;\n \n /**\n- * Computes a natural spline interpolation for the data set.\n+ * Computes a natural (a.k.a. \"free\", \"unclamped\") cubic spline interpolation for the data set.\n+ * <p>\n+ * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}\n+ * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  \n+ * x[0] < x[i] ... < x[n].  The x values are referred to as \"knot points.\"\n+ * <p>\n+ * The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest\n+ * knot point and strictly less than the largest knot point is computed by finding the subinterval to which\n+ * x belongs and computing the value of the corresponding polynomial at <code>x - x[i] </code> where\n+ * <code>i</code> is the index of the subinterval.  See {@link PolynomialSplineFunction} for more details.\n+ * <p>\n+ * The interpolating polynomials satisfy: <ol>\n+ * <li>The value of the PolynomialSplineFunction at each of the input x values equals the \n+ *  corresponding y value.</li>\n+ * <li>Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials \n+ *  \"match up\" at the knot points, as do their first and second derivatives).</li>\n+ * </ol>\n+ * <p>\n+ * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires, \n+ * <u>Numerical Analysis</u>, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131.\n  *\n- * @version $Revision: 1.14 $ $Date: 2004/02/18 03:24:19 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/02 21:16:21 $\n  *\n  */\n public class SplineInterpolator implements UnivariateRealInterpolator, Serializable {\n-    /** the natural spline coefficients. */\n-    private double[][] c = null;\n-\n+    \n     /**\n      * Computes an interpolating function for the data set.\n-     * @param xval the arguments for the interpolation points\n-     * @param yval the values for the interpolation points\n+     * @param x the arguments for the interpolation points\n+     * @param y the values for the interpolation points\n      * @return a function which interpolates the data set\n      */\n-    public UnivariateRealFunction interpolate(double[] xval, double[] yval) {\n-        if (xval.length != yval.length) {\n+    public UnivariateRealFunction interpolate(double x[], double y[]) {\n+        if (x.length != y.length) {\n             throw new IllegalArgumentException(\"Dataset arrays must have same length.\");\n         }\n-\n-        // TODO: What's this good for? Did I really write this???\n-        if (c == null) {\n-            // Number of intervals. The number of data points is N+1.\n-            int n = xval.length - 1;\n-            // Check whether the xval vector has ascending values.\n-            // TODO: Separation should be checked too (not implemented: which criteria?).\n-            for (int i = 0; i < n; i++) {\n-                if (xval[i] >= xval[i + 1]) {\n-                    throw new IllegalArgumentException(\"Dataset must specify sorted, ascending x values.\");\n-                }\n-            }\n-            // Vectors for the equation system. There are n-1 equations for the unknowns s[i] (1<=i<=N-1),\n-            // which are second order derivatives for the spline at xval[i]. At the end points, s[0]=s[N]=0.\n-            // Vector indices are offset by -1, except for the lower diagonal vector where the offset is -2. Layout of the equation system:\n-            // d[0]*s[1]+u[0]*s[2]                                           = b[0]\n-            // l[0]*s[1]+d[1]*s[2]+u[1]*s[3]                                 = b[1]\n-            //           l[1]*s[2]+d[2]*s[3]+u[2]*s[4]                       = b[2]\n-            //                           ...\n-            //                     l[N-4]*s[N-3]+d[N-3]*s[N-2]+u[N-3]*s[N-1] = b[N-3]\n-            //                                   l[N-3]*s[N-2]+d[N-2]*s[N-1] = b[N-2]\n-            // Vector b is the right hand side (RHS) of the system.\n-            double b[] = new double[n - 1];\n-            // Vector d is diagonal of the matrix and also holds the computed solution.\n-            double d[] = new double[n - 1];\n-            // Setup right hand side and diagonal.\n-            double dquot = (yval[1] - yval[0]) / (xval[1] - xval[0]);\n-            for (int i = 0; i < n - 1; i++) {\n-                double dquotNext = \n-                    (yval[i + 2] - yval[i + 1]) / (xval[i + 2] - xval[i + 1]);\n-                b[i] = 6.0 * (dquotNext - dquot);\n-                d[i] = 2.0 * (xval[i + 2] - xval[i]);\n-                dquot = dquotNext;\n-            }\n-            // u[] and l[] (for the upper and lower diagonal respectively) are not\n-            // really needed, the computation is folded into the system solving loops.\n-            // Keep this for documentation purposes. The computation is folded into\n-            // the loops computing the solution.\n-            //double u[] = new double[n - 2]; // upper diagonal\n-            //double l[] = new double[n - 2]; // lower diagonal\n-            // Set up upper and lower diagonal. Keep the offsets in mind.\n-            //for (int i = 0; i < n - 2; i++) {\n-            //  u[i] = xval[i + 2] - xval[i + 1];\n-            //  l[i] = xval[i + 2] - xval[i + 1];\n-            //}\n-            // Solve the system: forward pass.\n-            for (int i = 0; i < n - 2; i++) {\n-                double delta = xval[i + 2] - xval[i + 1];\n-                double deltaquot = delta / d[i];\n-                d[i + 1] -= delta * deltaquot;\n-                b[i + 1] -= b[i] * deltaquot;\n-            }\n-            // Solve the system: backward pass.\n-            d[n - 2] = b[n - 2] / d[n - 2];\n-            for (int i = n - 3; i >= 0; i--) {\n-                d[i] = (b[i] - (xval[i + 2] - xval[i + 1]) * d[i + 1]) / d[i];\n-            }\n-            // Compute coefficients as usual polynomial coefficients.\n-            // Not the best with respect to roundoff on evaluation, but simple.\n-            c = new double[n][4];\n-            double delta = xval[1] - xval[0];\n-            c[0][3] = d[0] / delta / 6.0;\n-            c[0][2] = 0.0;\n-            c[0][1] = (yval[1] - yval[0]) / delta - d[0] * delta / 6.0;\n-            for (int i = 1; i < n - 2; i++) {\n-                delta = xval[i + 1] - xval[i];\n-                c[i][3] = (d[i] - d[i - 1]) / delta / 6.0;\n-                c[i][2] = d[i - 1] / 2.0;\n-                c[i][1] =\n-                    (yval[i + 1] - yval[i]) / delta -\n-                        (d[i] / 2.0 - d[i - 1]) * delta / 3.0;\n-            }\n-            delta = (xval[n] - xval[n - 1]);\n-            c[n - 1][3] = -d[n - 2] / delta / 6.0;\n-            c[n - 1][2] = d[n - 2] / 2.0;\n-            c[n - 1][1] =\n-                (yval[n] - yval[n - 1]) / delta - d[n - 2] * delta / 3.0;\n-            for (int i = 0; i < n; i++) {\n-                c[i][0] = yval[i];\n+        \n+        if (x.length < 3) {\n+            throw new IllegalArgumentException\n+                (\"At least 3 datapoints are required to compute a spline interpolant\");\n+        }\n+        \n+        // Number of intervals.  The number of data points is n + 1.\n+        int n = x.length - 1;   \n+        \n+        for (int i = 0; i < n; i++) {\n+            if (x[i]  >= x[i + 1]) {\n+                throw new IllegalArgumentException(\"Dataset x values must be strictly increasing.\");\n             }\n         }\n-\n-        // TODO: copy xval, unless copied in CubicSplineFunction constructor\n-        return new CubicSplineFunction(xval, c);\n+        \n+        double h[] = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            h[i] = x[i + 1] - x[i];\n+        }\n+        \n+        double alpha[] = new double[n];\n+        for (int i = 1; i < n; i++) {\n+            alpha[i] = 3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /\n+                            (h[i - 1] * h[i]);\n+        }\n+        \n+        double l[] = new double[n + 1];\n+        double mu[] = new double[n];\n+        double z[] = new double[n + 1];\n+        l[0] = 1d;\n+        mu[0] = 0d;\n+        z[0] = 0d;\n+        for (int i = 1; i < n; i++) {\n+            l[i] = 2d * (x[i+1]  - x[i - 1]) - h[i - 1] * mu[i -1];\n+            mu[i] = h[i] / l[i];\n+            z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];\n+        }\n+       \n+        // cubic spline coefficients --  b is linear, c quadratic, d is cubic (original y's are constants)\n+        double b[] = new double[n];\n+        double c[] = new double[n + 1];\n+        double d[] = new double[n];\n+        \n+        l[n] = 1d;\n+        z[n] = 0d;\n+        c[n] = 0d;\n+        \n+        for (int j = n -1; j >=0; j--) {\n+            c[j] = z[j] - mu[j] * c[j + 1];\n+            b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;\n+            d[j] = (c[j + 1] - c[j]) / (3d * h[j]);\n+        }\n+        \n+        PolynomialFunction polynomials[] = new PolynomialFunction[n];\n+        double coefficients[] = new double[4];\n+        for (int i = 0; i < n; i++) {\n+            coefficients[0] = y[i];\n+            coefficients[1] = b[i];\n+            coefficients[2] = c[i];\n+            coefficients[3] = d[i];\n+            polynomials[i] = new PolynomialFunction(coefficients);\n+        }\n+        \n+        return new PolynomialSplineFunction(x, polynomials);\n     }\n \n }", "timestamp": 1080940581, "metainfo": ""}