{"sha": "3f0b2ae731c85b184f2bc569aad5557c7bbfa822", "log": "Eliminated MathException from distribution interfaces and impls.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws OutOfRangeException if {@code p} is not a valid probability.\n      */\n-    public double inverseCumulativeProbability(final double p)\n-        throws MathException {\n-        try {\n+    public double inverseCumulativeProbability(final double p) {\n \n         if (p < 0.0 || p > 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n         UnivariateRealFunction rootFindingFunction =\n             new UnivariateRealFunction() {\n             public double value(double x) {\n-                double ret = Double.NaN;\n-                try {\n-                    ret = cumulativeProbability(x) - p;\n-                } catch (MathException ex) {\n-                    throw new WrappingException(ex);\n-                }\n-                if (Double.isNaN(ret)) {\n-                    throw new WrappingException(new MathException(LocalizedFormats.CUMULATIVE_PROBABILITY_RETURNED_NAN, x, p));\n-                }\n-                return ret;\n+                return cumulativeProbability(x) - p;\n             }\n         };\n \n                 return upperBound;\n             }\n             // Failed bracket convergence was not because of corner solution\n-            throw new MathException(ex);\n+            throw new MathInternalError(ex);\n         }\n \n         // find root\n                 // absolute accuracy different from the default.\n                 bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n         return root;\n-\n-        } catch (WrappingException we) {\n-            throw we.getWrapped();\n-        }\n-    }\n-\n-    /** Local exception wrapping a MathException. */\n-    private static class WrappingException extends RuntimeException {\n-\n-        /** Serializable UID. */\n-        private static final long serialVersionUID = -2102700399222815344L;\n-\n-        /** Wrapped exception. */\n-        private final MathException wrapped;\n-\n-        /** simple constructor.\n-         * @param wrapped exception to wrap\n-         */\n-        public WrappingException(final MathException wrapped) {\n-            this.wrapped = wrapped;\n-        }\n-\n-        /** Get the wrapped exception.\n-         * @return wrapped exception\n-         */\n-        public MathException getWrapped() {\n-            return wrapped;\n-        }\n-\n     }\n \n     /**\n      * </a>\n      *\n      * @return a random value.\n-     * @throws MathException if an error occurs generating the random value.\n-     * @since 2.2\n-     */\n-    public double sample() throws MathException {\n+     * @since 2.2\n+     */\n+    public double sample() {\n         return randomData.nextInversionDeviate(this);\n     }\n \n      *\n      * @param sampleSize Number of random values to generate.\n      * @return an array representing the random sample.\n-     * @throws MathException if an error occurs generating the sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not positive.\n      * @since 2.2\n      */\n-    public double[] sample(int sampleSize) throws MathException {\n+    public double[] sample(int sampleSize) {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                                                    sampleSize);\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n      * @return the probability that a random variable with this distribution\n      * will take a value between {@code x0} and {@code x1},\n      * including the endpoints.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws NumberIsTooLargeException if {@code x0 > x1}\n      */\n-    public double cumulativeProbability(double x0, double x1)\n-        throws MathException {\n+    public double cumulativeProbability(double x0, double x1) {\n         if (x0 > x1) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n                                                 x0, x1, true);\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.OutOfRangeException;\n      * @param x Value at which the distribution function is evaluated.\n      * @return the cumulative probability that a random variable with this\n      * distribution takes a value less than or equal to {@code x}.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException {\n+     */\n+    public double cumulativeProbability(double x) {\n         return cumulativeProbability((int) FastMath.floor(x));\n     }\n \n      * @return the probability that a random variable with this distribution\n      * will take a value between {@code x0} and {@code x1},\n      * including the endpoints.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws NumberIsTooSmallException if {@code x1 > x0}.\n      */\n     @Override\n-    public double cumulativeProbability(double x0, double x1)\n-        throws MathException {\n+    public double cumulativeProbability(double x0, double x1) {\n         if (x1 < x0) {\n             throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n                                                 x1, x0, true);\n      *\n      * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n-     */\n-    public abstract double cumulativeProbability(int x) throws MathException;\n+     */\n+    public abstract double cumulativeProbability(int x);\n \n     /**\n      * For a random variable {@code X} whose values are distributed according\n      * @param x0 Inclusive lower bound.\n      * @param x1 Inclusive upper bound.\n      * @return the cumulative probability.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws NumberIsTooSmallException {@code if x0 > x1}.\n      */\n-    public double cumulativeProbability(int x0, int x1) throws MathException {\n+    public double cumulativeProbability(int x0, int x1) {\n         if (x1 < x0) {\n             throw new NumberIsTooSmallException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n                                                 x1, x0, true);\n      *\n      * @param p Desired probability.\n      * @return the largest {@code x} such that {@code P(X < x) <= p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n-    public int inverseCumulativeProbability(final double p) throws MathException{\n+    public int inverseCumulativeProbability(final double p) {\n         if (p < 0 || p > 1) {\n             throw new OutOfRangeException(p, 0, 1);\n         }\n      *\n      * @return a random value.\n      * @since 2.2\n-     * @throws MathException if an error occurs generating the random value.\n-     */\n-    public int sample() throws MathException {\n+     */\n+    public int sample() {\n         return randomData.nextInversionDeviate(this);\n     }\n \n      * @param sampleSize number of random values to generate.\n      * @since 2.2\n      * @return an array representing the random sample.\n-     * @throws MathException if an error occurs generating the sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize <= 0}.\n      */\n-    public int[] sample(int sampleSize) throws MathException {\n+    public int[] sample(int sampleSize) {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                                                    sampleSize);\n     /**\n      * Computes the cumulative probability function and checks for NaN\n      * values returned.\n-     * Throws MathException if the value is NaN. Rethrows any MathException encountered\n+     * Throws MathInternalError if the value is NaN. Rethrows any Exception encountered\n      * evaluating the cumulative probability function. Throws\n-     * MathException if the cumulative probability function returns NaN.\n+     * MathInternalError if the cumulative probability function returns NaN.\n      *\n      * @param argument Input value.\n      * @return the cumulative probability.\n-     * @throws MathException if the cumulative probability is NaN\n+     * @throws MathInternalError if the cumulative probability is NaN\n      */\n     private double checkedCumulativeProbability(int argument)\n-        throws MathException {\n+        throws MathInternalError {\n         double result = Double.NaN;\n             result = cumulativeProbability(argument);\n         if (Double.isNaN(result)) {\n-            throw new MathException(LocalizedFormats.DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument);\n+            throw new MathInternalError(\n+                    LocalizedFormats.DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument);\n         }\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n  */\n package org.apache.commons.math.distribution;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double inverseCumulativeProbability(double p) throws MathException {\n+    public double inverseCumulativeProbability(double p)  {\n         if (p == 0) {\n             return 0;\n         } else if (p == 1) {\n     }\n \n     /** {@inheritDoc} */\n-    public double cumulativeProbability(double x) throws MathException {\n+    public double cumulativeProbability(double x)  {\n         if (x <= 0) {\n             return 0;\n         } else if (x >= 1) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double cumulativeProbability(double x0, double x1) throws MathException {\n+    public double cumulativeProbability(double x0, double x1)  {\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      *\n      * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be computed\n      * due to convergence or other numerical errors.\n      */\n     @Override\n-    public double cumulativeProbability(int x) throws MathException {\n+    public double cumulativeProbability(int x) {\n         double ret;\n         if (x < 0) {\n             ret = 0.0;\n      *\n      * @param p Desired probability.\n      * @return the largest {@code x} such that {@code P(X < x) <= p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     @Override\n-    public int inverseCumulativeProbability(final double p)\n-            throws MathException {\n+    public int inverseCumulativeProbability(final double p) {\n         // handle extreme values explicitly\n         if (p == 0) {\n             return -1;\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n \n /**\n  * The default implementation of {@link ChiSquaredDistribution}\n      *\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n-     * @throws MathException if the cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException {\n+     */\n+    public double cumulativeProbability(double x)  {\n         return gamma.cumulativeProbability(x);\n     }\n \n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws org.apache.commons.math.exception.OutOfRangeException if\n      * {@code p} is not a valid probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p)\n-        throws MathException {\n+    public double inverseCumulativeProbability(final double p) {\n         if (p == 0) {\n             return 0d;\n         }\n--- a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import org.apache.commons.math.MathException;\n-\n /**\n  * Base interface for continuous distributions.\n  *\n      *\n      * @param p Cumulative probability.\n      * @return {@code x} such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n      */\n-    double inverseCumulativeProbability(double p) throws MathException;\n+    double inverseCumulativeProbability(double p);\n \n     /**\n      * Probability density for a particular point.\n      * Generate a random value sampled from this distribution.\n      *\n      * @return a random value.\n-     * @throws MathException if an error occurs generating the random value.\n      * @since 3.0\n      */\n-    double sample() throws MathException;\n+    double sample();\n \n     /**\n      * Generate a random sample from the distribution.\n      *\n      * @param sampleSize number of random values to generate.\n      * @return an array representing the random sample.\n-     * @throws MathException if an error occurs generating the sample.\n      * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n      * if {@code sampleSize} is not positive.\n      * @since 3.0\n      */\n-    double[] sample(int sampleSize) throws MathException;\n+    double[] sample(int sampleSize);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/Distribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/Distribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import org.apache.commons.math.MathException;\n-\n /**\n  * Base interface for probability distributions.\n  *\n      * @param x the value at which the distribution function is evaluated.\n      * @return the probability that a random variable with this\n      * distribution takes a value less than or equal to <code>x</code>\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      */\n-    double cumulativeProbability(double x) throws MathException;\n+    double cumulativeProbability(double x);\n \n     /**\n      * For a random variable X whose values are distributed according\n      * @return the probability that a random variable with this distribution\n      * will take a value between <code>x0</code> and <code>x1</code>,\n      * including the endpoints\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if <code>x0 > x1</code>\n      */\n-    double cumulativeProbability(double x0, double x1) throws MathException;\n+    double cumulativeProbability(double x0, double x1);\n \n     /**\n      * Use this method to get the numerical value of the mean of this\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      *\n      * @param x Value at which the CDF is evaluated.\n      * @return the CDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException {\n+     */\n+    public double cumulativeProbability(double x)  {\n         double ret;\n         if (x <= 0.0) {\n             ret = 0.0;\n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     @Override\n-    public double inverseCumulativeProbability(double p) throws MathException {\n+    public double inverseCumulativeProbability(double p) {\n         double ret;\n \n         if (p < 0.0 || p > 1.0) {\n      * uniform deviates.</p>\n      *\n      * @return a random value.\n-     * @throws MathException if an error occurs generating the random value.\n      * @since 2.2\n      */\n     @Override\n-    public double sample() throws MathException {\n+    public double sample() {\n         return randomData.nextExponential(mean);\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n      *\n      * @param x Value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n-     * @throws MathException if the cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException {\n+     */\n+    public double cumulativeProbability(double x)  {\n         double ret;\n         if (x <= 0) {\n             ret = 0;\n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if {@code p} is not a valid\n      * probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p)\n-        throws MathException {\n+    public double inverseCumulativeProbability(final double p) {\n         if (p == 0) {\n             return 0;\n         }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n      *\n      * @param x Value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException{\n+     */\n+    public double cumulativeProbability(double x) {\n         double ret;\n \n         if (x <= 0) {\n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n      * @throws org.apache.commons.math.exception.OutOfRangeException if\n      * {@code p} is not a valid probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p)\n-        throws MathException {\n+    public double inverseCumulativeProbability(final double p) {\n         if (p == 0) {\n             return 0;\n         }\n--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n-\n-import org.apache.commons.math.MathException;\n \n /**\n  * Interface for discrete distributions of integer-valued random variables.\n      *\n      * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n-     * @throws MathException if the cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n      */\n-    double cumulativeProbability(int x) throws MathException;\n+    double cumulativeProbability(int x);\n \n     /**\n      * For this distribution, {@code X}, this method returns\n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n      * @return the cumulative probability.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if {@code x0 > x1}.\n      */\n-    double cumulativeProbability(int x0, int x1) throws MathException;\n+    double cumulativeProbability(int x0, int x1);\n \n     /**\n      * For this distribution, {@code X}, this method returns the largest\n      *\n      * @param p Cumulative probability.\n      * @return the largest {@code x} such that {@code P(X < x) <= p}.\n-     * @throws MathException if the inverse cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if {@code p} is not between 0 and 1\n      * (inclusive).\n      */\n-    int inverseCumulativeProbability(double p) throws MathException;\n+    int inverseCumulativeProbability(double p);\n \n     /**\n      * Reseed the random generator used to generate samples.\n      * Generate a random value sampled from this distribution.\n      *\n      * @return a random value.\n-     * @throws MathException if an error occurs generating the random value.\n      * @since 3.0\n      */\n-    int sample() throws MathException;\n+    int sample();\n \n     /**\n      * Generate a random sample from the distribution.\n      *\n      * @param sampleSize number of random values to generate.\n      * @return an array representing the random sample.\n-     * @throws MathException if an error occurs generating the sample.\n      * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n      * if {@code sampleSize} is not positive.\n      * @since 3.0\n      */\n-    int[] sample(int sampleSize) throws MathException;\n+    int[] sample(int sampleSize);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      *\n      * @param x Value at which the CDF is evaluated.\n      * @return CDF evaluated at {@code x}.\n-     * @throws MathException if the algorithm fails to converge\n-     */\n-    public double cumulativeProbability(double x) throws MathException {\n+     */\n+    public double cumulativeProbability(double x)  {\n         final double dev = x - mean;\n         if (FastMath.abs(dev) > 40 * standardDeviation) {\n             return dev < 0 ? 0.0d : 1.0d;\n      * {@inheritDoc}\n      */\n     @Override\n-    public double cumulativeProbability(double x0, double x1) throws MathException {\n+    public double cumulativeProbability(double x0, double x1)  {\n         if (x0 > x1) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n                                                 x0, x1, true);\n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n      * @throws org.apache.commons.math.exception.OutOfRangeException if\n      * {@code p} is not a valid probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p)\n-    throws MathException {\n+     {\n         if (p == 0) {\n             return Double.NEGATIVE_INFINITY;\n         }\n      *\n      * @return a random value.\n      * @since 2.2\n-     * @throws MathException if an error occurs generating the random value.\n-     */\n-    @Override\n-    public double sample() throws MathException {\n+     */\n+    @Override\n+    public double sample()  {\n         return randomData.nextGaussian(mean, standardDeviation);\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      *\n      * @param x Value at which the PDF is evaluated.\n      * @return PDF for this distribution.\n-     * @throws MathException if the cumulative probability can not be computed\n      * due to convergence or other numerical errors.\n      */\n     @Override\n-    public double cumulativeProbability(int x) throws MathException {\n+    public double cumulativeProbability(int x) {\n         double ret;\n         if (x < 0) {\n             ret = 0.0;\n      *\n      * @param p Desired probability.\n      * @return the largest {@code x} such that {@code P(X <= x) <= p}.\n-     * @throws MathException if the inverse cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n      * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     @Override\n-    public int inverseCumulativeProbability(final double p)\n-        throws MathException {\n+    public int inverseCumulativeProbability(final double p) {\n         int ret;\n \n         // handle extreme values explicitly\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n-import org.apache.commons.math.MathException;\n \n /**\n  * Interface representing the Poisson Distribution.\n      *\n      * @param x the upper bound, inclusive\n      * @return the distribution function value calculated using a normal approximation\n-     * @throws MathException if an error occurs computing the normal approximation\n      */\n-    double normalApproximateProbability(int x) throws MathException;\n+    double normalApproximateProbability(int x) ;\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n      *\n      * @param x Value at which the PDF is evaluated.\n      * @return the Poisson distribution function evaluated at {@code x}.\n-     * @throws MathException if the cumulative probability cannot be computed\n      * due to convergence or other numerical errors.\n      */\n     @Override\n-    public double cumulativeProbability(int x) throws MathException {\n+    public double cumulativeProbability(int x)  {\n         if (x < 0) {\n             return 0;\n         }\n      * @param x Upper bound, inclusive.\n      * @return the distribution function value calculated using a normal\n      * approximation.\n-     * @throws MathException if an error occurs computing the normal\n      * approximation.\n      */\n-    public double normalApproximateProbability(int x) throws MathException {\n+    public double normalApproximateProbability(int x)  {\n         // calculate the probability using half-correction\n         return normal.cumulativeProbability(x + 0.5);\n     }\n      *\n      * @return a random value.\n      * @since 2.2\n-     * @throws MathException if an error occurs generating the random value.\n-     */\n-    @Override\n-    public int sample() throws MathException {\n+     */\n+    @Override\n+    public int sample()  {\n         return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n     }\n \n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n      *\n      * @param x Value at which the CDF is evaluated.\n      * @return CDF evaluated at {@code x}.\n-     * @throws MathException if the cumulative probability can not be\n-     * computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException{\n+     */\n+    public double cumulativeProbability(double x) {\n         double ret;\n         if (x == 0) {\n             ret = 0.5;\n      *\n      * @param p Desired probability.\n      * @return {@code x}, such that {@code P(X < x) = p}.\n-     * @throws MathException if the inverse cumulative probability cannot be\n-     * computed due to convergence or other numerical errors.\n      * @throws org.apache.commons.math.exception.OutOfRangeException if\n      * {@code p} is not a valid probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p)\n-    throws MathException {\n+    public double inverseCumulativeProbability(final double p) {\n         if (p == 0) {\n             return Double.NEGATIVE_INFINITY;\n         }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import java.security.SecureRandom;\n import java.util.Collection;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.distribution.BetaDistributionImpl;\n import org.apache.commons.math.distribution.BinomialDistributionImpl;\n import org.apache.commons.math.distribution.CauchyDistributionImpl;\n      * @param alpha first distribution shape parameter\n      * @param beta second distribution shape parameter\n      * @return random value sampled from the beta(alpha, beta) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public double nextBeta(double alpha, double beta) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextBeta(double alpha, double beta) {\n         return nextInversionDeviate(new BetaDistributionImpl(alpha, beta));\n     }\n \n      * @param numberOfTrials number of trials of the Binomial distribution\n      * @param probabilityOfSuccess probability of success of the Binomial distribution\n      * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) throws MathException {\n+     * @since 2.2\n+     */\n+    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {\n         return nextInversionDeviate(new BinomialDistributionImpl(numberOfTrials, probabilityOfSuccess));\n     }\n \n      * @param median the median of the Cauchy distribution\n      * @param scale the scale parameter of the Cauchy distribution\n      * @return random value sampled from the Cauchy(median, scale) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public double nextCauchy(double median, double scale) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextCauchy(double median, double scale) {\n         return nextInversionDeviate(new CauchyDistributionImpl(median, scale));\n     }\n \n      *\n      * @param df the degrees of freedom of the ChiSquare distribution\n      * @return random value sampled from the ChiSquare(df) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public double nextChiSquare(double df) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextChiSquare(double df) {\n         return nextInversionDeviate(new ChiSquaredDistributionImpl(df));\n     }\n \n      * @param numeratorDf the numerator degrees of freedom of the F distribution\n      * @param denominatorDf the denominator degrees of freedom of the F distribution\n      * @return random value sampled from the F(numeratorDf, denominatorDf) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public double nextF(double numeratorDf, double denominatorDf) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextF(double numeratorDf, double denominatorDf) {\n         return nextInversionDeviate(new FDistributionImpl(numeratorDf, denominatorDf));\n     }\n \n      * @param shape the median of the Gamma distribution\n      * @param scale the scale parameter of the Gamma distribution\n      * @return random value sampled from the Gamma(shape, scale) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public double nextGamma(double shape, double scale) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextGamma(double shape, double scale) {\n         if (shape < 1) {\n             // [1]: p. 228, Algorithm GS\n \n      * @param numberOfSuccesses number of successes in the population of the Hypergeometric distribution\n      * @param sampleSize the sample size of the Hypergeometric distribution\n      * @return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) throws MathException {\n+     * @since 2.2\n+     */\n+    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) {\n         return nextInversionDeviate(new HypergeometricDistributionImpl(populationSize, numberOfSuccesses, sampleSize));\n     }\n \n      * @param r the number of successes of the Pascal distribution\n      * @param p the probability of success of the Pascal distribution\n      * @return random value sampled from the Pascal(r, p) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public int nextPascal(int r, double p) throws MathException {\n+     * @since 2.2\n+     */\n+    public int nextPascal(int r, double p) {\n         return nextInversionDeviate(new PascalDistributionImpl(r, p));\n     }\n \n      *\n      * @param df the degrees of freedom of the T distribution\n      * @return random value from the T(df) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public double nextT(double df) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextT(double df) {\n         return nextInversionDeviate(new TDistributionImpl(df));\n     }\n \n      * @param shape the shape parameter of the Weibull distribution\n      * @param scale the scale parameter of the Weibull distribution\n      * @return random value sampled from the Weibull(shape, size) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public double nextWeibull(double shape, double scale) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextWeibull(double shape, double scale) {\n         return nextInversionDeviate(new WeibullDistributionImpl(shape, scale));\n     }\n \n      * @param numberOfElements the number of elements of the ZipfDistribution\n      * @param exponent the exponent of the ZipfDistribution\n      * @return random value sampled from the Zipf(numberOfElements, exponent) distribution\n-     * @throws MathException if an error occurs generating the random value\n-     * @since 2.2\n-     */\n-    public int nextZipf(int numberOfElements, double exponent) throws MathException {\n+     * @since 2.2\n+     */\n+    public int nextZipf(int numberOfElements, double exponent) {\n         return nextInversionDeviate(new ZipfDistributionImpl(numberOfElements, exponent));\n     }\n \n      *\n      * @param distribution Continuous distribution to generate a random value from\n      * @return a random value sampled from the given distribution\n-     * @throws MathException if an error occurs computing the inverse cumulative distribution function\n-     * @since 2.2\n-     */\n-    public double nextInversionDeviate(ContinuousDistribution distribution) throws MathException {\n+     * @since 2.2\n+     */\n+    public double nextInversionDeviate(ContinuousDistribution distribution) {\n         return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n \n     }\n      *\n      * @param distribution Integer distribution to generate a random value from\n      * @return a random value sampled from the given distribution\n-     * @throws MathException if an error occurs computing the inverse cumulative distribution function\n-     * @since 2.2\n-     */\n-    public int nextInversionDeviate(IntegerDistribution distribution) throws MathException {\n+     * @since 2.2\n+     */\n+    public int nextInversionDeviate(IntegerDistribution distribution) {\n         final double target = nextUniform(0, 1);\n         final int glb = distribution.inverseCumulativeProbability(target);\n         if (distribution.cumulativeProbability(glb) == 1.0d) { // No mass above\n--- a/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java\n \n package org.apache.commons.math.distribution;\n \n-import org.apache.commons.math.MathException;\n import org.junit.Assert;\n import org.junit.Test;\n \n         }\n \n         @Override\n-        public double cumulativeProbability(int x) throws MathException {\n+        public double cumulativeProbability(int x) {\n             if (x < 1) {\n                 return 0;\n             } else if (x >= 6) {\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n  */\n package org.apache.commons.math.distribution;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.junit.Assert;\n                         Assert.assertTrue(\"Zero cum probaility returned for mean = \" +\n                                 mean + \" x = \" + x, p > 0);\n                     }\n-                } catch (MathException ex) {\n+                } catch (Exception ex) {\n                     Assert.fail(\"mean of \" + mean + \" and x of \" + x + \" caused \" + ex.getMessage());\n                 }\n                 x -= dx;\n                     // Verify that returned value satisties definition\n                     Assert.assertTrue(p >= dist.cumulativeProbability(ret));\n                     Assert.assertTrue(p < dist.cumulativeProbability(ret + 1));\n-                } catch (MathException ex) {\n+                } catch (Exception ex) {\n                     Assert.fail(\"mean of \" + mean + \" and p of \" + p + \" caused \" + ex.getMessage());\n                 }\n                 p += dp;", "timestamp": 1317616587, "metainfo": ""}