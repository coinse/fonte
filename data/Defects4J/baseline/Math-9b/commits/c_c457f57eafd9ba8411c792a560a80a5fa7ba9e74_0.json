{"sha": "c457f57eafd9ba8411c792a560a80a5fa7ba9e74", "log": "- Populated throws clause of FieldVector, ArrayFieldVector, SparseFieldVector (MATH-854).   - Added some missing precondition checks.   - Corrected some mistakes in javadoc.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayFieldVector.java\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapAdd(T d) {\n+    public FieldVector<T> mapAdd(T d) throws NullArgumentException {\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].add(d);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapAddToSelf(T d) {\n+    public FieldVector<T> mapAddToSelf(T d) throws NullArgumentException {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i].add(d);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapSubtract(T d) {\n+    public FieldVector<T> mapSubtract(T d) throws NullArgumentException {\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].subtract(d);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapSubtractToSelf(T d) {\n+    public FieldVector<T> mapSubtractToSelf(T d) throws NullArgumentException {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i].subtract(d);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapMultiply(T d) {\n+    public FieldVector<T> mapMultiply(T d) throws NullArgumentException {\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n             out[i] = data[i].multiply(d);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> mapMultiplyToSelf(T d) {\n+    public FieldVector<T> mapMultiplyToSelf(T d) throws NullArgumentException {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i].multiply(d);\n         }\n--- a/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/FieldVector.java\n     /**\n      * Compute {@code this} minus {@code v}.\n      * @param v vector to be subtracted\n-     * @return {@code this + v}\n+     * @return {@code this - v}\n      * @throws DimensionMismatchException if {@code v} is not the same size as\n      * {@code this}\n      */\n      * Map an addition operation to each entry.\n      * @param d value to be added to each entry\n      * @return {@code this + d}\n-     */\n-    FieldVector<T> mapAdd(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     */\n+    FieldVector<T> mapAdd(T d) throws NullArgumentException;\n \n     /**\n      * Map an addition operation to each entry.\n      * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to be added to each entry\n      * @return for convenience, return {@code this}\n-     */\n-    FieldVector<T> mapAddToSelf(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     */\n+    FieldVector<T> mapAddToSelf(T d) throws NullArgumentException;\n \n     /**\n      * Map a subtraction operation to each entry.\n      * @param d value to be subtracted to each entry\n      * @return {@code this - d}\n-     */\n-    FieldVector<T> mapSubtract(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}\n+     */\n+    FieldVector<T> mapSubtract(T d) throws NullArgumentException;\n \n     /**\n      * Map a subtraction operation to each entry.\n      * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to be subtracted to each entry\n      * @return for convenience, return {@code this}\n-     */\n-    FieldVector<T> mapSubtractToSelf(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}\n+     */\n+    FieldVector<T> mapSubtractToSelf(T d) throws NullArgumentException;\n \n     /**\n      * Map a multiplication operation to each entry.\n      * @param d value to multiply all entries by\n      * @return {@code this * d}\n-     */\n-    FieldVector<T> mapMultiply(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     */\n+    FieldVector<T> mapMultiply(T d) throws NullArgumentException;\n \n     /**\n      * Map a multiplication operation to each entry.\n      * <p>The instance <strong>is</strong> changed by this method.</p>\n      * @param d value to multiply all entries by\n      * @return for convenience, return {@code this}\n-     */\n-    FieldVector<T> mapMultiplyToSelf(T d);\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     */\n+    FieldVector<T> mapMultiplyToSelf(T d) throws NullArgumentException;\n \n     /**\n      * Map a division operation to each entry.\n--- a/src/main/java/org/apache/commons/math3/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SparseFieldVector.java\n \n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.OpenIntToFieldHashMap;\n \n /**\n      * Optimized method to add sparse vectors.\n      *\n      * @param v Vector to add.\n-     * @return the sum of {@code this} and {@code v}.\n-     * @throws DimensionMismatchException\n-     * if the dimensions do not match.\n-     */\n-    public FieldVector<T> add(SparseFieldVector<T> v) {\n+     * @return {@code this + v}.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}.\n+     */\n+    public FieldVector<T> add(SparseFieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n         OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n    }\n \n     /** {@inheritDoc} */\n-    public T dotProduct(FieldVector<T> v) {\n+    public T dotProduct(FieldVector<T> v) throws DimensionMismatchException {\n         checkVectorDimensions(v.getDimension());\n         T res = field.getZero();\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(FieldVector<T> v) {\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws DimensionMismatchException, MathArithmeticException {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeMultiply(FieldVector<T> v) {\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n     }\n \n      /** {@inheritDoc} */\n-     public T getEntry(int index) {\n+     public T getEntry(int index) throws OutOfRangeException {\n         checkIndex(index);\n         return entries.get(index);\n    }\n     }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> getSubVector(int index, int n) {\n+    public FieldVector<T> getSubVector(int index, int n)\n+        throws OutOfRangeException, NotPositiveException {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);\n+        }\n         checkIndex(index);\n         checkIndex(index + n - 1);\n         SparseFieldVector<T> res = new SparseFieldVector<T>(field,n);\n     }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapAdd(T d) {\n+     public FieldVector<T> mapAdd(T d) throws NullArgumentException {\n         return copy().mapAddToSelf(d);\n    }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapAddToSelf(T d) {\n+     public FieldVector<T> mapAddToSelf(T d) throws NullArgumentException {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, getEntry(i).add(d));\n         }\n     }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapDivide(T d) {\n+    public FieldVector<T> mapDivide(T d)\n+        throws NullArgumentException, MathArithmeticException {\n         return copy().mapDivideToSelf(d);\n     }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapDivideToSelf(T d) {\n+    public FieldVector<T> mapDivideToSelf(T d)\n+        throws NullArgumentException, MathArithmeticException {\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n    }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapInv() {\n+     public FieldVector<T> mapInv() throws MathArithmeticException {\n         return copy().mapInvToSelf();\n    }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapInvToSelf() {\n+     public FieldVector<T> mapInvToSelf() throws MathArithmeticException {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, field.getOne().divide(getEntry(i)));\n         }\n    }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapMultiply(T d) {\n+     public FieldVector<T> mapMultiply(T d) throws NullArgumentException {\n         return copy().mapMultiplyToSelf(d);\n     }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapMultiplyToSelf(T d) {\n+     public FieldVector<T> mapMultiplyToSelf(T d) throws NullArgumentException {\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n    }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapSubtract(T d) {\n+     public FieldVector<T> mapSubtract(T d) throws NullArgumentException {\n         return copy().mapSubtractToSelf(d);\n     }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> mapSubtractToSelf(T d) {\n+     public FieldVector<T> mapSubtractToSelf(T d) throws NullArgumentException {\n         return mapAddToSelf(field.getZero().subtract(d));\n     }\n \n     /**\n      * Optimized method to compute outer product when both vectors are sparse.\n      * @param v vector with which outer product should be computed\n-     * @return the square matrix outer product between instance and v\n-     * @throws DimensionMismatchException\n-     * if the dimensions do not match.\n+     * @return the matrix outer product between instance and v\n      */\n     public FieldMatrix<T> outerProduct(SparseFieldVector<T> v) {\n         final int n = v.getDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> projection(FieldVector<T> v) {\n+    public FieldVector<T> projection(FieldVector<T> v)\n+        throws DimensionMismatchException, MathArithmeticException {\n         checkVectorDimensions(v.getDimension());\n         return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public void setEntry(int index, T value) {\n+    public void setEntry(int index, T value) throws OutOfRangeException {\n         checkIndex(index);\n         entries.put(index, value);\n    }\n \n     /** {@inheritDoc} */\n-    public void setSubVector(int index, FieldVector<T> v) {\n+    public void setSubVector(int index, FieldVector<T> v)\n+        throws OutOfRangeException {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n         final int n = v.getDimension();\n     }\n \n     /**\n-     * Optimized method to subtract SparseRealVectors.\n-     *\n-     * @param v Vector to subtract.\n-     * @return the difference between {@code this} and {@code v}.\n-     * @throws DimensionMismatchException\n-     * if the dimensions do not match.\n-     */\n-    public SparseFieldVector<T> subtract(SparseFieldVector<T> v){\n+     * Optimized method to compute {@code this} minus {@code v}.\n+     * @param v vector to be subtracted\n+     * @return {@code this - v}\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * {@code this}.\n+     */\n+    public SparseFieldVector<T> subtract(SparseFieldVector<T> v)\n+        throws DimensionMismatchException {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n         OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> subtract(FieldVector<T> v) {\n+    public FieldVector<T> subtract(FieldVector<T> v)\n+        throws DimensionMismatchException {\n         if (v instanceof SparseFieldVector<?>) {\n             return subtract((SparseFieldVector<T>)v);\n         } else {\n      * Check whether an index is valid.\n      *\n      * @param index Index to check.\n-     * @throws OutOfRangeException if the dimensions do not match.\n-     */\n-    private void checkIndex(final int index) {\n+     * @throws OutOfRangeException if the index is not valid.\n+     */\n+    private void checkIndex(final int index) throws OutOfRangeException {\n         if (index < 0 || index >= getDimension()) {\n             throw new OutOfRangeException(index, 0, getDimension() - 1);\n         }\n      * @param n Expected dimension.\n      * @throws DimensionMismatchException if the dimensions do not match.\n      */\n-    protected void checkVectorDimensions(int n) {\n+    protected void checkVectorDimensions(int n)\n+        throws DimensionMismatchException {\n         if (getDimension() != n) {\n             throw new DimensionMismatchException(getDimension(), n);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> add(FieldVector<T> v) {\n+    public FieldVector<T> add(FieldVector<T> v) throws DimensionMismatchException {\n         if (v instanceof SparseFieldVector<?>) {\n             return add((SparseFieldVector<T>) v);\n         } else {", "timestamp": 1347604926, "metainfo": ""}