{"sha": "f4bb5f44ce96f0120bda6ead699153d23278e66e", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20377 Submitted by:\tPhil Steitz   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/AbstractStoreUnivariate.java\n+++ b/src/java/org/apache/commons/math/stat/AbstractStoreUnivariate.java\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  * @author Mark Diggory\n+ * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n  */\n public abstract class AbstractStoreUnivariate implements StoreUnivariate {\n \n         }\n         return accum;\n     }\n+   \n+    /**\n+     * Uses <a href=\"http://www.nist.gov/dads/HTML/shellsort.html\">Shell sort\n+     * </a>\n+     * @see org.apache.commons.math.StoreUnivariate#getSortedValues()\n+     *\n+     */ \n+    public double[] getSortedValues() {\n+        double[] values = getValues();\n+        int n = values.length;\n+        int j = n;\n+        while (j > 1) {\n+            j = j / 2;\n+            boolean done = false;\n+            while (!done) {\n+                done = true;\n+                for (int i = 0; i < n - j; i++) {\n+                    int k = i + j;\n+                    if (values[i] > values[k]) {\n+                        double temp = values[i];\n+                        values[i] = values[k];\n+                        values[k] = temp;\n+                        done = false;\n+                    }\n+                }\n+            }\n+        }\n+        return values;\n+    }\n+    \n+    /**\n+     * Returns an estimate for the pth percentile of the stored values\n+     * @see org.apache.commons.math.StoreUnivariate#getPercentile()\n+     */\n+    public double getPercentile(double p) {    \n+        if ((p > 100) || (p <= 0)) {\n+            throw new IllegalArgumentException(\"invalid percentile value\");\n+        }\n+        double n = (double) getN();\n+        if (n == 0) {\n+            return Double.NaN;\n+        }\n+        if (n == 1) {\n+            return getElement(0);  // always return single value for n = 1\n+        }\n+        double pos = p * (n + 1) / 100;\n+        double fpos = Math.floor(pos);\n+        int intPos = (int) fpos;\n+        double d = pos - fpos;\n+        double[] sorted = getSortedValues();\n+        if (pos < 1) {\n+            return sorted[0];\n+        }\n+        if (pos > n) {\n+            return sorted[getN() - 1];\n+        }\n+        double lower = sorted[intPos - 1];\n+        double upper = sorted[intPos];\n+        return lower + d * (upper - lower);       \n+    }\n \n }\n--- a/src/java/org/apache/commons/math/stat/StoreUnivariate.java\n+++ b/src/java/org/apache/commons/math/stat/StoreUnivariate.java\n \n     /**\n      * Returns the current set of values in an array of double primitives.  \n-     * The order of addition is preserved\n+     * The order of addition is preserved.  The returned array is a fresh\n+     * copy of the underlying data -- i.e., it is not a reference to the\n+     * stored data.\n      * \n      * @return returns the current set of numbers in the order in which they \n      *         were added to this set\n      */\n     public abstract double[] getValues();\n+    \n+    /**\n+     * Returns the current set of values in an array of double primitives,  \n+     * sorted in ascending order.  The returned array is a fresh\n+     * copy of the underlying data -- i.e., it is not a reference to the\n+     * stored data.\n+     * \n+     * @return returns the current set of numbers sorted in ascending order        \n+     */\n+    public abstract double[] getSortedValues(); \n \n     /**\n      * Returns the element at the specified index\n      * @return return the element at the specified index\n      */\n     public abstract double getElement(int index);\n+    \n+    /**\n+     * Returns an estimate for the pth percentile of the stored values,\n+     * following the interpolation-adjusted defintion presented \n+     * <a href=\"http://www.utdallas.edu/~ammann/stat5311/node8.html\">here</a><p>\n+     *\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>0 < p < 100</code> (otherwise an <code>IllegalArgumentException\n+     *     </code> is thrown)</li>\n+     * <li>at least one value must be stored (returns <code>Double.NaN\n+     *     </code> otherwise)</li>\n+     * </ul>\n+     * \n+     * @param p the requested percentile (scaled from 0 - 100)\n+     * @return returns an estimate for the pth percentile of the stored data \n+     * values\n+     */\n+    public abstract double getPercentile(double p);\n \n }\n--- a/src/test/org/apache/commons/math/stat/StoreUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/StoreUnivariateImplTest.java\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+import org.apache.commons.math.RandomDataImpl;\n+import org.apache.commons.math.RandomData;\n \n /**\n  * Test cases for the {@link Univariate} class.\n  *\n  * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n- * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $\n+ * @version $Revision: 1.2 $ $Date: 2003/06/04 02:24:51 $\n  */\n \n public final class StoreUnivariateImplTest extends TestCase {\n     public void testN0andN1Conditions() throws Exception {\n     \tStoreUnivariate u = new StoreUnivariateImpl();\n     \t    \t\n-\t\tassertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n-\t\tassertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n-\t\tassertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n-\n-\t\tu.addValue(one);\n-\n-\t\tassertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n-\t\tassertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n-\t\tassertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);\t\n+            assertTrue(\"Mean of n = 0 set should be NaN\", \n+                Double.isNaN( u.getMean() ) );\n+            assertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+                Double.isNaN( u.getStandardDeviation() ) );\n+            assertTrue(\"Variance of n = 0 set should be NaN\",\n+                Double.isNaN(u.getVariance() ) );\n+\n+            u.addValue(one);\n+\n+            assertTrue( \"Mean of n = 1 set should be value of single item n1\",\n+                u.getMean() == one);\n+            assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" \n+                + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n+            assertTrue( \"Variance of n = 1 set should be zero\", \n+                u.getVariance() == 0);\t\n     }\n     \n     public void testSkewAndKurtosis() {\n     \tStoreUnivariate u = new StoreUnivariateImpl();\n     \t\n-    \tdouble[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n-  \t  \t\t\t\t\t\t\t\t\t\t 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n+    \tdouble[] testArray = \n+        { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n+          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n   \t  \tfor( int i = 0; i < testArray.length; i++) {\n   \t  \t\tu.addValue( testArray[i]);\n   \t  \t}\n         u.addValue( 3.0 );\n         u.addValue( 4.0 );\n \n-        assertEquals( \"Product not expected\", 24.0, u.getProduct(), Double.MIN_VALUE );\n-        assertEquals( \"Geometric mean not expected\", 2.213364, u.getGeometricMean(), 0.00001 );\n+        assertEquals( \"Product not expected\", \n+            24.0, u.getProduct(), Double.MIN_VALUE );\n+        assertEquals( \"Geometric mean not expected\", \n+            2.213364, u.getGeometricMean(), 0.00001 );\n \n         // Now test rolling - UnivariateImpl should discount the contribution\n         // of a discarded element\n         }\n         // Values should be (2,3,4,5,6,7,8,9,10,11)\n         \n-        assertEquals( \"Product not expected\", 39916800.0, u.getProduct(), 0.00001 );\n-        assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n-\n-\n-    }\n-\n+        assertEquals( \"Product not expected\", 39916800.0, \n+            u.getProduct(), 0.00001 );\n+        assertEquals( \"Geometric mean not expected\", 5.755931, \n+            u.getGeometricMean(), 0.00001 );\n+    }\n+    \n+    public void testGetSortedValues() {\n+        double[] test1 = {5,4,3,2,1};\n+        double[] test2 = {5,2,1,3,4,0};\n+        double[] test3 = {1};\n+        int[] testi = null;\n+        double[] test4 = null;\n+        RandomData rd = new RandomDataImpl();\n+        tstGetSortedValues(test1);\n+        tstGetSortedValues(test2);\n+        tstGetSortedValues(test3);\n+        for (int i = 0; i < 10; i++) {\n+            testi = rd.nextPermutation(10,6);\n+            test4 = new double[6];\n+            for (int j = 0; j < testi.length; j++) {\n+                test4[j] = (double) testi[j];\n+            }\n+            tstGetSortedValues(test4);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            testi = rd.nextPermutation(10,5);\n+            test4 = new double[5];\n+            for (int j = 0; j < testi.length; j++) {\n+                test4[j] = (double) testi[j];\n+            }\n+            tstGetSortedValues(test4);\n+        }        \n+    }\n+    \n+        \n+    private void tstGetSortedValues(double[] test) {\n+        StoreUnivariateImpl u = new StoreUnivariateImpl();\n+        for (int i = 0; i < test.length; i++) {\n+            u.addValue(test[i]);\n+        }\n+        double[] sorted = u.getSortedValues();\n+        if (sorted.length != test.length) {\n+            fail(\"wrong length for sorted values array\");\n+        }\n+        for (int i = 0; i < sorted.length-1; i++) {\n+            if (sorted[i] > sorted[i+1]) {\n+                fail(\"sorted values out of sequence\");\n+            }\n+        }\n+    }\n+    \n+    public void testPercentiles() {\n+        double[] test = {5,4,3,2,1};\n+        StoreUnivariateImpl u = new StoreUnivariateImpl();\n+        for (int i = 0; i < test.length; i++) {\n+            u.addValue(test[i]);\n+        }\n+        assertEquals(\"expecting min\",1,u.getPercentile(5),10E-12);\n+        assertEquals(\"expecting max\",5,u.getPercentile(99),10E-12);\n+        assertEquals(\"expecting middle\",3,u.getPercentile(50),10E-12);\n+        try {\n+            double x = u.getPercentile(0);\n+            fail(\"expecting IllegalArgumentException for getPercentile(0)\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = u.getPercentile(120);\n+            fail(\"expecting IllegalArgumentException for getPercentile(120)\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        \n+        u.clear();\n+        double[] test2 = {1,2,3,4};\n+        for (int i = 0; i < test2.length; i++) {\n+            u.addValue(test2[i]);\n+        }\n+        assertEquals(\"Q1\",1.25,u.getPercentile(25),10E-12);\n+        assertEquals(\"Q3\",3.75,u.getPercentile(75),10E-12);\n+        assertEquals(\"Q2\",2.5,u.getPercentile(50),10E-12);\n+        \n+        u.clear();\n+        double[] test3 = {1};\n+        for (int i = 0; i < test3.length; i++) {\n+            u.addValue(test3[i]);\n+        }\n+        assertEquals(\"Q1\",1,u.getPercentile(25),10E-12);\n+        assertEquals(\"Q3\",1,u.getPercentile(75),10E-12);\n+        assertEquals(\"Q2\",1,u.getPercentile(50),10E-12);\n+        \n+        u.clear();\n+        RandomData rd = new RandomDataImpl();\n+        int[] testi = rd.nextPermutation(100,100); // will contain 0-99\n+        for (int j = 0; j < testi.length; j++) {\n+            u.addValue((double) testi[j]);  //OK, laugh at me for the cast\n+        }\n+        for (int i = 1; i < 100; i++) {\n+            assertEquals(\"percentile \" + i,\n+                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);\n+        }\n+        \n+        u.clear();\n+        double[] test4 = {1,2,3,4,100};\n+        for (int i = 0; i < test4.length; i++) {\n+            u.addValue(test4[i]);\n+        }\n+        assertEquals(\"80th\",80.8,u.getPercentile(80),10E-12);\n+        \n+        u.clear();\n+        assertTrue(\"empty value set should return NaN\",\n+            Double.isNaN(u.getPercentile(50)));\n+    }\n+                                     \n }\n ", "timestamp": 1054693491, "metainfo": ""}