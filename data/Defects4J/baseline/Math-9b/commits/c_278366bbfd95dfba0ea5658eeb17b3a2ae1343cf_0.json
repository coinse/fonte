{"sha": "278366bbfd95dfba0ea5658eeb17b3a2ae1343cf", "log": "MATH-441 Implemented proposed solution (rethrow last exception if no optimum were found).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n      * elements will be null if the {@link #optimize(MultivariateRealFunction,GoalType,double[])\n-     * optimize} method did throw a {@link ConvergenceException}).\n+     * optimize} method did throw a {@link MathUserException}).\n      * This also means that if the first element is not {@code null}, it\n      * is the best point found across all starts.\n      *\n      * @return an array containing the optima.\n      * @throws MathIllegalStateException if {@link\n-     * #optimize(MultivariateRealFunction,GoalType,double[]) optimize} has not been called.\n+     * #optimize(MultivariateRealFunction,GoalType,double[]) optimize}\n+     * has not been called.\n      */\n     public RealPointValuePair[] getOptima() {\n         if (optima == null) {\n      */\n     public RealPointValuePair optimize(final FUNC f,\n                                        final GoalType goal,\n-                                       double[] startPoint)\n-        throws FunctionEvaluationException {\n+                                       double[] startPoint) {\n+        MathUserException lastException = null;\n         optima = new RealPointValuePair[starts];\n+        totalEvaluations = 0;\n \n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n-\n             try {\n                 optima[i] = optimizer.optimize(f, goal,\n                                                i == 0 ? startPoint : generator.nextVector());\n-            } catch (FunctionEvaluationException fee) {\n-                optima[i] = null;\n-            } catch (ConvergenceException oe) {\n+            } catch (MathUserException mue) {\n+                lastException = mue;\n                 optima[i] = null;\n             }\n \n         sortPairs(goal);\n \n         if (optima[0] == null) {\n-            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n-                                           starts);\n+            throw lastException;\n         }\n \n         // Return the found point given the best objective function value.\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.random.RandomGenerator;\n import org.apache.commons.math.optimization.GoalType;\n      * descending order if maximizing), followed by {@code null} elements\n      * corresponding to the runs that did not converge. This means all\n      * elements will be {@code null} if the {@link\n-     * #optimize(UnivariateRealFunction,GoalType,double,double) optimize} method did throw a\n-     * {@link ConvergenceException}). This also means that if the first\n-     * element is not {@code null}, it is the best point found across all\n-     * starts.\n+     * #optimize(UnivariateRealFunction,GoalType,double,double) optimize}\n+     * method did throw a {@link MathUserException}). This also means that\n+     * if the first element is not {@code null}, it is the best point found\n+     * across all starts.\n      *\n      * @return an array containing the optima.\n      * @throws MathIllegalStateException if {@link\n-     * #optimize(UnivariateRealFunction,GoalType,double,double) optimize} has not been called.\n+     * #optimize(UnivariateRealFunction,GoalType,double,double) optimize}\n+     * has not been called.\n      */\n     public UnivariateRealPointValuePair[] getOptima() {\n         if (optima == null) {\n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n-                                                 final double min, final double max)\n-        throws FunctionEvaluationException {\n+                                                 final double min, final double max) {\n         return optimize(f, goal, min, max, min + 0.5 * (max - min));\n     }\n \n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n                                                  final double min, final double max,\n-                                                 final double startValue)\n-        throws FunctionEvaluationException {\n+                                                 final double startValue) {\n+        MathUserException lastException = null;\n         optima = new UnivariateRealPointValuePair[starts];\n         totalEvaluations = 0;\n \n             try {\n                 final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n                 optima[i] = optimizer.optimize(f, goal, min, max, s);\n-            } catch (FunctionEvaluationException fee) {\n-                optima[i] = null;\n-            } catch (ConvergenceException ce) {\n+            } catch (MathUserException mue) {\n+                lastException = mue;\n                 optima[i] = null;\n             }\n \n         sortPairs(goal);\n \n         if (optima[0] == null) {\n-            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n-                                           starts);\n+            throw lastException;\n         }\n \n         // Return the point with the best objective function value.\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n public class MultiStartUnivariateRealOptimizerTest {\n \n     @Test\n-    public void testSinMin() throws MathException {\n+    public void testSinMin() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);\n         underlying.setMaxEvaluations(300);\n     }\n \n     @Test\n-    public void testQuinticMin() throws MathException {\n+    public void testQuinticMin() {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n         UnivariateRealFunction f = new QuinticFunction();\n         assertTrue(optimizer.getEvaluations() >= 50);\n         assertTrue(optimizer.getEvaluations() <= 100);\n     }\n+\n+    @Test(expected=MathUserException.class)\n+    public void testBadFunction() {\n+        UnivariateRealFunction f = new UnivariateRealFunction() {\n+                public double value(double x) {\n+                    if (x < 0) {\n+                        throw new MathUserException();\n+                    }\n+                    return 0;\n+                }\n+            };\n+        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n+        underlying.setMaxEvaluations(300);\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(4312000053L);\n+        MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n+            new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 5, g);\n+\n+        UnivariateRealPointValuePair optimum\n+            = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n+    }\n }", "timestamp": 1289823767, "metainfo": ""}