{"sha": "8742126f8f6117d90401f8d3ca1f40cd72b489aa", "log": "MATH-425 Deleted deprecated classes in package \"linear\". Removed redundant methods in \"Array2DRowRealMatrix\". Removed usage of \"MatrixIndexException\" (class is now deprecated). Javadoc clean up.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/MathArithmeticException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.math.exception.util.ArgUtils;\n+import org.apache.commons.math.exception.util.MessageFactory;\n+import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Base class for arithmetic exceptions.\n+ * It is used for all the exceptions that share the semantics of the standard\n+ * {@link ArithmeticException}, but must also provide a localized\n+ * message.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class MathArithmeticException extends ArithmeticException {\n+\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -6024911025449780478L;\n+\n+    /**\n+     * Pattern used to build the message (specific context).\n+     */\n+    private final Localizable specific;\n+    /**\n+     * Arguments used to build the message.\n+     */\n+    private final Object[] arguments;\n+\n+    /**\n+     * @param args Arguments.\n+     */\n+    public MathArithmeticException(Object ... args) {\n+        this(null, args);\n+    }\n+    /**\n+     * @param specific Message pattern providing the specific context of\n+     * the error.\n+     * @param args Arguments.\n+     */\n+    public MathArithmeticException(Localizable specific,\n+                                   Object ... args) {\n+        this.specific = specific;\n+        arguments = ArgUtils.flatten(args);\n+    }\n+\n+    /**\n+     * Get the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated.\n+     *\n+     * @return the localized message.\n+     */\n+    public String getMessage(final Locale locale) {\n+        return MessageFactory.buildMessage(locale,\n+                                           specific,\n+                                           LocalizedFormats.UNSUPPORTED_OPERATION,\n+                                           arguments);\n+    }\n+\n+   /** {@inheritDoc} */\n+    @Override\n+    public String getMessage() {\n+        return getMessage(Locale.US);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     INDEX_LARGER_THAN_MAX(\"the index specified: {0} is larger than the current maximal index {1}\"),\n     INDEX_NOT_POSITIVE(\"index ({0}) is not positive\"),\n     INDEX_OUT_OF_RANGE(\"index {0} out of allowed range [{1}, {2}]\"),\n+    INDEX(\"index ({0})\"), /* keep */\n     INFINITE_ARRAY_ELEMENT(\"Array contains an infinite element, {0} at index {1}\"),\n     INFINITE_VALUE_CONVERSION(\"cannot convert infinite value\"),\n     INITIAL_CAPACITY_NOT_POSITIVE(\"initial capacity ({0}) is not positive\"),\n-    INITIAL_COLUMN_AFTER_FINAL_COLUMN(\"initial column {0} after final column {1}\"),\n-    INITIAL_ROW_AFTER_FINAL_ROW(\"initial row {0} after final row {1}\"),\n+    INITIAL_COLUMN_AFTER_FINAL_COLUMN(\"initial column {1} after final column {0}\"),\n+    INITIAL_ROW_AFTER_FINAL_ROW(\"initial row {1} after final row {0}\"),\n     INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE(\"input data comes from unsupported datasource: {0}, supported sources: {1}, {2}\"),\n     INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES(\"instance of class {0} not comparable to existing values\"),\n     INSUFFICIENT_DATA_FOR_T_STATISTIC(\"insufficient data for t statistic, needs at least 2, got {0}\"),\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     public abstract RealMatrix copy();\n \n     /** {@inheritDoc} */\n-    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n-\n-        // safety check\n+    public RealMatrix add(RealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix subtract(final RealMatrix m) throws IllegalArgumentException {\n-\n-        // safety check\n+    public RealMatrix subtract(final RealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkSubtractionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n \n     /** {@inheritDoc} */\n     public RealMatrix scalarAdd(final double d) {\n-\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         final RealMatrix out = createMatrix(rowCount, columnCount);\n \n     /** {@inheritDoc} */\n     public RealMatrix scalarMultiply(final double d) {\n-\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         final RealMatrix out = createMatrix(rowCount, columnCount);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix multiply(final RealMatrix m)\n-        throws IllegalArgumentException {\n-\n-        // safety check\n+    public RealMatrix multiply(final RealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int nRows = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix preMultiply(final RealMatrix m)\n-        throws IllegalArgumentException {\n+    public RealMatrix preMultiply(final RealMatrix m) {\n         return m.multiply(this);\n     }\n \n     /** {@inheritDoc} */\n     public double[][] getData() {\n-\n         final double[][] data = new double[getRowDimension()][getColumnDimension()];\n \n         for (int i = 0; i < data.length; ++i) {\n \n     /** {@inheritDoc} */\n     public RealMatrix getSubMatrix(final int startRow, final int endRow,\n-                                   final int startColumn, final int endColumn)\n-        throws MatrixIndexException {\n-\n+                                   final int startColumn, final int endColumn) {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n \n         final RealMatrix subMatrix =\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns)\n-        throws MatrixIndexException {\n-\n+    public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) {\n         // safety checks\n         MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n \n     /** {@inheritDoc} */\n     public void copySubMatrix(final int startRow, final int endRow,\n                               final int startColumn, final int endColumn,\n-                              final double[][] destination)\n-        throws MatrixIndexException, IllegalArgumentException {\n+                              final double[][] destination) {\n \n         // safety checks\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n     }\n \n     /** {@inheritDoc} */\n-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n-        throws MatrixIndexException {\n-\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) {\n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getRowMatrix(final int row)\n-        throws MatrixIndexException {\n-\n+    public RealMatrix getRowMatrix(final int row) {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         final RealMatrix out = createMatrix(1, nCols);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getColumnMatrix(final int column)\n-        throws MatrixIndexException {\n-\n+    public RealMatrix getColumnMatrix(final int column) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         final RealMatrix out = createMatrix(nRows, 1);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector getRowVector(final int row)\n-        throws MatrixIndexException {\n+    public RealVector getRowVector(final int row) {\n         return new ArrayRealVector(getRow(row), false);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealVector getColumnVector(final int column)\n-        throws MatrixIndexException {\n+    public RealVector getColumnVector(final int column) {\n         return new ArrayRealVector(getColumn(column), false);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public double[] getRow(final int row)\n-        throws MatrixIndexException {\n-\n+    public double[] getRow(final int row) {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         final double[] out = new double[nCols];\n     }\n \n     /** {@inheritDoc} */\n-    public double[] getColumn(final int column)\n-        throws MatrixIndexException {\n-\n+    public double[] getColumn(final int column) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         final double[] out = new double[nRows];\n     }\n \n     /** {@inheritDoc} */\n-    public abstract double getEntry(int row, int column)\n-        throws MatrixIndexException;\n-\n-    /** {@inheritDoc} */\n-    public abstract void setEntry(int row, int column, double value)\n-        throws MatrixIndexException;\n-\n-    /** {@inheritDoc} */\n-    public abstract void addToEntry(int row, int column, double increment)\n-        throws MatrixIndexException;\n-\n-    /** {@inheritDoc} */\n-    public abstract void multiplyEntry(int row, int column, double factor)\n-        throws MatrixIndexException;\n+    public abstract double getEntry(int row, int column);\n+\n+    /** {@inheritDoc} */\n+    public abstract void setEntry(int row, int column, double value);\n+\n+    /** {@inheritDoc} */\n+    public abstract void addToEntry(int row, int column, double increment);\n+\n+    /** {@inheritDoc} */\n+    public abstract void multiplyEntry(int row, int column, double factor);\n \n     /** {@inheritDoc} */\n     public RealMatrix transpose() {\n-\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         final RealMatrix out = createMatrix(nCols, nRows);\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n-    throws MatrixIndexException, MatrixVisitorException {\n+    throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n-    throws MatrixIndexException, MatrixVisitorException {\n+    throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathUnsupportedOperationException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.analysis.BinaryFunction;\n import org.apache.commons.math.analysis.ComposableFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n     /**\n      * Check if an index is valid.\n-     * @param index index to check\n-     * @exception MatrixIndexException if index is not valid\n+     *\n+     * @param index Index to check.\n+     * @exception OutOfRangeException if {@code index} is not valid.\n      */\n-    protected void checkIndex(final int index)\n-        throws MatrixIndexException {\n-        if (index < 0 || index >= getDimension()) {\n-            throw new MatrixIndexException(LocalizedFormats.INDEX_OUT_OF_RANGE,\n-                                           index, 0, getDimension() - 1);\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+    protected void checkIndex(final int index) {\n+        if (index < 0 ||\n+            index >= getDimension()) {\n+            throw new OutOfRangeException(LocalizedFormats.INDEX,\n+                                          index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, RealVector v) {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n         setSubVector(index, v.getData());\n     }\n \n     /** {@inheritDoc} */\n-    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+    public void setSubVector(int index, double[] v) {\n         checkIndex(index);\n         checkIndex(index + v.length - 1);\n         for (int i = 0; i < v.length; i++) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector add(double[] v) throws IllegalArgumentException {\n+    public RealVector add(double[] v) {\n         double[] result = v.clone();\n         Iterator<Entry> it = sparseIterator();\n         Entry e;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector add(RealVector v) throws IllegalArgumentException {\n+    public RealVector add(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             double[] values = ((ArrayRealVector)v).getDataRef();\n             return add(values);\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector subtract(double[] v) throws IllegalArgumentException {\n+    public RealVector subtract(double[] v) {\n         double[] result = v.clone();\n         Iterator<Entry> it = sparseIterator();\n         Entry e;\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+    public RealVector subtract(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             double[] values = ((ArrayRealVector)v).getDataRef();\n             return add(values);\n     public abstract AbstractRealVector copy();\n \n     /** {@inheritDoc} */\n-    public double dotProduct(double[] v) throws IllegalArgumentException {\n+    public double dotProduct(double[] v) {\n         return dotProduct(new ArrayRealVector(v, false));\n     }\n \n     /** {@inheritDoc} */\n-    public double dotProduct(RealVector v) throws IllegalArgumentException {\n+    public double dotProduct(RealVector v) {\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = sparseIterator();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+    public RealVector ebeDivide(double[] v) {\n         return ebeDivide(new ArrayRealVector(v, false));\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+    public RealVector ebeMultiply(double[] v) {\n         return ebeMultiply(new ArrayRealVector(v, false));\n     }\n \n     /** {@inheritDoc} */\n-    public double getDistance(RealVector v) throws IllegalArgumentException {\n+    public double getDistance(RealVector v) {\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public double getDistance(double[] v) throws IllegalArgumentException {\n+    public double getDistance(double[] v) {\n         return getDistance(new ArrayRealVector(v,false));\n     }\n \n     /** {@inheritDoc} */\n-    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+    public double getL1Distance(RealVector v) {\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public double getL1Distance(double[] v) throws IllegalArgumentException {\n+    public double getL1Distance(double[] v) {\n         checkVectorDimensions(v.length);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+    public double getLInfDistance(RealVector v) {\n         checkVectorDimensions(v);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+    public double getLInfDistance(double[] v) {\n         checkVectorDimensions(v.length);\n         double d = 0;\n         Iterator<Entry> it = iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+    public RealMatrix outerProduct(RealVector v) {\n         RealMatrix product;\n         if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n-            product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());\n+            product = new OpenMapRealMatrix(this.getDimension(),\n+                                            v.getDimension());\n         } else {\n-            product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());\n+            product = new Array2DRowRealMatrix(this.getDimension(),\n+                                               v.getDimension());\n         }\n         Iterator<Entry> thisIt = sparseIterator();\n         Entry thisE = null;\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+    public RealMatrix outerProduct(double[] v) {\n         return outerProduct(new ArrayRealVector(v, false));\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector projection(double[] v) throws IllegalArgumentException {\n+    public RealVector projection(double[] v) {\n         return projection(new ArrayRealVector(v, false));\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * @version $Revision$ $Date$\n  */\n public class Array2DRowRealMatrix extends AbstractRealMatrix implements Serializable {\n-\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -1067294169172445528L;\n-\n-    /** Entries of the matrix */\n+    /** Entries of the matrix. */\n     protected double data[][];\n \n     /**\n      * Creates a matrix with no data\n      */\n-    public Array2DRowRealMatrix() {\n-    }\n+    public Array2DRowRealMatrix() {}\n \n     /**\n      * Create a new RealMatrix with the supplied row and column dimensions.\n     /**\n      * Create a new RealMatrix using the input array as the underlying\n      * data array.\n-     * <p>If an array is built specially in order to be embedded in a\n-     * RealMatrix and not used directly, the <code>copyArray</code> may be\n-     * set to <code>false</code. This will prevent the copying and improve\n-     * performance as no new array will be built and no data will be copied.</p>\n-     * @param d data for new matrix\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n-     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if <code>d</code> is null\n+     * If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the {@code copyArray} may be\n+     * set to {@code false}. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.\n+     *\n+     * @param d Data for new matrix.\n+     * @param copyArray if {@code true}, the input array will be copied,\n+     * otherwise it will be referenced.\n+     * @throws DimensionMismatchException if {@code d} is not rectangular\n+     * (not all rows have the same length) or empty.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws ZeroException if there are not at least one row and one column.\n      * @see #Array2DRowRealMatrix(double[][])\n      */\n-    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n-        throws IllegalArgumentException, NullPointerException {\n+    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray) {\n         if (copyArray) {\n             copyIn(d);\n         } else {\n             if (d == null) {\n-                throw new NullPointerException();\n+                throw new NullArgumentException();\n             }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_ROW);\n+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, d[r].length);\n+                    throw new DimensionMismatchException(d[r].length, nCols);\n                 }\n             }\n             data = d;\n     }\n \n     /**\n-     * Create a new (column) RealMatrix using <code>v</code> as the\n-     * data for the unique column of the <code>v.length x 1</code> matrix\n+     * Create a new (column) RealMatrix using {@code v} as the\n+     * data for the unique column of the {@code v.length x 1} matrix\n      * created.\n-     * <p>The input array is copied, not referenced.</p>\n-     *\n-     * @param v column vector holding data for new matrix\n+     * The input array is copied, not referenced.\n+     *\n+     * @param v Column vector holding data for new matrix.\n      */\n     public Array2DRowRealMatrix(final double[] v) {\n         final int nRows = v.length;\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n+    public RealMatrix createMatrix(final int rowDimension,\n+                                   final int columnDimension) {\n         return new Array2DRowRealMatrix(rowDimension, columnDimension);\n     }\n \n         return new Array2DRowRealMatrix(copyOut(), false);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public RealMatrix add(final RealMatrix m)\n-        throws IllegalArgumentException {\n-        try {\n-            return add((Array2DRowRealMatrix) m);\n-        } catch (ClassCastException cce) {\n-            return super.add(m);\n-        }\n-    }\n-\n-    /**\n-     * Compute the sum of this and <code>m</code>.\n-     *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n-    public Array2DRowRealMatrix add(final Array2DRowRealMatrix m)\n-        throws IllegalArgumentException {\n-\n-        // safety check\n+    /**\n+     * Compute the sum of this matrix with {@code m}.\n+     *\n+     * @param m Matrix to be added.\n+     * @return {@code this} + m.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n+     */\n+    public Array2DRowRealMatrix add(final Array2DRowRealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n         }\n \n         return new Array2DRowRealMatrix(outData, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealMatrix subtract(final RealMatrix m)\n-        throws IllegalArgumentException {\n-        try {\n-            return subtract((Array2DRowRealMatrix) m);\n-        } catch (ClassCastException cce) {\n-            return super.subtract(m);\n-        }\n-    }\n-\n-    /**\n-     * Compute  this minus <code>m</code>.\n-     *\n-     * @param m    matrix to be subtracted\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n-    public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m)\n-        throws IllegalArgumentException {\n-\n-        // safety check\n+    }\n+\n+    /**\n+     * Subtract {@code m} from this matrix.\n+     *\n+     * @param m Matrix to be subtracted.\n+     * @return {@code this} - m.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n+     */\n+    public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkSubtractionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n         }\n \n         return new Array2DRowRealMatrix(outData, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealMatrix multiply(final RealMatrix m)\n-        throws IllegalArgumentException {\n-        try {\n-            return multiply((Array2DRowRealMatrix) m);\n-        } catch (ClassCastException cce) {\n-            return super.multiply(m);\n-        }\n-    }\n-\n-    /**\n-     * Returns the result of postmultiplying this by <code>m</code>.\n-     * @param m    matrix to postmultiply by\n-     * @return     this*m\n-     * @throws     IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n-     */\n-    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n-        throws IllegalArgumentException {\n-\n-        // safety check\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this matrix with {@code m}.\n+     *\n+     * @param m Matrix to postmultiply by.\n+     * @return {@code this} * m.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if the column dimension of this matrix is different from the row\n+     * dimension of {@code m}.\n+     */\n+    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int nRows = this.getRowDimension();\n     }\n \n     /**\n-     * Returns a reference to the underlying data array.\n-     * <p>\n-     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n-     *\n-     * @return 2-dimensional array of entries\n+     * Return a reference to the underlying data array.\n+     *\n+     * @return 2-dimensional array of entries.\n      */\n     public double[][] getDataRef() {\n         return data;\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n-    throws MatrixIndexException {\n+    public void setSubMatrix(final double[][] subMatrix,\n+                             final int row, final int column) {\n         if (data == null) {\n             if (row > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\n-                      LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n+                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n             }\n             if (column > 0) {\n-                throw MathRuntimeException.createIllegalStateException(\n-                      LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n+                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_ROW);\n+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_ROW);\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+                throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                          LocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, subMatrix[i].length);\n+                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getEntry(final int row, final int column)\n-        throws MatrixIndexException {\n-        try {\n-            return data[row][column];\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setEntry(final int row, final int column, final double value)\n-        throws MatrixIndexException {\n-        try {\n-            data[row][column] = value;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void addToEntry(final int row, final int column, final double increment)\n-        throws MatrixIndexException {\n-        try {\n-            data[row][column] += increment;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void multiplyEntry(final int row, final int column, final double factor)\n-        throws MatrixIndexException {\n-        try {\n-            data[row][column] *= factor;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public int getRowDimension() {\n+    public double getEntry(final int row, final int column) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        return data[row][column];\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        data[row][column] = value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final double increment) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        data[row][column] += increment;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final double factor) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        data[row][column] *= factor;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+        public int getRowDimension() {\n         return (data == null) ? 0 : data.length;\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] operate(final double[] v)\n-        throws IllegalArgumentException {\n+    public double[] operate(final double[] v) {\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         if (v.length != nCols) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nCols);\n+            throw new DimensionMismatchException(v.length, nCols);\n         }\n         final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] preMultiply(final double[] v)\n-        throws IllegalArgumentException {\n-\n+    public double[] preMultiply(final double[] v) {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.VECTOR_LENGTH_MISMATCH, v.length, nRows);\n+            throw new DimensionMismatchException(v.length, nRows);\n         }\n \n         final double[] out = new double[nCols];\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * @since 2.0\n  */\n public class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 7648186910365927050L;\n-\n     /** Entries of the vector. */\n     protected T[] data;\n-\n     /** Field to which the elements belong. */\n     private final Field<T> field;\n \n     /**\n      * Build a 0-length vector.\n-     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * Zero-length vectors may be used to initialized construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #ArrayFieldVector(ArrayFieldVector, ArrayFieldVector)} constructor\n-     * or one of the <code>append</code> methods ({@link #append(FieldElement[])},\n+     * or one of the {@code append} methods ({@link #append(FieldElement[])},\n      * {@link #add(FieldVector)}, {@link #append(ArrayFieldVector)}) to gather data\n-     * into this vector.</p>\n+     * into this vector.\n+     *\n      * @param field field to which the elements belong\n      */\n     public ArrayFieldVector(final Field<T> field) {\n     }\n \n     /**\n-     * Construct a (size)-length vector of zeros.\n-     * @param field field to which the elements belong\n-     * @param size size of the vector\n+     * Construct a vector of zeroes.\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param size Size of the vector.\n      */\n     public ArrayFieldVector(Field<T> field, int size) {\n         this.field = field;\n     }\n \n     /**\n-     * Construct an (size)-length vector with preset values.\n-     * @param size size of the vector\n-     * @param preset fill the vector with this scalar value\n+     * Construct a vector with preset values.\n+     *\n+     * @param size Size of the vector.\n+     * @param preset All entries will be set with this value.\n      */\n     public ArrayFieldVector(int size, T preset) {\n         this(preset.getField(), size);\n \n     /**\n      * Construct a vector from an array, copying the input array.\n-     * <p>\n      * This constructor needs a non-empty {@code d} array to retrieve\n      * the field from its first element. This implies it cannot build\n      * 0 length vectors. To build vectors from any size, one should\n      * use the {@link #ArrayFieldVector(Field, FieldElement[])} constructor.\n-     * </p>\n-     * @param d array of Ts.\n-     * @throws IllegalArgumentException if <code>d</code> is empty\n+     *\n+     * @param d Array.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws ZeroException if {@code d} is empty.\n      * @see #ArrayFieldVector(Field, FieldElement[])\n      */\n-    public ArrayFieldVector(T[] d)\n-        throws IllegalArgumentException {\n+    public ArrayFieldVector(T[] d) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         try {\n             field = d[0].getField();\n             data = d.clone();\n         } catch (ArrayIndexOutOfBoundsException e) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n     }\n \n     /**\n      * Construct a vector from an array, copying the input array.\n-     * @param field field to which the elements belong\n-     * @param d array of Ts.\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param d Array.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n      * @see #ArrayFieldVector(FieldElement[])\n      */\n     public ArrayFieldVector(Field<T> field, T[] d) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         this.field = field;\n         data = d.clone();\n     }\n     /**\n      * Create a new ArrayFieldVector using the input array as the underlying\n      * data array.\n-     * <p>If an array is built specially in order to be embedded in a\n-     * ArrayFieldVector and not used directly, the <code>copyArray</code> may be\n-     * set to <code>false</code. This will prevent the copying and improve\n-     * performance as no new array will be built and no data will be copied.</p>\n-     * <p>\n+     * If an array is built specially in order to be embedded in a\n+     * ArrayFieldVector and not used directly, the {@code copyArray} may be\n+     * set to {@code false}. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.\n      * This constructor needs a non-empty {@code d} array to retrieve\n      * the field from its first element. This implies it cannot build\n      * 0 length vectors. To build vectors from any size, one should\n-     * use the {@link #ArrayFieldVector(Field, FieldElement[], boolean)} constructor.\n-     * </p>\n-     * @param d data for new vector\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n-     * @throws IllegalArgumentException if <code>d</code> is empty\n-     * @throws NullPointerException if <code>d</code> is null\n+     * use the {@link #ArrayFieldVector(Field, FieldElement[], boolean)}\n+     * constructor.\n+     *\n+     * @param d Data for the new vector.\n+     * @param copyArray If {@code true}, the input array will be copied,\n+     * otherwise it will be referenced.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws ZeroException if {@code d} is empty.\n      * @see #ArrayFieldVector(FieldElement[])\n      * @see #ArrayFieldVector(Field, FieldElement[], boolean)\n      */\n-    public ArrayFieldVector(T[] d, boolean copyArray)\n-        throws NullPointerException, IllegalArgumentException {\n+    public ArrayFieldVector(T[] d, boolean copyArray) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n         field = d[0].getField();\n         data = copyArray ? d.clone() :  d;\n     /**\n      * Create a new ArrayFieldVector using the input array as the underlying\n      * data array.\n-     * <p>If an array is built specially in order to be embedded in a\n-     * ArrayFieldVector and not used directly, the <code>copyArray</code> may be\n-     * set to <code>false</code. This will prevent the copying and improve\n-     * performance as no new array will be built and no data will be copied.</p>\n-     * @param field field to which the elements belong\n-     * @param d data for new vector\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n+     * If an array is built specially in order to be embedded in a\n+     * ArrayFieldVector and not used directly, the {@code copyArray} may be\n+     * set to {@code false}. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param d Data for the new vector.\n+     * @param copyArray If {@code true}, the input array will be copied,\n+     * otherwise it will be referenced.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n      * @see #ArrayFieldVector(FieldElement[], boolean)\n      */\n     public ArrayFieldVector(Field<T> field, T[] d, boolean copyArray) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         this.field = field;\n         data = copyArray ? d.clone() :  d;\n     }\n \n     /**\n      * Construct a vector from part of a array.\n-     * @param d array of Ts.\n-     * @param pos position of first entry\n-     * @param size number of entries to copy\n+     *\n+     * @param d Array.\n+     * @param pos Position of the first entry.\n+     * @param size Number of entries to copy.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws NumberIsTooLargeException if the size of {@code d} is less\n+     * than {@code pos + size}.\n      */\n     public ArrayFieldVector(T[] d, int pos, int size) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         if (d.length < pos + size) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY,\n-                    pos, size, d.length);\n+            throw new NumberIsTooLargeException(pos + size, d.length, true);\n         }\n         field = d[0].getField();\n         data = buildArray(size);\n \n     /**\n      * Construct a vector from another vector, using a deep copy.\n-     * @param v vector to copy\n+     *\n+     * @param v Vector to copy.\n+     * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayFieldVector(FieldVector<T> v) {\n+        if (v == null) {\n+            throw new NullArgumentException();\n+        }\n         field = v.getField();\n         data = buildArray(v.getDimension());\n         for (int i = 0; i < data.length; ++i) {\n \n     /**\n      * Construct a vector from another vector, using a deep copy.\n-     * @param v vector to copy\n+     *\n+     * @param v Vector to copy.\n+     * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v) {\n+        if (v == null) {\n+            throw new NullArgumentException();\n+        }\n         field = v.getField();\n         data = v.data.clone();\n     }\n \n     /**\n      * Construct a vector from another vector.\n-     * @param v vector to copy\n-     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     *\n+     * @param v Vector to copy.\n+     * @param deep If {@code true} perform a deep copy, otherwise perform\n+     * a shallow copy\n+     * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v, boolean deep) {\n+        if (v == null) {\n+            throw new NullArgumentException();\n+        }\n         field = v.getField();\n         data = deep ? v.data.clone() : v.data;\n     }\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     *\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n+     * @throws NullArgumentException if {@code v1} or {@code v2} is\n+     * {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v1, ArrayFieldVector<T> v2) {\n+        if (v1 == null ||\n+            v2 == null) {\n+            throw new NullArgumentException();\n+        }\n         field = v1.getField();\n         data = buildArray(v1.data.length + v2.data.length);\n         System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     *\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n+     * @throws NullArgumentException if {@code v1} or {@code v2} is\n+     * {@code null}.\n      */\n     public ArrayFieldVector(ArrayFieldVector<T> v1, T[] v2) {\n+        if (v1 == null ||\n+            v2 == null) {\n+            throw new NullArgumentException();\n+        }\n         field = v1.getField();\n         data = buildArray(v1.data.length + v2.length);\n         System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     *\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n+     * @throws NullArgumentException if {@code v1} or {@code v2} is\n+     * {@code null}.\n      */\n     public ArrayFieldVector(T[] v1, ArrayFieldVector<T> v2) {\n+        if (v1 == null ||\n+            v2 == null) {\n+            throw new NullArgumentException();\n+        }\n         field = v2.getField();\n         data = buildArray(v1.length + v2.data.length);\n         System.arraycopy(v1, 0, data, 0, v1.length);\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * <p>\n      * This constructor needs at least one non-empty array to retrieve\n      * the field from its first element. This implies it cannot build\n      * 0 length vectors. To build vectors from any size, one should\n-     * use the {@link #ArrayFieldVector(Field, FieldElement[], FieldElement[])} constructor.\n-     * </p>\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n-     * @exception IllegalArgumentException if both vectors are empty\n+     * use the {@link #ArrayFieldVector(Field, FieldElement[], FieldElement[])}\n+     * constructor.\n+     *\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n+     * @throws NullArgumentException if {@code v1} or {@code v2} is\n+     * {@code null}.\n+     * @throws ZeroException if both arrays are empty.\n      * @see #ArrayFieldVector(Field, FieldElement[], FieldElement[])\n      */\n     public ArrayFieldVector(T[] v1, T[] v2) {\n-        try {\n-            data = buildArray(v1.length + v2.length);\n-            System.arraycopy(v1, 0, data, 0, v1.length);\n-            System.arraycopy(v2, 0, data, v1.length, v2.length);\n-            field = data[0].getField();\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n-        }\n+        if (v1 == null ||\n+            v2 == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (v1.length + v2.length == 0) {\n+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n+        }\n+        data = buildArray(v1.length + v2.length);\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2, 0, data, v1.length, v2.length);\n+        field = data[0].getField();\n     }\n \n     /**\n      * Construct a vector by appending one vector to another vector.\n-     * @param field field to which the elements belong\n-     * @param v1 first vector (will be put in front of the new vector)\n-     * @param v2 second vector (will be put at back of the new vector)\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param v1 First vector (will be put in front of the new vector).\n+     * @param v2 Second vector (will be put at back of the new vector).\n+     * @throws NullArgumentException if {@code v1} or {@code v2} is\n+     * {@code null}.\n+     * @throws ZeroException if both arrays are empty.\n      * @see #ArrayFieldVector(FieldElement[], FieldElement[])\n      */\n     public ArrayFieldVector(Field<T> field, T[] v1, T[] v2) {\n         if (v1.length + v2.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n         }\n         data = buildArray(v1.length + v2.length);\n         System.arraycopy(v1, 0, data, 0, v1.length);\n         this.field = data[0].getField();\n     }\n \n-    /** Build an array of elements.\n-     * @param length size of the array to build\n-     * @return a new array\n+    /**\n+     * Build an array of elements.\n+     *\n+     * @param length Size of the array to build.\n+     * @return a new array.\n      */\n     @SuppressWarnings(\"unchecked\") // field is of type T\n     private T[] buildArray(final int length) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+    public FieldVector<T> add(FieldVector<T> v) {\n         try {\n             return add((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+    public FieldVector<T> add(T[] v) {\n         checkVectorDimensions(v.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n      * @return this + v\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public ArrayFieldVector<T> add(ArrayFieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public ArrayFieldVector<T> add(ArrayFieldVector<T> v) {\n         return (ArrayFieldVector<T>) add(v.data);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {\n+    public FieldVector<T> subtract(FieldVector<T> v) {\n         try {\n             return subtract((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+    public FieldVector<T> subtract(T[] v) {\n         checkVectorDimensions(v.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n      * @return this + v\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v) {\n         return (ArrayFieldVector<T>) subtract(v.data);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v) {\n         try {\n             return ebeMultiply((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeMultiply(T[] v)\n-        throws IllegalArgumentException {\n+    public FieldVector<T> ebeMultiply(T[] v) {\n         checkVectorDimensions(v.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n      * @return a vector containing this[i] * v[i] for all i\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n-    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v) {\n         return (ArrayFieldVector<T>) ebeMultiply(v.data);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public FieldVector<T> ebeDivide(FieldVector<T> v) {\n         try {\n             return ebeDivide((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(T[] v)\n-        throws IllegalArgumentException {\n+    public FieldVector<T> ebeDivide(T[] v) {\n         checkVectorDimensions(v.length);\n         T[] out = buildArray(data.length);\n         for (int i = 0; i < data.length; i++) {\n      * @return a vector containing this[i] / v[i] for all i\n      * @throws IllegalArgumentException if v is not the same size as this\n      */\n-    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v) {\n         return (ArrayFieldVector<T>) ebeDivide(v.data);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public T dotProduct(FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public T dotProduct(FieldVector<T> v) {\n         try {\n             return dotProduct((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n     }\n \n     /** {@inheritDoc} */\n-    public T dotProduct(T[] v)\n-        throws IllegalArgumentException {\n+    public T dotProduct(T[] v) {\n         checkVectorDimensions(v.length);\n         T dot = field.getZero();\n         for (int i = 0; i < data.length; i++) {\n      * @return the scalar dot product between instance and v\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n-    public T dotProduct(ArrayFieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public T dotProduct(ArrayFieldVector<T> v) {\n         return dotProduct(v.data);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> outerProduct(FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public FieldMatrix<T> outerProduct(FieldVector<T> v) {\n         try {\n             return outerProduct((ArrayFieldVector<T>) v);\n         } catch (ClassCastException cce) {\n      * @return the square matrix outer product between instance and v\n      * @exception IllegalArgumentException if v is not the same size as this\n      */\n-    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v) {\n         return outerProduct(v.data);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> outerProduct(T[] v)\n-        throws IllegalArgumentException {\n+    public FieldMatrix<T> outerProduct(T[] v) {\n         checkVectorDimensions(v.length);\n         final int m = data.length;\n         final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, m);\n     }\n \n     /** {@inheritDoc} */\n-    public T getEntry(int index) throws MatrixIndexException {\n+    public T getEntry(int index) {\n         return data[index];\n     }\n \n      *\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     * @exception MatrixIndexException if the index is\n+     * @throws OutOfRangeException if the index is\n      * inconsistent with vector size\n      */\n-    public void set(int index, ArrayFieldVector<T> v)\n-        throws MatrixIndexException {\n+    public void set(int index, ArrayFieldVector<T> v) {\n         setSubVector(index, v.data);\n     }\n \n      * @exception IllegalArgumentException if the vectors do not\n      * have the same dimension\n      */\n-    protected void checkVectorDimensions(FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    protected void checkVectorDimensions(FieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n     }\n \n     /**\n      * Check if instance dimension is equal to some expected value.\n      *\n-     * @param n expected dimension.\n-     * @exception IllegalArgumentException if the dimension is\n-     * inconsistent with vector size\n-     */\n-    protected void checkVectorDimensions(int n)\n-        throws IllegalArgumentException {\n+     * @param n Expected dimension.\n+     * @throws OutOfRangeException if the dimension is\n+     * inconsistent with this vector size.\n+     */\n+    protected void checkVectorDimensions(int n) {\n         if (data.length != n) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    data.length, n);\n-        }\n-    }\n-\n-    /**\n-     * Test for the equality of two real vectors.\n-     * <p>\n-     * If all coordinates of two real vectors are exactly the same, and none are\n-     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n-     * </p>\n-     * <p>\n-     * <code>NaN</code> coordinates are considered to affect globally the vector\n-     * and be equals to each other - i.e, if either (or all) coordinates of the\n-     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n-     * a vector with all <code>Double.NaN</code> coordinates.\n-     * </p>\n-     *\n-     * @param other Object to test for equality to this\n-     * @return true if two 3D vector objects are equal, false if\n-     *         object is null, not an instance of Vector3D, or\n-     *         not equal to this Vector3D instance\n-     *\n+            throw new DimensionMismatchException(data.length, n);\n+        }\n+    }\n+\n+    /**\n+     * Test for the equality of two vectors.\n+     *\n+     * @param other Object to test for equality.\n+     * @return {@code true} if two vector objects are equal, {@code false}\n+     * otherwise.\n      */\n     @Override\n     public boolean equals(Object other) {\n-\n-      if (this == other) {\n-        return true;\n-      }\n-\n-      if (other == null) {\n-        return false;\n-      }\n-\n-      try {\n-          @SuppressWarnings(\"unchecked\") // May fail, but we ignore ClassCastException\n-          FieldVector<T> rhs = (FieldVector<T>) other;\n-          if (data.length != rhs.getDimension()) {\n-              return false;\n-          }\n-\n-          for (int i = 0; i < data.length; ++i) {\n-              if (!data[i].equals(rhs.getEntry(i))) {\n-                  return false;\n-              }\n-          }\n-          return true;\n-\n-      } catch (ClassCastException ex) {\n-          // ignore exception\n-          return false;\n-      }\n-\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other == null) {\n+            return false;\n+        }\n+\n+        try {\n+            @SuppressWarnings(\"unchecked\") // May fail, but we ignore ClassCastException\n+                FieldVector<T> rhs = (FieldVector<T>) other;\n+            if (data.length != rhs.getDimension()) {\n+                return false;\n+            }\n+\n+            for (int i = 0; i < data.length; ++i) {\n+                if (!data[i].equals(rhs.getEntry(i))) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        } catch (ClassCastException ex) {\n+            // ignore exception\n+            return false;\n+        }\n     }\n \n     /**\n \n     /**\n      * Check if an index is valid.\n-     * @param index index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    private void checkIndex(final int index)\n-        throws MatrixIndexException {\n+     *\n+     * @param index Index to check.\n+     * @exception OutOfRangeException if the index is not valid.\n+     */\n+    private void checkIndex(final int index) {\n         if (index < 0 || index >= getDimension()) {\n-            throw new MatrixIndexException(LocalizedFormats.INDEX_OUT_OF_RANGE,\n-                                           index, 0, getDimension() - 1);\n-        }\n-    }\n-\n+            throw new OutOfRangeException(LocalizedFormats.INDEX,\n+                                          index, 0, getDimension() - 1);\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n import java.util.Arrays;\n import java.util.Iterator;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n  * @since 2.0\n  */\n public class ArrayRealVector extends AbstractRealVector implements Serializable {\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1097961340710804027L;\n-\n     /** Default format. */\n     private static final RealVectorFormat DEFAULT_FORMAT =\n         RealVectorFormat.getInstance();\n-\n     /** Entries of the vector. */\n     protected double data[];\n \n     /**\n      * Build a 0-length vector.\n-     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * Zero-length vectors may be used to initialized construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #ArrayRealVector(ArrayRealVector, ArrayRealVector)} constructor\n-     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * or one of the {@code append} method ({@link #append(double)}, {@link\n      * #append(double[])}, {@link #append(ArrayRealVector)}) to gather data\n-     * into this vector.</p>\n+     * into this vector.\n      */\n     public ArrayRealVector() {\n         data = new double[0];\n     }\n \n     /**\n-     * Construct a (size)-length vector of zeros.\n-     * @param size size of the vector\n+     * Construct a vector of zeroes.\n+     *\n+     * @param size Size of the vector.\n      */\n     public ArrayRealVector(int size) {\n         data = new double[size];\n     }\n \n     /**\n-     * Construct an (size)-length vector with preset values.\n-     * @param size size of the vector\n-     * @param preset fill the vector with this scalar value\n+     * Construct a vector with preset values.\n+     *\n+     * @param size Size of the vector\n+     * @param preset All entries will be set with this value.\n      */\n     public ArrayRealVector(int size, double preset) {\n         data = new double[size];\n \n     /**\n      * Construct a vector from an array, copying the input array.\n-     * @param d array of doubles.\n+     *\n+     * @param d Array.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n      */\n     public ArrayRealVector(double[] d) {\n         data = d.clone();\n     /**\n      * Create a new ArrayRealVector using the input array as the underlying\n      * data array.\n-     * <p>If an array is built specially in order to be embedded in a\n-     * ArrayRealVector and not used directly, the <code>copyArray</code> may be\n-     * set to <code>false</code. This will prevent the copying and improve\n-     * performance as no new array will be built and no data will be copied.</p>\n-     * @param d data for new vector\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n+     * If an array is built specially in order to be embedded in a\n+     * ArrayRealVector and not used directly, the {@code copyArray} may be\n+     * set to {@code false}. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.\n+     *\n+     * @param d Data for the new vector.\n+     * @param copyArray if {@code true}, the input array will be copied,\n+     * otherwise it will be referenced.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n      * @see #ArrayRealVector(double[])\n      */\n     public ArrayRealVector(double[] d, boolean copyArray) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         data = copyArray ? d.clone() :  d;\n     }\n \n     /**\n      * Construct a vector from part of a array.\n-     * @param d array of doubles.\n-     * @param pos position of first entry\n-     * @param size number of entries to copy\n+     *\n+     * @param d Array.\n+     * @param pos Position of first entry.\n+     * @param size Number of entries to copy.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws NumberIsTooLargeException if the size of {@code d} is less\n+     * than {@code pos + size}.\n      */\n     public ArrayRealVector(double[] d, int pos, int size) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         if (d.length < pos + size) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY, pos, size, d.length);\n+            throw new NumberIsTooLargeException(pos + size, d.length, true);\n         }\n         data = new double[size];\n         System.arraycopy(d, pos, data, 0, size);\n     }\n \n     /**\n-     * Construct a vector from part of a Double array\n-     * @param d array of Doubles.\n-     * @param pos position of first entry\n-     * @param size number of entries to copy\n+     * Construct a vector from part of an array.\n+     *\n+     * @param d Array.\n+     * @param pos Position of first entry.\n+     * @param size Number of entries to copy.\n+     * @throws NullArgumentException if {@code d} is {@code null}.\n+     * @throws NumberIsTooLargeException if the size of {@code d} is less\n+     * than {@code pos + size}.\n      */\n     public ArrayRealVector(Double[] d, int pos, int size) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         if (d.length < pos + size) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY, pos, size, d.length);\n+            throw new NumberIsTooLargeException(pos + size, d.length, true);\n         }\n         data = new double[size];\n         for (int i = pos; i < pos + size; i++) {\n-            data[i-pos] = d[i].doubleValue();\n+            data[i - pos] = d[i].doubleValue();\n         }\n     }\n \n     /**\n      * Construct a vector from another vector, using a deep copy.\n-     * @param v vector to copy\n+     *\n+     * @param v vector to copy.\n+     * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayRealVector(RealVector v) {\n+        if (v == null) {\n+            throw new NullArgumentException();\n+        }\n         data = new double[v.getDimension()];\n         for (int i = 0; i < data.length; ++i) {\n             data[i] = v.getEntry(i);\n \n     /**\n      * Construct a vector from another vector, using a deep copy.\n-     * @param v vector to copy\n+     *\n+     * @param v Vector to copy.\n+     * @throws NullArgumentException if {@code v} is {@code null}.\n      */\n     public ArrayRealVector(ArrayRealVector v) {\n         this(v, true);\n \n     /**\n      * Construct a vector from another vector.\n-     * @param v vector to copy\n-     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     *\n+     * @param v Vector to copy.\n+     * @param deep If {@code true} perform a deep copy, otherwise perform a\n+     * shallow copy.\n      */\n     public ArrayRealVector(ArrayRealVector v, boolean deep) {\n         data = deep ? v.data.clone() : v.data;\n \n     /**\n      * Compute the dot product.\n-     * @param v vector with which dot product should be computed\n-     * @return the scalar dot product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    public double dotProduct(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+     *\n+     * @param v Vector with which dot product should be computed\n+     * @return the scalar dot product between instance and {@code v}.\n+     * @throws DimensionMismatchException if {@code v} is not the same\n+     * size as this vector.\n+     */\n+    public double dotProduct(ArrayRealVector v) {\n         return dotProduct(v.data);\n     }\n \n \n    /**\n      * Distance between two vectors.\n-     * <p>This method computes the distance consistent with the\n+     * This method computes the distance consistent with the\n      * L<sub>2</sub> norm, i.e. the square root of the sum of\n-     * elements differences, or euclidian distance.</p>\n+     * elements differences, or euclidian distance.\n+     *\n      * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @return the distance between two vectors.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * this vector.\n      * @see #getDistance(RealVector)\n      * @see #getL1Distance(ArrayRealVector)\n      * @see #getLInfDistance(ArrayRealVector)\n      * @see #getNorm()\n      */\n-    public double getDistance(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+    public double getDistance(ArrayRealVector v) {\n         return getDistance(v.data);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getL1Distance(RealVector v)\n-        throws IllegalArgumentException {\n+    public double getL1Distance(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return getL1Distance((ArrayRealVector) v);\n         } else {\n \n     /**\n      * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n+     * This method computes the distance consistent with\n      * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n-     * elements differences.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * elements differences.\n+     *\n+     * @param v Vector to which distance is requested.\n+     * @return the distance between two vectors.\n+     * @throws DimensionMismatchException if {@code v} is not the same size\n+     * as this vector.\n      * @see #getDistance(RealVector)\n      * @see #getL1Distance(ArrayRealVector)\n      * @see #getLInfDistance(ArrayRealVector)\n      * @see #getNorm()\n      */\n-    public double getL1Distance(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+    public double getL1Distance(ArrayRealVector v) {\n         return getL1Distance(v.data);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getLInfDistance(RealVector v)\n-        throws IllegalArgumentException {\n+    public double getLInfDistance(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n             return getLInfDistance((ArrayRealVector) v);\n         } else {\n \n     /**\n      * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n+     * This method computes the distance consistent with\n      * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n-     * elements differences.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * elements differences.\n+     *\n+     * @param v Vector to which distance is requested.\n+     * @return the distance between two vectors.\n+     * @exception IllegalArgumentException if {@code v} is not the same size as this\n      * @see #getDistance(RealVector)\n      * @see #getL1Distance(ArrayRealVector)\n      * @see #getLInfDistance(ArrayRealVector)\n      * @see #getNorm()\n      */\n-    public double getLInfDistance(ArrayRealVector v)\n-        throws IllegalArgumentException {\n+    public double getLInfDistance(ArrayRealVector v) {\n         return getLInfDistance(v.data);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector unitVector() throws ArithmeticException {\n+    public RealVector unitVector() {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM);\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n         return mapDivide(norm);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public void unitize() throws ArithmeticException {\n+    public void unitize() {\n         final double norm = getNorm();\n         if (norm == 0) {\n-            throw MathRuntimeException.createArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n         mapDivideToSelf(norm);\n     }\n         return projection(new ArrayRealVector(v, false));\n     }\n \n-   /** Find the orthogonal projection of this vector onto another vector.\n-     * @param v vector onto which instance must be projected\n-     * @return projection of the instance onto v\n-     * @throws IllegalArgumentException if v is not the same size as this\n+    /**\n+     * Find the orthogonal projection of this vector onto another vector.\n+     *\n+     * @param v Vector onto which instance must be projected.\n+     * @return Projection of this instance onto {@code v}.\n+     * @throws DimensionMismatchException if {@code v} is not the same size as\n+     * this vector.\n      */\n     public ArrayRealVector projection(ArrayRealVector v) {\n         return (ArrayRealVector) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n     }\n \n     /** {@inheritDoc} */\n-    public double getEntry(int index) throws MatrixIndexException {\n+    public double getEntry(int index) {\n         return data[index];\n     }\n \n \n     /**\n      * Construct a vector by appending a vector to this vector.\n-     * @param v vector to append to this one.\n-     * @return a new vector\n+     *\n+     * @param v Vector to append to this one.\n+     * @return a new vector.\n      */\n     public ArrayRealVector append(ArrayRealVector v) {\n         return new ArrayRealVector(this, v);\n     /**\n      * Set a set of consecutive elements.\n      *\n-     * @param index index of first element to be set.\n-     * @param v vector containing the values to set.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n-     */\n-    public void set(int index, ArrayRealVector v)\n-        throws MatrixIndexException {\n+     * @param index Index of first element to be set.\n+     * @param v Vector containing the values to set.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is inconsistent with vector size.\n+     */\n+    public void set(int index, ArrayRealVector v) {\n         setSubVector(index, v.data);\n     }\n \n \n     /**\n      * Check if instance and specified vectors have the same dimension.\n-     * @param v vector to compare instance with\n-     * @exception IllegalArgumentException if the vectors do not\n-     * have the same dimension\n-     */\n-    @Override\n-    protected void checkVectorDimensions(RealVector v)\n-        throws IllegalArgumentException {\n+     *\n+     * @param v Vector to compare instance with.\n+     * @throws DimensionMismatchException if the vectors do not\n+     * have the same dimension.\n+     */\n+    @Override\n+    protected void checkVectorDimensions(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n     }\n \n     /**\n      * Check if instance dimension is equal to some expected value.\n      *\n-     * @param n expected dimension.\n-     * @exception IllegalArgumentException if the dimension is\n-     * inconsistent with vector size\n-     */\n-    @Override\n-    protected void checkVectorDimensions(int n)\n-        throws IllegalArgumentException {\n+     * @param n Expected dimension.\n+     * @throws DimensionMismatchException if the dimension is\n+     * inconsistent with vector size.\n+     */\n+    @Override\n+    protected void checkVectorDimensions(int n) {\n         if (data.length != n) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    data.length, n);\n-        }\n-    }\n-\n-    /**\n-     * Returns true if any coordinate of this vector is NaN; false otherwise\n-     * @return  true if any coordinate of this vector is NaN; false otherwise\n+            throw new DimensionMismatchException(data.length, n);\n+        }\n+    }\n+\n+    /**\n+     * Check if any coordinate of this vector is {@code NaN}.\n+     *\n+     * @return {@code true} if any coordinate of this vector is {@code NaN},\n+     * {@code false} otherwise.\n      */\n     public boolean isNaN() {\n         for (double v : data) {\n     }\n \n     /**\n-     * Returns true if any coordinate of this vector is infinite and none are NaN;\n-     * false otherwise\n-     * @return  true if any coordinate of this vector is infinite and none are NaN;\n-     * false otherwise\n+     * Check whether any coordinate of this vector is infinite and none\n+     * are {@code NaN}.\n+     *\n+     * @return {@code true} if any coordinate of this vector is infinite and\n+     * none are {@code NaN}, {@code false} otherwise.\n      */\n     public boolean isInfinite() {\n-\n         if (isNaN()) {\n             return false;\n         }\n         }\n \n         return false;\n-\n     }\n \n     /**\n      * Test for the equality of two real vectors.\n-     * <p>\n      * If all coordinates of two real vectors are exactly the same, and none are\n-     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n-     * </p>\n-     * <p>\n-     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * {@code NaN}, the two real vectors are considered to be equal.\n+     * {@code NaN} coordinates are considered to affect globally the vector\n      * and be equals to each other - i.e, if either (or all) coordinates of the\n-     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n-     * a vector with all <code>Double.NaN</code> coordinates.\n-     * </p>\n-     *\n-     * @param other Object to test for equality to this\n-     * @return true if two vector objects are equal, false if\n-     *         object is null, not an instance of RealVector, or\n-     *         not equal to this RealVector instance\n-     *\n+     * real vector are equal to {@code NaN}, the real vector is equal to\n+     * a vector with all {@code NaN} coordinates.\n+     *\n+     * @param other Object to test for equality.\n+     * @return {@code true} if two vector objects are equal, {@code false} if\n+     * {@code other} is null, not an instance of {@code RealVector}, or\n+     * not equal to this {@code RealVector} instance.\n      */\n     @Override\n     public boolean equals(Object other) {\n-\n-      if (this == other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other == null || !(other instanceof RealVector)) {\n+            return false;\n+        }\n+\n+        RealVector rhs = (RealVector) other;\n+        if (data.length != rhs.getDimension()) {\n+            return false;\n+        }\n+\n+        if (rhs.isNaN()) {\n+            return this.isNaN();\n+        }\n+\n+        for (int i = 0; i < data.length; ++i) {\n+            if (data[i] != rhs.getEntry(i)) {\n+                return false;\n+            }\n+        }\n         return true;\n-      }\n-\n-      if (other == null || !(other instanceof RealVector)) {\n-        return false;\n-      }\n-\n-\n-      RealVector rhs = (RealVector) other;\n-      if (data.length != rhs.getDimension()) {\n-        return false;\n-      }\n-\n-      if (rhs.isNaN()) {\n-        return this.isNaN();\n-      }\n-\n-      for (int i = 0; i < data.length; ++i) {\n-        if (data[i] != rhs.getEntry(i)) {\n-          return false;\n-        }\n-      }\n-      return true;\n     }\n \n     /**\n      * Get a hashCode for the real vector.\n-     * <p>All NaN values have the same hash code.</p>\n-     * @return a hash code value for this object\n+     * All {@code NaN} values have the same hash code.\n+     *\n+     * @return a hash code.\n      */\n     @Override\n     public int hashCode() {\n         }\n         return MathUtils.hash(data);\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n  * @since 2.0\n  */\n public class BlockRealMatrix extends AbstractRealMatrix implements Serializable {\n-\n     /** Block size. */\n     public static final int BLOCK_SIZE = 52;\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 4991895511313664478L;\n-\n     /** Blocks of matrix entries. */\n     private final double blocks[][];\n-\n     /** Number of rows of the matrix. */\n     private final int rows;\n-\n     /** Number of columns of the matrix. */\n     private final int columns;\n-\n     /** Number of block rows of the matrix. */\n     private final int blockRows;\n-\n     /** Number of block columns of the matrix. */\n     private final int blockColumns;\n \n      * @param rows  the number of rows in the new matrix\n      * @param columns  the number of columns in the new matrix\n      * @throws IllegalArgumentException if row or column dimension is not\n-     *  positive\n+     * positive.\n      */\n-    public BlockRealMatrix(final int rows, final int columns)\n-        throws IllegalArgumentException {\n-\n+    public BlockRealMatrix(final int rows, final int columns) {\n         super(rows, columns);\n-        this.rows    = rows;\n+        this.rows = rows;\n         this.columns = columns;\n \n         // number of blocks\n-        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n         blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n         // allocate storage blocks, taking care of smaller ones at right and bottom\n         blocks = createBlocksLayout(rows, columns);\n-\n     }\n \n     /**\n      * @see #BlockRealMatrix(double[][])\n      */\n     public BlockRealMatrix(final int rows, final int columns,\n-                           final double[][] blockData, final boolean copyArray)\n-        throws IllegalArgumentException {\n-\n+                           final double[][] blockData, final boolean copyArray) {\n         super(rows, columns);\n-        this.rows    = rows;\n+        this.rows = rows;\n         this.columns = columns;\n \n         // number of blocks\n-        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n         blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n         if (copyArray) {\n      * @see #createBlocksLayout(int, int)\n      * @see #BlockRealMatrix(int, int, double[][], boolean)\n      */\n-    public static double[][] toBlocksLayout(final double[][] rawData)\n-        throws IllegalArgumentException {\n-\n-        final int rows         = rawData.length;\n-        final int columns      = rawData[0].length;\n-        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+    public static double[][] toBlocksLayout(final double[][] rawData) {\n+        final int rows = rawData.length;\n+        final int columns = rawData[0].length;\n+        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n         // safety checks\n         final double[][] blocks = new double[blockRows * blockColumns][];\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n-            final int pStart  = iBlock * BLOCK_SIZE;\n-            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n \n                 // allocate new block\n                     System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                     index += jWidth;\n                 }\n-\n                 ++blockIndex;\n-\n             }\n         }\n \n      * @see #BlockRealMatrix(int, int, double[][], boolean)\n      */\n     public static double[][] createBlocksLayout(final int rows, final int columns) {\n-\n-        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n         final double[][] blocks = new double[blockRows * blockColumns][];\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n-            final int pStart  = iBlock * BLOCK_SIZE;\n-            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n                 blocks[blockIndex] = new double[iHeight * jWidth];\n                 ++blockIndex;\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n+    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension) {\n         return new BlockRealMatrix(rowDimension, columnDimension);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public BlockRealMatrix copy() {\n-\n         // create an empty matrix\n         BlockRealMatrix copied = new BlockRealMatrix(rows, columns);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix add(final RealMatrix m)\n-        throws IllegalArgumentException {\n+    public BlockRealMatrix add(final RealMatrix m) {\n         try {\n             return add((BlockRealMatrix) m);\n         } catch (ClassCastException cce) {\n-\n             // safety check\n             MatrixUtils.checkAdditionCompatible(this, m);\n \n                     // perform addition on the current block\n                     final double[] outBlock = out.blocks[blockIndex];\n                     final double[] tBlock   = blocks[blockIndex];\n-                    final int      pStart   = iBlock * BLOCK_SIZE;\n-                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);\n-                    final int      qStart   = jBlock * BLOCK_SIZE;\n-                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                    final int pStart = iBlock * BLOCK_SIZE;\n+                    final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     int k = 0;\n                     for (int p = pStart; p < pEnd; ++p) {\n                         for (int q = qStart; q < qEnd; ++q) {\n                             ++k;\n                         }\n                     }\n-\n                     // go to next block\n                     ++blockIndex;\n-\n                 }\n             }\n \n     }\n \n     /**\n-     * Compute the sum of this and <code>m</code>.\n+     * Compute the sum of this matrix and {@code m}.\n      *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n+     * @param m Matrix to be added.\n+     * @return {@code this} + m.\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as this matrix.\n      */\n-    public BlockRealMatrix add(final BlockRealMatrix m)\n-        throws IllegalArgumentException {\n-\n+    public BlockRealMatrix add(final BlockRealMatrix m) {\n         // safety check\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n         // perform addition block-wise, to ensure good cache behavior\n         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n             final double[] outBlock = out.blocks[blockIndex];\n-            final double[] tBlock   = blocks[blockIndex];\n-            final double[] mBlock   = m.blocks[blockIndex];\n+            final double[] tBlock = blocks[blockIndex];\n+            final double[] mBlock = m.blocks[blockIndex];\n             for (int k = 0; k < outBlock.length; ++k) {\n                 outBlock[k] = tBlock[k] + mBlock[k];\n             }\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix subtract(final RealMatrix m)\n-        throws IllegalArgumentException {\n+    public BlockRealMatrix subtract(final RealMatrix m) {\n         try {\n             return subtract((BlockRealMatrix) m);\n         } catch (ClassCastException cce) {\n-\n             // safety check\n             MatrixUtils.checkSubtractionCompatible(this, m);\n \n \n                     // perform subtraction on the current block\n                     final double[] outBlock = out.blocks[blockIndex];\n-                    final double[] tBlock   = blocks[blockIndex];\n-                    final int      pStart   = iBlock * BLOCK_SIZE;\n-                    final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);\n-                    final int      qStart   = jBlock * BLOCK_SIZE;\n-                    final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                    final double[] tBlock = blocks[blockIndex];\n+                    final int pStart = iBlock * BLOCK_SIZE;\n+                    final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     int k = 0;\n                     for (int p = pStart; p < pEnd; ++p) {\n                         for (int q = qStart; q < qEnd; ++q) {\n                             ++k;\n                         }\n                     }\n-\n                     // go to next block\n                     ++blockIndex;\n-\n                 }\n             }\n \n     }\n \n     /**\n-     * Compute this minus <code>m</code>.\n+     * Subtract {@code m} from this matrix.\n      *\n-     * @param m    matrix to be subtracted\n-     * @return     this - m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n+     * @param m Matrix to be subtracted.\n+     * @return {@code this} - m.\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the\n+     * same size as this matrix.\n      */\n-    public BlockRealMatrix subtract(final BlockRealMatrix m)\n-        throws IllegalArgumentException {\n-\n+    public BlockRealMatrix subtract(final BlockRealMatrix m) {\n         // safety check\n         MatrixUtils.checkSubtractionCompatible(this, m);\n \n         // perform subtraction block-wise, to ensure good cache behavior\n         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n             final double[] outBlock = out.blocks[blockIndex];\n-            final double[] tBlock   = blocks[blockIndex];\n-            final double[] mBlock   = m.blocks[blockIndex];\n+            final double[] tBlock = blocks[blockIndex];\n+            final double[] mBlock = m.blocks[blockIndex];\n             for (int k = 0; k < outBlock.length; ++k) {\n                 outBlock[k] = tBlock[k] - mBlock[k];\n             }\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix scalarAdd(final double d)\n-        throws IllegalArgumentException {\n+    public BlockRealMatrix scalarAdd(final double d) {\n \n         final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n \n         // perform subtraction block-wise, to ensure good cache behavior\n         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n             final double[] outBlock = out.blocks[blockIndex];\n-            final double[] tBlock   = blocks[blockIndex];\n+            final double[] tBlock = blocks[blockIndex];\n             for (int k = 0; k < outBlock.length; ++k) {\n                 outBlock[k] = tBlock[k] + d;\n             }\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix scalarMultiply(final double d)\n-        throws IllegalArgumentException {\n-\n+    public RealMatrix scalarMultiply(final double d) {\n         final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n \n         // perform subtraction block-wise, to ensure good cache behavior\n         for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n             final double[] outBlock = out.blocks[blockIndex];\n-            final double[] tBlock   = blocks[blockIndex];\n+            final double[] tBlock = blocks[blockIndex];\n             for (int k = 0; k < outBlock.length; ++k) {\n                 outBlock[k] = tBlock[k] * d;\n             }\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix multiply(final RealMatrix m)\n-        throws IllegalArgumentException {\n+    public BlockRealMatrix multiply(final RealMatrix m) {\n         try {\n             return multiply((BlockRealMatrix) m);\n         } catch (ClassCastException cce) {\n-\n             // safety check\n             MatrixUtils.checkMultiplicationCompatible(this, m);\n \n             // perform multiplication block-wise, to ensure good cache behavior\n             int blockIndex = 0;\n             for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n-\n                 final int pStart = iBlock * BLOCK_SIZE;\n-                final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n \n                 for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n-\n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n \n                     // select current block\n                     final double[] outBlock = out.blocks[blockIndex];\n \n                     // perform multiplication on current block\n                     for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n-                        final int kWidth      = blockWidth(kBlock);\n+                        final int kWidth = blockWidth(kBlock);\n                         final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n-                        final int rStart      = kBlock * BLOCK_SIZE;\n+                        final int rStart = kBlock * BLOCK_SIZE;\n                         int k = 0;\n                         for (int p = pStart; p < pEnd; ++p) {\n                             final int lStart = (p - pStart) * kWidth;\n-                            final int lEnd   = lStart + kWidth;\n+                            final int lEnd = lStart + kWidth;\n                             for (int q = qStart; q < qEnd; ++q) {\n                                 double sum = 0;\n                                 int r = rStart;\n                             }\n                         }\n                     }\n-\n                     // go to next block\n                     ++blockIndex;\n-\n                 }\n             }\n \n     }\n \n     /**\n-     * Returns the result of postmultiplying this by m.\n+     * Returns the result of postmultiplying this by {@code m}.\n      *\n-     * @param m    matrix to postmultiply by\n-     * @return     this * m\n-     * @throws     IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n+     * @param m Matrix to postmultiply by.\n+     * @return {@code this} * m.\n+     * @throws MatrixDimensionMismatchException if the matrices are not\n+     * compatible.\n      */\n-    public BlockRealMatrix multiply(BlockRealMatrix m) throws IllegalArgumentException {\n-\n+    public BlockRealMatrix multiply(BlockRealMatrix m) {\n         // safety check\n         MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n \n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n \n             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                 final int jWidth = out.blockWidth(jBlock);\n                     int k = 0;\n                     for (int p = pStart; p < pEnd; ++p) {\n                         final int lStart = (p - pStart) * kWidth;\n-                        final int lEnd   = lStart + kWidth;\n+                        final int lEnd = lStart + kWidth;\n                         for (int nStart = 0; nStart < jWidth; ++nStart) {\n                             double sum = 0;\n                             int l = lStart;\n                         }\n                     }\n                 }\n-\n                 // go to next block\n                 ++blockIndex;\n-\n             }\n         }\n \n     /** {@inheritDoc} */\n     @Override\n     public double[][] getData() {\n-\n         final double[][] data = new double[getRowDimension()][getColumnDimension()];\n         final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n \n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n-            int regularPos   = 0;\n-            int lastPos      = 0;\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            int regularPos = 0;\n+            int lastPos = 0;\n             for (int p = pStart; p < pEnd; ++p) {\n                 final double[] dataP = data[p];\n                 int blockIndex = iBlock * blockColumns;\n-                int dataPos    = 0;\n+                int dataPos = 0;\n                 for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n                     System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n                     dataPos += BLOCK_SIZE;\n     /** {@inheritDoc} */\n     @Override\n     public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n-                                   final int startColumn, final int endColumn)\n-        throws MatrixIndexException {\n-\n+                                        final int startColumn, final int endColumn) {\n         // safety checks\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n \n             new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n \n         // compute blocks shifts\n-        final int blockStartRow    = startRow    / BLOCK_SIZE;\n-        final int rowsShift        = startRow    % BLOCK_SIZE;\n+        final int blockStartRow = startRow / BLOCK_SIZE;\n+        final int rowsShift = startRow % BLOCK_SIZE;\n         final int blockStartColumn = startColumn / BLOCK_SIZE;\n-        final int columnsShift     = startColumn % BLOCK_SIZE;\n+        final int columnsShift = startColumn % BLOCK_SIZE;\n \n         // perform extraction block-wise, to ensure good cache behavior\n         int pBlock = blockStartRow;\n                 final int jWidth = out.blockWidth(jBlock);\n \n                 // handle one block of the output matrix\n-                final int      outIndex = iBlock * out.blockColumns + jBlock;\n+                final int outIndex = iBlock * out.blockColumns + jBlock;\n                 final double[] outBlock = out.blocks[outIndex];\n-                final int      index    = pBlock * blockColumns + qBlock;\n-                final int      width    = blockWidth(qBlock);\n+                final int index = pBlock * blockColumns + qBlock;\n+                final int width = blockWidth(qBlock);\n \n                 final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n-                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;\n+                final int widthExcess = jWidth + columnsShift - BLOCK_SIZE;\n                 if (heightExcess > 0) {\n                     // the submatrix block spans on two blocks rows from the original matrix\n                     if (widthExcess > 0) {\n                                       outBlock, jWidth, 0, 0);\n                     }\n                }\n-\n                 ++qBlock;\n-\n-            }\n-\n+            }\n             ++pBlock;\n-\n         }\n \n         return out;\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n-        throws MatrixIndexException {\n-\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) {\n         // safety checks\n         final int refLength = subMatrix[0].length;\n         if (refLength == 0) {\n             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n-        final int endRow    = row + subMatrix.length - 1;\n+        final int endRow = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n         MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);\n         for (final double[] subRow : subMatrix) {\n         }\n \n         // compute blocks bounds\n-        final int blockStartRow    = row / BLOCK_SIZE;\n-        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockStartRow = row / BLOCK_SIZE;\n+        final int blockEndRow = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n         final int blockStartColumn = column / BLOCK_SIZE;\n-        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockEndColumn = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n \n         // perform copy block-wise, to ensure good cache behavior\n         for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n-            final int iHeight  = blockHeight(iBlock);\n+            final int iHeight = blockHeight(iBlock);\n             final int firstRow = iBlock * BLOCK_SIZE;\n-            final int iStart   = FastMath.max(row,    firstRow);\n-            final int iEnd     = FastMath.min(endRow + 1, firstRow + iHeight);\n+            final int iStart = FastMath.max(row,    firstRow);\n+            final int iEnd = FastMath.min(endRow + 1, firstRow + iHeight);\n \n             for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n-                final int jWidth      = blockWidth(jBlock);\n+                final int jWidth = blockWidth(jBlock);\n                 final int firstColumn = jBlock * BLOCK_SIZE;\n-                final int jStart      = FastMath.max(column,    firstColumn);\n-                final int jEnd        = FastMath.min(endColumn + 1, firstColumn + jWidth);\n-                final int jLength     = jEnd - jStart;\n+                final int jStart = FastMath.max(column,    firstColumn);\n+                final int jEnd = FastMath.min(endColumn + 1, firstColumn + jWidth);\n+                final int jLength = jEnd - jStart;\n \n                 // handle one block, row by row\n                 final double[] block = blocks[iBlock * blockColumns + jBlock];\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix getRowMatrix(final int row)\n-        throws MatrixIndexException {\n-\n+    public BlockRealMatrix getRowMatrix(final int row) {\n         MatrixUtils.checkRowIndex(this, row);\n         final BlockRealMatrix out = new BlockRealMatrix(1, columns);\n \n         // perform copy block-wise, to ensure good cache behavior\n-        final int iBlock  = row / BLOCK_SIZE;\n-        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow = row - iBlock * BLOCK_SIZE;\n         int outBlockIndex = 0;\n-        int outIndex      = 0;\n+        int outIndex = 0;\n         double[] outBlock = out.blocks[outBlockIndex];\n         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n-            final int jWidth     = blockWidth(jBlock);\n+            final int jWidth = blockWidth(jBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n-            final int available  = outBlock.length - outIndex;\n+            final int available = outBlock.length - outIndex;\n             if (jWidth > available) {\n                 System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n                 outBlock = out.blocks[++outBlockIndex];\n      * @param row the row to be set\n      * @param matrix row matrix (must have one row and the same number of columns\n      * as the instance)\n-     * @throws MatrixIndexException if the specified row index is invalid\n-     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n-     * instance row\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the specified row index is invalid.\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do\n+     * not match one instance row.\n      */\n     public void setRowMatrix(final int row, final BlockRealMatrix matrix) {\n         MatrixUtils.checkRowIndex(this, row);\n \n         // perform copy block-wise, to ensure good cache behavior\n         final int iBlock = row / BLOCK_SIZE;\n-        final int iRow   = row - iBlock * BLOCK_SIZE;\n-        int mBlockIndex  = 0;\n-        int mIndex       = 0;\n-        double[] mBlock  = matrix.blocks[mBlockIndex];\n+        final int iRow = row - iBlock * BLOCK_SIZE;\n+        int mBlockIndex = 0;\n+        int mIndex = 0;\n+        double[] mBlock = matrix.blocks[mBlockIndex];\n         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n-            final int jWidth     = blockWidth(jBlock);\n+            final int jWidth = blockWidth(jBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n             final int available  = mBlock.length - mIndex;\n             if (jWidth > available) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix getColumnMatrix(final int column)\n-        throws MatrixIndexException {\n-\n+    public BlockRealMatrix getColumnMatrix(final int column) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final BlockRealMatrix out = new BlockRealMatrix(rows, 1);\n \n         // perform copy block-wise, to ensure good cache behavior\n-        final int jBlock  = column / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n         final int jColumn = column - jBlock * BLOCK_SIZE;\n-        final int jWidth  = blockWidth(jBlock);\n+        final int jWidth = blockWidth(jBlock);\n         int outBlockIndex = 0;\n-        int outIndex      = 0;\n+        int outIndex = 0;\n         double[] outBlock = out.blocks[outBlockIndex];\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int iHeight = blockHeight(iBlock);\n      * @param column the column to be set\n      * @param matrix column matrix (must have one column and the same number of rows\n      * as the instance)\n-     * @throws MatrixIndexException if the specified column index is invalid\n-     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n-     * instance column\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the specified column index is invalid.\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do\n+     * not match one instance column.\n      */\n     void setColumnMatrix(final int column, final BlockRealMatrix matrix) {\n         MatrixUtils.checkColumnIndex(this, column);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n-        final int jBlock  = column / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n         final int jColumn = column - jBlock * BLOCK_SIZE;\n-        final int jWidth  = blockWidth(jBlock);\n+        final int jWidth = blockWidth(jBlock);\n         int mBlockIndex = 0;\n-        int mIndex      = 0;\n+        int mIndex = 0;\n         double[] mBlock = matrix.blocks[mBlockIndex];\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int iHeight = blockHeight(iBlock);\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector getRowVector(final int row)\n-        throws MatrixIndexException {\n-\n+    public RealVector getRowVector(final int row) {\n         MatrixUtils.checkRowIndex(this, row);\n         final double[] outData = new double[columns];\n \n         // perform copy block-wise, to ensure good cache behavior\n-        final int iBlock  = row / BLOCK_SIZE;\n-        final int iRow    = row - iBlock * BLOCK_SIZE;\n-        int outIndex      = 0;\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow = row - iBlock * BLOCK_SIZE;\n+        int outIndex = 0;\n         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n-            final int jWidth     = blockWidth(jBlock);\n+            final int jWidth = blockWidth(jBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n             System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n             outIndex += jWidth;\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector getColumnVector(final int column)\n-        throws MatrixIndexException {\n-\n+    public RealVector getColumnVector(final int column) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final double[] outData = new double[rows];\n \n         // perform copy block-wise, to ensure good cache behavior\n-        final int jBlock  = column / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n         final int jColumn = column - jBlock * BLOCK_SIZE;\n-        final int jWidth  = blockWidth(jBlock);\n-        int outIndex      = 0;\n+        final int jWidth = blockWidth(jBlock);\n+        int outIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int iHeight = blockHeight(iBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] getRow(final int row)\n-        throws MatrixIndexException {\n-\n+    public double[] getRow(final int row) {\n         MatrixUtils.checkRowIndex(this, row);\n         final double[] out = new double[columns];\n \n         // perform copy block-wise, to ensure good cache behavior\n-        final int iBlock  = row / BLOCK_SIZE;\n-        final int iRow    = row - iBlock * BLOCK_SIZE;\n-        int outIndex      = 0;\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow = row - iBlock * BLOCK_SIZE;\n+        int outIndex = 0;\n         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n             final int jWidth     = blockWidth(jBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n-        final int iBlock  = row / BLOCK_SIZE;\n-        final int iRow    = row - iBlock * BLOCK_SIZE;\n-        int outIndex      = 0;\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow = row - iBlock * BLOCK_SIZE;\n+        int outIndex = 0;\n         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n             final int jWidth     = blockWidth(jBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] getColumn(final int column)\n-        throws MatrixIndexException {\n-\n+    public double[] getColumn(final int column) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final double[] out = new double[rows];\n \n         final int jBlock  = column / BLOCK_SIZE;\n         final int jColumn = column - jBlock * BLOCK_SIZE;\n         final int jWidth  = blockWidth(jBlock);\n-        int outIndex      = 0;\n+        int outIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int iHeight = blockHeight(iBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n         // perform copy block-wise, to ensure good cache behavior\n         final int jBlock  = column / BLOCK_SIZE;\n         final int jColumn = column - jBlock * BLOCK_SIZE;\n-        final int jWidth  = blockWidth(jBlock);\n-        int outIndex      = 0;\n+        final int jWidth = blockWidth(jBlock);\n+        int outIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int iHeight = blockHeight(iBlock);\n             final double[] block = blocks[iBlock * blockColumns + jBlock];\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getEntry(final int row, final int column)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            return blocks[iBlock * blockColumns + jBlock][k];\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setEntry(final int row, final int column, final double value)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            blocks[iBlock * blockColumns + jBlock][k] = value;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void addToEntry(final int row, final int column, final double increment)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            blocks[iBlock * blockColumns + jBlock][k] += increment;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void multiplyEntry(final int row, final int column, final double factor)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            blocks[iBlock * blockColumns + jBlock][k] *= factor;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n+    public double getEntry(final int row, final int column) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+        return blocks[iBlock * blockColumns + jBlock][k];\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+        blocks[iBlock * blockColumns + jBlock][k] = value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final double increment) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        final int iBlock = row    / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+        blocks[iBlock * blockColumns + jBlock][k] += increment;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final double factor) {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+        blocks[iBlock * blockColumns + jBlock][k] *= factor;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public BlockRealMatrix transpose() {\n-\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n             for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n-\n                 // transpose current block\n                 final double[] outBlock = out.blocks[blockIndex];\n-                final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n-                final int      pStart   = iBlock * BLOCK_SIZE;\n-                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n-                final int      qStart   = jBlock * BLOCK_SIZE;\n-                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n+                final double[] tBlock = blocks[jBlock * blockColumns + iBlock];\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns);\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows);\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n                     final int lInc = pEnd - pStart;\n                         l+= lInc;\n                     }\n                 }\n-\n                 // go to next block\n                 ++blockIndex;\n-\n             }\n         }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] operate(final double[] v)\n-        throws IllegalArgumentException {\n-\n+    public double[] operate(final double[] v) {\n         if (v.length != columns) {\n             throw new DimensionMismatchException(v.length, columns);\n         }\n         // perform multiplication block-wise, to ensure good cache behavior\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final double[] block  = blocks[iBlock * blockColumns + jBlock];\n-                final int      qStart = jBlock * BLOCK_SIZE;\n-                final int      qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n                     double sum = 0;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] preMultiply(final double[] v)\n-        throws IllegalArgumentException {\n-\n+    public double[] preMultiply(final double[] v) {\n         if (v.length != rows) {\n             throw new DimensionMismatchException(v.length, rows);\n         }\n             final int jWidth3 = jWidth2 + jWidth;\n             final int jWidth4 = jWidth3 + jWidth;\n             final int qStart = jBlock * BLOCK_SIZE;\n-            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n             for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n                 final double[] block  = blocks[iBlock * blockColumns + jBlock];\n-                final int      pStart = iBlock * BLOCK_SIZE;\n-                final int      pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n                 for (int q = qStart; q < qEnd; ++q) {\n                     int k = q - qStart;\n                     double sum = 0;\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - pStart) * jWidth;\n                     for (int q = qStart; q < qEnd; ++q) {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n                     final int qStart = jBlock * BLOCK_SIZE;\n-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - pStart) * jWidth;\n                     for (int q = qStart; q < qEnd; ++q) {\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n-            final int p0     = iBlock * BLOCK_SIZE;\n+            final int p0 = iBlock * BLOCK_SIZE;\n             final int pStart = FastMath.max(startRow, p0);\n-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n-                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int q0 = jBlock * BLOCK_SIZE;\n                     final int qStart = FastMath.max(startColumn, q0);\n-                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - p0) * jWidth + qStart - q0;\n                     for (int q = qStart; q < qEnd; ++q) {\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n-            final int p0     = iBlock * BLOCK_SIZE;\n+            final int p0 = iBlock * BLOCK_SIZE;\n             final int pStart = FastMath.max(startRow, p0);\n-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int p = pStart; p < pEnd; ++p) {\n                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                     final int jWidth = blockWidth(jBlock);\n-                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int q0 = jBlock * BLOCK_SIZE;\n                     final int qStart = FastMath.max(startColumn, q0);\n-                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n                     int k = (p - p0) * jWidth + qStart - q0;\n                     for (int q = qStart; q < qEnd; ++q) {\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final double[] block = blocks[blockIndex];\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n         int blockIndex = 0;\n         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);\n+            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n+                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                 final double[] block = blocks[blockIndex];\n                 int k = 0;\n                 for (int p = pStart; p < pEnd; ++p) {\n     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n-            final int p0     = iBlock * BLOCK_SIZE;\n+            final int p0 = iBlock * BLOCK_SIZE;\n             final int pStart = FastMath.max(startRow, p0);\n-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                 final int jWidth = blockWidth(jBlock);\n-                final int q0     = jBlock * BLOCK_SIZE;\n+                final int q0 = jBlock * BLOCK_SIZE;\n                 final int qStart = FastMath.max(startColumn, q0);\n-                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final double[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n                     int k = (p - p0) * jWidth + qStart - q0;\n     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n-            final int p0     = iBlock * BLOCK_SIZE;\n+            final int p0 = iBlock * BLOCK_SIZE;\n             final int pStart = FastMath.max(startRow, p0);\n-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n                 final int jWidth = blockWidth(jBlock);\n-                final int q0     = jBlock * BLOCK_SIZE;\n+                final int q0 = jBlock * BLOCK_SIZE;\n                 final int qStart = FastMath.max(startColumn, q0);\n-                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final double[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n                     int k = (p - p0) * jWidth + qStart - q0;\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n \n     /**\n      * Get the type of field elements of the matrix.\n-     * @return type of field elements of the matrix\n+     *\n+     * @return the type of field elements of the matrix.\n      */\n     Field<T> getField();\n \n     /**\n-     * Create a new FieldMatrix<T> of the same type as the instance with the supplied\n-     * row and column dimensions.\n+     * Create a new FieldMatrix<T> of the same type as the instance with\n+     * the supplied row and column dimensions.\n      *\n      * @param rowDimension  the number of rows in the new matrix\n      * @param columnDimension  the number of columns in the new matrix\n      * @return a new matrix of the same type as the instance\n-     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if row or column dimension is not positive.\n      * @since 2.0\n      */\n     FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension);\n \n     /**\n-     * Returns a (deep) copy of this.\n-     *\n-     * @return matrix copy\n+     * Make a (deep) copy of this.\n+     *\n+     * @return a copy of this matrix.\n      */\n     FieldMatrix<T> copy();\n \n     /**\n      * Compute the sum of this and m.\n      *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n+     * @param m Matrix to be added.\n+     * @return {@code this} + {@code m}.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n      */\n     FieldMatrix<T> add(FieldMatrix<T> m);\n \n     /**\n-     * Compute this minus m.\n-     *\n-     * @param m    matrix to be subtracted\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n+     * Subtract {@code m} from this matrix.\n+     *\n+     * @param m Matrix to be subtracted.\n+     * @return {@code this} - {@code m}.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n      */\n     FieldMatrix<T> subtract(FieldMatrix<T> m);\n \n      /**\n-     * Returns the result of adding d to each entry of this.\n-     *\n-     * @param d    value to be added to each entry\n-     * @return     d + this\n+     * Increment each entry of this matrix.\n+     *\n+     * @param d Value to be added to each entry.\n+     * @return {@code d} + {@code this}.\n      */\n     FieldMatrix<T> scalarAdd(T d);\n \n     /**\n-     * Returns the result multiplying each entry of this by d.\n-     *\n-     * @param d    value to multiply all entries by\n-     * @return     d * this\n+     * Multiply each entry by {@code d}.\n+     *\n+     * @param d Value to multiply all entries by.\n+     * @return {@code d} * {@code this}.\n      */\n     FieldMatrix<T> scalarMultiply(T d);\n \n     /**\n-     * Returns the result of postmultiplying this by m.\n-     *\n-     * @param m    matrix to postmultiply by\n-     * @return     this * m\n-     * @throws     IllegalArgumentException\n+     * Postmultiply this matrix by {@code m}.\n+     *\n+     * @param m  Matrix to postmultiply by.\n+     * @return {@code this} * {@code m}.\n+     * @throws IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n     FieldMatrix<T> multiply(FieldMatrix<T> m);\n \n     /**\n-     * Returns the result premultiplying this by <code>m</code>.\n-     * @param m    matrix to premultiply by\n-     * @return     m * this\n-     * @throws     IllegalArgumentException\n-     *             if rowDimension(this) != columnDimension(m)\n+     * Premultiply this matrix by {@code m}.\n+     *\n+     * @param m Matrix to premultiply by.\n+     * @return {@code m} * {@code this}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the number of columns of {@code m} differ from the number of rows\n+     * of this matrix.\n      */\n     FieldMatrix<T> preMultiply(FieldMatrix<T> m);\n \n     /**\n      * Returns matrix entries as a two-dimensional array.\n      *\n-     * @return    2-dimensional array of entries\n+     * @return a 2-dimensional array of entries.\n      */\n     T[][] getData();\n \n     /**\n-     * Gets a submatrix. Rows and columns are indicated\n-     * counting from 0 to n-1.\n+     * Get a submatrix. Rows and columns are indicated\n+     * counting from 0 to n - 1.\n      *\n      * @param startRow Initial row index\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n-     * @return The subMatrix containing the data of the\n-     *         specified rows and columns\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @return the matrix containing the data of the\n+     * specified rows and columns.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the indices are not valid.\n      */\n    FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn);\n \n    /**\n-    * Gets a submatrix. Rows and columns are indicated\n-    * counting from 0 to n-1.\n+    * Get a submatrix. Rows and columns are indicated\n+    * counting from 0 to n - 1.\n     *\n     * @param selectedRows Array of row indices.\n     * @param selectedColumns Array of column indices.\n-    * @return The subMatrix containing the data in the\n-    *         specified rows and columns\n-    * @exception MatrixIndexException if row or column selections are not valid\n+    * @return the matrix containing the data in the\n+    * specified rows and columns.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if row or column selections are not valid.\n     */\n    FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns);\n \n     * Copy a submatrix. Rows and columns are indicated\n     * counting from 0 to n-1.\n     *\n-    * @param startRow Initial row index\n-    * @param endRow Final row index (inclusive)\n-    * @param startColumn Initial column index\n-    * @param endColumn Final column index (inclusive)\n+    * @param startRow Initial row index.\n+    * @param endRow Final row index (inclusive).\n+    * @param startColumn Initial column index.\n+    * @param endColumn Final column index (inclusive).\n     * @param destination The arrays where the submatrix data should be copied\n-    * (if larger than rows/columns counts, only the upper-left part will be used)\n-    * @exception MatrixIndexException if the indices are not valid\n-    * @exception IllegalArgumentException if the destination array is too small\n+    * (if larger than rows/columns counts, only the upper-left part will be used).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the indices are not valid.\n+    * @exception IllegalArgumentException if the destination array is too small.\n     */\n   void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n                      T[][] destination);\n \n   /**\n    * Copy a submatrix. Rows and columns are indicated\n-   * counting from 0 to n-1.\n+   * counting from 0 to n - 1.\n    *\n-    * @param selectedRows Array of row indices.\n-    * @param selectedColumns Array of column indices.\n-   * @param destination The arrays where the submatrix data should be copied\n+   * @param selectedRows Array of row indices.\n+   * @param selectedColumns Array of column indices.\n+   * @param destination Arrays where the submatrix data should be copied\n    * (if larger than rows/columns counts, only the upper-left part will be used)\n-   * @exception MatrixIndexException if the indices are not valid\n+   * @throws org.apache.commons.math.exception.OutOfRangeException\n+   * if the indices are not valid.\n    * @exception IllegalArgumentException if the destination array is too small\n    */\n   void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination);\n \n    /**\n-    * Replace the submatrix starting at <code>row, column</code> using data in\n-    * the input <code>subMatrix</code> array. Indexes are 0-based.\n+    * Replace the submatrix starting at {@code (row, column)} using data in\n+    * the input {@code subMatrix} array. Indexes are 0-based.\n     * <p>\n     * Example:<br>\n     * Starting with <pre>\n     * 9  5  6  2\n     * </pre></p>\n     *\n-    * @param subMatrix  array containing the submatrix replacement data\n-    * @param row  row coordinate of the top, left element to be replaced\n-    * @param column  column coordinate of the top, left element to be replaced\n-    * @throws MatrixIndexException  if subMatrix does not fit into this\n-    *    matrix from element in (row, column)\n-    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n-    *  (not all rows have the same length) or empty\n-    * @throws NullPointerException if <code>subMatrix</code> is null\n+    * @param subMatrix Array containing the submatrix replacement data.\n+    * @param row Row coordinate of the top-left element to be replaced.\n+    * @param column Column coordinate of the top-left element to be replaced.\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if {@code subMatrix} does not fit into this matrix from element in\n+    * {@code (row, column)}.\n+    * @throws org.apache.commons.math.exception.ZeroException if a row or column\n+    * of {@code subMatrix} is empty.\n+    * @throws org.apache.commons.math.exception.DimensionMismatchException\n+    * if {@code subMatrix} is not rectangular (not all rows have the same\n+    * length).\n+    * @throws org.apache.commons.math.exception.NullArgumentException\n+    * if {@code subMatrix} is {@code null}.\n     * @since 2.0\n     */\n   void setSubMatrix(T[][] subMatrix, int row, int column);\n \n    /**\n-    * Returns the entries in row number <code>row</code>\n-    * as a row matrix.  Row indices start at 0.\n-    *\n-    * @param row the row to be fetched\n-    * @return row matrix\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * Get the entries in row number {@code row}\n+    * as a row matrix.\n+    *\n+    * @param row Row to be fetched.\n+    * @return a row matrix.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified row index is invalid.\n     */\n    FieldMatrix<T> getRowMatrix(int row);\n \n    /**\n-    * Sets the entries in row number <code>row</code>\n-    * as a row matrix.  Row indices start at 0.\n-    *\n-    * @param row the row to be set\n-    * @param matrix row matrix (must have one row and the same number of columns\n-    * as the instance)\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * Set the entries in row number {@code row}\n+    * as a row matrix.\n+    *\n+    * @param row Row to be set.\n+    * @param matrix Row matrix (must have one row and the same number\n+    * of columns as the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified row index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n     * if the matrix dimensions do not match one instance row.\n     */\n    void setRowMatrix(int row, FieldMatrix<T> matrix);\n \n    /**\n-    * Returns the entries in column number <code>column</code>\n-    * as a column matrix.  Column indices start at 0.\n-    *\n-    * @param column the column to be fetched\n-    * @return column matrix\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * Get the entries in column number {@code column}\n+    * as a column matrix.\n+    *\n+    * @param column Column to be fetched.\n+    * @return a column matrix.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified column index is invalid.\n     */\n    FieldMatrix<T> getColumnMatrix(int column);\n \n    /**\n-    * Sets the entries in column number <code>column</code>\n-    * as a column matrix.  Column indices start at 0.\n-    *\n-    * @param column the column to be set\n-    * @param matrix column matrix (must have one column and the same number of rows\n-    * as the instance)\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * Set the entries in column number {@code column}\n+    * as a column matrix.\n+    *\n+    * @param column Column to be set.\n+    * @param matrix column matrix (must have one column and the same\n+    * number of rows as the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified column index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n     * if the matrix dimensions do not match one instance column.\n     */\n    void setColumnMatrix(int column, FieldMatrix<T> matrix);\n \n    /**\n-    * Returns the entries in row number <code>row</code>\n-    * as a vector.  Row indices start at 0.\n-    *\n-    * @param row the row to be fetched\n-    * @return row vector\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * Get the entries in row number {@code row}\n+    * as a vector.\n+    *\n+    * @param row Row to be fetched\n+    * @return a row vector.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified row index is invalid.\n     */\n    FieldVector<T> getRowVector(int row);\n \n    /**\n-    * Sets the entries in row number <code>row</code>\n-    * as a vector.  Row indices start at 0.\n-    *\n-    * @param row the row to be set\n+    * Set the entries in row number {@code row}\n+    * as a vector.\n+    *\n+    * @param row Row to be set.\n     * @param vector row vector (must have the same number of columns\n-    * as the instance)\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * as the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified row index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance row.\n     */\n    void setRowVector(int row, FieldVector<T> vector);\n \n    /**\n-    * Returns the entries in column number <code>column</code>\n-    * as a vector.  Column indices start at 0.\n-    *\n-    * @param column the column to be fetched\n-    * @return column vector\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * Returns the entries in column number {@code column}\n+    * as a vector.\n+    *\n+    * @param column Column to be fetched.\n+    * @return a column vector.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified column index is invalid.\n     */\n    FieldVector<T> getColumnVector(int column);\n \n    /**\n-    * Sets the entries in column number <code>column</code>\n-    * as a vector.  Column indices start at 0.\n-    *\n-    * @param column the column to be set\n-    * @param vector column vector (must have the same number of rows as the instance)\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * Set the entries in column number {@code column}\n+    * as a vector.\n+    *\n+    * @param column Column to be set.\n+    * @param vector Column vector (must have the same number of rows\n+    * as the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException\n+    * if the specified column index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance column.\n     */\n    void setColumnVector(int column, FieldVector<T> vector);\n \n     /**\n-     * Returns the entries in row number <code>row</code> as an array.\n-     * <p>\n-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless {@code 0 <= row < rowDimension}.</p>\n-     *\n-     * @param row the row to be fetched\n-     * @return array of entries in the row\n-     * @throws MatrixIndexException if the specified row index is not valid\n+     * Get the entries in row number {@code row} as an array.\n+     *\n+     * @param row Row to be fetched.\n+     * @return array of entries in the row.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the specified row index is not valid.\n      */\n     T[] getRow(int row);\n \n     /**\n-     * Sets the entries in row number <code>row</code>\n-     * as a row matrix.  Row indices start at 0.\n-     *\n-     * @param row the row to be set\n-     * @param array row matrix (must have the same number of columns as the instance)\n-     * @throws MatrixIndexException if the specified row index is invalid\n+     * Set the entries in row number {@code row}\n+     * as a row matrix.\n+     *\n+     * @param row Row to be set.\n+     * @param array Row matrix (must have the same number of columns as\n+     * the instance).\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the specified row index is invalid.\n      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n      * if the array size does not match one instance row.\n      */\n     void setRow(int row, T[] array);\n \n     /**\n-     * Returns the entries in column number <code>col</code> as an array.\n-     * <p>\n-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless {@code 0 <= column < columnDimension}.</p>\n+     * Get the entries in column number {@code col} as an array.\n      *\n      * @param column the column to be fetched\n      * @return array of entries in the column\n-     * @throws MatrixIndexException if the specified column index is not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the specified column index is not valid.\n      */\n     T[] getColumn(int column);\n \n     /**\n-     * Sets the entries in column number <code>column</code>\n-     * as a column matrix.  Column indices start at 0.\n+     * Set the entries in column number {@code column}\n+     * as a column matrix.\n      *\n      * @param column the column to be set\n      * @param array column array (must have the same number of rows as the instance)\n-     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the specified column index is invalid.\n      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n      * if the array size does not match one instance column.\n      */\n \n     /**\n      * Returns the entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @param row  row location of entry to be fetched\n      * @param column  column location of entry to be fetched\n      * @return matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the row or column index is not valid.\n      */\n     T getEntry(int row, int column);\n \n     /**\n      * Set the entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param value matrix entry to be set in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the row or column index is not valid.\n      * @since 2.0\n      */\n     void setEntry(int row, int column, T value);\n \n     /**\n      * Change an entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     *\n-     * @param row  row location of entry to be set\n-     * @param column  column location of entry to be set\n-     * @param increment value to add to the current matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     *\n+     * @param row Row location of entry to be set.\n+     * @param column Column location of entry to be set.\n+     * @param increment Value to add to the current matrix entry in\n+     * {@code (row, column)}.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the row or column index is not valid.\n      * @since 2.0\n      */\n-    void addToEntry(int row, int column, T increment) throws MatrixIndexException;\n+    void addToEntry(int row, int column, T increment);\n \n     /**\n      * Change an entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     *\n-     * @param row  row location of entry to be set\n-     * @param column  column location of entry to be set\n-     * @param factor multiplication factor for the current matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     *\n+     * @param row Row location of entry to be set.\n+     * @param column Column location of entry to be set.\n+     * @param factor Multiplication factor for the current matrix entry\n+     * in {@code (row,column)}\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the row or column index is not valid.\n      * @since 2.0\n      */\n     void multiplyEntry(int row, int column, T factor);\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n      * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n      * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n      * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the indices are not valid.\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n      * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n      * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n--- a/src/main/java/org/apache/commons/math/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldVector.java\n \n     /**\n      * Returns the entry in the specified index.\n-     * <p>\n-     * The index start at 0 and must be lesser than the size,\n-     * otherwise a {@link MatrixIndexException} is thrown.\n-     * </p>\n-     * @param index  index location of entry to be fetched\n-     * @return vector entry at index\n-     * @throws MatrixIndexException if the index is not valid\n+     *\n+     * @param index Index location of entry to be fetched.\n+     * @return the vector entry at {@code index}.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * index is not valid.\n      * @see #setEntry(int, FieldElement)\n      */\n-    T getEntry(int index)\n-        throws MatrixIndexException;\n+    T getEntry(int index);\n \n     /**\n      * Set a single element.\n      * @param index element index.\n      * @param value new value for the element.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is inconsistent with vector size.\n      * @see #getEntry(int)\n      */\n-    void setEntry(int index, T value)\n-        throws MatrixIndexException;\n+    void setEntry(int index, T value);\n \n     /**\n      * Returns the size of the vector.\n      * @param index index of first element.\n      * @param n number of elements to be retrieved.\n      * @return a vector containing n elements.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n-     */\n-    FieldVector<T> getSubVector(int index, int n)\n-        throws MatrixIndexException;\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is inconsistent with vector size.\n+     */\n+    FieldVector<T> getSubVector(int index, int n);\n \n     /**\n      * Set a set of consecutive elements.\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is inconsistent with vector size.\n      * @see #setSubVector(int, FieldElement[])\n      */\n-    void setSubVector(int index, FieldVector<T> v)\n-        throws MatrixIndexException;\n+    void setSubVector(int index, FieldVector<T> v);\n \n     /**\n      * Set a set of consecutive elements.\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is inconsistent with vector size.\n      * @see #setSubVector(int, FieldVector)\n      */\n-    void setSubVector(int index, T[] v)\n-        throws MatrixIndexException;\n+    void setSubVector(int index, T[] v);\n \n     /**\n      * Set all elements to a single value.\n--- a/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java\n  * Thrown when an operation addresses a matrix coordinate (row, col)\n  * which is outside of the dimensions of a matrix.\n  * @version $Revision$ $Date$\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use the exceptions in package\n+ * {@link org.apache.commons.math.exception}.\n  */\n public class MatrixIndexException extends MathRuntimeException {\n \n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.lang.reflect.Array;\n-import java.math.BigDecimal;\n import java.util.Arrays;\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.fraction.Fraction;\n      *\n      * @param data input array\n      * @return  RealMatrix containing the values of the array\n-     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if either <code>data</code> or\n-     * <code>data[0]</code> is null\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code data} is not rectangular (not all rows have the same length).\n+     * @throws ZeroException if a row or column is empty.\n+     * @throws NullArgumentException if either {@code data} or {@code data[0]}\n+     * is {@code null}.\n      * @see #createRealMatrix(int, int)\n      */\n     public static RealMatrix createRealMatrix(double[][] data) {\n+        if (data == null ||\n+            data[0] == null) {\n+            throw new NullArgumentException();\n+        }\n         return (data.length * data[0].length <= 4096) ?\n                 new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n     }\n      * <p>The input array is copied, not referenced.</p>\n      * @param <T> the type of the field elements\n      * @param data input array\n-     * @return  RealMatrix containing the values of the array\n-     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if either <code>data</code> or\n-     * <code>data[0]</code> is null\n+     * @return a matrix containing the values of the array.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code data} is not rectangular (not all rows have the same length).\n+     * @throws ZeroException if a row or column is empty.\n+     * @throws NullArgumentException if either {@code data} or {@code data[0]}\n+     * is {@code null}.\n      * @see #createFieldMatrix(Field, int, int)\n      * @since 2.0\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) {\n+        if (data == null ||\n+            data[0] == null) {\n+            throw new NullArgumentException();\n+        }\n         return (data.length * data[0].length <= 4096) ?\n                 new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);\n     }\n     }\n \n     /**\n-     * Returns <code>dimension x dimension</code> identity matrix.\n-     *\n-     * @param dimension dimension of identity matrix to generate\n-     * @return identity matrix\n-     * @throws IllegalArgumentException if dimension is not positive\n-     * @since 1.1\n-     * @deprecated since 2.0, replaced by {@link #createFieldIdentityMatrix(Field, int)}\n-     */\n-    @Deprecated\n-    public static BigMatrix createBigIdentityMatrix(int dimension) {\n-        final BigDecimal[][] d = new BigDecimal[dimension][dimension];\n-        for (int row = 0; row < dimension; row++) {\n-            final BigDecimal[] dRow = d[row];\n-            Arrays.fill(dRow, BigMatrixImpl.ZERO);\n-            dRow[row] = BigMatrixImpl.ONE;\n-        }\n-        return new BigMatrixImpl(d, false);\n-    }\n-\n-    /**\n      * Returns a diagonal matrix with specified elements.\n      *\n      * @param diagonal diagonal elements of the matrix (the array elements\n     }\n \n     /**\n-     * Returns a {@link BigMatrix} whose entries are the the values in the\n-     * the input array.  The input array is copied, not referenced.\n-     *\n-     * @param data input array\n-     * @return  RealMatrix containing the values of the array\n-     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if data is null\n-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createBigMatrix(double[][] data) {\n-        return new BigMatrixImpl(data);\n-    }\n-\n-    /**\n-     * Returns a {@link BigMatrix} whose entries are the the values in the\n-     * the input array.  The input array is copied, not referenced.\n-     *\n-     * @param data input array\n-     * @return  RealMatrix containing the values of the array\n-     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if data is null\n-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createBigMatrix(BigDecimal[][] data) {\n-        return new BigMatrixImpl(data);\n-    }\n-\n-    /**\n-     * Returns a {@link BigMatrix} whose entries are the the values in the\n-     * the input array.\n-     * <p>If an array is built specially in order to be embedded in a\n-     * BigMatrix and not used directly, the <code>copyArray</code> may be\n-     * set to <code>false</code. This will prevent the copying and improve\n-     * performance as no new array will be built and no data will be copied.</p>\n-     * @param data data for new matrix\n-     * @param copyArray if true, the input array will be copied, otherwise\n-     * it will be referenced\n-     * @return  BigMatrix containing the values of the array\n-     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if <code>data</code> is null\n-     * @see #createRealMatrix(double[][])\n-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {\n-        return new BigMatrixImpl(data, copyArray);\n-    }\n-\n-    /**\n-     * Returns a {@link BigMatrix} whose entries are the the values in the\n-     * the input array.  The input array is copied, not referenced.\n-     *\n-     * @param data input array\n-     * @return  RealMatrix containing the values of the array\n-     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n-     *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if data is null\n-     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createBigMatrix(String[][] data) {\n-        return new BigMatrixImpl(data);\n-    }\n-\n-    /**\n      * Creates a {@link RealVector} using the data from the input array.\n      *\n      * @param data the input data\n      * @return a data.length RealVector\n-     * @throws IllegalArgumentException if <code>data</code> is empty\n-     * @throws NullPointerException if <code>data</code>is null\n+     * @throws ZeroException if {@code data} is empty.\n+     * @throws NullArgumentException if {@code data} is {@code null}.\n      */\n     public static RealVector createRealVector(double[] data) {\n+        if (data == null) {\n+            throw new NullArgumentException();\n+        }\n         return new ArrayRealVector(data, true);\n     }\n \n      * @param <T> the type of the field elements\n      * @param data the input data\n      * @return a data.length FieldVector\n-     * @throws IllegalArgumentException if <code>data</code> is empty\n-     * @throws NullPointerException if <code>data</code>is null\n+     * @throws ZeroException if {@code data} is empty.\n+     * @throws NullArgumentException if {@code data} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n+        if (data == null) {\n+            throw new NullArgumentException();\n+        }\n         return new ArrayFieldVector<T>(data, true);\n     }\n \n     /**\n-     * Creates a row {@link RealMatrix} using the data from the input\n+     * Create a row {@link RealMatrix} using the data from the input\n      * array.\n      *\n      * @param rowData the input row data\n      * @return a 1 x rowData.length RealMatrix\n-     * @throws IllegalArgumentException if <code>rowData</code> is empty\n-     * @throws NullPointerException if <code>rowData</code>is null\n+     * @throws ZeroException if {@code rowData} is empty.\n+     * @throws NullArgumentException if {@code rowData} is {@code null}.\n      */\n     public static RealMatrix createRowRealMatrix(double[] rowData) {\n+        if (rowData == null) {\n+            throw new NullArgumentException();\n+        }\n         final int nCols = rowData.length;\n         final RealMatrix m = createRealMatrix(1, nCols);\n         for (int i = 0; i < nCols; ++i) {\n     }\n \n     /**\n-     * Creates a row {@link FieldMatrix} using the data from the input\n+     * Create a row {@link FieldMatrix} using the data from the input\n      * array.\n      *\n      * @param <T> the type of the field elements\n      * @param rowData the input row data\n      * @return a 1 x rowData.length FieldMatrix\n-     * @throws IllegalArgumentException if <code>rowData</code> is empty\n-     * @throws NullPointerException if <code>rowData</code>is null\n+     * @throws ZeroException if {@code rowData} is empty.\n+     * @throws NullArgumentException if {@code rowData} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T>\n         createRowFieldMatrix(final T[] rowData) {\n+        if (rowData == null) {\n+            throw new NullArgumentException();\n+        }\n         final int nCols = rowData.length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+            throw new ZeroException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n         for (int i = 0; i < nCols; ++i) {\n     }\n \n     /**\n-     * Creates a row {@link BigMatrix} using the data from the input\n-     * array.\n-     *\n-     * @param rowData the input row data\n-     * @return a 1 x rowData.length BigMatrix\n-     * @throws IllegalArgumentException if <code>rowData</code> is empty\n-     * @throws NullPointerException if <code>rowData</code>is null\n-     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createRowBigMatrix(double[] rowData) {\n-        final int nCols = rowData.length;\n-        final BigDecimal[][] data = new BigDecimal[1][nCols];\n-        for (int i = 0; i < nCols; ++i) {\n-            data[0][i] = new BigDecimal(rowData[i]);\n-        }\n-        return new BigMatrixImpl(data, false);\n-    }\n-\n-    /**\n-     * Creates a row {@link BigMatrix} using the data from the input\n-     * array.\n-     *\n-     * @param rowData the input row data\n-     * @return a 1 x rowData.length BigMatrix\n-     * @throws IllegalArgumentException if <code>rowData</code> is empty\n-     * @throws NullPointerException if <code>rowData</code>is null\n-     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {\n-        final int nCols = rowData.length;\n-        final BigDecimal[][] data = new BigDecimal[1][nCols];\n-        System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new BigMatrixImpl(data, false);\n-    }\n-\n-    /**\n-     * Creates a row {@link BigMatrix} using the data from the input\n-     * array.\n-     *\n-     * @param rowData the input row data\n-     * @return a 1 x rowData.length BigMatrix\n-     * @throws IllegalArgumentException if <code>rowData</code> is empty\n-     * @throws NullPointerException if <code>rowData</code>is null\n-     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createRowBigMatrix(String[] rowData) {\n-        final int nCols = rowData.length;\n-        final BigDecimal[][] data = new BigDecimal[1][nCols];\n-        for (int i = 0; i < nCols; ++i) {\n-            data[0][i] = new BigDecimal(rowData[i]);\n-        }\n-        return new BigMatrixImpl(data, false);\n-    }\n-\n-    /**\n      * Creates a column {@link RealMatrix} using the data from the input\n      * array.\n      *\n      * @param columnData  the input column data\n      * @return a columnData x 1 RealMatrix\n-     * @throws IllegalArgumentException if <code>columnData</code> is empty\n-     * @throws NullPointerException if <code>columnData</code>is null\n+     * @throws ZeroException if {@code columnData} is empty.\n+     * @throws NullArgumentException if {@code columnData} is {@code null}.\n      */\n     public static RealMatrix createColumnRealMatrix(double[] columnData) {\n+        if (columnData == null) {\n+            throw new NullArgumentException();\n+        }\n         final int nRows = columnData.length;\n         final RealMatrix m = createRealMatrix(nRows, 1);\n         for (int i = 0; i < nRows; ++i) {\n      * @param <T> the type of the field elements\n      * @param columnData  the input column data\n      * @return a columnData x 1 FieldMatrix\n-     * @throws IllegalArgumentException if <code>columnData</code> is empty\n-     * @throws NullPointerException if <code>columnData</code>is null\n+     * @throws ZeroException if {@code data} is empty.\n+     * @throws NullArgumentException if {@code columnData} is {@code null}.\n      */\n     public static <T extends FieldElement<T>> FieldMatrix<T>\n         createColumnFieldMatrix(final T[] columnData) {\n+        if (columnData == null) {\n+            throw new NullArgumentException();\n+        }\n         final int nRows = columnData.length;\n         if (nRows == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n     }\n \n     /**\n-     * Creates a column {@link BigMatrix} using the data from the input\n-     * array.\n-     *\n-     * @param columnData  the input column data\n-     * @return a columnData x 1 BigMatrix\n-     * @throws IllegalArgumentException if <code>columnData</code> is empty\n-     * @throws NullPointerException if <code>columnData</code>is null\n-     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createColumnBigMatrix(double[] columnData) {\n-        final int nRows = columnData.length;\n-        final BigDecimal[][] data = new BigDecimal[nRows][1];\n-        for (int row = 0; row < nRows; row++) {\n-            data[row][0] = new BigDecimal(columnData[row]);\n-        }\n-        return new BigMatrixImpl(data, false);\n-    }\n-\n-    /**\n-     * Creates a column {@link BigMatrix} using the data from the input\n-     * array.\n-     *\n-     * @param columnData  the input column data\n-     * @return a columnData x 1 BigMatrix\n-     * @throws IllegalArgumentException if <code>columnData</code> is empty\n-     * @throws NullPointerException if <code>columnData</code>is null\n-     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {\n-        final int nRows = columnData.length;\n-        final BigDecimal[][] data = new BigDecimal[nRows][1];\n-        for (int row = 0; row < nRows; row++) {\n-            data[row][0] = columnData[row];\n-        }\n-        return new BigMatrixImpl(data, false);\n-    }\n-\n-    /**\n-     * Creates a column {@link BigMatrix} using the data from the input\n-     * array.\n-     *\n-     * @param columnData  the input column data\n-     * @return a columnData x 1 BigMatrix\n-     * @throws IllegalArgumentException if <code>columnData</code> is empty\n-     * @throws NullPointerException if <code>columnData</code>is null\n-     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n-     */\n-    @Deprecated\n-    public static BigMatrix createColumnBigMatrix(String[] columnData) {\n-        int nRows = columnData.length;\n-        final BigDecimal[][] data = new BigDecimal[nRows][1];\n-        for (int row = 0; row < nRows; row++) {\n-            data[row][0] = new BigDecimal(columnData[row]);\n-        }\n-        return new BigMatrixImpl(data, false);\n+     * Check if matrix indices are valid.\n+     *\n+     * @param m Matrix.\n+     * @param row Row index to check.\n+     * @param column Column index to check.\n+     * @throws OutOfRangeException if {@code row} or {@code column} is not\n+     * a valid index.\n+     */\n+    public static void checkMatrixIndex(final AnyMatrix m,\n+                                        final int row, final int column) {\n+        checkRowIndex(m, row);\n+        checkColumnIndex(m, column);\n     }\n \n     /**\n      * Check if a row index is valid.\n-     * @param m matrix containing the submatrix\n-     * @param row row index to check\n-     * @exception MatrixIndexException if index is not valid\n+     *\n+     * @param m Matrix.\n+     * @param row Row index to check.\n+     * @throws OutOfRangeException if {@code row} is not a valid index.\n      */\n     public static void checkRowIndex(final AnyMatrix m, final int row) {\n-        if (row < 0 || row >= m.getRowDimension()) {\n-            throw new MatrixIndexException(LocalizedFormats.ROW_INDEX_OUT_OF_RANGE,\n-                                           row, 0, m.getRowDimension() - 1);\n+        if (row < 0 ||\n+            row >= m.getRowDimension()) {\n+            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n+                                          row, 0, m.getRowDimension() - 1);\n         }\n     }\n \n     /**\n      * Check if a column index is valid.\n-     * @param m matrix containing the submatrix\n-     * @param column column index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    public static void checkColumnIndex(final AnyMatrix m, final int column)\n-        throws MatrixIndexException {\n+     *\n+     * @param m Matrix.\n+     * @param column Column index to check.\n+     * @throws OutOfRangeException if {@code column} is not a valid index.\n+     */\n+    public static void checkColumnIndex(final AnyMatrix m, final int column) {\n         if (column < 0 || column >= m.getColumnDimension()) {\n-            throw new MatrixIndexException(LocalizedFormats.COLUMN_INDEX_OUT_OF_RANGE,\n+            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                            column, 0, m.getColumnDimension() - 1);\n         }\n     }\n \n     /**\n      * Check if submatrix ranges indices are valid.\n-     * Rows and columns are indicated counting from 0 to n-1.\n-     *\n-     * @param m matrix containing the submatrix\n-     * @param startRow Initial row index\n-     * @param endRow Final row index\n-     * @param startColumn Initial column index\n-     * @param endColumn Final column index\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * Rows and columns are indicated counting from 0 to {@code n - 1}.\n+     *\n+     * @param m Matrix.\n+     * @param startRow Initial row index.\n+     * @param endRow Final row index.\n+     * @param startColumn Initial column index.\n+     * @param endColumn Final column index.\n+     * @throws OutOfRangeException if the indices are invalid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      */\n     public static void checkSubMatrixIndex(final AnyMatrix m,\n                                            final int startRow, final int endRow,\n                                            final int startColumn, final int endColumn) {\n         checkRowIndex(m, startRow);\n         checkRowIndex(m, endRow);\n-        if (startRow > endRow) {\n-            throw new MatrixIndexException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n-                                           startRow, endRow);\n+        if (endRow < startRow) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n+                                                endRow, startRow, false);\n         }\n \n         checkColumnIndex(m, startColumn);\n         checkColumnIndex(m, endColumn);\n-        if (startColumn > endColumn) {\n-            throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n-                                           startColumn, endColumn);\n+        if (endColumn < startColumn) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n+                                                endColumn, startColumn, false);\n         }\n \n \n      * Check if submatrix ranges indices are valid.\n      * Rows and columns are indicated counting from 0 to n-1.\n      *\n-     * @param m matrix containing the submatrix\n+     * @param m Matrix.\n      * @param selectedRows Array of row indices.\n      * @param selectedColumns Array of column indices.\n-     * @exception MatrixIndexException if row or column selections are not valid\n+     * @throws NullArgumentException if {@code selectedRows} or\n+     * {@code selectedColumns} are {@code null}.\n+     * @throws ZeroException if the row or column selections are empty (zero\n+     * length).\n+     * @throws OutOfRangeException if row or column selections are not valid.\n      */\n     public static void checkSubMatrixIndex(final AnyMatrix m,\n-                                           final int[] selectedRows, final int[] selectedColumns)\n-        throws MatrixIndexException {\n-        if (selectedRows.length * selectedColumns.length == 0) {\n-            if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n-            }\n-            throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n+                                           final int[] selectedRows,\n+                                           final int[] selectedColumns) {\n+        if (selectedRows == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (selectedColumns == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (selectedRows.length == 0) {\n+            throw new ZeroException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n+        }\n+        if (selectedColumns.length == 0) {\n+            throw new ZeroException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n         }\n \n         for (final int row : selectedRows) {\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class OpenMapRealMatrix extends AbstractRealMatrix implements SparseRealMatrix, Serializable {\n-\n+public class OpenMapRealMatrix extends AbstractRealMatrix\n+    implements SparseRealMatrix, Serializable {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -5962461716457143437L;\n-\n     /** Number of rows of the matrix. */\n     private final int rows;\n-\n     /** Number of columns of the matrix. */\n     private final int columns;\n-\n     /** Storage for (sparse) matrix elements. */\n     private final OpenIntToDoubleHashMap entries;\n \n     /**\n      * Build a sparse matrix with the supplied row and column dimensions.\n-     * @param rowDimension number of rows of the matrix\n-     * @param columnDimension number of columns of the matrix\n+     *\n+     * @param rowDimension Number of rows of the matrix.\n+     * @param columnDimension Number of columns of the matrix.\n      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n-        this.rows    = rowDimension;\n+        this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n     }\n \n     /**\n      * Build a matrix by copying another one.\n-     * @param matrix matrix to copy\n+     *\n+     * @param matrix matrix to copy.\n      */\n     public OpenMapRealMatrix(OpenMapRealMatrix matrix) {\n-        this.rows    = matrix.rows;\n+        this.rows = matrix.rows;\n         this.columns = matrix.columns;\n         this.entries = new OpenIntToDoubleHashMap(matrix.entries);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension)\n-            throws IllegalArgumentException {\n+    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension) {\n         return new OpenMapRealMatrix(rowDimension, columnDimension);\n     }\n \n         return columns;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public OpenMapRealMatrix add(final RealMatrix m)\n-        throws IllegalArgumentException {\n-        try {\n-            return add((OpenMapRealMatrix) m);\n-        } catch (ClassCastException cce) {\n-            return (OpenMapRealMatrix) super.add(m);\n-        }\n-    }\n-\n-    /**\n-     * Compute the sum of this and <code>m</code>.\n-     *\n-     * @param m    matrix to be added\n-     * @return     this + m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n-    public OpenMapRealMatrix add(OpenMapRealMatrix m) throws IllegalArgumentException {\n+    /**\n+     * Compute the sum of this matrix and {@code m}.\n+     *\n+     * @param m Matrix to be added.\n+     * @return {@code this} + {@code m}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n+     */\n+    public OpenMapRealMatrix add(OpenMapRealMatrix m) {\n \n         // safety check\n         MatrixUtils.checkAdditionCompatible(this, m);\n     }\n \n     /**\n-     * Compute this minus <code>m</code>.\n-     *\n-     * @param m    matrix to be subtracted\n-     * @return     this - m\n-     * @throws  IllegalArgumentException if m is not the same size as this\n-     */\n-    public OpenMapRealMatrix subtract(OpenMapRealMatrix m) throws IllegalArgumentException {\n-\n-        // safety check\n+     * Subtract {@code m} from this matrix.\n+     *\n+     * @param m Matrix to be subtracted.\n+     * @return {@code this} - {@code m}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code m} is not the same size as this matrix.\n+     */\n+    public OpenMapRealMatrix subtract(OpenMapRealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n         final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n             }\n \n             return out;\n-\n-        }\n-    }\n-\n-    /**\n-     * Returns the result of postmultiplying this by m.\n-     *\n-     * @param m    matrix to postmultiply by\n-     * @return     this * m\n-     * @throws     IllegalArgumentException\n-     *             if columnDimension(this) != rowDimension(m)\n-     */\n-    public OpenMapRealMatrix multiply(OpenMapRealMatrix m) throws IllegalArgumentException {\n-\n-        // safety check\n+        }\n+    }\n+\n+    /**\n+     * Postmultiply this matrix by {@code m}.\n+     *\n+     * @param m Matrix to postmultiply by.\n+     * @return {@code this} * {@code m}.\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if the number of rows of {@code m} differ from the number of columns\n+     * of this matrix.\n+     */\n+    public OpenMapRealMatrix multiply(OpenMapRealMatrix m) {\n+        // Safety check.\n         MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int outCols = m.getColumnDimension();\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double getEntry(int row, int column) throws MatrixIndexException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(int row, int column) {\n         MatrixUtils.checkRowIndex(this, row);\n         MatrixUtils.checkColumnIndex(this, column);\n         return entries.get(computeKey(row, column));\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setEntry(int row, int column, double value)\n-            throws MatrixIndexException {\n+    public void setEntry(int row, int column, double value) {\n         MatrixUtils.checkRowIndex(this, row);\n         MatrixUtils.checkColumnIndex(this, column);\n         if (value == 0.0) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public void addToEntry(int row, int column, double increment)\n-            throws MatrixIndexException {\n+    public void addToEntry(int row, int column, double increment) {\n         MatrixUtils.checkRowIndex(this, row);\n         MatrixUtils.checkColumnIndex(this, column);\n         final int key = computeKey(row, column);\n \n     /** {@inheritDoc} */\n     @Override\n-    public void multiplyEntry(int row, int column, double factor)\n-            throws MatrixIndexException {\n+    public void multiplyEntry(int row, int column, double factor) {\n         MatrixUtils.checkRowIndex(this, row);\n         MatrixUtils.checkColumnIndex(this, column);\n         final int key = computeKey(row, column);\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n import org.apache.commons.math.util.FastMath;\n \n /**\n- * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.\n+ * This class implements the {@link RealVector} interface with a\n+ * {@link OpenIntToDoubleHashMap} backing store.\n  * @version $Revision$ $Date$\n  * @since 2.0\n */\n-public class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable {\n-\n+public class OpenMapRealVector extends AbstractRealVector\n+    implements SparseRealVector, Serializable {\n     /** Default Tolerance for having a value considered zero. */\n     public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 8772222695580707260L;\n-\n     /** Entries of the vector. */\n     private final OpenIntToDoubleHashMap entries;\n-\n     /** Dimension of the vector. */\n     private final int virtualSize;\n-\n     /** Tolerance for having a value considered zero. */\n     private final double epsilon;\n \n     /**\n      * Build a 0-length vector.\n-     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * Zero-length vectors may be used to initialized construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n-     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * or one of the {@code append} method ({@link #append(double)}, {@link\n      * #append(double[])}, {@link #append(RealVector)}) to gather data\n-     * into this vector.</p>\n+     * into this vector.\n      */\n     public OpenMapRealVector() {\n         this(0, DEFAULT_ZERO_TOLERANCE);\n     }\n \n     /**\n-     * Construct a (dimension)-length vector of zeros.\n-     * @param dimension size of the vector\n+     * Construct a vector of zeroes.\n+     *\n+     * @param dimension Size of the vector.\n      */\n     public OpenMapRealVector(int dimension) {\n         this(dimension, DEFAULT_ZERO_TOLERANCE);\n     }\n \n     /**\n-     * Construct a (dimension)-length vector of zeros, specifying zero tolerance.\n-     * @param dimension Size of the vector\n-     * @param epsilon The tolerance for having a value considered zero\n+     * Construct a vector of zeroes, specifying zero tolerance.\n+     *\n+     * @param dimension Size of the vector.\n+     * @param epsilon Tolerance below which a value considered zero.\n      */\n     public OpenMapRealVector(int dimension, double epsilon) {\n         virtualSize = dimension;\n \n     /**\n      * Build a resized vector, for use with append.\n-     * @param v The original vector\n-     * @param resize The amount to resize it\n+     *\n+     * @param v Original vector.\n+     * @param resize Amount to add.\n      */\n     protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n         virtualSize = v.getDimension() + resize;\n \n     /**\n      * Build a vector with known the sparseness (for advanced use only).\n-     * @param dimension The size of the vector\n-     * @param expectedSize The expected number of non-zero entries\n+     *\n+     * @param dimension Size of the vector.\n+     * @param expectedSize The expected number of non-zero entries.\n      */\n     public OpenMapRealVector(int dimension, int expectedSize) {\n         this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n     }\n \n     /**\n-     * Build a vector with known the sparseness and zero tolerance setting (for advanced use only).\n-     * @param dimension The size of the vector\n-     * @param expectedSize The expected number of non-zero entries\n-     * @param epsilon The tolerance for having a value considered zero\n+     * Build a vector with known the sparseness and zero tolerance\n+     * setting (for advanced use only).\n+     *\n+     * @param dimension Size of the vector.\n+     * @param expectedSize Expected number of non-zero entries.\n+     * @param epsilon Tolerance below which a value is considered zero.\n      */\n     public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n         virtualSize = dimension;\n     }\n \n     /**\n-     * Create from a double array.\n-     * Only non-zero entries will be stored\n-     * @param values The set of values to create from\n+     * Create from an array.\n+     * Only non-zero entries will be stored.\n+     *\n+     * @param values Set of values to create from.\n      */\n     public OpenMapRealVector(double[] values) {\n         this(values, DEFAULT_ZERO_TOLERANCE);\n     }\n \n     /**\n-     * Create from a double array, specifying zero tolerance.\n-     * Only non-zero entries will be stored\n-     * @param values The set of values to create from\n-     * @param epsilon The tolerance for having a value considered zero\n+     * Create from an array, specifying zero tolerance.\n+     * Only non-zero entries will be stored.\n+     *\n+     * @param values Set of values to create from.\n+     * @param epsilon Tolerance below which a value is considered zero.\n      */\n     public OpenMapRealVector(double[] values, double epsilon) {\n         virtualSize = values.length;\n     }\n \n     /**\n-     * Create from a Double array.\n-     * Only non-zero entries will be stored\n+     * Create from an array.\n+     * Only non-zero entries will be stored.\n+     *\n      * @param values The set of values to create from\n      */\n     public OpenMapRealVector(Double[] values) {\n     }\n \n     /**\n-     * Create from a Double array.\n-     * Only non-zero entries will be stored\n-     * @param values The set of values to create from\n-     * @param epsilon The tolerance for having a value considered zero\n+     * Create from an array.\n+     * Only non-zero entries will be stored.\n+     *\n+     * @param values Set of values to create from.\n+     * @param epsilon Tolerance below which a value is considered zero.\n      */\n     public OpenMapRealVector(Double[] values, double epsilon) {\n         virtualSize = values.length;\n \n     /**\n      * Copy constructor.\n-     * @param v The instance to copy from\n+     *\n+     * @param v Instance to copy from.\n      */\n     public OpenMapRealVector(OpenMapRealVector v) {\n         virtualSize = v.getDimension();\n \n     /**\n      * Generic copy constructor.\n-     * @param v The instance to copy from\n+     *\n+     * @param v Instance to copy from.\n      */\n     public OpenMapRealVector(RealVector v) {\n         virtualSize = v.getDimension();\n \n     /**\n      * Get the entries of this instance.\n-     * @return entries of this instance\n+     *\n+     * @return the entries of this instance.\n      */\n     private OpenIntToDoubleHashMap getEntries() {\n         return entries;\n \n     /**\n      * Determine if this value is within epsilon of zero.\n-     * @param value The value to test\n-     * @return <code>true</code> if this value is within epsilon to zero, <code>false</code> otherwise\n+     *\n+     * @param value Value to test\n+     * @return {@code true} if this value is within epsilon to zero,\n+     * {@code false} otherwise.\n      * @since 2.1\n      */\n     protected boolean isDefaultValue(double value) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector add(RealVector v) throws IllegalArgumentException {\n+        public RealVector add(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return add((OpenMapRealVector) v);\n     }\n \n     /**\n-     * Optimized method to add two OpenMapRealVectors.  Copies the larger vector, iterates over the smaller.\n-     * @param v Vector to add with\n-     * @return The sum of <code>this</code> with <code>v</code>\n-     * @throws IllegalArgumentException If the dimensions don't match\n-     */\n-    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException{\n+     * Optimized method to add two OpenMapRealVectors.\n+     * It copies the larger vector, then iterates over the smaller.\n+     *\n+     * @param v Vector to add.\n+     * @return the sum of {@code this} and {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the dimensions do not match.\n+     */\n+    public OpenMapRealVector add(OpenMapRealVector v) {\n         checkVectorDimensions(v.getDimension());\n         boolean copyThis = entries.size() > v.entries.size();\n         OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n     /**\n      * Optimized method to append a OpenMapRealVector.\n      * @param v vector to append\n-     * @return The result of appending <code>v</code> to self\n+     * @return The result of appending {@code v} to self\n      */\n     public OpenMapRealVector append(OpenMapRealVector v) {\n         OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n \n     /**\n      * Optimized method to compute the dot product with an OpenMapRealVector.\n-     * Iterates over the smaller of the two.\n-     * @param v The vector to compute the dot product with\n-     * @return The dot product of <code>this</code> and <code>v</code>\n-     * @throws IllegalArgumentException If the dimensions don't match\n-     */\n-    public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {\n+     * It iterates over the smallest of the two.\n+     *\n+     * @param v Cector to compute the dot product with.\n+     * @return the dot product of {@code this} and {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the dimensions do not match.\n+     */\n+    public double dotProduct(OpenMapRealVector v) {\n         checkVectorDimensions(v.getDimension());\n         boolean thisIsSmaller  = entries.size() < v.entries.size();\n         Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n \n     /** {@inheritDoc} */\n     @Override\n-    public double dotProduct(RealVector v) throws IllegalArgumentException {\n+    public double dotProduct(RealVector v) {\n         if(v instanceof OpenMapRealVector) {\n             return dotProduct((OpenMapRealVector)v);\n         } else {\n     }\n \n     /** {@inheritDoc} */\n-    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {\n+    public OpenMapRealVector getSubVector(int index, int n) {\n         checkIndex(index);\n         checkIndex(index + n - 1);\n         OpenMapRealVector res = new OpenMapRealVector(n);\n \n     /**\n      * Optimized method to compute distance.\n-     * @param v The vector to compute distance to\n-     * @return The distance from <code>this</code> and <code>v</code>\n-     * @throws IllegalArgumentException If the dimensions don't match\n-     */\n-    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {\n+     *\n+     * @param v Vector to compute distance to.\n+     * @return the distance from {@code this} and {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the dimensions do not match.\n+     */\n+    public double getDistance(OpenMapRealVector v) {\n         Iterator iter = entries.iterator();\n         double res = 0;\n         while (iter.hasNext()) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getDistance(RealVector v) throws IllegalArgumentException {\n+    public double getDistance(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return getDistance((OpenMapRealVector) v);\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getDistance(double[] v) throws IllegalArgumentException {\n+    public double getDistance(double[] v) {\n         checkVectorDimensions(v.length);\n         double res = 0;\n         for (int i = 0; i < v.length; i++) {\n     }\n \n     /** {@inheritDoc} */\n-    public double getEntry(int index) throws MatrixIndexException {\n+    public double getEntry(int index) {\n         checkIndex(index);\n         return entries.get(index);\n     }\n \n     /**\n      * Distance between two vectors.\n-     * <p>This method computes the distance consistent with\n+     * This method computes the distance consistent with\n      * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n-     * elements differences.</p>\n-     * @param v vector to which distance is requested\n-     * @return distance between two vectors.\n+     * elements differences.\n+     *\n+     * @param v Vector to which distance is requested.\n+     * @return distance between this vector and {@code v}.\n      */\n     public double getL1Distance(OpenMapRealVector v) {\n         double max = 0;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+    public double getL1Distance(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return getL1Distance((OpenMapRealVector) v);\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getL1Distance(double[] v) throws IllegalArgumentException {\n+    public double getL1Distance(double[] v) {\n         checkVectorDimensions(v.length);\n         double max = 0;\n         for (int i = 0; i < v.length; i++) {\n \n     /**\n      * Optimized method to compute LInfDistance.\n-     * @param v The vector to compute from\n-     * @return the LInfDistance\n+     *\n+     * @param v Vector to compute distance from.\n+     * @return the LInfDistance.\n      */\n     private double getLInfDistance(OpenMapRealVector v) {\n         double max = 0;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+    public double getLInfDistance(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return getLInfDistance((OpenMapRealVector) v);\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+    public double getLInfDistance(double[] v) {\n         checkVectorDimensions(v.length);\n         double max = 0;\n         for (int i = 0; i < v.length; i++) {\n \n      /** {@inheritDoc} */\n     @Override\n-    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+    public RealMatrix outerProduct(double[] v) {\n         checkVectorDimensions(v.length);\n         RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n         Iterator iter = entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector projection(RealVector v) throws IllegalArgumentException {\n+    public RealVector projection(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector projection(double[] v) {\n         checkVectorDimensions(v.length);\n         return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n     }\n \n     /** {@inheritDoc} */\n-    public void setEntry(int index, double value) throws MatrixIndexException {\n+    public void setEntry(int index, double value) {\n         checkIndex(index);\n         if (!isDefaultValue(value)) {\n             entries.put(index, value);\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+    public void setSubVector(int index, RealVector v) {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n         setSubVector(index, v.getData());\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+    public void setSubVector(int index, double[] v) {\n         checkIndex(index);\n         checkIndex(index + v.length - 1);\n         for (int i = 0; i < v.length; i++) {\n \n     /**\n      * Optimized method to subtract OpenMapRealVectors.\n-     * @param v The vector to subtract from <code>this</code>\n-     * @return The difference of <code>this</code> and <code>v</code>\n-     * @throws IllegalArgumentException If the dimensions don't match\n-     */\n-    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{\n+     *\n+     * @param v Vector to subtract from {@code this}.\n+     * @return the difference of {@code this} and {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the dimensions do not match.\n+     */\n+    public OpenMapRealVector subtract(OpenMapRealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = copy();\n         Iterator iter = v.getEntries().iterator();\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n+    public OpenMapRealVector subtract(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n             return subtract((OpenMapRealVector) v);\n \n     /** {@inheritDoc} */\n     @Override\n-    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n+    public OpenMapRealVector subtract(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n         for (int i = 0; i < v.length; i++) {\n     public void unitize() {\n         double norm = getNorm();\n         if (isDefaultValue(norm)) {\n-            throw  MathRuntimeException.createArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             entries.put(iter.key(), iter.value() / norm);\n         }\n-\n-    }\n-\n+    }\n \n     /** {@inheritDoc} */\n     @Override\n         return getData();\n     }\n \n-    /** {@inheritDoc}\n-     * <p> Implementation Note: This works on exact values, and as a result\n+    /**\n+     * {@inheritDoc}\n+     * Implementation Note: This works on exact values, and as a result\n      * it is possible for {@code a.subtract(b)} to be the zero vector, while\n-     * {@code a.hashCode() != b.hashCode()}.</p>\n+     * {@code a.hashCode() != b.hashCode()}.\n      */\n     @Override\n     public int hashCode() {\n     }\n \n     /**\n-     * <p> Implementation Note: This performs an exact comparison, and as a result\n+     * {@inheritDoc}\n+     * Implementation Note: This performs an exact comparison, and as a result\n      * it is possible for {@code a.subtract(b}} to be the zero vector, while\n-     * {@code  a.equals(b) == false}.</p>\n-     * {@inheritDoc}\n+     * {@code  a.equals(b) == false}.\n      */\n     @Override\n     public boolean equals(Object obj) {\n     /**\n      *\n      * @return the percentage of none zero elements as a decimal percent.\n-     * @deprecated Use the correctly spelled {@link #getSparsity()}\n-     */\n-    @Deprecated\n-    public double getSparcity() {\n-        return getSparsity();\n-    }\n-\n-    /**\n-    *\n-    * @return the percentage of none zero elements as a decimal percent.\n-    */\n-   public double getSparsity() {\n+     */\n+    public double getSparsity() {\n         return (double)entries.size()/(double)getDimension();\n     }\n \n     }\n \n     /**\n-     *  Implementation of <code>Entry</code> optimized for OpenMap.\n-     * <p>This implementation does not allow arbitrary calls to <code>setIndex</code>\n-     * since the order that entries are returned is undefined.\n+     * Implementation of {@code Entry} optimized for OpenMap.\n+     * This implementation does not allow arbitrary calls to {@code setIndex}\n+     * since the order in which entries are returned is undefined.\n      */\n     protected class OpenMapEntry extends Entry {\n-\n         /** Iterator pointing to the entry. */\n         private final Iterator iter;\n \n-        /** Build an entry from an iterator point to an element.\n-         * @param iter iterator pointing to the entry\n+        /**\n+         * Build an entry from an iterator point to an element.\n+         *\n+         * @param iter Iterator pointing to the entry.\n          */\n         protected OpenMapEntry(Iterator iter) {\n             this.iter = iter;\n     }\n \n     /**\n-     *  Iterator class to do iteration over just the non-zero elements.\n-     *  <p>This implementation is fail-fast, so cannot be used to modify any zero element.\n-     *\n+     * Iterator class to do iteration over just the non-zero elements.\n+     * This implementation is fail-fast, so cannot be used to modify\n+     * any zero element.\n      */\n     protected class OpenMapSparseIterator implements java.util.Iterator<Entry> {\n-\n         /** Underlying iterator. */\n         private final Iterator iter;\n-\n         /** Current entry. */\n         private final Entry current;\n \n         /** {@inheritDoc} */\n         public void remove() {\n             throw new UnsupportedOperationException(\"Not supported\");\n-       }\n-\n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n      * @param endColumn Final column index (inclusive)\n      * @return The subMatrix containing the data of the\n      *         specified rows and columns\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the indices are not valid.\n      */\n     RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn);\n \n     * @param selectedColumns Array of column indices.\n     * @return The subMatrix containing the data in the\n     *         specified rows and columns\n-    * @exception MatrixIndexException if row or column selections are not valid\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * the indices are not valid.\n     */\n     RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns);\n \n     * @param endColumn Final column index (inclusive)\n     * @param destination The arrays where the submatrix data should be copied\n     * (if larger than rows/columns counts, only the upper-left part will be used)\n-    * @exception MatrixIndexException if the indices are not valid\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+    * indices are not valid.\n     * @exception IllegalArgumentException if the destination array is too small\n     */\n-  void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n-                     double[][] destination);\n-  /**\n-   * Copy a submatrix. Rows and columns are indicated\n-   * counting from 0 to n-1.\n-   *\n-    * @param selectedRows Array of row indices.\n-    * @param selectedColumns Array of column indices.\n-   * @param destination The arrays where the submatrix data should be copied\n-   * (if larger than rows/columns counts, only the upper-left part will be used)\n-   * @exception MatrixIndexException if the indices are not valid\n-   * @exception IllegalArgumentException if the destination array is too small\n-   */\n+    void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n+                       double[][] destination);\n+    /**\n+     * Copy a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @param destination The arrays where the submatrix data should be copied\n+     * (if larger than rows/columns counts, only the upper-left part will be used)\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * indices are not valid.\n+     * @exception IllegalArgumentException if the destination array is too small\n+     */\n     void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination);\n \n    /**\n     * @param subMatrix  array containing the submatrix replacement data\n     * @param row  row coordinate of the top, left element to be replaced\n     * @param column  column coordinate of the top, left element to be replaced\n-    * @throws MatrixIndexException  if subMatrix does not fit into this\n-    *    matrix from element in (row, column)\n-    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n-    *  (not all rows have the same length) or empty\n-    * @throws NullPointerException if <code>subMatrix</code> is null\n+    * @throws org.apache.commons.math.exception.ZeroException if\n+    * {@code subMatrix} does not contain at least one column.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * {@code subMatrix} does not fit into this matrix from element in\n+    * {@code (row, column)}.\n+    * @throws org.apache.commons.math.exception.DimensionMismatchException\n+    * if {@code subMatrix} is not rectangular.\n+    * (not all rows have the same length) or empty.\n+    * @throws org.apache.commons.math.exception.NullArgumentException if\n+    * {@code subMatrix} is {@code null}.\n     * @since 2.0\n     */\n     void setSubMatrix(double[][] subMatrix, int row, int column);\n \n    /**\n-    * Returns the entries in row number <code>row</code>\n+    * Geet the entries at the given row index\n     * as a row matrix.  Row indices start at 0.\n     *\n-    * @param row the row to be fetched\n-    * @return row matrix\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * @param row Row to be fetched.\n+    * @return row Matrix.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * the specified row index is invalid.\n     */\n    RealMatrix getRowMatrix(int row);\n \n    /**\n-    * Sets the entries in row number <code>row</code>\n+    * Set the entries at the given row index\n     * as a row matrix.  Row indices start at 0.\n     *\n-    * @param row the row to be set\n-    * @param matrix row matrix (must have one row and the same number of columns\n-    * as the instance)\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * @param row Row to be set.\n+    * @param matrix Row matrix (must have one row and the same number of\n+    * columns as the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+    * specified row index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n     * if the matrix dimensions do not match one instance row.\n     */\n     void setRowMatrix(int row, RealMatrix matrix);\n \n    /**\n-    * Returns the entries in column number <code>column</code>\n+    * Get the entries at the given column index\n     * as a column matrix.  Column indices start at 0.\n     *\n-    * @param column the column to be fetched\n-    * @return column matrix\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * @param column Column to be fetched.\n+    * @return column Matrix.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * the specified column index is invalid.\n     */\n    RealMatrix getColumnMatrix(int column);\n \n    /**\n-    * Sets the entries in column number <code>column</code>\n+    * Set the entries at the given column index\n     * as a column matrix.  Column indices start at 0.\n     *\n-    * @param column the column to be set\n-    * @param matrix column matrix (must have one column and the same number of rows\n-    * as the instance)\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * @param column Column to be set.\n+    * @param matrix Column matrix (must have one column and the same number\n+    * of rows as the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * the specified column index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n-    * if the matrix dimensions do not match one instance column.\n+    * if the {@code matrix} dimensions do not match one instance column.\n     */\n     void setColumnMatrix(int column, RealMatrix matrix);\n \n     * Returns the entries in row number <code>row</code>\n     * as a vector.  Row indices start at 0.\n     *\n-    * @param row the row to be fetched\n-    * @return row vector\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * @param row Row to be fetched.\n+    * @return a row vector.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * the specified row index is invalid.\n     */\n    RealVector getRowVector(int row);\n \n    /**\n-    * Sets the entries in row number <code>row</code>\n+    * Set the entries at the given row index.\n     * as a vector.  Row indices start at 0.\n     *\n-    * @param row the row to be set\n+    * @param row Row to be set.\n     * @param vector row vector (must have the same number of columns\n-    * as the instance)\n-    * @throws MatrixIndexException if the specified row index is invalid\n+    * as the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * the specified row index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance row.\n     */\n     void setRowVector(int row, RealVector vector);\n \n    /**\n-    * Returns the entries in column number <code>column</code>\n+    * Get the entries at the given column index\n     * as a vector.  Column indices start at 0.\n     *\n-    * @param column the column to be fetched\n-    * @return column vector\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * @param column Column to be fetched.\n+    * @return a column vector.\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if\n+    * the specified column index is invalid\n     */\n    RealVector getColumnVector(int column);\n \n    /**\n-    * Sets the entries in column number <code>column</code>\n+    * Set the entries at the given column index\n     * as a vector.  Column indices start at 0.\n     *\n-    * @param column the column to be set\n-    * @param vector column vector (must have the same number of rows as the instance)\n-    * @throws MatrixIndexException if the specified column index is invalid\n+    * @param column Column to be set.\n+    * @param vector column vector (must have the same number of rows as\n+    * the instance).\n+    * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+    * specified column index is invalid.\n     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n     * if the vector dimension does not match one instance column.\n     */\n     void setColumnVector(int column, RealVector vector);\n \n     /**\n-     * Returns the entries in row number <code>row</code> as an array.\n-     * <p>\n-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless {@code 0 <= row < rowDimension}.</p>\n-     *\n-     * @param row the row to be fetched\n-     * @return array of entries in the row\n-     * @throws MatrixIndexException if the specified row index is not valid\n+     * Get the entries at the given row index.\n+     * Row indices start at 0.\n+     *\n+     * @param row Row to be fetched.\n+     * @return the array of entries in the row.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * specified row index is not valid.\n      */\n     double[] getRow(int row);\n \n     /**\n-     * Sets the entries in row number <code>row</code>\n+     * Set the entries at the given row index\n      * as a row matrix.  Row indices start at 0.\n      *\n-     * @param row the row to be set\n-     * @param array row matrix (must have the same number of columns as the instance)\n-     * @throws MatrixIndexException if the specified row index is invalid\n+     * @param row Row to be set.\n+     * @param array Row matrix (must have the same number of columns as\n+     * the instance)\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * specified row index is invalid.\n      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n      * if the array size does not match one instance row.\n      */\n     void setRow(int row, double[] array);\n \n     /**\n-     * Returns the entries in column number <code>col</code> as an array.\n-     * <p>\n-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless {@code 0 <= column < columnDimension}.</p>\n-     *\n-     * @param column the column to be fetched\n-     * @return array of entries in the column\n-     * @throws MatrixIndexException if the specified column index is not valid\n+     * Get the entries at the given column index as an array.\n+     * Column indices start at 0.\n+     *\n+     * @param column Column to be fetched.\n+     * @return the array of entries in the column.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * specified column index is not valid.\n      */\n     double[] getColumn(int column);\n \n     /**\n-     * Sets the entries in column number <code>column</code>\n-     * as a column matrix.  Column indices start at 0.\n-     *\n-     * @param column the column to be set\n-     * @param array column array (must have the same number of rows as the instance)\n-     * @throws MatrixIndexException if the specified column index is invalid\n+     * Set the entries at the given column index\n+     * as a column matrix array.  Column indices start at 0.\n+     *\n+     * @param column Column to be set.\n+     * @param array Column array (must have the same number of rows as\n+     * the instance).\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * specified column index is invalid.\n      * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n      * if the array size does not match one instance column.\n      */\n     void setColumn(int column, double[] array);\n \n     /**\n-     * Returns the entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     *\n-     * @param row  row location of entry to be fetched\n-     * @param column  column location of entry to be fetched\n-     * @return matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     * Get the entry in the specified row and column.\n+     * Row and column indices start at 0.\n+     *\n+     * @param row Row location of entry to be fetched.\n+     * @param column Column location of entry to be fetched.\n+     * @return the matrix entry at {@code (row, column)}.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * row or column index is not valid.\n      */\n     double getEntry(int row, int column);\n \n     /**\n      * Set the entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     *\n-     * @param row  row location of entry to be set\n-     * @param column  column location of entry to be set\n-     * @param value matrix entry to be set in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     * Row and column indices start at 0.\n+     *\n+     * @param row Row location of entry to be set.\n+     * @param column Column location of entry to be set.\n+     * @param value matrix entry to be set.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the row or column index is not valid\n      * @since 2.0\n      */\n     void setEntry(int row, int column, double value);\n \n     /**\n      * Change an entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     *\n-     * @param row  row location of entry to be set\n-     * @param column  column location of entry to be set\n-     * @param increment value to add to the current matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     * Row and column indices start at 0.\n+     *\n+     * @param row Row location of entry to be set.\n+     * @param column Column location of entry to be set.\n+     * @param increment value to add to the matrix entry.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the row or column index is not valid.\n      * @since 2.0\n      */\n     void addToEntry(int row, int column, double increment);\n \n     /**\n      * Change an entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy\n-     * <ul>\n-     * <li>{@code 0 <= row < rowDimension}</li>\n-     * <li>{@code 0 <= column < columnDimension}</li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     *\n-     * @param row  row location of entry to be set\n-     * @param column  column location of entry to be set\n-     * @param factor multiplication factor for the current matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n+     * Row and column indices start at 0.\n+     *\n+     * @param row Row location of entry to be set.\n+     * @param column Column location of entry to be set.\n+     * @param factor Multiplication factor for the matrix entry.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the row or column index is not valid.\n      * @since 2.0\n      */\n     void multiplyEntry(int row, int column, double factor);\n      * of a row from left to right before going to the leftmost element\n      * of the next row.</p>\n      * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n      * of a row from left to right before going to the leftmost element\n      * of the next row.</p>\n      * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the indices are not valid.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the indices are not valid.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * of a column from top to bottom before going to the topmost element\n      * of the next column.</p>\n      * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * of a column from top to bottom before going to the topmost element\n      * of the next column.</p>\n      * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the indices are not valid.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the indices are not valid.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * <p>The fastest walking order depends on the exact matrix class. It may be\n      * different from traditional row or column orders.</p>\n      * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * <p>The fastest walking order depends on the exact matrix class. It may be\n      * different from traditional row or column orders.</p>\n      * @param visitor visitor used to process all matrix entries\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the indices are not valid.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n      * @param endRow Final row index (inclusive)\n      * @param startColumn Initial column index\n      * @param endColumn Final column index (inclusive)\n-     * @exception  MatrixVisitorException if the visitor cannot process an entry\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @throws MatrixVisitorException if the visitor cannot process an entry\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * indices are not valid.\n      * @see #walkInRowOrder(RealMatrixChangingVisitor)\n      * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n      * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n  * @since 2.0\n  */\n public interface RealVector {\n-\n     /**\n      * Acts as if it is implemented as:\n-     * Entry e = null;\n-     * for(Iterator<Entry> it = iterator(); it.hasNext(); e = it.next()) {\n-     *   e.setValue(function.value(e.getValue()));\n-     * }\n-     * @param function to apply to each successive entry\n-     * @return this vector\n-     * @throws FunctionEvaluationException if function throws it on application to any entry\n+     * <pre>\n+     *  Entry e = null;\n+     *  for(Iterator<Entry> it = iterator(); it.hasNext(); e = it.next()) {\n+     *      e.setValue(function.value(e.getValue()));\n+     *  }\n+     * </pre>\n+     *\n+     * @param function Function to apply to each entry.\n+     * @return this vector.\n+     * @throws FunctionEvaluationException if the function throws it.\n      */\n     RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException;\n \n     /**\n      * Acts as if implemented as:\n-     * return copy().map(function);\n-     * @param function to apply to each successive entry\n-     * @return a new vector\n-     * @throws FunctionEvaluationException if function throws it on application to any entry\n+     * <pre>\n+     *  return copy().map(function);\n+     * </pre>\n+     *\n+     * @param function Functin to apply to each entry.\n+     * @return a new vector.\n+     * @throws FunctionEvaluationException if the function throws it.\n      */\n     RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException;\n \n     /** Class representing a modifiable entry in the vector. */\n     public abstract class Entry {\n-\n         /** Index of the entry. */\n         private int index;\n \n-        /** Get the value of the entry.\n-         * @return value of the entry\n+        /**\n+         * Get the value of the entry.\n+         *\n+         * @return the value of the entry.\n          */\n         public abstract double getValue();\n-\n-        /** Set the value of the entry.\n-         * @param value new value for the entry\n+        /**\n+         * Set the value of the entry.\n+         *\n+         * @param value New value for the entry.\n          */\n         public abstract void setValue(double value);\n-\n-        /** Get the index of the entry.\n-         * @return index of the entry\n+        /**\n+         * Get the index of the entry.\n+         *\n+         * @return the index of the entry.\n          */\n         public int getIndex() {\n             return index;\n         }\n-\n-        /** Set the index of the entry.\n-         * @param index new index for the entry\n+        /**\n+         * Set the index of the entry.\n+         *\n+         * @param index New index for the entry.\n          */\n         public void setIndex(int index) {\n             this.index = index;\n         }\n-\n     }\n \n     /**\n-     * Generic dense iterator - starts with index == zero, and hasNext() == true until index == getDimension();\n+     * Generic dense iterator.\n+     * It iterates in increasing order of the vector index.\n+     *\n      * @return a dense iterator\n      */\n     Iterator<Entry> iterator();\n \n     /**\n-     * Specialized implementations may choose to not iterate over all dimensions, either because those values are\n-     * unset, or are equal to defaultValue(), or are small enough to be ignored for the purposes of iteration.\n+     * Specialized implementations may choose to not iterate over all\n+     * dimensions, either because those values are unset, or are equal\n+     * to defaultValue(), or are small enough to be ignored for the\n+     * purposes of iteration.\n      * No guarantees are made about order of iteration.\n-     * In dense implementations, this method will often delegate to {@link #iterator()}\n+     * In dense implementations, this method will often delegate to\n+     * {@link #iterator()}.\n+     *\n      * @return a sparse iterator\n      */\n     Iterator<Entry> sparseIterator();\n \n     /**\n-     * Returns a (deep) copy of this.\n-     * @return vector copy\n+     * Returns a (deep) copy of this vector.\n+     *\n+     * @return a vector copy.\n      */\n     RealVector copy();\n \n     /**\n-     * Compute the sum of this and v.\n-     * @param v vector to be added\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector add(RealVector v)\n-        throws IllegalArgumentException;\n-\n-    /**\n-     * Compute the sum of this and v.\n-     * @param v vector to be added\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector add(double[] v)\n-        throws IllegalArgumentException;\n-\n-    /**\n-     * Compute this minus v.\n-     * @param v vector to be subtracted\n-     * @return this + v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector subtract(RealVector v)\n-        throws IllegalArgumentException;\n-\n-    /**\n-     * Compute this minus v.\n-     * @param v vector to be subtracted\n-     * @return this - v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector subtract(double[] v)\n-        throws IllegalArgumentException;\n-\n-    /**\n-     * Map an addition operation to each entry.\n-     * @param d value to be added to each entry\n-     * @return this + d\n+     * Compute the sum of this vector and {@code v}.\n+     *\n+     * @param v Vector to be added.\n+     * @return {@code this} + {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector add(RealVector v);\n+\n+    /**\n+     * Compute the sum of this vector and {@code v}.\n+     *\n+     * @param v Vector to be added.\n+     * @return {@code this} + {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector add(double[] v);\n+\n+\n+    /**\n+     * Subtract {@code v} from this vector.\n+     *\n+     * @param v Vector to be subtracted.\n+     * @return {@code this} - {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector subtract(RealVector v);\n+\n+    /**\n+     * Subtract {@code v} from this vector.\n+     *\n+     * @param v Vector to be subtracted.\n+     * @return {@code this} - {@code v}.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector subtract(double[] v);\n+\n+    /**\n+     * Add a value to each entry.\n+     *\n+     * @param d Value to be added to each entry.\n+     * @return {@code this} + {@code d}.\n      */\n     RealVector mapAdd(double d);\n \n     /**\n-     * Map an addition operation to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @param d value to be added to each entry\n-     * @return for convenience, return this\n+     * Add a value to each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Value to be added to each entry.\n+     * @return {@code this}.\n      */\n     RealVector mapAddToSelf(double d);\n \n     /**\n-     * Map a subtraction operation to each entry.\n-     * @param d value to be subtracted to each entry\n-     * @return this - d\n+     * Subtract a value from each entry.\n+     *\n+     * @param d Value to be subtracted.\n+     * @return {@code this} - {@code d}.\n      */\n     RealVector mapSubtract(double d);\n \n     /**\n-     * Map a subtraction operation to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @param d value to be subtracted to each entry\n-     * @return for convenience, return this\n+     * Subtract a value from each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Value to be subtracted.\n+     * @return {@code this}.\n      */\n     RealVector mapSubtractToSelf(double d);\n \n     /**\n-     * Map a multiplication operation to each entry.\n-     * @param d value to multiply all entries by\n-     * @return this * d\n+     * Multiply each entry.\n+     *\n+     * @param d Multiplication factor.\n+     * @return {@code this} * {@code d}.\n      */\n     RealVector mapMultiply(double d);\n \n     /**\n-     * Map a multiplication operation to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @param d value to multiply all entries by\n-     * @return for convenience, return this\n+     * Multiply each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Multiplication factor.\n+     * @return {@code this}.\n      */\n     RealVector mapMultiplyToSelf(double d);\n \n     /**\n-     * Map a division operation to each entry.\n-     * @param d value to divide all entries by\n-     * @return this / d\n+     * Divide each entry.\n+     *\n+     * @param d Value to divide by.\n+     * @return {@code this} / {@code d}.\n      */\n     RealVector mapDivide(double d);\n \n     /**\n-     * Map a division operation to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @param d value to divide all entries by\n-     * @return for convenience, return this\n+     * Divide each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @param d Value to divide by.\n+     * @return {@code this}.\n      */\n     RealVector mapDivideToSelf(double d);\n \n     /**\n      * Map a power operation to each entry.\n-     * @param d value to raise all entries to\n-     * @return this ^ d\n+     *\n+     * @param d Operator value.\n+     * @return a mapped copy of the vector.\n      */\n     RealVector mapPow(double d);\n \n     /**\n      * Map a power operation to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @param d value to raise all entries to\n-     * @return for convenience, return this\n+     * The instance is changed in-place.\n+     *\n+     * @param d Operator value.\n+     * @return the mapped vector.\n      */\n     RealVector mapPowToSelf(double d);\n \n     /**\n      * Map the {@link Math#exp(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n+     *\n+     * @return a mapped copy of the vector.\n      */\n     RealVector mapExp();\n \n     /**\n-     * Map the {@link Math#exp(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n+     * Map {@link Math#exp(double)} operation to each entry.\n+     * The instance is changed in-place.\n+     *\n+     * @return the mapped vector.\n      */\n     RealVector mapExpToSelf();\n \n      * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n      * @return a vector containing this[i] * v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector ebeMultiply(RealVector v) throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector ebeMultiply(RealVector v);\n \n     /**\n      * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n      * @return a vector containing this[i] * v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector ebeMultiply(double[] v) throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector ebeMultiply(double[] v);\n \n     /**\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      * @return a vector containing this[i] / v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector ebeDivide(RealVector v) throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector ebeDivide(RealVector v);\n \n     /**\n      * Element-by-element division.\n      * @param v vector by which instance elements must be divided\n      * @return a vector containing this[i] / v[i] for all i\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector ebeDivide(double[] v) throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector ebeDivide(double[] v);\n \n     /**\n      * Returns vector entries as a double array.\n      * Compute the dot product.\n      * @param v vector with which dot product should be computed\n      * @return the scalar dot product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    double dotProduct(RealVector v)\n-        throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    double dotProduct(RealVector v);\n \n     /**\n      * Compute the dot product.\n      * @param v vector with which dot product should be computed\n      * @return the scalar dot product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    double dotProduct(double[] v)\n-        throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    double dotProduct(double[] v);\n \n     /**\n      * Returns the L<sub>2</sub> norm of the vector.\n      * elements differences, or euclidian distance.</p>\n      * @param v vector to which distance is requested\n      * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n      * @see #getL1Distance(RealVector)\n      * @see #getLInfDistance(RealVector)\n      * @see #getNorm()\n      */\n-    double getDistance(RealVector v)\n-        throws IllegalArgumentException;\n+    double getDistance(RealVector v);\n \n     /**\n      * Distance between two vectors.\n      * elements differences, or euclidian distance.</p>\n      * @param v vector to which distance is requested\n      * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n      * @see #getL1Distance(double[])\n      * @see #getLInfDistance(double[])\n      * @see #getNorm()\n      */\n-    double getDistance(double[] v)\n-        throws IllegalArgumentException;\n+    double getDistance(double[] v);\n \n     /**\n      * Distance between two vectors.\n      * elements differences.</p>\n      * @param v vector to which distance is requested\n      * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n      * @see #getDistance(RealVector)\n      * @see #getLInfDistance(RealVector)\n      * @see #getL1Norm()\n      */\n-    double getL1Distance(RealVector v)\n-        throws IllegalArgumentException;\n+    double getL1Distance(RealVector v);\n \n     /**\n      * Distance between two vectors.\n      * elements differences.</p>\n      * @param v vector to which distance is requested\n      * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n      * @see #getDistance(double[])\n      * @see #getLInfDistance(double[])\n      * @see #getL1Norm()\n      */\n-    double getL1Distance(double[] v)\n-        throws IllegalArgumentException;\n+    double getL1Distance(double[] v);\n \n     /**\n      * Distance between two vectors.\n      * elements differences.</p>\n      * @param v vector to which distance is requested\n      * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n      * @see #getDistance(RealVector)\n      * @see #getL1Distance(RealVector)\n      * @see #getLInfNorm()\n      */\n-    double getLInfDistance(RealVector v)\n-        throws IllegalArgumentException;\n+    double getLInfDistance(RealVector v);\n \n     /**\n      * Distance between two vectors.\n      * elements differences.</p>\n      * @param v vector to which distance is requested\n      * @return distance between two vectors.\n-     * @exception IllegalArgumentException if v is not the same size as this\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n      * @see #getDistance(double[])\n      * @see #getL1Distance(double[])\n      * @see #getLInfNorm()\n      */\n-    double getLInfDistance(double[] v)\n-        throws IllegalArgumentException;\n+    double getLInfDistance(double[] v);\n \n     /** Creates a unit vector pointing in the direction of this vector.\n      * <p>The instance is not changed by this method.</p>\n \n     /** Converts this vector into a unit vector.\n      * <p>The instance itself is changed by this method.</p>\n-     * @exception ArithmeticException if the norm is null\n+     * @throws  org.apache.commons.math.exception.MathArithmeticException\n+     * if the norm is zero.\n      */\n     void unitize();\n \n     /** Find the orthogonal projection of this vector onto another vector.\n      * @param v vector onto which instance must be projected\n      * @return projection of the instance onto v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector projection(RealVector v)\n-        throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector projection(RealVector v);\n \n     /** Find the orthogonal projection of this vector onto another vector.\n      * @param v vector onto which instance must be projected\n      * @return projection of the instance onto v\n-     * @throws IllegalArgumentException if v is not the same size as this\n-     */\n-    RealVector projection(double[] v)\n-        throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealVector projection(double[] v);\n \n     /**\n      * Compute the outer product.\n      * @param v vector with which outer product should be computed\n      * @return the square matrix outer product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    RealMatrix outerProduct(RealVector v)\n-        throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealMatrix outerProduct(RealVector v);\n \n     /**\n      * Compute the outer product.\n      * @param v vector with which outer product should be computed\n      * @return the square matrix outer product between instance and v\n-     * @exception IllegalArgumentException if v is not the same size as this\n-     */\n-    RealMatrix outerProduct(double[] v)\n-        throws IllegalArgumentException;\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if {@code v} is not the same size as this vector.\n+     */\n+    RealMatrix outerProduct(double[] v);\n \n     /**\n      * Returns the entry in the specified index.\n-     * <p>\n-     * The index start at 0 and must be lesser than the size,\n-     * otherwise a {@link MatrixIndexException} is thrown.\n-     * </p>\n-     * @param index  index location of entry to be fetched\n-     * @return vector entry at index\n-     * @throws MatrixIndexException if the index is not valid\n+     *\n+     * @param index Index location of entry to be fetched.\n+     * @return the vector entry at {@code index}.\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n      * @see #setEntry(int, double)\n      */\n-    double getEntry(int index)\n-        throws MatrixIndexException;\n+    double getEntry(int index);\n \n     /**\n      * Set a single element.\n      * @param index element index.\n      * @param value new value for the element.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n      * @see #getEntry(int)\n      */\n-    void setEntry(int index, double value)\n-        throws MatrixIndexException;\n+    void setEntry(int index, double value);\n \n     /**\n      * Returns the size of the vector.\n      * @param index index of first element.\n      * @param n number of elements to be retrieved.\n      * @return a vector containing n elements.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n-     */\n-    RealVector getSubVector(int index, int n)\n-        throws MatrixIndexException;\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n+     */\n+    RealVector getSubVector(int index, int n);\n \n     /**\n      * Set a set of consecutive elements.\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n      * @see #setSubVector(int, double[])\n      */\n-    void setSubVector(int index, RealVector v)\n-        throws MatrixIndexException;\n+    void setSubVector(int index, RealVector v);\n \n     /**\n      * Set a set of consecutive elements.\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n+     * @throws org.apache.commons.math.exception.OutOfRangeException\n+     * if the index is not valid.\n      * @see #setSubVector(int, RealVector)\n      */\n-    void setSubVector(int index, double[] v)\n-        throws MatrixIndexException;\n+    void setSubVector(int index, double[] v);\n \n     /**\n      * Set all elements to a single value.\n     double[] toArray();\n \n     /**\n-     * Returns true if any coordinate of this vector is NaN; false otherwise\n-     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     * Check whether any coordinate of this vector is {@code NaN}.\n+     * @return {@code true} if any coordinate of this vector is {@code NaN},\n+     * {@code false} otherwise.\n      */\n     boolean isNaN();\n \n     /**\n-     * Returns true if any coordinate of this vector is infinite and none are NaN;\n-     * false otherwise\n-     * @return  true if any coordinate of this vector is infinite and none are NaN;\n-     * false otherwise\n+     * Check whether any coordinate of this vector is infinite and none are {@code NaN}.\n+     *\n+     * @return {@code true} if any coordinate of this vector is infinite and\n+     * none are {@code NaN}, {@code false} otherwise.\n      */\n     boolean isInfinite();\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n  * @since 2.0\n  */\n public class SparseFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> {\n-    /**\n-     *  Serial id\n-     */\n+    /** Serialization identifier. */\n     private static final long serialVersionUID = 9078068119297757342L;\n     /** Storage for (sparse) matrix elements. */\n     private final OpenIntToFieldHashMap<T> entries;\n-    /**\n-     * row dimension\n-     */\n+    /** Row dimension. */\n     private final int rows;\n-    /**\n-     * column dimension\n-     */\n+    /** Column dimension. */\n     private final int columns;\n \n-\n     /**\n-     * Creates a matrix with no data.\n-     * @param field field to which the elements belong\n+     * Create a matrix with no data.\n+     *\n+     * @param field Field to which the elements belong.\n      */\n     public SparseFieldMatrix(final Field<T> field) {\n         super(field);\n     }\n \n     /**\n-     * Create a new SparseFieldMatrix<T> with the supplied row and column dimensions.\n+     * Create a new SparseFieldMatrix<T> with the supplied row and column\n+     * dimensions.\n      *\n-     * @param field field to which the elements belong\n-     * @param rowDimension  the number of rows in the new matrix\n-     * @param columnDimension  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @param field Field to which the elements belong.\n+     * @param rowDimension Number of rows in the new matrix.\n+     * @param columnDimension Number of columns in the new matrix.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if row or column dimension is not positive.\n      */\n     public SparseFieldMatrix(final Field<T> field,\n-                             final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n+                             final int rowDimension, final int columnDimension) {\n         super(field, rowDimension, columnDimension);\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n \n     /**\n      * Copy constructor.\n-     * @param other The instance to copy\n+     *\n+     * @param other Instance to copy.\n      */\n     public SparseFieldMatrix(SparseFieldMatrix<T> other) {\n         super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n \n     /**\n      * Generic copy constructor.\n-     * @param other The instance to copy\n+     *\n+     * @param other Instance to copy.\n      */\n     public SparseFieldMatrix(FieldMatrix<T> other){\n         super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n \n     /** {@inheritDoc} */\n     @Override\n-    public void addToEntry(int row, int column, T increment)\n-            throws MatrixIndexException {\n+    public void addToEntry(int row, int column, T increment) {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n         final int key = computeKey(row, column);\n         } else {\n             entries.put(key, value);\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> createMatrix(int rowDimension, int columnDimension)\n-            throws IllegalArgumentException {\n+    public FieldMatrix<T> createMatrix(int rowDimension, int columnDimension) {\n         return new SparseFieldMatrix<T>(getField(), rowDimension, columnDimension);\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public T getEntry(int row, int column) throws MatrixIndexException {\n+    public T getEntry(int row, int column) {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n         return entries.get(computeKey(row, column));\n \n     /** {@inheritDoc} */\n     @Override\n-    public void multiplyEntry(int row, int column, T factor)\n-            throws MatrixIndexException {\n+    public void multiplyEntry(int row, int column, T factor) {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n         final int key = computeKey(row, column);\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setEntry(int row, int column, T value)\n-            throws MatrixIndexException {\n+    public void setEntry(int row, int column, T value) {\n         checkRowIndex(row);\n         checkColumnIndex(column);\n         if (getField().getZero().equals(value)) {\n         } else {\n             entries.put(computeKey(row, column), value);\n         }\n+    }\n \n-    }\n     /**\n-     * Compute the key to access a matrix element\n-     * @param row row index of the matrix element\n-     * @param column column index of the matrix element\n-     * @return key within the map to access the matrix element\n+     * Compute the key to access a matrix element.\n+     *\n+     * @param row Row index of the matrix element.\n+     * @param column Column index of the matrix element.\n+     * @return the key within the map to access the matrix element.\n      */\n     private int computeKey(int row, int column) {\n         return row * columns + column;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.util.OpenIntToFieldHashMap;\n \n /**\n  * @since 2.0\n  */\n public class SparseFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n-\n-    /**\n-     *  Serial version id\n-     */\n+    /**  Serialization identifier. */\n     private static final long serialVersionUID = 7841233292190413362L;\n     /** Field to which the elements belong. */\n     private final Field<T> field;\n \n     /**\n      * Build a 0-length vector.\n-     * <p>Zero-length vectors may be used to initialize construction of vectors\n+     * Zero-length vectors may be used to initialize construction of vectors\n      * by data gathering. We start with zero-length and use either the {@link\n      * #SparseFieldVector(SparseFieldVector, int)} constructor\n-     * or one of the <code>append</code> method ({@link #append(FieldElement)},\n+     * or one of the {@code append} method ({@link #append(FieldElement)},\n      * {@link #append(FieldElement[])}, {@link #append(FieldVector)},\n-     * {@link #append(SparseFieldVector)}) to gather data into this vector.</p>\n-     * @param field field to which the elements belong\n+     * {@link #append(SparseFieldVector)}) to gather data into this vector.\n+     *\n+     * @param field Field to which the elements belong.\n      */\n     public SparseFieldVector(Field<T> field) {\n         this(field, 0);\n \n \n     /**\n-     * Construct a (dimension)-length vector of zeros.\n-     * @param field field to which the elements belong\n-     * @param dimension Size of the vector\n+     * Construct a vector of zeroes.\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param dimension Size of the vector.\n      */\n     public SparseFieldVector(Field<T> field, int dimension) {\n         this.field = field;\n \n     /**\n      * Build a resized vector, for use with append.\n-     * @param v The original vector\n-     * @param resize The amount to resize it\n+     *\n+     * @param v Original vector\n+     * @param resize Amount to add.\n      */\n     protected SparseFieldVector(SparseFieldVector<T> v, int resize) {\n         field = v.field;\n \n     /**\n      * Build a vector with known the sparseness (for advanced use only).\n-     * @param field field to which the elements belong\n-     * @param dimension The size of the vector\n-     * @param expectedSize The expected number of non-zero entries\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param dimension Size of the vector.\n+     * @param expectedSize Expected number of non-zero entries.\n      */\n     public SparseFieldVector(Field<T> field, int dimension, int expectedSize) {\n         this.field = field;\n \n     /**\n      * Create from a Field array.\n-     * Only non-zero entries will be stored\n-     * @param field field to which the elements belong\n-     * @param values The set of values to create from\n+     * Only non-zero entries will be stored.\n+     *\n+     * @param field Field to which the elements belong.\n+     * @param values Set of values to create from.\n      */\n     public SparseFieldVector(Field<T> field, T[] values) {\n         this.field = field;\n         }\n     }\n \n-\n-\n     /**\n      * Copy constructor.\n-     * @param v The instance to copy from\n+     *\n+     * @param v Instance to copy.\n      */\n     public SparseFieldVector(SparseFieldVector<T> v) {\n         field = v.field;\n \n     /**\n      * Get the entries of this instance.\n-     * @return entries of this instance\n+     *\n+     * @return the entries of this instance\n      */\n     private OpenIntToFieldHashMap<T> getEntries() {\n         return entries;\n \n     /**\n      * Optimized method to add sparse vectors.\n-     * @param v vector to add\n-     * @return The sum of <code>this</code> and <code>v</code>\n-     * @throws IllegalArgumentException If the dimensions don't match\n-     */\n-    public FieldVector<T> add(SparseFieldVector<T> v) throws IllegalArgumentException {\n+     *\n+     * @param v Vector to add.\n+     * @return the sum of {@code this} and {@code v}.\n+     * @throws DimensionMismatchException\n+     * if the dimensions do not match.\n+     */\n+    public FieldVector<T> add(SparseFieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n         OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n \n \n     /** {@inheritDoc} */\n-    public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+    public FieldVector<T> add(T[] v) {\n         checkVectorDimensions(v.length);\n         SparseFieldVector<T> res = new SparseFieldVector<T>(field,getDimension());\n         for (int i = 0; i < v.length; i++) {\n \n     /**\n      * Construct a vector by appending a vector to this vector.\n-     * @param v vector to append to this one.\n-     * @return a new vector\n+     *\n+     * @param v Vector to append to this one.\n+     * @return a new vector.\n      */\n     public FieldVector<T> append(SparseFieldVector<T> v) {\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this, v.getDimension());\n    }\n \n     /** {@inheritDoc} */\n-    public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {\n+    public T dotProduct(FieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n         T res = field.getZero();\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public T dotProduct(T[] v) throws IllegalArgumentException {\n+    public T dotProduct(T[] v) {\n         checkVectorDimensions(v.length);\n         T res = field.getZero();\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n      }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(FieldVector<T> v)\n-        throws IllegalArgumentException {\n+    public FieldVector<T> ebeDivide(FieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {\n+    public FieldVector<T> ebeDivide(T[] v) {\n         checkVectorDimensions(v.length);\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> ebeMultiply(FieldVector<T> v)throws IllegalArgumentException {\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-     public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {\n+     public FieldVector<T> ebeMultiply(T[] v) {\n         checkVectorDimensions(v.length);\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n     }\n \n      /** {@inheritDoc} */\n-     public T getEntry(int index) throws MatrixIndexException {\n+     public T getEntry(int index) {\n         checkIndex(index);\n         return entries.get(index);\n    }\n     }\n \n      /** {@inheritDoc} */\n-     public FieldVector<T> getSubVector(int index, int n)\n-            throws MatrixIndexException {\n+     public FieldVector<T> getSubVector(int index, int n) {\n         checkIndex(index);\n         checkIndex(index + n - 1);\n         SparseFieldVector<T> res = new SparseFieldVector<T>(field,n);\n         return mapAddToSelf(field.getZero().subtract(d));\n     }\n \n-     /**\n-      * Optimized method to compute outer product when both vectors are sparse.\n-      * @param v vector with which outer product should be computed\n-      * @return the square matrix outer product between instance and v\n-      * @throws IllegalArgumentException if v is not the same size as {@code this}\n-      */\n-    public FieldMatrix<T> outerProduct(SparseFieldVector<T> v)\n-            throws IllegalArgumentException {\n+    /**\n+     * Optimized method to compute outer product when both vectors are sparse.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @throws DimensionMismatchException\n+     * if the dimensions do not match.\n+     */\n+    public FieldMatrix<T> outerProduct(SparseFieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n         SparseFieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {\n+    public FieldMatrix<T> outerProduct(T[] v) {\n         checkVectorDimensions(v.length);\n         FieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);\n         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n      }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> outerProduct(FieldVector<T> v)\n-    throws IllegalArgumentException {\n+    public FieldMatrix<T> outerProduct(FieldVector<T> v) {\n         if(v instanceof SparseFieldVector<?>)\n             return outerProduct((SparseFieldVector<T>)v);\n         else\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> projection(FieldVector<T> v)\n-    throws IllegalArgumentException {\n+    public FieldVector<T> projection(FieldVector<T> v) {\n         checkVectorDimensions(v.getDimension());\n         return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> projection(T[] v) throws IllegalArgumentException {\n+    public FieldVector<T> projection(T[] v) {\n         checkVectorDimensions(v.length);\n         return projection(new SparseFieldVector<T>(field,v));\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public void setEntry(int index, T value) throws MatrixIndexException {\n+    public void setEntry(int index, T value) {\n         checkIndex(index);\n         entries.put(index, value);\n    }\n \n     /** {@inheritDoc} */\n-    public void setSubVector(int index, FieldVector<T> v)\n-            throws MatrixIndexException {\n+    public void setSubVector(int index, FieldVector<T> v) {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n         setSubVector(index, v.getData());\n     }\n \n     /** {@inheritDoc} */\n-    public void setSubVector(int index, T[] v) throws MatrixIndexException {\n+    public void setSubVector(int index, T[] v) {\n         checkIndex(index);\n         checkIndex(index + v.length - 1);\n         for (int i = 0; i < v.length; i++) {\n \n     /**\n      * Optimized method to subtract SparseRealVectors.\n-     * @param v The vector to subtract from <code>this</code>\n-     * @return The difference of <code>this</code> and <code>v</code>\n-     * @throws IllegalArgumentException If the dimensions don't match\n-     */\n-    public SparseFieldVector<T> subtract(SparseFieldVector<T> v) throws IllegalArgumentException{\n+     *\n+     * @param v Vector to subtract.\n+     * @return the difference between {@code this} and {@code v}.\n+     * @throws DimensionMismatchException\n+     * if the dimensions do not match.\n+     */\n+    public SparseFieldVector<T> subtract(SparseFieldVector<T> v){\n         checkVectorDimensions(v.getDimension());\n         SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n         OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> subtract(FieldVector<T> v)\n-           throws IllegalArgumentException {\n+    public FieldVector<T> subtract(FieldVector<T> v) {\n         if(v instanceof SparseFieldVector<?>)\n             return subtract((SparseFieldVector<T>)v);\n         else\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+    public FieldVector<T> subtract(T[] v) {\n         checkVectorDimensions(v.length);\n         SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n         for (int i = 0; i < v.length; i++) {\n     }\n \n     /**\n-     * Check if an index is valid.\n-     *\n-     * @param index\n-     *            index to check\n-     * @exception MatrixIndexException\n-     *                if index is not valid\n-     */\n-    private void checkIndex(final int index) throws MatrixIndexException {\n+     * Check whether an index is valid.\n+     *\n+     * @param index Index to check.\n+     * @throws OutOfRangeException if the dimensions do not match.\n+     */\n+    private void checkIndex(final int index) {\n         if (index < 0 || index >= getDimension()) {\n-            throw new MatrixIndexException(LocalizedFormats.INDEX_OUT_OF_RANGE,\n-                                           index, 0, getDimension() - 1);\n+            throw new OutOfRangeException(index, 0, getDimension() - 1);\n         }\n     }\n \n     /**\n      * Check if instance dimension is equal to some expected value.\n      *\n-     * @param n\n-     *            expected dimension.\n-     * @exception IllegalArgumentException\n-     *                if the dimension is inconsistent with vector size\n-     */\n-    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n+     * @param n Expected dimension.\n+     * @throws DimensionMismatchException if the dimensions do not match.\n+     */\n+    protected void checkVectorDimensions(int n) {\n         if (getDimension() != n) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    getDimension(), n);\n-        }\n-    }\n-\n-\n-    /** {@inheritDoc} */\n-    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+            throw new DimensionMismatchException(getDimension(), n);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(FieldVector<T> v) {\n         if (v instanceof SparseFieldVector<?>) {\n             return add((SparseFieldVector<T>)v);\n         } else {\n         }\n     }\n \n-    /** Build an array of elements.\n-     * @param length size of the array to build\n-     * @return a new array\n+    /**\n+     * Build an array of elements.\n+     *\n+     * @param length Size of the array to build.\n+     * @return a new array.\n      */\n     @SuppressWarnings(\"unchecked\") // field is type T\n     private T[] buildArray(final int length) {\n         }\n         return true;\n     }\n-\n-\n-\n }\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n \n /**\n  * Test cases for the {@link Array2DRowRealMatrix} class.\n         TestUtils.assertEquals(\"get col\",m.getColumn(2),testDataCol3,entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n         assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail (\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n             RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n             assertEquals(new Array2DRowRealMatrix(reference), sub);\n             if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n             RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns);\n             assertEquals(new Array2DRowRealMatrix(reference), sub);\n             if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n             m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n             assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n             if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n             m.copySubMatrix(selectedRows, selectedColumns, sub);\n             assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub));\n             if (mustFail) {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (!mustFail) {\n                 throw e;\n             }\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.exception.OutOfRangeException;\n \n /**\n  * Test cases for the {@link ArrayFieldVector} class.\n         assertEquals(new Fraction(5), vout5.getEntry(1));\n         try {\n             v4.getSubVector(3, 7);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(new Fraction(11), v_set1.getEntry(1));\n         try {\n             v_set1.setEntry(3, new Fraction(11));\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(new Fraction(7), v_set2.getEntry(6));\n         try {\n             v_set2.set(7, v1);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(new Fraction(7), v_set4.getEntry(6));\n         try {\n             v_set4.setSubVector(7, v2_t);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.OutOfRangeException;\n \n /**\n  * Test cases for the {@link ArrayRealVector} class.\n         assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n         try {\n             v4.getSubVector(3, 7);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n         try {\n             v_set1.setEntry(3, 11.0);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n         try {\n             v_set2.set(7, v1);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n         try {\n             v_set4.setSubVector(7, v2_t);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n \n /**\n  * Test cases for the {@link BlockRealMatrix} class.\n         assertClose(m.getColumn(2), testDataCol3, entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n         assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail (\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), sub);\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallExceptiono r ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub));\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or ZeroException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (ZeroException e) {\n             if (reference != null) {\n                 throw e;\n             }\n         assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionConversionException;\n import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Test cases for the {@link MatrixUtils} class.\n         }\n         try {\n             MatrixUtils.createRealMatrix(null);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+            fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             MatrixUtils.createFieldMatrix((Fraction[][])null);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    @Deprecated\n-    public void testCreateBigMatrix() {\n-        assertEquals(new BigMatrixImpl(testData),\n-                MatrixUtils.createBigMatrix(testData));\n-        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true),\n-                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));\n-        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false),\n-                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));\n-        assertEquals(new BigMatrixImpl(bigColMatrix),\n-                MatrixUtils.createBigMatrix(bigColMatrix));\n-        assertEquals(new BigMatrixImpl(stringColMatrix),\n-                MatrixUtils.createBigMatrix(stringColMatrix));\n-        try {\n-            MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            MatrixUtils.createBigMatrix(nullMatrix);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+            fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n             // expected\n         }\n     }\n                      new BlockRealMatrix(rowMatrix));\n         try {\n             MatrixUtils.createRowRealMatrix(new double[] {});  // empty\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+            fail(\"Expecting NotStrictlyPositiveException\");\n+        } catch (NotStrictlyPositiveException ex) {\n             // expected\n         }\n         try {\n             MatrixUtils.createRowRealMatrix(null);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+            fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             MatrixUtils.createRowFieldMatrix((Fraction[]) null);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    @Deprecated\n-    public void testCreateRowBigMatrix() {\n-        assertEquals(MatrixUtils.createRowBigMatrix(row),\n-                new BigMatrixImpl(rowMatrix));\n-        assertEquals(MatrixUtils.createRowBigMatrix(bigRow),\n-                new BigMatrixImpl(bigRowMatrix));\n-        assertEquals(MatrixUtils.createRowBigMatrix(stringRow),\n-                new BigMatrixImpl(stringRowMatrix));\n-        try {\n-            MatrixUtils.createRowBigMatrix(new double[] {});  // empty\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            MatrixUtils.createRowBigMatrix(nullDoubleArray);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+            fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             MatrixUtils.createColumnRealMatrix(null);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+            fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             MatrixUtils.createColumnFieldMatrix((Fraction[]) null);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    @Deprecated\n-    public void testCreateColumnBigMatrix() {\n-        assertEquals(MatrixUtils.createColumnBigMatrix(col),\n-                new BigMatrixImpl(colMatrix));\n-        assertEquals(MatrixUtils.createColumnBigMatrix(bigCol),\n-                new BigMatrixImpl(bigColMatrix));\n-        assertEquals(MatrixUtils.createColumnBigMatrix(stringCol),\n-                new BigMatrixImpl(stringColMatrix));\n-\n-        try {\n-            MatrixUtils.createColumnBigMatrix(new double[] {});  // empty\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            MatrixUtils.createColumnBigMatrix(nullDoubleArray);  // null\n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+            fail(\"Expecting NullArgumentException\");\n+        } catch (NullArgumentException ex) {\n             // expected\n         }\n     }\n         }\n         return d;\n     }\n-\n-    /**\n-     * Verifies that the matrix is an identity matrix\n-     */\n-    @Deprecated\n-    protected void checkIdentityBigMatrix(BigMatrix m) {\n-        for (int i = 0; i < m.getRowDimension(); i++) {\n-            for (int j =0; j < m.getColumnDimension(); j++) {\n-                if (i == j) {\n-                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE);\n-                } else {\n-                    assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Deprecated\n-    public void testCreateBigIdentityMatrix() {\n-        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3));\n-        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2));\n-        checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1));\n-        try {\n-            MatrixUtils.createRealIdentityMatrix(0);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n \n /**\n  * Test cases for the {@link OpenMapRealMatrix} class.\n         assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n         assertEquals(\"get entry\", m.getEntry(0, 1), 2d, entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting NumberIsTooSmallException\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(-1, 1, 2, 2);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 2);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting NumberIsTooSmallException\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting NumberIsTooSmallException\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] {}, new int[] { 0 });\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting ZeroException\");\n+        } catch (ZeroException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         // dimension overflow\n         try {\n             m.setSubMatrix(testData, 1, 1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData, -1, 1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData, 1, -1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.OutOfRangeException;\n \n /**\n  * Test cases for the {@link OpenMapRealVector} class.\n         assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n         try {\n             v4.getSubVector(3, 7);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n         try {\n             v_set1.setEntry(3, 11.0);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n         try {\n             v_set2.setSubVector(7, v1);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n \n         try {\n             v_set3.getEntry(23);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n         try {\n             v_set4.setSubVector(7, v2_t);\n-            fail(\"MatrixIndexException expected\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"OutOfRangeException expected\");\n+        } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n ", "timestamp": 1288185417, "metainfo": ""}