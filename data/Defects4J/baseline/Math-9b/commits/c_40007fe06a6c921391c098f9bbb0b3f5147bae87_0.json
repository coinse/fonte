{"sha": "40007fe06a6c921391c098f9bbb0b3f5147bae87", "log": "Added throws declarations, improved javadoc, made Kurtosis increment consistent with other moment statistics. JIRA: MATH-854.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math3/stat/Frequency.java\n      * </p>\n      *\n      * @param v the value to add.\n-     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n-     */\n-    public void addValue(Comparable<?> v){\n+     * @throws MathIllegalArgumentException if <code>v</code> is not comparable with previous entries\n+     */\n+    public void addValue(Comparable<?> v) throws MathIllegalArgumentException {\n         Comparable<?> obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n--- a/src/main/java/org/apache/commons/math3/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math3/stat/StatUtils.java\n  */\n package org.apache.commons.math3.stat;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n      * @param values  array of values to sum\n      * @return the sum of the values or <code>Double.NaN</code> if the array\n      * is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double sum(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double sum(final double[] values)\n+    throws MathIllegalArgumentException {\n         return SUM.evaluate(values);\n     }\n \n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the sum of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     public static double sum(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return SUM.evaluate(values, begin, length);\n     }\n \n      * @param values  input array\n      * @return the sum of the squared values or <code>Double.NaN</code> if the\n      * array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double sumSq(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double sumSq(final double[] values) throws MathIllegalArgumentException {\n         return SUM_OF_SQUARES.evaluate(values);\n     }\n \n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the sum of the squares of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n      */\n     public static double sumSq(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return SUM_OF_SQUARES.evaluate(values, begin, length);\n     }\n \n      *\n      * @param values the input array\n      * @return the product of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double product(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double product(final double[] values)\n+    throws MathIllegalArgumentException {\n         return PRODUCT.evaluate(values);\n     }\n \n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the product of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n      */\n     public static double product(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return PRODUCT.evaluate(values, begin, length);\n     }\n \n      * @param values the input array\n      * @return the sum of the natural logs of the values or Double.NaN if\n      * the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double sumLog(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double sumLog(final double[] values)\n+    throws MathIllegalArgumentException {\n         return SUM_OF_LOGS.evaluate(values);\n     }\n \n      * @param length the number of elements to include\n      * @return the sum of the natural logs of the values or Double.NaN if\n      * length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n      */\n     public static double sumLog(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return SUM_OF_LOGS.evaluate(values, begin, length);\n     }\n \n      *\n      * @param values the input array\n      * @return the mean of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double mean(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double mean(final double[] values)\n+    throws MathIllegalArgumentException {\n         return MEAN.evaluate(values);\n     }\n \n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the mean of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n      */\n     public static double mean(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return MEAN.evaluate(values, begin, length);\n     }\n \n      *\n      * @param values the input array\n      * @return the geometric mean of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public static double geometricMean(final double[] values) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public static double geometricMean(final double[] values)\n+    throws MathIllegalArgumentException {\n         return GEOMETRIC_MEAN.evaluate(values);\n     }\n \n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the geometric mean of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n      */\n     public static double geometricMean(final double[] values, final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n         return GEOMETRIC_MEAN.evaluate(values, begin, length);\n     }\n \n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n package org.apache.commons.math3.stat.descriptive;\n \n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.util.MathUtils;\n import org.apache.commons.math3.util.Precision;\n      * possibly more accurate implementation that works directly with the\n      * input array.</p>\n      * <p>\n-     * If the array is null, an IllegalArgumentException is thrown.</p>\n+     * If the array is null, a MathIllegalArgumentException is thrown.</p>\n      * @param values input array\n      * @return the value of the statistic applied to the input array\n+     * @throws MathIllegalArgumentException if values is null\n      * @see org.apache.commons.math3.stat.descriptive.UnivariateStatistic#evaluate(double[])\n      */\n     @Override\n-    public double evaluate(final double[] values) {\n+    public double evaluate(final double[] values) throws MathIllegalArgumentException {\n         if (values == null) {\n             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n         }\n      * input array.</p>\n      * <p>\n      * If the array is null or the index parameters are not valid, an\n-     * IllegalArgumentException is thrown.</p>\n+     * MathIllegalArgumentException is thrown.</p>\n      * @param values the input array\n      * @param begin the index of the first element to include\n      * @param length the number of elements to include\n      * @return the value of the statistic applied to the included array entries\n+     * @throws MathIllegalArgumentException if the array is null or the indices are not valid\n      * @see org.apache.commons.math3.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     @Override\n-    public double evaluate(final double[] values, final int begin, final int length) {\n+    public double evaluate(final double[] values, final int begin,\n+            final int length) throws MathIllegalArgumentException {\n         if (test(values, begin, length)) {\n             clear();\n             incrementAll(values, begin, length);\n      * Throws IllegalArgumentException if the input values array is null.</p>\n      *\n      * @param values values to add\n-     * @throws IllegalArgumentException if values is null\n+     * @throws MathIllegalArgumentException if values is null\n      * @see org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[])\n      */\n-    public void incrementAll(double[] values) {\n+    public void incrementAll(double[] values) throws MathIllegalArgumentException {\n         if (values == null) {\n             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n         }\n      * @param values  array holding values to add\n      * @param begin   index of the first array element to add\n      * @param length  number of array elements to add\n-     * @throws IllegalArgumentException if values is null\n+     * @throws MathIllegalArgumentException if values is null\n      * @see org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[], int, int)\n      */\n-    public void incrementAll(double[] values, int begin, int length) {\n+    public void incrementAll(double[] values, int begin, int length) throws MathIllegalArgumentException {\n         if (test(values, begin, length)) {\n             int k = begin + length;\n             for (int i = begin; i < k; i++) {\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/AbstractUnivariateStatistic.java\n     /**\n      * Set the data array.\n      * <p>\n-     * The stored value is a copy of the parameter array, not the array itself\n+     * The stored value is a copy of the parameter array, not the array itself.\n      * </p>\n      * @param values data array to store (may be null to remove stored data)\n      * @see #evaluate()\n     }\n \n     /**\n-     * Set the data array.\n+     * Set the data array.  The input array is copied, not referenced.\n+     *\n      * @param values data array to store\n      * @param begin the index of the first element to include\n      * @param length the number of elements to include\n+     * @throws MathIllegalArgumentException if values is null or the indices\n+     * are not valid\n      * @see #evaluate()\n      */\n-    public void setData(final double[] values, final int begin, final int length) {\n+    public void setData(final double[] values, final int begin, final int length)\n+    throws MathIllegalArgumentException {\n+        if (values == null) {\n+            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n+        }\n+\n+        if (begin < 0) {\n+            throw new NotPositiveException(LocalizedFormats.START_POSITION, begin);\n+        }\n+\n+        if (length < 0) {\n+            throw new NotPositiveException(LocalizedFormats.LENGTH, length);\n+        }\n+\n+        if (begin + length > values.length) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END,\n+                                                begin + length, values.length, true);\n+        }\n         storedData = new double[length];\n         System.arraycopy(values, begin, storedData, 0, length);\n     }\n     /**\n      * Returns the result of evaluating the statistic over the stored data.\n      * <p>\n-     * The stored array is the one which was set by previous calls to\n+     * The stored array is the one which was set by previous calls to {@link #setData(double[])}.\n      * </p>\n      * @return the value of the statistic applied to the stored data\n-     */\n-    public double evaluate() {\n+     * @throws MathIllegalArgumentException if the stored data array is null\n+     */\n+    public double evaluate() throws MathIllegalArgumentException {\n         return evaluate(storedData);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public double evaluate(final double[] values) {\n+    public double evaluate(final double[] values) throws MathIllegalArgumentException {\n         test(values, 0, 0);\n         return evaluate(values, 0, values.length);\n     }\n     /**\n      * {@inheritDoc}\n      */\n-    public abstract double evaluate(final double[] values, final int begin, final int length);\n+    public abstract double evaluate(final double[] values, final int begin, final int length)\n+    throws MathIllegalArgumentException;\n \n     /**\n      * {@inheritDoc}\n      * <ul>\n      * <li>returns <code>true</code> iff the parameters designate a subarray of\n      * positive length</li>\n-     * <li>throws <code>IllegalArgumentException</code> if the array is null or\n+     * <li>throws <code>MathIllegalArgumentException</code> if the array is null or\n      * or the indices are invalid</li>\n      * <li>returns <code>false</li> if the array is non-null, but\n      * <code>length</code> is 0.\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return true if the parameters are valid and designate a subarray of positive length\n-     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n      */\n     protected boolean test(\n         final double[] values,\n         final int begin,\n-        final int length) {\n+        final int length) throws MathIllegalArgumentException {\n         return test(values, begin, length, false);\n     }\n \n      * @param length the number of elements to include\n      * @param allowEmpty if <code>true</code> then zero length arrays are allowed\n      * @return true if the parameters are valid\n-     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n      * @since 3.0\n      */\n-    protected boolean test(final double[] values, final int begin, final int length, final boolean allowEmpty){\n+    protected boolean test(final double[] values, final int begin,\n+            final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n \n         if (values == null) {\n             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return true if the parameters are valid and designate a subarray of positive length\n-     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n      * @since 2.1\n      */\n     protected boolean test(\n         final double[] values,\n         final double[] weights,\n         final int begin,\n-        final int length) {\n+        final int length) throws MathIllegalArgumentException {\n         return test(values, weights, begin, length, false);\n     }\n \n      * <ul>\n      * <li>returns <code>true</code> iff the parameters designate a subarray of\n      * non-negative length and the weights array contains legitimate values.</li>\n-     * <li>throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <li>throws <code>MathIllegalArgumentException</code> if any of the following are true:\n      * <ul><li>the values array is null</li>\n      *     <li>the weights array is null</li>\n      *     <li>the weights array does not have the same length as the values array</li>\n      * @param length the number of elements to include.\n      * @param allowEmpty if {@code true} than allow zero length arrays to pass.\n      * @return {@code true} if the parameters are valid.\n-     * @throws IllegalArgumentException if the indices are invalid or the array\n-     * is {@code null}.\n+     * @throws NullArgumentException if either of the arrays are null\n+     * @throws MathIllegalArgumentException if the array indices are not valid,\n+     * the weights array contains NaN, infinite or negative elements, or there\n+     * are no positive weights.\n      * @since 3.0\n      */\n-    protected boolean test(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty){\n-\n-        if (weights == null) {\n+    protected boolean test(final double[] values, final double[] weights,\n+            final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n+\n+        if (weights == null || values == null) {\n             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n         }\n \n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/AggregateSummaryStatistics.java\n import java.io.Serializable;\n import java.util.Collection;\n import java.util.Iterator;\n+\n+import org.apache.commons.math3.exception.NullArgumentException;\n \n /**\n  * <p>\n      *\n      */\n     public AggregateSummaryStatistics() {\n+        // No try-catch or throws NAE because arg is guaranteed non-null\n         this(new SummaryStatistics());\n     }\n \n      *      If {@code null}, a new, default statistics object is used.  Any statistic\n      *      values in the prototype are propagated to contributing statistics\n      *      objects and (once) into these aggregate statistics.\n+     * @throws NullArgumentException if prototypeStatistics is null\n      * @see #createContributingStatistics()\n      */\n-    public AggregateSummaryStatistics(SummaryStatistics prototypeStatistics) {\n+    public AggregateSummaryStatistics(SummaryStatistics prototypeStatistics) throws NullArgumentException {\n         this(prototypeStatistics,\n              prototypeStatistics == null ? null : new SummaryStatistics(prototypeStatistics));\n     }\n         SummaryStatistics contributingStatistics\n                 = new AggregatingSummaryStatistics(statistics);\n \n+        // No try - catch or advertising NAE because neither argument will ever be null\n         SummaryStatistics.copy(statisticsPrototype, contributingStatistics);\n \n         return contributingStatistics;\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/DescriptiveStatistics.java\n      * Construct a DescriptiveStatistics instance with the specified window\n      *\n      * @param window the window size.\n-     */\n-    public DescriptiveStatistics(int window) {\n+     * @throws MathIllegalArgumentException if window size is less than 1 but\n+     * not equal to {@link #INFINITE_WINDOW}\n+     */\n+    public DescriptiveStatistics(int window) throws MathIllegalArgumentException {\n         setWindowSize(window);\n     }\n \n      * is a copy of original.\n      *\n      * @param original DescriptiveStatistics instance to copy\n-     */\n-    public DescriptiveStatistics(DescriptiveStatistics original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public DescriptiveStatistics(DescriptiveStatistics original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n     }\n \n     /**\n-     * WindowSize controls the number of values which contribute\n-     * to the reported statistics.  For example, if\n-     * windowSize is set to 3 and the values {1,2,3,4,5}\n-     * have been added <strong> in that order</strong>\n-     * then the <i>available values</i> are {3,4,5} and all\n-     * reported statistics will be based on these values\n+     * WindowSize controls the number of values that contribute to the\n+     * reported statistics.  For example, if windowSize is set to 3 and the\n+     * values {1,2,3,4,5} have been added <strong> in that order</strong> then\n+     * the <i>available values</i> are {3,4,5} and all reported statistics will\n+     * be based on these values. If {@code windowSize} is decreased as a result\n+     * of this call and there are more than the new value of elements in the\n+     * current dataset, values from the front of the array are discarded to\n+     * reduce the dataset to {@code windowSize} elements.\n+     *\n      * @param windowSize sets the size of the window.\n-     */\n-    public void setWindowSize(int windowSize) {\n+     * @throws MathIllegalArgumentException if window size is less than 1 but\n+     * not equal to {@link #INFINITE_WINDOW}\n+     */\n+    public void setWindowSize(int windowSize) throws MathIllegalArgumentException {\n         if (windowSize < 1) {\n             if (windowSize != INFINITE_WINDOW) {\n                 throw new MathIllegalArgumentException(\n      *\n      * @param p the requested percentile (scaled from 0 - 100)\n      * @return An estimate for the pth percentile of the stored data\n-     * @throws IllegalStateException if percentile implementation has been\n+     * @throws MathIllegalStateException if percentile implementation has been\n      *  overridden and the supplied implementation does not support setQuantile\n      */\n-    public double getPercentile(double p) {\n+    public double getPercentile(double p) throws MathIllegalStateException {\n         if (percentileImpl instanceof Percentile) {\n             ((Percentile) percentileImpl).setQuantile(p);\n         } else {\n         outBuffer.append(\"mean: \").append(getMean()).append(endl);\n         outBuffer.append(\"std dev: \").append(getStandardDeviation())\n             .append(endl);\n-        outBuffer.append(\"median: \").append(getPercentile(50)).append(endl);\n+        try {\n+            outBuffer.append(\"median: \").append(getPercentile(50)).append(endl);\n+        } catch (MathIllegalStateException ex) {\n+            outBuffer.append(\"median: unavailable\").append(endl);\n+        }\n         outBuffer.append(\"skewness: \").append(getSkewness()).append(endl);\n         outBuffer.append(\"kurtosis: \").append(getKurtosis()).append(endl);\n         return outBuffer.toString();\n      * @return the computed value of the statistic.\n      */\n     public double apply(UnivariateStatistic stat) {\n+        // No try-catch or advertised exception here because arguments are guaranteed valid\n         return stat.evaluate(eDA.getInternalValues(), eDA.start(), eDA.getNumElements());\n     }\n \n      * <code>IllegalArgumentException</code> is thrown.\n      *\n      * @param percentileImpl the percentileImpl to set\n-     * @throws IllegalArgumentException if the supplied implementation does not\n+     * @throws MathIllegalArgumentException if the supplied implementation does not\n      *  provide a <code>setQuantile</code> method\n      * @since 1.2\n      */\n-    public synchronized void setPercentileImpl(\n-            UnivariateStatistic percentileImpl) {\n+    public synchronized void setPercentileImpl(UnivariateStatistic percentileImpl)\n+    throws MathIllegalArgumentException {\n         try {\n             percentileImpl.getClass().getMethod(SET_QUANTILE_METHOD_NAME,\n                     new Class[] {Double.TYPE}).invoke(percentileImpl,\n      */\n     public DescriptiveStatistics copy() {\n         DescriptiveStatistics result = new DescriptiveStatistics();\n+        // No try-catch or advertised exception because parms are guaranteed valid\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/MultivariateSummaryStatistics.java\n      * @throws DimensionMismatchException if the length of the array\n      * does not match the one used at construction\n      */\n-    public void addValue(double[] value) {\n+    public void addValue(double[] value) throws DimensionMismatchException {\n         checkDimension(value.length);\n         for (int i = 0; i < k; ++i) {\n             double v = value[i];\n      * @param oldImpl old implementations for statistics\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n-     *  (i.e if n > 0)\n+     * @throws MathIllegalStateException if data has already been added\n+     * (i.e. if n > 0)\n      */\n     private void setImpl(StorelessUnivariateStatistic[] newImpl,\n-                         StorelessUnivariateStatistic[] oldImpl) {\n+                         StorelessUnivariateStatistic[] oldImpl) throws MathIllegalStateException,\n+                         DimensionMismatchException {\n         checkEmpty();\n         checkDimension(newImpl.length);\n         System.arraycopy(newImpl, 0, oldImpl, 0, newImpl.length);\n      * for computing the Sum\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setSumImpl(StorelessUnivariateStatistic[] sumImpl) {\n+    public void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n+    throws MathIllegalStateException, DimensionMismatchException {\n         setImpl(sumImpl, this.sumImpl);\n     }\n \n      * for computing the sum of squares\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl) {\n+    public void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n+    throws MathIllegalStateException, DimensionMismatchException {\n         setImpl(sumsqImpl, this.sumSqImpl);\n     }\n \n      * for computing the minimum\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setMinImpl(StorelessUnivariateStatistic[] minImpl) {\n+    public void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n+    throws MathIllegalStateException, DimensionMismatchException {\n         setImpl(minImpl, this.minImpl);\n     }\n \n      * for computing the maximum\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setMaxImpl(StorelessUnivariateStatistic[] maxImpl) {\n+    public void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n+    throws MathIllegalStateException, DimensionMismatchException{\n         setImpl(maxImpl, this.maxImpl);\n     }\n \n      * for computing the log sum\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl) {\n+    public void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n+    throws MathIllegalStateException, DimensionMismatchException{\n         setImpl(sumLogImpl, this.sumLogImpl);\n     }\n \n      * for computing the geometric mean\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl) {\n+    public void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n+    throws MathIllegalStateException, DimensionMismatchException {\n         setImpl(geoMeanImpl, this.geoMeanImpl);\n     }\n \n      * for computing the mean\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setMeanImpl(StorelessUnivariateStatistic[] meanImpl) {\n+    public void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n+    throws MathIllegalStateException, DimensionMismatchException{\n         setImpl(meanImpl, this.meanImpl);\n     }\n \n      * Throws MathIllegalStateException if the statistic is not empty.\n      * @throws MathIllegalStateException if n > 0.\n      */\n-    private void checkEmpty() {\n+    private void checkEmpty() throws MathIllegalStateException {\n         if (n > 0) {\n             throw new MathIllegalStateException(\n                     LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC, n);\n      * @param dimension dimension to check\n      * @throws DimensionMismatchException if dimension != k\n      */\n-    private void checkDimension(int dimension) {\n+    private void checkDimension(int dimension) throws DimensionMismatchException {\n         if (dimension != k) {\n             throw new DimensionMismatchException(dimension, k);\n         }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/StorelessUnivariateStatistic.java\n  * limitations under the License.\n  */\n package org.apache.commons.math3.stat.descriptive;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n \n /**\n  * Extends the definition of {@link UnivariateStatistic} with\n      * i.e., the values are added <strong>incrementally</strong> to the dataset.\n      *\n      * @param values  array holding the new values to add\n-     * @throws IllegalArgumentException if the array is null\n+     * @throws MathIllegalArgumentException if the array is null\n      */\n-    void incrementAll(double[] values);\n+    void incrementAll(double[] values) throws MathIllegalArgumentException;\n \n     /**\n      * Updates the internal state of the statistic to reflect addition of\n      * @param values  array holding the new values to add\n      * @param start  the array index of the first value to add\n      * @param length  the number of elements to add\n-     * @throws IllegalArgumentException if the array is null or the index\n+     * @throws MathIllegalArgumentException if the array is null or the index\n      */\n-    void incrementAll(double[] values, int start, int length);\n+    void incrementAll(double[] values, int start, int length) throws MathIllegalArgumentException;\n \n     /**\n      * Returns the current value of the Statistic.\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/SummaryStatistics.java\n      * A copy constructor. Creates a deep-copy of the {@code original}.\n      *\n      * @param original the {@code SummaryStatistics} instance to copy\n-     */\n-    public SummaryStatistics(SummaryStatistics original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public SummaryStatistics(SummaryStatistics original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n      * </p>\n      * @param sumImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the Sum\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n >0)\n+     * @since 1.2\n+     */\n+    public void setSumImpl(StorelessUnivariateStatistic sumImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.sumImpl = sumImpl;\n     }\n      * </p>\n      * @param sumsqImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the sum of squares\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n > 0)\n+     * @since 1.2\n+     */\n+    public void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.sumsqImpl = sumsqImpl;\n     }\n      * </p>\n      * @param minImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the minimum\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setMinImpl(StorelessUnivariateStatistic minImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n > 0)\n+     * @since 1.2\n+     */\n+    public void setMinImpl(StorelessUnivariateStatistic minImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.minImpl = minImpl;\n     }\n      * </p>\n      * @param maxImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the maximum\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n > 0)\n+     * @since 1.2\n+     */\n+    public void setMaxImpl(StorelessUnivariateStatistic maxImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.maxImpl = maxImpl;\n     }\n      * </p>\n      * @param sumLogImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the log sum\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n > 0)\n+     * @since 1.2\n+     */\n+    public void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.sumLogImpl = sumLogImpl;\n         geoMean.setSumLogImpl(sumLogImpl);\n      * </p>\n      * @param geoMeanImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the geometric mean\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n > 0)\n+     * @since 1.2\n+     */\n+    public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.geoMeanImpl = geoMeanImpl;\n     }\n      * </p>\n      * @param meanImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the mean\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n > 0)\n+     * @since 1.2\n+     */\n+    public void setMeanImpl(StorelessUnivariateStatistic meanImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.meanImpl = meanImpl;\n     }\n      * </p>\n      * @param varianceImpl the StorelessUnivariateStatistic instance to use for\n      *        computing the variance\n-     * @throws IllegalStateException if data has already been added (i.e if n >\n-     *         0)\n-     * @since 1.2\n-     */\n-    public void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n+     * @throws MathIllegalStateException if data has already been added (i.e if n > 0)\n+     * @since 1.2\n+     */\n+    public void setVarianceImpl(StorelessUnivariateStatistic varianceImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.varianceImpl = varianceImpl;\n     }\n \n     /**\n      * Throws IllegalStateException if n > 0.\n-     */\n-    private void checkEmpty() {\n+     * @throws MathIllegalStateException if data has been added\n+     */\n+    private void checkEmpty() throws MathIllegalStateException {\n         if (n > 0) {\n             throw new MathIllegalStateException(\n                 LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC, n);\n      */\n     public SummaryStatistics copy() {\n         SummaryStatistics result = new SummaryStatistics();\n+        // No try-catch or advertised exception because arguments are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedDescriptiveStatistics.java\n  */\n package org.apache.commons.math3.stat.descriptive;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.util.MathUtils;\n \n      * Construct an instance with infinite window\n      */\n     public SynchronizedDescriptiveStatistics() {\n+        // no try-catch or advertized IAE because arg is valid\n         this(INFINITE_WINDOW);\n     }\n \n     /**\n      * Construct an instance with finite window\n      * @param window the finite window size.\n+     * @throws MathIllegalArgumentException if window size is less than 1 but\n+     * not equal to {@link #INFINITE_WINDOW}\n      */\n-    public SynchronizedDescriptiveStatistics(int window) {\n+    public SynchronizedDescriptiveStatistics(int window) throws MathIllegalArgumentException {\n         super(window);\n     }\n \n      * A copy constructor. Creates a deep-copy of the {@code original}.\n      *\n      * @param original the {@code SynchronizedDescriptiveStatistics} instance to copy\n+     * @throws NullArgumentException if original is null\n      */\n-    public SynchronizedDescriptiveStatistics(SynchronizedDescriptiveStatistics original) {\n+    public SynchronizedDescriptiveStatistics(SynchronizedDescriptiveStatistics original)\n+    throws NullArgumentException {\n         copy(original, this);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setWindowSize(int windowSize) {\n+    public synchronized void setWindowSize(int windowSize) throws MathIllegalArgumentException {\n         super.setWindowSize(windowSize);\n     }\n \n     public synchronized SynchronizedDescriptiveStatistics copy() {\n         SynchronizedDescriptiveStatistics result =\n             new SynchronizedDescriptiveStatistics();\n+        // No try-catch or advertised exception because arguments are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n  */\n package org.apache.commons.math3.stat.descriptive;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.linear.RealMatrix;\n \n /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void addValue(double[] value) {\n+    public synchronized void addValue(double[] value) throws DimensionMismatchException {\n       super.addValue(value);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl) {\n+    public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n+    throws DimensionMismatchException, MathIllegalStateException {\n         super.setSumImpl(sumImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl) {\n+    public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n+    throws DimensionMismatchException, MathIllegalStateException {\n         super.setSumsqImpl(sumsqImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl) {\n+    public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n+    throws DimensionMismatchException, MathIllegalStateException {\n         super.setMinImpl(minImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl) {\n+    public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n+    throws DimensionMismatchException, MathIllegalStateException{\n         super.setMaxImpl(maxImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl) {\n+    public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n+    throws DimensionMismatchException, MathIllegalStateException {\n         super.setSumLogImpl(sumLogImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl) {\n+    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n+    throws DimensionMismatchException, MathIllegalStateException {\n         super.setGeoMeanImpl(geoMeanImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl) {\n+    public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n+    throws DimensionMismatchException, MathIllegalStateException {\n         super.setMeanImpl(meanImpl);\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/SynchronizedSummaryStatistics.java\n  */\n package org.apache.commons.math3.stat.descriptive;\n \n+import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.util.MathUtils;\n \n      * A copy constructor. Creates a deep-copy of the {@code original}.\n      *\n      * @param original the {@code SynchronizedSummaryStatistics} instance to copy\n-     */\n-    public SynchronizedSummaryStatistics(SynchronizedSummaryStatistics original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public SynchronizedSummaryStatistics(SynchronizedSummaryStatistics original)\n+    throws NullArgumentException {\n         copy(original, this);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n+    public synchronized void setSumImpl(StorelessUnivariateStatistic sumImpl)\n+    throws MathIllegalStateException {\n         super.setSumImpl(sumImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl) {\n+    public synchronized void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl)\n+    throws MathIllegalStateException {\n         super.setSumsqImpl(sumsqImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMinImpl(StorelessUnivariateStatistic minImpl) {\n+    public synchronized void setMinImpl(StorelessUnivariateStatistic minImpl)\n+    throws MathIllegalStateException {\n         super.setMinImpl(minImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n+    public synchronized void setMaxImpl(StorelessUnivariateStatistic maxImpl)\n+    throws MathIllegalStateException {\n         super.setMaxImpl(maxImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl) {\n+    public synchronized void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl)\n+    throws MathIllegalStateException {\n         super.setSumLogImpl(sumLogImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n+    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl)\n+    throws MathIllegalStateException {\n         super.setGeoMeanImpl(geoMeanImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n+    public synchronized void setMeanImpl(StorelessUnivariateStatistic meanImpl)\n+    throws MathIllegalStateException {\n         super.setMeanImpl(meanImpl);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public synchronized void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n+    public synchronized void setVarianceImpl(StorelessUnivariateStatistic varianceImpl)\n+    throws MathIllegalStateException {\n         super.setVarianceImpl(varianceImpl);\n     }\n \n     public synchronized SynchronizedSummaryStatistics copy() {\n         SynchronizedSummaryStatistics result =\n             new SynchronizedSummaryStatistics();\n+        // No try-catch or advertised exception because arguments are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/UnivariateStatistic.java\n  */\n package org.apache.commons.math3.stat.descriptive;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+\n \n /**\n  * Base interface implemented by all statistics.\n      *\n      * @param values input array\n      * @return the value of the statistic applied to the input array\n+     * @throws MathIllegalArgumentException  if values is null\n      */\n-    double evaluate(double[] values);\n+    double evaluate(double[] values) throws MathIllegalArgumentException;\n \n     /**\n      * Returns the result of evaluating the statistic over the specified entries\n      * @param begin the index of the first element to include\n      * @param length the number of elements to include\n      * @return the value of the statistic applied to the included array entries\n+     * @throws MathIllegalArgumentException if values is null or the indices are invalid\n      */\n-    double evaluate(double[] values, int begin, int length);\n+    double evaluate(double[] values, int begin, int length) throws MathIllegalArgumentException;\n \n     /**\n      * Returns a copy of the statistic with the same internal state.\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/WeightedEvaluation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/WeightedEvaluation.java\n  */\n package org.apache.commons.math3.stat.descriptive;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+\n /**\n  * Weighted evaluation for statistics.\n  *\n      * @param values input array\n      * @param weights array of weights\n      * @return the value of the weighted statistic applied to the input array\n+     * @throws MathIllegalArgumentException if either array is null, lengths\n+     * do not match, weights contain NaN, negative or infinite values, or\n+     * weights does not include at least on positive value\n      */\n-    double evaluate(double[] values, double[] weights);\n+    double evaluate(double[] values, double[] weights) throws MathIllegalArgumentException;\n \n     /**\n      * Returns the result of evaluating the statistic over the specified entries\n      * @param begin the index of the first element to include\n      * @param length the number of elements to include\n      * @return the value of the weighted statistic applied to the included array entries\n+     * @throws MathIllegalArgumentException if either array is null, lengths\n+     * do not match, indices are invalid, weights contain NaN, negative or\n+     * infinite values, or weights does not include at least on positive value\n      */\n-    double evaluate(double[] values, double[] weights, int begin, int length);\n+    double evaluate(double[] values, double[] weights, int begin, int length)\n+    throws MathIllegalArgumentException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/FirstMoment.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/FirstMoment.java\n      * to the {@code original}\n      *\n      * @param original the {@code FirstMoment} instance to copy\n+     * @throws NullArgumentException if original is null\n      */\n-     public FirstMoment(FirstMoment original) {\n+     public FirstMoment(FirstMoment original) throws NullArgumentException {\n          super();\n          copy(original, this);\n      }\n     @Override\n     public FirstMoment copy() {\n         FirstMoment result = new FirstMoment();\n+        // No try-catch or advertised exception because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/FourthMoment.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/FourthMoment.java\n      * to the {@code original}\n      *\n      * @param original the {@code FourthMoment} instance to copy\n+     * @throws NullArgumentException if original is null\n      */\n-     public FourthMoment(FourthMoment original) {\n+     public FourthMoment(FourthMoment original) throws NullArgumentException {\n          super();\n          copy(original, this);\n      }\n     @Override\n     public FourthMoment copy() {\n         FourthMoment result = new FourthMoment();\n+        // No try-catch or advertised exception because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/GeometricMean.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/GeometricMean.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n      * to the {@code original}\n      *\n      * @param original the {@code GeometricMean} instance to copy\n-     */\n-    public GeometricMean(GeometricMean original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public GeometricMean(GeometricMean original) throws NullArgumentException {\n         super();\n         copy(original, this);\n     }\n     @Override\n     public GeometricMean copy() {\n         GeometricMean result = new GeometricMean();\n+        // no try-catch or advertised exception because args guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n      * @param length the number of elements to include\n      * @return the geometric mean or Double.NaN if length = 0 or\n      * any of the values are &lt;= 0.\n-     * @throws IllegalArgumentException if the input array is null or the array\n+     * @throws MathIllegalArgumentException if the input array is null or the array\n      * index parameters are not valid\n      */\n     @Override\n     public double evaluate(\n-        final double[] values, final int begin, final int length) {\n+        final double[] values, final int begin, final int length)\n+    throws MathIllegalArgumentException {\n         return FastMath.exp(\n             sumOfLogs.evaluate(values, begin, length) / length);\n     }\n      *\n      * @param sumLogImpl the StorelessUnivariateStatistic instance to use\n      * for computing the log sum\n-     * @throws IllegalStateException if data has already been added\n+     * @throws MathIllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n-    public void setSumLogImpl(\n-            StorelessUnivariateStatistic sumLogImpl) {\n+    public void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl)\n+    throws MathIllegalStateException {\n         checkEmpty();\n         this.sumOfLogs = sumLogImpl;\n     }\n \n \n     /**\n-     * Throws IllegalStateException if n > 0.\n-     */\n-    private void checkEmpty() {\n+     * Throws MathIllegalStateException if n > 0.\n+     * @throws MathIllegalStateException if data has been added to this statistic\n+     */\n+    private void checkEmpty() throws MathIllegalStateException {\n         if (getN() > 0) {\n             throw new MathIllegalStateException(\n                     LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC,\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Kurtosis.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Kurtosis.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathUtils;\n      * to the {@code original}\n      *\n      * @param original the {@code Kurtosis} instance to copy\n-     */\n-    public Kurtosis(Kurtosis original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public Kurtosis(Kurtosis original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n     /**\n      * {@inheritDoc}\n+     * <p>Note that when {@link #Kurtosis(FourthMoment)} is used to\n+     * create a Variance, this method does nothing. In that case, the\n+     * FourthMoment should be incremented directly.</p>\n      */\n     @Override\n     public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n-        }  else  {\n-            throw new MathIllegalStateException(LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS);\n         }\n     }\n \n     public void clear() {\n         if (incMoment) {\n             moment.clear();\n-        } else  {\n-            throw new MathIllegalStateException(LocalizedFormats.CANNOT_CLEAR_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS);\n         }\n     }\n \n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the kurtosis of the values or Double.NaN if length is less than\n-     * 4\n-     * @throws IllegalArgumentException if the input array is null or the array\n+     * @return the kurtosis of the values or Double.NaN if length is less than 4\n+     * @throws MathIllegalArgumentException if the input array is null or the array\n      * index parameters are not valid\n      */\n     @Override\n-    public double evaluate(final double[] values,final int begin, final int length) {\n+    public double evaluate(final double[] values,final int begin, final int length)\n+    throws MathIllegalArgumentException {\n         // Initialize the kurtosis\n         double kurt = Double.NaN;\n \n     @Override\n     public Kurtosis copy() {\n         Kurtosis result = new Kurtosis();\n+        // No try-catch because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Mean.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Mean.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math3.stat.descriptive.WeightedEvaluation;\n      * to the {@code original}\n      *\n      * @param original the {@code Mean} instance to copy\n-     */\n-    public Mean(Mean original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public Mean(Mean original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n     /**\n      * {@inheritDoc}\n+     * <p>Note that when {@link #Mean(FirstMoment)} is used to\n+     * create a Mean, this method does nothing. In that case, the\n+     * FirstMoment should be incremented directly.</p>\n      */\n     @Override\n     public void increment(final double d) {\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the mean of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n-    public double evaluate(final double[] values,final int begin, final int length) {\n+    public double evaluate(final double[] values,final int begin, final int length)\n+    throws MathIllegalArgumentException {\n         if (test(values, begin, length)) {\n             Sum sum = new Sum();\n             double sampleSize = length;\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the mean of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the parameters are not valid\n+     * @throws MathIllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n-                           final int begin, final int length) {\n+                           final int begin, final int length) throws MathIllegalArgumentException {\n         if (test(values, weights, begin, length)) {\n             Sum sum = new Sum();\n \n     /**\n      * Returns the weighted arithmetic mean of the entries in the input array.\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if either array is null.</p>\n      * <p>\n      * See {@link Mean} for details on the computing algorithm. The two-pass algorithm\n      * described above is used here, with weights applied in computing both the original\n      * estimate and the correction factor.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * Throws <code>MathIllegalArgumentException</code> if any of the following are true:\n      * <ul><li>the values array is null</li>\n      *     <li>the weights array is null</li>\n      *     <li>the weights array does not have the same length as the values array</li>\n      * @param values the input array\n      * @param weights the weights array\n      * @return the mean of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the parameters are not valid\n+     * @throws MathIllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n-    public double evaluate(final double[] values, final double[] weights) {\n+    public double evaluate(final double[] values, final double[] weights)\n+    throws MathIllegalArgumentException {\n         return evaluate(values, weights, 0, values.length);\n     }\n \n     @Override\n     public Mean copy() {\n         Mean result = new Mean();\n+        // No try-catch or advertised exception because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/SecondMoment.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/SecondMoment.java\n      * to the {@code original}\n      *\n      * @param original the {@code SecondMoment} instance to copy\n+     * @throws NullArgumentException if original is null\n      */\n-    public SecondMoment(SecondMoment original) {\n+    public SecondMoment(SecondMoment original)\n+    throws NullArgumentException {\n         super(original);\n         this.m2 = original.m2;\n     }\n     @Override\n     public SecondMoment copy() {\n         SecondMoment result = new SecondMoment();\n+        // no try-catch or advertised NAE because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/SemiVariance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/SemiVariance.java\n package org.apache.commons.math3.stat.descriptive.moment;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.stat.descriptive.AbstractUnivariateStatistic;\n import org.apache.commons.math3.util.MathUtils;\n \n      * to the {@code original}\n      *\n      * @param original the {@code SemiVariance} instance to copy\n-     */\n-    public SemiVariance(final SemiVariance original) {\n+     * @throws NullArgumentException  if original is null\n+     */\n+    public SemiVariance(final SemiVariance original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n     @Override\n     public SemiVariance copy() {\n         SemiVariance result = new SemiVariance();\n+        // No try-catch or advertised exception because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n         dest.varianceDirection = source.varianceDirection;\n     }\n \n-\n-    /**\n-     * This method calculates {@link SemiVariance} for the entire array against the mean, using\n-     * instance properties varianceDirection and biasCorrection.\n-     *\n-     * @param values the input array\n-     * @return the SemiVariance\n-     * @throws IllegalArgumentException if values is null\n-     *\n-     */\n-    @Override\n-    public double evaluate(final double[] values) {\n-        if (values == null) {\n-            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n-         }\n-        return evaluate(values, 0, values.length);\n-    }\n-\n-\n     /**\n       * <p>Returns the {@link SemiVariance} of the designated values against the mean, using\n       * instance properties varianceDirection and biasCorrection.</p>\n       * @param start index of the first array element to include\n       * @param length the number of elements to include\n       * @return the SemiVariance\n-      * @throws IllegalArgumentException if the parameters are not valid\n+      * @throws MathIllegalArgumentException if the parameters are not valid\n       *\n       */\n       @Override\n-      public double evaluate(final double[] values, final int start, final int length) {\n+      public double evaluate(final double[] values, final int start, final int length)\n+      throws MathIllegalArgumentException {\n         double m = (new Mean()).evaluate(values, start, length);\n         return evaluate(values, m, varianceDirection, biasCorrected, 0, values.length);\n       }\n        * @param values the input array\n        * @param direction the {@link Direction} of the semivariance\n        * @return the SemiVariance\n-       * @throws IllegalArgumentException if values is null\n+       * @throws MathIllegalArgumentException if values is null\n        *\n        */\n-      public double evaluate(final double[] values, Direction direction) {\n+      public double evaluate(final double[] values, Direction direction)\n+      throws MathIllegalArgumentException {\n           double m = (new Mean()).evaluate(values);\n           return evaluate (values, m, direction, biasCorrected, 0, values.length);\n       }\n       * @param start index of the first array element to include\n       * @param length the number of elements to include\n       * @return the SemiVariance\n-      * @throws IllegalArgumentException if the parameters are not valid\n+      * @throws MathIllegalArgumentException if the parameters are not valid\n       *\n       */\n     public double evaluate (final double[] values, final double cutoff, final Direction direction,\n-            final boolean corrected, final int start, final int length) {\n+            final boolean corrected, final int start, final int length) throws MathIllegalArgumentException {\n \n         test(values, start, length);\n         if (values.length == 0) {\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Skewness.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Skewness.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math3.util.FastMath;\n      * to the {@code original}\n      *\n      * @param original the {@code Skewness} instance to copy\n-     */\n-    public Skewness(Skewness original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public Skewness(Skewness original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n     /**\n      * {@inheritDoc}\n+     * <p>Note that when {@link #Skewness(ThirdMoment)} is used to\n+     * create a Skewness, this method does nothing. In that case, the\n+     * ThirdMoment should be incremented directly.</p>\n      */\n     @Override\n     public void increment(final double d) {\n      * @param length the number of elements to include\n      * @return the skewness of the values or Double.NaN if length is less than\n      * 3\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values,final int begin,\n-            final int length) {\n+            final int length) throws MathIllegalArgumentException {\n \n         // Initialize the skewness\n         double skew = Double.NaN;\n     @Override\n     public Skewness copy() {\n         Skewness result = new Skewness();\n+        // No try-catch or advertised exception because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/StandardDeviation.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math3.util.FastMath;\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * <p>\n-     * Does not change the internal state of the statistic.</p>\n-     *\n-     * @param values the input array\n-     * @return the standard deviation of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    @Override\n-    public double evaluate(final double[] values)  {\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     *\n+     * @param values the input array\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    @Override\n+    public double evaluate(final double[] values) throws MathIllegalArgumentException  {\n         return FastMath.sqrt(variance.evaluate(values));\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample. </p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      *\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the standard deviation of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n-    public double evaluate(final double[] values, final int begin, final int length)  {\n+    public double evaluate(final double[] values, final int begin, final int length)\n+    throws MathIllegalArgumentException  {\n        return FastMath.sqrt(variance.evaluate(values, begin, length));\n     }\n \n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the standard deviation of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     public double evaluate(final double[] values, final double mean,\n-            final int begin, final int length)  {\n+            final int begin, final int length) throws MathIllegalArgumentException  {\n         return FastMath.sqrt(variance.evaluate(values, mean, begin, length));\n     }\n \n      * is supplied only to save computation when the mean has already been\n      * computed.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @return the standard deviation of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public double evaluate(final double[] values, final double mean)  {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values, final double mean)\n+    throws MathIllegalArgumentException  {\n         return FastMath.sqrt(variance.evaluate(values, mean));\n     }\n \n     @Override\n     public StandardDeviation copy() {\n         StandardDeviation result = new StandardDeviation();\n+        // No try-catch or advertised exception because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/ThirdMoment.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/ThirdMoment.java\n      * to the {@code original}\n      *\n      * @param original the {@code ThirdMoment} instance to copy\n+     * @throws NullArgumentException if orginal is null\n      */\n-    public ThirdMoment(ThirdMoment original) {\n+    public ThirdMoment(ThirdMoment original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n     @Override\n     public ThirdMoment copy() {\n         ThirdMoment result = new ThirdMoment();\n+        // No try-catch or advertised exception because args are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/Variance.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.stat.descriptive.WeightedEvaluation;\n      * to the {@code original}\n      *\n      * @param original the {@code Variance} instance to copy\n-     */\n-    public Variance(Variance original) {\n+     * @throws NullArgumentException if original is null\n+     */\n+    public Variance(Variance original) throws NullArgumentException {\n         copy(original, this);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      *\n      * @param values the input array\n      * @return the variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null\n+     * @throws MathIllegalArgumentException if the array is null\n      */\n     @Override\n-    public double evaluate(final double[] values) {\n+    public double evaluate(final double[] values) throws MathIllegalArgumentException {\n         if (values == null) {\n             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n         }\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n-    public double evaluate(final double[] values, final int begin, final int length) {\n+    public double evaluate(final double[] values, final int begin, final int length)\n+    throws MathIllegalArgumentException {\n \n         double var = Double.NaN;\n \n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if either array is null.</p>\n      *\n      * @param values the input array\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the weighted variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the parameters are not valid\n+     * @throws MathIllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n-                           final int begin, final int length) {\n+                           final int begin, final int length) throws MathIllegalArgumentException {\n \n         double var = Double.NaN;\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * Throws <code>MathIllegalArgumentException</code> if any of the following are true:\n      * <ul><li>the values array is null</li>\n      *     <li>the weights array is null</li>\n      *     <li>the weights array does not have the same length as the values array</li>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if either array is null.</p>\n      *\n      * @param values the input array\n      * @param weights the weights array\n      * @return the weighted variance of the values\n-     * @throws IllegalArgumentException if the parameters are not valid\n+     * @throws MathIllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n-    public double evaluate(final double[] values, final double[] weights) {\n+    public double evaluate(final double[] values, final double[] weights)\n+    throws MathIllegalArgumentException {\n         return evaluate(values, weights, 0, values.length);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      *\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the array is null or the array index\n+     * @throws MathIllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     public double evaluate(final double[] values, final double mean,\n-            final int begin, final int length) {\n+            final int begin, final int length) throws MathIllegalArgumentException {\n \n         double var = Double.NaN;\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n      *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @return the variance of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public double evaluate(final double[] values, final double mean) {\n+     * @throws MathIllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values, final double mean) throws MathIllegalArgumentException {\n         return evaluate(values, mean, 0, values.length);\n     }\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * Throws <code>MathIllegalArgumentException</code> if any of the following are true:\n      * <ul><li>the values array is null</li>\n      *     <li>the weights array is null</li>\n      *     <li>the weights array does not have the same length as the values array</li>\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @return the variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the parameters are not valid\n+     * @throws MathIllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n-                           final double mean, final int begin, final int length) {\n+    final double mean, final int begin, final int length)\n+    throws MathIllegalArgumentException {\n \n         double var = Double.NaN;\n \n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n-     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * Throws <code>MathIllegalArgumentException</code> if any of the following are true:\n      * <ul><li>the values array is null</li>\n      *     <li>the weights array is null</li>\n      *     <li>the weights array does not have the same length as the values array</li>\n      * @param weights the weights array\n      * @param mean the precomputed weighted mean value\n      * @return the variance of the values or Double.NaN if length = 0\n-     * @throws IllegalArgumentException if the parameters are not valid\n+     * @throws MathIllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n-    public double evaluate(final double[] values, final double[] weights, final double mean) {\n+    public double evaluate(final double[] values, final double[] weights, final double mean)\n+    throws MathIllegalArgumentException {\n         return evaluate(values, weights, mean, 0, values.length);\n     }\n \n     @Override\n     public Variance copy() {\n         Variance result = new Variance();\n+        // No try-catch or advertised exception because parameters are guaranteed non-null\n         copy(this, result);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/moment/VectorialMean.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/moment/VectorialMean.java\n      * @param v vector to add\n      * @throws DimensionMismatchException if the vector does not have the right dimension\n      */\n-    public void increment(double[] v) {\n+    public void increment(double[] v) throws DimensionMismatchException {\n         if (v.length != means.length) {\n             throw new DimensionMismatchException(v.length, means.length);\n         }", "timestamp": 1347125267, "metainfo": ""}