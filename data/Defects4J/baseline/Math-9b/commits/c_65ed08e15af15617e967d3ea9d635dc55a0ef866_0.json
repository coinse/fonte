{"sha": "65ed08e15af15617e967d3ea9d635dc55a0ef866", "log": "Introduced tests to guard against overflow (MATH-722). Corrected Javadoc and updated unit tests accordingly.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n      *  </code>\n      * </pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n+     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n+     * {@link FastMath#sinh}.\n      * <br/>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is {@code NaN}.\n      * <pre>\n      *  Examples:\n      *  <code>\n-     *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\n-     *   tan(&plusmn;INFINITY + i) = NaN + NaN i\n+     *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n+     *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n      *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n      *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n      *  </code>\n      * @since 1.2\n      */\n     public Complex tan() {\n-        if (isNaN) {\n-            return NaN;\n+        if (isNaN || Double.isInfinite(real)) {\n+            return NaN;\n+        }\n+        if (imaginary > 20.0) {\n+            return createComplex(0.0, 1.0);\n+        }\n+        if (imaginary < -20.0) {\n+            return createComplex(0.0, -1.0);\n         }\n \n         double real2 = 2.0 * real;\n      *  </code>\n      * </pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n+     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n+     * {@link FastMath#sinh}.\n      * <br/>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is {@code NaN}.\n      * <pre>\n      *  Examples:\n      *  <code>\n-     *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     *   tanh(&plusmn;INFINITY + i) = NaN + 0 i\n+     *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n+     *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n      *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n      *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n      *  </code>\n      * @since 1.2\n      */\n     public Complex tanh() {\n-        if (isNaN) {\n-            return NaN;\n-        }\n-\n+        if (isNaN || Double.isInfinite(imaginary)) {\n+            return NaN;\n+        }\n+        if (real > 20.0) {\n+            return createComplex(1.0, 0.0);\n+        }\n+        if (real < -20.0) {\n+            return createComplex(-1.0, 0.0);\n+        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-0.000187346, 0.999356);\n         TestUtils.assertEquals(expected, z.tan(), 1.0e-5);\n+        /* Check that no overflow occurs (MATH-722) */\n+        Complex actual = new Complex(3.0, 1E10).tan();\n+        expected = new Complex(0, 1);\n+        TestUtils.assertEquals(expected, actual, 1.0e-5);\n+        actual = new Complex(3.0, -1E10).tan();\n+        expected = new Complex(0, -1);\n+        TestUtils.assertEquals(expected, actual, 1.0e-5);\n     }\n \n     @Test\n \n     @Test\n     public void testTanInf() {\n-        TestUtils.assertSame(zeroNaN, oneInf.tan());\n-        TestUtils.assertSame(zeroNaN, oneNegInf.tan());\n+        TestUtils.assertSame(Complex.valueOf(0.0, 1.0), oneInf.tan());\n+        TestUtils.assertSame(Complex.valueOf(0.0, -1.0), oneNegInf.tan());\n         TestUtils.assertSame(Complex.NaN, infOne.tan());\n         TestUtils.assertSame(Complex.NaN, negInfOne.tan());\n         TestUtils.assertSame(Complex.NaN, infInf.tan());\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.00071, 0.00490826);\n         TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);\n+        /* Check that no overflow occurs (MATH-722) */\n+        Complex actual = new Complex(1E10, 3.0).tanh();\n+        expected = new Complex(1, 0);\n+        TestUtils.assertEquals(expected, actual, 1.0e-5);\n+        actual = new Complex(-1E10, 3.0).tanh();\n+        expected = new Complex(-1, 0);\n+        TestUtils.assertEquals(expected, actual, 1.0e-5);\n     }\n \n     @Test\n     public void testTanhInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.tanh());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());\n-        TestUtils.assertSame(nanZero, infOne.tanh());\n-        TestUtils.assertSame(nanZero, negInfOne.tanh());\n+        TestUtils.assertSame(Complex.valueOf(1.0, 0.0), infOne.tanh());\n+        TestUtils.assertSame(Complex.valueOf(-1.0, 0.0), negInfOne.tanh());\n         TestUtils.assertSame(Complex.NaN, infInf.tanh());\n         TestUtils.assertSame(Complex.NaN, infNegInf.tanh());\n         TestUtils.assertSame(Complex.NaN, negInfInf.tanh());", "timestamp": 1327647619, "metainfo": ""}