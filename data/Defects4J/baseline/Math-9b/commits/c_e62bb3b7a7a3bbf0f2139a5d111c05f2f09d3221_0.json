{"sha": "e62bb3b7a7a3bbf0f2139a5d111c05f2f09d3221", "log": "changed SVD to compute either compact SVD (using only positive singular values) or truncated SVD (using only singular values up to a user-specified max number) started fix of SVD solver that did not compute a least square solution the fix is not complete yet as it seems the solution does not really gives the smallest possible residuals. See for example the commented out parts of testMath320A in SingularValueSolverTest. JIRA: MATH-320  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n  * Singular Value Decomposition of a real matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p is n,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n  * <p>This interface is similar to the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Calculates the Singular Value Decomposition of a matrix.\n+ * Calculates the compact or truncated Singular Value Decomposition of a matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p would be n, but this is not supported by this implementation,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Note that since this class computes only the compact or truncated SVD and not\n+ * the full SVD, the singular values computed are always positive.\n+ * </p>\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n     private RealMatrix cachedVt;\n \n     /**\n-     * Calculates the Singular Value Decomposition of the given matrix.\n+     * Calculates the compact Singular Value Decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n      * @exception InvalidMatrixException (wrapping a {@link\n      * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n      */\n-    public SingularValueDecompositionImpl(RealMatrix matrix)\n+    public SingularValueDecompositionImpl(final RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n+    }\n+\n+    /**\n+     * Calculates the Singular Value Decomposition of the given matrix.\n+     * @param matrix The matrix to decompose.\n+     * @param max maximal number of singular values to compute\n+     * @exception InvalidMatrixException (wrapping a {@link\n+     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n+     */\n+    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)\n         throws InvalidMatrixException {\n \n         m = matrix.getRowDimension();\n         eigenDecomposition =\n             new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                        MathUtils.SAFE_MIN);\n-        singularValues = eigenDecomposition.getRealEigenvalues();\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            singularValues[i] = (si < 0) ? 0.0 : Math.sqrt(si);\n+        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n+        int p = Math.min(max, eigenValues.length);\n+        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n+            --p;\n+        }\n+        singularValues = new double[p];\n+        for (int i = 0; i < p; ++i) {\n+            singularValues[i] = Math.sqrt(eigenValues[i]);\n         }\n \n     }\n \n         if (cachedU == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[m][];\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < n - 1; ++i) {\n-                    // compute B.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n+                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < n; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[n - 1];\n-                for (int j = 0; j < n; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n-                }\n-                for (int i = n; i < m; ++i) {\n-                    iData[i] = new double[n];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n+                }\n+                for (int i = p; i < m; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedU =\n-                    transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                cachedU = transformer.getU().multiply(e);\n             }\n \n         }\n \n         if (cachedV == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n+                cachedV = transformer.getV().multiply(e);\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[n][];\n+                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < m - 1; ++i) {\n-                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < m; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[m - 1];\n-                for (int j = 0; j < m; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n-                }\n-                for (int i = m; i < n; ++i) {\n-                    iData[i] = new double[m];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n+                }\n+                for (int i = p; i < n; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedV =\n-                    transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n             }\n \n         }\n     public RealMatrix getCovariance(final double minSingularValue) {\n \n         // get the number of singular values to consider\n+        final int p = singularValues.length;\n         int dimension = 0;\n-        while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {\n+        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n             ++dimension;\n         }\n \n                   minSingularValue, singularValues[0]);\n         }\n \n-        final double[][] data = new double[dimension][n];\n+        final double[][] data = new double[dimension][p];\n         getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             /** {@inheritDoc} */\n             @Override\n             public void visit(final int row, final int column, final double value) {\n                 data[row][column] = value / singularValues[row];\n             }\n-        }, 0, dimension - 1, 0, n - 1);\n+        }, 0, dimension - 1, 0, p - 1);\n \n         RealMatrix jv = new Array2DRowRealMatrix(data, false);\n         return jv.transpose().multiply(jv);\n     /** {@inheritDoc} */\n     public DecompositionSolver getSolver() {\n         return new Solver(singularValues, getUT(), getV(),\n-                          getRank() == singularValues.length);\n+                          getRank() == Math.max(m, n));\n     }\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n \n-        /** Singular values. */\n-        private final double[] singularValues;\n-\n-        /** U<sup>T</sup> matrix of the decomposition. */\n-        private final RealMatrix uT;\n-\n-        /** V matrix of the decomposition. */\n-        private final RealMatrix v;\n+        /** Pseudo-inverse of the initial matrix. */\n+        private final RealMatrix pseudoInverse;\n \n         /** Singularity indicator. */\n         private boolean nonSingular;\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,\n                        final boolean nonSingular) {\n-            this.singularValues = singularValues;\n-            this.uT             = uT;\n-            this.v              = v;\n-            this.nonSingular    = nonSingular;\n+            double[][] suT      = uT.getData();\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double a      = 1.0 / singularValues[i];\n+                final double[] suTi = suT[i];\n+                for (int j = 0; j < suTi.length; ++j) {\n+                    suTi[j] *= a;\n+                }\n+            }\n+            pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));\n+            this.nonSingular = nonSingular;\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public double[] solve(final double[] b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.length != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                        b.length, uT.getColumnDimension());\n-            }\n-\n-            final double[] w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w[i] /= si;\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealVector solve(final RealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getDimension() != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                         b.getDimension(), uT.getColumnDimension());\n-            }\n-\n-            final RealVector w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w.setEntry(i, w.getEntry(i) / si);\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a matrix X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealMatrix solve(final RealMatrix b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getRowDimension() != singularValues.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        b.getRowDimension(), b.getColumnDimension(),\n-                        singularValues.length, \"n\");\n-            }\n-\n-            final RealMatrix w = uT.multiply(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si  = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                final double inv = 1.0 / si;\n-                for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                    w.multiplyEntry(i, j, inv);\n-                }\n-            }\n-            return v.multiply(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.multiply(b);\n         }\n \n         /**\n \n         /** Get the pseudo-inverse of the decomposed matrix.\n          * @return inverse matrix\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n-         */\n-        public RealMatrix getInverse()\n-            throws InvalidMatrixException {\n-\n-            if (!isNonSingular()) {\n-                throw new SingularMatrixException();\n-            }\n-\n-            return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n-\n+         */\n+        public RealMatrix getInverse() {\n+            return pseudoInverse;\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n \n package org.apache.commons.math.linear;\n \n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n-\n-import org.apache.commons.math.linear.DecompositionSolver;\n-import org.apache.commons.math.linear.InvalidMatrixException;\n-import org.apache.commons.math.linear.MatrixUtils;\n-import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.ArrayRealVector;\n-import org.apache.commons.math.linear.SingularValueDecompositionImpl;\n-\n-public class SingularValueSolverTest extends TestCase {\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SingularValueSolverTest {\n \n     private double[][] testSquare = {\n             { 24.0 / 25.0, 43.0 / 25.0 },\n \n     private static final double normTolerance = 10e-14;\n \n-    public SingularValueSolverTest(String name) {\n-        super(name);\n-    }\n-\n-    public static Test suite() {\n-        TestSuite suite = new TestSuite(SingularValueSolverTest.class);\n-        suite.setName(\"SingularValueSolver Tests\");\n-        return suite;\n-    }\n-\n     /** test solve dimension errors */\n+    @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n             new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n         try {\n             solver.solve(b);\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n         } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n+            Assert.fail(\"wrong exception caught\");\n         }\n         try {\n             solver.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n         } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n+            Assert.fail(\"wrong exception caught\");\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n-            fail(\"an exception should have been thrown\");\n+            Assert.fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n         } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve singularity errors */\n-    public void testSolveSingularityErrors() {\n+            Assert.fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test least square solve */\n+    @Test\n+    public void testLeastSquareSolve() {\n         RealMatrix m =\n             MatrixUtils.createRealMatrix(new double[][] {\n                                    { 1.0, 0.0 },\n                                    { 0.0, 0.0 }\n                                });\n         DecompositionSolver solver = new SingularValueDecompositionImpl(m).getSolver();\n-        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n-        try {\n-            solver.solve(b);\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumn(0));\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumnVector(0));\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+            { 11, 12 }, { 21, 22 } \n+        });\n+        RealMatrix xMatrix = solver.solve(b);\n+        Assert.assertEquals(11, xMatrix.getEntry(0, 0), 1.0e-15);\n+        Assert.assertEquals(12, xMatrix.getEntry(0, 1), 1.0e-15);\n+        Assert.assertEquals(0, xMatrix.getEntry(1, 0), 1.0e-15);\n+        Assert.assertEquals(0, xMatrix.getEntry(1, 1), 1.0e-15);\n+        double[] xCol = solver.solve(b.getColumn(0));\n+        Assert.assertEquals(11, xCol[0], 1.0e-15);\n+        Assert.assertEquals(0, xCol[1], 1.0e-15);\n+        RealVector xColVec = solver.solve(b.getColumnVector(0));\n+        Assert.assertEquals(11, xColVec.getEntry(0), 1.0e-15);\n+        Assert.assertEquals(0, xColVec.getEntry(1), 1.0e-15);\n+        RealVector xColOtherVec = solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n+        Assert.assertEquals(11, xColOtherVec.getEntry(0), 1.0e-15);\n+        Assert.assertEquals(0, xColOtherVec.getEntry(1), 1.0e-15);\n     }\n \n     /** test solve */\n+    @Test\n     public void testSolve() {\n         DecompositionSolver solver =\n             new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n         });\n \n         // using RealMatrix\n-        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);\n+        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          new ArrayRealVector(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n         // using Array2DRowRealMatrix\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             ArrayRealVectorTest.RealVectorTestImpl v =\n                 new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n+            Assert.assertEquals(0,\n                          solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n     }\n \n     /** test condition number */\n+    @Test\n     public void testConditionNumber() {\n         SingularValueDecompositionImpl svd =\n             new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n-        assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n+        Assert.assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testMath320A() {\n+        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n+            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n+        });\n+        double s439  = Math.sqrt(439.0);\n+        double[] reference = new double[] {\n+            Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\n+        };\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(rm);\n+        double[] singularValues = svd.getSingularValues();\n+        for (int i = 0; i < reference.length; ++i) {\n+            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n+        }\n+        regularElements(svd.getU());\n+        regularElements(svd.getVT());\n+//        double[] b = new double[] { 5.0, 6.0, 7.0 };\n+//        double[] resSVD = svd.getSolver().solve(b);\n+//        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n+//        System.out.println(\"resSVD = \" + resSVD[0] + \" \" + resSVD[1] + \" \" + resSVD[2]);\n+//        double minResidual = Double.POSITIVE_INFINITY;\n+//        double d0Min = Double.NaN;\n+//        double d1Min = Double.NaN;\n+//        double d2Min = Double.NaN;\n+//        double h = 0.01;\n+//        int    k = 100;\n+//        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n+//            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n+//                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n+//                    double[] f = rm.operate(new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 });\n+//                    double residual = Math.sqrt((f[0] - b[0]) * (f[0] - b[0]) +\n+//                                                (f[1] - b[1]) * (f[1] - b[1]) +\n+//                                                (f[2] - b[2]) * (f[2] - b[2]));\n+//                    if (residual < minResidual) {\n+//                        d0Min = d0;\n+//                        d1Min = d1;\n+//                        d2Min = d2;\n+//                        minResidual = residual;\n+//                    }\n+//                }\n+//            }\n+//        }\n+//        System.out.println(d0Min + \" \" + d1Min + \" \" + d2Min + \" -> \" + minResidual);\n+//        Assert.assertEquals(0, d0Min, 1.0e-15);\n+//        Assert.assertEquals(0, d1Min, 1.0e-15);\n+//        Assert.assertEquals(0, d2Min, 1.0e-15);\n+    }\n+\n+\n+    @Test\n+    public void testMath320B() {\n+        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n+            { 1.0, 2.0 }, { 1.0, 2.0 }\n+        });\n+        SingularValueDecomposition svd =\n+            new SingularValueDecompositionImpl(rm);\n+        regularElements(svd.getU());\n+        regularElements(svd.getVT());\n+    }\n+\n+    private void regularElements(RealMatrix m) {\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                double mij = m.getEntry(i, j);\n+                Assert.assertFalse(Double.isInfinite(mij));\n+                Assert.assertFalse(Double.isNaN(mij));\n+            }\n+        }\n     }\n \n }", "timestamp": 1262215021, "metainfo": ""}