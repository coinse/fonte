{"sha": "af3fffb74b6e2e35548a9519732077652fe89bb4", "log": "- In distribution.AbstractRealDistribution, removed superfluous methods getDomainLowerBound(double), getDomainUpperBound(double) and getInitialDomain(double p) (MATH-699). - Resolved checkstyle issues in the distribution package. - Improved Javadoc of RealDistribution.getSupportLowerBound(), RealDistribution.getSupportUpperBound() and AbstractRealDistribution.inverseCumulativeDistribution(double).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n     protected final RandomDataImpl randomData = new RandomDataImpl();\n \n     /** Default constructor. */\n-    protected AbstractIntegerDistribution() {}\n+    protected AbstractIntegerDistribution() { }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The default implementation uses the identity\n      * <p>{@code P(x0 <= X <= x1) = P(X <= x1) - P(X <= x0 - 1)}</p>\n      */\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The default implementation uses the\n      * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\">\n      * inversion method</a>.\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The default implementation generates the sample by calling\n      * {@link #sample()} in a loop.\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n  */\n public abstract class AbstractRealDistribution\n implements RealDistribution, Serializable {\n+    /** Default accuracy. */\n+    public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n \n-    /** Default accuracy. */\n-    public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n-\n     /** Solver absolute accuracy for inverse cumulative computation */\n     private double solverAbsoluteAccuracy = SOLVER_DEFAULT_ABSOLUTE_ACCURACY;\n \n     protected final RandomDataImpl randomData = new RandomDataImpl();\n \n     /** Default constructor. */\n-    protected AbstractRealDistribution() {}\n+    protected AbstractRealDistribution() { }\n \n     /**\n      * {@inheritDoc}\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n \n-    /** {@inheritDoc} */\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The default implementation returns\n+     * <ul>\n+     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n+     * <li>{@link #getSupportUpperBound()} for {@code p = 1}.</li>\n+     * </ul>\n+     */\n     public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        /*\n+         * IMPLEMENTATION NOTES\n+         * --------------------\n+         * Where applicable, use is made of the one-sided Chebyshev inequality\n+         * to bracket the root. This inequality states that\n+         * P(X - mu >= k * sig) <= 1 / (1 + k^2),\n+         * mu: mean, sig: standard deviation. Equivalently\n+         * 1 - P(X < mu + k * sig) <= 1 / (1 + k^2),\n+         * F(mu + k * sig) >= k^2 / (1 + k^2).\n+         *\n+         * For k = sqrt(p / (1 - p)), we find\n+         * F(mu + k * sig) >= p,\n+         * and (mu + k * sig) is an upper-bound for the root.\n+         *\n+         * Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and\n+         * P(Y >= -mu + k * sig) <= 1 / (1 + k^2),\n+         * P(-X >= -mu + k * sig) <= 1 / (1 + k^2),\n+         * P(X <= mu - k * sig) <= 1 / (1 + k^2),\n+         * F(mu - k * sig) <= 1 / (1 + k^2).\n+         *\n+         * For k = sqrt((1 - p) / p), we find\n+         * F(mu - k * sig) <= p,\n+         * and (mu - k * sig) is a lower-bound for the root.\n+         *\n+         * In cases where the Chebyshev inequality does not apply, geometric\n+         * progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket\n+         * the root.\n+         */\n         if (p < 0.0 || p > 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n         }\n     }\n \n     /**\n-     * Access the initial domain value, based on {@code p}, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p Desired probability for the critical value.\n-     * @return the initial domain value.\n-     * TODO to be deleted when applying MATH-699\n-     */\n-    protected abstract double getInitialDomain(double p);\n-\n-    /**\n-     * Access the domain value lower bound, based on {@code p}, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p Desired probability for the critical value.\n-     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n-     * TODO to be deleted when applying MATH-699\n-     */\n-    protected abstract double getDomainLowerBound(double p);\n-\n-    /**\n-     * Access the domain value upper bound, based on {@code p}, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     *\n-     * @param p Desired probability for the critical value.\n-     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n-     * TODO to be deleted when applying MATH-699\n-     */\n-    protected abstract double getDomainUpperBound(double p);\n-\n-    /**\n      * Returns the solver absolute accuracy for inverse cumulative computation.\n      * You can override this method in order to use a Brent solver with an\n      * absolute accuracy different from the default.\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The default implementation uses the\n      * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\">\n      * inversion method.\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The default implementation generates the sample by calling\n      * {@link #sample()} in a loop.\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n     }\n \n     /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        return p;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainLowerBound(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        return 1;\n-    }\n-\n-    /** {@inheritDoc} */\n     public double cumulativeProbability(double x)  {\n         if (x <= 0) {\n             return 0;\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n \n     /** {@inheritDoc} */\n     @Override\n-    protected double getDomainLowerBound(double p) {\n-        double ret;\n-\n-        if (p < 0.5) {\n-            ret = -Double.MAX_VALUE;\n-        } else {\n-            ret = median;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        double ret;\n-\n-        if (p < 0.5) {\n-            ret = median;\n-        } else {\n-            ret = Double.MAX_VALUE;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        double ret;\n-\n-        if (p < 0.5) {\n-            ret = median - scale;\n-        } else if (p > 0.5) {\n-            ret = median + scale;\n-        } else {\n-            ret = median;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n \n     /** {@inheritDoc} */\n     @Override\n-    protected double getDomainLowerBound(double p) {\n-        return Double.MIN_VALUE * gamma.getBeta();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        // NOTE: chi squared is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > .5\n-\n-        double ret;\n-\n-        if (p < .5) {\n-            // use mean\n-            ret = getDegreesOfFreedom();\n-        } else {\n-            // use max\n-            ret = Double.MAX_VALUE;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        // NOTE: chi squared is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > 0.5\n-\n-        double ret;\n-\n-        if (p < 0.5) {\n-            // use 1/2 mean\n-            ret = getDegreesOfFreedom() * 0.5;\n-        } else {\n-            // use mean\n-            ret = getDegreesOfFreedom();\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n      * @return {@inheritDoc}\n      */\n     public double getNumericalVariance() {\n-        return 2*getDegreesOfFreedom();\n+        return 2 * getDegreesOfFreedom();\n     }\n \n     /**\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n      * @since 2.1\n      */\n     public ExponentialDistribution(double mean, double inverseCumAccuracy)\n-        throws NotStrictlyPositiveException{\n+        throws NotStrictlyPositiveException {\n         if (mean <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n         }\n \n     /** {@inheritDoc} */\n     @Override\n-    protected double getDomainLowerBound(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        // NOTE: exponential is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > .5\n-\n-        if (p < 0.5) {\n-            // use mean\n-            return mean;\n-        } else {\n-            // use max\n-            return Double.MAX_VALUE;\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        // TODO: try to improve on this estimate\n-        // TODO: what should really happen here is not derive from\n-        // AbstractContinuousDistribution\n-        // TODO: because the inverse cumulative distribution is simple.\n-        // Exponential is skewed to the left, therefore, P(X < &mu;) > .5\n-        if (p < 0.5) {\n-            // use 1/2 mean\n-            return mean * 0.5;\n-        } else {\n-            // use mean\n-            return mean;\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n  * @version $Id$\n  */\n public class FDistribution extends AbstractRealDistribution {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -8516354193418641566L;\n-\n-    /**\n-     * Default inverse cumulative probability accuracy.\n-     * @since 2.1\n-     */\n-    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n \n     /** The numerator degrees of freedom. */\n     private final double numeratorDegreesOfFreedom;\n         return super.inverseCumulativeProbability(p);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainLowerBound(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        return Double.MAX_VALUE;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        double ret = 1;\n-        double d = denominatorDegreesOfFreedom;\n-        if (d > 2) {\n-            // use mean\n-            ret = d / (d - 2);\n-        }\n-        return ret;\n-    }\n-\n     /**\n      * Access the numerator degrees of freedom.\n      *\n \n     /**\n      * used by {@link #getNumericalVariance()}\n-     * \n+     *\n      * @return the variance of this distribution\n      */\n     protected double calculateNumericalVariance() {\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n \n     /** {@inheritDoc} */\n     @Override\n-    protected double getDomainLowerBound(double p) {\n-        // TODO: try to improve on this estimate\n-        return Double.MIN_VALUE;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        // TODO: try to improve on this estimate\n-        // NOTE: gamma is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > .5\n-\n-        double ret;\n-\n-        if (p < 0.5) {\n-            // use mean\n-            ret = alpha * beta;\n-        } else {\n-            // use max value\n-            ret = Double.MAX_VALUE;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        // TODO: try to improve on this estimate\n-        // Gamma is skewed to the left, therefore, P(X < &mu;) > .5\n-\n-        double ret;\n-\n-        if (p < 0.5) {\n-            // use 1/2 mean\n-            ret = alpha * beta * 0.5;\n-        } else {\n-            // use mean\n-            ret = alpha * beta;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double)(getSampleSize() * getNumberOfSuccesses()) / (double)getPopulationSize();\n+        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n \n     /**\n      * Used by {@link #getNumericalVariance()}.\n-     * \n+     *\n      * @return the variance of this distribution\n      */\n     protected double calculateNumericalVariance() {\n         final double N = getPopulationSize();\n         final double m = getNumberOfSuccesses();\n         final double n = getSampleSize();\n-        return ( n * m * (N - n) * (N - m) ) / ( (N*N * (N - 1)) );\n+        return ( n * m * (N - n) * (N - m) ) / ( (N * N * (N - 1)) );\n     }\n \n     /**\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n      * Use this method to get the numerical value of the variance of this\n      * distribution.\n      *\n-     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} as\n-     * for certain cases in {@link TDistributionImpl}) or\n-     * {@code Double.NaN} if it is not defined\n+     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} or\n+     * {@code Double.NaN} if it is not defined)\n      */\n     double getNumericalVariance();\n \n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n         double pFrac = Hpower.getEntry(k - 1, k - 1);\n \n         for (int i = 1; i <= n; ++i) {\n-            pFrac *= (double)i / (double)n;\n+            pFrac *= (double) i / (double) n;\n         }\n \n         return pFrac;\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n \n     /** {@inheritDoc} */\n     @Override\n-    protected double getDomainLowerBound(double p) {\n-        double ret;\n-\n-        if (p < 0.5) {\n-            ret = -Double.MAX_VALUE;\n-        } else {\n-            ret = mean;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        double ret;\n-\n-        if (p < 0.5) {\n-            ret = mean;\n-        } else {\n-            ret = Double.MAX_VALUE;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        double ret;\n-\n-        if (p < 0.5) {\n-            ret = mean - standardDeviation;\n-        } else if (p > 0.5) {\n-            ret = mean + standardDeviation;\n-        } else {\n-            ret = mean;\n-        }\n-\n-        return ret;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n         } else if (x == 0) {\n             ret = FastMath.exp(-mean);\n         } else {\n-            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x)\n-                  - SaddlePointExpansion.getDeviancePart(x, mean))\n-                  / FastMath.sqrt(MathUtils.TWO_PI * x);\n+            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) -\n+                  SaddlePointExpansion.getDeviancePart(x, mean)) /\n+                  FastMath.sqrt(MathUtils.TWO_PI * x);\n         }\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/RealDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/RealDistribution.java\n      * distribution.\n      *\n      * @return the variance (possibly {@code Double.POSITIVE_INFINITY} as\n-     * for certain cases in {@link TDistributionImpl}) or\n-     * {@code Double.NaN} if it is not defined\n+     * for certain cases in {@link TDistribution}) or {@code Double.NaN} if it\n+     * is not defined\n      */\n     double getNumericalVariance();\n \n     /**\n-     * Access the lower bound of the support.\n+     * Access the lower bound of the support. This method must return the same\n+     * value as {@code inverseCumulativeProbability(0)}. In other words, this\n+     * method must return\n+     * <p><code>inf {x in R | P(X <= x) > 0}</code>.</p>\n      *\n      * @return lower bound of the support (might be\n      * {@code Double.NEGATIVE_INFINITY})\n     double getSupportLowerBound();\n \n     /**\n-     * Access the upper bound of the support.\n+     * Access the upper bound of the support. This method must return the same\n+     * value as {@code inverseCumulativeProbability(1)}. In other words, this\n+     * method must return\n+     * <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>\n      *\n      * @return upper bound of the support (might be\n      * {@code Double.POSITIVE_INFINITY})\n--- a/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n     public double density(double x) {\n         final double n = degreesOfFreedom;\n         final double nPlus1Over2 = (n + 1) / 2;\n-        return FastMath.exp(Gamma.logGamma(nPlus1Over2)\n-                            - 0.5 * (FastMath.log(FastMath.PI)\n-                                     + FastMath.log(n))\n-                            - Gamma.logGamma(n/2)\n-                            - nPlus1Over2 * FastMath.log(1 + x * x /n));\n+        return FastMath.exp(Gamma.logGamma(nPlus1Over2) -\n+                            0.5 * (FastMath.log(FastMath.PI) +\n+                                   FastMath.log(n)) -\n+                            Gamma.logGamma(n / 2) -\n+                            nPlus1Over2 * FastMath.log(1 + x * x / n));\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     @Override\n-    protected double getDomainLowerBound(double p) {\n-        return -Double.MAX_VALUE;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        return Double.MAX_VALUE;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n  * @version $Id$\n  */\n public class WeibullDistribution extends AbstractRealDistribution {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 8589540077390120676L;\n-    \n-    /**\n-     * Default inverse cumulative probability accuracy.\n-     * @since 2.1\n-     */\n-    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-    \n+\n     /** The shape parameter. */\n     private final double shape;\n-    \n+\n     /** The scale parameter. */\n     private final double scale;\n-    \n+\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n         return ret;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainLowerBound(double p) {\n-        return 0;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getDomainUpperBound(double p) {\n-        return Double.MAX_VALUE;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected double getInitialDomain(double p) {\n-        // use median\n-        return FastMath.pow(scale * FastMath.log(2.0), 1.0 / shape);\n-    }\n-\n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n \n     /**\n      * used by {@link #getNumericalMean()}\n-     * \n+     *\n      * @return the mean of this distribution\n      */\n     protected double calculateNumericalMean() {\n \n     /**\n      * used by {@link #getNumericalVariance()}\n-     * \n+     *\n      * @return the variance of this distribution\n      */\n     protected double calculateNumericalVariance() {\n         final double sc = getScale();\n         final double mn = getNumericalMean();\n \n-        return (sc * sc) * FastMath.exp(Gamma.logGamma(1 + (2 / sh)))\n-               - (mn * mn);\n+        return (sc * sc) * FastMath.exp(Gamma.logGamma(1 + (2 / sh))) -\n+               (mn * mn);\n     }\n \n     /**\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n \n     /**\n      * Used by {@link #getNumericalMean()}.\n-     * \n+     *\n      * @return the mean of this distribution\n      */\n     protected double calculateNumericalMean() {\n \n     /**\n      * used by {@link #getNumericalVariance()}\n-     * \n+     *\n      * @return the variance of this distribution\n      */\n     protected double calculateNumericalVariance() {\n \n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The support of this distribution is connected.\n-     * \n+     *\n      * @return {@code true}\n      */\n     public boolean isSupportConnected() {\n--- a/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java\n                 return 0.0;\n             }\n \n-            @Override\n-            protected double getDomainLowerBound(final double p) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            protected double getDomainUpperBound(final double p) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            protected double getInitialDomain(final double p) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n             public double getNumericalMean() {\n                 return ((x0 + x1) * p12 + (x2 + x3) * (1.0 - p12)) / 2.0;\n             }\n                 }\n             }\n \n-            @Override\n-            protected double getDomainLowerBound(final double p) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            protected double getDomainUpperBound(final double p) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            protected double getInitialDomain(final double p) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n             public double getNumericalMean() {\n                 final UnivariateFunction f = new UnivariateFunction() {\n ", "timestamp": 1322936582, "metainfo": ""}