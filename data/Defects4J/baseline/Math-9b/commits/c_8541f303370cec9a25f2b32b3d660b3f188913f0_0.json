{"sha": "8541f303370cec9a25f2b32b3d660b3f188913f0", "log": "adapted old Levenberg-Marquardt estimator to new top level optimizers API  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/VectorialDifferentiableOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/VectorialDifferentiableOptimizer.java\n      * </p>\n      * @return number of evaluations of the objective function\n      */\n-   int getEvaluations();\n+    int getEvaluations();\n+\n+    /** Get the number of evaluations of the objective function jacobian .\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(ObjectiveFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function jacobian\n+     */\n+    int getJacobianEvaluations();\n \n     /** Set the convergence checker.\n      * @param checker object to use to check for convergence\n--- a/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n /**\n- * Base class for implementing estimators.\n- * <p>This base class handles the boilerplates methods associated to thresholds\n+ * Base class for implementing least squares optimizers.\n+ * <p>This base class handles the boilerplate methods associated to thresholds\n  * settings, jacobian and error estimation.</p>\n  * @version $Revision$ $Date$\n  * @since 1.2\n      * Jacobian matrix.\n      * <p>This matrix is in canonical form just after the calls to\n      * {@link #updateJacobian()}, but may be modified by the solver\n-     * in the derived class (the {@link LevenbergMarquardtEstimator\n-     * Levenberg-Marquardt estimator} does this).</p>\n+     * in the derived class (the {@link LevenbergMarquardtOptimizer\n+     * Levenberg-Marquardt optimizer} does this).</p>\n      */\n     protected double[][] jacobian;\n \n \n     /** Current objective function value. */\n     protected double[] objective;\n+\n+    /** Current residuals. */\n+    protected double[] residuals;\n \n     /** Cost value (square root of the sum of the residuals). */\n     protected double cost;\n     /** {@inheritDoc} */\n     public int getEvaluations() {\n         return objectiveEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getJacobianEvaluations() {\n+        return jacobianEvaluations;\n     }\n \n     /** {@inheritDoc} */\n         }\n         cost = 0;\n         for (int i = 0, index = 0; i < rows; i++, index += cols) {\n-            final double residual = objective[i] - target[i];\n+            final double residual = target[i] - objective[i];\n+            residuals[i] = residual;\n             cost += weights[i] * residual * residual;\n         }\n         cost = Math.sqrt(cost);\n      * Get the Root Mean Square value.\n      * Get the Root Mean Square value, i.e. the root of the arithmetic\n      * mean of the square of all weighted residuals. This is related to the\n-     * criterion that is minimized by the estimator as follows: if\n+     * criterion that is minimized by the optimizer as follows: if\n      * <em>c</em> if the criterion, and <em>n</em> is the number of\n      * measurements, then the RMS is <em>sqrt (c/n)</em>.\n      * \n     public double getRMS() {\n         double criterion = 0;\n         for (int i = 0; i < rows; ++i) {\n-            final double residual = objective[i] - target[i];\n+            final double residual = residuals[i];\n             criterion += weights[i] * residual * residual;\n         }\n         return Math.sqrt(criterion / rows);\n     public double getChiSquare() {\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n-            final double residual = objective[i] - target[i];\n+            final double residual = residuals[i];\n             chiSquare += residual * residual / weights[i];\n         }\n         return chiSquare;\n     }\n \n     /**\n-     * Get the covariance matrix of unbound estimated parameters.\n+     * Get the covariance matrix of optimized parameters.\n      * @return covariance matrix\n      * @exception ObjectiveException if the function jacobian cannot\n      * be evaluated\n         // compute transpose(J).J, avoiding building big intermediate matrices\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {\n-            final double[] ji = jacobian[i];\n             for (int j = i; j < cols; ++j) {\n-                final double[] jj = jacobian[j];\n                 double sum = 0;\n                 for (int k = 0; k < rows; ++k) {\n-                    sum += ji[k] * jj[k];\n+                    sum += jacobian[k][i] * jacobian[k][j];\n                 }\n                 jTj[i][j] = sum;\n                 jTj[j][i] = sum;\n     }\n \n     /**\n-     * Guess the errors in unbound estimated parameters.\n+     * Guess the errors in optimized parameters.\n      * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n-     * @return errors in estimated parameters\n+     * @return errors in optimized parameters\n      * @exception ObjectiveException if the function jacobian cannot b evaluated\n      * @exception OptimizationException if the covariances matrix cannot be computed\n      * or the number of degrees of freedom is not positive (number of measurements\n         this.target    = target;\n         this.weights   = weights;\n         this.variables = startPoint.clone();\n+        this.residuals = new double[target.length];\n \n         // arrays shared with the other private methods\n         rows      = target.length;\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.general;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.optimization.ObjectiveException;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+\n+/** \n+ * This class solves a least squares problem using the Levenberg-Marquardt algorithm.\n+ *\n+ * <p>This implementation <em>should</em> work even for over-determined systems\n+ * (i.e. systems having more variables than equations). Over-determined systems\n+ * are solved by ignoring the variables which have the smallest impact according\n+ * to their jacobian column norm. Only the rank of the matrix and some loop bounds\n+ * are changed to implement this.</p>\n+ *\n+ * <p>The resolution engine is a simple translation of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n+ * changes. The changes include the over-determined resolution and the Q.R.\n+ * decomposition which has been rewritten following the algorithm described in the\n+ * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle\n+ * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986. The\n+ * redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n+ * is reproduced below.</p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran)\n+ * @author Burton S. Garbow (original fortran)\n+ * @author Kenneth E. Hillstrom (original fortran)\n+ * @author Jorge J. More (original fortran)\n+\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8851282236194244323L;\n+\n+    /** Number of solved variables. */\n+    private int solvedCols;\n+\n+    /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n+    private double[] diagR;\n+\n+    /** Norms of the columns of the jacobian matrix. */\n+    private double[] jacNorm;\n+\n+    /** Coefficients of the Householder transforms vectors. */\n+    private double[] beta;\n+\n+    /** Columns permutation array. */\n+    private int[] permutation;\n+\n+    /** Rank of the jacobian matrix. */\n+    private int rank;\n+\n+    /** Levenberg-Marquardt parameter. */\n+    private double lmPar;\n+\n+    /** Parameters evolution direction associated with lmPar. */\n+    private double[] lmDir;\n+\n+    /** Positive input variable used in determining the initial step bound. */\n+    private double initialStepBoundFactor;\n+\n+    /** Desired relative error in the sum of squares. */\n+    private double costRelativeTolerance;\n+\n+    /**  Desired relative error in the approximate solution parameters. */\n+    private double parRelativeTolerance;\n+\n+    /** Desired max cosine on the orthogonality between the function vector\n+     * and the columns of the jacobian. */\n+    private double orthoTolerance;\n+\n+    /** \n+     * Build an optimizer for least squares problems.\n+     * <p>The default values for the algorithm settings are:\n+     *   <ul>\n+     *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n+     *    <li>{@link #setMaxCostEval maximal cost evaluations}: 1000</li>\n+     *    <li>{@link #setCostRelativeTolerance cost relative tolerance}: 1.0e-10</li>\n+     *    <li>{@link #setParRelativeTolerance parameters relative tolerance}: 1.0e-10</li>\n+     *    <li>{@link #setOrthoTolerance orthogonality tolerance}: 1.0e-10</li>\n+     *   </ul>\n+     * </p>\n+     */\n+    public LevenbergMarquardtOptimizer() {\n+\n+        // set up the superclass with a default  max cost evaluations setting\n+        setMaxEvaluations(1000);\n+\n+        // default values for the tuning parameters\n+        setInitialStepBoundFactor(100.0);\n+        setCostRelativeTolerance(1.0e-10);\n+        setParRelativeTolerance(1.0e-10);\n+        setOrthoTolerance(1.0e-10);\n+\n+    }\n+\n+    /** \n+     * Set the positive input variable used in determining the initial step bound.\n+     * This bound is set to the product of initialStepBoundFactor and the euclidean\n+     * norm of diag*x if nonzero, or else to initialStepBoundFactor itself. In most\n+     * cases factor should lie in the interval (0.1, 100.0). 100.0 is a generally\n+     * recommended value.\n+     *\n+     * @param initialStepBoundFactor initial step bound factor\n+     */\n+    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n+        this.initialStepBoundFactor = initialStepBoundFactor;\n+    }\n+\n+    /** \n+     * Set the desired relative error in the sum of squares.\n+     * \n+     * @param costRelativeTolerance desired relative error in the sum of squares\n+     */\n+    public void setCostRelativeTolerance(double costRelativeTolerance) {\n+        this.costRelativeTolerance = costRelativeTolerance;\n+    }\n+\n+    /** \n+     * Set the desired relative error in the approximate solution parameters.\n+     * \n+     * @param parRelativeTolerance desired relative error\n+     * in the approximate solution parameters\n+     */\n+    public void setParRelativeTolerance(double parRelativeTolerance) {\n+        this.parRelativeTolerance = parRelativeTolerance;\n+    }\n+\n+    /** \n+     * Set the desired max cosine on the orthogonality.\n+     * \n+     * @param orthoTolerance desired max cosine on the orthogonality\n+     * between the function vector and the columns of the jacobian\n+     */\n+    public void setOrthoTolerance(double orthoTolerance) {\n+        this.orthoTolerance = orthoTolerance;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected VectorialPointValuePair doOptimize()\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+\n+        // arrays shared with the other private methods\n+        solvedCols  = Math.min(rows, cols);\n+        diagR       = new double[cols];\n+        jacNorm     = new double[cols];\n+        beta        = new double[cols];\n+        permutation = new int[cols];\n+        lmDir       = new double[cols];\n+\n+        // local variables\n+        double   delta   = 0, xNorm = 0;\n+        double[] diag    = new double[cols];\n+        double[] oldX    = new double[cols];\n+        double[] oldRes  = new double[rows];\n+        double[] work1   = new double[cols];\n+        double[] work2   = new double[cols];\n+        double[] work3   = new double[cols];\n+\n+        // evaluate the function at the starting point and calculate its norm\n+        updateResidualsAndCost();\n+\n+        // outer loop\n+        lmPar = 0;\n+        boolean firstIteration = true;\n+        while (true) {\n+\n+            // compute the Q.R. decomposition of the jacobian matrix\n+            updateJacobian();\n+            qrDecomposition();\n+\n+            // compute Qt.res\n+            qTy(residuals);\n+\n+            // now we don't need Q anymore,\n+            // so let jacobian contain the R matrix with its diagonal elements\n+            for (int k = 0; k < solvedCols; ++k) {\n+                int pk = permutation[k];\n+                jacobian[k][pk] = diagR[pk];\n+            }\n+\n+            if (firstIteration) {\n+\n+                // scale the variables according to the norms of the columns\n+                // of the initial jacobian\n+                xNorm = 0;\n+                for (int k = 0; k < cols; ++k) {\n+                    double dk = jacNorm[k];\n+                    if (dk == 0) {\n+                        dk = 1.0;\n+                    }\n+                    double xk = dk * variables[k];\n+                    xNorm  += xk * xk;\n+                    diag[k] = dk;\n+                }\n+                xNorm = Math.sqrt(xNorm);\n+\n+                // initialize the step bound delta\n+                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n+\n+            }\n+\n+            // check orthogonality between function vector and jacobian columns\n+            double maxCosine = 0;\n+            if (cost != 0) {\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int    pj = permutation[j];\n+                    double s  = jacNorm[pj];\n+                    if (s != 0) {\n+                        double sum = 0;\n+                        for (int i = 0; i <= j; ++i) {\n+                            sum += jacobian[i][pj] * residuals[i];\n+                        }\n+                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n+                    }\n+                }\n+            }\n+            if (maxCosine <= orthoTolerance) {\n+                // convergence has been reached\n+                return new VectorialPointValuePair(variables, objective);\n+            }\n+\n+            // rescale if necessary\n+            for (int j = 0; j < cols; ++j) {\n+                diag[j] = Math.max(diag[j], jacNorm[j]);\n+            }\n+\n+            // inner loop\n+            for (double ratio = 0; ratio < 1.0e-4;) {\n+\n+                // save the state\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    oldX[pj] = variables[pj];\n+                }\n+                double previousCost = cost;\n+                double[] tmpVec = residuals;\n+                residuals = oldRes;\n+                oldRes    = tmpVec;\n+\n+                // determine the Levenberg-Marquardt parameter\n+                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+\n+                // compute the new point and the norm of the evolution direction\n+                double lmNorm = 0;\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    lmDir[pj] = -lmDir[pj];\n+                    variables[pj] = oldX[pj] + lmDir[pj];\n+                    double s = diag[pj] * lmDir[pj];\n+                    lmNorm  += s * s;\n+                }\n+                lmNorm = Math.sqrt(lmNorm);\n+\n+                // on the first iteration, adjust the initial step bound.\n+                if (firstIteration) {\n+                    delta = Math.min(delta, lmNorm);\n+                }\n+\n+                // evaluate the function at x + p and calculate its norm\n+                updateResidualsAndCost();\n+\n+                // compute the scaled actual reduction\n+                double actRed = -1.0;\n+                if (0.1 * cost < previousCost) {\n+                    double r = cost / previousCost;\n+                    actRed = 1.0 - r * r;\n+                }\n+\n+                // compute the scaled predicted reduction\n+                // and the scaled directional derivative\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    double dirJ = lmDir[pj];\n+                    work1[j] = 0;\n+                    for (int i = 0; i <= j; ++i) {\n+                        work1[i] += jacobian[i][pj] * dirJ;\n+                    }\n+                }\n+                double coeff1 = 0;\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    coeff1 += work1[j] * work1[j];\n+                }\n+                double pc2 = previousCost * previousCost;\n+                coeff1 = coeff1 / pc2;\n+                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n+                double preRed = coeff1 + 2 * coeff2;\n+                double dirDer = -(coeff1 + coeff2);\n+\n+                // ratio of the actual to the predicted reduction\n+                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n+\n+                // update the step bound\n+                if (ratio <= 0.25) {\n+                    double tmp =\n+                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n+                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n+                            tmp = 0.1;\n+                        }\n+                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n+                        lmPar /= tmp;\n+                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n+                    delta = 2 * lmNorm;\n+                    lmPar *= 0.5;\n+                }\n+\n+                // test for successful iteration.\n+                if (ratio >= 1.0e-4) {\n+                    // successful iteration, update the norm\n+                    firstIteration = false;\n+                    xNorm = 0;\n+                    for (int k = 0; k < cols; ++k) {\n+                        double xK = diag[k] * variables[k];\n+                        xNorm    += xK * xK;\n+                    }\n+                    xNorm = Math.sqrt(xNorm);\n+                } else {\n+                    // failed iteration, reset the previous values\n+                    cost = previousCost;\n+                    for (int j = 0; j < solvedCols; ++j) {\n+                        int pj = permutation[j];\n+                        variables[pj] = oldX[pj];\n+                    }\n+                    tmpVec    = residuals;\n+                    residuals = oldRes;\n+                    oldRes    = tmpVec;\n+                }\n+\n+                // tests for convergence.\n+                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+                        (preRed <= costRelativeTolerance) &&\n+                        (ratio <= 2.0)) ||\n+                        (delta <= parRelativeTolerance * xNorm)) {\n+                    return new VectorialPointValuePair(variables, objective);\n+                }\n+\n+                // tests for termination and stringent tolerances\n+                // (2.2204e-16 is the machine epsilon for IEEE754)\n+                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n+                    throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n+                            \" no further reduction in the\" +\n+                            \" sum of squares is possible\",\n+                            costRelativeTolerance);\n+                } else if (delta <= 2.2204e-16 * xNorm) {\n+                    throw new OptimizationException(\"parameters relative tolerance is too small\" +\n+                            \" ({0}), no further improvement in\" +\n+                            \" the approximate solution is possible\",\n+                            parRelativeTolerance);\n+                } else if (maxCosine <= 2.2204e-16)  {\n+                    throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n+                            \" solution is orthogonal to the jacobian\",\n+                            orthoTolerance);\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** \n+     * Determine the Levenberg-Marquardt parameter.\n+     * <p>This implementation is a translation in Java of the MINPACK\n+     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n+     * routine.</p>\n+     * <p>This method sets the lmPar and lmDir attributes.</p>\n+     * <p>The authors of the original fortran function are:</p>\n+     * <ul>\n+     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+     *   <li>Burton  S. Garbow</li>\n+     *   <li>Kenneth E. Hillstrom</li>\n+     *   <li>Jorge   J. More</li>\n+     * </ul>\n+     * <p>Luc Maisonobe did the Java translation.</p>\n+     * \n+     * @param qy array containing qTy\n+     * @param delta upper bound on the euclidean norm of diagR * lmDir\n+     * @param diag diagonal matrix\n+     * @param work1 work array\n+     * @param work2 work array\n+     * @param work3 work array\n+     */\n+    private void determineLMParameter(double[] qy, double delta, double[] diag,\n+            double[] work1, double[] work2, double[] work3) {\n+\n+        // compute and store in x the gauss-newton direction, if the\n+        // jacobian is rank-deficient, obtain a least squares solution\n+        for (int j = 0; j < rank; ++j) {\n+            lmDir[permutation[j]] = qy[j];\n+        }\n+        for (int j = rank; j < cols; ++j) {\n+            lmDir[permutation[j]] = 0;\n+        }\n+        for (int k = rank - 1; k >= 0; --k) {\n+            int pk = permutation[k];\n+            double ypk = lmDir[pk] / diagR[pk];\n+            for (int i = 0; i < k; ++i) {\n+                lmDir[permutation[i]] -= ypk * jacobian[i][pk];\n+            }\n+            lmDir[pk] = ypk;\n+        }\n+\n+        // evaluate the function at the origin, and test\n+        // for acceptance of the Gauss-Newton direction\n+        double dxNorm = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            double s = diag[pj] * lmDir[pj];\n+            work1[pj] = s;\n+            dxNorm += s * s;\n+        }\n+        dxNorm = Math.sqrt(dxNorm);\n+        double fp = dxNorm - delta;\n+        if (fp <= 0.1 * delta) {\n+            lmPar = 0;\n+            return;\n+        }\n+\n+        // if the jacobian is not rank deficient, the Newton step provides\n+        // a lower bound, parl, for the zero of the function,\n+        // otherwise set this bound to zero\n+        double sum2, parl = 0;\n+        if (rank == solvedCols) {\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] *= diag[pj] / dxNorm; \n+            }\n+            sum2 = 0;\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                double sum = 0;\n+                for (int i = 0; i < j; ++i) {\n+                    sum += jacobian[i][pj] * work1[permutation[i]];\n+                }\n+                double s = (work1[pj] - sum) / diagR[pj];\n+                work1[pj] = s;\n+                sum2 += s * s;\n+            }\n+            parl = fp / (delta * sum2);\n+        }\n+\n+        // calculate an upper bound, paru, for the zero of the function\n+        sum2 = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            double sum = 0;\n+            for (int i = 0; i <= j; ++i) {\n+                sum += jacobian[i][pj] * qy[i];\n+            }\n+            sum /= diag[pj];\n+            sum2 += sum * sum;\n+        }\n+        double gNorm = Math.sqrt(sum2);\n+        double paru = gNorm / delta;\n+        if (paru == 0) {\n+            // 2.2251e-308 is the smallest positive real for IEE754\n+            paru = 2.2251e-308 / Math.min(delta, 0.1);\n+        }\n+\n+        // if the input par lies outside of the interval (parl,paru),\n+        // set par to the closer endpoint\n+        lmPar = Math.min(paru, Math.max(lmPar, parl));\n+        if (lmPar == 0) {\n+            lmPar = gNorm / dxNorm;\n+        }\n+\n+        for (int countdown = 10; countdown >= 0; --countdown) {\n+\n+            // evaluate the function at the current value of lmPar\n+            if (lmPar == 0) {\n+                lmPar = Math.max(2.2251e-308, 0.001 * paru);\n+            }\n+            double sPar = Math.sqrt(lmPar);\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] = sPar * diag[pj];\n+            }\n+            determineLMDirection(qy, work1, work2, work3);\n+\n+            dxNorm = 0;\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                double s = diag[pj] * lmDir[pj];\n+                work3[pj] = s;\n+                dxNorm += s * s;\n+            }\n+            dxNorm = Math.sqrt(dxNorm);\n+            double previousFP = fp;\n+            fp = dxNorm - delta;\n+\n+            // if the function is small enough, accept the current value\n+            // of lmPar, also test for the exceptional cases where parl is zero\n+            if ((Math.abs(fp) <= 0.1 * delta) ||\n+                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n+                return;\n+            }\n+\n+            // compute the Newton correction\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] = work3[pj] * diag[pj] / dxNorm; \n+            }\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] /= work2[j];\n+                double tmp = work1[pj];\n+                for (int i = j + 1; i < solvedCols; ++i) {\n+                    work1[permutation[i]] -= jacobian[i][pj] * tmp;\n+                }\n+            }\n+            sum2 = 0;\n+            for (int j = 0; j < solvedCols; ++j) {\n+                double s = work1[permutation[j]];\n+                sum2 += s * s;\n+            }\n+            double correction = fp / (delta * sum2);\n+\n+            // depending on the sign of the function, update parl or paru.\n+            if (fp > 0) {\n+                parl = Math.max(parl, lmPar);\n+            } else if (fp < 0) {\n+                paru = Math.min(paru, lmPar);\n+            }\n+\n+            // compute an improved estimate for lmPar\n+            lmPar = Math.max(parl, lmPar + correction);\n+\n+        }\n+    }\n+\n+    /** \n+     * Solve a*x = b and d*x = 0 in the least squares sense.\n+     * <p>This implementation is a translation in Java of the MINPACK\n+     * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n+     * routine.</p>\n+     * <p>This method sets the lmDir and lmDiag attributes.</p>\n+     * <p>The authors of the original fortran function are:</p>\n+     * <ul>\n+     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+     *   <li>Burton  S. Garbow</li>\n+     *   <li>Kenneth E. Hillstrom</li>\n+     *   <li>Jorge   J. More</li>\n+     * </ul>\n+     * <p>Luc Maisonobe did the Java translation.</p>\n+     * \n+     * @param qy array containing qTy\n+     * @param diag diagonal matrix\n+     * @param lmDiag diagonal elements associated with lmDir\n+     * @param work work array\n+     */\n+    private void determineLMDirection(double[] qy, double[] diag,\n+            double[] lmDiag, double[] work) {\n+\n+        // copy R and Qty to preserve input and initialize s\n+        //  in particular, save the diagonal elements of R in lmDir\n+        for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            for (int i = j + 1; i < solvedCols; ++i) {\n+                jacobian[i][pj] = jacobian[j][permutation[i]];\n+            }\n+            lmDir[j] = diagR[pj];\n+            work[j]  = qy[j];\n+        }\n+\n+        // eliminate the diagonal matrix d using a Givens rotation\n+        for (int j = 0; j < solvedCols; ++j) {\n+\n+            // prepare the row of d to be eliminated, locating the\n+            // diagonal element using p from the Q.R. factorization\n+            int pj = permutation[j];\n+            double dpj = diag[pj];\n+            if (dpj != 0) {\n+                Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n+            }\n+            lmDiag[j] = dpj;\n+\n+            //  the transformations to eliminate the row of d\n+            // modify only a single element of Qty\n+            // beyond the first n, which is initially zero.\n+            double qtbpj = 0;\n+            for (int k = j; k < solvedCols; ++k) {\n+                int pk = permutation[k];\n+\n+                // determine a Givens rotation which eliminates the\n+                // appropriate element in the current row of d\n+                if (lmDiag[k] != 0) {\n+\n+                    double sin, cos;\n+                    double rkk = jacobian[k][pk];\n+                    if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n+                        double cotan = rkk / lmDiag[k];\n+                        sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n+                        cos   = sin * cotan;\n+                    } else {\n+                        double tan = lmDiag[k] / rkk;\n+                        cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n+                        sin = cos * tan;\n+                    }\n+\n+                    // compute the modified diagonal element of R and\n+                    // the modified element of (Qty,0)\n+                    jacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n+                    double temp = cos * work[k] + sin * qtbpj;\n+                    qtbpj = -sin * work[k] + cos * qtbpj;\n+                    work[k] = temp;\n+\n+                    // accumulate the tranformation in the row of s\n+                    for (int i = k + 1; i < solvedCols; ++i) {\n+                        double rik = jacobian[i][pk];\n+                        temp = cos * rik + sin * lmDiag[i];\n+                        lmDiag[i] = -sin * rik + cos * lmDiag[i];\n+                        jacobian[i][pk] = temp;\n+                    }\n+\n+                }\n+            }\n+\n+            // store the diagonal element of s and restore\n+            // the corresponding diagonal element of R\n+            lmDiag[j] = jacobian[j][permutation[j]];\n+            jacobian[j][permutation[j]] = lmDir[j];\n+\n+        }\n+\n+        // solve the triangular system for z, if the system is\n+        // singular, then obtain a least squares solution\n+        int nSing = solvedCols;\n+        for (int j = 0; j < solvedCols; ++j) {\n+            if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n+                nSing = j;\n+            }\n+            if (nSing < solvedCols) {\n+                work[j] = 0;\n+            }\n+        }\n+        if (nSing > 0) {\n+            for (int j = nSing - 1; j >= 0; --j) {\n+                int pj = permutation[j];\n+                double sum = 0;\n+                for (int i = j + 1; i < nSing; ++i) {\n+                    sum += jacobian[i][pj] * work[i];\n+                }\n+                work[j] = (work[j] - sum) / lmDiag[j];\n+            }\n+        }\n+\n+        // permute the components of z back to components of lmDir\n+        for (int j = 0; j < lmDir.length; ++j) {\n+            lmDir[permutation[j]] = work[j];\n+        }\n+\n+    }\n+\n+    /** \n+     * Decompose a matrix A as A.P = Q.R using Householder transforms.\n+     * <p>As suggested in the P. Lascaux and R. Theodor book\n+     * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n+     * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n+     * the Householder transforms with u<sub>k</sub> unit vectors such that:\n+     * <pre>\n+     * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n+     * </pre>\n+     * we use <sub>k</sub> non-unit vectors such that:\n+     * <pre>\n+     * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n+     * </pre>\n+     * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n+     * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n+     * them from the v<sub>k</sub> vectors would be costly.</p>\n+     * <p>This decomposition handles rank deficient cases since the tranformations\n+     * are performed in non-increasing columns norms order thanks to columns\n+     * pivoting. The diagonal elements of the R matrix are therefore also in\n+     * non-increasing absolute values order.</p>\n+     * @exception OptimizationException if the decomposition cannot be performed\n+     */\n+    private void qrDecomposition() throws OptimizationException {\n+\n+        // initializations\n+        for (int k = 0; k < cols; ++k) {\n+            permutation[k] = k;\n+            double norm2 = 0;\n+            for (int i = 0; i < jacobian.length; ++i) {\n+                double akk = jacobian[i][k];\n+                norm2 += akk * akk;\n+            }\n+            jacNorm[k] = Math.sqrt(norm2);\n+        }\n+\n+        // transform the matrix column after column\n+        for (int k = 0; k < cols; ++k) {\n+\n+            // select the column with the greatest norm on active components\n+            int nextColumn = -1;\n+            double ak2 = Double.NEGATIVE_INFINITY;\n+            for (int i = k; i < cols; ++i) {\n+                double norm2 = 0;\n+                for (int j = k; j < jacobian.length; ++j) {\n+                    double aki = jacobian[j][permutation[i]];\n+                    norm2 += aki * aki;\n+                }\n+                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n+                    throw new OptimizationException(\n+                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n+                            rows, cols);\n+                }\n+                if (norm2 > ak2) {\n+                    nextColumn = i;\n+                    ak2        = norm2;\n+                }\n+            }\n+            if (ak2 == 0) {\n+                rank = k;\n+                return;\n+            }\n+            int pk                  = permutation[nextColumn];\n+            permutation[nextColumn] = permutation[k];\n+            permutation[k]          = pk;\n+\n+            // choose alpha such that Hk.u = alpha ek\n+            double akk   = jacobian[k][pk];\n+            double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n+            double betak = 1.0 / (ak2 - akk * alpha);\n+            beta[pk]     = betak;\n+\n+            // transform the current column\n+            diagR[pk]        = alpha;\n+            jacobian[k][pk] -= alpha;\n+\n+            // transform the remaining columns\n+            for (int dk = cols - 1 - k; dk > 0; --dk) {\n+                double gamma = 0;\n+                for (int j = k; j < jacobian.length; ++j) {\n+                    gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n+                }\n+                gamma *= betak;\n+                for (int j = k; j < jacobian.length; ++j) {\n+                    jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n+                }\n+            }\n+\n+        }\n+\n+        rank = solvedCols;\n+\n+    }\n+\n+    /** \n+     * Compute the product Qt.y for some Q.R. decomposition.\n+     * \n+     * @param y vector to multiply (will be overwritten with the result)\n+     */\n+    private void qTy(double[] y) {\n+        for (int k = 0; k < cols; ++k) {\n+            int pk = permutation[k];\n+            double gamma = 0;\n+            for (int i = k; i < rows; ++i) {\n+                gamma += jacobian[i][pk] * y[i];\n+            }\n+            gamma *= beta[pk];\n+            for (int i = k; i < rows; ++i) {\n+                y[i] -= gamma * jacobian[i][pk];\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.linear.DenseRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.ObjectiveException;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.VectorialDifferentiableObjectiveFunction;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class LevenbergMarquardtOptimizerTest\n+  extends TestCase {\n+\n+    public LevenbergMarquardtOptimizerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testTrivial() throws ObjectiveException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        try {\n+            optimizer.guessParametersErrors();\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+    }\n+\n+    public void testQRColumnsPermutation() throws ObjectiveException, OptimizationException {\n+\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n+                    new double[] { 4.0, 6.0, 1.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+\n+    }\n+\n+    public void testNoDependency() throws ObjectiveException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 2, 0, 0, 0, 0, 0 },\n+                { 0, 2, 0, 0, 0, 0 },\n+                { 0, 0, 2, 0, 0, 0 },\n+                { 0, 0, 0, 2, 0, 0 },\n+                { 0, 0, 0, 0, 2, 0 },\n+                { 0, 0, 0, 0, 0, 2 }\n+        }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        for (int i = 0; i < problem.target.length; ++i) {\n+            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    public void testOneSet() throws ObjectiveException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1,  0, 0 },\n+                { -1,  1, 0 },\n+                {  0, -1, 1 }\n+        }, new double[] { 1, 1, 1});\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+\n+    }\n+\n+    public void testTwoSets() throws ObjectiveException, OptimizationException {\n+        double epsilon = 1.0e-7;\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  2,  1,   0,  4,       0, 0 },\n+                { -4, -2,   3, -7,       0, 0 },\n+                {  4,  1,  -2,  8,       0, 0 },\n+                {  0, -3, -12, -1,       0, 0 },\n+                {  0,  0,   0,  0, epsilon, 1 },\n+                {  0,  0,   0,  0,       1, 1 }\n+        }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+                               new double[] { 0, 0, 0, 0, 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+\n+    }\n+\n+    public void testNonInversible() throws ObjectiveException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                {  1, 2, -3 },\n+                {  2, 1,  3 },\n+                { -3, 0, -9 }\n+        }, new double[] { 1, 1, 1 });\n+ \n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        assertTrue(Math.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n+        try {\n+            optimizer.getCovariances();\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+    }\n+\n+    public void testIllConditioned() throws ObjectiveException, OptimizationException {\n+        LinearProblem problem1 = new LinearProblem(new double[][] {\n+                { 10.0, 7.0,  8.0,  7.0 },\n+                {  7.0, 5.0,  6.0,  5.0 },\n+                {  8.0, 6.0, 10.0,  9.0 },\n+                {  7.0, 5.0,  9.0, 10.0 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum1 =\n+            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10);\n+        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10);\n+\n+        LinearProblem problem2 = new LinearProblem(new double[][] {\n+                { 10.00, 7.00, 8.10, 7.20 },\n+                {  7.08, 5.04, 6.00, 5.00 },\n+                {  8.00, 5.98, 9.89, 9.00 },\n+                {  6.99, 4.99, 9.00, 9.98 }\n+        }, new double[] { 32, 23, 33, 31 });\n+        VectorialPointValuePair optimum2 =\n+            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n+                               new double[] { 0, 1, 2, 3 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n+        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8);\n+        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8);\n+        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n+\n+    }\n+\n+    public void testMoreEstimatedParametersSimple() throws ObjectiveException, OptimizationException {\n+\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 3.0, 2.0,  0.0, 0.0 },\n+                { 0.0, 1.0, -1.0, 1.0 },\n+                { 2.0, 0.0,  1.0, 0.0 }\n+        }, new double[] { 7.0, 3.0, 5.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+                new double[] { 7, 6, 5, 4 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+\n+    }\n+\n+    public void testMoreEstimatedParametersUnsorted() throws ObjectiveException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n+                { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n+                { 0.0, 0.0,  0.0,  0.0, 1.0, -1.0 },\n+                { 0.0, 0.0, -1.0,  1.0, 0.0,  1.0 },\n+                { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n+       }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 2, 2, 2, 2, 2, 2 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);\n+        assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10);\n+        assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10);\n+        assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n+\n+    }\n+\n+    public void testRedundantEquations() throws ObjectiveException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 5.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+                               new double[] { 1, 1 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n+        assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n+\n+    }\n+\n+    public void testInconsistentEquations() throws ObjectiveException, OptimizationException {\n+        LinearProblem problem = new LinearProblem(new double[][] {\n+                { 1.0,  1.0 },\n+                { 1.0, -1.0 },\n+                { 1.0,  3.0 }\n+        }, new double[] { 3.0, 1.0, 4.0 });\n+\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n+        assertTrue(optimizer.getRMS() > 0.1);\n+\n+    }\n+\n+    public void testInconsistentSizes() throws ObjectiveException, OptimizationException {\n+        LinearProblem problem =\n+            new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n+        assertEquals(0, optimizer.getRMS(), 1.0e-10);\n+        assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n+        assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n+\n+        try {\n+            optimizer.optimize(problem, problem.target,\n+                               new double[] { 1 },\n+                               new double[] { 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException oe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        try {\n+            optimizer.optimize(problem, new double[] { 1 },\n+                               new double[] { 1 },\n+                               new double[] { 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (ObjectiveException oe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+    }\n+\n+    public void testControlParameters() throws OptimizationException {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false);\n+        checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true);\n+        checkEstimate(circle, 0.1,  5, 1.0e-15, 1.0e-16, 1.0e-10, true);\n+        circle.addPoint(300, -300);\n+        checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);\n+    }\n+\n+    private void checkEstimate(VectorialDifferentiableObjectiveFunction problem,\n+                               double initialStepBoundFactor, int maxCostEval,\n+                               double costRelativeTolerance, double parRelativeTolerance,\n+                               double orthoTolerance, boolean shouldFail) {\n+        try {\n+            LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+            optimizer.setInitialStepBoundFactor(initialStepBoundFactor);\n+            optimizer.setMaxEvaluations(maxCostEval);\n+            optimizer.setCostRelativeTolerance(costRelativeTolerance);\n+            optimizer.setParRelativeTolerance(parRelativeTolerance);\n+            optimizer.setOrthoTolerance(orthoTolerance);\n+            optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 98.680, 47.345 });\n+            assertTrue(! shouldFail);\n+        } catch (OptimizationException ee) {\n+            assertTrue(shouldFail);\n+        } catch (ObjectiveException ee) {\n+            assertTrue(shouldFail);\n+        } catch (Exception e) {\n+            fail(\"wrong exception type caught\");\n+        }\n+    }\n+\n+    public void testCircleFitting() throws ObjectiveException, OptimizationException {\n+        Circle circle = new Circle();\n+        circle.addPoint( 30.0,  68.0);\n+        circle.addPoint( 50.0,  -6.0);\n+        circle.addPoint(110.0, -20.0);\n+        circle.addPoint( 35.0,  15.0);\n+        circle.addPoint( 45.0,  97.0);\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+                               new double[] { 98.680, 47.345 });\n+        assertTrue(optimizer.getEvaluations() < 10);\n+        assertTrue(optimizer.getJacobianEvaluations() < 10);\n+        double rms = optimizer.getRMS();\n+        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\n+        assertEquals(96.07590211815305, center.x,      1.0e-10);\n+        assertEquals(48.13516790438953, center.y,      1.0e-10);\n+        double[][] cov = optimizer.getCovariances();\n+        assertEquals(1.839, cov[0][0], 0.001);\n+        assertEquals(0.731, cov[0][1], 0.001);\n+        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        assertEquals(0.786, cov[1][1], 0.001);\n+        double[] errors = optimizer.guessParametersErrors();\n+        assertEquals(1.384, errors[0], 0.001);\n+        assertEquals(0.905, errors[1], 0.001);\n+\n+        // add perfect measurements and check errors are reduced\n+        double  r = circle.getRadius(center);\n+        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n+            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n+        }\n+        double[] target = new double[circle.getN()];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[circle.getN()];\n+        Arrays.fill(weights, 2.0);\n+        optimum =\n+            optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n+        cov = optimizer.getCovariances();\n+        assertEquals(0.0016, cov[0][0], 0.001);\n+        assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n+        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\n+        assertEquals(0.0016, cov[1][1], 0.001);\n+        errors = optimizer.guessParametersErrors();\n+        assertEquals(0.002, errors[0], 0.001);\n+        assertEquals(0.002, errors[1], 0.001);\n+\n+    }\n+\n+    public void testCircleFittingBadInit() throws ObjectiveException, OptimizationException {\n+        Circle circle = new Circle();\n+        double[][] points = new double[][] {\n+                {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n+                {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n+                {-0.280579,  0.444306}, {-0.216035,  0.470009}, {-0.149127,  0.493832},\n+                {-0.075133,  0.483271}, {-0.007759,  0.452680}, { 0.060071,  0.410235},\n+                { 0.103037,  0.341076}, { 0.118438,  0.273884}, { 0.131293,  0.192201},\n+                { 0.115869,  0.129797}, { 0.072223,  0.058396}, { 0.022884,  0.000718},\n+                {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862},\n+                {-0.278592, -0.005008}, {-0.337655,  0.056658}, {-0.385899,  0.112526},\n+                {-0.405517,  0.186957}, {-0.415374,  0.262071}, {-0.387482,  0.343398},\n+                {-0.347322,  0.397943}, {-0.287623,  0.458425}, {-0.223502,  0.475513},\n+                {-0.135352,  0.478186}, {-0.061221,  0.483371}, { 0.003711,  0.422737},\n+                { 0.065054,  0.375830}, { 0.108108,  0.297099}, { 0.123882,  0.222850},\n+                { 0.117729,  0.134382}, { 0.085195,  0.056820}, { 0.029800, -0.019138},\n+                {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578},\n+                {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561,  0.014926},\n+                {-0.471036,  0.074716}, {-0.488638,  0.182508}, {-0.485990,  0.254068},\n+                {-0.463943,  0.338438}, {-0.406453,  0.404704}, {-0.334287,  0.466119},\n+                {-0.254244,  0.503188}, {-0.161548,  0.495769}, {-0.075733,  0.495560},\n+                { 0.001375,  0.434937}, { 0.082787,  0.385806}, { 0.115490,  0.323807},\n+                { 0.141089,  0.223450}, { 0.138693,  0.131703}, { 0.126415,  0.049174},\n+                { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635},\n+                {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251},\n+                {-0.405195, -0.000895}, {-0.444937,  0.085456}, {-0.484357,  0.175597},\n+                {-0.472453,  0.248681}, {-0.438580,  0.347463}, {-0.402304,  0.422428},\n+                {-0.326777,  0.479438}, {-0.247797,  0.505581}, {-0.152676,  0.519380},\n+                {-0.071754,  0.516264}, { 0.015942,  0.472802}, { 0.076608,  0.419077},\n+                { 0.127673,  0.330264}, { 0.159951,  0.262150}, { 0.153530,  0.172681},\n+                { 0.140653,  0.089229}, { 0.078666,  0.024981}, { 0.023807, -0.037022},\n+                {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526}\n+        };\n+        double[] target = new double[points.length];\n+        Arrays.fill(target, 0.0);\n+        double[] weights = new double[points.length];\n+        Arrays.fill(weights, 2.0);\n+        for (int i = 0; i < points.length; ++i) {\n+            circle.addPoint(points[i][0], points[i][1]);\n+        }\n+        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-10, 1.0e-10));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n+        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n+        assertTrue(optimizer.getEvaluations() < 25);\n+        assertTrue(optimizer.getJacobianEvaluations() < 20);\n+        assertEquals( 0.043, optimizer.getRMS(), 1.0e-3);\n+        assertEquals( 0.292235,  circle.getRadius(center), 1.0e-6);\n+        assertEquals(-0.151738,  center.x,      1.0e-6);\n+        assertEquals( 0.2075001, center.y,      1.0e-6);\n+    }\n+\n+    public void testMath199() throws ObjectiveException, OptimizationException {\n+        try {\n+            QuadraticProblem problem = new QuadraticProblem();\n+            problem.addPoint (0, -3.182591015485607);\n+            problem.addPoint (1, -2.5581184967730577);\n+            problem.addPoint (2, -2.1488478161387325);\n+            problem.addPoint (3, -1.9122489313410047);\n+            problem.addPoint (4, 1.7785661310051026);\n+            new LevenbergMarquardtOptimizer().optimize(problem,\n+                                                       new double[] { 0, 0, 0, 0, 0 },\n+                                                       new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },\n+                                                       new double[] { 0, 0, 0 });\n+            fail(\"an exception should have been thrown\");\n+        } catch (OptimizationException ee) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    private static class LinearProblem implements VectorialDifferentiableObjectiveFunction {\n+\n+        private static final long serialVersionUID = 703247177355019415L;\n+        final RealMatrix factors;\n+        final double[] target;\n+        public LinearProblem(double[][] factors, double[] target) {\n+            this.factors = new DenseRealMatrix(factors);\n+            this.target  = target;\n+        }\n+\n+        public double[][] jacobian(double[] variables, double[] value) {\n+            return factors.getData();\n+        }\n+\n+        public double[] objective(double[] variables) {\n+            return factors.operate(variables);\n+        }\n+\n+    }\n+\n+    private static class Circle implements VectorialDifferentiableObjectiveFunction {\n+\n+        private static final long serialVersionUID = -4711170319243817874L;\n+\n+        private ArrayList<Point2D.Double> points;\n+\n+        public Circle() {\n+            points  = new ArrayList<Point2D.Double>();\n+        }\n+\n+        public void addPoint(double px, double py) {\n+            points.add(new Point2D.Double(px, py));\n+        }\n+\n+        public int getN() {\n+            return points.size();\n+        }\n+\n+        public double getRadius(Point2D.Double center) {\n+            double r = 0;\n+            for (Point2D.Double point : points) {\n+                r += point.distance(center);\n+            }\n+            return r / points.size();\n+        }\n+\n+        public double[][] jacobian(double[] variables, double[] value)\n+        throws ObjectiveException, IllegalArgumentException {\n+\n+            int n = points.size();\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+\n+            // gradient of the optimal radius\n+            double dRdX = 0;\n+            double dRdY = 0;\n+            for (Point2D.Double pk : points) {\n+                double dk = pk.distance(center);\n+                dRdX += (center.x - pk.x) / dk;\n+                dRdY += (center.y - pk.y) / dk;\n+            }\n+            dRdX /= n;\n+            dRdY /= n;\n+\n+            // jacobian of the radius residuals\n+            double[][] jacobian = new double[n][2];\n+            for (int i = 0; i < n; ++i) {\n+                Point2D.Double pi = points.get(i);\n+                double di   = pi.distance(center);\n+                jacobian[i][0] = (center.x - pi.x) / di - dRdX;    \n+                jacobian[i][1] = (center.y - pi.y) / di - dRdY;    \n+            }\n+\n+            return jacobian;\n+\n+        }\n+\n+        public double[] objective(double[] variables)\n+        throws ObjectiveException, IllegalArgumentException {\n+\n+            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            double radius = getRadius(center);\n+\n+            double[] residuals = new double[points.size()];\n+            for (int i = 0; i < residuals.length; ++i) {\n+                residuals[i] = points.get(i).distance(center) - radius;\n+            }\n+\n+            return residuals;\n+\n+        }\n+\n+    }\n+\n+    private static class QuadraticProblem implements VectorialDifferentiableObjectiveFunction {\n+\n+        private static final long serialVersionUID = -247096133023967957L;\n+        private List<Double> x;\n+        private List<Double> y;\n+\n+        public QuadraticProblem() {\n+            x = new ArrayList<Double>();\n+            y = new ArrayList<Double>();\n+        }\n+\n+        public void addPoint(double x, double y) {\n+            this.x.add(x);\n+            this.y.add(y);\n+        }\n+\n+        public double[][] jacobian(double[] variables, double[] value) {\n+            double[][] jacobian = new double[x.size()][3];\n+            for (int i = 0; i < jacobian.length; ++i) {\n+                jacobian[i][0] = x.get(i) * x.get(i);\n+                jacobian[i][1] = x.get(i);\n+                jacobian[i][2] = 1.0;\n+            }\n+            return jacobian;\n+        }\n+\n+        public double[] objective(double[] variables) {\n+            double[] values = new double[x.size()];\n+            for (int i = 0; i < values.length; ++i) {\n+                values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];\n+            }\n+            return values;\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(LevenbergMarquardtOptimizerTest.class);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n \n import java.util.Arrays;\n \n+import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.VectorialDifferentiableObjectiveFunction;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n \n import junit.framework.*;\n  * @author Jorge J. More (original fortran minpack tests)\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n-public class MinpackTest\n-  extends TestCase {\n+public class MinpackTest extends TestCase {\n \n   public MinpackTest(String name) {\n     super(name);\n   }\n \n   private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n-    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n-    estimator.setMaxCostEval(100 * (function.getN() + 1));\n-    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n-    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n-    estimator.setOrthoTolerance(2.22044604926e-16);\n-    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));\n-    try {\n-      estimator.estimate(function);\n-      assertFalse(exceptionExpected);\n-    } catch (OptimizationException lsse) {\n-      assertTrue(exceptionExpected);\n-    }\n-    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));\n-    assertTrue(function.checkTheoreticalMinParams());\n-  }\n-\n-  private static abstract class MinpackFunction implements EstimationProblem {\n+      LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n+      optimizer.setMaxEvaluations(100 * (function.getN() + 1));\n+      optimizer.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+      optimizer.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+      optimizer.setOrthoTolerance(2.22044604926e-16);\n+//      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n+      try {\n+          VectorialPointValuePair optimum =\n+              optimizer.optimize(function,\n+                                 function.getTarget(), function.getWeight(),\n+                                 function.getStartPoint());\n+          assertFalse(exceptionExpected);\n+          assertTrue(function.checkTheoreticalMinCost(optimizer.getRMS()));\n+          assertTrue(function.checkTheoreticalMinParams(optimum));\n+      } catch (OptimizationException lsse) {\n+          assertTrue(exceptionExpected);\n+      } catch (ObjectiveException oe) {\n+          assertTrue(exceptionExpected);\n+      }\n+  }\n+\n+  private static abstract class MinpackFunction\n+      implements VectorialDifferentiableObjectiveFunction {\n  \n-    protected MinpackFunction(int m,\n-                              double[] startParams,\n-                              double   theoreticalStartCost,\n-                              double   theoreticalMinCost,\n-                              double[] theoreticalMinParams) {\n-      this.m = m;\n-      this.n = startParams.length;\n-      parameters = new EstimatedParameter[n];\n-      for (int i = 0; i < n; ++i) {\n-        parameters[i] = new EstimatedParameter(\"p\" + i, startParams[i]);\n-      }\n-      this.theoreticalStartCost = theoreticalStartCost;\n-      this.theoreticalMinCost   = theoreticalMinCost;\n-      this.theoreticalMinParams = theoreticalMinParams;\n-      this.costAccuracy         = 1.0e-8;\n-      this.paramsAccuracy       = 1.0e-5;\n-    }\n-\n-    protected static double[] buildArray(int n, double x) {\n-      double[] array = new double[n];\n-      Arrays.fill(array, x);\n-      return array;\n-    }\n-\n-    protected void setCostAccuracy(double costAccuracy) {\n-      this.costAccuracy = costAccuracy;\n-    }\n-\n-    protected void setParamsAccuracy(double paramsAccuracy) {\n-      this.paramsAccuracy = paramsAccuracy;\n-    }\n-\n-    public int getN() {\n-      return parameters.length;\n-    }\n-\n-    public boolean checkTheoreticalStartCost(double rms) {\n-      double threshold = costAccuracy * (1.0 + theoreticalStartCost);\n-      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;\n-    }\n-\n-    public boolean checkTheoreticalMinCost(double rms) {\n-      double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n-     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n-    }\n-\n-    public boolean checkTheoreticalMinParams() {\n-      if (theoreticalMinParams != null) {\n-        for (int i = 0; i < theoreticalMinParams.length; ++i) {\n-          double mi = theoreticalMinParams[i];\n-          double vi = parameters[i].getEstimate();\n-          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n-            return false;\n+      private static final long serialVersionUID = -6209760235478794233L;\n+      protected int      n;\n+      protected int      m;\n+      protected double[] startParams;\n+      protected double   theoreticalMinCost;\n+      protected double[] theoreticalMinParams;\n+      protected double   costAccuracy;\n+      protected double   paramsAccuracy;\n+\n+      protected MinpackFunction(int m, double[] startParams,\n+                                double theoreticalMinCost, double[] theoreticalMinParams) {\n+          this.m = m;\n+          this.n = startParams.length;\n+          this.startParams          = startParams.clone();\n+          this.theoreticalMinCost   = theoreticalMinCost;\n+          this.theoreticalMinParams = theoreticalMinParams;\n+          this.costAccuracy         = 1.0e-8;\n+          this.paramsAccuracy       = 1.0e-5;\n+      }\n+\n+      protected static double[] buildArray(int n, double x) {\n+          double[] array = new double[n];\n+          Arrays.fill(array, x);\n+          return array;\n+      }\n+\n+      public double[] getTarget() {\n+          return buildArray(m, 0.0);\n+      }\n+\n+      public double[] getWeight() {\n+          return buildArray(m, 1.0);\n+      }\n+\n+      public double[] getStartPoint() {\n+          return startParams.clone();\n+      }\n+\n+      protected void setCostAccuracy(double costAccuracy) {\n+          this.costAccuracy = costAccuracy;\n+      }\n+\n+      protected void setParamsAccuracy(double paramsAccuracy) {\n+          this.paramsAccuracy = paramsAccuracy;\n+      }\n+\n+      public int getN() {\n+          return startParams.length;\n+      }\n+\n+      public boolean checkTheoreticalMinCost(double rms) {\n+          double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n+          return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n+      }\n+\n+      public boolean checkTheoreticalMinParams(VectorialPointValuePair optimum) {\n+          double[] params = optimum.getPointRef();\n+          if (theoreticalMinParams != null) {\n+              for (int i = 0; i < theoreticalMinParams.length; ++i) {\n+                  double mi = theoreticalMinParams[i];\n+                  double vi = params[i];\n+                  if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n+                      return false;\n+                  }\n+              }\n           }\n-        }\n-      }\n-      return true;\n-    }\n- \n-    public WeightedMeasurement[] getMeasurements() {\n-      WeightedMeasurement[] measurements = new WeightedMeasurement[m];\n-      for (int i = 0; i < m; ++i) {\n-        measurements[i] = new MinpackMeasurement(i);\n-      }\n-      return measurements;\n-    }\n-\n-    public EstimatedParameter[] getUnboundParameters() {\n-      return parameters;\n-    }\n-\n-    public EstimatedParameter[] getAllParameters() {\n-      return parameters;\n-    }\n-\n-    protected abstract double[][] getJacobian();\n-\n-    protected abstract double[] getResiduals();\n-\n-    private class MinpackMeasurement extends WeightedMeasurement {\n-\n-      public MinpackMeasurement(int index) {\n-        super(1.0, 0.0);\n-        this.index = index;\n-      }\n-\n-      public double getTheoreticalValue() {\n-        // this is obviously NOT efficient as we recompute the whole vector\n-        // each time we need only one element, but it is only for test\n-        // purposes and is simpler to check.\n-        // This implementation should NOT be taken as an example, it is ugly!\n-        return getResiduals()[index];\n-      }\n-\n-      public double getPartial(EstimatedParameter parameter) {\n-        // this is obviously NOT efficient as we recompute the whole jacobian\n-        // each time we need only one element, but it is only for test\n-        // purposes and is simpler to check.\n-        // This implementation should NOT be taken as an example, it is ugly!\n-        for (int j = 0; j < n; ++j) {\n-          if (parameter == parameters[j]) {\n-            return getJacobian()[index][j];\n-          }\n-        }\n-        return 0;\n-      }\n-\n-      private int index;\n-      private static final long serialVersionUID = 1L;\n-\n-    }\n-\n-    protected int                  n;\n-    protected int                  m;\n-    protected EstimatedParameter[] parameters;\n-    protected double               theoreticalStartCost;\n-    protected double               theoreticalMinCost;\n-    protected double[]             theoreticalMinParams;\n-    protected double               costAccuracy;\n-    protected double               paramsAccuracy;\n+          return true;\n+      }\n+\n+      public abstract double[][] jacobian(double[] variables, double[] value);\n+\n+      public abstract double[] objective(double[] variables);\n \n   }\n \n   private static class LinearFullRankFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -9030323226268039536L;\n \n     public LinearFullRankFunction(int m, int n, double x0,\n                                   double theoreticalStartCost,\n                                   double theoreticalMinCost) {\n-      super(m, buildArray(n, x0), theoreticalStartCost,\n-            theoreticalMinCost, buildArray(n, -1.0));\n-    }\n-\n-    protected double[][] getJacobian() {\n+      super(m, buildArray(n, x0), theoreticalMinCost,\n+            buildArray(n, -1.0));\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n       double t = 2.0 / m;\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n+    public double[] objective(double[] variables) {\n       double sum = 0;\n       for (int i = 0; i < n; ++i) {\n-        sum += parameters[i].getEstimate();\n+        sum += variables[i];\n       }\n       double t  = 1 + 2 * sum / m;\n       double[] f = new double[m];\n       for (int i = 0; i < n; ++i) {\n-        f[i] = parameters[i].getEstimate() - t;\n+        f[i] = variables[i] - t;\n       }\n       Arrays.fill(f, n, m, -t);\n       return f;\n   }\n \n   private static class LinearRank1Function extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 8494863245104608300L;\n \n     public LinearRank1Function(int m, int n, double x0,\n                                   double theoreticalStartCost,\n                                   double theoreticalMinCost) {\n-      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);\n-    }\n-\n-    protected double[][] getJacobian() {\n+      super(m, buildArray(n, x0), theoreticalMinCost, null);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         jacobian[i] = new double[n];\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n+    public double[] objective(double[] variables) {\n       double[] f = new double[m];\n       double sum = 0;\n       for (int i = 0; i < n; ++i) {\n-        sum += (i + 1) * parameters[i].getEstimate();\n+        sum += (i + 1) * variables[i];\n       }\n       for (int i = 0; i < m; ++i) {\n         f[i] = (i + 1) * sum - 1;\n   }\n \n   private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -3316653043091995018L;\n \n     public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n       super(m, buildArray(n, x0),\n-            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),\n             Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n             null);\n     }\n \n-    protected double[][] getJacobian() {\n+    public double[][] jacobian(double[] variables, double[] value) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         jacobian[i] = new double[n];\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n+    public double[] objective(double[] variables) {\n       double[] f = new double[m];\n       double sum = 0;\n       for (int i = 1; i < (n - 1); ++i) {\n-        sum += (i + 1) * parameters[i].getEstimate();\n+        sum += (i + 1) * variables[i];\n       }\n       for (int i = 0; i < (m - 1); ++i) {\n         f[i] = i * sum - 1;\n \n   private static class RosenbrockFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = 2893438180956569134L;\n+\n     public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {\n-      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x1 = parameters[0].getEstimate();\n+      super(2, startParams, 0.0, buildArray(2, 1.0));\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double x1 = variables[0];\n       return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n       return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };\n     }\n \n   }\n \n   private static class HelicalValleyFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 220613787843200102L;\n \n     public HelicalValleyFunction(double[] startParams,\n                                  double theoreticalStartCost) {\n-      super(3, startParams, theoreticalStartCost, 0.0,\n-            new double[] { 1.0, 0.0, 0.0 });\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n+      super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n       double tmpSquare = x1 * x1 + x2 * x2;\n       double tmp1 = twoPi * tmpSquare;\n       double tmp2 = Math.sqrt(tmpSquare);\n       };\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n       double tmp1;\n       if (x1 == 0) {\n         tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n \n   private static class PowellSingularFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = 7298364171208142405L;\n+\n     public PowellSingularFunction(double[] startParams,\n                                   double theoreticalStartCost) {\n-      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n+      super(4, startParams, 0.0, buildArray(4, 0.0));\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n       return new double[][] {\n         { 1, 10, 0, 0 },\n         { 0, 0, sqrt5, -sqrt5 },\n       };\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n       return new double[] {\n         x1 + 10 * x2,\n         sqrt5 * (x3 - x4),\n \n   private static class FreudensteinRothFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = 2892404999344244214L;\n+\n     public FreudensteinRothFunction(double[] startParams,\n                                     double theoreticalStartCost,\n                                     double theoreticalMinCost,\n                                     double[] theoreticalMinParams) {\n-      super(2, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double x2 = parameters[1].getEstimate();\n+      super(2, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double x2 = variables[1];\n       return new double[][] {\n         { 1, x2 * (10 - 3 * x2) -  2 },\n         { 1, x2 * ( 2 + 3 * x2) - 14, }\n       };\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n       return new double[] {\n        -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,\n        -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2\n \n   private static class BardFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = 5990442612572087668L;\n+\n     public BardFunction(double x0,\n                         double theoreticalStartCost,\n                         double theoreticalMinCost,\n                         double[] theoreticalMinParams) {\n-      super(15, buildArray(3, x0), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n+      super(15, buildArray(3, x0), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double tmp1 = i  + 1;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double tmp1 = i + 1;\n \n   private static class KowalikOsborneFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = -4867445739880495801L;\n+\n     public KowalikOsborneFunction(double[] startParams,\n                                   double theoreticalStartCost,\n                                   double theoreticalMinCost,\n                                   double[] theoreticalMinParams) {\n-      super(11, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n+      super(11, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n       if (theoreticalStartCost > 20.0) {\n         setCostAccuracy(2.0e-4);\n         setParamsAccuracy(5.0e-3);\n       }\n     }\n \n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double   x4 = parameters[3].getEstimate();\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double   x4 = variables[3];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double tmp = v[i] * (v[i] + x3) + x4;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);\n \n   private static class MeyerFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = -838060619150131027L;\n+\n     public MeyerFunction(double[] startParams,\n                          double theoreticalStartCost,\n                          double theoreticalMinCost,\n                          double[] theoreticalMinParams) {\n-      super(16, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n+      super(16, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n       if (theoreticalStartCost > 1.0e6) {\n         setCostAccuracy(7.0e-3);\n         setParamsAccuracy(2.0e-2);\n       }\n     }\n \n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = 5.0 * (i + 1) + 45.0 + x3;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n \n   private static class WatsonFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = -9034759294980218927L;\n+\n     public WatsonFunction(int n, double x0,\n                           double theoreticalStartCost,\n                           double theoreticalMinCost,\n                           double[] theoreticalMinParams) {\n-      super(31, buildArray(n, x0), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n+      super(31, buildArray(n, x0), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n \n       double[][] jacobian = new double[m][];\n \n         double s2  = 0.0;\n         double dx  = 1.0;\n         for (int j = 0; j < n; ++j) {\n-          s2 += dx * parameters[j].getEstimate();\n+          s2 += dx * variables[j];\n           dx *= div;\n         }\n         double temp= 2 * div * s2;\n       jacobian[m - 2][0] = 1;\n \n       jacobian[m - 1]   = new double[n];\n-      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();\n+      jacobian[m - 1][0]= -2 * variables[0];\n       jacobian[m - 1][1]= 1;\n \n       return jacobian;\n \n     }\n \n-    protected double[] getResiduals() {\n+    public double[] objective(double[] variables) {\n      double[] f = new double[m];\n      for (int i = 0; i < (m - 2); ++i) {\n        double div = (i + 1) / 29.0;\n        double s1 = 0;\n        double dx = 1;\n        for (int j = 1; j < n; ++j) {\n-         s1 += j * dx * parameters[j].getEstimate();\n+         s1 += j * dx * variables[j];\n          dx *= div;\n        }\n        double s2 =0;\n        dx =1;\n        for (int j = 0; j < n; ++j) {\n-         s2 += dx * parameters[j].getEstimate();\n+         s2 += dx * variables[j];\n          dx *= div;\n        }\n        f[i] = s1 - s2 * s2 - 1;\n      }\n \n-     double x1 = parameters[0].getEstimate();\n-     double x2 = parameters[1].getEstimate();\n+     double x1 = variables[0];\n+     double x2 = variables[1];\n      f[m - 2] = x1;\n      f[m - 1] = x2 - x1 * x1 - 1;\n \n \n   private static class Box3DimensionalFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = 5511403858142574493L;\n+\n     public Box3DimensionalFunction(int m, double[] startParams,\n                                    double theoreticalStartCost) {\n-      super(m, startParams, theoreticalStartCost,\n-            0.0, new double[] { 1.0, 10.0, 1.0 });\n+      super(m, startParams, 0.0,\n+            new double[] { 1.0, 10.0, 1.0 });\n    }\n \n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double tmp = (i + 1) / 10.0;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double tmp = (i + 1) / 10.0;\n   }\n \n   private static class JennrichSampsonFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -2489165190443352947L;\n \n     public JennrichSampsonFunction(int m, double[] startParams,\n                                    double theoreticalStartCost,\n                                    double theoreticalMinCost,\n                                    double[] theoreticalMinParams) {\n-      super(m, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n+      super(m, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double t = i + 1;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = i + 1;\n   }\n \n   private static class BrownDennisFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 8340018645694243910L;\n \n     public BrownDennisFunction(int m, double[] startParams,\n                                double theoreticalStartCost,\n                                double theoreticalMinCost,\n                                double[] theoreticalMinParams) {\n-      super(m, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x1 = parameters[0].getEstimate();\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double   x4 = parameters[3].getEstimate();\n+      super(m, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x1 = variables[0];\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double   x4 = variables[3];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = (i + 1) / 5.0;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = (i + 1) / 5.0;\n   }\n \n   private static class ChebyquadFunction extends MinpackFunction {\n+\n+    private static final long serialVersionUID = -2394877275028008594L;\n \n     private static double[] buildChebyquadArray(int n, double factor) {\n       double[] array = new double[n];\n                              double theoreticalStartCost,\n                              double theoreticalMinCost,\n                              double[] theoreticalMinParams) {\n-      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n+      super(m, buildChebyquadArray(n, factor), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n \n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n       double dx = 1.0 / n;\n       for (int j = 0; j < n; ++j) {\n         double tmp1 = 1;\n-        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double tmp2 = 2 * variables[j] - 1;\n         double temp = 2 * tmp2;\n         double tmp3 = 0;\n         double tmp4 = 2;\n \n     }\n \n-    protected double[] getResiduals() {\n+    public double[] objective(double[] variables) {\n \n       double[] f = new double[m];\n \n       for (int j = 0; j < n; ++j) {\n         double tmp1 = 1;\n-        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double tmp2 = 2 * variables[j] - 1;\n         double temp = 2 * tmp2;\n         for (int i = 0; i < m; ++i) {\n           f[i] += tmp2;\n \n   private static class BrownAlmostLinearFunction extends MinpackFunction {\n \n+    private static final long serialVersionUID = 8239594490466964725L;\n+\n     public BrownAlmostLinearFunction(int m, double factor,\n                                      double theoreticalStartCost,\n                                      double theoreticalMinCost,\n                                      double[] theoreticalMinParams) {\n-      super(m, buildArray(m, factor), theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n+      super(m, buildArray(m, factor), theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         jacobian[i] = new double[n];\n \n       double prod = 1;\n       for (int j = 0; j < n; ++j) {\n-        prod *= parameters[j].getEstimate();\n+        prod *= variables[j];\n         for (int i = 0; i < n; ++i) {\n           jacobian[i][j] = 1;\n         }\n       }\n \n       for (int j = 0; j < n; ++j) {\n-        EstimatedParameter vj = parameters[j];\n-        double temp = vj.getEstimate();\n+        double temp = variables[j];\n         if (temp == 0) {\n           temp = 1;\n           prod = 1;\n           for (int k = 0; k < n; ++k) {\n             if (k != j) {\n-              prod *= parameters[k].getEstimate();\n+              prod *= variables[k];\n             }\n           }\n         }\n \n     }\n \n-    protected double[] getResiduals() {\n+    public double[] objective(double[] variables) {\n       double[] f = new double[m];\n       double sum  = -(n + 1);\n       double prod = 1;\n       for (int j = 0; j < n; ++j) {\n-        sum  += parameters[j].getEstimate();\n-        prod *= parameters[j].getEstimate();\n+        sum  += variables[j];\n+        prod *= variables[j];\n       }\n       for (int i = 0; i < n; ++i) {\n-        f[i] = parameters[i].getEstimate() + sum;\n+        f[i] = variables[i] + sum;\n       }\n       f[n - 1] = prod - 1;\n       return f;\n   }\n \n   private static class Osborne1Function extends MinpackFunction {\n+\n+    private static final long serialVersionUID = 4006743521149849494L;\n \n     public Osborne1Function(double[] startParams,\n                             double theoreticalStartCost,\n                             double theoreticalMinCost,\n                             double[] theoreticalMinParams) {\n-      super(33, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x2 = parameters[1].getEstimate();\n-      double   x3 = parameters[2].getEstimate();\n-      double   x4 = parameters[3].getEstimate();\n-      double   x5 = parameters[4].getEstimate();\n+      super(33, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x2 = variables[1];\n+      double   x3 = variables[2];\n+      double   x4 = variables[3];\n+      double   x5 = variables[4];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = 10.0 * i;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double x1 = parameters[0].getEstimate();\n-      double x2 = parameters[1].getEstimate();\n-      double x3 = parameters[2].getEstimate();\n-      double x4 = parameters[3].getEstimate();\n-      double x5 = parameters[4].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x1 = variables[0];\n+      double x2 = variables[1];\n+      double x3 = variables[2];\n+      double x4 = variables[3];\n+      double x5 = variables[4];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = 10.0 * i;\n \n   private static class Osborne2Function extends MinpackFunction {\n \n+    private static final long serialVersionUID = -8418268780389858746L;\n+\n     public Osborne2Function(double[] startParams,\n                             double theoreticalStartCost,\n                             double theoreticalMinCost,\n                             double[] theoreticalMinParams) {\n-      super(65, startParams, theoreticalStartCost,\n-            theoreticalMinCost, theoreticalMinParams);\n-    }\n-\n-    protected double[][] getJacobian() {\n-      double   x01 = parameters[0].getEstimate();\n-      double   x02 = parameters[1].getEstimate();\n-      double   x03 = parameters[2].getEstimate();\n-      double   x04 = parameters[3].getEstimate();\n-      double   x05 = parameters[4].getEstimate();\n-      double   x06 = parameters[5].getEstimate();\n-      double   x07 = parameters[6].getEstimate();\n-      double   x08 = parameters[7].getEstimate();\n-      double   x09 = parameters[8].getEstimate();\n-      double   x10 = parameters[9].getEstimate();\n-      double   x11 = parameters[10].getEstimate();\n+      super(65, startParams, theoreticalMinCost,\n+            theoreticalMinParams);\n+    }\n+\n+    public double[][] jacobian(double[] variables, double[] value) {\n+      double   x01 = variables[0];\n+      double   x02 = variables[1];\n+      double   x03 = variables[2];\n+      double   x04 = variables[3];\n+      double   x05 = variables[4];\n+      double   x06 = variables[5];\n+      double   x07 = variables[6];\n+      double   x08 = variables[7];\n+      double   x09 = variables[8];\n+      double   x10 = variables[9];\n+      double   x11 = variables[10];\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         double temp = i / 10.0;\n       return jacobian;\n     }\n \n-    protected double[] getResiduals() {\n-      double x01 = parameters[0].getEstimate();\n-      double x02 = parameters[1].getEstimate();\n-      double x03 = parameters[2].getEstimate();\n-      double x04 = parameters[3].getEstimate();\n-      double x05 = parameters[4].getEstimate();\n-      double x06 = parameters[5].getEstimate();\n-      double x07 = parameters[6].getEstimate();\n-      double x08 = parameters[7].getEstimate();\n-      double x09 = parameters[8].getEstimate();\n-      double x10 = parameters[9].getEstimate();\n-      double x11 = parameters[10].getEstimate();\n+    public double[] objective(double[] variables) {\n+      double x01 = variables[0];\n+      double x02 = variables[1];\n+      double x03 = variables[2];\n+      double x04 = variables[3];\n+      double x05 = variables[4];\n+      double x06 = variables[5];\n+      double x07 = variables[6];\n+      double x08 = variables[7];\n+      double x09 = variables[8];\n+      double x10 = variables[9];\n+      double x11 = variables[10];\n       double[] f = new double[m];\n       for (int i = 0; i < m; ++i) {\n         double temp = i / 10.0;", "timestamp": 1237144262, "metainfo": ""}