{"sha": "7b45e6f6cacb8966debb805b25c410adbe8c0f92", "log": "MATH-854: filled the \"throws\" clause of BlockRealMatrix.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/BlockRealMatrix.java\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathUtils;\n      *\n      * @param rows  the number of rows in the new matrix\n      * @param columns  the number of columns in the new matrix\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if row or column dimension is not positive.\n+     * @throws NotStrictlyPositiveException if row or column dimension is not\n+     * positive.\n      */\n-    public BlockRealMatrix(final int rows, final int columns) {\n+    public BlockRealMatrix(final int rows, final int columns)\n+        throws NotStrictlyPositiveException {\n         super(rows, columns);\n         this.rows = rows;\n         this.columns = columns;\n      * @param rawData data for new matrix, in raw layout\n      * @throws DimensionMismatchException if the shape of {@code blockData} is\n      * inconsistent with block layout.\n+     * @throws NotStrictlyPositiveException if row or column dimension is not\n+     * positive.\n      * @see #BlockRealMatrix(int, int, double[][], boolean)\n      */\n-    public BlockRealMatrix(final double[][] rawData) {\n+    public BlockRealMatrix(final double[][] rawData)\n+        throws DimensionMismatchException, NotStrictlyPositiveException {\n         this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n     }\n \n      * @param copyArray Whether the input array will be copied or referenced.\n      * @throws DimensionMismatchException if the shape of {@code blockData} is\n      * inconsistent with block layout.\n+     * @throws NotStrictlyPositiveException if row or column dimension is not\n+     * positive.\n      * @see #createBlocksLayout(int, int)\n      * @see #toBlocksLayout(double[][])\n      * @see #BlockRealMatrix(double[][])\n      */\n     public BlockRealMatrix(final int rows, final int columns,\n-                           final double[][] blockData, final boolean copyArray) {\n+                           final double[][] blockData, final boolean copyArray)\n+        throws DimensionMismatchException, NotStrictlyPositiveException {\n         super(rows, columns);\n         this.rows = rows;\n         this.columns = columns;\n      * @see #createBlocksLayout(int, int)\n      * @see #BlockRealMatrix(int, int, double[][], boolean)\n      */\n-    public static double[][] toBlocksLayout(final double[][] rawData) {\n+    public static double[][] toBlocksLayout(final double[][] rawData)\n+        throws DimensionMismatchException {\n         final int rows = rawData.length;\n         final int columns = rawData[0].length;\n         final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension) {\n+    public BlockRealMatrix createMatrix(final int rowDimension,\n+                                        final int columnDimension)\n+        throws NotStrictlyPositiveException {\n         return new BlockRealMatrix(rowDimension, columnDimension);\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix add(final RealMatrix m) {\n+    public BlockRealMatrix add(final RealMatrix m)\n+        throws MatrixDimensionMismatchException {\n         try {\n             return add((BlockRealMatrix) m);\n         } catch (ClassCastException cce) {\n      * @throws MatrixDimensionMismatchException if {@code m} is not the same\n      * size as this matrix.\n      */\n-    public BlockRealMatrix add(final BlockRealMatrix m) {\n+    public BlockRealMatrix add(final BlockRealMatrix m)\n+        throws MatrixDimensionMismatchException {\n         // safety check\n         MatrixUtils.checkAdditionCompatible(this, m);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix subtract(final RealMatrix m) {\n+    public BlockRealMatrix subtract(final RealMatrix m)\n+        throws MatrixDimensionMismatchException {\n         try {\n             return subtract((BlockRealMatrix) m);\n         } catch (ClassCastException cce) {\n      * @throws MatrixDimensionMismatchException if {@code m} is not the\n      * same size as this matrix.\n      */\n-    public BlockRealMatrix subtract(final BlockRealMatrix m) {\n+    public BlockRealMatrix subtract(final BlockRealMatrix m)\n+        throws MatrixDimensionMismatchException {\n         // safety check\n         MatrixUtils.checkSubtractionCompatible(this, m);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix multiply(final RealMatrix m) {\n+    public BlockRealMatrix multiply(final RealMatrix m)\n+        throws DimensionMismatchException {\n         try {\n             return multiply((BlockRealMatrix) m);\n         } catch (ClassCastException cce) {\n      *\n      * @param m Matrix to postmultiply by.\n      * @return {@code this} * m.\n-     * @throws MatrixDimensionMismatchException if the matrices are not\n-     * compatible.\n+     * @throws DimensionMismatchException if the matrices are not compatible.\n      */\n-    public BlockRealMatrix multiply(BlockRealMatrix m) {\n+    public BlockRealMatrix multiply(BlockRealMatrix m)\n+        throws DimensionMismatchException {\n         // safety check\n         MatrixUtils.checkMultiplicationCompatible(this, m);\n \n     /** {@inheritDoc} */\n     @Override\n     public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n-                                        final int startColumn, final int endColumn) {\n+                                        final int startColumn,\n+                                        final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         // safety checks\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n-        throws NoDataException, NullArgumentException {\n+    public void setSubMatrix(final double[][] subMatrix, final int row,\n+                             final int column)\n+        throws OutOfRangeException, NoDataException, NullArgumentException,\n+        DimensionMismatchException {\n         // safety checks\n         MathUtils.checkNotNull(subMatrix);\n         final int refLength = subMatrix[0].length;\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix getRowMatrix(final int row) {\n+    public BlockRealMatrix getRowMatrix(final int row)\n+        throws OutOfRangeException {\n         MatrixUtils.checkRowIndex(this, row);\n         final BlockRealMatrix out = new BlockRealMatrix(1, columns);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRowMatrix(final int row, final RealMatrix matrix) {\n+    public void setRowMatrix(final int row, final RealMatrix matrix)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         try {\n             setRowMatrix(row, (BlockRealMatrix) matrix);\n         } catch (ClassCastException cce) {\n      * @param row the row to be set\n      * @param matrix row matrix (must have one row and the same number of columns\n      * as the instance)\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the specified row index is invalid.\n+     * @throws OutOfRangeException if the specified row index is invalid.\n      * @throws MatrixDimensionMismatchException if the matrix dimensions do\n      * not match one instance row.\n      */\n-    public void setRowMatrix(final int row, final BlockRealMatrix matrix) {\n+    public void setRowMatrix(final int row, final BlockRealMatrix matrix)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n \n     /** {@inheritDoc} */\n     @Override\n-    public BlockRealMatrix getColumnMatrix(final int column) {\n+    public BlockRealMatrix getColumnMatrix(final int column)\n+        throws OutOfRangeException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final BlockRealMatrix out = new BlockRealMatrix(rows, 1);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumnMatrix(final int column, final RealMatrix matrix) {\n+    public void setColumnMatrix(final int column, final RealMatrix matrix)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         try {\n             setColumnMatrix(column, (BlockRealMatrix) matrix);\n         } catch (ClassCastException cce) {\n      * @param column the column to be set\n      * @param matrix column matrix (must have one column and the same number of rows\n      * as the instance)\n-     * @throws org.apache.commons.math3.exception.OutOfRangeException\n-     * if the specified column index is invalid.\n+     * @throws OutOfRangeException if the specified column index is invalid.\n      * @throws MatrixDimensionMismatchException if the matrix dimensions do\n      * not match one instance column.\n      */\n-    void setColumnMatrix(final int column, final BlockRealMatrix matrix) {\n+    void setColumnMatrix(final int column, final BlockRealMatrix matrix)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector getRowVector(final int row) {\n+    public RealVector getRowVector(final int row)\n+        throws OutOfRangeException {\n         MatrixUtils.checkRowIndex(this, row);\n         final double[] outData = new double[columns];\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRowVector(final int row, final RealVector vector) {\n+    public void setRowVector(final int row, final RealVector vector)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         try {\n             setRow(row, ((ArrayRealVector) vector).getDataRef());\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealVector getColumnVector(final int column) {\n+    public RealVector getColumnVector(final int column)\n+        throws OutOfRangeException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final double[] outData = new double[rows];\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumnVector(final int column, final RealVector vector) {\n+    public void setColumnVector(final int column, final RealVector vector)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         try {\n             setColumn(column, ((ArrayRealVector) vector).getDataRef());\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] getRow(final int row) {\n+    public double[] getRow(final int row) throws OutOfRangeException {\n         MatrixUtils.checkRowIndex(this, row);\n         final double[] out = new double[columns];\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRow(final int row, final double[] array) {\n+    public void setRow(final int row, final double[] array)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] getColumn(final int column) {\n+    public double[] getColumn(final int column) throws OutOfRangeException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final double[] out = new double[rows];\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumn(final int column, final double[] array) {\n+    public void setColumn(final int column, final double[] array)\n+        throws OutOfRangeException, MatrixDimensionMismatchException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public double getEntry(final int row, final int column) {\n+    public double getEntry(final int row, final int column)\n+        throws OutOfRangeException {\n         MatrixUtils.checkMatrixIndex(this, row, column);\n         final int iBlock = row / BLOCK_SIZE;\n         final int jBlock = column / BLOCK_SIZE;\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setEntry(final int row, final int column, final double value) {\n+    public void setEntry(final int row, final int column, final double value)\n+        throws OutOfRangeException {\n         MatrixUtils.checkMatrixIndex(this, row, column);\n         final int iBlock = row / BLOCK_SIZE;\n         final int jBlock = column / BLOCK_SIZE;\n \n     /** {@inheritDoc} */\n     @Override\n-    public void addToEntry(final int row, final int column, final double increment) {\n+    public void addToEntry(final int row, final int column,\n+                           final double increment)\n+        throws OutOfRangeException {\n         MatrixUtils.checkMatrixIndex(this, row, column);\n         final int iBlock = row    / BLOCK_SIZE;\n         final int jBlock = column / BLOCK_SIZE;\n \n     /** {@inheritDoc} */\n     @Override\n-    public void multiplyEntry(final int row, final int column, final double factor) {\n+    public void multiplyEntry(final int row, final int column,\n+                              final double factor)\n+        throws OutOfRangeException {\n         MatrixUtils.checkMatrixIndex(this, row, column);\n         final int iBlock = row / BLOCK_SIZE;\n         final int jBlock = column / BLOCK_SIZE;\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] operate(final double[] v) {\n+    public double[] operate(final double[] v)\n+        throws DimensionMismatchException {\n         if (v.length != columns) {\n             throw new DimensionMismatchException(v.length, columns);\n         }\n \n     /** {@inheritDoc} */\n     @Override\n-    public double[] preMultiply(final double[] v) {\n+    public double[] preMultiply(final double[] v)\n+        throws DimensionMismatchException {\n         if (v.length != rows) {\n             throw new DimensionMismatchException(v.length, rows);\n         }\n     @Override\n     public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n                                  final int startRow, final int endRow,\n-                                 final int startColumn, final int endColumn) {\n+                                 final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     @Override\n     public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n                                  final int startRow, final int endRow,\n-                                 final int startColumn, final int endColumn) {\n+                                 final int startColumn, final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     @Override\n     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n                                        final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                       final int startColumn,\n+                                       final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     @Override\n     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n                                        final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n+                                       final int startColumn,\n+                                       final int endColumn)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n         MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {", "timestamp": 1348771365, "metainfo": ""}