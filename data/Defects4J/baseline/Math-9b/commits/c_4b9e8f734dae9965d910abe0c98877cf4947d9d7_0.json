{"sha": "4b9e8f734dae9965d910abe0c98877cf4947d9d7", "log": "MATH-366   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/TrivariateRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * An interface representing a trivariate real function.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public interface TrivariateRealFunction {\n+    /**\n+     * Compute the value for the function.\n+     *\n+     * @param x x-coordinate for which the function value should be computed.\n+     * @param y y-coordinate for which the function value should be computed.\n+     * @param z z-coordinate for which the function value should be computed.\n+     * @return the value.\n+     * @throws FunctionEvaluationException if the function evaluation fails.\n+     */\n+    public double value(double x, double y, double z)\n+        throws FunctionEvaluationException;\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n \n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n \n     private final double[] xval;\n     /** Samples y-coordinates */\n     private final double[] yval;\n-    /** Set of cubic splines pacthing the whole data grid */\n+    /** Set of cubic splines patching the whole data grid */\n     private final BicubicSplineFunction[][] splines;\n-\n-    /**\n-     * @param x Sample values of the x-coordinate, in increasing order\n-     * @param y Sample values of the y-coordinate, in increasing order\n-     * @param z Values of the function on every grid point\n-     * @param dZdX Values of the partial derivative of function with respect\n-     * to x on every grid point\n-     * @param dZdY Values of the partial derivative of function with respect\n-     * to y on every grid point\n-     * @param dZdXdY Values of the cross partial derivative of function on\n-     * every grid point\n+    /**\n+     * Partial derivatives\n+     * The value of the first index determines the kind of derivatives:\n+     * 0 = first partial derivatives wrt x\n+     * 1 = first partial derivatives wrt y\n+     * 2 = second partial derivatives wrt x\n+     * 3 = second partial derivatives wrt y\n+     * 4 = cross partial derivatives\n+     */\n+    private BivariateRealFunction[][][] partialDerivatives = null;\n+\n+    /**\n+     * @param x Sample values of the x-coordinate, in increasing order.\n+     * @param y Sample values of the y-coordinate, in increasing order.\n+     * @param f Values of the function on every grid point.\n+     * @param dFdX Values of the partial derivative of function with respect\n+     * to x on every grid point.\n+     * @param dFdY Values of the partial derivative of function with respect\n+     * to y on every grid point.\n+     * @param d2FdXdY Values of the cross partial derivative of function on\n+     * every grid point.\n      * @throws DimensionMismatchException if the various arrays do not contain\n      * the expected number of elements.\n      * @throws IllegalArgumentException if {@code x} or {@code y} are not strictly\n      */\n     public BicubicSplineInterpolatingFunction(double[] x,\n                                               double[] y,\n-                                              double[][] z,\n-                                              double[][] dZdX,\n-                                              double[][] dZdY,\n-                                              double[][] dZdXdY)\n+                                              double[][] f,\n+                                              double[][] dFdX,\n+                                              double[][] dFdY,\n+                                              double[][] d2FdXdY)\n         throws DimensionMismatchException {\n         final int xLen = x.length;\n         final int yLen = y.length;\n \n-        if (xLen == 0 || yLen == 0 || z.length == 0 || z[0].length == 0) {\n+        if (xLen == 0 || yLen == 0 || f.length == 0 || f[0].length == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n         }\n-        if (xLen != z.length) {\n-            throw new DimensionMismatchException(xLen, z.length);\n-        }\n-        if (xLen != dZdX.length) {\n-            throw new DimensionMismatchException(xLen, dZdX.length);\n-        }\n-        if (xLen != dZdY.length) {\n-            throw new DimensionMismatchException(xLen, dZdY.length);\n-        }\n-        if (xLen != dZdXdY.length) {\n-            throw new DimensionMismatchException(xLen, dZdXdY.length);\n+        if (xLen != f.length) {\n+            throw new DimensionMismatchException(xLen, f.length);\n+        }\n+        if (xLen != dFdX.length) {\n+            throw new DimensionMismatchException(xLen, dFdX.length);\n+        }\n+        if (xLen != dFdY.length) {\n+            throw new DimensionMismatchException(xLen, dFdY.length);\n+        }\n+        if (xLen != d2FdXdY.length) {\n+            throw new DimensionMismatchException(xLen, d2FdXdY.length);\n         }\n \n         MathUtils.checkOrder(x, 1, true);\n         splines = new BicubicSplineFunction[lastI][lastJ];\n \n         for (int i = 0; i < lastI; i++) {\n-            if (z[i].length != yLen) {\n-                throw new DimensionMismatchException(z[i].length, yLen);\n-            }\n-            if (dZdX[i].length != yLen) {\n-                throw new DimensionMismatchException(dZdX[i].length, yLen);\n-            }\n-            if (dZdY[i].length != yLen) {\n-                throw new DimensionMismatchException(dZdY[i].length, yLen);\n-            }\n-            if (dZdXdY[i].length != yLen) {\n-                throw new DimensionMismatchException(dZdXdY[i].length, yLen);\n+            if (f[i].length != yLen) {\n+                throw new DimensionMismatchException(f[i].length, yLen);\n+            }\n+            if (dFdX[i].length != yLen) {\n+                throw new DimensionMismatchException(dFdX[i].length, yLen);\n+            }\n+            if (dFdY[i].length != yLen) {\n+                throw new DimensionMismatchException(dFdY[i].length, yLen);\n+            }\n+            if (d2FdXdY[i].length != yLen) {\n+                throw new DimensionMismatchException(d2FdXdY[i].length, yLen);\n             }\n             final int ip1 = i + 1;\n             for (int j = 0; j < lastJ; j++) {\n                 final int jp1 = j + 1;\n                 final double[] beta = new double[] {\n-                    z[i][j],      z[ip1][j],      z[i][jp1],      z[ip1][jp1],\n-                    dZdX[i][j],   dZdX[ip1][j],   dZdX[i][jp1],   dZdX[ip1][jp1],\n-                    dZdY[i][j],   dZdY[ip1][j],   dZdY[i][jp1],   dZdY[ip1][jp1],\n-                    dZdXdY[i][j], dZdXdY[ip1][j], dZdXdY[i][jp1], dZdXdY[ip1][jp1]\n+                    f[i][j], f[ip1][j], f[i][jp1], f[ip1][jp1],\n+                    dFdX[i][j], dFdX[ip1][j], dFdX[i][jp1], dFdX[ip1][jp1],\n+                    dFdY[i][j], dFdY[ip1][j], dFdY[i][jp1], dFdY[ip1][jp1],\n+                    d2FdXdY[i][j], d2FdXdY[ip1][j], d2FdXdY[i][jp1], d2FdXdY[ip1][jp1]\n                 };\n \n                 splines[i][j] = new BicubicSplineFunction(computeSplineCoefficients(beta));\n     }\n \n     /**\n-     * @param c coordinate\n-     * @param val coordinate samples\n+     * @param x x-coordinate.\n+     * @param y y-coordinate.\n+     * @return the value at point (x, y) of the first partial derivative with\n+     * respect to x.\n+     */\n+    public double partialDerivativeX(double x, double y) {\n+        return partialDerivative(0, x, y);\n+    }\n+    /**\n+     * @param x x-coordinate.\n+     * @param y y-coordinate.\n+     * @return the value at point (x, y) of the first partial derivative with\n+     * respect to y.\n+     */\n+    public double partialDerivativeY(double x, double y) {\n+        return partialDerivative(1, x, y);\n+    }\n+    /**\n+     * @param x x-coordinate.\n+     * @param y y-coordinate.\n+     * @return the value at point (x, y) of the second partial derivative with\n+     * respect to x.\n+     */\n+    public double partialDerivativeXX(double x, double y) {\n+        return partialDerivative(2, x, y);\n+    }\n+    /**\n+     * @param x x-coordinate.\n+     * @param y y-coordinate.\n+     * @return the value at point (x, y) of the second partial derivative with\n+     * respect to y.\n+     */\n+    public double partialDerivativeYY(double x, double y) {\n+        return partialDerivative(3, x, y);\n+    }\n+    /**\n+     * @param x x-coordinate.\n+     * @param y y-coordinate.\n+     * @return the value at point (x, y) of the second partial cross-derivative.\n+     */\n+    public double partialDerivativeXY(double x, double y) {\n+        return partialDerivative(4, x, y);\n+    }\n+\n+    /**\n+     * @param which First index in {@link #partialDerivatives}.\n+     * @param x x-coordinate.\n+     * @param y y-coordinate.\n+     * @return the value at point (x, y) of the selected partial derivative.\n+     */\n+    private double partialDerivative(int which, double x, double y) {\n+        if (partialDerivatives == null) {\n+            computePartialDerivatives();\n+        }\n+\n+        final int i = searchIndex(x, xval);\n+        if (i == -1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      x, xval[0], xval[xval.length - 1]);\n+        }\n+        final int j = searchIndex(y, yval);\n+        if (j == -1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      y, yval[0], yval[yval.length - 1]);\n+        }\n+\n+        final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n+        final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]);\n+\n+        double result = Double.NaN;\n+        try { // Workaround to avoid carrying around \"try\" blocks for an\n+              // exception that will never happen\n+            result = partialDerivatives[which][i][j].value(xN, yN);\n+        } catch (FunctionEvaluationException e) {\n+            // Will never happen\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Compute all partial derivatives.\n+     */\n+    private void computePartialDerivatives() {\n+        final int lastI = xval.length - 1;\n+        final int lastJ = yval.length - 1;\n+        partialDerivatives = new BivariateRealFunction[5][lastI][lastJ];\n+\n+        for (int i = 0; i < lastI; i++) {\n+            for (int j = 0; j < lastJ; j++) {\n+                final BicubicSplineFunction f = splines[i][j];\n+                partialDerivatives[0][i][j] = f.partialDerivativeX();\n+                partialDerivatives[1][i][j] = f.partialDerivativeY();\n+                partialDerivatives[2][i][j] = f.partialDerivativeXX();\n+                partialDerivatives[3][i][j] = f.partialDerivativeYY();\n+                partialDerivatives[4][i][j] = f.partialDerivativeXY();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param c Coordinate.\n+     * @param val Coordinate samples.\n      * @return the index in {@code val} corresponding to the interval\n      * containing {@code c}, or {@code -1} if {@code c} is out of the\n-     * range defined by the end values of {@code val}\n+     * range defined by the end values of {@code val}.\n      */\n     private int searchIndex(double c, double[] val) {\n         if (c < val[0]) {\n             return -1;\n         }\n \n-        int max = val.length;\n+        final int max = val.length;\n         for (int i = 1; i < max; i++) {\n             if (c <= val[i]) {\n                 return i - 1;\n      *  <li>f(1,0)</li>\n      *  <li>f(0,1)</li>\n      *  <li>f(1,1)</li>\n-     *  <li>fx(0,0)</li>\n-     *  <li>fx(1,0)</li>\n-     *  <li>fx(0,1)</li>\n-     *  <li>fx(1,1)</li>\n-     *  <li>fy(0,0)</li>\n-     *  <li>fy(1,0)</li>\n-     *  <li>fy(0,1)</li>\n-     *  <li>fy(1,1)</li>\n-     *  <li>fxy(0,0)</li>\n-     *  <li>fxy(1,0)</li>\n-     *  <li>fxy(0,1)</li>\n-     *  <li>fxy(1,1)</li>\n+     *  <li>f<sub>x</sub>(0,0)</li>\n+     *  <li>f<sub>x</sub>(1,0)</li>\n+     *  <li>f<sub>x</sub>(0,1)</li>\n+     *  <li>f<sub>x</sub>(1,1)</li>\n+     *  <li>f<sub>y</sub>(0,0)</li>\n+     *  <li>f<sub>y</sub>(1,0)</li>\n+     *  <li>f<sub>y</sub>(0,1)</li>\n+     *  <li>f<sub>y</sub>(1,1)</li>\n+     *  <li>f<sub>xy</sub>(0,0)</li>\n+     *  <li>f<sub>xy</sub>(1,0)</li>\n+     *  <li>f<sub>xy</sub>(0,1)</li>\n+     *  <li>f<sub>xy</sub>(1,1)</li>\n      * </ul>\n+     * where the subscripts indicate the partial derivative with respect to\n+     * the corresponding variable(s).\n+     *\n      * @param beta List of function values and function partial derivatives\n-     * values\n-     * @return the spline coefficients\n+     * values.\n+     * @return the spline coefficients.\n      */\n     private double[] computeSplineCoefficients(double[] beta) {\n         final double[] a = new double[16];\n         return a;\n     }\n }\n+\n /**\n  * 2D-spline function.\n  *\n  */\n class BicubicSplineFunction\n     implements BivariateRealFunction {\n-//CHECKSTYLE: stop MultipleVariableDeclarations\n+    private static final short N = 4;\n     /** Coefficients */\n-    private final double\n-        a00, a01, a02, a03,\n-        a10, a11, a12, a13,\n-        a20, a21, a22, a23,\n-        a30, a31, a32, a33;\n-//CHECKSTYLE: resume MultipleVariableDeclarations\n+    private final double[][] a = new double[N][N];\n+    /** Partial derivatives */\n+    BivariateRealFunction partialDerivativeX = null;\n+    BivariateRealFunction partialDerivativeY = null;\n+    BivariateRealFunction partialDerivativeXX = null;\n+    BivariateRealFunction partialDerivativeYY = null;\n+    BivariateRealFunction partialDerivativeXY = null;\n \n     /**\n      * @param a Spline coefficients\n      */\n-    public BicubicSplineFunction(double[] a) {\n-        this.a00 = a[0];\n-        this.a10 = a[1];\n-        this.a20 = a[2];\n-        this.a30 = a[3];\n-        this.a01 = a[4];\n-        this.a11 = a[5];\n-        this.a21 = a[6];\n-        this.a31 = a[7];\n-        this.a02 = a[8];\n-        this.a12 = a[9];\n-        this.a22 = a[10];\n-        this.a32 = a[11];\n-        this.a03 = a[12];\n-        this.a13 = a[13];\n-        this.a23 = a[14];\n-        this.a33 = a[15];\n-    }\n-\n-    /**\n-     * @param x x-coordinate of the interpolation point\n-     * @param y y-coordinate of the interpolation point\n-     * @return the interpolated value.\n+    public BicubicSplineFunction(double[] aV) {\n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                a[i][j] = aV[i + N * j];\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n      */\n     public double value(double x, double y) {\n         if (x < 0 || x > 1) {\n \n         final double x2 = x * x;\n         final double x3 = x2 * x;\n+        final double[] pX = {1, x, x2, x3};\n+\n         final double y2 = y * y;\n         final double y3 = y2 * y;\n-\n-        return a00 + a01 * y + a02 * y2 + a03 * y3 +\n-            a10 * x + a11 * x * y + a12 * x * y2 + a13 * x * y3 +\n-            a20 * x2 + a21 * x2 * y + a22 * x2 * y2 + a23 * x2 * y3 +\n-            a30 * x3 + a31 * x3 * y + a32 * x3 * y2 + a33 * x3 * y3;\n+        final double[] pY = {1, y, y2, y3};\n+\n+        return apply(pX, pY, a);\n+    }\n+\n+    /**\n+     * Compute the value of the bicubic polynomial.\n+     *\n+     * @param pX Powers of the x-coordinate.\n+     * @param pY Powers of the y-coordinate.\n+     * @param coeff Spline coefficients.\n+     * @return the interpolated value.\n+     */\n+    private double apply(double[] pX, double[] pY, double[][] coeff) {\n+        double result = 0;\n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                result += coeff[i][j] * pX[i] * pY[j];\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * @return the partial derivative wrt {@code x}.\n+     */\n+    public BivariateRealFunction partialDerivativeX() {\n+        if (partialDerivativeX == null) {\n+            computePartialDerivatives();\n+        }\n+\n+        return partialDerivativeX;\n+    }\n+    /**\n+     * @return the partial derivative wrt {@code y}.\n+     */\n+    public BivariateRealFunction partialDerivativeY() {\n+        if (partialDerivativeY == null) {\n+            computePartialDerivatives();\n+        }\n+\n+        return partialDerivativeY;\n+    }\n+    /**\n+     * @return the second partial derivative wrt {@code x}.\n+     */\n+    public BivariateRealFunction partialDerivativeXX() {\n+        if (partialDerivativeXX == null) {\n+            computePartialDerivatives();\n+        }\n+\n+        return partialDerivativeXX;\n+    }\n+    /**\n+     * @return the second partial derivative wrt {@code y}.\n+     */\n+    public BivariateRealFunction partialDerivativeYY() {\n+        if (partialDerivativeYY == null) {\n+            computePartialDerivatives();\n+        }\n+\n+        return partialDerivativeYY;\n+    }\n+    /**\n+     * @return the second partial cross-derivative.\n+     */\n+    public BivariateRealFunction partialDerivativeXY() {\n+        if (partialDerivativeXY == null) {\n+            computePartialDerivatives();\n+        }\n+\n+        return partialDerivativeXY;\n+    }\n+\n+    /**\n+     * Compute all partial derivatives functions.\n+     */\n+    private void computePartialDerivatives() {\n+        final double[][] aX = new double[N][N];\n+        final double[][] aY = new double[N][N];\n+        final double[][] aXX = new double[N][N];\n+        final double[][] aYY = new double[N][N];\n+        final double[][] aXY = new double[N][N];\n+\n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                final double c = a[i][j];\n+                aX[i][j] = i * c;\n+                aY[i][j] = j * c;\n+                aXX[i][j] = (i - 1) * aX[i][j];\n+                aYY[i][j] = (j - 1) * aY[i][j];\n+                aXY[i][j] = j * aX[i][j];\n+            }\n+        }\n+\n+        partialDerivativeX = new BivariateRealFunction() {\n+                public double value(double x, double y)  {\n+                    final double x2 = x * x;\n+                    final double[] pX = {0, 1, x, x2};\n+                    \n+                    final double y2 = y * y;\n+                    final double y3 = y2 * y;\n+                    final double[] pY = {1, y, y2, y3};\n+\n+                    return apply(pX, pY, aX);\n+                }\n+            };\n+        partialDerivativeY = new BivariateRealFunction() {\n+                public double value(double x, double y)  {\n+                    final double x2 = x * x;\n+                    final double x3 = x2 * x;\n+                    final double[] pX = {1, x, x2, x3};\n+                    \n+                    final double y2 = y * y;\n+                    final double[] pY = {0, 1, y, y2};\n+\n+                    return apply(pX, pY, aY);\n+                }\n+            };\n+        partialDerivativeXX = new BivariateRealFunction() {\n+                public double value(double x, double y)  {\n+                    final double[] pX = {0, 0, 1, x};\n+                    \n+                    final double y2 = y * y;\n+                    final double y3 = y2 * y;\n+                    final double[] pY = {1, y, y2, y3};\n+\n+                    return apply(pX, pY, aXX);\n+                }\n+            };\n+        partialDerivativeYY = new BivariateRealFunction() {\n+                public double value(double x, double y)  {\n+                    final double x2 = x * x;\n+                    final double x3 = x2 * x;\n+                    final double[] pX = {1, x, x2, x3};\n+                    \n+                    final double[] pY = {0, 0, 1, y};\n+\n+                    return apply(pX, pY, aYY);\n+                }\n+            };\n+        partialDerivativeXY = new BivariateRealFunction() {\n+                public double value(double x, double y)  {\n+                    final double x2 = x * x;\n+                    final double[] pX = {0, 1, x, x2};\n+                    \n+                    final double y2 = y * y;\n+                    final double[] pY = {0, 1, y, y2};\n+\n+                    return apply(pX, pY, aXY);\n+                }\n+            };\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n     private final PolynomialFitter yFitter;\n \n     /**\n-     * Default constructor. The degree of the fitting polynomials are set to 3.\n+     * Default constructor. The degree of the fitting polynomials is set to 3.\n      */\n     public SmoothingPolynomialBicubicSplineInterpolator() {\n         this(3);\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.TrivariateRealFunction;\n+\n+/**\n+ * Function that implements the\n+ * <a href=\"http://en.wikipedia.org/wiki/Tricubic_interpolation\">\n+ * tricubic spline interpolation</a>, as proposed in\n+ * <quote>\n+ *  Tricubic interpolation in three dimensions<br/>\n+ *  F. Lekien and J. Marsden<br/>\n+ *  <em>Int. J. Numer. Meth. Engng</em> 2005; <b>63</b>:455-471\n+ * </quote>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class TricubicSplineInterpolatingFunction\n+    implements TrivariateRealFunction {\n+    /**\n+     * Matrix to compute the spline coefficients from the function values\n+     * and function derivatives values\n+     */\n+    private static final double[][] AINV = {\n+        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { -3,3,0,0,0,0,0,0,-2,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 2,-2,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { -3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,-3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 9,-9,-9,9,0,0,0,0,6,3,-6,-3,0,0,0,0,6,-6,3,-3,0,0,0,0,0,0,0,0,0,0,0,0,4,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { -6,6,6,-6,0,0,0,0,-3,-3,3,3,0,0,0,0,-4,4,-2,2,0,0,0,0,0,0,0,0,0,0,0,0,-2,-2,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { -6,6,6,-6,0,0,0,0,-4,-2,4,2,0,0,0,0,-3,3,-3,3,0,0,0,0,0,0,0,0,0,0,0,0,-2,-1,-2,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 4,-4,-4,4,0,0,0,0,2,2,-2,-2,0,0,0,0,2,-2,2,-2,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,3,0,0,0,0,0,0,-2,-1,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,0,0,0,0,1,1,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-1,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,-9,-9,9,0,0,0,0,0,0,0,0,0,0,0,0,6,3,-6,-3,0,0,0,0,6,-6,3,-3,0,0,0,0,4,2,2,1,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-6,6,6,-6,0,0,0,0,0,0,0,0,0,0,0,0,-3,-3,3,3,0,0,0,0,-4,4,-2,2,0,0,0,0,-2,-2,-1,-1,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-6,6,6,-6,0,0,0,0,0,0,0,0,0,0,0,0,-4,-2,4,2,0,0,0,0,-3,3,-3,3,0,0,0,0,-2,-1,-2,-1,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,-4,-4,4,0,0,0,0,0,0,0,0,0,0,0,0,2,2,-2,-2,0,0,0,0,2,-2,2,-2,0,0,0,0,1,1,1,1,0,0,0,0 },\n+        {-3,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,-3,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 9,-9,0,0,-9,9,0,0,6,3,0,0,-6,-3,0,0,0,0,0,0,0,0,0,0,6,-6,0,0,3,-3,0,0,0,0,0,0,0,0,0,0,4,2,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { -6,6,0,0,6,-6,0,0,-3,-3,0,0,3,3,0,0,0,0,0,0,0,0,0,0,-4,4,0,0,-2,2,0,0,0,0,0,0,0,0,0,0,-2,-2,0,0,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,0,0,-1,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,-9,0,0,-9,9,0,0,0,0,0,0,0,0,0,0,6,3,0,0,-6,-3,0,0,0,0,0,0,0,0,0,0,6,-6,0,0,3,-3,0,0,4,2,0,0,2,1,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-6,6,0,0,6,-6,0,0,0,0,0,0,0,0,0,0,-3,-3,0,0,3,3,0,0,0,0,0,0,0,0,0,0,-4,4,0,0,-2,2,0,0,-2,-2,0,0,-1,-1,0,0 },\n+        { 9,0,-9,0,-9,0,9,0,0,0,0,0,0,0,0,0,6,0,3,0,-6,0,-3,0,6,0,-6,0,3,0,-3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,2,0,2,0,1,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,9,0,-9,0,-9,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,3,0,-6,0,-3,0,6,0,-6,0,3,0,-3,0,0,0,0,0,0,0,0,0,4,0,2,0,2,0,1,0 },\n+        { -27,27,27,-27,27,-27,-27,27,-18,-9,18,9,18,9,-18,-9,-18,18,-9,9,18,-18,9,-9,-18,18,18,-18,-9,9,9,-9,-12,-6,-6,-3,12,6,6,3,-12,-6,12,6,-6,-3,6,3,-12,12,-6,6,-6,6,-3,3,-8,-4,-4,-2,-4,-2,-2,-1 },\n+        { 18,-18,-18,18,-18,18,18,-18,9,9,-9,-9,-9,-9,9,9,12,-12,6,-6,-12,12,-6,6,12,-12,-12,12,6,-6,-6,6,6,6,3,3,-6,-6,-3,-3,6,6,-6,-6,3,3,-3,-3,8,-8,4,-4,4,-4,2,-2,4,4,2,2,2,2,1,1 },\n+        { -6,0,6,0,6,0,-6,0,0,0,0,0,0,0,0,0,-3,0,-3,0,3,0,3,0,-4,0,4,0,-2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-2,0,-1,0,-1,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,-6,0,6,0,6,0,-6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-3,0,-3,0,3,0,3,0,-4,0,4,0,-2,0,2,0,0,0,0,0,0,0,0,0,-2,0,-2,0,-1,0,-1,0 },\n+        { 18,-18,-18,18,-18,18,18,-18,12,6,-12,-6,-12,-6,12,6,9,-9,9,-9,-9,9,-9,9,12,-12,-12,12,6,-6,-6,6,6,3,6,3,-6,-3,-6,-3,8,4,-8,-4,4,2,-4,-2,6,-6,6,-6,3,-3,3,-3,4,2,4,2,2,1,2,1 },\n+        { -12,12,12,-12,12,-12,-12,12,-6,-6,6,6,6,6,-6,-6,-6,6,-6,6,6,-6,6,-6,-8,8,8,-8,-4,4,4,-4,-3,-3,-3,-3,3,3,3,3,-4,-4,4,4,-2,-2,2,2,-4,4,-4,4,-2,2,-2,2,-2,-2,-2,-2,-1,-1,-1,-1 },\n+        { 2,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,2,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { -6,6,0,0,6,-6,0,0,-4,-2,0,0,4,2,0,0,0,0,0,0,0,0,0,0,-3,3,0,0,-3,3,0,0,0,0,0,0,0,0,0,0,-2,-1,0,0,-2,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 4,-4,0,0,-4,4,0,0,2,2,0,0,-2,-2,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,2,-2,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-6,6,0,0,6,-6,0,0,0,0,0,0,0,0,0,0,-4,-2,0,0,4,2,0,0,0,0,0,0,0,0,0,0,-3,3,0,0,-3,3,0,0,-2,-1,0,0,-2,-1,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,-4,0,0,-4,4,0,0,0,0,0,0,0,0,0,0,2,2,0,0,-2,-2,0,0,0,0,0,0,0,0,0,0,2,-2,0,0,2,-2,0,0,1,1,0,0,1,1,0,0 },\n+        { -6,0,6,0,6,0,-6,0,0,0,0,0,0,0,0,0,-4,0,-2,0,4,0,2,0,-3,0,3,0,-3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-2,0,-1,0,-2,0,-1,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,-6,0,6,0,6,0,-6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-4,0,-2,0,4,0,2,0,-3,0,3,0,-3,0,3,0,0,0,0,0,0,0,0,0,-2,0,-1,0,-2,0,-1,0 },\n+        { 18,-18,-18,18,-18,18,18,-18,12,6,-12,-6,-12,-6,12,6,12,-12,6,-6,-12,12,-6,6,9,-9,-9,9,9,-9,-9,9,8,4,4,2,-8,-4,-4,-2,6,3,-6,-3,6,3,-6,-3,6,-6,3,-3,6,-6,3,-3,4,2,2,1,4,2,2,1 },\n+        { -12,12,12,-12,12,-12,-12,12,-6,-6,6,6,6,6,-6,-6,-8,8,-4,4,8,-8,4,-4,-6,6,6,-6,-6,6,6,-6,-4,-4,-2,-2,4,4,2,2,-3,-3,3,3,-3,-3,3,3,-4,4,-2,2,-4,4,-2,2,-2,-2,-1,-1,-2,-2,-1,-1 },\n+        { 4,0,-4,0,-4,0,4,0,0,0,0,0,0,0,0,0,2,0,2,0,-2,0,-2,0,2,0,-2,0,2,0,-2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,4,0,-4,0,-4,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,-2,0,-2,0,2,0,-2,0,2,0,-2,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0 },\n+        { -12,12,12,-12,12,-12,-12,12,-8,-4,8,4,8,4,-8,-4,-6,6,-6,6,6,-6,6,-6,-6,6,6,-6,-6,6,6,-6,-4,-2,-4,-2,4,2,4,2,-4,-2,4,2,-4,-2,4,2,-3,3,-3,3,-3,3,-3,3,-2,-1,-2,-1,-2,-1,-2,-1 },\n+        { 8,-8,-8,8,-8,8,8,-8,4,4,-4,-4,-4,-4,4,4,4,-4,4,-4,-4,4,-4,4,4,-4,-4,4,4,-4,-4,4,2,2,2,2,-2,-2,-2,-2,2,2,-2,-2,2,2,-2,-2,2,-2,2,-2,2,-2,2,-2,1,1,1,1,1,1,1,1 }\n+    };\n+\n+    /** Samples x-coordinates */\n+    private final double[] xval;\n+    /** Samples y-coordinates */\n+    private final double[] yval;\n+    /** Samples z-coordinates */\n+    private final double[] zval;\n+    /** Set of cubic splines pacthing the whole data grid */\n+    private final TricubicSplineFunction[][][] splines;\n+\n+    /**\n+     * @param x Sample values of the x-coordinate, in increasing order.\n+     * @param y Sample values of the y-coordinate, in increasing order.\n+     * @param z Sample values of the y-coordinate, in increasing order.\n+     * @param f Values of the function on every grid point.\n+     * @param dFdX Values of the partial derivative of function with respect\n+     * to x on every grid point.\n+     * @param dFdY Values of the partial derivative of function with respect\n+     * to y on every grid point.\n+     * @param d2FdXdY Values of the cross partial derivative of function on\n+     * every grid point.\n+     * @param d2FdXdZ Values of the cross partial derivative of function on\n+     * every grid point.\n+     * @param d2FdYdZ Values of the cross partial derivative of function on\n+     * every grid point.\n+     * @param d3FdXdYdZ Values of the cross partial derivative of function on\n+     * every grid point.\n+     * @throws DimensionMismatchException if the various arrays do not contain\n+     * the expected number of elements.\n+     * @throws IllegalArgumentException if {@code x}, {@code y} or {@code z}\n+     * are not strictly increasing.\n+     */\n+    public TricubicSplineInterpolatingFunction(double[] x,\n+                                               double[] y,\n+                                               double[] z,\n+                                               double[][][] f,\n+                                               double[][][] dFdX,\n+                                               double[][][] dFdY,\n+                                               double[][][] dFdZ,\n+                                               double[][][] d2FdXdY,\n+                                               double[][][] d2FdXdZ,\n+                                               double[][][] d2FdYdZ,\n+                                               double[][][] d3FdXdYdZ)\n+        throws DimensionMismatchException {\n+        final int xLen = x.length;\n+        final int yLen = y.length;\n+        final int zLen = z.length;\n+\n+        if (xLen == 0 || yLen == 0 || z.length == 0\n+            || f.length == 0 || f[0].length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+        }\n+        if (xLen != f.length) {\n+            throw new DimensionMismatchException(xLen, f.length);\n+        }\n+        if (xLen != dFdX.length) {\n+            throw new DimensionMismatchException(xLen, dFdX.length);\n+        }\n+        if (xLen != dFdY.length) {\n+            throw new DimensionMismatchException(xLen, dFdY.length);\n+        }\n+        if (xLen != dFdZ.length) {\n+            throw new DimensionMismatchException(xLen, dFdZ.length);\n+        }\n+        if (xLen != d2FdXdY.length) {\n+            throw new DimensionMismatchException(xLen, d2FdXdY.length);\n+        }\n+        if (xLen != d2FdXdZ.length) {\n+            throw new DimensionMismatchException(xLen, d2FdXdZ.length);\n+        }\n+        if (xLen != d2FdYdZ.length) {\n+            throw new DimensionMismatchException(xLen, d2FdYdZ.length);\n+        }\n+        if (xLen != d3FdXdYdZ.length) {\n+            throw new DimensionMismatchException(xLen, d3FdXdYdZ.length);\n+        }\n+\n+        MathUtils.checkOrder(x, 1, true);\n+        MathUtils.checkOrder(y, 1, true);\n+        MathUtils.checkOrder(z, 1, true);\n+\n+        xval = x.clone();\n+        yval = y.clone();\n+        zval = z.clone();\n+\n+        final int lastI = xLen - 1;\n+        final int lastJ = yLen - 1;\n+        final int lastK = zLen - 1;\n+        splines = new TricubicSplineFunction[lastI][lastJ][lastK];\n+\n+        for (int i = 0; i < lastI; i++) {\n+            if (f[i].length != yLen) {\n+                throw new DimensionMismatchException(f[i].length, yLen);\n+            }\n+            if (dFdX[i].length != yLen) {\n+                throw new DimensionMismatchException(dFdX[i].length, yLen);\n+            }\n+            if (dFdY[i].length != yLen) {\n+                throw new DimensionMismatchException(dFdY[i].length, yLen);\n+            }\n+            if (dFdZ[i].length != yLen) {\n+                throw new DimensionMismatchException(dFdZ[i].length, yLen);\n+            }\n+            if (d2FdXdY[i].length != yLen) {\n+                throw new DimensionMismatchException(d2FdXdY[i].length, yLen);\n+            }\n+            if (d2FdXdZ[i].length != yLen) {\n+                throw new DimensionMismatchException(d2FdXdZ[i].length, yLen);\n+            }\n+            if (d2FdYdZ[i].length != yLen) {\n+                throw new DimensionMismatchException(d2FdYdZ[i].length, yLen);\n+            }\n+            if (d3FdXdYdZ[i].length != yLen) {\n+                throw new DimensionMismatchException(d3FdXdYdZ[i].length, yLen);\n+            }\n+\n+            final int ip1 = i + 1;\n+            for (int j = 0; j < lastJ; j++) {\n+                if (f[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(f[i][j].length, zLen);\n+                }\n+                if (dFdX[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(dFdX[i][j].length, zLen);\n+                }\n+                if (dFdY[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(dFdY[i][j].length, zLen);\n+                }\n+                if (dFdZ[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(dFdZ[i][j].length, zLen);\n+                }\n+                if (d2FdXdY[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(d2FdXdY[i][j].length, zLen);\n+                }\n+                if (d2FdXdZ[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(d2FdXdZ[i][j].length, zLen);\n+                }\n+                if (d2FdYdZ[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(d2FdYdZ[i][j].length, zLen);\n+                }\n+                if (d3FdXdYdZ[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(d3FdXdYdZ[i][j].length, zLen);\n+                }\n+\n+                final int jp1 = j + 1;\n+                for (int k = 0; k < lastK; k++) {\n+                    final int kp1 = k + 1;\n+\n+                    final double[] beta = new double[] {\n+                        f[i][j][k], f[ip1][j][k],\n+                        f[i][jp1][k], f[ip1][jp1][k],\n+                        f[i][j][kp1], f[ip1][j][kp1],\n+                        f[i][jp1][kp1], f[ip1][jp1][kp1],\n+\n+                        dFdX[i][j][k], dFdX[ip1][j][k],\n+                        dFdX[i][jp1][k], dFdX[ip1][jp1][k],\n+                        dFdX[i][j][kp1], dFdX[ip1][j][kp1],\n+                        dFdX[i][jp1][kp1], dFdX[ip1][jp1][kp1],\n+\n+                        dFdY[i][j][k], dFdY[ip1][j][k],\n+                        dFdY[i][jp1][k], dFdY[ip1][jp1][k],\n+                        dFdY[i][j][kp1], dFdY[ip1][j][kp1],\n+                        dFdY[i][jp1][kp1], dFdY[ip1][jp1][kp1],\n+\n+                        dFdZ[i][j][k], dFdZ[ip1][j][k],\n+                        dFdZ[i][jp1][k], dFdZ[ip1][jp1][k],\n+                        dFdZ[i][j][kp1], dFdZ[ip1][j][kp1],\n+                        dFdZ[i][jp1][kp1], dFdZ[ip1][jp1][kp1],\n+                        \n+                        d2FdXdY[i][j][k], d2FdXdY[ip1][j][k],\n+                        d2FdXdY[i][jp1][k], d2FdXdY[ip1][jp1][k],\n+                        d2FdXdY[i][j][kp1], d2FdXdY[ip1][j][kp1],\n+                        d2FdXdY[i][jp1][kp1], d2FdXdY[ip1][jp1][kp1],\n+\n+                        d2FdXdZ[i][j][k], d2FdXdZ[ip1][j][k],\n+                        d2FdXdZ[i][jp1][k], d2FdXdZ[ip1][jp1][k],\n+                        d2FdXdZ[i][j][kp1], d2FdXdZ[ip1][j][kp1],\n+                        d2FdXdZ[i][jp1][kp1], d2FdXdZ[ip1][jp1][kp1],\n+\n+                        d2FdYdZ[i][j][k], d2FdYdZ[ip1][j][k],\n+                        d2FdYdZ[i][jp1][k], d2FdYdZ[ip1][jp1][k],\n+                        d2FdYdZ[i][j][kp1], d2FdYdZ[ip1][j][kp1],\n+                        d2FdYdZ[i][jp1][kp1], d2FdYdZ[ip1][jp1][kp1],\n+\n+                        d3FdXdYdZ[i][j][k], d3FdXdYdZ[ip1][j][k],\n+                        d3FdXdYdZ[i][jp1][k], d3FdXdYdZ[ip1][jp1][k],\n+                        d3FdXdYdZ[i][j][kp1], d3FdXdYdZ[ip1][j][kp1],\n+                        d3FdXdYdZ[i][jp1][kp1], d3FdXdYdZ[ip1][jp1][kp1],\n+                    };\n+\n+                    splines[i][j][k] = new TricubicSplineFunction(computeSplineCoefficients(beta));\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double value(double x, double y, double z) {\n+        final int i = searchIndex(x, xval);\n+        if (i == -1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      x, xval[0], xval[xval.length - 1]);\n+        }\n+        final int j = searchIndex(y, yval);\n+        if (j == -1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      y, yval[0], yval[yval.length - 1]);\n+        }\n+        final int k = searchIndex(z, zval);\n+        if (k == -1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      z, zval[0], zval[zval.length - 1]);\n+        }\n+\n+        final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n+        final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]);\n+        final double zN = (z - zval[k]) / (zval[k + 1] - zval[k]);\n+\n+        return splines[i][j][k].value(xN, yN, zN);\n+    }\n+\n+    /**\n+     * @param c Coordinate.\n+     * @param val Coordinate samples.\n+     * @return the index in {@code val} corresponding to the interval\n+     * containing {@code c}, or {@code -1} if {@code c} is out of the\n+     * range defined by the end values of {@code val}.\n+     */\n+    private int searchIndex(double c, double[] val) {\n+        if (c < val[0]) {\n+            return -1;\n+        }\n+\n+        final int max = val.length;\n+        for (int i = 1; i < max; i++) {\n+            if (c <= val[i]) {\n+                return i - 1;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    /**\n+     * Compute the spline coefficients from the list of function values and\n+     * function partial derivatives values at the four corners of a grid\n+     * element. They must be specified in the following order:\n+     * <ul>\n+     *  <li>f(0,0,0)</li>\n+     *  <li>f(1,0,0)</li>\n+     *  <li>f(0,1,0)</li>\n+     *  <li>f(1,1,0)</li>\n+     *  <li>f(0,0,1)</li>\n+     *  <li>f(1,0,1)</li>\n+     *  <li>f(0,1,1)</li>\n+     *  <li>f(1,1,1)</li>\n+     *\n+     *  <li>f<sub>x</sub>(0,0,0)</li>\n+     *  <li>... <em>(same order as above)</em></li>\n+     *  <li>f<sub>x</sub>(1,1,1)</li>\n+     *\n+     *  <li>f<sub>y</sub>(0,0,0)</li>\n+     *  <li>... <em>(same order as above)</em></li>\n+     *  <li>f<sub>y</sub>(1,1,1)</li>\n+     *\n+     *  <li>f<sub>z</sub>(0,0,0)</li>\n+     *  <li>... <em>(same order as above)</em></li>\n+     *  <li>f<sub>z</sub>(1,1,1)</li>\n+     *\n+     *  <li>f<sub>xy</sub>(0,0,0)</li>\n+     *  <li>... <em>(same order as above)</em></li>\n+     *  <li>f<sub>xy</sub>(1,1,1)</li>\n+     *\n+     *  <li>f<sub>xz</sub>(0,0,0)</li>\n+     *  <li>... <em>(same order as above)</em></li>\n+     *  <li>f<sub>xz</sub>(1,1,1)</li>\n+     *\n+     *  <li>f<sub>yz</sub>(0,0,0)</li>\n+     *  <li>... <em>(same order as above)</em></li>\n+     *  <li>f<sub>yz</sub>(1,1,1)</li>\n+     *\n+     *  <li>f<sub>xyz</sub>(0,0,0)</li>\n+     *  <li>... <em>(same order as above)</em></li>\n+     *  <li>f<sub>xyz</sub>(1,1,1)</li>\n+     * </ul>\n+     * where the subscripts indicate the partial derivative with respect to\n+     * the corresponding variable(s).\n+     *\n+     * @param beta List of function values and function partial derivatives\n+     * values.\n+     * @return the spline coefficients.\n+     */\n+    private double[] computeSplineCoefficients(double[] beta) {\n+        final int sz = 64;\n+        final double[] a = new double[sz];\n+\n+        for (int i = 0; i < sz; i++) {\n+            double result = 0;\n+            final double[] row = AINV[i];\n+            for (int j = 0; j < sz; j++) {\n+                result += row[j] * beta[j];\n+            }\n+            a[i] = result;\n+        }\n+\n+        return a;\n+    }\n+}\n+\n+/**\n+ * 3D-spline function.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+class TricubicSplineFunction\n+    implements TrivariateRealFunction {\n+    private static final short N = 4;\n+    private static final short N2 = N * N;\n+    /** Coefficients */\n+    private final double[][][] a = new double[N][N][N];\n+\n+    /**\n+     * @param aV List of spline coefficients.\n+     */\n+    public TricubicSplineFunction(double[] aV) {\n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                for (int k = 0; k < N; k++) {\n+                    a[i][j][k] = aV[i + N * j + N2 * k];\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param x x-coordinate of the interpolation point.\n+     * @param y y-coordinate of the interpolation point.\n+     * @param z z-coordinate of the interpolation point.\n+     * @return the interpolated value.\n+     */\n+    public double value(double x, double y, double z) {\n+        if (x < 0 || x > 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      x, 0, 1);\n+        }\n+        if (y < 0 || y > 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      y, 0, 1);\n+        }\n+        if (z < 0 || z > 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      z, 0, 1);\n+        }\n+\n+        final double x2 = x * x;\n+        final double x3 = x2 * x;\n+        final double[] pX = { 1, x, x2, x3 };\n+\n+        final double y2 = y * y;\n+        final double y3 = y2 * y;\n+        final double[] pY = { 1, y, y2, y3 };\n+\n+        final double z2 = z * z;\n+        final double z3 = z2 * z;\n+        final double[] pZ = { 1, z, z2, z3 };\n+\n+        double result = 0;\n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                for (int k = 0; k < N; k++) {\n+                    result += a[i][j][k] * pX[i] * pY[j] * pZ[k];\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+/**\n+ * Generates a tricubic interpolating function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public class TricubicSplineInterpolator\n+    implements TrivariateRealGridInterpolator {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public TricubicSplineInterpolatingFunction interpolate(final double[] xval,\n+                                                           final double[] yval,\n+                                                           final double[] zval,\n+                                                           final double[][][] fval)\n+        throws MathException, IllegalArgumentException {\n+        if (xval.length == 0 || yval.length == 0 || zval.length == 0 || fval.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+        }\n+        if (xval.length != fval.length) {\n+            throw new DimensionMismatchException(xval.length, fval.length);\n+        }\n+\n+        MathUtils.checkOrder(xval, 1, true);\n+        MathUtils.checkOrder(yval, 1, true);\n+        MathUtils.checkOrder(zval, 1, true);\n+\n+        final int xLen = xval.length;\n+        final int yLen = yval.length;\n+        final int zLen = zval.length;\n+\n+        // Samples, re-ordered as (z, x, y) and (y, z, x) tuplets\n+        // fvalXY[k][i][j] = f(xval[i], yval[j], zval[k])\n+        // fvalZX[j][k][i] = f(xval[i], yval[j], zval[k])\n+        final double[][][] fvalXY = new double[zLen][xLen][yLen];\n+        final double[][][] fvalZX = new double[yLen][zLen][xLen];\n+        for (int i = 0; i < xLen; i++) {\n+            if (fval[i].length != yLen) {\n+                throw new DimensionMismatchException(fval[i].length, yLen);\n+            }\n+\n+            for (int j = 0; j < yLen; j++) {\n+                if (fval[i][j].length != zLen) {\n+                    throw new DimensionMismatchException(fval[i][j].length, zLen);\n+                }\n+                \n+                for (int k = 0; k < zLen; k++) {\n+                    final double v = fval[i][j][k];\n+                    fvalXY[k][i][j] = v;\n+                    fvalZX[j][k][i] = v;\n+                }\n+            }\n+        }\n+\n+        final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator();\n+\n+        // For each line x[i] (0 <= i < xLen), construct a 2D spline in y and z\n+        final BicubicSplineInterpolatingFunction[] xSplineYZ\n+            = new BicubicSplineInterpolatingFunction[xLen];\n+        for (int i = 0; i < xLen; i++) {\n+            xSplineYZ[i] = bsi.interpolate(yval, zval, fval[i]);\n+        }\n+\n+        // For each line y[j] (0 <= j < yLen), construct a 2D spline in z and x\n+        final BicubicSplineInterpolatingFunction[] ySplineZX\n+            = new BicubicSplineInterpolatingFunction[yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            ySplineZX[j] = bsi.interpolate(zval, xval, fvalZX[j]);\n+        }\n+\n+        // For each line z[k] (0 <= k < zLen), construct a 2D spline in x and y\n+        final BicubicSplineInterpolatingFunction[] zSplineXY\n+            = new BicubicSplineInterpolatingFunction[zLen];\n+        for (int k = 0; k < zLen; k++) {\n+            zSplineXY[k] = bsi.interpolate(xval, yval, fvalXY[k]);\n+        }\n+\n+        // Partial derivatives wrt x and wrt y\n+        final double[][][] dFdX = new double[xLen][yLen][zLen];\n+        final double[][][] dFdY = new double[xLen][yLen][zLen];\n+        final double[][][] d2FdXdY = new double[xLen][yLen][zLen];\n+        for (int k = 0; k < zLen; k++) {\n+            final BicubicSplineInterpolatingFunction f = zSplineXY[k];\n+            for (int i = 0; i < xLen; i++) {\n+                final double x = xval[i];\n+                for (int j = 0; j < yLen; j++) {\n+                    final double y = yval[j];\n+                    dFdX[i][j][k] = f.partialDerivativeX(x, y);\n+                    dFdY[i][j][k] = f.partialDerivativeY(x, y);\n+                    d2FdXdY[i][j][k] = f.partialDerivativeXY(x, y);\n+                }\n+            }\n+        }\n+\n+        // Partial derivatives wrt y and wrt z\n+        final double[][][] dFdZ = new double[xLen][yLen][zLen];\n+        final double[][][] d2FdYdZ = new double[xLen][yLen][zLen];\n+        for (int i = 0; i < xLen; i++) {\n+            final BicubicSplineInterpolatingFunction f = xSplineYZ[i];\n+            for (int j = 0; j < yLen; j++) {\n+                final double y = yval[j];\n+                for (int k = 0; k < zLen; k++) {\n+                    final double z = zval[k];\n+                    dFdZ[i][j][k] = f.partialDerivativeY(y, z);\n+                    d2FdYdZ[i][j][k] = f.partialDerivativeXY(y, z);\n+                }\n+            }\n+        }\n+\n+        // Partial derivatives wrt x and wrt z\n+        final double[][][] d2FdZdX = new double[xLen][yLen][zLen];\n+        for (int j = 0; j < yLen; j++) {\n+            final BicubicSplineInterpolatingFunction f = ySplineZX[j];\n+            for (int k = 0; k < zLen; k++) {\n+                final double z = zval[k];\n+                for (int i = 0; i < xLen; i++) {\n+                    final double x = xval[i];\n+                    d2FdZdX[i][j][k] = f.partialDerivativeXY(z, x);\n+                }\n+            }\n+        }\n+\n+        // Third partial cross-derivatives\n+        final double[][][] d3FdXdYdZ = new double[xLen][yLen][zLen];\n+        for (int i = 0; i < xLen ; i++) {\n+            final int nI = nextIndex(i, xLen);\n+            final int pI = previousIndex(i);\n+            for (int j = 0; j < yLen; j++) {\n+                final int nJ = nextIndex(j, yLen);\n+                final int pJ = previousIndex(j);\n+                for (int k = 0; k < zLen; k++) {\n+                    final int nK = nextIndex(k, zLen);\n+                    final int pK = previousIndex(k);\n+                    \n+                    // XXX Not sure about this formula\n+                    d3FdXdYdZ[i][j][k] = (fval[nI][nJ][nK] - fval[nI][pJ][nK] -\n+                                          fval[pI][nJ][nK] + fval[pI][pJ][nK] -\n+                                          fval[nI][nJ][pK] + fval[nI][pJ][pK] +\n+                                          fval[pI][nJ][pK] - fval[pI][pJ][pK]) /\n+                        ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ]) * (zval[nK] - zval[pK])) ;\n+                }\n+            }\n+        }\n+\n+        // Create the interpolating splines\n+        return new TricubicSplineInterpolatingFunction(xval, yval, zval, fval,\n+                                                       dFdX, dFdY, dFdZ,\n+                                                       d2FdXdY, d2FdZdX, d2FdYdZ,\n+                                                       d3FdXdYdZ);\n+    }\n+\n+    /**\n+     * Compute the next index of an array, clipping if necessary.\n+     * It is assumed (but not checked) that {@code i} is larger than or equal to 0}.\n+     *\n+     * @param i Index\n+     * @param max Upper limit of the array\n+     * @return the next index\n+     */\n+    private int nextIndex(int i, int max) {\n+        final int index = i + 1;\n+        return index < max ? index : index - 1;\n+    }\n+    /**\n+     * Compute the previous index of an array, clipping if necessary.\n+     * It is assumed (but not checked) that {@code i} is smaller than the size of the array.\n+     *\n+     * @param i Index\n+     * @return the previous index\n+     */\n+    private int previousIndex(int i) {\n+        final int index = i - 1;\n+        return index >= 0 ? index : 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateRealGridInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.TrivariateRealFunction;\n+\n+/**\n+ * Interface representing a trivariate real interpolating function where the\n+ * sample points must be specified on a regular grid.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface TrivariateRealGridInterpolator {\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param xval All the x-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param yval All the y-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param zval All the z-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param fval the values of the interpolation points on all the grid knots:\n+     * {@code fval[i][j][k] = f(xval[i], yval[j], zval[k])}.\n+     * @return a function which interpolates the data set.\n+     * @throws MathException if arguments violate assumptions made by the\n+     *         interpolation algorithm.\n+     */\n+    TrivariateRealFunction interpolate(double[] xval, double[] yval, double[] zval, double[][][] fval)\n+        throws MathException;\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n         Assert.assertEquals(\"Half-way between sample points (border of the patch)\",\n                             expected, result, 2);\n     }\n+\n+    /**\n+     * Test for partial derivatives of {@link BicubicSplineFunction}.\n+     * <p>\n+     * f(x, y) = &Sigma;<sub>i</sub>&Sigma;<sub>j</sub> (i+1) (j+2) x<sup>i</sup> y<sup>j</sup>\n+     */\n+    @Test\n+    public void testSplinePartialDerivatives() throws MathException {\n+        final int N = 4;\n+        final double[] coeff = new double[16];\n+\n+        for (int i = 0; i < N; i++) {\n+            for (int j = 0; j < N; j++) {\n+                final int index = i + N * j;\n+                coeff[i + N * j] = (i + 1) * (j + 2);\n+            }\n+        }\n+\n+        final BicubicSplineFunction f = new BicubicSplineFunction(coeff);\n+        BivariateRealFunction derivative;\n+        final double x = 0.435;\n+        final double y = 0.776;\n+        final double tol = 1e-13;\n+\n+        derivative = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double x2 = x * x;\n+                    final double y2 = y * y;\n+                    final double y3 = y2 * y;\n+                    final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3;\n+                    return yFactor * (2 + 6 * x + 12 * x2);\n+                }\n+            };\n+        Assert.assertEquals(\"dFdX\", derivative.value(x, y),\n+                            f.partialDerivativeX().value(x, y), tol);\n+        \n+        derivative = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double x2 = x * x;\n+                    final double x3 = x2 * x;\n+                    final double y2 = y * y;\n+                    final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3;\n+                    return xFactor * (3 + 8 * y + 15 * y2);\n+                }\n+            };\n+        Assert.assertEquals(\"dFdY\", derivative.value(x, y),\n+                            f.partialDerivativeY().value(x, y), tol);\n+\n+        derivative = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double y2 = y * y;\n+                    final double y3 = y2 * y;\n+                    final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3;\n+                    return yFactor * (6 + 24 * x);\n+                }\n+            };\n+        Assert.assertEquals(\"d2FdX2\", derivative.value(x, y),\n+                            f.partialDerivativeXX().value(x, y), tol);\n+\n+        derivative = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double x2 = x * x;\n+                    final double x3 = x2 * x;\n+                    final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3;\n+                    return xFactor * (8 + 30 * y);\n+                }\n+            };\n+        Assert.assertEquals(\"d2FdY2\", derivative.value(x, y),\n+                            f.partialDerivativeYY().value(x, y), tol);\n+\n+        derivative = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double x2 = x * x;\n+                    final double y2 = y * y;\n+                    final double yFactor = 3 + 8 * y + 15 * y2;\n+                    return yFactor * (2 + 6 * x + 12 * x2);\n+                }\n+            };\n+        Assert.assertEquals(\"d2FdXdY\", derivative.value(x, y),\n+                            f.partialDerivativeXY().value(x, y), tol);\n+    }\n+\n+    /**\n+     * Test that the partial derivatives computed from a\n+     * {@link BicubicSplineInterpolatingFunction} match the input data.\n+     * <p>\n+     * f(x, y) = 5\n+     *           - 3 x + 2 y\n+     *           - x y + 2 x<sup>2</sup> - 3 y<sup>2</sup>\n+     *           + 4 x<sup>2</sup> y - x y<sup>2</sup> - 3 x<sup>3</sup> + y<sup>3</sup>\n+     */\n+    @Test\n+    public void testMatchingPartialDerivatives() throws MathException {\n+        final int sz = 21;\n+        double[] val = new double[sz];\n+        // Coordinate values\n+        final double delta = 1d / (sz - 1);\n+        for (int i = 0; i < sz; i++) {\n+            val[i] = i * delta;\n+        }\n+        // Function values\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double x2 = x * x;\n+                    final double x3 = x2 * x;\n+                    final double y2 = y * y;\n+                    final double y3 = y2 * y;\n+\n+                    return 5\n+                        - 3 * x + 2 * y\n+                        - x * y + 2 * x2 - 3 * y2\n+                        + 4 * x2 * y - x * y2 - 3 * x3 + y3;\n+                }\n+            };\n+        double[][] fval = new double[sz][sz];\n+        for (int i = 0; i < sz; i++) {\n+            for (int j = 0; j < sz; j++) {\n+                fval[i][j] = f.value(val[i], val[j]);\n+            }\n+        }\n+        // Partial derivatives with respect to x\n+        double[][] dFdX = new double[sz][sz];\n+        BivariateRealFunction dfdX = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double x2 = x * x;\n+                    final double y2 = y * y;                    \n+                    return - 3 - y + 4 * x + 8 * x * y - y2 - 9 * x2;\n+                }\n+            };\n+        for (int i = 0; i < sz; i++) {\n+            for (int j = 0; j < sz; j++) {\n+                dFdX[i][j] = dfdX.value(val[i], val[j]);\n+            }\n+        }\n+        // Partial derivatives with respect to y\n+        double[][] dFdY = new double[sz][sz];\n+        BivariateRealFunction dfdY = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    final double x2 = x * x;\n+                    final double y2 = y * y;                    \n+                    return 2 - x - 6 * y + 4 * x2 - 2 * x * y + 3 * y2;\n+                }\n+            };\n+        for (int i = 0; i < sz; i++) {\n+            for (int j = 0; j < sz; j++) {\n+                dFdY[i][j] = dfdY.value(val[i], val[j]);\n+            }\n+        }\n+        // Partial cross-derivatives\n+        double[][] d2FdXdY = new double[sz][sz];\n+        BivariateRealFunction d2fdXdY = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return -1 + 8 * x - 2 * y;\n+                }\n+            };\n+        for (int i = 0; i < sz; i++) {\n+            for (int j = 0; j < sz; j++) {\n+                d2FdXdY[i][j] = d2fdXdY.value(val[i], val[j]);\n+            }\n+        }\n+\n+        BicubicSplineInterpolatingFunction bcf\n+            = new BicubicSplineInterpolatingFunction(val, val, fval, dFdX, dFdY, d2FdXdY);\n+\n+        double x, y;\n+        double expected, result;\n+\n+        final double tol = 1e-12;\n+        for (int i = 0; i < sz; i++) {\n+            x = val[i];\n+            for (int j = 0; j < sz; j++) {\n+                y = val[j];\n+                \n+                expected = dfdX.value(x, y);\n+                result = bcf.partialDerivativeX(x, y);\n+                Assert.assertEquals(x + \" \" + y + \" dFdX\", expected, result, tol);\n+\n+                expected = dfdY.value(x, y);\n+                result = bcf.partialDerivativeY(x, y);\n+                Assert.assertEquals(x + \" \" + y + \" dFdY\", expected, result, tol);\n+                \n+                expected = d2fdXdY.value(x, y);\n+                result = bcf.partialDerivativeXY(x, y);\n+                Assert.assertEquals(x + \" \" + y + \" d2FdXdY\", expected, result, tol);\n+            }\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatingFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.TrivariateRealFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for the bicubic function.\n+ * \n+ * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n+ */\n+public final class TricubicSplineInterpolatingFunctionTest {\n+    /**\n+     * Test preconditions.\n+     */\n+    @Test\n+    public void testPreconditions() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2.5};\n+        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};\n+        double[][][] fval = new double[xval.length][yval.length][zval.length];\n+\n+        @SuppressWarnings(\"unused\")\n+        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                                             fval, fval, fval, fval,\n+                                                                             fval, fval, fval, fval);\n+        \n+        double[] wxval = new double[] {3, 2, 5, 6.5};\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(wxval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        double[] wyval = new double[] {-4, -1, -1, 2.5};\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, wyval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        double[] wzval = new double[] {-12, -8, -9, -3, 0, 2.5};\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, wzval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        double[][][] wfval = new double[xval.length - 1][yval.length - 1][zval.length];\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          wfval, fval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, wfval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, wfval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, wfval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          wfval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, wfval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, wfval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, fval, wfval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wfval = new double[xval.length][yval.length - 1][zval.length];\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          wfval, fval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, wfval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, wfval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, wfval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          wfval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, wfval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, wfval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, fval, wfval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wfval = new double[xval.length][yval.length][zval.length - 1];\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          wfval, fval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, wfval, fval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, wfval, fval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, wfval,\n+                                                          fval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          wfval, fval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, wfval, fval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, wfval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                          fval, fval, fval, fval,\n+                                                          fval, fval, fval, wfval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Test for a plane.\n+     * <p>\n+     *  f(x, y, z) = 2 x - 3 y - 4 z + 5\n+     * </p>\n+     */\n+    @Test\n+    public void testPlane() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};\n+\n+        // Function values\n+        TrivariateRealFunction f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return 2 * x - 3 * y - 4 * z + 5;\n+                }\n+            };\n+\n+        double[][][] fval = new double[xval.length][yval.length][zval.length];\n+\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+        // Partial derivatives with respect to x\n+        double[][][] dFdX = new double[xval.length][yval.length][zval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    dFdX[i][j][k] = 2;\n+                }\n+            }\n+        }\n+        // Partial derivatives with respect to y\n+        double[][][] dFdY = new double[xval.length][yval.length][zval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    dFdY[i][j][k] = -3;\n+                }\n+            }\n+        }\n+\n+        // Partial derivatives with respect to z\n+        double[][][] dFdZ = new double[xval.length][yval.length][zval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    dFdZ[i][j][k] = -4;\n+                }\n+            }\n+        }\n+        // Partial cross-derivatives\n+        double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length];\n+        double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length];\n+        double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length];\n+        double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    d2FdXdY[i][j][k] = 0;\n+                    d2FdXdZ[i][j][k] = 0;\n+                    d2FdYdZ[i][j][k] = 0;\n+                    d3FdXdYdZ[i][j][k] = 0;\n+                }\n+            }\n+        }\n+\n+        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                                             fval, dFdX, dFdY, dFdZ,\n+                                                                             d2FdXdY, d2FdXdZ, d2FdYdZ,\n+                                                                             d3FdXdYdZ);\n+        double x, y, z;\n+        double expected, result;\n+\n+        x = 4;\n+        y = -3;\n+        z = 0;\n+        expected = f.value(x, y, z);\n+        result = tcf.value(x, y, z);\n+        Assert.assertEquals(\"On sample point\",\n+                            expected, result, 1e-15);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        z = -4.25;\n+        expected = f.value(x, y, z);\n+        result = tcf.value(x, y, z);\n+        Assert.assertEquals(\"Half-way between sample points (middle of the patch)\",\n+                            expected, result, 0.3);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        z = -10;\n+        expected = f.value(x, y, z);\n+        result = tcf.value(x, y, z);\n+        Assert.assertEquals(\"Half-way between sample points (border of the patch)\",\n+                            expected, result, 0.3);\n+    }\n+\n+    /**\n+     * Sine wave.\n+     * <p>\n+     *  f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y]\n+     * </p>\n+     * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1.\n+     */\n+    @Test\n+    public void testWave() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4};\n+        \n+        final double a = 0.2;\n+        final double omega = 0.5;\n+        final double kx = 2;\n+        final double ky = 1;\n+        \n+        // Function values\n+        TrivariateRealFunction f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return a * Math.cos(omega * z - kx * x - ky * y);\n+                }\n+            };\n+        \n+        double[][][] fval = new double[xval.length][yval.length][zval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+        \n+        // Partial derivatives with respect to x\n+        double[][][] dFdX = new double[xval.length][yval.length][zval.length];\n+        TrivariateRealFunction dFdX_f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return a * Math.sin(omega * z - kx * x - ky * y) * kx;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    dFdX[i][j][k] = dFdX_f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+            \n+        // Partial derivatives with respect to y\n+        double[][][] dFdY = new double[xval.length][yval.length][zval.length];\n+        TrivariateRealFunction dFdY_f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return a * Math.sin(omega * z - kx * x - ky * y) * ky;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    dFdY[i][j][k] = dFdY_f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        // Partial derivatives with respect to z\n+        double[][][] dFdZ = new double[xval.length][yval.length][zval.length];\n+        TrivariateRealFunction dFdZ_f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return -a * Math.sin(omega * z - kx * x - ky * y) * omega;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    dFdZ[i][j][k] = dFdZ_f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        // Partial second derivatives w.r.t. (x, y)\n+        double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length];\n+        TrivariateRealFunction d2FdXdY_f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return -a * Math.cos(omega * z - kx * x - ky * y) * kx * ky;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    d2FdXdY[i][j][k] = d2FdXdY_f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        // Partial second derivatives w.r.t. (x, z)\n+        double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length];\n+        TrivariateRealFunction d2FdXdZ_f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return a * Math.cos(omega * z - kx * x - ky * y) * kx * omega;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    d2FdXdZ[i][j][k] = d2FdXdZ_f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        // Partial second derivatives w.r.t. (y, z)\n+        double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length];\n+        TrivariateRealFunction d2FdYdZ_f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return a * Math.cos(omega * z - kx * x - ky * y) * ky * omega;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    d2FdYdZ[i][j][k] = d2FdYdZ_f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        // Partial third derivatives\n+        double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length];\n+        TrivariateRealFunction d3FdXdYdZ_f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return a * Math.sin(omega * z - kx * x - ky * y) * kx * ky * omega;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    d3FdXdYdZ[i][j][k] = d3FdXdYdZ_f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        TrivariateRealFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                                             fval, dFdX, dFdY, dFdZ,\n+                                                                             d2FdXdY, d2FdXdZ, d2FdYdZ,\n+                                                                             d3FdXdYdZ);\n+        double x, y, z;\n+        double expected, result;\n+        \n+        x = 4;\n+        y = -3;\n+        z = 0;\n+        expected = f.value(x, y, z);\n+        result = tcf.value(x, y, z);\n+        Assert.assertEquals(\"On sample point\",\n+                            expected, result, 1e-14);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        z = -4.25;\n+        expected = f.value(x, y, z);\n+        result = tcf.value(x, y, z);\n+        Assert.assertEquals(\"Half-way between sample points (middle of the patch)\",\n+                            expected, result, 0.1);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        z = -10;\n+        expected = f.value(x, y, z);\n+        result = tcf.value(x, y, z);\n+        Assert.assertEquals(\"Half-way between sample points (border of the patch)\",\n+                            expected, result, 0.1);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.TrivariateRealFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for the tricubic interpolator.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class TricubicSplineInterpolatorTest {\n+    /**\n+     * Test preconditions.\n+     */\n+    @Test\n+    public void testPreconditions() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2.5};\n+        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};\n+        double[][][] fval = new double[xval.length][yval.length][zval.length];\n+\n+        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();\n+        \n+        @SuppressWarnings(\"unused\")\n+        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);\n+        \n+        double[] wxval = new double[] {3, 2, 5, 6.5};\n+        try {\n+            p = interpolator.interpolate(wxval, yval, zval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[] wyval = new double[] {-4, -3, -1, -1};\n+        try {\n+            p = interpolator.interpolate(xval, wyval, zval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[] wzval = new double[] {-12, -8, -5.5, -3, -4, 2.5};\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval, fval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[][][] wfval = new double[xval.length][yval.length + 1][zval.length];\n+        try {\n+            p = interpolator.interpolate(xval, yval, zval, wfval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wfval = new double[xval.length - 1][yval.length][zval.length];\n+        try {\n+            p = interpolator.interpolate(xval, yval, zval, wfval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wfval = new double[xval.length][yval.length][zval.length - 1];\n+        try {\n+            p = interpolator.interpolate(xval, yval, zval, wfval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Test of interpolator for a plane.\n+     * <p>\n+     * f(x, y, z) = 2 x - 3 y - z + 5\n+     */\n+    @Test\n+    public void testPlane() throws MathException {\n+        TrivariateRealFunction f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return 2 * x - 3 * y - z + 5;\n+                }\n+            };\n+\n+        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();\n+\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};\n+        double[][][] fval = new double[xval.length][yval.length][zval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);\n+        double x, y, z;\n+        double expected, result;\n+        \n+        x = 4;\n+        y = -3;\n+        z = 0;\n+        expected = f.value(x, y, z);\n+        result = p.value(x, y, z);\n+        Assert.assertEquals(\"On sample point\", expected, result, 1e-15);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        z = -4.25;\n+        expected = f.value(x, y, z);\n+        result = p.value(x, y, z);\n+        Assert.assertEquals(\"half-way between sample points (middle of the patch)\", expected, result, 0.3);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        z = -10;\n+        expected = f.value(x, y, z);\n+        result = p.value(x, y, z);\n+        Assert.assertEquals(\"half-way between sample points (border of the patch)\", expected, result, 0.3);\n+    }\n+\n+    /**\n+     * Test of interpolator for a sine wave.\n+     * <p>\n+     * <p>\n+     *  f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y]\n+     * </p>\n+     * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1.\n+     */\n+    @Test\n+    public void testWave() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4};\n+\n+        final double a = 0.2;\n+        final double omega = 0.5;\n+        final double kx = 2;\n+        final double ky = 1;\n+\n+        // Function values\n+        TrivariateRealFunction f = new TrivariateRealFunction() {\n+                public double value(double x, double y, double z) {\n+                    return a * Math.cos(omega * z - kx * x - ky * y);\n+                }\n+            };\n+        \n+        double[][][] fval = new double[xval.length][yval.length][zval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                for (int k = 0; k < zval.length; k++) {\n+                    fval[i][j][k] = f.value(xval[i], yval[j], zval[k]);\n+                }\n+            }\n+        }\n+\n+        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();\n+\n+        TrivariateRealFunction p = interpolator.interpolate(xval, yval, zval, fval);\n+        double x, y, z;\n+        double expected, result;\n+        \n+        x = 4;\n+        y = -3;\n+        z = 0;\n+        expected = f.value(x, y, z);\n+        result = p.value(x, y, z);\n+        Assert.assertEquals(\"On sample point\",\n+                            expected, result, 1e-12);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        z = -4.25;\n+        expected = f.value(x, y, z);\n+        result = p.value(x, y, z);\n+        Assert.assertEquals(\"Half-way between sample points (middle of the patch)\",\n+                            expected, result, 0.1);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        z = -10;\n+        expected = f.value(x, y, z);\n+        result = p.value(x, y, z);\n+        Assert.assertEquals(\"Half-way between sample points (border of the patch)\",\n+                            expected, result, 0.1);\n+    }\n+}", "timestamp": 1271974161, "metainfo": ""}