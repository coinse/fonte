{"sha": "a25f1e4515b215f4510088cd1787725479390b14", "log": "PR: 29419 Added an implementation of regularized gamma function, Q(a, x) = 1 - P(a,x), based on a continued fraction.  This converges much faster for the large x case.  I added the example submitted by Scott as a test case and ran all the test cases with everything passing.   ", "commit": "\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.ContinuedFraction;\n \n /**\n  * This is a utility class that provides computation methods related to the\n  * Gamma family of functions.\n  * \n- * @version $Revision: 1.18 $ $Date: 2004/04/23 19:30:47 $\n+ * @version $Revision: 1.19 $ $Date: 2004/06/07 20:30:16 $\n  */\n-public class Gamma implements Serializable{\n+public class Gamma implements Serializable {\n+    \n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 10e-9;\n \n     }\n \n     /**\n-     * Returns the regularized gamma function P(a, x).\n-     * \n-     * @param a the a parameter.\n-     * @param x the value.\n-     * @return the regularized gamma function P(a, x)\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public static double regularizedGammaP(double a, double x)\n-        throws MathException\n-    {\n-        return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n-    }\n-    \n-    /**\n-     * Returns the regularized gamma function P(a, x).\n-     * \n-     * The implementation of this method is based on:\n-     * <ul>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n-     * Regularized Gamma Function</a>, equation (1).</li>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n-     * Incomplete Gamma Function</a>, equation (4).</li>\n-     * <li>\n-     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n-     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n-     * </li>\n-     * </ul>\n-     * \n-     * @param a the a parameter.\n-     * @param x the value.\n-     * @param epsilon When the absolute value of the nth item in the\n-     *                series is less than epsilon the approximation ceases\n-     *                to calculate further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete. \n-     * @return the regularized gamma function P(a, x)\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public static double regularizedGammaP(double a, \n-                                           double x, \n-                                           double epsilon, \n-                                           int maxIterations) \n-        throws MathException\n-    {\n-        double ret;\n-\n-        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n-            ret = Double.NaN;\n-        } else if (x == 0.0) {\n-            ret = 0.0;\n-        } else {\n-            // calculate series\n-            double n = 0.0; // current element index\n-            double an = 1.0 / a; // n-th element in the series\n-            double sum = an; // partial sum\n-            while (Math.abs(an) > epsilon && n < maxIterations) {\n-                // compute next element in the series\n-                n = n + 1.0;\n-                an = an * (x / (a + n));\n-\n-                // update partial sum\n-                sum = sum + an;\n-            }\n-            if (n >= maxIterations) {\n-                throw new ConvergenceException(\n-                    \"maximum number of iterations reached\");\n-            } else {\n-                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n-            }\n-        }\n-\n-        return ret;\n-    }\n-\n-    /**\n      * Returns the natural logarithm of the gamma function &#915;(x).\n      *\n      * The implementation of this method is based on:\n \n         return ret;\n     }\n+\n+    /**\n+     * Returns the regularized gamma function P(a, x).\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @return the regularized gamma function P(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaP(double a, double x)\n+        throws MathException\n+    {\n+        return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }\n+        \n+        \n+    /**\n+     * Returns the regularized gamma function P(a, x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n+     * Regularized Gamma Function</a>, equation (1).</li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n+     * Incomplete Gamma Function</a>, equation (4).</li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n+     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n+     * </li>\n+     * </ul>\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized gamma function P(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaP(double a, \n+                                           double x, \n+                                           double epsilon, \n+                                           int maxIterations) \n+        throws MathException\n+    {\n+        double ret;\n+\n+        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n+            ret = Double.NaN;\n+        } else if (x == 0.0) {\n+            ret = 0.0;\n+        } else if (a > 1.0 && x > a) {\n+            // use regularizedGammaQ because it should converge faster in this\n+            // case.\n+            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n+        } else {\n+            // calculate series\n+            double n = 0.0; // current element index\n+            double an = 1.0 / a; // n-th element in the series\n+            double sum = an; // partial sum\n+            while (Math.abs(an) > epsilon && n < maxIterations) {\n+                // compute next element in the series\n+                n = n + 1.0;\n+                an = an * (x / (a + n));\n+\n+                // update partial sum\n+                sum = sum + an;\n+            }\n+            if (n >= maxIterations) {\n+                throw new ConvergenceException(\n+                    \"maximum number of iterations reached\");\n+            } else {\n+                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+    \n+    /**\n+     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @return the regularized gamma function Q(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaQ(double a, double x)\n+        throws MathException\n+    {\n+        return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }\n+    \n+    /**\n+     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n+     * Regularized Gamma Function</a>, equation (1).</li>\n+     * <li>\n+     * <a href=\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n+     * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>\n+     * </ul>\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized gamma function P(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaQ(final double a, \n+                                           double x, \n+                                           double epsilon, \n+                                           int maxIterations) \n+        throws MathException\n+    {\n+        double ret;\n+\n+        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n+            ret = Double.NaN;\n+        } else if (x == 0.0) {\n+            ret = 1.0;\n+        } else if (x < a || a <= 1.0) {\n+            // use regularizedGammaP because it should converge faster in this\n+            // case.\n+            ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n+        } else {\n+            // create continued fraction\n+            ContinuedFraction cf = new ContinuedFraction() {\n+                protected double getA(int n, double x) {\n+                    double ret;\n+                    switch(n) {\n+                        case 0: ret = 0.0; break;\n+                        default:\n+                            ret = ((2.0 * n) - 1.0) - a + x; break;\n+                    }\n+                    return ret;\n+                }\n+\n+                protected double getB(int n, double x) {\n+                    double ret;\n+                    double t;\n+                    switch(n) {\n+                        case 1: ret = 1.0; break;\n+                        default:\n+                            t = n - 1.0;\n+                            ret = t * (a - t);\n+                            break;\n+                    }\n+                    return ret;\n+                }\n+            };\n+            \n+            ret = cf.evaluate(x, epsilon, maxIterations);\n+            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n+        }\n+\n+        return ret;\n+    }\n }\n--- a/src/test/org/apache/commons/math/special/GammaTest.java\n+++ b/src/test/org/apache/commons/math/special/GammaTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:17 $\n+ * @version $Revision: 1.10 $ $Date: 2004/06/07 20:30:16 $\n  */\n public class GammaTest extends TestCase {\n     /**\n \n     private void testRegularizedGamma(double expected, double a, double x) {\n         try {\n-            double actual = Gamma.regularizedGammaP(a, x);\n-            TestUtils.assertEquals(expected, actual, 10e-5);\n+            double actualP = Gamma.regularizedGammaP(a, x);\n+            double actualQ = Gamma.regularizedGammaQ(a, x);\n+            TestUtils.assertEquals(expected, actualP, 10e-5);\n+            TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-5);\n         } catch(MathException ex){\n             fail(ex.getMessage());\n         }\n--- a/src/test/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n /**\n  * Test cases for the ChiSquareTestImpl class.\n  *\n- * @version $Revision: 1.1 $ $Date: 2004/05/03 03:04:54 $\n+ * @version $Revision: 1.2 $ $Date: 2004/06/07 20:30:16 $\n  */\n \n public final class ChiSquareTestTest extends TestCase {\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }      \n-    }    \n+    }\n+    \n+    public void testChiSquareLargeTestStatistic() throws Exception {\n+        double[] exp = new double[] {\n+            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n+            232921.0, 437665.75\n+        };\n+\n+        long[] obs = new long[] {\n+            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n+        };\n+        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n+            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n+        double cst = csti.chiSquareTest(exp, obs); \n+        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n+    }\n }", "timestamp": 1086640216, "metainfo": ""}