{"sha": "42a96a6061f2189619594a54e630e2050b7f0c76", "log": "(Too) poor javadoc for MATH-437 improved  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java\n \n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.MathArithmeticException;\n+\n /**\n  * Treats the distribution of the two-sided \n- * {@code P(D<sub>n</sup> &lt; d)}\n- * where {@code D<sub>n</sup> = sup_x | G(x) - Gn (x) |} for the \n+ * {@code P(D}<sub>{@code n}</sub>{@code < d)}\n+ * where {@code D}<sub>{@code n}</sub>{@code = sup_x | G(x) - Gn (x) |} for the \n  * theoretical cdf G and the emperical cdf Gn.\n- * \n- * This implementation is based on [1] with certain quick \n- * decisions for extreme values given in [2].\n- * \n- * In short, when wanting to evaluate {@code P(D<sub>n</sup> &lt; d)}, \n- * the method in [1] is to write {@code d = (k - h) / n} for positive \n- * integer {@code k} and {@code 0 <= h < 1}. Then \n- * {@code P(D<sub>n</sup> &lt; d) = (n!/n^n) * t_kk}\n- * where {@code t_kk} is the (k, k)'th entry in the special matrix {@code H^n}, \n- * i.e. {@code H} to the {@code n}'th power. \n- * \n- * See also <a href=\"http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test\">\n- * Kolmogorov-Smirnov test on Wikipedia</a> for details.\n- * \n- * References: \n- * [1] Evaluating Kolmogorov's Distribution by George Marsaglia, Wai\n- * Wan Tsang, Jingbo Wang http://www.jstatsoft.org/v08/i18/paper\n- * \n- * [2] <a href=\"http://www.iro.umontreal.ca/~lecuyer/myftp/papers/ksdist.pdf\">\n- * Computing the Two-Sided Kolmogorov-Smirnov Distribution</a> by Richard Simard\n- * and Pierre L'Ecuyer\n- * \n- * Note that [1] contains an error in computing h, refer to \n- * <a href=\"https://issues.apache.org/jira/browse/MATH-437\">MATH-437</a> for details.\n  * \n  * @version $Revision$ $Date$\n  */\n public interface KolmogorovSmirnovDistribution {\n     \n+    /**\n+     * Calculates {@code P(D}<sub>n</sub> {@code < d)}.\n+     * \n+     * @param d statistic\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     */\n     public double cdf(double d);\n     \n }\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n /**\n  * The default implementation of {@link KolmogorovSmirnovDistribution}.\n  * \n+ * <p>Treats the distribution of the two-sided \n+ * {@code P(D}<sub>{@code n}</sub>{@code < d)}\n+ * where {@code D}<sub>{@code n}</sub>{@code = sup_x | G(x) - Gn (x) |} for the \n+ * theoretical cdf G and the emperical cdf Gn.</p>\n+ * \n+ * <p>This implementation is based on [1] with certain quick \n+ * decisions for extreme values given in [2].</p>\n+ * \n+ * <p>In short, when wanting to evaluate {@code P(D}<sub>{@code n}</sub>{@code < d)}, \n+ * the method in [1] is to write {@code d = (k - h) / n} for positive \n+ * integer {@code k} and {@code 0 <= h < 1}. Then \n+ * {@code P(D}<sub>{@code n}</sub>{@code < d) = (n!/n}<sup>{@code n}</sup>{@code ) * t_kk}\n+ * where {@code t_kk} is the {@code (k, k)}'th entry in the special \n+ * matrix {@code H}<sup>{@code n}</sup>, i.e. {@code H} to the {@code n}'th power.</p> \n+ * \n+ * <p>See also <a href=\"http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test\">\n+ * Kolmogorov-Smirnov test on Wikipedia</a> for details.</p>\n+ * \n+ * <p>References: \n+ * <ul>\n+ * <li>[1] <a href=\"http://www.jstatsoft.org/v08/i18/paper\">\n+ * Evaluating Kolmogorov's Distribution</a> by George Marsaglia, Wai\n+ * Wan Tsang, and Jingbo Wang</li>\n+ * <li>[2] <a href=\"http://www.iro.umontreal.ca/~lecuyer/myftp/papers/ksdist.pdf\">\n+ * Computing the Two-Sided Kolmogorov-Smirnov Distribution</a> by Richard Simard\n+ * and Pierre L'Ecuyer</li>\n+ * </ul>\n+ * Note that [1] contains an error in computing h, refer to \n+ * <a href=\"https://issues.apache.org/jira/browse/MATH-437\">MATH-437</a> for details.\n+ * </p>\n+ * \n  * @version $Revision$ $Date$\n  */\n public class KolmogorovSmirnovDistributionImpl implements KolmogorovSmirnovDistribution, Serializable {\n     /**\n      * @param n Number of observations\n      * @throws NotStrictlyPositiveException\n-     *             if n <= 0\n+     *             if {@code n <= 0}\n      */\n     public KolmogorovSmirnovDistributionImpl(int n) {\n         if (n <= 0) {\n     }\n \n     /**\n-     * Calculates {@code P(D<sub>n</sup> &lt; d)} using method described in\n+     * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n      * [1] with quick decisions for extreme values given in [2] (see above). The\n      * result is not exact as with \n      * {@link KolmogorovSmirnovDistributionImpl#cdfExact(double)} because\n      * {@link org.apache.commons.math.fraction.BigFraction}.\n      * \n      * @param d statistic\n-     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert h to a BigFraction in\n-     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a \n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     public double cdf(double d) throws MathArithmeticException {\n         return this.cdf(d, false);\n     }\n \n     /**\n-     * Calculates {@code P(D<sub>n</sup> &lt; d)} using method described in\n+     * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n      * [1] with quick decisions for extreme values given in [2] (see above). \n      * The result is exact in the sense that BigFraction/BigReal is used everywhere \n      * at the expense of very slow execution time. Almost never choose this in \n      * {@link KolmogorovSmirnovDistributionImpl#cdf(double)}\n      * \n      * @param d statistic\n-     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert h to a BigFraction in\n-     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a \n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     public double cdfExact(double d) throws MathArithmeticException {\n         return this.cdf(d, true);\n     }\n \n     /**\n-     * Calculates {@code P(D<sub>n</sup> &lt; d)} using method described in\n+     * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n      * [1] with quick decisions for extreme values given in [2] (see above).\n      * \n      * @param d statistic\n      *            whether the probability should be calculated exact using\n      *            BigFraction everywhere at the expense of very\n      *            slow execution time, or if double should be used convenient\n-     *            places to gain speed. Never choose true in real applications\n-     *            unless you are very sure; true is almost solely for\n-     *            verification purposes.\n-     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert h to a BigFraction in\n-     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     *            places to gain speed. Almost never choose {@code true} in \n+     *            real applications unless you are very sure; {@code true} is \n+     *            almost solely for verification purposes.\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a \n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     public double cdf(double d, boolean exact)\n             throws MathArithmeticException {\n     }\n \n     /**\n-     * Calculates {@code P(D<sub>n</sup> &lt; d)} exact using method\n+     * Calculates {@code P(D}<sub>n</sub> {@code < d)} exact using method\n      * described in [1] and BigFraction (see above).\n      * \n      * @param d statistic\n-     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert h to a BigFraction in\n-     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a \n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     private double exactK(double d)\n             throws MathArithmeticException {\n     }\n \n     /**\n-     * Calculates <code>P(D<sub>n</sup> &lt; d)</code> using method described in\n+     * Calculates {@code P(D}<sub>n</sub> {@code < d)} using method described in\n      * [1] and doubles (see above).\n      * \n      * @param d statistic\n-     * @return the two-sided probability of {@code P(D<sub>n</sup> &lt; d)}\n-     * @throws MathArithmeticException\n-     *             if algorithm fails to convert h to a BigFraction in\n-     *             expressing d as (k - h) / m for integer k, m and 0 <= h < 1.\n+     * @return the two-sided probability of {@code P(D}<sub>n</sub> {@code < d)}\n+     * @throws MathArithmeticException\n+     *             if algorithm fails to convert {@code h} to a \n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     private double roundedK(double d)\n             throws MathArithmeticException {\n     }\n \n     /***\n-     * Creates H of size m x m as described in [1] (see above).\n+     * Creates {@code H} of size {@code m x m} as described in [1] (see above).\n      * \n      * @param d statistic\n      *            \n      * @throws MathArithmeticException\n-     *             if algorithm fails to convert h to a BigFraction in\n-     *             expressing x as (k - h) / m for integer k, m and 0 <= h < 1.\n+     *             if algorithm fails to convert {@code h} to a \n+     *             {@link org.apache.commons.math.fraction.BigFraction} in\n+     *             expressing {@code d} as {@code (k - h) / m} for integer \n+     *             {@code k, m} and {@code 0 <= h < 1}.\n      */\n     private FieldMatrix<BigFraction> createH(double d)\n             throws MathArithmeticException {", "timestamp": 1300712554, "metainfo": ""}