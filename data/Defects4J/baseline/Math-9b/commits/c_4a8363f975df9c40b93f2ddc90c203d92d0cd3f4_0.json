{"sha": "4a8363f975df9c40b93f2ddc90c203d92d0cd3f4", "log": "MATH-863 New \"Quaternion\" class. Thanks to Julien Anxionnat. After applying the original patch, the following changes were made: * Renamed the \"static\" quaternion instances (\"PLUS_\" prefix removed). * Removed some (syntactic sugar) methods; removed or modified corresponding   unit tests. * Made the redundant accessors call the \"canonic\" ones. * Removed the default tolerance and added an explicit tolerance parameter   in methods that depend on equality testing. * When a \"ZeroException\" is thrown, the actual value of the norm is provided   in the detailed message (as the implementation actually does not use a   strict comparison with 0). * Added \"equals(Object)\" and \"hashCode\" methods. * Javadoc and formatting. Added license header. * Removed \"toString\" documentation (as this representation should not be   binding). Changed the representation to not use a comma. * Renamed \"scalarMultiply\" to \"multiply\". * More stringent tolerance used in the unit tests assertions, whenever   possible. * Added unit tests.    ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/complex/Quaternion.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.complex;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.Precision;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.ZeroException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+\n+/**\n+ * This class implements <a href=\"http://mathworld.wolfram.com/Quaternion.html\">\n+ * quaternions</a> (Hamilton's hypercomplex numbers).\n+ * <br/>\n+ * Instance of this class are guaranteed to be immutable.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public final class Quaternion implements Serializable {\n+    /** Identity quaternion. */\n+    public static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);\n+    /** Zero quaternion. */\n+    public static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);\n+    /** i */\n+    public static final Quaternion I = new Quaternion(0, 1, 0, 0);\n+    /** j */\n+    public static final Quaternion J = new Quaternion(0, 0, 1, 0);\n+    /** k */\n+    public static final Quaternion K = new Quaternion(0, 0, 0, 1);\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 20092012L;\n+\n+    /** First component (scalar part). */\n+    private final double q0;\n+    /** Second component (first vector part). */\n+    private final double q1;\n+    /** Third component (second vector part). */\n+    private final double q2;\n+    /** Fourth component (third vector part). */\n+    private final double q3;\n+\n+    /**\n+     * Builds a quaternion from its components.\n+     *\n+     * @param a Scalar component.\n+     * @param b First vector component.\n+     * @param c Second vector component.\n+     * @param d Third vector component.\n+     */\n+    public Quaternion(final double a,\n+                      final double b,\n+                      final double c,\n+                      final double d) {\n+        this.q0 = a;\n+        this.q1 = b;\n+        this.q2 = c;\n+        this.q3 = d;\n+    }\n+\n+    /**\n+     * Builds a quaternion from scalar and vector parts.\n+     *\n+     * @param scalar Scalar part of the quaternion.\n+     * @param v Components of the vector part of the quaternion.\n+     *\n+     * @throws DimensionMismatchException if the array length is not 3.\n+     */\n+    public Quaternion(final double scalar,\n+                      final double[] v)\n+        throws DimensionMismatchException {\n+        if (v.length != 3) {\n+            throw new DimensionMismatchException(v.length, 3);\n+        }\n+        this.q0 = 0;\n+        this.q1 = v[0];\n+        this.q2 = v[1];\n+        this.q3 = v[2];\n+    }\n+\n+    /**\n+     * Builds a pure quaternion from a vector (assuming that the scalar\n+     * part is zero.\n+     *\n+     * @param v Components of the vector part of the pure quaternion.\n+     */\n+    public Quaternion(final double[] v) {\n+        this(0, v);\n+    }\n+\n+    /**\n+     * Returns the conjugate quaternion of the instance.\n+     *\n+     * @return the conjugate quaternion\n+     */\n+    public Quaternion getConjugate() {\n+        return new Quaternion(q0, -q1, -q2, -q3);\n+    }\n+\n+    /**\n+     * Returns the Hamilton product of two quaternions.\n+     *\n+     * @param q1 First quaternion.\n+     * @param q2 Second quaternion.\n+     * @return the product {@code q1} and {@code q2}, in that order.\n+     */\n+    public static Quaternion product(final Quaternion q1, final Quaternion q2) {\n+        // Components of the first quaternion.\n+        final double q1a = q1.getQ0();\n+        final double q1b = q1.getQ1();\n+        final double q1c = q1.getQ2();\n+        final double q1d = q1.getQ3();\n+\n+        // Components of the second quaternion.\n+        final double q2a = q2.getQ0();\n+        final double q2b = q2.getQ1();\n+        final double q2c = q2.getQ2();\n+        final double q2d = q2.getQ3();\n+\n+        // Components of the product.\n+        final double w = q1a * q2a - q1b * q2b - q1c * q2c - q1d * q2d;\n+        final double x = q1a * q2b + q1b * q2a + q1c * q2d - q1d * q2c;\n+        final double y = q1a * q2c - q1b * q2d + q1c * q2a + q1d * q2b;\n+        final double z = q1a * q2d + q1b * q2c - q1c * q2b + q1d * q2a;\n+\n+        return new Quaternion(w, x, y, z);\n+    }\n+\n+    /**\n+     * Returns the Hamilton product of the instance by a quaternion.\n+     *\n+     * @param q Quaternion.\n+     * @return the product of this instance with {@code q}, in that order.\n+     */\n+    public Quaternion multiply(final Quaternion q) {\n+        return product(this, q);\n+    }\n+\n+    /**\n+     * Computes the sum of two quaternions.\n+     *\n+     * @param q1 Quaternion.\n+     * @param q2 Quaternion.\n+     * @return the sum of {@code q1} and {@code q2}.\n+     */\n+    public static Quaternion add(final Quaternion q1,\n+                                 final Quaternion q2) {\n+        return new Quaternion(q1.getQ0() + q2.getQ0(),\n+                              q1.getQ1() + q2.getQ1(),\n+                              q1.getQ2() + q2.getQ2(),\n+                              q1.getQ3() + q2.getQ3());\n+    }\n+\n+    /**\n+     * Computes the sum of the instance and another quaternion.\n+     *\n+     * @param q Quaternion.\n+     * @return the sum of this instance and {@code q}\n+     */\n+    public Quaternion add(final Quaternion q) {\n+        return add(this, q);\n+    }\n+\n+    /**\n+     * Subtracts two quaternions.\n+     *\n+     * @param q1 First Quaternion.\n+     * @param q2 Second quaternion.\n+     * @return the difference between {@code q1} and {@code q2}.\n+     */\n+    public static Quaternion subtract(final Quaternion q1,\n+                                      final Quaternion q2) {\n+        return new Quaternion(q1.getQ0() - q2.getQ0(),\n+                              q1.getQ1() - q2.getQ1(),\n+                              q1.getQ2() - q2.getQ2(),\n+                              q1.getQ3() - q2.getQ3());\n+    }\n+\n+    /**\n+     * Subtracts a quaternion from the instance.\n+     *\n+     * @param q Quaternion.\n+     * @return the difference between this instance and {@code q}.\n+     */\n+    public Quaternion subtract(final Quaternion q) {\n+        return subtract(this, q);\n+    }\n+\n+    /**\n+     * Computes the dot-product of two quaternions.\n+     *\n+     * @param q1 Quaternion.\n+     * @param q2 Quaternion.\n+     * @return the dot product of {@code q1} and {@code q2}.\n+     */\n+    public static double dotProduct(final Quaternion q1,\n+                                    final Quaternion q2) {\n+        return q1.getQ0() * q2.getQ0() +\n+            q1.getQ1() * q2.getQ1() +\n+            q1.getQ2() * q2.getQ2() +\n+            q1.getQ3() * q2.getQ3();\n+    }\n+\n+    /**\n+     * Compute the dot-product of the instance by a quaternion.\n+     *\n+     * @param q Quaternion.\n+     * @return the dot product of this instance and {@code q}.\n+     */\n+    public double dotProduct(final Quaternion q) {\n+        return dotProduct(q);\n+    }\n+\n+    /**\n+     * Computes the norm of the quaternion.\n+     *\n+     * @return the norm.\n+     */\n+    public double getNorm() {\n+        return FastMath.sqrt(q0 * q0 +\n+                             q1 * q1 +\n+                             q2 * q2 +\n+                             q3 * q3);\n+    }\n+\n+    /**\n+     * Computes the normalized quaternion (the versor of the instance).\n+     * The norm of the quaternion must not be zero.\n+     *\n+     * @return a normalized quaternion.\n+     * @throws ZeroException if the norm of the quaternion is zero.\n+     */\n+    public Quaternion normalize() {\n+        final double norm = getNorm();\n+\n+        if (norm < Precision.SAFE_MIN) {\n+            throw new ZeroException(LocalizedFormats.NORM, norm);\n+        }\n+\n+        return new Quaternion(q0 / norm,\n+                              q1 / norm,\n+                              q2 / norm,\n+                              q3 / norm);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (other instanceof Quaternion) {\n+            final Quaternion q = (Quaternion) other;\n+            return q0 == q.getQ0() &&\n+                q1 == q.getQ1() &&\n+                q2 == q.getQ2() &&\n+                q3 == q.getQ3();\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        // \"Effective Java\" (second edition, p. 47).\n+        int result = 17;\n+        for (double comp : new double[] { q0, q1, q2, q3 }) {\n+            final int c = MathUtils.hash(comp);\n+            result = 31 * result + c;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Checks whether this instance is equal to another quaternion\n+     * within a given tolerance.\n+     *\n+     * @param q Quaternion with which to compare the current quaternion.\n+     * @param eps Tolerance.\n+     * @return {@code true} if the each of the components are equal\n+     * within the allowed absolute error.\n+     */\n+    public boolean equals(final Quaternion q,\n+                          final double eps) {\n+        return Precision.equals(q0, q.getQ0(), eps) &&\n+            Precision.equals(q1, q.getQ1(), eps) &&\n+            Precision.equals(q2, q.getQ2(), eps) &&\n+            Precision.equals(q3, q.getQ3(), eps);\n+    }\n+\n+    /**\n+     * Checks whether the instance is a unit quaternion within a given\n+     * tolerance.\n+     *\n+     * @param eps Tolerance (absolute error).\n+     * @return {@code true} if the norm is 1 within the given tolerance,\n+     * {@code false} otherwise\n+     */\n+    public boolean isUnitQuaternion(double eps) {\n+        return Precision.equals(getNorm(), 1d, eps);\n+    }\n+\n+    /**\n+     * Checks whether the instance is a pure quaternion within a given\n+     * tolerance.\n+     *\n+     * @param eps Tolerance (absolute error).\n+     * @return {@code true} if the scalar part of the quaternion is zero.\n+     */\n+    public boolean isPureQuaternion(double eps) {\n+        return FastMath.abs(getQ0()) <= eps;\n+    }\n+\n+    /**\n+     * Returns the polar form of the quaternion.\n+     *\n+     * @return the unit quaternion with positive scalar part.\n+     */\n+    public Quaternion getPositivePolarForm() {\n+        if (getQ0() < 0) {\n+            final Quaternion unitQ = normalize();\n+            // The quaternion of rotation (normalized quaternion) q and -q\n+            // are equivalent (i.e. represent the same rotation).\n+            return new Quaternion(-unitQ.getQ0(),\n+                                  -unitQ.getQ1(),\n+                                  -unitQ.getQ2(),\n+                                  -unitQ.getQ3());\n+        } else {\n+            return this.normalize();\n+        }\n+    }\n+\n+    /**\n+     * Returns the inverse of this instance.\n+     * The norm of the quaternion must not be zero.\n+     *\n+     * @return the inverse.\n+     * @throws ZeroException if the norm (squared) of the quaternion is zero.\n+     */\n+    public Quaternion getInverse() {\n+        final double squareNorm = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3;\n+        if (squareNorm < Precision.SAFE_MIN) {\n+            throw new ZeroException(LocalizedFormats.NORM, squareNorm);\n+        }\n+\n+        return new Quaternion(q0 / squareNorm,\n+                              -q1 / squareNorm,\n+                              -q2 / squareNorm,\n+                              -q3 / squareNorm);\n+    }\n+\n+    /**\n+     * Gets the first component of the quaternion (scalar part).\n+     *\n+     * @return the scalar part.\n+     */\n+    public double getQ0() {\n+        return q0;\n+    }\n+\n+    /**\n+     * Gets the second component of the quaternion (first component\n+     * of the vector part).\n+     *\n+     * @return the first component of the vector part.\n+     */\n+    public double getQ1() {\n+        return q1;\n+    }\n+\n+    /**\n+     * Gets the third component of the quaternion (second component\n+     * of the vector part).\n+     *\n+     * @return the second component of the vector part.\n+     */\n+    public double getQ2() {\n+        return q2;\n+    }\n+\n+    /**\n+     * Gets the fourth component of the quaternion (third component\n+     * of the vector part).\n+     *\n+     * @return the third component of the vector part.\n+     */\n+    public double getQ3() {\n+        return q3;\n+    }\n+\n+    /**\n+     * Gets the scalar part of the quaternion.\n+     *\n+     * @return the scalar part.\n+     * @see #getQ0()\n+     */\n+    public double getScalarPart() {\n+        return getQ0();\n+    }\n+\n+    /**\n+     * Gets the three components of the vector part of the quaternion.\n+     *\n+     * @return the vector part.\n+     * @see #getQ1()\n+     * @see #getQ2()\n+     * @see #getQ3()\n+     */\n+    public double[] getVectorPart() {\n+        return new double[] { getQ1(), getQ2(), getQ3() };\n+    }\n+\n+    /**\n+     * Multiplies the instance by a scalar.\n+     *\n+     * @param alpha Scalar factor.\n+     * @return a scaled quaternion.\n+     */\n+    public Quaternion multiply(final double alpha) {\n+        return new Quaternion(alpha * q0,\n+                              alpha * q1,\n+                              alpha * q2,\n+                              alpha * q3);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        final String sp = \" \";\n+        final StringBuilder s = new StringBuilder();\n+        s.append(\"[\")\n+            .append(q0).append(sp)\n+            .append(q1).append(sp)\n+            .append(q2).append(sp)\n+            .append(q3)\n+            .append(\"]\");\n+\n+        return s.toString();\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n     NON_REAL_FINITE_ORDINATE(\"all ordinatae must be finite real numbers, but {0}-th is {1}\"),\n     NON_REAL_FINITE_WEIGHT(\"all weights must be finite real numbers, but {0}-th is {1}\"),\n     NON_SQUARE_MATRIX(\"non square ({0}x{1}) matrix\"),\n+    NORM(\"Norm ({0})\"), /* keep */\n     NORMALIZE_INFINITE(\"Cannot normalize to an infinite value\"),\n     NORMALIZE_NAN(\"Cannot normalize to NaN\"),\n     NOT_ADDITION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not addition compatible\"),\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/complex/QuaternionTest.java\n+package org.apache.commons.math3.complex;\n+\n+import java.util.Random;\n+import org.apache.commons.math3.complex.Quaternion;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.ZeroException;\n+import org.apache.commons.math3.geometry.euclidean.threed.Rotation;\n+import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n+import org.apache.commons.math3.util.Precision;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class QuaternionTest {\n+    /** Epsilon for double comparison. */\n+    private static final double EPS = Math.ulp(1d);\n+    /** Epsilon for double comparison. */\n+    private static final double COMPARISON_EPS = 1e-14;\n+\n+    @Test\n+    public final void testAccessors1() {\n+        final double q0 = 2;\n+        final double q1 = 5.4;\n+        final double q2 = 17;\n+        final double q3 = 0.0005;\n+        final Quaternion q = new Quaternion(q0, q1, q2, q3);\n+\n+        Assert.assertEquals(q0, q.getQ0(), 0);\n+        Assert.assertEquals(q1, q.getQ1(), 0);\n+        Assert.assertEquals(q2, q.getQ2(), 0);\n+        Assert.assertEquals(q3, q.getQ3(), 0);\n+    }\n+\n+    @Test\n+    public final void testAccessors2() {\n+        final double q0 = 2;\n+        final double q1 = 5.4;\n+        final double q2 = 17;\n+        final double q3 = 0.0005;\n+        final Quaternion q = new Quaternion(q0, q1, q2, q3);\n+\n+        final double sP = q.getScalarPart();\n+        final double[] vP = q.getVectorPart();\n+\n+        Assert.assertEquals(q0, sP, 0);\n+        Assert.assertEquals(q1, vP[0], 0);\n+        Assert.assertEquals(q2, vP[1], 0);\n+        Assert.assertEquals(q3, vP[2], 0);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testWrongDimension() {\n+        new Quaternion(new double[] { 1, 2 });\n+    }\n+    \n+    @Test\n+    public final void testConjugate() {\n+        final double q0 = 2;\n+        final double q1 = 5.4;\n+        final double q2 = 17;\n+        final double q3 = 0.0005;\n+        final Quaternion q = new Quaternion(q0, q1, q2, q3);\n+\n+        final Quaternion qConjugate = q.getConjugate();\n+\n+        Assert.assertEquals(q0, qConjugate.getQ0(), 0);\n+        Assert.assertEquals(-q1, qConjugate.getQ1(), 0);\n+        Assert.assertEquals(-q2, qConjugate.getQ2(), 0);\n+        Assert.assertEquals(-q3, qConjugate.getQ3(), 0);\n+    }\n+\n+    @Test\n+    public final void testProductQuaternionQuaternion() {\n+\n+        // Case : analytic test case\n+\n+        final Quaternion qA = new Quaternion(1, 0.5, -3, 4);\n+        final Quaternion qB = new Quaternion(6, 2, 1, -9);\n+        final Quaternion qResult = Quaternion.product(qA, qB);\n+\n+        Assert.assertEquals(44, qResult.getQ0(), EPS);\n+        Assert.assertEquals(28, qResult.getQ1(), EPS);\n+        Assert.assertEquals(-4.5, qResult.getQ2(), EPS);\n+        Assert.assertEquals(21.5, qResult.getQ3(), EPS);\n+\n+        // comparison with the result given by the formula :\n+        // qResult = (scalarA * scalarB - vectorA . vectorB) + (scalarA * vectorB + scalarB * vectorA + vectorA ^\n+        // vectorB)\n+\n+        final Vector3D vectorA = new Vector3D(qA.getVectorPart());\n+        final Vector3D vectorB = new Vector3D(qB.getVectorPart());\n+        final Vector3D vectorResult = new Vector3D(qResult.getVectorPart());\n+\n+        final double scalarPartRef = qA.getScalarPart() * qB.getScalarPart() - Vector3D.dotProduct(vectorA, vectorB);\n+\n+        Assert.assertEquals(scalarPartRef, qResult.getScalarPart(), EPS);\n+\n+        final Vector3D vectorPartRef = ((vectorA.scalarMultiply(qB.getScalarPart())).add(vectorB.scalarMultiply(qA\n+                .getScalarPart()))).add(Vector3D.crossProduct(vectorA, vectorB));\n+        final double norm = (vectorResult.subtract(vectorPartRef)).getNorm();\n+\n+        Assert.assertEquals(0, norm, EPS);\n+\n+        // Conjugate of the product of two quaternions and product of their conjugates :\n+        // Conj(qA * qB) = Conj(qB) * Conj(qA)\n+\n+        final Quaternion conjugateOfProduct = Quaternion.product(qB.getConjugate(), qA.getConjugate());\n+        final Quaternion productOfConjugate = (Quaternion.product(qA, qB)).getConjugate();\n+\n+        Assert.assertEquals(conjugateOfProduct.getQ0(), productOfConjugate.getQ0(), EPS);\n+        Assert.assertEquals(conjugateOfProduct.getQ1(), productOfConjugate.getQ1(), EPS);\n+        Assert.assertEquals(conjugateOfProduct.getQ2(), productOfConjugate.getQ2(), EPS);\n+        Assert.assertEquals(conjugateOfProduct.getQ3(), productOfConjugate.getQ3(), EPS);\n+    }\n+\n+    @Test\n+    public final void testProductQuaternionVector() {\n+\n+        // Case : Product between a vector and a quaternion : QxV\n+\n+        final Quaternion quaternion = new Quaternion(4, 7, -1, 2);\n+        final double[] vector = {2.0, 1.0, 3.0};\n+        final Quaternion qResultQxV = Quaternion.product(quaternion, new Quaternion(vector));\n+\n+        Assert.assertEquals(-19, qResultQxV.getQ0(), EPS);\n+        Assert.assertEquals(3, qResultQxV.getQ1(), EPS);\n+        Assert.assertEquals(-13, qResultQxV.getQ2(), EPS);\n+        Assert.assertEquals(21, qResultQxV.getQ3(), EPS);\n+\n+        // comparison with the result given by the formula :\n+        // qResult = (- vectorQ . vector) + (scalarQ * vector + vectorQ ^ vector)\n+\n+        final double[] vectorQ = quaternion.getVectorPart();\n+        final double[] vectorResultQxV = qResultQxV.getVectorPart();\n+\n+        final double scalarPartRefQxV = -Vector3D.dotProduct(new Vector3D(vectorQ), new Vector3D(vector));\n+        Assert.assertEquals(scalarPartRefQxV, qResultQxV.getScalarPart(), EPS);\n+\n+        final Vector3D vectorPartRefQxV = (new Vector3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Vector3D\n+                .crossProduct(new Vector3D(vectorQ), new Vector3D(vector)));\n+        final double normQxV = (new Vector3D(vectorResultQxV).subtract(vectorPartRefQxV)).getNorm();\n+        Assert.assertEquals(0, normQxV, EPS);\n+\n+        // Case : Product between a vector and a quaternion : VxQ\n+\n+        final Quaternion qResultVxQ = Quaternion.product(new Quaternion(vector), quaternion);\n+\n+        Assert.assertEquals(-19, qResultVxQ.getQ0(), EPS);\n+        Assert.assertEquals(13, qResultVxQ.getQ1(), EPS);\n+        Assert.assertEquals(21, qResultVxQ.getQ2(), EPS);\n+        Assert.assertEquals(3, qResultVxQ.getQ3(), EPS);\n+\n+        final double[] vectorResultVxQ = qResultVxQ.getVectorPart();\n+\n+        // comparison with the result given by the formula :\n+        // qResult = (- vector . vectorQ) + (scalarQ * vector + vector ^ vectorQ)\n+\n+        final double scalarPartRefVxQ = -Vector3D.dotProduct(new Vector3D(vectorQ), new Vector3D(vector));\n+        Assert.assertEquals(scalarPartRefVxQ, qResultVxQ.getScalarPart(), EPS);\n+\n+        final Vector3D vectorPartRefVxQ = (new Vector3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Vector3D\n+                .crossProduct(new Vector3D(vector), new Vector3D(vectorQ)));\n+        final double normVxQ = (new Vector3D(vectorResultVxQ).subtract(vectorPartRefVxQ)).getNorm();\n+        Assert.assertEquals(0, normVxQ, EPS);\n+    }\n+\n+    @Test\n+    public final void testDotProductQuaternionQuaternion() {\n+        // expected output\n+        final double expected = -6.;\n+        // inputs\n+        final Quaternion q1 = new Quaternion(1, 2, 2, 1);\n+        final Quaternion q2 = new Quaternion(3, -2, -1, -3);\n+\n+        final double actual = Quaternion.dotProduct(q1, q2);\n+\n+        Assert.assertEquals(expected, actual, EPS);\n+    }\n+\n+    @Test\n+    public final void testScalarMultiplyDouble() {\n+        // expected outputs\n+        final double w = 1.6;\n+        final double x = -4.8;\n+        final double y = 11.20;\n+        final double z = 2.56;\n+        // inputs\n+        final Quaternion q1 = new Quaternion(0.5, -1.5, 3.5, 0.8);\n+        final double a = 3.2;\n+\n+        final Quaternion q = q1.multiply(a);\n+\n+        Assert.assertEquals(w, q.getQ0(), COMPARISON_EPS);\n+        Assert.assertEquals(x, q.getQ1(), COMPARISON_EPS);\n+        Assert.assertEquals(y, q.getQ2(), COMPARISON_EPS);\n+        Assert.assertEquals(z, q.getQ3(), COMPARISON_EPS);\n+    }\n+\n+    @Test\n+    public final void testAddQuaternionQuaternion() {\n+        // expected outputs\n+        final double w = 4;\n+        final double x = -1;\n+        final double y = 2;\n+        final double z = -4;\n+        // inputs\n+        final Quaternion q1 = new Quaternion(1., 2., -2., -1.);\n+        final Quaternion q2 = new Quaternion(3., -3., 4., -3.);\n+\n+        final Quaternion q = Quaternion.add(q1, q2);\n+\n+        Assert.assertEquals(w, q.getQ0(), EPS);\n+        Assert.assertEquals(x, q.getQ1(), EPS);\n+        Assert.assertEquals(y, q.getQ2(), EPS);\n+        Assert.assertEquals(z, q.getQ3(), EPS);\n+    }\n+\n+    @Test\n+    public final void testSubtractQuaternionQuaternion() {\n+        // expected outputs\n+        final double w = -2.;\n+        final double x = 5.;\n+        final double y = -6.;\n+        final double z = 2.;\n+        // inputs\n+        final Quaternion q1 = new Quaternion(1., 2., -2., -1.);\n+        final Quaternion q2 = new Quaternion(3., -3., 4., -3.);\n+\n+        final Quaternion q = Quaternion.subtract(q1, q2);\n+\n+        Assert.assertEquals(w, q.getQ0(), EPS);\n+        Assert.assertEquals(x, q.getQ1(), EPS);\n+        Assert.assertEquals(y, q.getQ2(), EPS);\n+        Assert.assertEquals(z, q.getQ3(), EPS);\n+    }\n+\n+    @Test\n+    public final void testNorm() {\n+\n+        final double q0 = 2;\n+        final double q1 = 1;\n+        final double q2 = -4;\n+        final double q3 = 3;\n+        final Quaternion q = new Quaternion(q0, q1, q2, q3);\n+\n+        final double norm = q.getNorm();\n+\n+        Assert.assertEquals(Math.sqrt(30), norm, 0);\n+\n+        final double normSquareRef = Quaternion.product(q, q.getConjugate()).getScalarPart();\n+        Assert.assertEquals(Math.sqrt(normSquareRef), norm, 0);\n+    }\n+\n+    @Test\n+    public final void testNormalize() {\n+\n+        final Quaternion q = new Quaternion(2, 1, -4, -2);\n+\n+        final Quaternion versor = q.normalize();\n+\n+        Assert.assertEquals(2.0 / 5.0, versor.getQ0(), 0);\n+        Assert.assertEquals(1.0 / 5.0, versor.getQ1(), 0);\n+        Assert.assertEquals(-4.0 / 5.0, versor.getQ2(), 0);\n+        Assert.assertEquals(-2.0 / 5.0, versor.getQ3(), 0);\n+\n+        Assert.assertEquals(1, versor.getNorm(), 0);\n+    }\n+\n+    @Test(expected=ZeroException.class)\n+    public final void testNormalizeFail() {\n+        final Quaternion zeroQ = new Quaternion(0, 0, 0, 0);\n+        zeroQ.normalize();\n+    }\n+\n+    @Test\n+    public final void testObjectEquals() {\n+        final double one = 1;\n+        final Quaternion q1 = new Quaternion(one, one, one, one);\n+        Assert.assertTrue(q1.equals(q1));\n+\n+        final Quaternion q2 = new Quaternion(one, one, one, one);\n+        Assert.assertTrue(q2.equals(q1));\n+\n+        final Quaternion q3 = new Quaternion(one, FastMath.nextUp(one), one, one);\n+        Assert.assertFalse(q3.equals(q1));\n+    }\n+\n+    @Test\n+    public final void testQuaternionEquals() {\n+        final double inc = 1e-5;\n+        final Quaternion q1 = new Quaternion(2, 1, -4, -2);\n+        final Quaternion q2 = new Quaternion(q1.getQ0() + inc, q1.getQ1(), q1.getQ2(), q1.getQ3());\n+        final Quaternion q3 = new Quaternion(q1.getQ0(), q1.getQ1() + inc, q1.getQ2(), q1.getQ3());\n+        final Quaternion q4 = new Quaternion(q1.getQ0(), q1.getQ1(), q1.getQ2() + inc, q1.getQ3());\n+        final Quaternion q5 = new Quaternion(q1.getQ0(), q1.getQ1(), q1.getQ2(), q1.getQ3() + inc);\n+\n+        Assert.assertFalse(q1.equals(q2, 0.9 * inc));\n+        Assert.assertFalse(q1.equals(q3, 0.9 * inc));\n+        Assert.assertFalse(q1.equals(q4, 0.9 * inc));\n+        Assert.assertFalse(q1.equals(q5, 0.9 * inc));\n+\n+        Assert.assertTrue(q1.equals(q2, 1.1 * inc));\n+        Assert.assertTrue(q1.equals(q3, 1.1 * inc));\n+        Assert.assertTrue(q1.equals(q4, 1.1 * inc));\n+        Assert.assertTrue(q1.equals(q5, 1.1 * inc));\n+    }\n+\n+    @Test\n+    public final void testQuaternionEquals2() {\n+        final Quaternion q1 = new Quaternion(1, 4, 2, 3);\n+        final double gap = 1e-5;\n+        final Quaternion q2 = new Quaternion(1 + gap, 4 + gap, 2 + gap, 3 + gap);\n+\n+        Assert.assertTrue(q1.equals(q2, 10 * gap));\n+        Assert.assertFalse(q1.equals(q2, gap));\n+        Assert.assertFalse(q1.equals(q2, gap / 10));\n+    }\n+\n+    @Test\n+    public final void testIsUnitQuaternion() {\n+        final Random r = new Random(48);\n+        final int numberOfTrials = 1000;\n+        for (int i = 0; i < numberOfTrials; i++) {\n+            final Quaternion q1 = new Quaternion(r.nextDouble(), r.nextDouble(), r.nextDouble(), r.nextDouble());\n+            final Quaternion q2 = q1.normalize();\n+            Assert.assertTrue(q2.isUnitQuaternion(COMPARISON_EPS));\n+        }\n+\n+        final Quaternion q = new Quaternion(1, 1, 1, 1);\n+        Assert.assertFalse(q.isUnitQuaternion(COMPARISON_EPS));\n+    }\n+\n+    @Test\n+    public final void testIsPureQuaternion() {\n+        final Quaternion q1 = new Quaternion(0, 5, 4, 8);\n+        Assert.assertTrue(q1.isPureQuaternion(EPS));\n+\n+        final Quaternion q2 = new Quaternion(0 - EPS, 5, 4, 8);\n+        Assert.assertTrue(q2.isPureQuaternion(EPS));\n+\n+        final Quaternion q3 = new Quaternion(0 - 1.1 * EPS, 5, 4, 8);\n+        Assert.assertFalse(q3.isPureQuaternion(EPS));\n+\n+        final Random r = new Random(48);\n+        final double[] v = {r.nextDouble(), r.nextDouble(), r.nextDouble()};\n+        final Quaternion q4 = new Quaternion(v);\n+        Assert.assertTrue(q4.isPureQuaternion(0));\n+\n+        final Quaternion q5 = new Quaternion(0, v);\n+        Assert.assertTrue(q5.isPureQuaternion(0));\n+    }\n+\n+    @Test\n+    public final void testPolarForm() {\n+        final Random r = new Random(48);\n+        final int numberOfTrials = 1000;\n+        for (int i = 0; i < numberOfTrials; i++) {\n+            final Quaternion q = new Quaternion(2 * (r.nextDouble() - 0.5), 2 * (r.nextDouble() - 0.5),\n+                                                2 * (r.nextDouble() - 0.5), 2 * (r.nextDouble() - 0.5));\n+            final Quaternion qP = q.getPositivePolarForm();\n+\n+            Assert.assertTrue(qP.isUnitQuaternion(COMPARISON_EPS));\n+            Assert.assertTrue(qP.getQ0() >= 0);\n+\n+            final Rotation rot = new Rotation(q.getQ0(), q.getQ1(), q.getQ2(), q.getQ3(), true);\n+            final Rotation rotP = new Rotation(qP.getQ0(), qP.getQ1(), qP.getQ2(), qP.getQ3(), true);\n+\n+            Assert.assertEquals(rot.getAngle(), rotP.getAngle(), COMPARISON_EPS);\n+            Assert.assertEquals(rot.getAxis().getX(), rot.getAxis().getX(), COMPARISON_EPS);\n+            Assert.assertEquals(rot.getAxis().getY(), rot.getAxis().getY(), COMPARISON_EPS);\n+            Assert.assertEquals(rot.getAxis().getZ(), rot.getAxis().getZ(), COMPARISON_EPS);\n+        }\n+    }\n+\n+    @Test\n+    public final void testGetInverse() {\n+        final Quaternion q = new Quaternion(1.5, 4, 2, -2.5);\n+\n+        final Quaternion inverseQ = q.getInverse();\n+        Assert.assertEquals(1.5 / 28.5, inverseQ.getQ0(), 0);\n+        Assert.assertEquals(-4.0 / 28.5, inverseQ.getQ1(), 0);\n+        Assert.assertEquals(-2.0 / 28.5, inverseQ.getQ2(), 0);\n+        Assert.assertEquals(2.5 / 28.5, inverseQ.getQ3(), 0);\n+\n+        final Quaternion product = Quaternion.product(inverseQ, q);\n+        Assert.assertEquals(1, product.getQ0(), EPS);\n+        Assert.assertEquals(0, product.getQ1(), EPS);\n+        Assert.assertEquals(0, product.getQ2(), EPS);\n+        Assert.assertEquals(0, product.getQ3(), EPS);\n+\n+        final Quaternion qNul = new Quaternion(0, 0, 0, 0);\n+        try {\n+            final Quaternion inverseQNul = qNul.getInverse();\n+            Assert.fail(\"expecting ZeroException but got : \" + inverseQNul);\n+        } catch (ZeroException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public final void testToString() {\n+        final Quaternion q = new Quaternion(1, 2, 3, 4);\n+        Assert.assertTrue(q.toString().equals(\"[1.0 2.0 3.0 4.0]\"));\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math3/exception/util/LocalizedFormatsTest.java\n+++ b/src/test/java/org/apache/commons/math3/exception/util/LocalizedFormatsTest.java\n \n     @Test\n     public void testMessageNumber() {\n-        Assert.assertEquals(310, LocalizedFormats.values().length);\n+        Assert.assertEquals(311, LocalizedFormats.values().length);\n     }\n \n     @Test", "timestamp": 1348158106, "metainfo": ""}