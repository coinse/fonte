{"sha": "47dbe73de639fac31d05faa4d11140c51cc3b075", "log": "added absolute accuracy handling for integrators  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n      \"les valeurs de la fonction aux bornes n''ont pas des signes diff\\u00e9rents. Bornes : [{0}, {1}], valeurs : [{2}, {3}]\" },\n \n    // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl\n+   // org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl\n    // org.apache.commons.math.transform.FastFourierTransformer\n    { \"endpoints do not specify an interval: [{0}, {1}]\",\n      \"les extr\\u00e9mit\\u00e9s ne constituent pas un intervalle : [{0}, {1}]\" },\n    // org.apache.commons.math.analysis.solvers.NewtonSolver\n    { \"function is not differentiable\",\n      \"la fonction n''est pas diff\\u00e9rentiable\" },\n+\n+   // org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl\n+   { \"invalid iteration limits: min={0}, max={1}\",\n+     \"limites d''it\\u00e9rations invalides : min = {0}, max = {1}\" },\n \n    // org.apache.commons.math.fraction.Fraction\n    { \"zero denominator in fraction {0}/{1}\",\n--- a/src/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n  * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n  * chapter 3.\n  * <p>\n- * Romberg integration employs k successvie refinements of the trapezoid\n+ * Romberg integration employs k successive refinements of the trapezoid\n  * rule to remove error terms less than order O(N^(-2k)). Simpson's rule\n  * is a special case of k = 2.</p>\n  *  \n         super(f, 32);\n     }\n \n-    /**\n-     * Integrate the function in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value of integral\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double integrate(double min, double max) throws MaxIterationsExceededException,\n+    /** {@inheritDoc} */\n+   public double integrate(double min, double max) throws MaxIterationsExceededException,\n         FunctionEvaluationException, IllegalArgumentException {\n         \n         int i = 1, j, m = maximalIterationCount + 1;\n-        // Array strcture here can be improved for better space\n+        // Array structure here can be improved for better space\n         // efficiency because only the lower triangle is used.\n         double r, t[][] = new double[m][m], s, olds;\n \n             }\n             s = t[i][i];\n             if (i >= minimalIterationCount) {\n-                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n+                final double delta = Math.abs(s - olds);\n+                final double rLimit =\n+                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5; \n+                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(s, i);\n                     return result;\n                 }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n-    /**\n-     * Verifies that the iteration limits are valid and within the range.\n-     * \n-     * @throws IllegalArgumentException if not\n-     */\n+    /** {@inheritDoc} */\n     protected void verifyIterationCount() throws IllegalArgumentException {\n         super.verifyIterationCount();\n         // at most 32 bisection refinements due to higher order divider\n         if (maximalIterationCount > 32) {\n-            throw new IllegalArgumentException\n-                (\"Iteration upper limit out of [0, 32] range: \" +\n-                maximalIterationCount);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    new Object[] { 0, 32 });\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n         super(f, 64);\n     }\n \n-    /**\n-     * Integrate the function in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value of integral\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n+    /** {@inheritDoc} */\n     public double integrate(double min, double max) throws MaxIterationsExceededException,\n         FunctionEvaluationException, IllegalArgumentException {\n         \n             t = qtrap.stage(min, max, i);\n             s = (4 * t - oldt) / 3.0;\n             if (i >= minimalIterationCount) {\n-                if (Math.abs(s - olds) <= Math.abs(relativeAccuracy * olds)) {\n+                final double delta = Math.abs(s - olds);\n+                final double rLimit =\n+                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5; \n+                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(s, i);\n                     return result;\n                 }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n-    /**\n-     * Verifies that the iteration limits are valid and within the range.\n-     * \n-     * @throws IllegalArgumentException if not\n-     */\n+    /** {@inheritDoc} */\n     protected void verifyIterationCount() throws IllegalArgumentException {\n         super.verifyIterationCount();\n         // at most 64 bisection refinements\n         if (maximalIterationCount > 64) {\n-            throw new IllegalArgumentException\n-                (\"Iteration upper limit out of [0, 64] range: \" +\n-                maximalIterationCount);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    new Object[] { 0, 64 });\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n         }\n     }\n \n-    /**\n-     * Integrate the function in the given interval.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value of integral\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the integrator detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n+    /** {@inheritDoc} */\n     public double integrate(double min, double max) throws MaxIterationsExceededException,\n         FunctionEvaluationException, IllegalArgumentException {\n         \n         while (i <= maximalIterationCount) {\n             t = stage(min, max, i);\n             if (i >= minimalIterationCount) {\n-                if (Math.abs(t - oldt) <= Math.abs(relativeAccuracy * oldt)) {\n+                final double delta = Math.abs(t - oldt);\n+                final double rLimit =\n+                    relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5; \n+                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(t, i);\n                     return result;\n                 }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n-    /**\n-     * Verifies that the iteration limits are valid and within the range.\n-     * \n-     * @throws IllegalArgumentException if not\n-     */\n+    /** {@inheritDoc} */\n     protected void verifyIterationCount() throws IllegalArgumentException {\n         super.verifyIterationCount();\n         // at most 64 bisection refinements\n         if (maximalIterationCount > 64) {\n-            throw new IllegalArgumentException\n-                (\"Iteration upper limit out of [0, 64] range: \" +\n-                maximalIterationCount);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    new Object[] { 0, 64 });\n         }\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n package org.apache.commons.math.analysis.integration;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ConvergingAlgorithm;\n import org.apache.commons.math.FunctionEvaluationException;\n \n /**\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public interface UnivariateRealIntegrator {\n+public interface UnivariateRealIntegrator extends ConvergingAlgorithm {\n \n-    /**\n-     * Set the upper limit for the number of iterations.\n-     * <p>\n-     * Usually a high iteration count indicates convergence problem. However,\n-     * the \"reasonable value\" varies widely for different cases.  Users are\n-     * advised to use the default value.</p>\n-     * <p>\n-     * A <code>ConvergenceException</code> will be thrown if this number\n-     * is exceeded.</p>\n-     *  \n-     * @param count maximum number of iterations\n-     */\n-    void setMaximalIterationCount(int count);\n-\n-    /**\n-     * Get the upper limit for the number of iterations.\n-     * \n-     * @return the actual upper limit\n-     */\n-    int getMaximalIterationCount();\n-\n-    /**\n-     * Reset the upper limit for the number of iterations to the default.\n-     * <p>\n-     * The default value is supplied by the implementation.</p>\n-     * \n-     * @see #setMaximalIterationCount(int)\n-     */\n-    void resetMaximalIterationCount();\n-\n-    /**\n+   /**\n      * Set the lower limit for the number of iterations.\n      * <p>\n      * Minimal iteration is needed to avoid false early convergence, e.g.\n     void resetMinimalIterationCount();\n \n     /**\n-     * Set the relative accuracy.\n-     * <p>\n-     * This is used to stop iterations.</p>\n-     * \n-     * @param accuracy the relative accuracy\n-     * @throws IllegalArgumentException if the accuracy can't be achieved\n-     * or is otherwise deemed unreasonable\n-     */\n-    void setRelativeAccuracy(double accuracy);\n-\n-    /**\n-     * Get the actual relative accuracy.\n-     *\n-     * @return the accuracy\n-     */\n-    double getRelativeAccuracy();\n-\n-    /**\n-     * Reset the relative accuracy to the default.\n-     * <p>\n-     * The default value is provided by the implementation.</p>\n-     *\n-     * @see #setRelativeAccuracy(double)\n-     */\n-    void resetRelativeAccuracy();\n-\n-    /**\n      * Integrate the function in the given interval.\n      * \n      * @param min the lower bound for the interval\n      */\n     double getResult() throws IllegalStateException;\n \n-    /**\n-     * Get the number of iterations in the last run of the integrator.\n-     * <p>\n-     * This is mainly meant for testing purposes. It may occasionally\n-     * help track down performance problems: if the iteration count\n-     * is notoriously high, check whether the function is evaluated\n-     * properly, and whether another integrator is more amenable to the\n-     * problem.</p>\n-     * \n-     * @return the last iteration count\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed\n-     */\n-    int getIterationCount() throws IllegalStateException;\n }\n--- a/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n  */\n package org.apache.commons.math.analysis.integration;\n \n-import java.io.Serializable;\n-\n+import org.apache.commons.math.ConvergingAlgorithmImpl;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public abstract class UnivariateRealIntegratorImpl implements\n-    UnivariateRealIntegrator, Serializable {\n+public abstract class UnivariateRealIntegratorImpl\n+    extends ConvergingAlgorithmImpl implements UnivariateRealIntegrator {\n \n-    /** serializable version identifier */\n-    static final long serialVersionUID = -3365294665201465048L;\n-\n-    /** maximum relative error */\n-    protected double relativeAccuracy;\n-\n-    /** maximum number of iterations */\n-    protected int maximalIterationCount;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 6248808456637441533L;\n \n     /** minimum number of iterations */\n     protected int minimalIterationCount;\n-\n-    /** default maximum relative error */\n-    protected double defaultRelativeAccuracy;\n-\n-    /** default maximum number of iterations */\n-    protected int defaultMaximalIterationCount;\n \n     /** default minimum number of iterations */\n     protected int defaultMinimalIterationCount;\n \n     /** the last computed integral */\n     protected double result;\n-\n-    /** the last iteration count */\n-    protected int iterationCount;\n \n     /** the integrand function */\n     protected UnivariateRealFunction f;\n      * @throws IllegalArgumentException if f is null or the iteration\n      * limits are not valid\n      */\n-    protected UnivariateRealIntegratorImpl(\n-        UnivariateRealFunction f,\n-        int defaultMaximalIterationCount) throws IllegalArgumentException {\n-        \n+    protected UnivariateRealIntegratorImpl(final UnivariateRealFunction f,\n+                                           final int defaultMaximalIterationCount)\n+        throws IllegalArgumentException {\n+        super(defaultMaximalIterationCount, 1.0e-15);\n         if (f == null) {\n             throw new IllegalArgumentException(\"Function can not be null.\");\n         }\n \n         this.f = f;\n-        // parameters that may depend on algorithm\n-        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n-        this.maximalIterationCount = defaultMaximalIterationCount;\n+\n         // parameters that are problem specific\n-        this.defaultRelativeAccuracy = 1E-6;\n-        this.relativeAccuracy = defaultRelativeAccuracy;\n+        setRelativeAccuracy(1.0e-6);\n         this.defaultMinimalIterationCount = 3;\n         this.minimalIterationCount = defaultMinimalIterationCount;\n         \n     }\n \n     /**\n-     * Access the last iteration count.\n-     * \n-     * @return the last iteration count\n-     * @throws IllegalStateException if no integral has been computed\n-     */\n-    public int getIterationCount() throws IllegalStateException {\n-        if (resultComputed) {\n-            return iterationCount;\n-        } else {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n-        }\n-    }\n-\n-    /**\n      * Convenience function for implementations.\n      * \n      * @param result the result to set\n      * Convenience function for implementations.\n      */\n     protected final void clearResult() {\n+        this.iterationCount = 0;\n         this.resultComputed = false;\n     }\n \n-    /**\n-     * Set the upper limit for the number of iterations.\n-     * \n-     * @param count maximum number of iterations\n-     */\n-    public void setMaximalIterationCount(int count) {\n-        maximalIterationCount = count;\n-    }\n-\n-    /**\n-     * Get the upper limit for the number of iterations.\n-     * \n-     * @return the actual upper limit\n-     */\n-    public int getMaximalIterationCount() {\n-        return maximalIterationCount;\n-    }\n-\n-    /**\n-     * Reset the upper limit for the number of iterations to the default.\n-     */\n-    public void resetMaximalIterationCount() {\n-        maximalIterationCount = defaultMaximalIterationCount;\n-    }\n-\n-    /**\n-     * Set the lower limit for the number of iterations.\n-     * \n-     * @param count minimum number of iterations\n-     */\n+    /** {@inheritDoc} */\n     public void setMinimalIterationCount(int count) {\n         minimalIterationCount = count;\n     }\n \n-    /**\n-     * Get the lower limit for the number of iterations.\n-     * \n-     * @return the actual lower limit\n-     */\n+    /** {@inheritDoc} */\n     public int getMinimalIterationCount() {\n         return minimalIterationCount;\n     }\n \n-    /**\n-     * Reset the lower limit for the number of iterations to the default.\n-     */\n+    /** {@inheritDoc} */\n     public void resetMinimalIterationCount() {\n         minimalIterationCount = defaultMinimalIterationCount;\n-    }\n-\n-    /**\n-     * Set the relative accuracy.\n-     * \n-     * @param accuracy the relative accuracy\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the integrator or is otherwise deemed unreasonable\n-     */\n-    public void setRelativeAccuracy(double accuracy) {\n-        relativeAccuracy = accuracy;\n-    }\n-\n-    /**\n-     * Get the actual relative accuracy.\n-     *\n-     * @return the accuracy\n-     */\n-    public double getRelativeAccuracy() {\n-        return relativeAccuracy;\n-    }\n-\n-    /**\n-     * Reset the relative accuracy to the default.\n-     */\n-    public void resetRelativeAccuracy() {\n-        relativeAccuracy = defaultRelativeAccuracy;\n-    }\n-\n-    /**\n-     * Returns true if the arguments form a (strictly) increasing sequence\n-     * \n-     * @param start first number\n-     * @param mid second number\n-     * @param end third number\n-     * @return true if the arguments form an increasing sequence\n-     */\n-    protected boolean isSequence(double start, double mid, double end) {\n-        return (start < mid) && (mid < end);\n     }\n \n     /**\n     protected void verifyInterval(double lower, double upper) throws\n         IllegalArgumentException {\n         if (lower >= upper) {\n-            throw new IllegalArgumentException\n-                (\"Endpoints do not specify an interval: [\" + lower +\n-                \", \" + upper + \"]\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"endpoints do not specify an interval: [{0}, {1}]\",\n+                    new Object[] { lower, upper });\n         }       \n     }\n \n      * @throws IllegalArgumentException if not valid\n      */\n     protected void verifyIterationCount() throws IllegalArgumentException {\n-        if (!isSequence(0, minimalIterationCount, maximalIterationCount+1)) {\n-            throw new IllegalArgumentException\n-                (\"Invalid iteration limits: min=\" + minimalIterationCount +\n-                \" max=\" + maximalIterationCount);\n+        if ((minimalIterationCount <= 0) || (maximalIterationCount <= minimalIterationCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    new Object[] { minimalIterationCount, maximalIterationCount });\n         }       \n     }\n }", "timestamp": 1232311516, "metainfo": ""}