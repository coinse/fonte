{"sha": "6e62aefca7aefe26a2ebc43fcdcd6cd58953f7de", "log": "MATH-867 Unit test showing the problem. It is disabled (with the \"@Ignore\" annotation) because it fails with the current code.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n import org.apache.commons.math3.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n+import org.junit.Ignore;\n import org.junit.runner.RunWith;\n \n /**\n \n     @Test\n     public void testConstrainedRosen() {\n-        double[] startPoint = point(DIM,0.1);\n-        double[] insigma = point(DIM,0.1);\n-        double[][] boundaries = boundaries(DIM,-1,2);\n+        double[] startPoint = point(DIM, 0.1);\n+        double[] insigma = point(DIM, 1);\n+        double[][] boundaries = boundaries(DIM, -1, 2);\n         PointValuePair expected =\n             new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n \n         final double[] start = { 0 };\n         final double[] lower = { -1e6 };\n-        final double[] upper = { 0.5 };\n+        final double[] upper = { 1.5 };\n         final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n                                                    start, lower, upper).getPoint();\n         Assert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",\n                                                    start, lower, upper).getPoint();\n     }\n \n+    /**\n+     * Cf. MATH-867\n+     */\n+    @Ignore@Test\n+    public void testFitAccuracyDependsOnBoundary() {\n+        final CMAESOptimizer optimizer = new CMAESOptimizer();\n+        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n+                public double value(double[] parameters) {\n+                    final double target = 11.1;\n+                    final double error = target - parameters[0];\n+                    return error * error;\n+                }\n+            };\n+\n+        final double[] start = { 1 };\n+\n+        // No bounds.\n+        PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n+                                                   start);\n+        final double resNoBound = result.getPoint()[0];\n+\n+        // Optimum is near the lower bound.\n+        final double[] lower = { -20 };\n+        final double[] upper = { 5e16 };\n+        result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n+                                    start, lower, upper);\n+        final double resNearLo = result.getPoint()[0];\n+\n+        // Optimum is near the upper bound.\n+        lower[0] = -5e16;\n+        upper[0] = 20;\n+        result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n+                                    start, lower, upper);\n+        final double resNearHi = result.getPoint()[0];\n+\n+        // System.out.println(\"resNoBound=\" + resNoBound +\n+        //                    \" resNearLo=\" + resNearLo +\n+        //                    \" resNearHi=\" + resNearHi);\n+\n+        // The two values currently differ by a substantial amount, indicating that\n+        // the bounds definition can prevent reaching the optimum.\n+        Assert.assertEquals(resNoBound, resNearLo, 1e-3);\n+        Assert.assertEquals(resNoBound, resNearHi, 1e-3);\n+    }\n+ \n     /**\n      * @param func Function to optimize.\n      * @param startPoint Starting point.\n             PointValuePair expected) {\n         int dim = startPoint.length;\n         // test diagonalOnly = 0 - slow but normally fewer feval#\n-        CMAESOptimizer optim = new CMAESOptimizer( lambda, inSigma, 30000,\n-                                                   stopValue, isActive, diagonalOnly,\n-                                                   0, new MersenneTwister(), false);\n+        CMAESOptimizer optim = new CMAESOptimizer(lambda, inSigma, 30000,\n+                                                  stopValue, isActive, diagonalOnly,\n+                                                  0, new MersenneTwister(), false);\n         final double[] lB = boundaries == null ? null : boundaries[0];\n         final double[] uB = boundaries == null ? null : boundaries[1];\n         PointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n-        Assert.assertEquals(expected.getValue(),\n-                result.getValue(), fTol);\n+        // System.out.println(\"sol=\" + Arrays.toString(result.getPoint()));\n+        Assert.assertEquals(expected.getValue(), result.getValue(), fTol);\n         for (int i = 0; i < dim; i++) {\n-            Assert.assertEquals(expected.getPoint()[i],\n-                    result.getPoint()[i], pointTol);\n+            Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol);\n         }\n     }\n ", "timestamp": 1348841179, "metainfo": ""}