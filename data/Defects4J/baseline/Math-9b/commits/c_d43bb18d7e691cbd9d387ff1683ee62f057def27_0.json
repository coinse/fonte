{"sha": "d43bb18d7e691cbd9d387ff1683ee62f057def27", "log": "Fixes MATH-385  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * Access the lower bound of the support.\n+     *\n+     * @return lower bound of the support (might be Double.NEGATIVE_INFINITY)\n+     */\n+    public abstract double getSupportLowerBound();\n+    \n+    /**\n+     * Access the upper bound of the support.\n+     *\n+     * @return upper bound of the support (might be Double.POSITIVE_INFINITY)\n+     */\n+    public abstract double getSupportUpperBound();\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n \n+    private double numericalMean = Double.NaN;\n+    private boolean numericalMeanIsCalculated = false;\n+    \n+    private double numericalVariance = Double.NaN;\n+    private boolean numericalVarianceIsCalculated = false;\n+    \n     /**\n      * Default constructor.\n      */\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n+    \n+    /**\n+     * Use this method to actually calculate the mean for the \n+     * specific distribution. Use {@link #getNumericalMean()} \n+     * (which implements caching) to actually get the mean.\n+     * \n+     * @return the mean or Double.NaN if it's not defined\n+     */\n+    protected abstract double calculateNumericalMean();\n+    \n+    /**\n+     * Use this method to get the numerical value of the mean of this \n+     * distribution.\n+     *\n+     * @return the mean or Double.NaN if it's not defined\n+     */\n+    public double getNumericalMean() {\n+        if (!numericalMeanIsCalculated) {\n+            numericalMean = calculateNumericalMean();\n+            numericalMeanIsCalculated = true;\n+        }\n+\n+        return numericalMean;\n+    }\n+    \n+    /**\n+     * Use this method to actually calculate the variance for the \n+     * specific distribution.  Use {@link #getNumericalVariance()} \n+     * (which implements caching) to actually get the variance. \n+     *\n+     * @return the variance or Double.NaN if it's not defined\n+     */\n+    protected abstract double calculateNumericalVariance();\n+    \n+    /**\n+     * Use this method to get the numerical value of the variance of this \n+     * distribution.\n+     *\n+     * @return the variance (possibly Double.POSITIVE_INFINITY as \n+     * for certain cases in {@link TDistributionImpl}) or \n+     * Double.NaN if it's not defined\n+     */\n+    public double getNumericalVariance() {\n+        if (!numericalVarianceIsCalculated) {\n+            numericalVariance = calculateNumericalVariance();\n+            numericalVarianceIsCalculated = true;\n+        }\n+        \n+        return numericalVariance;\n+    }    \n+    \n+    /**\n+     * Use this method to get information about whether the lower bound \n+     * of the support is inclusive or not.\n+     *\n+     * @return whether the lower bound of the support is inclusive or not\n+     */\n+    public abstract boolean isSupportLowerBoundInclusive();\n+    \n+    /**\n+     * Use this method to get information about whether the upper bound \n+     * of the support is inclusive or not.\n+     *\n+     * @return whether the upper bound of the support is inclusive or not\n+     */\n+    public abstract boolean isSupportUpperBoundInclusive();    \n+    \n+    /**\n+     * Use this method to get information about whether the support is connected, \n+     * i.e. whether all values between the lower and upper bound of the support\n+     * is included in the support.\n+     * \n+     * For {@link AbstractIntegerDistribution} the support is discrete, so\n+     * if this is true, then the support is \n+     * {lower bound, lower bound + 1, ..., upper bound}.\n+     * \n+     * For {@link AbstractContinuousDistribution} the support is continuous, so\n+     * if this is true, then the support is the interval\n+     * [lower bound, upper bound]\n+     * where the limits are inclusive or not according to \n+     * {@link #isSupportLowerBoundInclusive()} and {@link #isSupportUpperBoundInclusive()} \n+     * (in the example both are true). If both are false, then the support is the interval\n+     * (lower bound, upper bound)\n+     *\n+     * @return whether the support limits given by subclassed methods are connected or not\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n      * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     protected abstract int getDomainUpperBound(double p);\n+    \n+    /**\n+     * Access the lower bound of the support.\n+     *\n+     * @return lower bound of the support (Integer.MIN_VALUE for negative infinity)\n+     */\n+    public abstract int getSupportLowerBound();\n+    \n+    /**\n+     * Access the upper bound of the support.\n+     *\n+     * @return upper bound of the support (Integer.MAX_VALUE for positive infinity)\n+     */\n+    public abstract int getSupportUpperBound();\n+    \n+    /**\n+     * Use this method to get information about whether the lower bound \n+     * of the support is inclusive or not. For discrete support,\n+     * only true here is meaningful.\n+     *\n+     * @return true (always but at Integer.MIN_VALUE because of the nature of discrete support) \n+     */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+    \n+    /**\n+     * Use this method to get information about whether the upper bound \n+     * of the support is inclusive or not. For discrete support,\n+     * only true here is meaningful.\n+     *\n+     * @return true (always but at Integer.MAX_VALUE because of the nature of discrete support) \n+     */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return true;\n+    }    \n }\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always 1 no matter the parameters.\n+     *\n+     * @return upper bound of the support (always 1)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return 1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For first shape parameter <code>s1</code> and \n+     * second shape parameter <code>s2</code>, the mean is\n+     * <code>s1 / (s1 + s2)</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double alpha = getAlpha();\n+        return alpha / (alpha + getBeta());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For first shape parameter <code>s1</code> and \n+     * second shape parameter <code>s2</code>, \n+     * the variance is\n+     * <code>[ s1 * s2 ] / [ (s1 + s2)^2 * (s1 + s2 + 1) ]</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double alpha = getAlpha();\n+        final double beta = getBeta();        \n+        final double alphabetasum = alpha + beta;\n+        return (alpha * beta) / ((alphabetasum * alphabetasum) * (alphabetasum + 1));\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n         // use default bisection impl\n         return super.inverseCumulativeProbability(p);\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the number of trials \n+     * and probability parameter.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return 0;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is the number of trials.\n+     *\n+     * @return upper bound of the support (equal to number of trials)\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return getNumberOfTrials();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For <code>n</code> number of trials and \n+     * probability parameter <code>p</code>, the mean is\n+     * <code>n * p</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return (double)getNumberOfTrials() * getProbabilityOfSuccess();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For <code>n</code> number of trials and \n+     * probability parameter <code>p</code>, the variance is\n+     * <code>n * p * (1 - p)</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double p = getProbabilityOfSuccess();\n+        return (double)getNumberOfTrials() * p * (1 - p);\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n         }\n \n         return ret;\n-    }\n+    }    \n \n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always negative infinity no matter \n+     * the parameters.\n+     *\n+     * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity no matter \n+     * the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The mean is always undefined no matter the parameters.\n+     *\n+     * @return mean (always Double.NaN)\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The variance is always undefined no matter the parameters.\n+     *\n+     * @return variance (always Double.NaN)\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        return Double.NaN;\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the \n+     * degrees of freedom.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity no matter the \n+     * degrees of freedom.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For <code>k</code> degrees of freedom, the mean is\n+     * <code>k</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getDegreesOfFreedom();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For <code>k</code> degrees of freedom, the variance is\n+     * <code>2 * k</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        return 2*getDegreesOfFreedom();\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/Distribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/Distribution.java\n      * @throws IllegalArgumentException if <code>x0 > x1</code>\n      */\n     double cumulativeProbability(double x0, double x1) throws MathException;\n+    \n+    /**\n+     * Use this method to get the numerical value of the mean of this \n+     * distribution.\n+     *\n+     * @return the mean or Double.NaN if it's not defined\n+     */\n+    double getNumericalMean();\n+    \n+    /**\n+     * Use this method to get the numerical value of the variance of this \n+     * distribution.\n+     *\n+     * @return the variance (possibly Double.POSITIVE_INFINITY as \n+     * for certain cases in {@link TDistributionImpl}) or \n+     * Double.NaN if it's not defined\n+     */\n+    double getNumericalVariance(); \n+    \n+    /**\n+     * Use this method to get information about whether the lower bound \n+     * of the support is inclusive or not.\n+     *\n+     * @return whether the lower bound of the support is inclusive or not\n+     */\n+    boolean isSupportLowerBoundInclusive();\n+    \n+    /**\n+     * Use this method to get information about whether the upper bound \n+     * of the support is inclusive or not.\n+     *\n+     * @return whether the upper bound of the support is inclusive or not\n+     */\n+    boolean isSupportUpperBoundInclusive();    \n+    \n+    /**\n+     * Use this method to get information about whether the support is connected, \n+     * i.e. whether all values between the lower and upper bound of the support\n+     * is included in the support.\n+     * \n+     * For {@link AbstractIntegerDistribution} the support is discrete, so\n+     * if this is true, then the support is \n+     * {lower bound, lower bound + 1, ..., upper bound}.\n+     * \n+     * For {@link AbstractContinuousDistribution} the support is continuous, so\n+     * if this is true, then the support is the interval\n+     * [lower bound, upper bound]\n+     * where the limits are inclusive or not according to \n+     * {@link #isSupportLowerBoundInclusive()} and {@link #isSupportUpperBoundInclusive()} \n+     * (in the example both are true). If both are false, then the support is the interval\n+     * (lower bound, upper bound)\n+     *\n+     * @return whether the support limits given by subclassed methods are connected or not\n+     */\n+    boolean isSupportConnected();\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the mean parameter.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity \n+     * no matter the mean parameter.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For mean parameter <code>k</code>, the mean is\n+     * <code>k</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For mean parameter <code>k</code>, the variance is\n+     * <code>k^2</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double mean = getMean();\n+        return mean * mean;\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity \n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For denominator degrees of freedom parameter <code>b</code>, \n+     * the mean is\n+     * <ul>\n+     *  <li>if <code>b &gt; 2</code> then <code>b / (b - 2)</code></li>\n+     *  <li>else <code>undefined</code>\n+     * </ul>\n+     *\n+     * @return {@inheritDoc}\n+     */    \n+    @Override\n+    protected double calculateNumericalMean() {        \n+        final double denominatorDF = getDenominatorDegreesOfFreedom();\n+\n+        if (denominatorDF > 2) {\n+            return denominatorDF / (denominatorDF - 2);     \n+        }\n+        \n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For numerator degrees of freedom parameter <code>a</code> \n+     * and denominator degrees of freedom parameter <code>b</code>, \n+     * the variance is\n+     * <ul>\n+     *  <li>\n+     *    if <code>b &gt; 4</code> then \n+     *    <code>[ 2 * b^2 * (a + b - 2) ] / [ a * (b - 2)^2 * (b - 4) ]</code>\n+     *  </li>\n+     *  <li>else <code>undefined</code>\n+     * </ul>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double denominatorDF = getDenominatorDegreesOfFreedom();\n+\n+        if (denominatorDF > 4) {\n+            final double numeratorDF = getNumeratorDegreesOfFreedom();\n+            final double denomDFMinusTwo = denominatorDF - 2;\n+            \n+            return ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) )\n+                   / ( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );\n+        }\n+        \n+        return Double.NaN;        \n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity \n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For shape parameter <code>alpha</code> and scale \n+     * parameter <code>beta</code>, the mean is\n+     * <code>alpha * beta</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getAlpha() * getBeta();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For shape parameter <code>alpha</code> and scale \n+     * parameter <code>beta</code>, the variance is\n+     * <code>alpha * beta^2</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double beta = getBeta();        \n+        return getAlpha() * beta * beta;\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n         }\n         return ret;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For population size <code>N</code>, \n+     * number of successes <code>m</code>, and \n+     * sample size <code>n</code>, \n+     * the lower bound of the support is\n+     * <code>max(0, n + m - N)</code>\n+     *\n+     * @return lower bound of the support\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return FastMath.max(0, \n+                getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For number of successes <code>m</code> and \n+     * sample size <code>n</code>, \n+     * the upper bound of the support is\n+     * <code>min(m, n)</code>\n+     *\n+     * @return upper bound of the support\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return FastMath.min(getNumberOfSuccesses(), getSampleSize());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For population size <code>N</code>, \n+     * number of successes <code>m</code>, and \n+     * sample size <code>n</code>, the mean is\n+     * <code>n * m / N</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return (double)(getSampleSize() * getNumberOfSuccesses()) / (double)getPopulationSize();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For population size <code>N</code>, \n+     * number of successes <code>m</code>, and \n+     * sample size <code>n</code>, the variance is\n+     * <code>[ n * m * (N - n) * (N - m) ] / [ N^2 * (N - 1) ]</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double N = getPopulationSize();\n+        final double m = getNumberOfSuccesses();\n+        final double n = getSampleSize();\n+        return ( n * m * (N - n) * (N - m) ) / ( (N*N * (N - 1)) );\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n \n         return ret;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always negative infinity \n+     * no matter the parameters.\n+     *\n+     * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity \n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For mean parameter <code>mu</code>, the mean is <code>mu</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For standard deviation parameter <code>s</code>, \n+     * the variance is <code>s^2</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double s = getStandardDeviation();\n+        return s * s;\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n \n         return ret;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity \n+     * no matter the parameters. Positive infinity is symbolised \n+     * by <code>Integer.MAX_VALUE</code> together with \n+     * {@link #isSupportUpperBoundInclusive()} being <code>false</code>\n+     *\n+     * @return upper bound of the support (always <code>Integer.MAX_VALUE</code> for positive infinity)\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For number of successes <code>r</code> and \n+     * probability of success <code>p</code>, the mean is\n+     * <code>( r * p ) / ( 1 - p )</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double p = getProbabilityOfSuccess();\n+        final double r = getNumberOfSuccesses();\n+        return ( r * p ) / ( 1 - p );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For number of successes <code>r</code> and \n+     * probability of success <code>p</code>, the mean is\n+     * <code>( r * p ) / ( 1 - p )^2</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double p = getProbabilityOfSuccess();\n+        final double r = getNumberOfSuccesses();\n+        final double pInv = 1 - p;\n+        return ( r * p ) / (pInv * pInv);\n+    }\n+    \n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n     protected int getDomainUpperBound(double p) {\n         return Integer.MAX_VALUE;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the mean parameter.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is positive infinity, \n+     * regardless of the parameter values. There is no integer infinity, \n+     * so this method returns <code>Integer.MAX_VALUE</code> and\n+     * {@link #isSupportUpperBoundInclusive()} returns <code>true</code>.\n+     *\n+     * @return upper bound of the support (always <code>Integer.MAX_VALUE</code> for positive infinity)\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For mean parameter <code>p</code>, the mean is <code>p</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For mean parameter <code>p</code>, the variance is <code>p</code>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        return getMean();\n+    }\n+    \n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always negative infinity \n+     * no matter the parameters.\n+     *\n+     * @return lower bound of the support (always Double.NEGATIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity \n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For degrees of freedom parameter df, the mean is\n+     * <ul>\n+     *  <li>if <code>df &gt; 1</code> then <code>0</code></li>\n+     * <li>else <code>undefined</code></li>\n+     * </ul>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double df = getDegreesOfFreedom();\n+        \n+        if (df > 1) {\n+            return 0;\n+        }\n+        \n+        return Double.NaN;        \n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For degrees of freedom parameter df, the variance is\n+     * <ul>\n+     *  <li>if <code>df &gt; 2</code> then <code>df / (df - 2)</code> </li>\n+     *  <li>if <code>1 &lt; df &lt;= 2</code> then <code>positive infinity</code></li>\n+     *  <li>else <code>undefined</code></li>\n+     * </ul>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double df = getDegreesOfFreedom();        \n+\n+        if (df > 2) {\n+            return df / (df - 2);\n+        }\n+\n+        if (df > 1 && df <= 2) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        \n+        return Double.NaN;\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.FastMath;\n \n /**\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is always positive infinity \n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The mean is <code>scale * Gamma(1 + (1 / shape))</code>\n+     * where <code>Gamma(...)</code> is the Gamma-function\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double shape = getShape();\n+        final double scale = getScale();\n+\n+        return scale * FastMath.exp(Gamma.logGamma(1 + (1 / shape)));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The variance is \n+     * <code>scale^2 * Gamma(1 + (2 / shape)) - mean^2</code> \n+     * where <code>Gamma(...)</code> is the Gamma-function\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double shape = getShape();\n+        final double scale = getScale();\n+        final double mean = getNumericalMean();\n+\n+        return (scale * scale) * \n+            FastMath.exp(Gamma.logGamma(1 + (2 / shape))) -\n+            (mean * mean);\n+    }\n+\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n         }\n         return value;\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The lower bound of the support is always 1 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 1)\n+     */\n+    @Override\n+    public int getSupportLowerBound() {        \n+        return 1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The upper bound of the support is the number of elements\n+     *\n+     * @return upper bound of the support\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return getNumberOfElements();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For number of elements N and exponent s, the mean is\n+     * <code>Hs1 / Hs</code> where \n+     * <ul>\n+     *  <li><code>Hs1 = generalizedHarmonic(N, s - 1)</code></li> \n+     *  <li><code>Hs = generalizedHarmonic(N, s)</code></li>\n+     * </ul>\n+     *\n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final int N = getNumberOfElements();\n+        final double s = getExponent();\n+        \n+        final double Hs1 = generalizedHarmonic(N, s - 1);\n+        final double Hs = generalizedHarmonic(N, s);\n+\n+        return Hs1 / Hs;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * For number of elements N and exponent s, the mean is\n+     * <code>(Hs2 / Hs) - (Hs1^2 / Hs^2)</code> where \n+     * <ul>\n+     *  <li><code>Hs2 = generalizedHarmonic(N, s - 2)</code></li>\n+     *  <li><code>Hs1 = generalizedHarmonic(N, s - 1)</code></li> \n+     *  <li><code>Hs = generalizedHarmonic(N, s)</code></li>\n+     * </ul>\n+     * \n+     * @return {@inheritDoc}\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final int N = getNumberOfElements();\n+        final double s = getExponent();\n+        \n+        final double Hs2 = generalizedHarmonic(N, s - 2);\n+        final double Hs1 = generalizedHarmonic(N, s - 1);\n+        final double Hs = generalizedHarmonic(N, s);\n+\n+        return (Hs2 / Hs) - ((Hs1 * Hs1) / (Hs * Hs));\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n \n import junit.framework.TestCase;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.FastMath;\n \n public class BetaDistributionTest extends TestCase {\n     public void testCumulative() throws MathException {\n             assertEquals(String.format(\"density at x=%.1f for alpha=%.1f, beta=%.1f\", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);\n         }\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        BetaDistribution dist;\n+        \n+        dist = new BetaDistributionImpl(1, 1);\n+        assertEquals(dist.getNumericalMean(), 0.5, tol);\n+        assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol); \n+        \n+        dist = new BetaDistributionImpl(2, 5);\n+        assertEquals(dist.getNumericalMean(), 2.0 / 7.0, tol);\n+        assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol); \n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n         verifyInverseCumulativeProbabilities();\n     }\n \n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        BinomialDistribution dist;\n+        \n+        dist = new BinomialDistributionImpl(10, 0.5);\n+        assertEquals(dist.getNumericalMean(), 10d * 0.5d, tol);\n+        assertEquals(dist.getNumericalVariance(), 10d * 0.5d * 0.5d, tol); \n+        \n+        dist = new BinomialDistributionImpl(30, 0.3);\n+        assertEquals(dist.getNumericalMean(), 30d * 0.3d, tol);\n+        assertEquals(dist.getNumericalVariance(), 30d * 0.3d * (1d - 0.3d), tol);\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n             // Expected.\n         }\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        CauchyDistribution dist;\n+        \n+        dist = new CauchyDistributionImpl(10.2, 0.15);\n+        assertEquals(dist.getNumericalMean(), Double.NaN, tol);\n+        assertEquals(dist.getNumericalVariance(), Double.NaN, tol); \n+        \n+        dist = new CauchyDistributionImpl(23.12, 2.12);\n+        assertEquals(dist.getNumericalMean(), Double.NaN, tol);\n+        assertEquals(dist.getNumericalVariance(), Double.NaN, tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n         }\n     }\n \n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        ChiSquaredDistribution dist;\n+        \n+        dist = new ChiSquaredDistributionImpl(1500);\n+        assertEquals(dist.getNumericalMean(), 1500, tol);\n+        assertEquals(dist.getNumericalVariance(), 3000, tol); \n+        \n+        dist = new ChiSquaredDistributionImpl(1.12);\n+        assertEquals(dist.getNumericalMean(), 1.12, tol);\n+        assertEquals(dist.getNumericalVariance(), 2.24, tol);\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n             // Expected.\n         }\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        ExponentialDistribution dist;\n+        \n+        dist = new ExponentialDistributionImpl(11d);\n+        assertEquals(dist.getNumericalMean(), 11d, tol);\n+        assertEquals(dist.getNumericalVariance(), 11d * 11d, tol);\n+        \n+        dist = new ExponentialDistributionImpl(10.5d);\n+        assertEquals(dist.getNumericalMean(), 10.5d, tol);\n+        assertEquals(dist.getNumericalVariance(), 10.5d * 10.5d, tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n         x = fd.inverseCumulativeProbability(p);\n         assertEquals(0.975, x, 1.0e-5);\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        FDistribution dist;\n+        \n+        dist = new FDistributionImpl(1, 2);\n+        assertEquals(dist.getNumericalMean(), Double.NaN, tol);\n+        assertEquals(dist.getNumericalVariance(), Double.NaN, tol); \n+        \n+        dist = new FDistributionImpl(1, 3);\n+        assertEquals(dist.getNumericalMean(), 3d / (3d - 2d), tol);\n+        assertEquals(dist.getNumericalVariance(), Double.NaN, tol);\n+        \n+        dist = new FDistributionImpl(1, 5);\n+        assertEquals(dist.getNumericalMean(), 5d / (5d - 2d), tol);\n+        assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol);        \n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n         verifyInverseCumulativeProbabilities();\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        GammaDistribution dist;\n+        \n+        dist = new GammaDistributionImpl(1, 2);\n+        assertEquals(dist.getNumericalMean(), 2, tol);\n+        assertEquals(dist.getNumericalVariance(), 4, tol); \n+        \n+        dist = new GammaDistributionImpl(1.1, 4.2);\n+        assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol);\n+        assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n         };\n         testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        HypergeometricDistribution dist;\n+        \n+        dist = new HypergeometricDistributionImpl(1500, 40, 100);\n+        assertEquals(dist.getNumericalMean(), 40d * 100d / 1500d, tol);\n+        assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol); \n+        \n+        dist = new HypergeometricDistributionImpl(3000, 55, 200);\n+        assertEquals(dist.getNumericalMean(), 55d * 200d / 3000d, tol);\n+        assertEquals(dist.getNumericalVariance(), ( 200d * 55d * (3000d - 200d) * (3000d - 55d) ) / ( (3000d * 3000d * 2999d) ), tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n         assertEquals(2.0, result, defaultTolerance);\n     }\n \n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        NormalDistribution dist;\n+        \n+        dist = new NormalDistributionImpl(0, 1);        \n+        assertEquals(dist.getNumericalMean(), 0, tol);\n+        assertEquals(dist.getNumericalVariance(), 1, tol);        \n+ \n+        dist = new NormalDistributionImpl(2.2, 1.4);\n+        assertEquals(dist.getNumericalMean(), 2.2, tol);\n+        assertEquals(dist.getNumericalVariance(), 1.4 * 1.4, tol);\n+        \n+        dist = new NormalDistributionImpl(-2000.9, 10.4);\n+        assertEquals(dist.getNumericalMean(), -2000.9, tol);\n+        assertEquals(dist.getNumericalVariance(), 10.4 * 10.4, tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        PascalDistribution dist;\n+        \n+        dist = new PascalDistributionImpl(10, 0.5);\n+        assertEquals(dist.getNumericalMean(), ( 10d * 0.5d ) / 0.5d, tol);\n+        assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol); \n+        \n+        dist = new PascalDistributionImpl(25, 0.3);\n+        assertEquals(dist.getNumericalMean(), ( 25d * 0.3d ) / 0.7d, tol);\n+        assertEquals(dist.getNumericalVariance(), ( 25d * 0.3d ) / (0.7d * 0.7d), tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n             mean *= 10.0;\n         }\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        PoissonDistribution dist;\n+        \n+        dist = new PoissonDistributionImpl(1);\n+        assertEquals(dist.getNumericalMean(), 1, tol);\n+        assertEquals(dist.getNumericalVariance(), 1, tol); \n+        \n+        dist = new PoissonDistributionImpl(11.23);\n+        assertEquals(dist.getNumericalMean(), 11.23, tol);\n+        assertEquals(dist.getNumericalVariance(), 11.23, tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n             // expected\n         }\n     }\n+    \n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        TDistribution dist;\n+        \n+        dist = new TDistributionImpl(1);\n+        assertEquals(dist.getNumericalMean(), Double.NaN, tol);\n+        assertEquals(dist.getNumericalVariance(), Double.NaN, tol); \n+        \n+        dist = new TDistributionImpl(1.5);\n+        assertEquals(dist.getNumericalMean(), 0, tol);\n+        assertEquals(dist.getNumericalVariance(), Double.POSITIVE_INFINITY, tol);\n+        \n+        dist = new TDistributionImpl(5);\n+        assertEquals(dist.getNumericalMean(), 0, tol);\n+        assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol);        \n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n \n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n             // Expected.\n         }\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        WeibullDistribution dist;\n+        \n+        dist = new WeibullDistributionImpl(2.5, 3.5);\n+        // In R: 3.5*gamma(1+(1/2.5)) (or emperically: mean(rweibull(10000, 2.5, 3.5)))\n+        assertEquals(dist.getNumericalMean(), 3.5 * FastMath.exp(Gamma.logGamma(1 + (1 / 2.5))), tol);\n+        assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) * \n+                FastMath.exp(Gamma.logGamma(1 + (2 / 2.5))) -\n+                (dist.getNumericalMean() * dist.getNumericalMean()), tol); \n+        \n+        dist = new WeibullDistributionImpl(10.4, 2.222);\n+        assertEquals(dist.getNumericalMean(), 2.222 * FastMath.exp(Gamma.logGamma(1 + (1 / 10.4))), tol);\n+        assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) * \n+                FastMath.exp(Gamma.logGamma(1 + (2 / 10.4))) -\n+                (dist.getNumericalMean() * dist.getNumericalMean()), tol);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+\n+import org.apache.commons.math.util.FastMath;\n \n /**\n  * Test cases for {@link ZipfDistribution}.\n     public int[] makeInverseCumulativeTestValues() {\n         return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};\n     }\n+\n+    public void testMomonts() {\n+        final double tol = 1e-9;\n+        ZipfDistribution dist;\n+        \n+        dist = new ZipfDistributionImpl(2, 0.5);\n+        assertEquals(dist.getNumericalMean(), FastMath.sqrt(2), tol);\n+        assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol); \n+    }\n }", "timestamp": 1293443516, "metainfo": ""}