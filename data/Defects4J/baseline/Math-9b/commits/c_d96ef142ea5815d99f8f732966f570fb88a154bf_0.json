{"sha": "d96ef142ea5815d99f8f732966f570fb88a154bf", "log": "Converted tabs to spaces.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n  * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.\n  *\n- * @version $Revision: 1.22 $ $Date: 2004/06/05 22:28:10 $\n+ * @version $Revision: 1.23 $ $Date: 2004/06/05 22:31:16 $\n  */\n public class RealMatrixImpl implements RealMatrix, Serializable {\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = 4237564493130426188L;\n     \n-\t/** Entries of the matrix */\n-\tprivate double data[][] = null;\n-\n-\t/** Entries of cached LU decomposition.\n-\t *  All updates to data (other than luDecompose()) *must* set this to null\n-\t */\n-\tprivate double lu[][] = null;\n-\n-\t/** Permutation associated with LU decompostion */\n-\tprivate int[] permutation = null;\n-\n-\t/** Parity of the permutation associated with the LU decomposition */\n-\tprivate int parity = 1;\n-\n-\t/** Bound to determine effective singularity in LU decomposition */\n-\tprotected static double TOO_SMALL = 10E-12;\n-\n-\t/** \n-\t * Creates a matrix with no data\n-\t */\n-\tpublic RealMatrixImpl() {\n-\t}\n-\n-\t/**\n-\t * Create a new RealMatrix with the supplied row and column dimensions.\n-\t *\n-\t * @param rowDimension      the number of rows in the new matrix\n-\t * @param columnDimension   the number of columns in the new matrix\n-\t */\n-\tpublic RealMatrixImpl(int rowDimension, int columnDimension) {\n-\t\tdata = new double[rowDimension][columnDimension];\n-\t\tlu = null;\n-\t}\n-\n-\t/**\n-\t * Create a new RealMatrix using the <code>data</code> as the underlying\n-\t * data array.\n-\t * <p>\n-\t * The input array is copied, not referenced.\n-\t *\n-\t * @param d data for new matrix\n-\t */\n-\tpublic RealMatrixImpl(double[][] d) {\n-\t\tthis.copyIn(d);\n-\t\tlu = null;\n-\t}\n-\n-\t/**\n-\t * Create a new (column) RealMatrix using <code>v</code> as the \n-\t * data for the unique column of the <code>v.length x 1</code> matrix \n-\t * created.\n-\t * <p>\n-\t * The input array is copied, not referenced.\n-\t *\n-\t * @param v column vector holding data for new matrix\n-\t */\n-\tpublic RealMatrixImpl(double[] v) {\n-\t\tint nRows = v.length;\n-\t\tdata = new double[nRows][1];\n-\t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tdata[row][0] = v[row];\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Create a new RealMatrix which is a copy of this.\n-\t *\n-\t * @return  the cloned matrix\n-\t */\n-\tpublic RealMatrix copy() {\n-\t\treturn new RealMatrixImpl(this.copyOut());\n-\t}\n-\n-\t/**\n-\t * Compute the sum of this and <code>m</code>.\n-\t *\n-\t * @param m    matrix to be added\n-\t * @return     this + m\n-\t * @throws  IllegalArgumentException if m is not the same size as this\n-\t */\n-\tpublic RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n-\t\tif (this.getColumnDimension() != m.getColumnDimension() ||\n-\t\t\t\tthis.getRowDimension() != m.getRowDimension()) {\n-\t\t\tthrow new IllegalArgumentException(\"matrix dimension mismatch\");\n-\t\t}\n-\t\tint rowCount = this.getRowDimension();\n-\t\tint columnCount = this.getColumnDimension();\n-\t\tdouble[][] outData = new double[rowCount][columnCount];\n-\t\tdouble[][] mData = m.getData();\n-\t\tfor (int row = 0; row < rowCount; row++) {\n-\t\t\tfor (int col = 0; col < columnCount; col++) {\n-\t\t\t\toutData[row][col] = data[row][col] + mData[row][col];\n-\t\t\t}\n-\t\t}\n-\t\treturn new RealMatrixImpl(outData);\n-\t}\n-\n-\t/**\n-\t * Compute  this minus <code>m</code>.\n-\t *\n-\t * @param m    matrix to be subtracted\n-\t * @return     this + m\n-\t * @throws  IllegalArgumentException if m is not the same size as *this\n-\t */\n-\tpublic RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n-\t\tif (this.getColumnDimension() != m.getColumnDimension() ||\n-\t\t\t\tthis.getRowDimension() != m.getRowDimension()) {\n-\t\t\tthrow new IllegalArgumentException(\"matrix dimension mismatch\");\n-\t\t}\n-\t\tint rowCount = this.getRowDimension();\n-\t\tint columnCount = this.getColumnDimension();\n-\t\tdouble[][] outData = new double[rowCount][columnCount];\n-\t\tdouble[][] mData = m.getData();\n-\t\tfor (int row = 0; row < rowCount; row++) {\n-\t\t\tfor (int col = 0; col < columnCount; col++) {\n-\t\t\t\toutData[row][col] = data[row][col] - mData[row][col];\n-\t\t\t}\n-\t\t}\n-\t\treturn new RealMatrixImpl(outData);\n-\t}\n-\n-\t/**\n-\t * Returns the result of adding d to each entry of this.\n-\t *\n-\t * @param d    value to be added to each entry\n-\t * @return     d + this\n-\t */\n-\tpublic RealMatrix scalarAdd(double d) {\n-\t\tint rowCount = this.getRowDimension();\n-\t\tint columnCount = this.getColumnDimension();\n-\t\tdouble[][] outData = new double[rowCount][columnCount];\n-\t\tfor (int row = 0; row < rowCount; row++) {\n-\t\t\tfor (int col = 0; col < columnCount; col++) {\n-\t\t\t\toutData[row][col] = data[row][col] + d;\n-\t\t\t}\n-\t\t}\n-\t\treturn new RealMatrixImpl(outData);\n-\t}\n-\n-\t/**\n-\t * Returns the result multiplying each entry of this by <code>d</code>\n-\t * @param d  value to multiply all entries by\n-\t * @return d * this\n-\t */\n-\tpublic RealMatrix scalarMultiply(double d) {\n-\t\tint rowCount = this.getRowDimension();\n-\t\tint columnCount = this.getColumnDimension();\n-\t\tdouble[][] outData = new double[rowCount][columnCount];\n-\t\tfor (int row = 0; row < rowCount; row++) {\n-\t\t\tfor (int col = 0; col < columnCount; col++) {\n-\t\t\t\toutData[row][col] = data[row][col] * d;\n-\t\t\t}\n-\t\t}\n-\t\treturn new RealMatrixImpl(outData);\n-\t}\n-\n-\t/**\n-\t * Returns the result postmultiplying this by <code>m</code>.\n-\t * @param m    matrix to postmultiply by\n-\t * @return     this*m\n-\t * @throws     IllegalArgumentException\n-\t *             if columnDimension(this) != rowDimension(m)\n-\t */\n-\tpublic RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n-\t\tif (this.getColumnDimension() != m.getRowDimension()) {\n-\t\t\tthrow new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n-\t\t}\n-\t\tint nRows = this.getRowDimension();\n-\t\tint nCols = m.getColumnDimension();\n-\t\tint nSum = this.getColumnDimension();\n-\t\tdouble[][] mData = m.getData();\n-\t\tdouble[][] outData = new double[nRows][nCols];\n-\t\tdouble sum = 0;\n-\t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tfor (int col = 0; col < nCols; col++) {\n-\t\t\t\tsum = 0;\n-\t\t\t\tfor (int i = 0; i < nSum; i++) {\n-\t\t\t\t\tsum += data[row][i] * mData[i][col];\n-\t\t\t\t}\n-\t\t\t\toutData[row][col] = sum;\n-\t\t\t}\n-\t\t}\n-\t\treturn new RealMatrixImpl(outData);\n-\t}\n+    /** Entries of the matrix */\n+    private double data[][] = null;\n+\n+    /** Entries of cached LU decomposition.\n+     *  All updates to data (other than luDecompose()) *must* set this to null\n+     */\n+    private double lu[][] = null;\n+\n+    /** Permutation associated with LU decompostion */\n+    private int[] permutation = null;\n+\n+    /** Parity of the permutation associated with the LU decomposition */\n+    private int parity = 1;\n+\n+    /** Bound to determine effective singularity in LU decomposition */\n+    protected static double TOO_SMALL = 10E-12;\n+\n+    /** \n+     * Creates a matrix with no data\n+     */\n+    public RealMatrixImpl() {\n+    }\n+\n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension      the number of rows in the new matrix\n+     * @param columnDimension   the number of columns in the new matrix\n+     */\n+    public RealMatrixImpl(int rowDimension, int columnDimension) {\n+        data = new double[rowDimension][columnDimension];\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the <code>data</code> as the underlying\n+     * data array.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param d data for new matrix\n+     */\n+    public RealMatrixImpl(double[][] d) {\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new (column) RealMatrix using <code>v</code> as the \n+     * data for the unique column of the <code>v.length x 1</code> matrix \n+     * created.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public RealMatrixImpl(double[] v) {\n+        int nRows = v.length;\n+        data = new double[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+\n+    /**\n+     * Create a new RealMatrix which is a copy of this.\n+     *\n+     * @return  the cloned matrix\n+     */\n+    public RealMatrix copy() {\n+        return new RealMatrixImpl(this.copyOut());\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getColumnDimension() ||\n+                this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        }\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        double[][] mData = m.getData();\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] + mData[row][col];\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as *this\n+     */\n+    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getColumnDimension() ||\n+                this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        }\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        double[][] mData = m.getData();\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] - mData[row][col];\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+\n+    /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    public RealMatrix scalarAdd(double d) {\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] + d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+\n+    /**\n+     * Returns the result multiplying each entry of this by <code>d</code>\n+     * @param d  value to multiply all entries by\n+     * @return d * this\n+     */\n+    public RealMatrix scalarMultiply(double d) {\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col] * d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n+\n+    /**\n+     * Returns the result postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = m.getColumnDimension();\n+        int nSum = this.getColumnDimension();\n+        double[][] mData = m.getData();\n+        double[][] outData = new double[nRows][nCols];\n+        double sum = 0;\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                sum = 0;\n+                for (int i = 0; i < nSum; i++) {\n+                    sum += data[row][i] * mData[i][col];\n+                }\n+                outData[row][col] = sum;\n+            }\n+        }\n+        return new RealMatrixImpl(outData);\n+    }\n     \n     /**\n      * Returns the result premultiplying this by <code>m</code>.\n         return m.multiply(this);\n     }\n \n-\t/**\n-\t * Returns matrix entries as a two-dimensional array.\n-\t * <p>\n-\t * Makes a fresh copy of the underlying data.\n-\t *\n-\t * @return    2-dimensional array of entries\n-\t */\n-\tpublic double[][] getData() {\n-\t\treturn copyOut();\n-\t}\n-\n-\t/**\n-\t * Overwrites the underlying data for the matrix\n-\t * with a fresh copy of <code>inData</code>.\n-\t *\n-\t * @param  inData 2-dimensional array of entries\n-\t */\n-\tpublic void setData(double[][] inData) {\n-\t\tcopyIn(inData);\n-\t\tlu = null;\n-\t}\n-\n-\t/**\n-\t * Returns a reference to the underlying data array.\n-\t * <p>\n-\t * Does not make a fresh copy of the underlying data.\n-\t *\n-\t * @return 2-dimensional array of entries\n-\t */\n-\tpublic double[][] getDataRef() {\n-\t\treturn data;\n-\t}\n-\n-\t/**\n-\t * Overwrites the underlying data for the matrix\n-\t * with a reference to <code>inData</code>.\n-\t * <p>\n-\t * Does not make a fresh copy of <code>data</code>.\n-\t *\n-\t * @param  inData 2-dimensional array of entries\n-\t */\n-\tpublic void setDataRef(double[][] inData) {\n-\t\tthis.data = inData;\n-\t\tlu = null;\n-\t}\n-\n-\t/**\n-\t *\n-\t * @return norm\n-\t */\n-\tpublic double getNorm() {\n-\t\tdouble maxColSum = 0;\n-\t\tfor (int col = 0; col < this.getColumnDimension(); col++) {\n-\t\t\tdouble sum = 0;\n-\t\t\tfor (int row = 0; row < this.getRowDimension(); row++) {\n-\t\t\t\tsum += Math.abs(data[row][col]);\n-\t\t\t}\n-\t\t\tmaxColSum = Math.max(maxColSum, sum);\n-\t\t}\n-\t\treturn maxColSum;\n-\t}\n-\n-\t/**\n-\t * Returns the entries in row number <code>row</code> as an array.\n-\t *\n-\t * @param row the row to be fetched\n-\t * @return array of entries in the row\n-\t * @throws MatrixIndexException if the specified row is greater \n-\t *                              than the number of rows in this matrix\n-\t */\n-\tpublic double[] getRow(int row) throws MatrixIndexException {\n-\t\tif ( !isValidCoordinate( row, 1 ) ) {\n-\t\t\tthrow new MatrixIndexException(\"illegal row argument\");\n-\t\t}\n-\t\tint ncols = this.getColumnDimension();\n-\t\tdouble[] out = new double[ncols];\n-\t\tSystem.arraycopy(data[row - 1], 0, out, 0, ncols);\n-\t\treturn out;\n-\t}\n-\n-\t/**\n-\t * Returns the entries in column number <code>col</code> as an array.\n-\t *\n-\t * @param col  column to fetch\n-\t * @return array of entries in the column\n-\t * @throws MatrixIndexException if the specified column is greater\n-\t *                              than the number of columns in this matrix\n-\t */\n-\tpublic double[] getColumn(int col) throws MatrixIndexException {\n-\t\tif ( !isValidCoordinate(1, col) ) {\n-\t\t\tthrow new MatrixIndexException(\"illegal column argument\");\n-\t\t}\n-\t\tint nRows = this.getRowDimension();\n-\t\tdouble[] out = new double[nRows];\n-\t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tout[row] = data[row][col - 1];\n-\t\t}\n-\t\treturn out;\n-\t}\n-\n-\t/**\n-\t * Returns the entry in the specified row and column.\n-\t *\n-\t * @param row  row location of entry to be fetched  \n-\t * @param column  column location of entry to be fetched\n-\t * @return matrix entry in row,column\n-\t * @throws MatrixIndexException if the specified coordinate is outside \n-\t *                              the dimensions of this matrix\n-\t */\n-\tpublic double getEntry(int row, int column)\n-\t\tthrows MatrixIndexException {\n-\t\tif (!isValidCoordinate(row,column)) {\n-\t\t\tthrow new MatrixIndexException(\"matrix entry does not exist\");\n-\t\t}\n-\t\treturn data[row - 1][column - 1];\n-\t}\n-\n-\t/**\n-\t * Sets the entry in the specified row and column to the specified value.\n-\t *\n-\t * @param row    row location of entry to be set \n-\t * @param column    column location of entry to be set\n-\t * @param value  value to set \n-\t * @throws MatrixIndexException if the specified coordinate is outside\n-\t *                              he dimensions of this matrix\n-\t */\n-\tpublic void setEntry(int row, int column, double value)\n-\t\tthrows MatrixIndexException {\n-\t\tif (!isValidCoordinate(row,column)) {\n-\t\t\tthrow new MatrixIndexException(\"matrix entry does not exist\");\n-\t\t}\n-\t\tdata[row - 1][column - 1] = value;\n-\t\tlu = null;\n-\t}\n-\n-\t/**\n-\t * Returns the transpose matrix.\n-     *\n-\t * @return transpose matrix\n-\t */\n-\tpublic RealMatrix transpose() {\n-\t\tint nRows = this.getRowDimension();\n-\t\tint nCols = this.getColumnDimension();\n-\t\tRealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n-\t\tdouble[][] outData = out.getDataRef();\n-\t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tfor (int col = 0; col < nCols; col++) {\n-\t\t\t\toutData[col][row] = data[row][col];\n-\t\t\t}\n-\t\t}\n-\t\treturn out;\n-\t}\n-\n-\t/**\n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     * <p>\n+     * Makes a fresh copy of the underlying data.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    public double[][] getData() {\n+        return copyOut();\n+    }\n+\n+    /**\n+     * Overwrites the underlying data for the matrix\n+     * with a fresh copy of <code>inData</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setData(double[][] inData) {\n+        copyIn(inData);\n+        lu = null;\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does not make a fresh copy of the underlying data.\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public double[][] getDataRef() {\n+        return data;\n+    }\n+\n+    /**\n+     * Overwrites the underlying data for the matrix\n+     * with a reference to <code>inData</code>.\n+     * <p>\n+     * Does not make a fresh copy of <code>data</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setDataRef(double[][] inData) {\n+        this.data = inData;\n+        lu = null;\n+    }\n+\n+    /**\n+     *\n+     * @return norm\n+     */\n+    public double getNorm() {\n+        double maxColSum = 0;\n+        for (int col = 0; col < this.getColumnDimension(); col++) {\n+            double sum = 0;\n+            for (int row = 0; row < this.getRowDimension(); row++) {\n+                sum += Math.abs(data[row][col]);\n+            }\n+            maxColSum = Math.max(maxColSum, sum);\n+        }\n+        return maxColSum;\n+    }\n+\n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row is greater \n+     *                              than the number of rows in this matrix\n+     */\n+    public double[] getRow(int row) throws MatrixIndexException {\n+        if ( !isValidCoordinate( row, 1 ) ) {\n+            throw new MatrixIndexException(\"illegal row argument\");\n+        }\n+        int ncols = this.getColumnDimension();\n+        double[] out = new double[ncols];\n+        System.arraycopy(data[row - 1], 0, out, 0, ncols);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     *\n+     * @param col  column to fetch\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column is greater\n+     *                              than the number of columns in this matrix\n+     */\n+    public double[] getColumn(int col) throws MatrixIndexException {\n+        if ( !isValidCoordinate(1, col) ) {\n+            throw new MatrixIndexException(\"illegal column argument\");\n+        }\n+        int nRows = this.getRowDimension();\n+        double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = data[row][col - 1];\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Returns the entry in the specified row and column.\n+     *\n+     * @param row  row location of entry to be fetched  \n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the specified coordinate is outside \n+     *                              the dimensions of this matrix\n+     */\n+    public double getEntry(int row, int column)\n+        throws MatrixIndexException {\n+        if (!isValidCoordinate(row,column)) {\n+            throw new MatrixIndexException(\"matrix entry does not exist\");\n+        }\n+        return data[row - 1][column - 1];\n+    }\n+\n+    /**\n+     * Sets the entry in the specified row and column to the specified value.\n+     *\n+     * @param row    row location of entry to be set \n+     * @param column    column location of entry to be set\n+     * @param value  value to set \n+     * @throws MatrixIndexException if the specified coordinate is outside\n+     *                              he dimensions of this matrix\n+     */\n+    public void setEntry(int row, int column, double value)\n+        throws MatrixIndexException {\n+        if (!isValidCoordinate(row,column)) {\n+            throw new MatrixIndexException(\"matrix entry does not exist\");\n+        }\n+        data[row - 1][column - 1] = value;\n+        lu = null;\n+    }\n+\n+    /**\n+     * Returns the transpose matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    public RealMatrix transpose() {\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n+        double[][] outData = out.getDataRef();\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                outData[col][row] = data[row][col];\n+            }\n+        }\n+        return out;\n+    }\n+\n+    /**\n      * Returns the inverse matrix if this matrix is invertible.\n      * \n-\t * @return inverse matrix\n-\t * @throws InvalidMatrixException if this is not invertible\n-\t */\n-\tpublic RealMatrix inverse() throws InvalidMatrixException {\n-\t\treturn solve(getIdentity(this.getRowDimension()));\n-\t}\n-\n-\t/**\n-\t * @return determinant\n-\t * @throws InvalidMatrixException if matrix is not square\n-\t */\n-\tpublic double getDeterminant() throws InvalidMatrixException {\n-\t\tif (!isSquare()) {\n-\t\t\tthrow new InvalidMatrixException(\"matrix is not square\");\n-\t\t}\n-\t\tif (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n-\t\t\treturn 0d;  \n-\t\t} else {\n-\t\t\tdouble det = (double) parity;\n-\t\t\tfor (int i = 0; i < this.getRowDimension(); i++) {\n-\t\t\t\tdet *= lu[i][i];\n-\t\t\t}\n-\t\t\treturn det;\n-\t\t}\n-\t}\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if this is not invertible\n+     */\n+    public RealMatrix inverse() throws InvalidMatrixException {\n+        return solve(getIdentity(this.getRowDimension()));\n+    }\n+\n+    /**\n+     * @return determinant\n+     * @throws InvalidMatrixException if matrix is not square\n+     */\n+    public double getDeterminant() throws InvalidMatrixException {\n+        if (!isSquare()) {\n+            throw new InvalidMatrixException(\"matrix is not square\");\n+        }\n+        if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n+            return 0d;  \n+        } else {\n+            double det = (double) parity;\n+            for (int i = 0; i < this.getRowDimension(); i++) {\n+                det *= lu[i][i];\n+            }\n+            return det;\n+        }\n+    }\n     \n-\t/**\n-\t * @return true if the matrix is square (rowDimension = columnDimension)\n-\t */\n-\tpublic boolean isSquare() {\n-\t\treturn (this.getColumnDimension() == this.getRowDimension());\n-\t}\n-\n-\t/**\n-\t * @return true if the matrix is singular\n-\t */\n-\tpublic boolean isSingular() {\n-\t\tif (lu == null) {\n-\t\t\ttry {\n-\t\t\t\tluDecompose();\n-\t\t\t\treturn false;\n-\t\t\t} catch (InvalidMatrixException ex) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t} else { // LU decomp must have been successfully performed\n-\t\t\treturn false; // so the matrix is not singular\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * @return rowDimension\n-\t */\n-\tpublic int getRowDimension() {\n-\t\treturn data.length;\n-\t}\n-\n-\t/**\n-\t * @return columnDimension\n-\t */\n-\tpublic int getColumnDimension() {\n-\t\treturn data[0].length;\n-\t}\n-\n-\t/**\n-\t * @return trace\n-\t * @throws IllegalArgumentException if the matrix is not square\n-\t */\n-\tpublic double getTrace() throws IllegalArgumentException {\n-\t\tif (!isSquare()) {\n-\t\t\tthrow new IllegalArgumentException(\"matrix is not square\");\n-\t\t}\n-\t\tdouble trace = data[0][0];\n-\t\tfor (int i = 1; i < this.getRowDimension(); i++) {\n-\t\t\ttrace += data[i][i];\n-\t\t}\n-\t\treturn trace;\n-\t}\n-\n-\t/**\n-\t * @param v vector to operate on\n-\t * @throws IllegalArgumentException if columnDimension != v.length\n-\t * @return resulting vector\n-\t */\n-\tpublic double[] operate(double[] v) throws IllegalArgumentException {\n-\t\tif (v.length != this.getColumnDimension()) {\n-\t\t\tthrow new IllegalArgumentException(\"vector has wrong length\");\n-\t\t}\n-\t\tint nRows = this.getRowDimension();\n-\t\tint nCols = this.getColumnDimension();\n-\t\tdouble[] out = new double[v.length];\n-\t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tdouble sum = 0;\n-\t\t\tfor (int i = 0; i < nCols; i++) {\n-\t\t\t\tsum += data[row][i] * v[i];\n-\t\t\t}\n-\t\t\tout[row] = sum;\n-\t\t}\n-\t\treturn out;\n-\t}\n-\n-\t/**\n-\t * @param v vector to premultiply by\n-\t * @throws IllegalArgumentException if rowDimension != v.length\n-\t * @return resulting matrix\n-\t */\n-\tpublic double[] preMultiply(double[] v) throws IllegalArgumentException {\n-\t\tint nRows = this.getRowDimension();\n-\t\tif (v.length != nRows) {\n-\t\t\tthrow new IllegalArgumentException(\"vector has wrong length\");\n-\t\t}\n+    /**\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    public boolean isSquare() {\n+        return (this.getColumnDimension() == this.getRowDimension());\n+    }\n+\n+    /**\n+     * @return true if the matrix is singular\n+     */\n+    public boolean isSingular() {\n+        if (lu == null) {\n+            try {\n+                luDecompose();\n+                return false;\n+            } catch (InvalidMatrixException ex) {\n+                return true;\n+            }\n+        } else { // LU decomp must have been successfully performed\n+            return false; // so the matrix is not singular\n+        }\n+    }\n+\n+    /**\n+     * @return rowDimension\n+     */\n+    public int getRowDimension() {\n+        return data.length;\n+    }\n+\n+    /**\n+     * @return columnDimension\n+     */\n+    public int getColumnDimension() {\n+        return data[0].length;\n+    }\n+\n+    /**\n+     * @return trace\n+     * @throws IllegalArgumentException if the matrix is not square\n+     */\n+    public double getTrace() throws IllegalArgumentException {\n+        if (!isSquare()) {\n+            throw new IllegalArgumentException(\"matrix is not square\");\n+        }\n+        double trace = data[0][0];\n+        for (int i = 1; i < this.getRowDimension(); i++) {\n+            trace += data[i][i];\n+        }\n+        return trace;\n+    }\n+\n+    /**\n+     * @param v vector to operate on\n+     * @throws IllegalArgumentException if columnDimension != v.length\n+     * @return resulting vector\n+     */\n+    public double[] operate(double[] v) throws IllegalArgumentException {\n+        if (v.length != this.getColumnDimension()) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        double[] out = new double[v.length];\n+        for (int row = 0; row < nRows; row++) {\n+            double sum = 0;\n+            for (int i = 0; i < nCols; i++) {\n+                sum += data[row][i] * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * @param v vector to premultiply by\n+     * @throws IllegalArgumentException if rowDimension != v.length\n+     * @return resulting matrix\n+     */\n+    public double[] preMultiply(double[] v) throws IllegalArgumentException {\n+        int nRows = this.getRowDimension();\n+        if (v.length != nRows) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n         int nCols = this.getColumnDimension();\n         double[] out = new double[nCols];\n         for (int col = 0; col < nCols; col++) {\n             out[col] = sum;\n         }\n         return out;\n-\t}\n-\n-\t/**\n-\t * Returns a matrix of (column) solution vectors for linear systems with\n-\t * coefficient matrix = this and constant vectors = columns of\n-\t * <code>b</code>. \n-\t *\n-\t * @param b  array of constant forming RHS of linear systems to\n-\t * to solve\n-\t * @return solution array\n-\t * @throws IllegalArgumentException if this.rowDimension != row dimension\n-\t * @throws InvalidMatrixException if this matrix is not square or is singular\n-\t */\n-\tpublic double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-\t\tint nRows = this.getRowDimension();\n-\t\tif (b.length != nRows) {\n-\t\t\tthrow new IllegalArgumentException(\"constant vector has wrong length\");\n-\t\t}\n-\t\tRealMatrix bMatrix = new RealMatrixImpl(b);\n-\t\tdouble[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n-\t\tdouble[] out = new double[nRows];\n-\t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tout[row] = solution[row][0];\n-\t\t}\n-\t\treturn out;\n-\t}\n-\n-\t/**\n-\t * Returns a matrix of (column) solution vectors for linear systems with\n-\t * coefficient matrix = this and constant vectors = columns of\n-\t * <code>b</code>. \n-\t *\n-\t * @param b  matrix of constant vectors forming RHS of linear systems to\n-\t * to solve\n-\t * @return matrix of solution vectors\n-\t * @throws IllegalArgumentException if this.rowDimension != row dimension\n-\t * @throws InvalidMatrixException if this matrix is not square or is singular\n-\t */\n-\tpublic RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n-\t\tif (b.getRowDimension() != this.getRowDimension()) {\n-\t\t\tthrow new IllegalArgumentException(\"Incorrect row dimension\");\n-\t\t}\n-\t\tif (!this.isSquare()) {\n-\t\t\tthrow new InvalidMatrixException(\"coefficient matrix is not square\");\n-\t\t}\n-\t\tif (this.isSingular()) { // side effect: compute LU decomp\n-\t\t\tthrow new InvalidMatrixException(\"Matrix is singular.\");\n-\t\t}\n-\n-\t\tint nCol = this.getColumnDimension();\n-\t\tint nColB = b.getColumnDimension();\n-\t\tint nRowB = b.getRowDimension();\n-\n-\t\t// Apply permutations to b\n-\t\tdouble[][] bv = b.getData();\n-\t\tdouble[][] bp = new double[nRowB][nColB];\n-\t\tfor (int row = 0; row < nRowB; row++) {\n-\t\t\tfor (int col = 0; col < nColB; col++) {\n-\t\t\t\tbp[row][col] = bv[permutation[row]][col];\n-\t\t\t}\n-\t\t}\n-\t\tbv = null;\n-\n-\t\t// Solve LY = b\n-\t\tfor (int col = 0; col < nCol; col++) {\n-\t\t\tfor (int i = col + 1; i < nCol; i++) {\n-\t\t\t\tfor (int j = 0; j < nColB; j++) {\n-\t\t\t\t\tbp[i][j] -= bp[col][j] * lu[i][col];\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Solve UX = Y\n-\t\tfor (int col = nCol - 1; col >= 0; col--) {\n-\t\t\tfor (int j = 0; j < nColB; j++) {\n-\t\t\t\tbp[col][j] /= lu[col][col];\n-\t\t\t}\n-\t\t\tfor (int i = 0; i < col; i++) {\n-\t\t\t\tfor (int j = 0; j < nColB; j++) {\n-\t\t\t\t\tbp[i][j] -= bp[col][j] * lu[i][col];\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tRealMatrixImpl outMat = new RealMatrixImpl(bp);\n-\t\treturn outMat;\n-\t}\n-\n-\t/**\n-\t * Computes a new \n-\t * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n-\t * LU decompostion</a> for this matrix, storing the result for use by other methods. \n-\t * <p>\n-\t * <strong>Implementation Note</strong>:<br>\n-\t * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n-\t * Crout's algortithm</a>, with partial pivoting.\n-\t * <p>\n-\t * <strong>Usage Note</strong>:<br>\n-\t * This method should rarely be invoked directly. Its only use is\n-\t * to force recomputation of the LU decomposition when changes have been\n-\t * made to the underlying data using direct array references. Changes\n-\t * made using setXxx methods will trigger recomputation when needed\n-\t * automatically.\n-\t *\n-\t * @throws InvalidMatrixException if the matrix is non-square or singular.\n-\t */\n-\tpublic void luDecompose() throws InvalidMatrixException {\n-\t\t \n-\t\tint nRows = this.getRowDimension();\n-\t\tint nCols = this.getColumnDimension();\n-\t\tif (nRows != nCols) {\n-\t\t\tthrow new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n-\t\t}\n-\t\tlu = this.getData();\n-\n-\t\t// Initialize permutation array and parity\n-\t\tpermutation = new int[nRows];\n-\t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tpermutation[row] = row;\n-\t\t}\n-\t\tparity = 1;\n-\n-\t\t// Loop over columns\n-\t\tfor (int col = 0; col < nCols; col++) {\n-\n-\t\t\tdouble sum = 0;\n-\n-\t\t\t// upper\n-\t\t\tfor (int row = 0; row < col; row++) {\n-\t\t\t\tsum = lu[row][col];\n-\t\t\t\tfor (int i = 0; i < row; i++) {\n-\t\t\t\t\tsum -= lu[row][i] * lu[i][col];\n-\t\t\t\t}\n-\t\t\t\tlu[row][col] = sum;\n-\t\t\t}\n-\n-\t\t\t// lower\n-\t\t\tint max = col; // permutation row\n-\t\t\tdouble largest = 0d;\n-\t\t\tfor (int row = col; row < nRows; row++) {\n-\t\t\t\tsum = lu[row][col];\n-\t\t\t\tfor (int i = 0; i < col; i++) {\n-\t\t\t\t\tsum -= lu[row][i] * lu[i][col];\n-\t\t\t\t}\n-\t\t\t\tlu[row][col] = sum;\n-\n-\t\t\t\t// maintain best permutation choice\n-\t\t\t\tif (Math.abs(sum) > largest) {\n-\t\t\t\t\tlargest = Math.abs(sum);\n-\t\t\t\t\tmax = row;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Singularity check\n-\t\t\tif (Math.abs(lu[max][col]) < TOO_SMALL) {\n-\t\t\t\tlu = null;\n-\t\t\t\tthrow new InvalidMatrixException(\"matrix is singular\");\n-\t\t\t}\n-\n-\t\t\t// Pivot if necessary\n-\t\t\tif (max != col) {\n-\t\t\t\tdouble tmp = 0;\n-\t\t\t\tfor (int i = 0; i < nCols; i++) {\n-\t\t\t\t\ttmp = lu[max][i];\n-\t\t\t\t\tlu[max][i] = lu[col][i];\n-\t\t\t\t\tlu[col][i] = tmp;\n-\t\t\t\t}\n-\t\t\t\tint temp = permutation[max];\n-\t\t\t\tpermutation[max] = permutation[col];\n-\t\t\t\tpermutation[col] = temp;\n-\t\t\t\tparity = -parity;\n-\t\t\t}\n-\n-\t\t\t//Divide the lower elements by the \"winning\" diagonal elt.\n-\t\t\tfor (int row = col + 1; row < nRows; row++) {\n-\t\t\t\tlu[row][col] /= lu[col][col];\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * \n-\t * @see java.lang.Object#toString()\n-\t */\n-\tpublic String toString() {\n-\t\tStringBuffer res = new StringBuffer();\n-\t\tres.append(\"RealMatrixImpl{\");\n-\t\tfor (int i = 0; i < data.length; i++) {\n-\t\t\tif (i > 0)\n-\t\t\t\tres.append(\",\");\n-\t\t\tres.append(\"{\");\n-\t\t\tfor (int j = 0; j < data[0].length; j++) {\n-\t\t\t\tif (j > 0)\n-\t\t\t\t\tres.append(\",\");\n-\t\t\t\tres.append(data[i][j]);\n-\t\t\t} //for\n-\t\t\tres.append(\"}\");\n-\t\t} //for\n-\t\tres.append(\"}\");\n-\t\treturn res.toString();\n-\t} //toString\n-\n-\t//------------------------ Protected methods\n-\n-\t/**\n-\t * Returns <code>dimension x dimension</code> identity matrix.\n-\t *\n-\t * @param dimension dimension of identity matrix to generate\n-\t * @return identity matrix\n-\t */\n-\tprotected RealMatrix getIdentity(int dimension) {\n-\t\tRealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n-\t\tdouble[][] d = out.getDataRef();\n-\t\tfor (int row = 0; row < dimension; row++) {\n-\t\t\tfor (int col = 0; col < dimension; col++) {\n-\t\t\t\td[row][col] = row == col ? 1d : 0d;\n-\t\t\t}\n-\t\t}\n-\t\treturn out;\n-\t}\n-\t\n-\t/**\n-\t *  Returns the LU decomposition as a RealMatrix.\n-\t *  Returns a fresh copy of the cached LU matrix if this has been computed; \n-\t *  otherwise the composition is computed and cached for use by other methods.   \n-\t *  Since a copy is returned in either case, changes to the returned matrix do not \n-\t *  affect the LU decomposition property. \n-\t * <p>\n-\t * The matrix returned is a compact representation of the LU decomposition. \n-\t * Elements below the main diagonal correspond to entries of the \"L\" matrix;   \n-\t * elements on and above the main diagonal correspond to entries of the \"U\"\n-\t * matrix.\n-\t * <p>\n-\t * Example: <pre>\n-\t * \n-\t *     Returned matrix                L                  U\n-\t *         2  3  1                   1  0  0            2  3  1          \n-\t *         5  4  6                   5  1  0            0  4  6\n-\t *         1  7  8                   1  7  1            0  0  8          \n-\t * </pre>\n-\t * \n-\t * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n-\t *  where permuteRows reorders the rows of the matrix to follow the order determined\n-\t *  by the <a href=#getPermutation()>permutation</a> property.\n-\t * \n-\t * @return LU decomposition matrix\n-\t * @throws InvalidMatrixException if the matrix is non-square or singular.\n-\t */\n-\tprotected RealMatrix getLUMatrix() throws InvalidMatrixException {\n-\t    if (lu == null) {\n-\t        luDecompose();\n-\t    }\n-\t    return new RealMatrixImpl(lu);   \n-\t}\n-\t\n-\t/**\n-\t * Returns the permutation associated with the lu decomposition.\n-\t * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n-\t * <p>\n-\t * Example:\n-\t * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n-\t * and current first row is last.\n-\t * <p>\n-\t * Returns a fresh copy of the array.\n-\t * \n-\t * @return the permutation\n-\t */\n-\tprotected int[] getPermutation() {\n-\t    int[] out = new int[permutation.length];\n-\t    System.arraycopy(permutation, 0, out, 0, permutation.length);\n-\t    return out;\n-\t}\n-\n-\t//------------------------ Private methods\n-\n-\t/**\n-\t * Returns a fresh copy of the underlying data array.\n-\t *\n-\t * @return a copy of the underlying data array.\n-\t */\n-\tprivate double[][] copyOut() {\n-\t\tint nRows = this.getRowDimension();\n-\t\tdouble[][] out = new double[nRows][this.getColumnDimension()];\n-\t\t// can't copy 2-d array in one shot, otherwise get row references\n-\t\tfor (int i = 0; i < nRows; i++) {\n-\t\t\tSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\n-\t\t}\n-\t\treturn out;\n-\t}\n-\n-\t/**\n-\t * Replaces data with a fresh copy of the input array.\n-\t *\n-\t * @param in data to copy in\n-\t */\n-\tprivate void copyIn(double[][] in) {\n-\t\tint nRows = in.length;\n-\t\tint nCols = in[0].length;\n-\t\tdata = new double[nRows][nCols];\n-\t\tSystem.arraycopy(in, 0, data, 0, in.length);\n-\t\tfor (int i = 0; i < nRows; i++) {\n-\t\t\tSystem.arraycopy(in[i], 0, data[i], 0, nCols);\n-\t\t}\n-\t\tlu = null;\n-\t}\n-\n-\t/**\n-\t * Tests a given coordinate as being valid or invalid\n-\t *\n-\t * @param row the row index.\n-\t * @param col the column index.\n-\t * @return true if the coordinate is with the current dimensions\n-\t */\n-\tprivate boolean isValidCoordinate(int row, int col) {\n-\t\tint nRows = this.getRowDimension();\n-\t\tint nCols = this.getColumnDimension();\n-\n-\t\treturn !(row < 1 || row > nRows || col < 1 || col > nCols);\n-\t}\n-\t\n+    }\n+\n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  array of constant forming RHS of linear systems to\n+     * to solve\n+     * @return solution array\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n+        int nRows = this.getRowDimension();\n+        if (b.length != nRows) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        RealMatrix bMatrix = new RealMatrixImpl(b);\n+        double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n+        double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = solution[row][0];\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n+        if (b.getRowDimension() != this.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (!this.isSquare()) {\n+            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n+        }\n+        if (this.isSingular()) { // side effect: compute LU decomp\n+            throw new InvalidMatrixException(\"Matrix is singular.\");\n+        }\n+\n+        int nCol = this.getColumnDimension();\n+        int nColB = b.getColumnDimension();\n+        int nRowB = b.getRowDimension();\n+\n+        // Apply permutations to b\n+        double[][] bv = b.getData();\n+        double[][] bp = new double[nRowB][nColB];\n+        for (int row = 0; row < nRowB; row++) {\n+            for (int col = 0; col < nColB; col++) {\n+                bp[row][col] = bv[permutation[row]][col];\n+            }\n+        }\n+        bv = null;\n+\n+        // Solve LY = b\n+        for (int col = 0; col < nCol; col++) {\n+            for (int i = col + 1; i < nCol; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                }\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        for (int col = nCol - 1; col >= 0; col--) {\n+            for (int j = 0; j < nColB; j++) {\n+                bp[col][j] /= lu[col][col];\n+            }\n+            for (int i = 0; i < col; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] -= bp[col][j] * lu[i][col];\n+                }\n+            }\n+        }\n+\n+        RealMatrixImpl outMat = new RealMatrixImpl(bp);\n+        return outMat;\n+    }\n+\n+    /**\n+     * Computes a new \n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decompostion</a> for this matrix, storing the result for use by other methods. \n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algortithm</a>, with partial pivoting.\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.\n+     *\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     */\n+    public void luDecompose() throws InvalidMatrixException {\n+         \n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        if (nRows != nCols) {\n+            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n+        }\n+        lu = this.getData();\n+\n+        // Initialize permutation array and parity\n+        permutation = new int[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            permutation[row] = row;\n+        }\n+        parity = 1;\n+\n+        // Loop over columns\n+        for (int col = 0; col < nCols; col++) {\n+\n+            double sum = 0;\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= lu[row][i] * lu[i][col];\n+                }\n+                lu[row][col] = sum;\n+            }\n+\n+            // lower\n+            int max = col; // permutation row\n+            double largest = 0d;\n+            for (int row = col; row < nRows; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= lu[row][i] * lu[i][col];\n+                }\n+                lu[row][col] = sum;\n+\n+                // maintain best permutation choice\n+                if (Math.abs(sum) > largest) {\n+                    largest = Math.abs(sum);\n+                    max = row;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n+                lu = null;\n+                throw new InvalidMatrixException(\"matrix is singular\");\n+            }\n+\n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                for (int i = 0; i < nCols; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = permutation[max];\n+                permutation[max] = permutation[col];\n+                permutation[col] = temp;\n+                parity = -parity;\n+            }\n+\n+            //Divide the lower elements by the \"winning\" diagonal elt.\n+            for (int row = col + 1; row < nRows; row++) {\n+                lu[row][col] /= lu[col][col];\n+            }\n+        }\n+    }\n+\n+    /**\n+     * \n+     * @see java.lang.Object#toString()\n+     */\n+    public String toString() {\n+        StringBuffer res = new StringBuffer();\n+        res.append(\"RealMatrixImpl{\");\n+        for (int i = 0; i < data.length; i++) {\n+            if (i > 0)\n+                res.append(\",\");\n+            res.append(\"{\");\n+            for (int j = 0; j < data[0].length; j++) {\n+                if (j > 0)\n+                    res.append(\",\");\n+                res.append(data[i][j]);\n+            } //for\n+            res.append(\"}\");\n+        } //for\n+        res.append(\"}\");\n+        return res.toString();\n+    } //toString\n+\n+    //------------------------ Protected methods\n+\n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     */\n+    protected RealMatrix getIdentity(int dimension) {\n+        RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n+        double[][] d = out.getDataRef();\n+        for (int row = 0; row < dimension; row++) {\n+            for (int col = 0; col < dimension; col++) {\n+                d[row][col] = row == col ? 1d : 0d;\n+            }\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     *  Returns the LU decomposition as a RealMatrix.\n+     *  Returns a fresh copy of the cached LU matrix if this has been computed; \n+     *  otherwise the composition is computed and cached for use by other methods.   \n+     *  Since a copy is returned in either case, changes to the returned matrix do not \n+     *  affect the LU decomposition property. \n+     * <p>\n+     * The matrix returned is a compact representation of the LU decomposition. \n+     * Elements below the main diagonal correspond to entries of the \"L\" matrix;   \n+     * elements on and above the main diagonal correspond to entries of the \"U\"\n+     * matrix.\n+     * <p>\n+     * Example: <pre>\n+     * \n+     *     Returned matrix                L                  U\n+     *         2  3  1                   1  0  0            2  3  1          \n+     *         5  4  6                   5  1  0            0  4  6\n+     *         1  7  8                   1  7  1            0  0  8          \n+     * </pre>\n+     * \n+     * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n+     *  where permuteRows reorders the rows of the matrix to follow the order determined\n+     *  by the <a href=#getPermutation()>permutation</a> property.\n+     * \n+     * @return LU decomposition matrix\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     */\n+    protected RealMatrix getLUMatrix() throws InvalidMatrixException {\n+        if (lu == null) {\n+            luDecompose();\n+        }\n+        return new RealMatrixImpl(lu);   \n+    }\n+    \n+    /**\n+     * Returns the permutation associated with the lu decomposition.\n+     * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n+     * <p>\n+     * Example:\n+     * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n+     * and current first row is last.\n+     * <p>\n+     * Returns a fresh copy of the array.\n+     * \n+     * @return the permutation\n+     */\n+    protected int[] getPermutation() {\n+        int[] out = new int[permutation.length];\n+        System.arraycopy(permutation, 0, out, 0, permutation.length);\n+        return out;\n+    }\n+\n+    //------------------------ Private methods\n+\n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private double[][] copyOut() {\n+        int nRows = this.getRowDimension();\n+        double[][] out = new double[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     *\n+     * @param in data to copy in\n+     */\n+    private void copyIn(double[][] in) {\n+        int nRows = in.length;\n+        int nCols = in[0].length;\n+        data = new double[nRows][nCols];\n+        System.arraycopy(in, 0, data, 0, in.length);\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(in[i], 0, data[i], 0, nCols);\n+        }\n+        lu = null;\n+    }\n+\n+    /**\n+     * Tests a given coordinate as being valid or invalid\n+     *\n+     * @param row the row index.\n+     * @param col the column index.\n+     * @return true if the coordinate is with the current dimensions\n+     */\n+    private boolean isValidCoordinate(int row, int col) {\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+\n+        return !(row < 1 || row > nRows || col < 1 || col > nCols);\n+    }\n+    \n }", "timestamp": 1086474676, "metainfo": ""}