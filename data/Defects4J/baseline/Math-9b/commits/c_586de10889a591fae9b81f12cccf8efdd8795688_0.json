{"sha": "586de10889a591fae9b81f12cccf8efdd8795688", "log": "Code cleanup: Removed unnecessary parentheses, empty lines. Bitwise operator replaced by logical one.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n  * @since 2.0\n  */\n public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n-\n     /** Relative threshold for small singular values. */\n     private static final double EPS = 0x1.0p-52;\n-\n     /** Absolute threshold for small singular values. */\n     private static final double TINY = 0x1.0p-966;\n-\n     /** Computed singular values. */\n     private final double[] singularValues;\n-\n     /** max(row dimension, column dimension). */\n     private final int m;\n-\n     /** min(row dimension, column dimension). */\n     private final int n;\n-\n     /** Indicator for transposed matrix. */\n     private final boolean transposed;\n-\n     /** Cached value of U matrix. */\n     private final RealMatrix cachedU;\n-\n     /** Cached value of transposed U matrix. */\n     private RealMatrix cachedUt;\n-\n     /** Cached value of S (diagonal) matrix. */\n     private RealMatrix cachedS;\n-\n     /** Cached value of V matrix. */\n     private final RealMatrix cachedV;\n-\n     /** Cached value of transposed V matrix. */\n     private RealMatrix cachedVt;\n \n                 singularValues[k] = -singularValues[k];\n             }\n             for (int j = k + 1; j < n; j++) {\n-                if ((k < nct) && (singularValues[k] != 0.0)) {\n+                if (k < nct &&\n+                    singularValues[k] != 0.0) {\n                     // Apply the transformation.\n                     double t = 0;\n                     for (int i = k; i < m; i++) {\n                 // subsequent calculation of the row transformation.\n                 e[j] = A[k][j];\n             }\n-            if (wantu && (k < nct)) {\n+            if (wantu &&\n+                k < nct) {\n                 // Place the transformation in U for subsequent back\n                 // multiplication.\n                 for (int i = k; i < m; i++) {\n                     e[k + 1] += 1.0;\n                 }\n                 e[k] = -e[k];\n-                if ((k + 1 < m) && (e[k] != 0.0)) {\n+                if (k + 1 < m &&\n+                    e[k] != 0) {\n                     // Apply the transformation.\n                     for (int i = k + 1; i < m; i++) {\n                         work[i] = 0.0;\n         // If required, generate V.\n         if (wantv) {\n             for (int k = n - 1; k >= 0; k--) {\n-                if ((k < nrt) && (e[k] != 0.0)) {\n+                if (k < nrt &&\n+                    e[k] != 0) {\n                     for (int j = k + 1; j < nu; j++) {\n                         double t = 0;\n                         for (int i = k + 1; i < n; i++) {\n                     final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                     final double c = (sp * epm1) * (sp * epm1);\n                     double shift = 0.0;\n-                    if ((b != 0.0) | (c != 0.0)) {\n+                    if (b != 0 ||\n+                        c != 0) {\n                         shift = FastMath.sqrt(b * b + c);\n                         if (b < 0.0) {\n                             shift = -shift;\n                         singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                         g = sn * e[j + 1];\n                         e[j + 1] = cs * e[j + 1];\n-                        if (wantu && (j < m - 1)) {\n+                        if (wantu &&\n+                            j < m - 1) {\n                             for (int i = 0; i < m; i++) {\n                                 t = cs * U[i][j] + sn * U[i][j + 1];\n                                 U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                         double t = singularValues[k];\n                         singularValues[k] = singularValues[k + 1];\n                         singularValues[k + 1] = t;\n-                        if (wantv && (k < n - 1)) {\n+                        if (wantv &&\n+                            k < n - 1) {\n                             for (int i = 0; i < n; i++) {\n                                 t = V[i][k + 1];\n                                 V[i][k + 1] = V[i][k];\n                                 V[i][k] = t;\n                             }\n                         }\n-                        if (wantu && (k < m - 1)) {\n+                        if (wantu &&\n+                            k < m - 1) {\n                             for (int i = 0; i < m; i++) {\n                                 t = U[i][k + 1];\n                                 U[i][k + 1] = U[i][k];\n         // get the number of singular values to consider\n         final int p = singularValues.length;\n         int dimension = 0;\n-        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n+        while (dimension < p &&\n+               singularValues[dimension] >= minSingularValue) {\n             ++dimension;\n         }\n ", "timestamp": 1313188649, "metainfo": ""}