{"sha": "1560839416cb0784bb9e27eab1f2aa0362d75371", "log": "extracted a CompositeFormat base class from ComplexFormat  ", "commit": "\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n \n package org.apache.commons.math.complex;\n \n-import java.io.Serializable;\n import java.text.FieldPosition;\n-import java.text.Format;\n import java.text.NumberFormat;\n import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math.util.CompositeFormat;\n+\n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n- * be replaced with 'j', and the number format for both real and imaginary parts\n- * can be configured.\n+ * be replaced with 'j' (or anything else), and the number format for both real\n+ * and imaginary parts can be configured.\n  *\n  * @author Apache Software Foundation\n  * @version $Revision$ $Date$\n  */\n-public class ComplexFormat extends Format implements Serializable {\n+public class ComplexFormat extends CompositeFormat {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -6337346779577272306L;\n-    \n-    /** The default imaginary character. */\n+    private static final long serialVersionUID = -3343698360149467646L;\n+\n+     /** The default imaginary character. */\n     private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n     \n     /** The notation used to signify the imaginary part of the complex number. */\n      * @param realFormat the custom format for the real part.\n      * @param imaginaryFormat the custom format for the imaginary part.\n      */\n-    public ComplexFormat(NumberFormat realFormat,\n-            NumberFormat imaginaryFormat) {\n+    public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {\n         this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n     }\n     \n     }\n \n     /**\n-     * This static method calls formatComplex() on a default instance of\n+     * Get the set of locales for which complex formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p> \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n      * ComplexFormat.\n      *\n      * @param c Complex object to format\n      * @return A formatted number in the form \"Re(c) + Im(c)i\"\n      */\n-    public static String formatComplex( Complex c ) {\n-        return getInstance().format( c );\n+    public static String formatComplex(Complex c) {\n+        return getInstance().format(c);\n     }\n     \n     /**\n             ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                 toAppendTo, pos);\n         } else { \n-            throw new IllegalArgumentException(\n-                \"Cannot format given Object as a Date\");\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Complex\");\n         }\n         \n         return ret;\n     }\n \n-    /**\n-     * Formats a double value to produce a string.  In general, the value is\n-     * formatted using the formatting rules of <code>format</code>.  There are\n-     * three exceptions to this:\n-     * <ol>\n-     * <li>NaN is formatted as '(NaN)'</li>\n-     * <li>Positive infinity is formatted as '(Infinity)'</li>\n-     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n-     * </ol>\n-     *\n-     * @param value the double to format.\n-     * @param format the format used.\n-     * @param toAppendTo where the text is to be appended\n-     * @param pos On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return the value passed in as toAppendTo.\n-     */\n-    private StringBuffer formatDouble(double value, NumberFormat format,\n-            StringBuffer toAppendTo, FieldPosition pos) {\n-        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n-            toAppendTo.append('(');\n-            toAppendTo.append(value);\n-            toAppendTo.append(')');\n-        } else {\n-            format.format(value, toAppendTo, pos);\n-        }\n-        return toAppendTo;\n-    }\n-    \n-    /**\n-     * Get the set of locales for which complex formats are available.  This\n-     * is the same set as the {@link NumberFormat} set. \n-     * @return available complex format locales.\n-     */\n-    public static Locale[] getAvailableLocales() {\n-        return NumberFormat.getAvailableLocales();\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getInstance()} with the only customizing is the\n-     * maximum number of fraction digits, which is set to 2.  \n-     * @return the default number format.\n-     */\n-    private static NumberFormat getDefaultNumberFormat() {\n-        return getDefaultNumberFormat(Locale.getDefault());\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of fraction digits, which is set to 2.  \n-     * @param locale the specific locale used by the format.\n-     * @return the default number format specific to the given locale.\n-     */\n-    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n-        NumberFormat nf = NumberFormat.getInstance(locale);\n-        nf.setMaximumFractionDigits(2);\n-        return nf;\n-    }\n-    \n     /**\n      * Access the imaginaryCharacter.\n      * @return the imaginaryCharacter.\n      * Returns the default complex format for the current locale.\n      * @return the default complex format.\n      */\n-    public static ComplexFormat getInstance() {\n+    public static CompositeFormat getInstance() {\n         return getInstance(Locale.getDefault());\n     }\n     \n         Complex result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n             throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n-                \"\\\"\", parsePosition.getErrorIndex());\n+                                     \"\\\"\", parsePosition.getErrorIndex());\n         }\n         return result;\n     }\n         if (re == null) {\n             // invalid real number\n             // set index back to initial, error index should already be set\n-            // character examined.\n             pos.setIndex(initialIndex);\n             return null;\n         }\n         if (im == null) {\n             // invalid imaginary number\n             // set index back to initial, error index should already be set\n-            // character examined.\n             pos.setIndex(initialIndex);\n             return null;\n         }\n \n         // parse imaginary character\n-        int n = getImaginaryCharacter().length();\n-        startIndex = pos.getIndex();\n-        int endIndex = startIndex + n;\n-        if ((startIndex >= source.length()) ||\n-            (endIndex > source.length()) ||\n-            source.substring(startIndex, endIndex).compareTo(\n-            getImaginaryCharacter()) != 0) {\n-            // set index back to initial, error index should be the start index\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n+        if (!parseFixedstring(source, getImaginaryCharacter(), pos)) {\n             return null;\n         }\n-        pos.setIndex(endIndex);\n \n         return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+\n     }\n      \n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     *\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n-     *        holds the index of the next non-whitespace character.\n-     */\n-    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n-        parseNextCharacter(source, pos);\n-        pos.setIndex(pos.getIndex() - 1);\n-    }\n-\n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     *\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the first non-whitespace character.\n-     */\n-    private char parseNextCharacter(String source, ParsePosition pos) {\n-         int index = pos.getIndex();\n-         int n = source.length();\n-         char ret = 0;\n-\n-         if (index < n) {\n-             char c;\n-             do {\n-                 c = source.charAt(index++);\n-             } while (Character.isWhitespace(c) && index < n);\n-             pos.setIndex(index);\n-         \n-             if (index < n) {\n-                 ret = c;\n-             }\n-         }\n-         \n-         return ret;\n-    }\n-    \n-    /**\n-     * Parses <code>source</code> for a special double values.  These values\n-     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n-     *\n-     * @param source the string to parse\n-     * @param value the special value to parse.\n-     * @param pos input/ouput parsing parameter.\n-     * @return the special number.\n-     */\n-    private Number parseNumber(String source, double value, ParsePosition pos) {\n-        Number ret = null;\n-        \n-        StringBuffer sb = new StringBuffer();\n-        sb.append('(');\n-        sb.append(value);\n-        sb.append(')');\n-        \n-        int n = sb.length();\n-        int startIndex = pos.getIndex();\n-        int endIndex = startIndex + n;\n-        if (endIndex < source.length()) {\n-            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n-                ret = Double.valueOf(value);\n-                pos.setIndex(endIndex);\n-            }\n-        }\n-        \n-        return ret;\n-    }\n-    \n-    /**\n-     * Parses <code>source</code> for a number.  This method can parse normal,\n-     * numeric values as well as special values.  These special values include\n-     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n-     *\n-     * @param source the string to parse\n-     * @param format the number format used to parse normal, numeric values.\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed number.\n-     */\n-    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n-        int startIndex = pos.getIndex();\n-        Number number = format.parse(source, pos);\n-        int endIndex = pos.getIndex();\n-        \n-        // check for error parsing number\n-        if (startIndex == endIndex) {\n-            // try parsing special numbers\n-            double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n-            for (int i = 0; i < special.length; ++i) {\n-                number = parseNumber(source, special[i], pos);\n-                if (number != null) {\n-                    break;\n-                }\n-            }\n-        }\n-        \n-        return number;\n-    }\n-\n     /**\n      * Parses a string to produce a object.\n      *\n     public Object parseObject(String source, ParsePosition pos) {\n         return parse(source, pos);\n     }\n+\n     /**\n      * Modify the imaginaryCharacter.\n      * @param imaginaryCharacter The new imaginaryCharacter value.\n         }\n         this.realFormat = realFormat;\n     }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/CompositeFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+/**\n+ * Base class for formatters of composite objects (complex numbers, vectors ...).\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class CompositeFormat extends Format {\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing is the\n+     * maximum number of fraction digits, which is set to 2.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of fraction digits, which is set to 2.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n+        final NumberFormat nf = NumberFormat.getInstance(locale);\n+        nf.setMaximumFractionDigits(2);\n+        return nf;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    protected void parseAndIgnoreWhitespace(final String source,\n+                                            final ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    protected char parseNextCharacter(final String source,\n+                                      final ParsePosition pos) {\n+         int index = pos.getIndex();\n+         final int n = source.length();\n+         char ret = 0;\n+    \n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> for a special double values.  These values\n+     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param value the special value to parse.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the special number.\n+     */\n+    private Number parseNumber(final String source, final double value,\n+                               final ParsePosition pos) {\n+        Number ret = null;\n+        \n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        sb.append(value);\n+        sb.append(')');\n+        \n+        final int n = sb.length();\n+        final int startIndex = pos.getIndex();\n+        final int endIndex = startIndex + n;\n+        if (endIndex < source.length()) {\n+            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n+                ret = Double.valueOf(value);\n+                pos.setIndex(endIndex);\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> for a number.  This method can parse normal,\n+     * numeric values as well as special values.  These special values include\n+     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param format the number format used to parse normal, numeric values.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed number.\n+     */\n+    protected Number parseNumber(final String source, final NumberFormat format,\n+                                 final ParsePosition pos) {\n+        final int startIndex = pos.getIndex();\n+        Number number = format.parse(source, pos);\n+        final int endIndex = pos.getIndex();\n+        \n+        // check for error parsing number\n+        if (startIndex == endIndex) {\n+            // try parsing special numbers\n+            final double[] special = {\n+                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n+            };\n+            for (int i = 0; i < special.length; ++i) {\n+                number = parseNumber(source, special[i], pos);\n+                if (number != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        return number;\n+    }\n+\n+    /**\n+     * Parse <code>source</code> for an expected fixed string.\n+     * @param source the string to parse\n+     * @param expected expected string\n+     * @param pos input/ouput parsing parameter.\n+     * @return true if the expected string was there\n+     */\n+    protected boolean parseFixedstring(final String source, final String expected,\n+                                       final ParsePosition pos) {\n+\n+        final int startIndex = pos.getIndex();\n+        final int endIndex = startIndex + expected.length();\n+        if ((startIndex >= source.length()) ||\n+            (endIndex > source.length()) ||\n+            (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {\n+            // set index back to start, error index should be the start index\n+            pos.setIndex(startIndex);\n+            pos.setErrorIndex(startIndex);\n+            return false;\n+        }\n+\n+        // the string was here\n+        pos.setIndex(endIndex);\n+        return true;\n+\n+    }\n+\n+    /**\n+     * Formats a double value to produce a string.  In general, the value is\n+     * formatted using the formatting rules of <code>format</code>.  There are\n+     * three exceptions to this:\n+     * <ol>\n+     * <li>NaN is formatted as '(NaN)'</li>\n+     * <li>Positive infinity is formatted as '(Infinity)'</li>\n+     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n+     * </ol>\n+     *\n+     * @param value the double to format.\n+     * @param format the format used.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    protected StringBuffer formatDouble(final double value, final NumberFormat format,\n+                                        final StringBuffer toAppendTo,\n+                                        final FieldPosition pos) {\n+        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n+            toAppendTo.append('(');\n+            toAppendTo.append(value);\n+            toAppendTo.append(')');\n+        } else {\n+            format.format(value, toAppendTo, pos);\n+        }\n+        return toAppendTo;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math.util.CompositeFormat;\n+\n import junit.framework.TestCase;\n \n public abstract class ComplexFormatAbstractTest extends TestCase {\n  \n-    ComplexFormat complexFormat = null;\n+    CompositeFormat complexFormat = null;\n     ComplexFormat complexFormatJ = null;\n \n     protected abstract Locale getLocale();\n     }\n     \n     public void testFormatNumber() {\n-        ComplexFormat cf = ComplexFormat.getInstance(getLocale());\n+        CompositeFormat cf = ComplexFormat.getInstance(getLocale());\n         Double pi = Double.valueOf(Math.PI);\n         String text = cf.format(pi);\n         assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n     \n     public void testFormatObject() {\n         try {\n-            ComplexFormat cf = new ComplexFormat();\n+            CompositeFormat cf = new ComplexFormat();\n             Object object = new Object();\n             cf.format(object);\n             fail();", "timestamp": 1217096925, "metainfo": ""}