{"sha": "d87651ffa9fd8409ab8277ed81329d24d26aa48d", "log": "Modifications to the ConjugateGradient class and unit tests   - altered the way iterations are counted: Incrementor is incremented prior to any modification to the current state, so that the solver is in a consistent state (accessible residual corresponds to the last estimate of the solution), even in case of MaxCountExceededException occuring.   - modified some tests which were not testing anything.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n+++ b/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n         manager.resetIterationCount();\n         final double r2max = delta * delta * b.dotProduct(b);\n \n+        // Initialization phase counts as one iteration.\n+        manager.incrementIterationCount();\n         // p and x are constructed as copies of x0, since presumably, the type\n         // of x is optimized for the calculation of the matrix-vector product\n         // A.x.\n         final RealVector x = x0;\n         final RealVector p = x.copy();\n         RealVector q = a.operate(p);\n-        manager.incrementIterationCount();\n+\n         final RealVector r = b.combine(1, -1, q);\n         double r2 = r.dotProduct(r);\n         RealVector z;\n         }\n         double rhoPrev = 0.;\n         while (true) {\n+            manager.incrementIterationCount();\n             manager.fireIterationStartedEvent(event);\n             if (m != null) {\n                 z = m.solve(r);\n                 context.setValue(VECTOR, r);\n                 throw e;\n             }\n-            if (manager.getIterations() == 1) {\n+            if (manager.getIterations() == 2) {\n                 p.setSubVector(0, z);\n             } else {\n                 p.combineToSelf(rhoNext / rhoPrev, 1., z);\n             }\n             q = a.operate(p);\n-            manager.incrementIterationCount();\n             final double pq = p.dotProduct(q);\n             if (check && (pq <= 0.)) {\n                 final NonPositiveDefiniteOperatorException e;\n--- a/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n      * due to the loss of orthogonality of the successive search directions.\n      * Therefore, in the present test, the number of iterations is limited.\n      */\n-    @Test(expected = MaxCountExceededException.class)\n+    @Test\n     public void testUnpreconditionedResidual() {\n         final int n = 10;\n         final int maxIterations = n;\n         final ConjugateGradient solver;\n         solver = new ConjugateGradient(maxIterations, 1E-15, true);\n         final RealVector r = new ArrayRealVector(n);\n+        final RealVector x = new ArrayRealVector(n);\n         final IterationListener listener = new IterationListener() {\n \n             public void terminationPerformed(final IterationEvent e) {\n-                r.setSubVector(0, ((ProvidesResidual) e).getResidual());\n+                // Do nothing\n             }\n \n             public void iterationStarted(final IterationEvent e) {\n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n-                // Do nothing\n+                RealVector v = ((ProvidesResidual)e).getResidual();\n+                r.setSubVector(0, v);\n+                v = ((IterativeLinearSolverEvent) e).getSolution();\n+                x.setSubVector(0, v);\n             }\n \n             public void initializationPerformed(final IterationEvent e) {\n             }\n         };\n         solver.getIterationManager().addIterationListener(listener);\n-\n-        final RealVector b = new ArrayRealVector(n);\n-        for (int j = 0; j < n; j++) {\n-            b.set(0.);\n-            b.setEntry(j, 1.);\n-\n-            final RealVector x = solver.solve(a, b);\n-            final RealVector y = a.operate(x);\n-            for (int i = 0; i < n; i++) {\n-                final double actual = b.getEntry(i) - y.getEntry(i);\n-                final double expected = r.getEntry(i);\n-                final double delta = 1E-6 * Math.abs(expected);\n-                final String msg = String\n-                    .format(\"column %d, residual %d\", i, j);\n-                Assert.assertEquals(msg, expected, actual, delta);\n-            }\n+        final RealVector b = new ArrayRealVector(n);\n+        for (int j = 0; j < n; j++) {\n+            b.set(0.);\n+            b.setEntry(j, 1.);\n+\n+            boolean caught = false;\n+            try {\n+                solver.solve(a, b);\n+            } catch (MaxCountExceededException e) {\n+                caught = true;\n+                final RealVector y = a.operate(x);\n+                for (int i = 0; i < n; i++) {\n+                    final double actual = b.getEntry(i) - y.getEntry(i);\n+                    final double expected = r.getEntry(i);\n+                    final double delta = 1E-6 * Math.abs(expected);\n+                    final String msg = String\n+                        .format(\"column %d, residual %d\", i, j);\n+                    Assert.assertEquals(msg, expected, actual, delta);\n+                }\n+            }\n+            Assert\n+                .assertTrue(\"MaxCountExceededException should have been caught\",\n+                            caught);\n         }\n     }\n \n         }\n     }\n \n-    @Test(expected = MaxCountExceededException.class)\n+    @Test\n     public void testPreconditionedResidual() {\n         final int n = 10;\n         final int maxIterations = n;\n         final ConjugateGradient solver;\n         solver = new ConjugateGradient(maxIterations, 1E-15, true);\n         final RealVector r = new ArrayRealVector(n);\n+        final RealVector x = new ArrayRealVector(n);\n         final IterationListener listener = new IterationListener() {\n \n             public void terminationPerformed(final IterationEvent e) {\n-                r.setSubVector(0, ((ProvidesResidual) e).getResidual());\n+                // Do nothing\n             }\n \n             public void iterationStarted(final IterationEvent e) {\n             }\n \n             public void iterationPerformed(final IterationEvent e) {\n-                // Do nothing\n+                RealVector v = ((ProvidesResidual)e).getResidual();\n+                r.setSubVector(0, v);\n+                v = ((IterativeLinearSolverEvent) e).getSolution();\n+                x.setSubVector(0, v);\n             }\n \n             public void initializationPerformed(final IterationEvent e) {\n         for (int j = 0; j < n; j++) {\n             b.set(0.);\n             b.setEntry(j, 1.);\n-            final RealVector x = solver.solve(a, m, b);\n-            final RealVector y = a.operate(x);\n-            double rnorm = 0.;\n-            for (int i = 0; i < n; i++) {\n-                final double actual = b.getEntry(i) - y.getEntry(i);\n-                final double expected = r.getEntry(i);\n-                final double delta = 1E-6 * Math.abs(expected);\n-                final String msg = String\n-                    .format(\"column %d, residual %d\", i, j);\n-                Assert.assertEquals(msg, expected, actual, delta);\n-            }\n-            rnorm = r.getNorm();\n-            Assert.assertEquals(\"norm of residual\", rnorm, r.getNorm(),\n-                                1E-6 * Math.abs(rnorm));\n+\n+            boolean caught = false;\n+            try {\n+                solver.solve(a, m, b);\n+            } catch (MaxCountExceededException e) {\n+                caught = true;\n+                final RealVector y = a.operate(x);\n+                for (int i = 0; i < n; i++) {\n+                    final double actual = b.getEntry(i) - y.getEntry(i);\n+                    final double expected = r.getEntry(i);\n+                    final double delta = 1E-6 * Math.abs(expected);\n+                    final String msg = String\n+                        .format(\"column %d, residual %d\", i, j);\n+                    Assert.assertEquals(msg, expected, actual, delta);\n+                }\n+            }\n+            Assert\n+                .assertTrue(\"MaxCountExceededException should have been caught\",\n+                            caught);\n         }\n     }\n ", "timestamp": 1317867260, "metainfo": ""}