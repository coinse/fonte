{"sha": "8d356234ae61038c10881249b39b173d33aa0d40", "log": "MATH-197.  added rejection method to poisson random variates to help with large lamda values.  ", "commit": "\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n import java.security.NoSuchProviderException;\n import java.util.Collection;\n \n+import org.apache.commons.math.util.MathUtils;\n+\n /**\n  * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n- * instance to generate non-secure data and a \n- * {@link java.security.SecureRandom} instance to provide data for the\n- * <code>nextSecureXxx</code> methods.  If no <code>RandomGenerator</code>\n- * is provided in the constructor, the default is to use a generator based on\n- * {@link java.util.Random}.   To plug in a different implementation, \n- * either implement <code>RandomGenerator</code> directly or extend\n- * {@link AbstractRandomGenerator}.\n+ * instance to generate non-secure data and a {@link java.security.SecureRandom}\n+ * instance to provide data for the <code>nextSecureXxx</code> methods. If no\n+ * <code>RandomGenerator</code> is provided in the constructor, the default is\n+ * to use a generator based on {@link java.util.Random}. To plug in a different\n+ * implementation, either implement <code>RandomGenerator</code> directly or\n+ * extend {@link AbstractRandomGenerator}.\n  * <p>\n- * Supports reseeding the underlying pseudo-random number generator (PRNG). \n- * The <code>SecurityProvider</code> and <code>Algorithm</code>\n- * used by the <code>SecureRandom</code> instance can also be reset.</p>\n+ * Supports reseeding the underlying pseudo-random number generator (PRNG). The\n+ * <code>SecurityProvider</code> and <code>Algorithm</code> used by the\n+ * <code>SecureRandom</code> instance can also be reset.\n+ * </p>\n  * <p>\n  * For details on the default PRNGs, see {@link java.util.Random} and\n- * {@link java.security.SecureRandom}.</p>\n+ * {@link java.security.SecureRandom}.\n+ * </p>\n  * <p>\n- * <strong>Usage Notes</strong>: <ul>\n+ * <strong>Usage Notes</strong>:\n+ * <ul>\n  * <li>\n  * Instance variables are used to maintain <code>RandomGenerator</code> and\n- * <code>SecureRandom</code> instances used in data generation. Therefore,\n- * to generate a random sequence of values or strings, you should use just\n+ * <code>SecureRandom</code> instances used in data generation. Therefore, to\n+ * generate a random sequence of values or strings, you should use just\n  * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n  * <li>\n- * The \"secure\" methods are *much* slower.  These should be used only when a\n- * cryptographically secure random sequence is required.  A secure random\n+ * The \"secure\" methods are *much* slower. These should be used only when a\n+ * cryptographically secure random sequence is required. A secure random\n  * sequence is a sequence of pseudo-random values which, in addition to being\n  * well-dispersed (so no subsequence of values is an any more likely than other\n  * subsequence of the the same length), also has the additional property that\n  * it any easier to predict subsequent values.</li>\n  * <li>\n  * When a new <code>RandomDataImpl</code> is created, the underlying random\n- * number generators are <strong>not</strong> intialized.  If you do not\n- * explicitly seed the default non-secure generator, it is seeded with the current time\n- * in milliseconds on first use.  The same holds for the secure generator.  \n- * If you provide a <code>RandomGenerator</code> to the constructor, however,\n- * this generator is not reseeded by the constructor nor is it reseeded on\n- * first use. </li>\n+ * number generators are <strong>not</strong> intialized. If you do not\n+ * explicitly seed the default non-secure generator, it is seeded with the\n+ * current time in milliseconds on first use. The same holds for the secure\n+ * generator. If you provide a <code>RandomGenerator</code> to the constructor,\n+ * however, this generator is not reseeded by the constructor nor is it reseeded\n+ * on first use.</li>\n  * <li>\n- * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate\n- * to the corresponding methods on the underlying <code>RandomGenerator</code>\n- * and<code>SecureRandom</code> instances.  Therefore, \n- * <code>reSeed(long)</code> fully resets the initial state of the non-secure\n- * random number generator (so that reseeding with a specific value always\n- * results in the same subsequent random sequence); whereas reSeedSecure(long)\n- * does <strong>not</strong> reinitialize the secure random number generator\n- * (so secure sequences started with calls to reseedSecure(long) won't be\n- * identical).</li>\n+ * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate to the\n+ * corresponding methods on the underlying <code>RandomGenerator</code> and\n+ * <code>SecureRandom</code> instances. Therefore, <code>reSeed(long)</code>\n+ * fully resets the initial state of the non-secure random number generator (so\n+ * that reseeding with a specific value always results in the same subsequent\n+ * random sequence); whereas reSeedSecure(long) does <strong>not</strong>\n+ * reinitialize the secure random number generator (so secure sequences started\n+ * with calls to reseedSecure(long) won't be identical).</li>\n  * <li>\n  * This implementation is not synchronized.\n- * </ul></p>\n- *\n- * @version $Revision$ $Date$\n+ * </ul>\n+ * </p>\n+ * \n+ * @version $Revision$ $Date: 2008-11-23 08:27:09 -0600 (Sun, 23 Nov\n+ *          2008) $\n  */\n public class RandomDataImpl implements RandomData, Serializable {\n \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -626730818244969716L;\n-\n-    /** underlying random number generator */\n-    private RandomGenerator rand = null;\n-\n-    /** underlying secure random number generator */\n-    private SecureRandom secRand = null;\n-\n-    /**\n-     * Construct a RandomDataImpl.\n-     */\n-    public RandomDataImpl() {\n-    }\n-    \n-    /**\n-     * Construct a RandomDataImpl using the supplied {@link RandomGenerator}\n-     * as the source of (non-secure) random data.\n-     * \n-     * @param rand  the source of (non-secure) random data\n-     * @since 1.1\n-     */\n-    public RandomDataImpl(RandomGenerator rand) {\n-        super();\n-        this.rand = rand;\n-    }\n-\n-    /**\n-     * {@inheritDoc}<p>\n-     * <strong>Algorithm Description:</strong> hex strings are generated\n-     * using a 2-step process. <ol>\n-     * <li>\n-     * len/2+1 binary bytes are generated using the underlying Random</li>\n-     * <li>\n-     * Each binary byte is translated into 2 hex digits</li></ol></p>\n-     * \n-     * @param len the desired string length.\n-     * @return the random string.\n-     */\n-    public String nextHexString(int len) {\n-        if (len <= 0) {\n-            throw new IllegalArgumentException(\"length must be positive\");\n-        }\n-\n-        //Get a random number generator\n-        RandomGenerator ran = getRan();\n-\n-        //Initialize output buffer\n-        StringBuffer outBuffer = new StringBuffer();\n-\n-        //Get int(len/2)+1 random bytes\n-        byte[] randomBytes = new byte[(len / 2) + 1];\n-        ran.nextBytes(randomBytes);\n-\n-        //Convert each byte to 2 hex digits\n-        for (int i = 0; i < randomBytes.length; i++) {\n-            Integer c = Integer.valueOf(randomBytes[i]);\n-\n-            /* Add 128 to byte value to make interval 0-255 before\n-             * doing hex conversion.\n-             * This guarantees <= 2 hex digits from toHexString()\n-             * toHexString would otherwise add 2^32 to negative arguments.\n-             */\n-             String hex = Integer.toHexString(c.intValue() + 128);\n-\n-             // Make sure we add 2 hex digits for each byte\n-             if (hex.length() == 1)  {\n-                 hex = \"0\" + hex;\n-             }\n-             outBuffer.append(hex);\n-        }\n-        return outBuffer.toString().substring(0, len);\n-    }\n-\n-    /**\n-     * Generate a random int value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive.\n-     * \n-     * @param lower the lower bound.\n-     * @param upper the upper bound.\n-     * @return the random integer.\n-     */\n-    public int nextInt(int lower, int upper) {\n-        if (lower >= upper) {\n-            throw new IllegalArgumentException\n-                (\"upper bound must be > lower bound\");\n-        }\n-        RandomGenerator rand = getRan();\n-        double r = rand.nextDouble();\n-        return (int)((r * upper) + ((1.0 - r) * lower) + r);\n-    }\n-\n-    /**\n-     * Generate a random long value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive.\n-     * \n-     * @param lower the lower bound.\n-     * @param upper the upper bound.\n-     * @return the random integer.\n-     */\n-    public long nextLong(long lower, long upper) {\n-        if (lower >= upper) {\n-            throw new IllegalArgumentException\n-                (\"upper bound must be > lower bound\");\n-        }\n-        RandomGenerator rand = getRan();\n-        double r = rand.nextDouble();\n-        return (long)((r * upper) + ((1.0 - r) * lower) + r);\n-    }\n-\n-     /**\n-     * {@inheritDoc}<p>\n-     * <strong>Algorithm Description:</strong> hex strings are generated in\n-     * 40-byte segments using a 3-step process. <ol>\n-     * <li>\n-     * 20 random bytes are generated using the underlying\n-     * <code>SecureRandom</code>.</li>\n-     * <li>\n-     * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n-     * <li>\n-     * Each byte of the binary digest is converted to 2 hex digits.</li></ol>\n-     * </p>\n-     *\n-     * @param len the length of the generated string\n-     * @return the random string\n-     */\n-    public String nextSecureHexString(int len) {\n-        if (len <= 0) {\n-            throw new IllegalArgumentException(\"length must be positive\");\n-        }\n-\n-       // Get SecureRandom and setup Digest provider\n-       SecureRandom secRan = getSecRan();\n-       MessageDigest alg = null;\n-       try {\n-            alg = MessageDigest.getInstance(\"SHA-1\");\n-       } catch (NoSuchAlgorithmException ex) {\n-           return null; // gulp FIXME? -- this *should* never fail.\n-       }\n-       alg.reset();\n-\n-       //Compute number of iterations required (40 bytes each)\n-       int numIter = (len / 40) + 1;\n-\n-       StringBuffer outBuffer = new StringBuffer();\n-       for (int iter = 1; iter < numIter + 1; iter++) {\n-            byte[] randomBytes = new byte[40];\n-            secRan.nextBytes(randomBytes);\n-            alg.update(randomBytes);\n-\n-            //Compute hash -- will create 20-byte binary hash\n-            byte hash[] = alg.digest();\n-\n-            //Loop over the hash, converting each byte to 2 hex digits\n-            for (int i = 0; i < hash.length; i++) {\n-                Integer c = Integer.valueOf(hash[i]);\n-\n-                /* Add 128 to byte value to make interval 0-255\n-                 * This guarantees <= 2 hex digits from toHexString()\n-                 * toHexString would otherwise add 2^32 to negative\n-                 * arguments\n-                 */\n-                String hex = Integer.toHexString(c.intValue() + 128);\n-\n-               //Keep strings uniform length -- guarantees 40 bytes\n-                if (hex.length() == 1) {\n-                    hex = \"0\" + hex;\n-                }\n-               outBuffer.append(hex);\n-            }\n-        }\n-        return outBuffer.toString().substring(0, len);\n-    }\n-\n-    /**\n-     * Generate a random int value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n-     * uses a secure random number generator.\n-     * \n-     * @param lower the lower bound.\n-     * @param upper the upper bound.\n-     * @return the random integer.\n-     */\n-    public int nextSecureInt(int lower, int upper) {\n-          if (lower >= upper) {\n-              throw new IllegalArgumentException\n-                (\"lower bound must be < upper bound\");\n-          }\n-          SecureRandom sec = getSecRan();\n-          return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n-    }\n-\n-    /**\n-     * Generate a random long value uniformly distributed between\n-     * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n-     * uses a secure random number generator.\n-     * \n-     * @param lower the lower bound.\n-     * @param upper the upper bound.\n-     * @return the random integer.\n-     */\n-    public long nextSecureLong(long lower, long upper) {\n-        if (lower >= upper) {\n-            throw new IllegalArgumentException\n-            (\"lower bound must be < upper bound\");\n-        }\n-        SecureRandom sec = getSecRan();\n-        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     * <p>\n-     * <strong>Algorithm Description</strong>:\n-     * Uses simulation of a Poisson process using Uniform deviates, as\n-     * described\n-     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\">\n-     * here.</a></p>\n-     * <p>\n-     * The Poisson process (and hence value returned) is bounded by \n-     * 1000 * mean.</p>\n-     * \n-     * @param mean mean of the Poisson distribution.\n-     * @return the random Poisson value.\n-     */\n-    public long nextPoisson(double mean) {\n-        if (mean <= 0) {\n-            throw new IllegalArgumentException(\"Poisson mean must be > 0\");\n-        }\n-        double p = Math.exp(-mean);\n-        long n = 0;\n-        double r = 1.0d;\n-        double rnd = 1.0d;\n-        RandomGenerator rand = getRan();\n-        while (n < 1000 * mean) {\n-            rnd = rand.nextDouble();\n-            r = r * rnd;\n-            if (r >= p) {\n-                n++;\n-            } else {\n-                return n;\n-            }\n-        }\n-        return n;\n-    }\n-\n-    /**\n-     * Generate a random value from a Normal (a.k.a. Gaussian) distribution\n-     * with the given mean, <code>mu</code> and the given standard deviation,\n-     * <code>sigma</code>.\n-     * \n-     * @param mu the mean of the distribution\n-     * @param sigma the standard deviation of the distribution\n-     * @return the random Normal value\n-     */\n-    public double nextGaussian(double mu, double sigma) {\n-        if (sigma <= 0) {\n-            throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n-        }\n-        RandomGenerator rand = getRan();\n-        return sigma * rand.nextGaussian() + mu;\n-    }\n-\n-    /**\n-     * Returns a random value from an Exponential distribution with the given\n-     * mean.\n-     * <p>\n-     * <strong>Algorithm Description</strong>:  Uses the\n-     * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\">\n-     * Inversion Method</a> to generate exponentially distributed random values\n-     * from uniform deviates.</p>\n-     * \n-     * @param mean the mean of the distribution\n-     * @return the random Exponential value\n-     */\n-    public double nextExponential(double mean)  {\n-        if (mean < 0.0)  {\n-            throw new IllegalArgumentException\n-                (\"Exponential mean must be >= 0\");\n-        }\n-        RandomGenerator rand = getRan();\n-        double unif = rand.nextDouble();\n-        while (unif == 0.0d) {\n-            unif = rand.nextDouble();\n-        }\n-        return -mean * Math.log(unif);\n-    }\n-\n-    /**\n-     * {@inheritDoc}<p>\n-     * <strong>Algorithm Description</strong>: scales the output of\n-     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n-     * random double if Random.nextDouble() returns 0).\n-     * This is necessary to provide a symmetric output interval\n-     * (both endpoints excluded).</p>\n-     * \n-     * @param lower the lower bound.\n-     * @param upper the upper bound.\n-     * @return a uniformly distributed random value from the interval (lower, upper)\n-     */\n-    public double nextUniform(double lower, double upper) {\n-        if (lower >= upper) {\n-            throw new IllegalArgumentException\n-            (\"lower bound must be < upper bound\");\n-        }\n-        RandomGenerator rand = getRan();\n-\n-        // ensure nextDouble() isn't 0.0\n-        double u = rand.nextDouble();\n-        while(u <= 0.0){\n-            u = rand.nextDouble();\n-        }\n-\n-        return lower + u * (upper - lower);\n-    }\n-\n-    /**\n-     * Returns the RandomGenerator used to generate non-secure\n-     * random data.\n-     * <p>\n-     * Creates and initializes a default generator if null.</p>\n-     *\n-     * @return the Random used to generate random data\n-     * @since 1.1\n-     */\n-    private RandomGenerator getRan() {\n-        if (rand == null) {\n-            rand = new JDKRandomGenerator();\n-            rand.setSeed(System.currentTimeMillis());\n-        }\n-        return rand;\n-    }\n-\n-    /**\n-     * Returns the SecureRandom used to generate secure random data.\n-     * <p>\n-     * Creates and initializes if null.</p>\n-     *\n-     * @return the SecureRandom used to generate secure random data\n-     */\n-    private SecureRandom getSecRan() {\n-        if (secRand == null) {\n-            secRand = new SecureRandom();\n-            secRand.setSeed(System.currentTimeMillis());\n-        }\n-        return secRand;\n-    }\n-\n-    /**\n-     * Reseeds the random number generator with the supplied seed.\n-     * <p>\n-     * Will create and initialize if null.</p>\n-     *\n-     * @param seed the seed value to use\n-     */\n-    public void reSeed(long seed) {\n-        if (rand == null) {\n-            rand = new JDKRandomGenerator();\n-        }\n-        rand.setSeed(seed);\n-    }\n-\n-    /**\n-     * Reseeds the secure random number generator with the current time\n-     * in milliseconds.\n-     * <p>\n-     * Will create and initialize if null.</p>\n-     */\n-    public void reSeedSecure() {\n-        if (secRand == null) {\n-            secRand = new SecureRandom();\n-        }\n-        secRand.setSeed(System.currentTimeMillis());\n-    }\n-\n-    /**\n-     * Reseeds the secure random number generator with the supplied seed.\n-     * <p>\n-     * Will create and initialize if null.</p>\n-     *\n-     * @param seed the seed value to use\n-     */\n-    public void reSeedSecure(long seed) {\n-        if (secRand == null) {\n-            secRand = new SecureRandom();\n-        }\n-        secRand.setSeed(seed);\n-    }\n-\n-    /**\n-     * Reseeds the random number generator with the current time\n-     * in milliseconds.\n-     */\n-    public void reSeed() {\n-        if (rand == null) {\n-            rand = new JDKRandomGenerator();\n-        }\n-        rand.setSeed(System.currentTimeMillis());\n-    }\n-\n-    /**\n-     * Sets the PRNG algorithm for the underlying SecureRandom instance\n-     * using the Security Provider API.  The Security Provider API is defined in\n-     * <a href=\"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">\n-     * Java Cryptography Architecture API Specification & Reference.</a>\n-     * <p>\n-     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n-     * overhead and may take several seconds to execute.\n-     * </p>\n-     *\n-     * @param algorithm the name of the PRNG algorithm\n-     * @param provider the name of the provider\n-     * @throws NoSuchAlgorithmException if the specified algorithm\n-     * is not available\n-     * @throws NoSuchProviderException if the specified provider\n-     * is not installed\n-     */\n-    public void setSecureAlgorithm(String algorithm, String provider)\n-        throws NoSuchAlgorithmException, NoSuchProviderException {\n-        secRand = SecureRandom.getInstance(algorithm, provider);\n-    }\n-\n-    /**\n-     * Generates an integer array of length <code>k</code> whose entries\n-     * are selected randomly, without repetition, from the integers\n-     * <code>0 through n-1</code> (inclusive).\n-     * <p>\n-     * Generated arrays represent permutations\n-     * of <code>n</code> taken <code>k</code> at a time.</p>\n-     * <p>\n-     * <strong>Preconditions:</strong><ul>\n-     * <li> <code>k <= n</code></li>\n-     * <li> <code>n > 0</code> </li>\n-     * </ul>\n-     * If the preconditions are not met, an IllegalArgumentException is\n-     * thrown.</p>\n-     * <p>\n-     * Uses a 2-cycle permutation shuffle. The shuffling process is described\n-     * <a href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n-     * here</a>.</p>\n-     * \n-     * @param n domain of the permutation (must be positive)\n-     * @param k size of the permutation (must satisfy 0 < k <= n).\n-     * @return the random permutation as an int array\n-     */\n-    public int[] nextPermutation(int n, int k) {\n-        if (k > n) {\n-            throw new IllegalArgumentException\n-                (\"permutation k exceeds n\");\n-        }\n-        if (k == 0) {\n-            throw new IllegalArgumentException\n-                (\"permutation k must be > 0\");\n-        }\n-\n-        int[] index = getNatural(n);\n-        shuffle(index, n - k);\n-        int[] result = new int[k];\n-        for (int i = 0; i < k; i++) {\n-            result[i] = index[n - i - 1];\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Uses a 2-cycle permutation shuffle to generate a random permutation.\n-     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n-     * shuffle to generate a random permutation of <code>c.size()</code> and\n-     * then returns the elements whose indexes correspond to the elements of\n-     * the generated permutation.\n-     * This technique is described, and proven to generate random samples,\n-     * <a href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n-     * here</a>\n-     * @param c Collection to sample from.\n-     * @param k sample size.\n-     * @return the random sample.\n-     */\n-    public Object[] nextSample(Collection<?> c, int k) {\n-        int len = c.size();\n-        if (k > len) {\n-            throw new IllegalArgumentException\n-                (\"sample size exceeds collection size\");\n-        }\n-        if (k == 0) {\n-            throw new IllegalArgumentException\n-                (\"sample size must be > 0\");\n-        }\n-\n-       Object[] objects = c.toArray();\n-       int[] index = nextPermutation(len, k);\n-       Object[] result = new Object[k];\n-       for (int i = 0; i < k; i++) {\n-           result[i] = objects[index[i]];\n-       }\n-       return result;\n-    }\n-\n-    //------------------------Private methods----------------------------------\n-\n-    /**\n-     * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n-     * of list.\n-     *\n-     * @param list list to be shuffled\n-     * @param end element past which shuffling begins\n-     */\n-    private void shuffle(int[] list, int end) {\n-        int target = 0;\n-        for (int i = list.length - 1 ; i >= end; i--) {\n-            if (i == 0) {\n-                target = 0;\n-            } else {\n-                target = nextInt(0, i);\n-            }\n-            int temp = list[target];\n-            list[target] = list[i];\n-            list[i] = temp;\n-        }\n-    }\n-\n-    /**\n-     * Returns an array representing n.\n-     *\n-     * @param n the natural number to represent\n-     * @return array with entries = elements of n\n-     */\n-    private int[] getNatural(int n) {\n-        int[] natural = new int[n];\n-        for (int i = 0; i < n; i++) {\n-            natural[i] = i;\n-        }\n-        return natural;\n-    }\n+\t/** Serializable version identifier */\n+\tprivate static final long serialVersionUID = -626730818244969716L;\n+\n+\t/** underlying random number generator */\n+\tprivate RandomGenerator rand = null;\n+\n+\t/** underlying secure random number generator */\n+\tprivate SecureRandom secRand = null;\n+\n+\t/**\n+\t * Construct a RandomDataImpl.\n+\t */\n+\tpublic RandomDataImpl() {\n+\t}\n+\n+\t/**\n+\t * Construct a RandomDataImpl using the supplied {@link RandomGenerator} as\n+\t * the source of (non-secure) random data.\n+\t * \n+\t * @param rand\n+\t *            the source of (non-secure) random data\n+\t * @since 1.1\n+\t */\n+\tpublic RandomDataImpl(RandomGenerator rand) {\n+\t\tsuper();\n+\t\tthis.rand = rand;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t * <p>\n+\t * <strong>Algorithm Description:</strong> hex strings are generated using a\n+\t * 2-step process.\n+\t * <ol>\n+\t * <li>\n+\t * len/2+1 binary bytes are generated using the underlying Random</li>\n+\t * <li>\n+\t * Each binary byte is translated into 2 hex digits</li>\n+\t * </ol>\n+\t * </p>\n+\t * \n+\t * @param len\n+\t *            the desired string length.\n+\t * @return the random string.\n+\t */\n+\tpublic String nextHexString(int len) {\n+\t\tif (len <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\"length must be positive\");\n+\t\t}\n+\n+\t\t// Get a random number generator\n+\t\tRandomGenerator ran = getRan();\n+\n+\t\t// Initialize output buffer\n+\t\tStringBuffer outBuffer = new StringBuffer();\n+\n+\t\t// Get int(len/2)+1 random bytes\n+\t\tbyte[] randomBytes = new byte[(len / 2) + 1];\n+\t\tran.nextBytes(randomBytes);\n+\n+\t\t// Convert each byte to 2 hex digits\n+\t\tfor (int i = 0; i < randomBytes.length; i++) {\n+\t\t\tInteger c = Integer.valueOf(randomBytes[i]);\n+\n+\t\t\t/*\n+\t\t\t * Add 128 to byte value to make interval 0-255 before doing hex\n+\t\t\t * conversion. This guarantees <= 2 hex digits from toHexString()\n+\t\t\t * toHexString would otherwise add 2^32 to negative arguments.\n+\t\t\t */\n+\t\t\tString hex = Integer.toHexString(c.intValue() + 128);\n+\n+\t\t\t// Make sure we add 2 hex digits for each byte\n+\t\t\tif (hex.length() == 1) {\n+\t\t\t\thex = \"0\" + hex;\n+\t\t\t}\n+\t\t\toutBuffer.append(hex);\n+\t\t}\n+\t\treturn outBuffer.toString().substring(0, len);\n+\t}\n+\n+\t/**\n+\t * Generate a random int value uniformly distributed between\n+\t * <code>lower</code> and <code>upper</code>, inclusive.\n+\t * \n+\t * @param lower\n+\t *            the lower bound.\n+\t * @param upper\n+\t *            the upper bound.\n+\t * @return the random integer.\n+\t */\n+\tpublic int nextInt(int lower, int upper) {\n+\t\tif (lower >= upper) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"upper bound must be > lower bound\");\n+\t\t}\n+\t\tRandomGenerator rand = getRan();\n+\t\tdouble r = rand.nextDouble();\n+\t\treturn (int) ((r * upper) + ((1.0 - r) * lower) + r);\n+\t}\n+\n+\t/**\n+\t * Generate a random long value uniformly distributed between\n+\t * <code>lower</code> and <code>upper</code>, inclusive.\n+\t * \n+\t * @param lower\n+\t *            the lower bound.\n+\t * @param upper\n+\t *            the upper bound.\n+\t * @return the random integer.\n+\t */\n+\tpublic long nextLong(long lower, long upper) {\n+\t\tif (lower >= upper) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"upper bound must be > lower bound\");\n+\t\t}\n+\t\tRandomGenerator rand = getRan();\n+\t\tdouble r = rand.nextDouble();\n+\t\treturn (long) ((r * upper) + ((1.0 - r) * lower) + r);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t * <p>\n+\t * <strong>Algorithm Description:</strong> hex strings are generated in\n+\t * 40-byte segments using a 3-step process.\n+\t * <ol>\n+\t * <li>\n+\t * 20 random bytes are generated using the underlying\n+\t * <code>SecureRandom</code>.</li>\n+\t * <li>\n+\t * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n+\t * <li>\n+\t * Each byte of the binary digest is converted to 2 hex digits.</li>\n+\t * </ol>\n+\t * </p>\n+\t * \n+\t * @param len\n+\t *            the length of the generated string\n+\t * @return the random string\n+\t */\n+\tpublic String nextSecureHexString(int len) {\n+\t\tif (len <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\"length must be positive\");\n+\t\t}\n+\n+\t\t// Get SecureRandom and setup Digest provider\n+\t\tSecureRandom secRan = getSecRan();\n+\t\tMessageDigest alg = null;\n+\t\ttry {\n+\t\t\talg = MessageDigest.getInstance(\"SHA-1\");\n+\t\t} catch (NoSuchAlgorithmException ex) {\n+\t\t\treturn null; // gulp FIXME? -- this *should* never fail.\n+\t\t}\n+\t\talg.reset();\n+\n+\t\t// Compute number of iterations required (40 bytes each)\n+\t\tint numIter = (len / 40) + 1;\n+\n+\t\tStringBuffer outBuffer = new StringBuffer();\n+\t\tfor (int iter = 1; iter < numIter + 1; iter++) {\n+\t\t\tbyte[] randomBytes = new byte[40];\n+\t\t\tsecRan.nextBytes(randomBytes);\n+\t\t\talg.update(randomBytes);\n+\n+\t\t\t// Compute hash -- will create 20-byte binary hash\n+\t\t\tbyte hash[] = alg.digest();\n+\n+\t\t\t// Loop over the hash, converting each byte to 2 hex digits\n+\t\t\tfor (int i = 0; i < hash.length; i++) {\n+\t\t\t\tInteger c = Integer.valueOf(hash[i]);\n+\n+\t\t\t\t/*\n+\t\t\t\t * Add 128 to byte value to make interval 0-255 This guarantees\n+\t\t\t\t * <= 2 hex digits from toHexString() toHexString would\n+\t\t\t\t * otherwise add 2^32 to negative arguments\n+\t\t\t\t */\n+\t\t\t\tString hex = Integer.toHexString(c.intValue() + 128);\n+\n+\t\t\t\t// Keep strings uniform length -- guarantees 40 bytes\n+\t\t\t\tif (hex.length() == 1) {\n+\t\t\t\t\thex = \"0\" + hex;\n+\t\t\t\t}\n+\t\t\t\toutBuffer.append(hex);\n+\t\t\t}\n+\t\t}\n+\t\treturn outBuffer.toString().substring(0, len);\n+\t}\n+\n+\t/**\n+\t * Generate a random int value uniformly distributed between\n+\t * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n+\t * a secure random number generator.\n+\t * \n+\t * @param lower\n+\t *            the lower bound.\n+\t * @param upper\n+\t *            the upper bound.\n+\t * @return the random integer.\n+\t */\n+\tpublic int nextSecureInt(int lower, int upper) {\n+\t\tif (lower >= upper) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"lower bound must be < upper bound\");\n+\t\t}\n+\t\tSecureRandom sec = getSecRan();\n+\t\treturn lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+\t}\n+\n+\t/**\n+\t * Generate a random long value uniformly distributed between\n+\t * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n+\t * a secure random number generator.\n+\t * \n+\t * @param lower\n+\t *            the lower bound.\n+\t * @param upper\n+\t *            the upper bound.\n+\t * @return the random integer.\n+\t */\n+\tpublic long nextSecureLong(long lower, long upper) {\n+\t\tif (lower >= upper) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"lower bound must be < upper bound\");\n+\t\t}\n+\t\tSecureRandom sec = getSecRan();\n+\t\treturn lower + (long) (sec.nextDouble() * (upper - lower + 1));\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t * <p>\n+\t * <strong>Algorithm Description</strong>: For small means, uses simulation\n+\t * of a Poisson process using Uniform deviates, as described <a\n+\t * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+\t * </p>\n+\t * <p>\n+\t * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n+\t * </p>\n+\t * \n+\t * <p>\n+\t * For large means, uses a reject method as described in <a\n+\t * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n+\t * Variate Generation</a>\n+\t * </p>\n+\t * \n+\t * <p>\n+\t * References:\n+\t * <ul>\n+\t * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n+\t * New York, NY. Springer-Verlag</li>\n+\t * </ul>\n+\t * </p>\n+\t * \n+\t * @param mean\n+\t *            mean of the Poisson distribution.\n+\t * @return the random Poisson value.\n+\t */\n+\tpublic long nextPoisson(double mean) {\n+\t\tif (mean <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\"Poisson mean must be > 0\");\n+\t\t}\n+\n+\t\tRandomGenerator rand = getRan();\n+\n+\t\tdouble pivot = 6.0;\n+\t\tif (mean < pivot) {\n+\t\t\tdouble p = Math.exp(-mean);\n+\t\t\tlong n = 0;\n+\t\t\tdouble r = 1.0d;\n+\t\t\tdouble rnd = 1.0d;\n+\n+\t\t\twhile (n < 1000 * mean) {\n+\t\t\t\trnd = rand.nextDouble();\n+\t\t\t\tr = r * rnd;\n+\t\t\t\tif (r >= p) {\n+\t\t\t\t\tn++;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn n;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn n;\n+\t\t} else {\n+\t\t\tdouble mu = Math.floor(mean);\n+\t\t\tdouble delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n+\t\t\t// between 6\n+\t\t\t// and mean\n+\t\t\tdouble mu2delta = 2.0 * mu + delta;\n+\t\t\tdouble muDeltaHalf = mu + delta / 2.0;\n+\t\t\tdouble logMeanMu = Math.log(mean / mu);\n+\n+\t\t\tdouble muFactorialLog = MathUtils.factorialLog((int) mu);\n+\n+\t\t\tdouble c1 = Math.sqrt(Math.PI * mu / 2.0);\n+\t\t\tdouble c2 = c1\n+\t\t\t\t\t+ Math.sqrt(Math.PI * muDeltaHalf\n+\t\t\t\t\t\t\t/ (2.0 * Math.exp(1.0 / mu2delta)));\n+\t\t\tdouble c3 = c2 + 2.0;\n+\t\t\tdouble c4 = c3 + Math.exp(1.0 / 78.0);\n+\t\t\tdouble c = c4 + 2.0 / delta * mu2delta\n+\t\t\t\t\t* Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n+\n+\t\t\tdouble y = 0.0;\n+\t\t\tdouble x = 0.0;\n+\t\t\tdouble w = Double.POSITIVE_INFINITY;\n+\n+\t\t\tboolean accept = false;\n+\t\t\twhile (!accept) {\n+\t\t\t\tdouble u = nextUniform(0.0, c);\n+\t\t\t\tdouble e = nextExponential(mean);\n+\n+\t\t\t\tif (u <= c1) {\n+\t\t\t\t\tdouble z = nextGaussian(0.0, 1.0);\n+\t\t\t\t\ty = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n+\t\t\t\t\tx = Math.floor(y);\n+\t\t\t\t\tw = -z * z / 2.0 - e - x * logMeanMu;\n+\t\t\t\t\tif (x < -mu) {\n+\t\t\t\t\t\tw = Double.POSITIVE_INFINITY;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (c1 < u && u <= c2) {\n+\t\t\t\t\tdouble z = nextGaussian(0.0, 1.0);\n+\t\t\t\t\ty = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n+\t\t\t\t\tx = Math.ceil(y);\n+\t\t\t\t\tw = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n+\t\t\t\t\tif (x > delta) {\n+\t\t\t\t\t\tw = Double.POSITIVE_INFINITY;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (c2 < u && u <= c3) {\n+\t\t\t\t\tx = 0.0;\n+\t\t\t\t\tw = -e;\n+\t\t\t\t} else if (c3 < u && u <= c4) {\n+\t\t\t\t\tx = 1.0;\n+\t\t\t\t\tw = -e - logMeanMu;\n+\t\t\t\t} else if (c4 < u) {\n+\t\t\t\t\tdouble v = nextExponential(mean);\n+\t\t\t\t\ty = delta + v * 2.0 / delta * mu2delta;\n+\t\t\t\t\tx = Math.ceil(y);\n+\t\t\t\t\tw = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n+\t\t\t\t}\n+\t\t\t\taccept = (w <= x * Math.log(mu)\n+\t\t\t\t\t\t- MathUtils.factorialLog((int) (mu + x))\n+\t\t\t\t\t\t/ muFactorialLog);\n+\t\t\t}\n+\t\t\t// cast to long is acceptable because both x and mu are whole\n+\t\t\t// numbers.\n+\t\t\treturn (long) (x + mu);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a random value from a Normal (a.k.a. Gaussian) distribution with\n+\t * the given mean, <code>mu</code> and the given standard deviation,\n+\t * <code>sigma</code>.\n+\t * \n+\t * @param mu\n+\t *            the mean of the distribution\n+\t * @param sigma\n+\t *            the standard deviation of the distribution\n+\t * @return the random Normal value\n+\t */\n+\tpublic double nextGaussian(double mu, double sigma) {\n+\t\tif (sigma <= 0) {\n+\t\t\tthrow new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n+\t\t}\n+\t\tRandomGenerator rand = getRan();\n+\t\treturn sigma * rand.nextGaussian() + mu;\n+\t}\n+\n+\t/**\n+\t * Returns a random value from an Exponential distribution with the given\n+\t * mean.\n+\t * <p>\n+\t * <strong>Algorithm Description</strong>: Uses the <a\n+\t * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n+\t * Method</a> to generate exponentially distributed random values from\n+\t * uniform deviates.\n+\t * </p>\n+\t * \n+\t * @param mean\n+\t *            the mean of the distribution\n+\t * @return the random Exponential value\n+\t */\n+\tpublic double nextExponential(double mean) {\n+\t\tif (mean < 0.0) {\n+\t\t\tthrow new IllegalArgumentException(\"Exponential mean must be >= 0\");\n+\t\t}\n+\t\tRandomGenerator rand = getRan();\n+\t\tdouble unif = rand.nextDouble();\n+\t\twhile (unif == 0.0d) {\n+\t\t\tunif = rand.nextDouble();\n+\t\t}\n+\t\treturn -mean * Math.log(unif);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t * <p>\n+\t * <strong>Algorithm Description</strong>: scales the output of\n+\t * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n+\t * random double if Random.nextDouble() returns 0). This is necessary to\n+\t * provide a symmetric output interval (both endpoints excluded).\n+\t * </p>\n+\t * \n+\t * @param lower\n+\t *            the lower bound.\n+\t * @param upper\n+\t *            the upper bound.\n+\t * @return a uniformly distributed random value from the interval (lower,\n+\t *         upper)\n+\t */\n+\tpublic double nextUniform(double lower, double upper) {\n+\t\tif (lower >= upper) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"lower bound must be < upper bound\");\n+\t\t}\n+\t\tRandomGenerator rand = getRan();\n+\n+\t\t// ensure nextDouble() isn't 0.0\n+\t\tdouble u = rand.nextDouble();\n+\t\twhile (u <= 0.0) {\n+\t\t\tu = rand.nextDouble();\n+\t\t}\n+\n+\t\treturn lower + u * (upper - lower);\n+\t}\n+\n+\t/**\n+\t * Returns the RandomGenerator used to generate non-secure random data.\n+\t * <p>\n+\t * Creates and initializes a default generator if null.\n+\t * </p>\n+\t * \n+\t * @return the Random used to generate random data\n+\t * @since 1.1\n+\t */\n+\tprivate RandomGenerator getRan() {\n+\t\tif (rand == null) {\n+\t\t\trand = new JDKRandomGenerator();\n+\t\t\trand.setSeed(System.currentTimeMillis());\n+\t\t}\n+\t\treturn rand;\n+\t}\n+\n+\t/**\n+\t * Returns the SecureRandom used to generate secure random data.\n+\t * <p>\n+\t * Creates and initializes if null.\n+\t * </p>\n+\t * \n+\t * @return the SecureRandom used to generate secure random data\n+\t */\n+\tprivate SecureRandom getSecRan() {\n+\t\tif (secRand == null) {\n+\t\t\tsecRand = new SecureRandom();\n+\t\t\tsecRand.setSeed(System.currentTimeMillis());\n+\t\t}\n+\t\treturn secRand;\n+\t}\n+\n+\t/**\n+\t * Reseeds the random number generator with the supplied seed.\n+\t * <p>\n+\t * Will create and initialize if null.\n+\t * </p>\n+\t * \n+\t * @param seed\n+\t *            the seed value to use\n+\t */\n+\tpublic void reSeed(long seed) {\n+\t\tif (rand == null) {\n+\t\t\trand = new JDKRandomGenerator();\n+\t\t}\n+\t\trand.setSeed(seed);\n+\t}\n+\n+\t/**\n+\t * Reseeds the secure random number generator with the current time in\n+\t * milliseconds.\n+\t * <p>\n+\t * Will create and initialize if null.\n+\t * </p>\n+\t */\n+\tpublic void reSeedSecure() {\n+\t\tif (secRand == null) {\n+\t\t\tsecRand = new SecureRandom();\n+\t\t}\n+\t\tsecRand.setSeed(System.currentTimeMillis());\n+\t}\n+\n+\t/**\n+\t * Reseeds the secure random number generator with the supplied seed.\n+\t * <p>\n+\t * Will create and initialize if null.\n+\t * </p>\n+\t * \n+\t * @param seed\n+\t *            the seed value to use\n+\t */\n+\tpublic void reSeedSecure(long seed) {\n+\t\tif (secRand == null) {\n+\t\t\tsecRand = new SecureRandom();\n+\t\t}\n+\t\tsecRand.setSeed(seed);\n+\t}\n+\n+\t/**\n+\t * Reseeds the random number generator with the current time in\n+\t * milliseconds.\n+\t */\n+\tpublic void reSeed() {\n+\t\tif (rand == null) {\n+\t\t\trand = new JDKRandomGenerator();\n+\t\t}\n+\t\trand.setSeed(System.currentTimeMillis());\n+\t}\n+\n+\t/**\n+\t * Sets the PRNG algorithm for the underlying SecureRandom instance using\n+\t * the Security Provider API. The Security Provider API is defined in <a\n+\t * href =\n+\t * \"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">\n+\t * Java Cryptography Architecture API Specification & Reference.</a>\n+\t * <p>\n+\t * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n+\t * overhead and may take several seconds to execute.\n+\t * </p>\n+\t * \n+\t * @param algorithm\n+\t *            the name of the PRNG algorithm\n+\t * @param provider\n+\t *            the name of the provider\n+\t * @throws NoSuchAlgorithmException\n+\t *             if the specified algorithm is not available\n+\t * @throws NoSuchProviderException\n+\t *             if the specified provider is not installed\n+\t */\n+\tpublic void setSecureAlgorithm(String algorithm, String provider)\n+\t\t\tthrows NoSuchAlgorithmException, NoSuchProviderException {\n+\t\tsecRand = SecureRandom.getInstance(algorithm, provider);\n+\t}\n+\n+\t/**\n+\t * Generates an integer array of length <code>k</code> whose entries are\n+\t * selected randomly, without repetition, from the integers\n+\t * <code>0 through n-1</code> (inclusive).\n+\t * <p>\n+\t * Generated arrays represent permutations of <code>n</code> taken\n+\t * <code>k</code> at a time.\n+\t * </p>\n+\t * <p>\n+\t * <strong>Preconditions:</strong>\n+\t * <ul>\n+\t * <li> <code>k <= n</code></li>\n+\t * <li> <code>n > 0</code></li>\n+\t * </ul>\n+\t * If the preconditions are not met, an IllegalArgumentException is thrown.\n+\t * </p>\n+\t * <p>\n+\t * Uses a 2-cycle permutation shuffle. The shuffling process is described <a\n+\t * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+\t * here</a>.\n+\t * </p>\n+\t * \n+\t * @param n\n+\t *            domain of the permutation (must be positive)\n+\t * @param k\n+\t *            size of the permutation (must satisfy 0 < k <= n).\n+\t * @return the random permutation as an int array\n+\t */\n+\tpublic int[] nextPermutation(int n, int k) {\n+\t\tif (k > n) {\n+\t\t\tthrow new IllegalArgumentException(\"permutation k exceeds n\");\n+\t\t}\n+\t\tif (k == 0) {\n+\t\t\tthrow new IllegalArgumentException(\"permutation k must be > 0\");\n+\t\t}\n+\n+\t\tint[] index = getNatural(n);\n+\t\tshuffle(index, n - k);\n+\t\tint[] result = new int[k];\n+\t\tfor (int i = 0; i < k; i++) {\n+\t\t\tresult[i] = index[n - i - 1];\n+\t\t}\n+\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Uses a 2-cycle permutation shuffle to generate a random permutation.\n+\t * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n+\t * shuffle to generate a random permutation of <code>c.size()</code> and\n+\t * then returns the elements whose indexes correspond to the elements of the\n+\t * generated permutation. This technique is described, and proven to\n+\t * generate random samples, <a\n+\t * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+\t * here</a>\n+\t * \n+\t * @param c\n+\t *            Collection to sample from.\n+\t * @param k\n+\t *            sample size.\n+\t * @return the random sample.\n+\t */\n+\tpublic Object[] nextSample(Collection<?> c, int k) {\n+\t\tint len = c.size();\n+\t\tif (k > len) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"sample size exceeds collection size\");\n+\t\t}\n+\t\tif (k == 0) {\n+\t\t\tthrow new IllegalArgumentException(\"sample size must be > 0\");\n+\t\t}\n+\n+\t\tObject[] objects = c.toArray();\n+\t\tint[] index = nextPermutation(len, k);\n+\t\tObject[] result = new Object[k];\n+\t\tfor (int i = 0; i < k; i++) {\n+\t\t\tresult[i] = objects[index[i]];\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t// ------------------------Private methods----------------------------------\n+\n+\t/**\n+\t * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n+\t * of list.\n+\t * \n+\t * @param list\n+\t *            list to be shuffled\n+\t * @param end\n+\t *            element past which shuffling begins\n+\t */\n+\tprivate void shuffle(int[] list, int end) {\n+\t\tint target = 0;\n+\t\tfor (int i = list.length - 1; i >= end; i--) {\n+\t\t\tif (i == 0) {\n+\t\t\t\ttarget = 0;\n+\t\t\t} else {\n+\t\t\t\ttarget = nextInt(0, i);\n+\t\t\t}\n+\t\t\tint temp = list[target];\n+\t\t\tlist[target] = list[i];\n+\t\t\tlist[i] = temp;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns an array representing n.\n+\t * \n+\t * @param n\n+\t *            the natural number to represent\n+\t * @return array with entries = elements of n\n+\t */\n+\tprivate int[] getNatural(int n) {\n+\t\tint[] natural = new int[n];\n+\t\tfor (int i = 0; i < n; i++) {\n+\t\t\tnatural[i] = i;\n+\t\t}\n+\t\treturn natural;\n+\t}\n }\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n import junit.framework.Test;\n import junit.framework.TestSuite;\n import java.util.HashSet;\n+import java.util.Iterator;\n \n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.stat.Frequency;\n \n /**\n  * Test cases for the RandomData class.\n- *\n- * @version $Revision$ $Date$\n+ * \n+ * @version $Revision$ $Date: 2009-04-05 11:55:59 -0500 (Sun, 05 Apr\n+ *          2009) $\n  */\n \n public class RandomDataTest extends RetryTestCase {\n \n-    public RandomDataTest(String name) {\n-        super(name);\n-        randomData = new RandomDataImpl();\n-    }\n-\n-    protected long smallSampleSize = 1000;\n-    protected double[] expected = {250,250,250,250};\n-    protected int largeSampleSize = 10000;\n-    private String[] hex = \n-        {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"}; \n-    protected RandomDataImpl randomData = null; \n-    protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n-    \n-    public static Test suite() {\n-        TestSuite suite = new TestSuite(RandomDataTest.class);\n-        suite.setName(\"RandomData Tests\");\n-        return suite;\n-    }\n-\n-    public void testNextIntExtremeValues() {\n-        int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-        int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-        assertFalse(x == y);\n-    }\n-\n-    public void testNextLongExtremeValues() {\n-        long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n-        long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n-        assertFalse(x == y);\n-    }\n-    \n-    /** test dispersion and failure modes for nextInt() */\n-    public void testNextInt() {\n-        try {\n-            randomData.nextInt(4,3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        Frequency freq = new Frequency();\n-        int value = 0;\n-        for (int i=0;i<smallSampleSize;i++) {\n-            value = randomData.nextInt(0,3);\n-            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n-            freq.addValue(value);  \n-        }\n-        long[] observed = new long[4];\n-        for (int i=0; i<4; i++) {\n-            observed[i] = freq.getCount(i);\n-        } \n-        \n-        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n-         * Change to 11.34 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 16.27);    \n-    }\n-    \n-    /** test dispersion and failure modes for nextLong() */\n-    public void testNextLong() {\n-       try {\n-            randomData.nextLong(4,3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-       Frequency freq = new Frequency();\n-       long value = 0;\n-        for (int i=0;i<smallSampleSize;i++) {\n-            value = randomData.nextLong(0,3);\n-            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n-            freq.addValue(value);  \n-        }\n-        long[] observed = new long[4];\n-        for (int i=0; i<4; i++) {\n-            observed[i] = freq.getCount(i);\n-        } \n-        \n-        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n-         * Change to 11.34 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 16.27);    \n-    }\n-    \n-    /** test dispersion and failure modes for nextSecureLong() */\n-    public void testNextSecureLong() {\n-        try {\n-            randomData.nextSecureLong(4,3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        Frequency freq = new Frequency();\n-        long value = 0;\n-        for (int i=0;i<smallSampleSize;i++) {\n-            value = randomData.nextSecureLong(0,3);\n-            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n-            freq.addValue(value);  \n-        }\n-        long[] observed = new long[4];\n-        for (int i=0; i<4; i++) {\n-            observed[i] = freq.getCount(i);\n-        } \n-        \n-        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n-         * Change to 11.34 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 16.27);    \n-    }\n-    \n-    /** test dispersion and failure modes for nextSecureInt() */\n-    public void testNextSecureInt() {\n-        try {\n-            randomData.nextSecureInt(4,3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        Frequency freq = new Frequency();\n-        int value = 0;\n-        for (int i=0;i<smallSampleSize;i++) {\n-            value = randomData.nextSecureInt(0,3);\n-            assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n-            freq.addValue(value);  \n-        }\n-        long[] observed = new long[4];\n-        for (int i=0; i<4; i++) {\n-            observed[i] = freq.getCount(i);\n-        } \n-        \n-        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n-         * Change to 11.34 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 16.27);    \n-    }\n-    \n-    /** \n-     * Make sure that empirical distribution of random Poisson(4)'s \n-     * has P(X <= 5) close to actual cumulative Poisson probablity\n-     * and that nextPoisson fails when mean is non-positive\n-     * TODO: replace with statistical test, adding test stat to TestStatistic\n-     */\n-    public void testNextPoisson() {\n-        try {\n-            randomData.nextPoisson(0);\n-            fail(\"zero mean -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        Frequency f = new Frequency();\n-        for (int i = 0; i<largeSampleSize; i++) {\n-            try {\n-                f.addValue(randomData.nextPoisson(4.0d));\n-            } catch (Exception ex) {\n-                fail(ex.getMessage());\n-            }\n-        }\n-        long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2) + \n-                        f.getCount(3) + f.getCount(4) + f.getCount(5);\n-        long sumFreq = f.getSumFreq();\n-        double cumPct = \n-            Double.valueOf(cumFreq).doubleValue()/Double.valueOf(sumFreq).doubleValue();\n-        assertEquals(\"cum Poisson(4)\",cumPct,0.7851,0.2);\n-        try {\n-            randomData.nextPoisson(-1);\n-            fail(\"negative mean supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        try {\n-            randomData.nextPoisson(0);\n-            fail(\"0 mean supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        \n-    }\n-    \n-    /** test dispersion and failute modes for nextHex() */\n-    public void testNextHex() {\n-        try {\n-            randomData.nextHexString(-1);\n-            fail(\"negative length supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        try {\n-            randomData.nextHexString(0);\n-            fail(\"zero length supplied -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        String hexString = randomData.nextHexString(3);\n-        if (hexString.length() != 3) {\n-                fail(\"incorrect length for generated string\");\n-        }\n-        hexString = randomData.nextHexString(1);\n-        if (hexString.length() != 1) {\n-                fail(\"incorrect length for generated string\");\n-        }\n-        try {\n-            hexString = randomData.nextHexString(0);\n-            fail(\"zero length requested -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        if (hexString.length() != 1) {\n-                fail(\"incorrect length for generated string\");\n-        }      \n-        Frequency f = new Frequency();\n-        for (int i = 0; i < smallSampleSize; i++) {\n-            hexString = randomData.nextHexString(100);\n-            if (hexString.length() != 100) {\n-                fail(\"incorrect length for generated string\");\n-            }\n-            for (int j = 0; j < hexString.length(); j++) {\n-                f.addValue(hexString.substring(j,j+1));\n-            }\n-        }\n-        double[] expected = new double[16];\n-        long[] observed = new long[16];\n-        for (int i = 0; i < 16; i++) {\n-            expected[i] = (double)smallSampleSize*100/16;\n-            observed[i] = f.getCount(hex[i]);\n-        }\n-        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001\n-         * Change to 30.58 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 37.70);    \n-    }\n-    \n-    /** test dispersion and failute modes for nextHex() */\n-    public void testNextSecureHex() {\n-        try {\n-            randomData.nextSecureHexString(-1);\n-            fail(\"negative length -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        try {\n-            randomData.nextSecureHexString(0);\n-            fail(\"zero length -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        String hexString = randomData.nextSecureHexString(3);\n-        if (hexString.length() != 3) {\n-                fail(\"incorrect length for generated string\");\n-        }\n-        hexString = randomData.nextSecureHexString(1);\n-        if (hexString.length() != 1) {\n-                fail(\"incorrect length for generated string\");\n-        }\n-        try {\n-            hexString = randomData.nextSecureHexString(0);\n-            fail(\"zero length requested -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        if (hexString.length() != 1) {\n-                fail(\"incorrect length for generated string\");\n-        }      \n-        Frequency f = new Frequency();\n-        for (int i = 0; i < smallSampleSize; i++) {\n-            hexString = randomData.nextSecureHexString(100);\n-            if (hexString.length() != 100) {\n-                fail(\"incorrect length for generated string\");\n-            }\n-            for (int j = 0; j < hexString.length(); j++) {\n-                f.addValue(hexString.substring(j,j+1));\n-            }\n-        }\n-        double[] expected = new double[16];\n-        long[] observed = new long[16];\n-        for (int i = 0; i < 16; i++) {\n-            expected[i] = (double)smallSampleSize*100/16;\n-            observed[i] = f.getCount(hex[i]);\n-        }\n-        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001\n-         * Change to 30.58 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 37.70);    \n-    }\n-    \n-    /** test failure modes and dispersion of nextUniform() */  \n-    public void testNextUniform() {    \n-        try {\n-            randomData.nextUniform(4,3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        try {\n-            randomData.nextUniform(3,3);\n-            fail(\"IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        double[] expected = {500,500};\n-        long[] observed = {0,0};\n-        double lower = -1d;\n-        double upper = 20d;\n-        double midpoint = (lower + upper)/2d;\n-        double result = 0;\n-        for (int i = 0; i < 1000; i++) {\n-            result = randomData.nextUniform(lower,upper);\n-            if ((result == lower) || (result == upper)) {\n-                fail(\"generated value equal to an endpoint: \" + result);\n-            } \n-            if (result < midpoint) {\n-                observed[0]++;\n-            } else {\n-                observed[1]++;\n-            }\n-        }\n-        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001\n-         * Change to 6.64 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 10.83);  \n-    }\n-    \n-    /** test exclusive endpoints of nextUniform **/\n-    public void testNextUniformExclusiveEndpoints() {\n-        for (int i = 0; i < 1000; i++) {\n-            double u = randomData.nextUniform(0.99, 1);\n-            assertTrue(u > 0.99 && u < 1);\n-        }\n-    }\n-    \n-    /** test failure modes and distribution of nextGaussian() */  \n-    public void testNextGaussian() { \n-        try {\n-            randomData.nextGaussian(0,0);\n-            fail(\"zero sigma -- IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        SummaryStatistics u = new SummaryStatistics();\n-        for (int i = 0; i<largeSampleSize; i++) {\n-            u.addValue(randomData.nextGaussian(0,1));\n-        }\n-        double xbar = u.getMean();\n-        double s = u.getStandardDeviation();\n-        double n = u.getN(); \n-        /* t-test at .001-level TODO: replace with externalized t-test, with\n-         * test statistic defined in TestStatistic\n-         */\n-        assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);\n-    }\n-    \n-    /** test failure modes and distribution of nextExponential() */  \n-    public void testNextExponential() {\n-        try {\n-            randomData.nextExponential(-1);\n-            fail(\"negative mean -- expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // ignored\n-        }\n-        assertEquals(\"0 mean\", 0,randomData.nextExponential(0),10E-8); \n-        long cumFreq = 0;\n-        double v = 0;\n-        for (int i = 0; i < largeSampleSize; i++) {\n-            v = randomData.nextExponential(1);\n-            assertTrue(\"exponential deviate postive\", v > 0);\n-            if (v < 2) cumFreq++;\n-        }\n-        /* TODO: Replace with a statistical test, with statistic added to\n-         * TestStatistic.  Check below compares observed cumulative distribution\n-         * evaluated at 2 with exponential CDF \n-         */\n-        assertEquals(\"exponential cumulative distribution\",\n-            (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);\n-    } \n-    \n-    /** test reseeding, algorithm/provider games */\n-    public void testConfig() {\n-        randomData.reSeed(1000);\n-        double v = randomData.nextUniform(0,1);\n-        randomData.reSeed();\n-        assertTrue(\"different seeds\", \n-            Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);\n-        randomData.reSeed(1000);\n-        assertEquals(\"same seeds\",v,randomData.nextUniform(0,1),10E-12);\n-        randomData.reSeedSecure(1000);\n-        String hex = randomData.nextSecureHexString(40);\n-        randomData.reSeedSecure();\n-        assertTrue(\"different seeds\",\n-            !hex.equals(randomData.nextSecureHexString(40)));\n-        randomData.reSeedSecure(1000);\n-        assertTrue(\"same seeds\",\n-            !hex.equals(randomData.nextSecureHexString(40))); \n-        \n-        /* remove this test back soon,\n-         * since it takes about 4 seconds \n-\n-        try {\n-            randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\");\n-        } catch (NoSuchProviderException ex) {\n-            ;\n-        }\n-        assertTrue(\"different seeds\",\n-            !hex.equals(randomData.nextSecureHexString(40)));\n-        try {\n-            randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n-            fail(\"expecting NoSuchAlgorithmException\");\n-        } catch (NoSuchProviderException ex) {\n-            ;\n-        } catch (NoSuchAlgorithmException ex) {\n-            ;\n-        }\n-        \n-        try {\n-            randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n-            fail(\"expecting NoSuchProviderException\");\n-        } catch (NoSuchProviderException ex) {\n-            ;\n-        } \n-        */\n-        \n-        // test reseeding without first using the generators\n-        RandomDataImpl rd = new RandomDataImpl();\n-        rd.reSeed(100);\n-        rd.nextLong(1,2);\n-        RandomDataImpl rd2 = new RandomDataImpl();\n-        rd2.reSeedSecure(2000);\n-        rd2.nextSecureLong(1,2);\n-        rd = new RandomDataImpl();\n-        rd.reSeed();\n-        rd.nextLong(1,2);\n-        rd2 = new RandomDataImpl();\n-        rd2.reSeedSecure();\n-        rd2.nextSecureLong(1,2);\n-    }\n-    \n-    /** tests for nextSample() sampling from Collection */\n-    public void testNextSample() {\n-       Object[][] c = {{\"0\",\"1\"},{\"0\",\"2\"},{\"0\",\"3\"},{\"0\",\"4\"},{\"1\",\"2\"},\n-                        {\"1\",\"3\"},{\"1\",\"4\"},{\"2\",\"3\"},{\"2\",\"4\"},{\"3\",\"4\"}};\n-       long[] observed = {0,0,0,0,0,0,0,0,0,0};\n-       double[] expected = {100,100,100,100,100,100,100,100,100,100};\n-       \n-       HashSet<Object> cPop = new HashSet<Object>();  //{0,1,2,3,4}\n-       for (int i = 0; i < 5; i++) {\n-           cPop.add(Integer.toString(i));\n-       }\n-       \n-       Object[] sets = new Object[10]; // 2-sets from 5\n-       for (int i = 0; i < 10; i ++) {\n-           HashSet<Object> hs = new HashSet<Object>();\n-           hs.add(c[i][0]);\n-           hs.add(c[i][1]);\n-           sets[i] = hs;\n-       }\n-       \n-       for (int i = 0; i < 1000; i ++) {\n-           Object[] cSamp = randomData.nextSample(cPop,2);\n-           observed[findSample(sets,cSamp)]++;\n-       }\n-       \n-        /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001\n-         * Change to 21.67 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-            testStatistic.chiSquare(expected,observed) < 27.88);  \n-       \n-       // Make sure sample of size = size of collection returns same collection\n-       HashSet<Object> hs = new HashSet<Object>();\n-       hs.add(\"one\");\n-       Object[] one = randomData.nextSample(hs,1);\n-       String oneString = (String) one[0];\n-       if ((one.length != 1) || !oneString.equals(\"one\")){\n-           fail(\"bad sample for set size = 1, sample size = 1\");\n-       }\n-       \n-       // Make sure we fail for sample size > collection size\n-       try {\n-           one = randomData.nextSample(hs,2);\n-           fail(\"sample size > set size, expecting IllegalArgumentException\");\n-       } catch (IllegalArgumentException ex) {\n-           // ignored\n-       }\n-       \n-       // Make sure we fail for empty collection\n-       try {\n-           hs = new HashSet<Object>();\n-           one = randomData.nextSample(hs,0);\n-           fail(\"n = k = 0, expecting IllegalArgumentException\");\n-       } catch (IllegalArgumentException ex) {\n-           // ignored\n-       }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private int findSample(Object[] u, Object[] samp) {\n-        for (int i = 0; i < u.length; i++) {\n-            HashSet<Object> set = (HashSet<Object>) u[i];\n-            HashSet<Object> sampSet = new HashSet<Object>();\n-            for (int j = 0; j < samp.length; j++) {\n-                sampSet.add(samp[j]);\n-            }\n-            if (set.equals(sampSet)) {                 \n-               return i;\n-           }\n-        }\n-        fail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n-        return -1;\n-    }\n-    \n-    /** tests for nextPermutation */\n-    public void testNextPermutation() {\n-        int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};\n-        long[] observed = {0,0,0,0,0,0};\n-        double[] expected = {100,100,100,100,100,100};\n-        \n-        for (int i = 0; i < 600; i++) {\n-            int[] perm = randomData.nextPermutation(3,3);\n-            observed[findPerm(p,perm)]++;\n-        }  \n-        \n-        /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001\n-         * Change to 15.09 for alpha = .01\n-         */\n-        assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected,observed) < 20.52); \n-        \n-        // Check size = 1 boundary case\n-        int[] perm = randomData.nextPermutation(1,1);\n-        if ((perm.length != 1) || (perm[0] != 0)){\n-            fail(\"bad permutation for n = 1, sample k = 1\");\n-            \n-            // Make sure we fail for k size > n \n-            try {\n-                perm = randomData.nextPermutation(2,3);\n-                fail(\"permutation k > n, expecting IllegalArgumentException\");\n-            } catch (IllegalArgumentException ex) {\n-                // ignored\n-            }\n-            \n-            // Make sure we fail for n = 0\n-            try {\n-                perm = randomData.nextPermutation(0,0);\n-                fail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n-            } catch (IllegalArgumentException ex) {\n-                // ignored\n-            }  \n-            \n-            // Make sure we fail for k < n < 0\n-            try {\n-                perm = randomData.nextPermutation(-1,-3);\n-                fail(\"permutation k < n < 0, expecting IllegalArgumentException\");\n-            } catch (IllegalArgumentException ex) {\n-                // ignored\n-            }  \n-            \n-        }       \n-    }\n-    \n-    private int findPerm(int[][] p, int[] samp) {\n-        for (int i = 0; i < p.length; i++) {\n-            boolean good = true;\n-            for (int j = 0; j < samp.length; j++) {\n-                if (samp[j] != p[i][j]) {\n-                    good = false;\n-                }\n-            }\n-            if (good)  {\n-                return i;\n-            }\n-        }        \n-        fail(\"permutation not found\");\n-        return -1;\n-    }   \n+\tpublic RandomDataTest(String name) {\n+\t\tsuper(name);\n+\t\trandomData = new RandomDataImpl();\n+\t}\n+\n+\tprotected long smallSampleSize = 1000;\n+\tprotected double[] expected = { 250, 250, 250, 250 };\n+\tprotected int largeSampleSize = 10000;\n+\tprivate String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n+\t\t\t\"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n+\tprotected RandomDataImpl randomData = null;\n+\tprotected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();\n+\n+\tpublic static Test suite() {\n+\t\tTestSuite suite = new TestSuite(RandomDataTest.class);\n+\t\tsuite.setName(\"RandomData Tests\");\n+\t\treturn suite;\n+\t}\n+\n+\tpublic void testNextIntExtremeValues() {\n+\t\tint x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+\t\tint y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+\t\tassertFalse(x == y);\n+\t}\n+\n+\tpublic void testNextLongExtremeValues() {\n+\t\tlong x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+\t\tlong y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+\t\tassertFalse(x == y);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextInt() */\n+\tpublic void testNextInt() {\n+\t\ttry {\n+\t\t\trandomData.nextInt(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tint value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextInt(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextLong() */\n+\tpublic void testNextLong() {\n+\t\ttry {\n+\t\t\trandomData.nextLong(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tlong value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextLong(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextSecureLong() */\n+\tpublic void testNextSecureLong() {\n+\t\ttry {\n+\t\t\trandomData.nextSecureLong(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tlong value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextSecureLong(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/** test dispersion and failure modes for nextSecureInt() */\n+\tpublic void testNextSecureInt() {\n+\t\ttry {\n+\t\t\trandomData.nextSecureInt(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency freq = new Frequency();\n+\t\tint value = 0;\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\tvalue = randomData.nextSecureInt(0, 3);\n+\t\t\tassertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+\t\t\tfreq.addValue(value);\n+\t\t}\n+\t\tlong[] observed = new long[4];\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tobserved[i] = freq.getCount(i);\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 16.27);\n+\t}\n+\n+\t/**\n+\t * Make sure that empirical distribution of random Poisson(4)'s has P(X <=\n+\t * 5) close to actual cumulative Poisson probablity and that nextPoisson\n+\t * fails when mean is non-positive TODO: replace with statistical test,\n+\t * adding test stat to TestStatistic\n+\t */\n+\tpublic void testNextPoisson() {\n+\t\ttry {\n+\t\t\trandomData.nextPoisson(0);\n+\t\t\tfail(\"zero mean -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tFrequency f = new Frequency();\n+\t\tfor (int i = 0; i < largeSampleSize; i++) {\n+\t\t\ttry {\n+\t\t\t\tf.addValue(randomData.nextPoisson(4.0d));\n+\t\t\t} catch (Exception ex) {\n+\t\t\t\tfail(ex.getMessage());\n+\t\t\t}\n+\t\t}\n+\t\tlong cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)\n+\t\t\t\t+ f.getCount(3) + f.getCount(4) + f.getCount(5);\n+\t\tlong sumFreq = f.getSumFreq();\n+\t\tdouble cumPct = Double.valueOf(cumFreq).doubleValue()\n+\t\t\t\t/ Double.valueOf(sumFreq).doubleValue();\n+\t\tassertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n+\t\ttry {\n+\t\t\trandomData.nextPoisson(-1);\n+\t\t\tfail(\"negative mean supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextPoisson(0);\n+\t\t\tfail(\"0 mean supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\n+\t}\n+\n+\tpublic void testNextPoissonLargeMean() {\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tlong n = randomData.nextPoisson(1500.0);\n+\t\t\tassertTrue(0 <= n);\n+\t\t}\n+\t}\n+\n+\t/** test dispersion and failute modes for nextHex() */\n+\tpublic void testNextHex() {\n+\t\ttry {\n+\t\t\trandomData.nextHexString(-1);\n+\t\t\tfail(\"negative length supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextHexString(0);\n+\t\t\tfail(\"zero length supplied -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tString hexString = randomData.nextHexString(3);\n+\t\tif (hexString.length() != 3) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\thexString = randomData.nextHexString(1);\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\ttry {\n+\t\t\thexString = randomData.nextHexString(0);\n+\t\t\tfail(\"zero length requested -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\tFrequency f = new Frequency();\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\thexString = randomData.nextHexString(100);\n+\t\t\tif (hexString.length() != 100) {\n+\t\t\t\tfail(\"incorrect length for generated string\");\n+\t\t\t}\n+\t\t\tfor (int j = 0; j < hexString.length(); j++) {\n+\t\t\t\tf.addValue(hexString.substring(j, j + 1));\n+\t\t\t}\n+\t\t}\n+\t\tdouble[] expected = new double[16];\n+\t\tlong[] observed = new long[16];\n+\t\tfor (int i = 0; i < 16; i++) {\n+\t\t\texpected[i] = (double) smallSampleSize * 100 / 16;\n+\t\t\tobserved[i] = f.getCount(hex[i]);\n+\t\t}\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 37.70);\n+\t}\n+\n+\t/** test dispersion and failute modes for nextHex() */\n+\tpublic void testNextSecureHex() {\n+\t\ttry {\n+\t\t\trandomData.nextSecureHexString(-1);\n+\t\t\tfail(\"negative length -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextSecureHexString(0);\n+\t\t\tfail(\"zero length -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tString hexString = randomData.nextSecureHexString(3);\n+\t\tif (hexString.length() != 3) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\thexString = randomData.nextSecureHexString(1);\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\ttry {\n+\t\t\thexString = randomData.nextSecureHexString(0);\n+\t\t\tfail(\"zero length requested -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tif (hexString.length() != 1) {\n+\t\t\tfail(\"incorrect length for generated string\");\n+\t\t}\n+\t\tFrequency f = new Frequency();\n+\t\tfor (int i = 0; i < smallSampleSize; i++) {\n+\t\t\thexString = randomData.nextSecureHexString(100);\n+\t\t\tif (hexString.length() != 100) {\n+\t\t\t\tfail(\"incorrect length for generated string\");\n+\t\t\t}\n+\t\t\tfor (int j = 0; j < hexString.length(); j++) {\n+\t\t\t\tf.addValue(hexString.substring(j, j + 1));\n+\t\t\t}\n+\t\t}\n+\t\tdouble[] expected = new double[16];\n+\t\tlong[] observed = new long[16];\n+\t\tfor (int i = 0; i < 16; i++) {\n+\t\t\texpected[i] = (double) smallSampleSize * 100 / 16;\n+\t\t\tobserved[i] = f.getCount(hex[i]);\n+\t\t}\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 16-1 = 15, alpha = .001 Change to 30.58\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 37.70);\n+\t}\n+\n+\t/** test failure modes and dispersion of nextUniform() */\n+\tpublic void testNextUniform() {\n+\t\ttry {\n+\t\t\trandomData.nextUniform(4, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\ttry {\n+\t\t\trandomData.nextUniform(3, 3);\n+\t\t\tfail(\"IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tdouble[] expected = { 500, 500 };\n+\t\tlong[] observed = { 0, 0 };\n+\t\tdouble lower = -1d;\n+\t\tdouble upper = 20d;\n+\t\tdouble midpoint = (lower + upper) / 2d;\n+\t\tdouble result = 0;\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tresult = randomData.nextUniform(lower, upper);\n+\t\t\tif ((result == lower) || (result == upper)) {\n+\t\t\t\tfail(\"generated value equal to an endpoint: \" + result);\n+\t\t\t}\n+\t\t\tif (result < midpoint) {\n+\t\t\t\tobserved[0]++;\n+\t\t\t} else {\n+\t\t\t\tobserved[1]++;\n+\t\t\t}\n+\t\t}\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for\n+\t\t * alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 10.83);\n+\t}\n+\n+\t/** test exclusive endpoints of nextUniform **/\n+\tpublic void testNextUniformExclusiveEndpoints() {\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tdouble u = randomData.nextUniform(0.99, 1);\n+\t\t\tassertTrue(u > 0.99 && u < 1);\n+\t\t}\n+\t}\n+\n+\t/** test failure modes and distribution of nextGaussian() */\n+\tpublic void testNextGaussian() {\n+\t\ttry {\n+\t\t\trandomData.nextGaussian(0, 0);\n+\t\t\tfail(\"zero sigma -- IllegalArgumentException expected\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tSummaryStatistics u = new SummaryStatistics();\n+\t\tfor (int i = 0; i < largeSampleSize; i++) {\n+\t\t\tu.addValue(randomData.nextGaussian(0, 1));\n+\t\t}\n+\t\tdouble xbar = u.getMean();\n+\t\tdouble s = u.getStandardDeviation();\n+\t\tdouble n = u.getN();\n+\t\t/*\n+\t\t * t-test at .001-level TODO: replace with externalized t-test, with\n+\t\t * test statistic defined in TestStatistic\n+\t\t */\n+\t\tassertTrue(Math.abs(xbar) / (s / Math.sqrt(n)) < 3.29);\n+\t}\n+\n+\t/** test failure modes and distribution of nextExponential() */\n+\tpublic void testNextExponential() {\n+\t\ttry {\n+\t\t\trandomData.nextExponential(-1);\n+\t\t\tfail(\"negative mean -- expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t\tassertEquals(\"0 mean\", 0, randomData.nextExponential(0), 10E-8);\n+\t\tlong cumFreq = 0;\n+\t\tdouble v = 0;\n+\t\tfor (int i = 0; i < largeSampleSize; i++) {\n+\t\t\tv = randomData.nextExponential(1);\n+\t\t\tassertTrue(\"exponential deviate postive\", v > 0);\n+\t\t\tif (v < 2)\n+\t\t\t\tcumFreq++;\n+\t\t}\n+\t\t/*\n+\t\t * TODO: Replace with a statistical test, with statistic added to\n+\t\t * TestStatistic. Check below compares observed cumulative distribution\n+\t\t * evaluated at 2 with exponential CDF\n+\t\t */\n+\t\tassertEquals(\"exponential cumulative distribution\", (double) cumFreq\n+\t\t\t\t/ (double) largeSampleSize, 0.8646647167633873, .2);\n+\t}\n+\n+\t/** test reseeding, algorithm/provider games */\n+\tpublic void testConfig() {\n+\t\trandomData.reSeed(1000);\n+\t\tdouble v = randomData.nextUniform(0, 1);\n+\t\trandomData.reSeed();\n+\t\tassertTrue(\"different seeds\", Math\n+\t\t\t\t.abs(v - randomData.nextUniform(0, 1)) > 10E-12);\n+\t\trandomData.reSeed(1000);\n+\t\tassertEquals(\"same seeds\", v, randomData.nextUniform(0, 1), 10E-12);\n+\t\trandomData.reSeedSecure(1000);\n+\t\tString hex = randomData.nextSecureHexString(40);\n+\t\trandomData.reSeedSecure();\n+\t\tassertTrue(\"different seeds\", !hex.equals(randomData\n+\t\t\t\t.nextSecureHexString(40)));\n+\t\trandomData.reSeedSecure(1000);\n+\t\tassertTrue(\"same seeds\", !hex\n+\t\t\t\t.equals(randomData.nextSecureHexString(40)));\n+\n+\t\t/*\n+\t\t * remove this test back soon, since it takes about 4 seconds\n+\t\t * \n+\t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\"); } catch\n+\t\t * (NoSuchProviderException ex) { ; } assertTrue(\"different seeds\",\n+\t\t * !hex.equals(randomData.nextSecureHexString(40))); try {\n+\t\t * randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n+\t\t * fail(\"expecting NoSuchAlgorithmException\"); } catch\n+\t\t * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException\n+\t\t * ex) { ; }\n+\t\t * \n+\t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n+\t\t * fail(\"expecting NoSuchProviderException\"); } catch\n+\t\t * (NoSuchProviderException ex) { ; }\n+\t\t */\n+\n+\t\t// test reseeding without first using the generators\n+\t\tRandomDataImpl rd = new RandomDataImpl();\n+\t\trd.reSeed(100);\n+\t\trd.nextLong(1, 2);\n+\t\tRandomDataImpl rd2 = new RandomDataImpl();\n+\t\trd2.reSeedSecure(2000);\n+\t\trd2.nextSecureLong(1, 2);\n+\t\trd = new RandomDataImpl();\n+\t\trd.reSeed();\n+\t\trd.nextLong(1, 2);\n+\t\trd2 = new RandomDataImpl();\n+\t\trd2.reSeedSecure();\n+\t\trd2.nextSecureLong(1, 2);\n+\t}\n+\n+\t/** tests for nextSample() sampling from Collection */\n+\tpublic void testNextSample() {\n+\t\tObject[][] c = { { \"0\", \"1\" }, { \"0\", \"2\" }, { \"0\", \"3\" },\n+\t\t\t\t{ \"0\", \"4\" }, { \"1\", \"2\" }, { \"1\", \"3\" }, { \"1\", \"4\" },\n+\t\t\t\t{ \"2\", \"3\" }, { \"2\", \"4\" }, { \"3\", \"4\" } };\n+\t\tlong[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+\t\tdouble[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+\t\tHashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}\n+\t\tfor (int i = 0; i < 5; i++) {\n+\t\t\tcPop.add(Integer.toString(i));\n+\t\t}\n+\n+\t\tObject[] sets = new Object[10]; // 2-sets from 5\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\tHashSet<Object> hs = new HashSet<Object>();\n+\t\t\ths.add(c[i][0]);\n+\t\t\ths.add(c[i][1]);\n+\t\t\tsets[i] = hs;\n+\t\t}\n+\n+\t\tfor (int i = 0; i < 1000; i++) {\n+\t\t\tObject[] cSamp = randomData.nextSample(cPop, 2);\n+\t\t\tobserved[findSample(sets, cSamp)]++;\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 27.88);\n+\n+\t\t// Make sure sample of size = size of collection returns same collection\n+\t\tHashSet<Object> hs = new HashSet<Object>();\n+\t\ths.add(\"one\");\n+\t\tObject[] one = randomData.nextSample(hs, 1);\n+\t\tString oneString = (String) one[0];\n+\t\tif ((one.length != 1) || !oneString.equals(\"one\")) {\n+\t\t\tfail(\"bad sample for set size = 1, sample size = 1\");\n+\t\t}\n+\n+\t\t// Make sure we fail for sample size > collection size\n+\t\ttry {\n+\t\t\tone = randomData.nextSample(hs, 2);\n+\t\t\tfail(\"sample size > set size, expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\n+\t\t// Make sure we fail for empty collection\n+\t\ttry {\n+\t\t\ths = new HashSet<Object>();\n+\t\t\tone = randomData.nextSample(hs, 0);\n+\t\t\tfail(\"n = k = 0, expecting IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// ignored\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate int findSample(Object[] u, Object[] samp) {\n+\t\tfor (int i = 0; i < u.length; i++) {\n+\t\t\tHashSet<Object> set = (HashSet<Object>) u[i];\n+\t\t\tHashSet<Object> sampSet = new HashSet<Object>();\n+\t\t\tfor (int j = 0; j < samp.length; j++) {\n+\t\t\t\tsampSet.add(samp[j]);\n+\t\t\t}\n+\t\t\tif (set.equals(sampSet)) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}\n+\t\tfail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n+\t\treturn -1;\n+\t}\n+\n+\t/** tests for nextPermutation */\n+\tpublic void testNextPermutation() {\n+\t\tint[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },\n+\t\t\t\t{ 2, 0, 1 }, { 2, 1, 0 } };\n+\t\tlong[] observed = { 0, 0, 0, 0, 0, 0 };\n+\t\tdouble[] expected = { 100, 100, 100, 100, 100, 100 };\n+\n+\t\tfor (int i = 0; i < 600; i++) {\n+\t\t\tint[] perm = randomData.nextPermutation(3, 3);\n+\t\t\tobserved[findPerm(p, perm)]++;\n+\t\t}\n+\n+\t\t/*\n+\t\t * Use ChiSquare dist with df = 6-1 = 5, alpha = .001 Change to 15.09\n+\t\t * for alpha = .01\n+\t\t */\n+\t\tassertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+\t\t\t\ttestStatistic.chiSquare(expected, observed) < 20.52);\n+\n+\t\t// Check size = 1 boundary case\n+\t\tint[] perm = randomData.nextPermutation(1, 1);\n+\t\tif ((perm.length != 1) || (perm[0] != 0)) {\n+\t\t\tfail(\"bad permutation for n = 1, sample k = 1\");\n+\n+\t\t\t// Make sure we fail for k size > n\n+\t\t\ttry {\n+\t\t\t\tperm = randomData.nextPermutation(2, 3);\n+\t\t\t\tfail(\"permutation k > n, expecting IllegalArgumentException\");\n+\t\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t\t// ignored\n+\t\t\t}\n+\n+\t\t\t// Make sure we fail for n = 0\n+\t\t\ttry {\n+\t\t\t\tperm = randomData.nextPermutation(0, 0);\n+\t\t\t\tfail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n+\t\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t\t// ignored\n+\t\t\t}\n+\n+\t\t\t// Make sure we fail for k < n < 0\n+\t\t\ttry {\n+\t\t\t\tperm = randomData.nextPermutation(-1, -3);\n+\t\t\t\tfail(\"permutation k < n < 0, expecting IllegalArgumentException\");\n+\t\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t\t// ignored\n+\t\t\t}\n+\n+\t\t}\n+\t}\n+\n+\tprivate int findPerm(int[][] p, int[] samp) {\n+\t\tfor (int i = 0; i < p.length; i++) {\n+\t\t\tboolean good = true;\n+\t\t\tfor (int j = 0; j < samp.length; j++) {\n+\t\t\t\tif (samp[j] != p[i][j]) {\n+\t\t\t\t\tgood = false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (good) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}\n+\t\tfail(\"permutation not found\");\n+\t\treturn -1;\n+\t}\n }\n-", "timestamp": 1238981134, "metainfo": ""}