{"sha": "dc5fdf712a7d0f04d44f97db379827a4f1fe043d", "log": "MATH-476 FastMath code contains 'magic' numbers Extracted 2^52 value as a constant  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n      */\n     private static final double HEX_40000000 = 1073741824.0;\n \n+    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n+    private static final double TWO_POWER_52 = 4503599627370496.0;\n+\n     // Initialize tables\n     static {\n         int i;\n         // y is the most significant 10 bits of the mantissa\n         //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n         //double epsilon = (x - y) / y;\n-        double epsilon = (double)(bits & 0x3ffffffffffL) / (4503599627370496.0 + (bits & 0x000ffc0000000000L));\n+        double epsilon = (double)(bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n \n         double lnza = 0.0;\n         double lnzb = 0.0;\n \n             /* Need a more accurate epsilon, so adjust the division. */\n             double numer = (double)(bits & 0x3ffffffffffL);\n-            double denom = 4503599627370496.0 + (bits & 0x000ffc0000000000L);\n+            double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n             aa = numer - xa*denom - xb * denom;\n             xb += aa / denom;\n \n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {\n+            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                 return pow(-x, y);\n             }\n \n         }\n \n         /* Convert to double */\n-        double tmpA = (prod2A >>> 12) / 4503599627370496.0;  // High order 52 bits\n-        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / 4503599627370496.0 / 4503599627370496.0; // Low bits\n+        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n+        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n \n         double sumA = tmpA + tmpB;\n         double sumB = -(sumA - tmpA - tmpB);\n             return x;\n         }\n \n-        if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {\n+        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n             return x;\n         }\n ", "timestamp": 1295584495, "metainfo": ""}