{"sha": "eba263ad6d8e0a87985f85920eb82e139844bad8", "log": "added missing @since tags JIRA: MATH-532  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal or both are NaN.\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(float x, float y) {\n         return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, 1);\n      * @param y second value\n      * @param eps the amount of absolute error to allow.\n      * @return {@code true} if the values are equal or within range of each other.\n+     * @since 2.2\n      */\n     public static boolean equals(float x, float y, float eps) {\n         return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n      * @param eps the amount of absolute error to allow.\n      * @return {@code true} if the values are equal or within range of each other,\n      * or both are NaN.\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(float x, float y, float eps) {\n         return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n      * values between {@code x} and {@code y}.\n      * @return {@code true} if there are fewer than {@code maxUlps} floating\n      * point values between {@code x} and {@code y}.\n+     * @since 2.2\n      */\n     public static boolean equals(float x, float y, int maxUlps) {\n         // Check that \"maxUlps\" is non-negative and small enough so that\n      * values between {@code x} and {@code y}.\n      * @return {@code true} if both arguments are NaN or if there are less than\n      * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n         return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, maxUlps);\n      * @param y second array\n      * @return true if the values are both null or have same dimension and\n      * equal elements\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(float[] x, float[] y) {\n         if ((x == null) || (y == null)) {\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal or both are NaN.\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(double x, double y) {\n         return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n      * @param eps the amount of absolute error to allow.\n      * @return {@code true} if the values are equal or within range of each other,\n      * or both are NaN.\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(double x, double y, double eps) {\n         return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n      * values between {@code x} and {@code y}.\n      * @return {@code true} if both arguments are NaN or if there are less than\n      * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n         return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);\n      * @param y Second array.\n      * @return {@code true} if the values are both {@code null} or have same\n      * dimension and equal elements.\n+     * @since 2.2\n      */\n     public static boolean equalsIncludingNaN(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n      * @param dir Ordering direction.\n      * @param strict Whether the order should be strict.\n      * @throws NonMonotonousSequenceException if the array is not sorted.\n+     * @since 2.2\n      */\n     public static void checkOrder(double[] val, OrderDirection dir,\n                                   boolean strict) {\n      *\n      * @param val Values.\n      * @throws NonMonotonousSequenceException if the array is not sorted.\n+     * @since 2.2\n      */\n     public static void checkOrder(double[] val) {\n         checkOrder(val, OrderDirection.INCREASING, true);\n      *\n      * @param v vector of doubles\n      * @return the 2-norm of the vector\n+     * @since 2.2\n      */\n     public static double safeNorm(double[] v) {\n         double rdwarf = 3.834e-20;", "timestamp": 1298404178, "metainfo": ""}