{"sha": "95d84005fdd65f9fb67e000aa3ed3f83b511d25b", "log": "Javadoc formatting and minor edits.  ", "commit": "\n--- a/src/java/org/apache/commons/math/estimation/EstimatedParameter.java\n+++ b/src/java/org/apache/commons/math/estimation/EstimatedParameter.java\n \n import java.io.Serializable;\n \n-/** This class represent the estimated parameters of an estimation problem.\n-\n+/** This class represents the estimated parameters of an estimation problem.\n+ *\n  * <p>The parameters of an estimation problem have a name, a value and\n  * a bound flag. The value of bound parameters is considered trusted\n  * and the solvers should not adjust them. On the other hand, the\n  * solvers should adjust the value of unbounds parameters until they\n  * satisfy convergence criterions specific to each solver.</p>\n-\n+ *\n  * @version $Id: EstimatedParameter.java 1705 2006-09-17 19:57:39Z luc $\n-\n+ *\n  */\n \n public class EstimatedParameter\n--- a/src/java/org/apache/commons/math/estimation/EstimationException.java\n+++ b/src/java/org/apache/commons/math/estimation/EstimationException.java\n \n import org.apache.commons.math.MathException;\n \n-/** This class represents exceptions thrown by the estimation solvers.\n-\n+/** \n+ * This class represents exceptions thrown by the estimation solvers.\n+ *\n  * @version $Id: EstimationException.java 1705 2006-09-17 19:57:39Z luc $\n-\n+ *\n  */\n \n public class EstimationException\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -7414806622114810487L;\n \n-    /** Simple constructor.\n+    /** \n+     * Simple constructor.\n      * Build an exception by translating and formating a message\n      * @param specifier format specifier (to be translated)\n      * @param parts to insert in the format (no translation)\n         super(specifier, parts);\n     }\n \n-    /** Simple constructor.\n+    /** \n+     * Simple constructor.\n      * Build an exception from a cause\n      * @param cause cause of this exception\n      */\n--- a/src/java/org/apache/commons/math/estimation/EstimationProblem.java\n+++ b/src/java/org/apache/commons/math/estimation/EstimationProblem.java\n \n package org.apache.commons.math.estimation;\n \n-/** This interface represents an estimation problem.\n-\n+/** \n+ * This interface represents an estimation problem.\n+ *\n  * <p>This interface should be implemented by all real estimation\n  * problems before they can be handled by the estimators through the\n  * {@link Estimator#estimate Estimator.estimate} method.</p>\n-\n+ *\n  * <p>An estimation problem, as seen by a solver is a set of\n  * parameters and a set of measurements. The parameters are adjusted\n  * during the estimation through the {@link #getUnboundParameters\n  * the parameters are adjusted. The purpose of the solver is to reduce\n  * the residual between these values, it can retrieve the measurements\n  * through the {@link #getMeasurements getMeasurements} method.</p>\n-\n+ *\n  * @see Estimator\n  * @see WeightedMeasurement\n-\n+ *\n  * @version $Id: EstimationProblem.java 1705 2006-09-17 19:57:39Z luc $\n-\n+ *\n  */\n \n public interface EstimationProblem {\n-  /** Get the measurements of an estimation problem.\n+  /** \n+   * Get the measurements of an estimation problem.\n    * @return measurements\n    */\n   public WeightedMeasurement[] getMeasurements();\n \n-  /** Get the unbound parameters of the problem.\n+  /** \n+   * Get the unbound parameters of the problem.\n    * @return unbound parameters\n    */\n   public EstimatedParameter[] getUnboundParameters();\n \n-  /** Get all the parameters of the problem.\n+  /** \n+   * Get all the parameters of the problem.\n    * @return parameters\n    */\n   public EstimatedParameter[] getAllParameters();\n--- a/src/java/org/apache/commons/math/estimation/Estimator.java\n+++ b/src/java/org/apache/commons/math/estimation/Estimator.java\n \n package org.apache.commons.math.estimation;\n \n-/** This interface represents solvers for estimation problems.\n-\n+/**\n+ * This interface represents solvers for estimation problems.\n+ *\n  * <p>The classes which are devoted to solve estimation problems\n  * should implement this interface. The problems which can be handled\n  * should implement the {@link EstimationProblem} interface which\n  * gather all the information needed by the solver.</p>\n-\n+ *\n  * <p>The interface is composed only of the {@link #estimate estimate}\n  * method.</p>\n-\n+ *\n  * @see EstimationProblem\n-\n+ *\n  * @version $Id: Estimator.java 1705 2006-09-17 19:57:39Z luc $\n-\n+ *\n  */\n \n public interface Estimator {\n \n-  /** Solve an estimation problem.\n-\n+  /** \n+   * Solve an estimation problem.\n+   *\n    * <p>The method should set the parameters of the problem to several\n    * trial values until it reaches convergence. If this method returns\n    * normally (i.e. without throwing an exception), then the best\n    * estimate of the parameters can be retrieved from the problem\n    * itself, through the {@link EstimationProblem#getAllParameters\n    * EstimationProblem.getAllParameters} method.</p>\n-\n+   *\n    * @param problem estimation problem to solve\n    * @exception EstimationException if the problem cannot be solved\n-\n+   *\n    */\n   public void estimate(EstimationProblem problem)\n     throws EstimationException;\n \n-  /** Get the Root Mean Square value.\n+  /** \n+   * Get the Root Mean Square value.\n    * Get the Root Mean Square value, i.e. the root of the arithmetic\n    * mean of the square of all weighted residuals. This is related to the\n    * criterion that is minimized by the estimator as follows: if\n-   * <em>c</em> if the criterion, and <em>n</em> is the number of\n-   * measurements, the the RMS is <em>sqrt (c/n)</em>.\n+   * <em>c</em> is the criterion, and <em>n</em> is the number of\n+   * measurements, then the RMS is <em>sqrt (c/n)</em>.\n+   * \n    * @param problem estimation problem\n    * @return RMS value\n    */\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n \n-/** This class implements a solver for estimation problems.\n-\n+/** \n+ * This class implements a solver for estimation problems.\n+ *\n  * <p>This class solves estimation problems using a weighted least\n  * squares criterion on the measurement residuals. It uses a\n  * Gauss-Newton algorithm.</p>\n-\n+ *\n  * @version $Id: GaussNewtonEstimator.java 1705 2006-09-17 19:57:39Z luc $\n-\n+ *\n  */\n \n public class GaussNewtonEstimator\n   implements Estimator, Serializable {\n \n-  /** Simple constructor.\n-\n-   * <p>This constructor build an estimator and store its convergence\n+  /** \n+   * Simple constructor.\n+   *\n+   * <p>This constructor builds an estimator and stores its convergence\n    * characteristics.</p>\n-\n+   *\n    * <p>An estimator is considered to have converged whenever either\n    * the criterion goes below a physical threshold under which\n    * improvements are considered useless or when the algorithm is\n    * unable to improve it (even if it is still high). The first\n    * condition that is met stops the iterations.</p>\n-\n+   *\n    * <p>The fact an estimator has converged does not mean that the\n    * model accurately fits the measurements. It only means no better\n    * solution can be found, it does not mean this one is good. Such an\n    * analysis is left to the caller.</p>\n-\n+   *\n    * <p>If neither conditions are fulfilled before a given number of\n    * iterations, the algorithm is considered to have failed and an\n    * {@link EstimationException} is thrown.</p>\n-\n+   *\n    * @param maxIterations maximum number of iterations allowed\n    * @param convergence criterion threshold below which we do not need\n    * to improve the criterion anymore\n     this.convergence          = convergence;\n   }\n \n-  /** Solve an estimation problem using a least squares criterion.\n-\n+  /** \n+   * Solve an estimation problem using a least squares criterion.\n+   *\n    * <p>This method set the unbound parameters of the given problem\n    * starting from their current values through several iterations. At\n    * each step, the unbound parameters are changed in order to\n    * minimize a weighted least square criterion based on the\n    * measurements of the problem.</p>\n-\n+   *\n    * <p>The iterations are stopped either when the criterion goes\n    * below a physical threshold under which improvement are considered\n    * useless or when the algorithm is unable to improve it (even if it\n    * iterations. If the convergence it nos reached before the maximum\n    * number of iterations, an {@link EstimationException} is\n    * thrown.</p>\n-\n+   *\n    * @param problem estimation problem to solve\n    * @exception EstimationException if the problem cannot be solved\n-\n+   *\n    * @see EstimationProblem\n-\n+   *\n    */\n   public void estimate(EstimationProblem problem)\n     throws EstimationException {\n \n   }\n \n-  /** Estimate the solution of a linear least square problem.\n-\n+  /** \n+   * Estimate the solution of a linear least square problem.\n+   *\n    * <p>The Gauss-Newton algorithm is iterative. Each iteration\n-   * consist in solving a linearized least square problem. Several\n+   * consists in solving a linearized least square problem. Several\n    * iterations are needed for general problems since the\n    * linearization is only an approximation of the problem\n    * behaviour. However, for linear problems one iteration is enough\n    * to get the solution. This method is provided in the public\n    * interface in order to handle more efficiently these linear\n    * problems.</p>\n-\n+   *\n    * @param problem estimation problem to solve\n    * @exception EstimationException if the problem cannot be solved\n-\n+   *\n    */\n   public void linearEstimate(EstimationProblem problem)\n     throws EstimationException {\n \n   }\n \n-  /** Get the Root Mean Square value.\n+  /** \n+   * Get the Root Mean Square value.\n    * Get the Root Mean Square value, i.e. the root of the arithmetic\n    * mean of the square of all weighted residuals. This is related to the\n    * criterion that is minimized by the estimator as follows: if\n--- a/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-/** This class solves a least squares problem.\n-\n+/** \n+ * This class solves a least squares problem.\n+ *\n  * <p>This implementation <em>should</em> work even for over-determined systems\n  * (i.e. systems having more variables than equations). Over-determined systems\n  * are solved by ignoring the variables which have the smallest impact according\n  * to their jacobian column norm. Only the rank of the matrix and some loop bounds\n  * are changed to implement this. This feature has undergone only basic testing\n  * for now and should still be considered experimental.</p>\n-\n+ *\n  * <p>The resolution engine is a simple translation of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n  * changes. The changes include the over-determined resolution and the Q.R.\n  * redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n  * is reproduced below.</p>\n-\n+ *\n  * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n  * <tr><td>\n  *    Minpack Copyright Notice (1999) University of Chicago.\n  */\n public class LevenbergMarquardtEstimator implements Serializable, Estimator {\n \n-  /** Build an estimator for least squares problems.\n+  /** \n+   * Build an estimator for least squares problems.\n    * <p>The default values for the algorithm settings are:\n    *   <ul>\n    *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n     setOrthoTolerance(1.0e-10);\n   }\n \n-  /** Set the positive input variable used in determining the initial step bound.\n+  /** \n+   * Set the positive input variable used in determining the initial step bound.\n    * This bound is set to the product of initialStepBoundFactor and the euclidean norm of diag*x if nonzero,\n    * or else to initialStepBoundFactor itself. In most cases factor should lie\n    * in the interval (0.1, 100.0). 100.0 is a generally recommended value\n+   * \n    * @param initialStepBoundFactor initial step bound factor\n    * @see #estimate\n    */\n     this.initialStepBoundFactor = initialStepBoundFactor;\n   }\n \n-  /** Set the maximal number of cost evaluations.\n-  * @param maxCostEval maximal number of cost evaluations\n+  /** \n+   * Set the maximal number of cost evaluations.\n+   * \n+   * @param maxCostEval maximal number of cost evaluations\n    * @see #estimate\n   */\n   public void setMaxCostEval(int maxCostEval) {\n     this.maxCostEval = maxCostEval;\n   }\n \n-  /** Set the desired relative error in the sum of squares.\n+  /** \n+   * Set the desired relative error in the sum of squares.\n+   * \n    * @param costRelativeTolerance desired relative error in the sum of squares\n    * @see #estimate\n    */\n     this.costRelativeTolerance = costRelativeTolerance;\n   }\n \n-  /** Set the desired relative error in the approximate solution parameters.\n+  /** \n+   * Set the desired relative error in the approximate solution parameters.\n+   * \n    * @param parRelativeTolerance desired relative error\n    * in the approximate solution parameters\n    * @see #estimate\n     this.parRelativeTolerance = parRelativeTolerance;\n   }\n \n-  /** Set the desired max cosine on the orthogonality.\n+  /** \n+   * Set the desired max cosine on the orthogonality.\n+   * \n    * @param orthoTolerance desired max cosine on the orthogonality\n    * between the function vector and the columns of the jacobian\n    * @see #estimate\n     this.orthoTolerance = orthoTolerance;\n   }\n \n-  /** Get the number of cost evaluations.\n+  /** \n+   * Get the number of cost evaluations.\n+   * \n    * @return number of cost evaluations\n    * */\n   public int getCostEvaluations() {\n     return costEvaluations;\n   }\n \n-  /** Get the number of jacobian evaluations.\n+  /** \n+   * Get the number of jacobian evaluations.\n+   * \n    * @return number of jacobian evaluations\n    * */\n   public int getJacobianEvaluations() {\n     return jacobianEvaluations;\n   }\n \n-  /** Update the jacobian matrix.\n+  /** \n+   * Update the jacobian matrix.\n    */\n   private void updateJacobian() {\n     ++jacobianEvaluations;\n     }\n   }\n \n-  /** Update the residuals array and cost function value.\n+  /** \n+   * Update the residuals array and cost function value.\n    */\n   private void updateResidualsAndCost() {\n     ++costEvaluations;\n     cost = Math.sqrt(cost);\n   }\n \n-  /** Get the Root Mean Square value.\n+  /** \n+   * Get the Root Mean Square value.\n    * Get the Root Mean Square value, i.e. the root of the arithmetic\n    * mean of the square of all weighted residuals. This is related to the\n    * criterion that is minimized by the estimator as follows: if\n    * <em>c</em> if the criterion, and <em>n</em> is the number of\n    * measurements, then the RMS is <em>sqrt (c/n)</em>.\n+   * \n    * @param problem estimation problem\n    * @return RMS value\n    */\n     return Math.sqrt(criterion / wm.length);\n   }\n \n-  /** Solve an estimation problem using the Levenberg-Marquardt algorithm.\n+  /** \n+   * Solve an estimation problem using the Levenberg-Marquardt algorithm.\n    * <p>The algorithm used is a modified Levenberg-Marquardt one, based\n    * on the MINPACK <a href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a>\n    * routine. The algorithm settings must have been set up before this method\n    *   <li>Jorge   J. More</li>\n    *   </ul>\n    * <p>Luc Maisonobe did the Java translation.</p>\n+   * \n    * @param problem estimation problem to solve\n    * @exception EstimationException if convergence cannot be\n    * reached with the specified algorithm settings or if there are more variables\n \n   }\n \n-  /** Determine the Levenberg-Marquardt parameter.\n+  /** \n+   * Determine the Levenberg-Marquardt parameter.\n    * <p>This implementation is a translation in Java of the MINPACK\n    * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n    * routine.</p>\n    *   <li>Jorge   J. More</li>\n    * </ul>\n    * <p>Luc Maisonobe did the Java translation.</p>\n+   * \n    * @param qy array containing qTy\n    * @param delta upper bound on the euclidean norm of diagR * lmDir\n    * @param diag diagonal matrix\n     }\n   }\n \n-  /** Solve a*x = b and d*x = 0 in the least squares sense.\n+  /** \n+   * Solve a*x = b and d*x = 0 in the least squares sense.\n    * <p>This implementation is a translation in Java of the MINPACK\n    * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n    * routine.</p>\n    *   <li>Jorge   J. More</li>\n    * </ul>\n    * <p>Luc Maisonobe did the Java translation.</p>\n+   * \n    * @param qy array containing qTy\n    * @param diag diagonal matrix\n    * @param lmDiag diagonal elements associated with lmDir\n \n   }\n \n-  /** Decompose a matrix A as A.P = Q.R using Householder transforms.\n+  /** \n+   * Decompose a matrix A as A.P = Q.R using Householder transforms.\n    * <p>As suggested in the P. Lascaux and R. Theodor book\n    * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n    * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n \n   }\n \n-  /** Compute the product Qt.y for some Q.R. decomposition.\n+  /** \n+   * Compute the product Qt.y for some Q.R. decomposition.\n+   * \n    * @param y vector to multiply (will be overwritten with the result)\n    */\n   private void qTy(double[] y) {\n   /** Array of parameters. */\n   private EstimatedParameter[] parameters;\n \n-  /** Jacobian matrix.\n+  /** \n+   * Jacobian matrix.\n    * <p>Depending on the computation phase, this matrix is either in\n    * canonical form (just after the calls to updateJacobian) or in\n    * Q.R. decomposed form (after calls to qrDecomposition)</p>\n--- a/src/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n+++ b/src/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n \n import java.io.Serializable;\n \n-/** This class represents measurements in estimation problems.\n-\n+/** \n+ * This class represents measurements in estimation problems.\n+ *\n  * <p>This abstract class implements all the methods needed to handle\n  * measurements in a general way. It defines neither the {@link\n  * #getTheoreticalValue getTheoreticalValue} nor the {@link\n  * #getPartial getPartial} methods, which should be defined by\n  * sub-classes according to the specific problem.</p>\n-\n+ *\n  * <p>The {@link #getTheoreticalValue getTheoreticalValue} and {@link\n  * #getPartial getPartial} methods must always use the current\n  * estimate of the parameters set by the solver in the problem. These\n  * EstimationProblem.getAllParameters} method if the measurements are\n  * independant of the problem, or directly if they are implemented as\n  * inner classes of the problem.</p>\n-\n+ *\n  * <p>The instances for which the <code>ignored</code> flag is set\n  * through the {@link #setIgnored setIgnored} method are ignored by the\n  * solvers. This can be used to reject wrong measurements at some\n  * steps of the estimation.</p>\n-\n+ *\n  * @see EstimationProblem\n-\n+ *\n  * @version $Id: WeightedMeasurement.java 1705 2006-09-17 19:57:39Z luc $\n-\n+ *\n  */\n \n public abstract class WeightedMeasurement implements Serializable {\n \n-  /** Simple constructor.\n+  /** \n+   * Simple constructor.\n    * Build a measurement with the given parameters, and set its ignore\n    * flag to false.\n    * @param weight weight of the measurement in the least squares problem\n    * (two common choices are either to use 1.0 for all measurements, or to\n    * use a value proportional to the inverse of the variance of the measurement\n    * type)\n+   * \n    * @param measuredValue measured value\n    */\n   public WeightedMeasurement(double weight, double measuredValue) {\n   }\n \n   /** Simple constructor.\n+   * \n    * Build a measurement with the given parameters\n+   * \n    * @param weight weight of the measurement in the least squares problem\n    * @param measuredValue measured value\n    * @param ignored true if the measurement should be ignored\n     this.ignored       = ignored;\n   }\n \n-  /** Get the weight of the measurement in the least squares problem\n+  /** \n+   * Get the weight of the measurement in the least squares problem\n+   * \n    * @return weight\n    */\n   public double getWeight() {\n     return weight;\n   }\n \n-  /** Get the measured value\n+  /** \n+   * Get the measured value\n+   * \n    * @return measured value\n    */\n   public double getMeasuredValue() {\n     return measuredValue;\n   }\n \n-  /** Get the residual for this measurement\n+  /** \n+   * Get the residual for this measurement\n    * The residual is the measured value minus the theoretical value.\n+   * \n    * @return residual\n    */\n   public double getResidual() {\n     return measuredValue - getTheoreticalValue();\n   }\n \n-  /** Get the theoretical value expected for this measurement\n+  /** \n+   * Get the theoretical value expected for this measurement\n    * <p>The theoretical value is the value expected for this measurement\n    * if the model and its parameter were all perfectly known.</p>\n    * <p>The value must be computed using the current estimate of the parameters\n    * set by the solver in the problem.</p>\n+   * \n    * @return theoretical value\n    */\n   public abstract double getTheoreticalValue();\n \n-  /** Get the partial derivative of the {@link #getTheoreticalValue\n+  /** \n+   * Get the partial derivative of the {@link #getTheoreticalValue\n    * theoretical value} according to the parameter.\n    * <p>The value must be computed using the current estimate of the parameters\n    * set by the solver in the problem.</p>\n+   * \n    * @param parameter parameter against which the partial derivative\n    * should be computed\n    * @return partial derivative of the {@link #getTheoreticalValue\n    */\n   public abstract double getPartial(EstimatedParameter parameter);\n \n-  /** Set the ignore flag to the specified value\n+  /** \n+   * Set the ignore flag to the specified value\n    * Setting the ignore flag to true allow to reject wrong\n    * measurements, which sometimes can be detected only rather late.\n+   * \n    * @param ignored value for the ignore flag\n    */\n   public void setIgnored(boolean ignored) {\n     this.ignored = ignored;\n   }\n \n-  /** Check if this measurement should be ignored\n+  /** \n+   * Check if this measurement should be ignored\n+   * \n    * @return true if the measurement should be ignored\n    */\n   public boolean isIgnored() {", "timestamp": 1180306933, "metainfo": ""}