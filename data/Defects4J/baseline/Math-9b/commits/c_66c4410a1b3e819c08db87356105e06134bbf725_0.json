{"sha": "66c4410a1b3e819c08db87356105e06134bbf725", "log": "MATH-646 Unmodifiable view of a vector.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n             throw new MathUnsupportedOperationException();\n         }\n     }\n+\n+    /**\n+     * This class is an implementation of {@link RealVector} with read-only\n+     * access.\n+     * It wraps any {@link RealVector}, and exposes all methods which do not\n+     * modify it. Invoking methods which should normally result in the\n+     * modification of the calling {@link RealVector} results in an\n+     * {@link MathUnsupportedOperationException}. It should be noted that\n+     * {@link UnmodifiableVector} is <em>not</em> immutable.\n+     */\n+    private static final class UnmodifiableVector implements RealVector {\n+        /** The vector for which an unmodifiable view is provided. */\n+        private final RealVector v;\n+\n+        /**\n+         * Creates a view of the given vector.\n+         *\n+         * @param v Vector wrapped in {@code this} view.\n+         */\n+        public UnmodifiableVector(RealVector v) {\n+            this.v = v;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapToSelf(UnivariateRealFunction function) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector map(UnivariateRealFunction function) {\n+            return v.map(function);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Iterator<Entry> iterator() {\n+            final Iterator<Entry> i = v.iterator();\n+            return new Iterator<Entry>() {\n+                /** The current entry. */\n+                private final UnmodifiableEntry e = new UnmodifiableEntry();\n+\n+                public boolean hasNext() {\n+                    return i.hasNext();\n+                }\n+\n+                public Entry next() {\n+                    e.setIndex(i.next().getIndex());\n+                    return e;\n+                }\n+\n+                public void remove() {\n+                    throw new MathUnsupportedOperationException();\n+                }\n+            };\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Iterator<Entry> sparseIterator() {\n+            final Iterator<Entry> i = v.sparseIterator();\n+            return new Iterator<Entry>() {\n+                /** The current entry. */\n+                private final UnmodifiableEntry e = new UnmodifiableEntry();\n+\n+                public boolean hasNext() {\n+                    return i.hasNext();\n+                }\n+\n+                public Entry next() {\n+                    e.setIndex(i.next().getIndex());\n+                    return e;\n+                }\n+\n+                public void remove() {\n+                    throw new MathUnsupportedOperationException();\n+                }\n+            };\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector copy() {\n+            return v.copy();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector add(RealVector w) {\n+            return v.add(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector add(double[] w) {\n+            return v.add(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector subtract(RealVector w) {\n+            return v.subtract(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector subtract(double[] w) {\n+            return v.subtract(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapAdd(double d) {\n+            return v.mapAdd(d);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapAddToSelf(double d) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapSubtract(double d) {\n+            return v.mapSubtract(d);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapSubtractToSelf(double d) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapMultiply(double d) {\n+            return v.mapMultiply(d);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapMultiplyToSelf(double d) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapDivide(double d) {\n+            return v.mapDivide(d);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector mapDivideToSelf(double d) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector ebeMultiply(RealVector w) {\n+            return v.ebeMultiply(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector ebeMultiply(double[] w) {\n+            return v.ebeMultiply(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector ebeDivide(RealVector w) {\n+            return v.ebeDivide(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector ebeDivide(double[] w) {\n+            return v.ebeDivide(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] getData() {\n+            // TODO It is not specified in the javadoc that getData should\n+            // return a\n+            // deep copy\n+            return v.getData();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double dotProduct(RealVector w) {\n+            return v.dotProduct(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double dotProduct(double[] w) {\n+            return v.dotProduct(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double cosine(RealVector w) {\n+            return v.cosine(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double cosine(double[] w) {\n+            return v.cosine(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getNorm() {\n+            return v.getNorm();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getL1Norm() {\n+            return v.getL1Norm();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getLInfNorm() {\n+            return v.getLInfNorm();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getDistance(RealVector w) {\n+            return v.getDistance(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getDistance(double[] w) {\n+            return v.getDistance(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getL1Distance(RealVector w) {\n+            return v.getL1Distance(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getL1Distance(double[] w) {\n+            return v.getL1Distance(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getLInfDistance(RealVector w) {\n+            return v.getLInfDistance(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getLInfDistance(double[] w) {\n+            return v.getLInfDistance(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector unitVector() {\n+            return v.unitVector();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void unitize() {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector projection(RealVector w) {\n+            return v.projection(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector projection(double[] w) {\n+            return v.projection(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix outerProduct(RealVector w) {\n+            return v.outerProduct(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix outerProduct(double[] w) {\n+            return v.outerProduct(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double getEntry(int index) {\n+            return v.getEntry(index);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setEntry(int index, double value) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            return v.getDimension();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector append(RealVector w) {\n+            return v.append(w);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector append(double d) {\n+            return v.append(d);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector append(double[] a) {\n+            return v.append(a);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector getSubVector(int index, int n) {\n+            return v.getSubVector(index, n);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setSubVector(int index, RealVector w) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void setSubVector(int index, double[] w) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void set(double value) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] toArray() {\n+            return v.toArray();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNaN() {\n+            return v.isNaN();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isInfinite() {\n+            return v.isInfinite();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector combine(double a, double b, double[] y) {\n+            return v.combine(a, b, y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector combine(double a, double b, RealVector y) {\n+            return v.combine(a, b, y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector combineToSelf(double a, double b, double[] y) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector combineToSelf(double a, double b, RealVector y) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+\n+        /** An entry in the vector. */\n+        private class UnmodifiableEntry extends Entry {\n+            /** {@inheritDoc} */\n+            @Override\n+            public double getValue() {\n+                return v.getEntry(getIndex());\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void setValue(double newValue) {\n+                throw new MathUnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the specified vector.\n+     * The returned vector has read-only access. An attempt to modify it will\n+     * result in a {@link MathUnsupportedOperationException}. However, the\n+     * returned vector is <em>not</em> immutable, since any modification of\n+     * {@code v} will also change the returned view.\n+     * For example, in the following piece of code\n+     * <pre>\n+     *     RealVector v = new ArrayRealVector(2);\n+     *     RealVector w = RealVector.unmodifiableRealVector(v);\n+     *     v.setEntry(0, 1.2);\n+     *     v.setEntry(1, -3.4);\n+     * </pre>\n+     * the changes will be seen in the {@code w} view of {@code v}.\n+     *\n+     * @param v Vector for which an unmodifiable view is to be returned.\n+     * @return an unmodifiable view of {@code v}.\n+     */\n+    public static RealVector unmodifiableRealVector(final RealVector v) {\n+        return new UnmodifiableVector(v);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/UnmodifiableArrayRealVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for\n+ * unmodifiable views of {@link ArrayRealVectorTest}.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableArrayRealVectorTest\n+    extends UnmodifiableRealVectorAbstractTest {\n+    /**\n+     * Returns a random vector of type {@link ArrayRealVector}.\n+     *\n+     * @return a new random {@link ArrayRealVector}.\n+     */\n+    @Override\n+    public RealVector createVector() {\n+        ArrayRealVector v = new ArrayRealVector(DIM);\n+        for (int i = 0; i < DIM; i++) {\n+            v.setEntry(i, RANDOM.nextDouble());\n+        }\n+        return v;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/UnmodifiableOpenMapRealVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for\n+ * unmodifiable views of {@link OpenMapRealVector}.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableOpenMapRealVectorTest\n+    extends UnmodifiableRealVectorAbstractTest {\n+    /** To ensure sufficient sparsity. */\n+    public static final double PROBABILITY_OF_ZERO = 0.5;\n+\n+    /**\n+     * Returns a random vector of type {@link ArrayRealVector}.\n+     *\n+     * @return a new random {@link ArrayRealVector}.\n+     */\n+    @Override\n+    public RealVector createVector() {\n+        OpenMapRealVector v = new OpenMapRealVector(DIM, EPS);\n+        for (int i = 0; i < DIM; i++) {\n+            if (RANDOM.nextDouble() > PROBABILITY_OF_ZERO) {\n+                v.setEntry(i, RANDOM.nextDouble());\n+            }\n+        }\n+        return v;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/UnmodifiableRealVectorAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.Random;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.function.Sin;\n+import org.apache.commons.math.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math.linear.RealVector.Entry;\n+import org.junit.Test;\n+\n+/**\n+ * This is an abstract test of the {@link AbstractRealVector.UnmodifiableVector}\n+ * implementation. These unmodifiable vectors decorate a (modifiable)\n+ * {@link RealVector}; therefore, a new implementation of this abstract test\n+ * should be considered for each implementation of {@link RealVector}.\n+ *\n+ * @version $Id$\n+ *\n+ */\n+public abstract class UnmodifiableRealVectorAbstractTest {\n+    /** The dimension of the randomly generated vectors. */\n+    protected static final int DIM = 100;\n+    /** Absolute tolerance. */\n+    protected static final double EPS = 10 * Math.ulp(1d);\n+    /**\n+     * The list of methods which are excluded from the general test\n+     * {@link #testAllButExcluded()}.\n+     */\n+    protected static final ArrayList<String> EXCLUDE;\n+    /** The random number generator (always initialized with the same seed. */\n+    protected static final Random RANDOM;\n+\n+    static {\n+        EXCLUDE = new ArrayList<String>();\n+        EXCLUDE.add(\"getEntry\");\n+        EXCLUDE.add(\"setEntry\");\n+        EXCLUDE.add(\"getSubVector\");\n+        EXCLUDE.add(\"setSubVector\");\n+        EXCLUDE.add(\"iterator\");\n+        EXCLUDE.add(\"sparseIterator\");\n+        RANDOM = new Random(20110813);\n+    }\n+\n+    /**\n+     * Returns {@code true} if the specified {@code double} are equal (within a\n+     * given tolerance).\n+     *\n+     * @param x First {@code double}.\n+     * @param y Second {@code double}.\n+     * @return {@code true} if {@code x} and {@code y} are equal.\n+     */\n+    public static boolean equals(final double x, final double y) {\n+        if (x == y) {\n+            return true;\n+        } else if (Math.abs(x) <= EPS) {\n+            return Math.abs(y) <= EPS;\n+        } else if (Math.abs(y) <= EPS) {\n+            return Math.abs(x) <= EPS;\n+        } else {\n+            return Math.abs(x - y) <= EPS * Math.min(Math.abs(x), Math.abs(y));\n+        }\n+    }\n+\n+    /**\n+     * Returns {@code true} if the specified {@code double} arrays are equal\n+     * (within a given tolerance).\n+     *\n+     * @param x First array.\n+     * @param y Second array.\n+     * @return {@code true} if {@code x} and {@code y} are equal.\n+     */\n+    public static boolean equals(final double[] x, final double[] y) {\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        final int n = x.length;\n+        for (int i = 0; i < n; i++) {\n+            if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns {@code true} if the specified {@code RealVector} are equal\n+     * (within a given tolerance).\n+     *\n+     * @param x First vector.\n+     * @param y Second vector.\n+     * @return {@code true} if {@code x} and {@code y} are equal.\n+     */\n+    public static boolean equals(final RealVector x, final RealVector y) {\n+        if (x.getDimension() != y.getDimension()) {\n+            return false;\n+        }\n+        final int n = x.getDimension();\n+        for (int i = 0; i < n; i++) {\n+            if (!equals(x.getEntry(i), y.getEntry(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns {@code true} if the specified {@code RealVector} is equal to the\n+     * specified {@code double} array (within a given tolerance).\n+     *\n+     * @param x Vector.\n+     * @param y Array.\n+     * @return {@code true} if {@code x} and {@code y} are equal.\n+     */\n+    public static boolean equals(final RealVector x, final double[] y) {\n+        if (x.getDimension() != y.length) {\n+            return false;\n+        }\n+        final int n = x.getDimension();\n+        for (int i = 0; i < n; i++) {\n+            if (!equals(x.getEntry(i), y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns {@code true} if the specified {@code RealMatrix} are equal\n+     * (within a given tolerance).\n+     *\n+     * @param x First matrix.\n+     * @param y Second matrix.\n+     * @return {@code true} if {@code x} and {@code y} are equal.\n+     */\n+    public static boolean equals(final RealMatrix x, final RealMatrix y) {\n+        if (x.getRowDimension() != y.getRowDimension()) {\n+            return false;\n+        }\n+        if (x.getColumnDimension() != y.getColumnDimension()) {\n+            return false;\n+        }\n+        final int rows = x.getRowDimension();\n+        final int cols = x.getColumnDimension();\n+        for (int i = 0; i < rows; i++) {\n+            for (int j = 0; j < cols; j++) {\n+                if (!equals(x.getEntry(i, j), y.getEntry(i, j))) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns {@code true} if the specified {@code Object} are equal.\n+     *\n+     * @param x First object.\n+     * @param y Second object.\n+     * @return {@code true} if {@code x} and {@code y} are equal.\n+     * @throws IllegalArgumentException if {@code x} and {@code y} could\n+     * not be compared.\n+     */\n+    public static boolean equals(final Object x, final Object y) {\n+        if (x instanceof Boolean) {\n+            if (y instanceof Boolean) {\n+                return ((Boolean) x).booleanValue() == ((Boolean) y)\n+                        .booleanValue();\n+            } else {\n+                return false;\n+            }\n+        }\n+        if (x instanceof Integer) {\n+            if (y instanceof Integer) {\n+                return ((Integer) x).intValue() == ((Integer) y).intValue();\n+            } else {\n+                return false;\n+            }\n+        } else if (x instanceof Double) {\n+            if (y instanceof Double) {\n+                return equals(((Double) x).doubleValue(),\n+                        ((Double) y).doubleValue());\n+            } else {\n+                return false;\n+            }\n+        } else if (x instanceof double[]) {\n+            if (y instanceof double[]) {\n+                return equals((double[]) x, (double[]) y);\n+            } else if (y instanceof RealVector) {\n+                return equals((RealVector) y, (double[]) x);\n+            } else {\n+                return false;\n+            }\n+        } else if (x instanceof RealVector) {\n+            if (y instanceof double[]) {\n+                return equals((RealVector) x, (double[]) y);\n+            } else if (y instanceof RealVector) {\n+                return equals((RealVector) x, (RealVector) y);\n+            } else {\n+                return false;\n+            }\n+        } else if (x instanceof RealMatrix) {\n+            if (y instanceof RealMatrix) {\n+                return equals((RealMatrix) x, (RealMatrix) y);\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"could not compare \" + x + \", \"\n+                    + y);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new random vector of a specified type. This vector is then to\n+     * be wrapped in a {@link AbstractRealVector.UnmodifiableVector}.\n+     *\n+     * @return a new random vector.\n+     */\n+    public abstract RealVector createVector();\n+\n+    /**\n+     * Creates a new random object of the specified type.\n+     *\n+     * @param c\n+     *            the class of the object to be created.\n+     * @return a new random object.\n+     * @throws IllegalArgumentException\n+     *             if the specified class is not recognized by this method.\n+     */\n+    public Object createParameter(final Class<?> c) {\n+        if (c == Integer.TYPE) {\n+            return Integer.valueOf(RANDOM.nextInt());\n+        } else if (c == Double.TYPE) {\n+            return Double.valueOf(RANDOM.nextDouble());\n+        } else if (c == double[].class) {\n+            final double[] v = new double[DIM];\n+            for (int i = 0; i < DIM; i++) {\n+                v[i] = RANDOM.nextDouble();\n+            }\n+            return v;\n+        } else if (c.isAssignableFrom(RealVector.class)) {\n+            return createVector();\n+        } else if (c.isAssignableFrom(UnivariateRealFunction.class)) {\n+            return new Sin();\n+        } else {\n+            throw new IllegalArgumentException(\"could not create \" + c);\n+        }\n+    }\n+\n+    /**\n+     * This is the general test of most methods in\n+     * {@link AbstractRealVector.UnmodifiableVector}. It works as follows.\n+     * First, an unmodifiable view of a copy of the specified random vector\n+     * {@code u} is created: this defines {@code v}. Then the <em>same</em>\n+     * method {@code m} is invoked on {@code u} and {@code v}, with randomly\n+     * generated parameters {@code args}.\n+     * If it turns out that {@code u} has changed after the call of method\n+     * {@code m}, then this test checks that the call of this method on\n+     * {@code v} resulted in a {@link MathUnsupportedOperationException}. If\n+     * {@code u} was not modified, then this test checks that the results\n+     * returned by the call of method {@code m} on {@code u} and {@code v}\n+     * returned the same result.\n+     *\n+     * @param m Method to be tested.\n+     * @param u Random vector from which the unmodifiable view is to be\n+     *constructed.\n+     * @param args Arguments to be passed to method {@code m}.\n+     */\n+    private void callMethod(final Method m, final RealVector u,\n+            final Object... args) throws IllegalAccessException,\n+            IllegalArgumentException, InvocationTargetException {\n+        final RealVector uu = u.copy();\n+        final RealVector v = AbstractRealVector\n+                .unmodifiableRealVector(u.copy());\n+        Object exp = m.invoke(u, args);\n+        if (equals(uu, u)) {\n+            Object act = m.invoke(v, args);\n+            Assert.assertTrue(m.toGenericString()\n+                    + \", unmodifiable vector has changed\", equals(uu, v));\n+            Assert.assertTrue(m.toGenericString() + \", wrong result\",\n+                    equals(exp, act));\n+\n+        } else {\n+            boolean flag = false;\n+            try {\n+                m.invoke(v, args);\n+            } catch (InvocationTargetException e) {\n+                if (e.getCause() instanceof MathUnsupportedOperationException) {\n+                    flag = true;\n+                }\n+            }\n+            Assert.assertTrue(m.toGenericString()+\", exception should have been thrown\", flag);\n+        }\n+    }\n+\n+    /**\n+     * This test calls {@link #callMethod(Method, RealVector, Object...)} on\n+     * every method defined in interface {@link RealVector}. It generates the\n+     * appropriate random arguments. Some methods are manually excluded (see\n+     * {@link #EXCLUDE}), they must be handled by separate tests.\n+     */\n+    @Test\n+    public void testAllButExcluded() throws IllegalAccessException,\n+            IllegalArgumentException, InvocationTargetException {\n+        Method[] method = RealVector.class.getMethods();\n+        for (int i = 0; i < method.length; i++) {\n+            Method m = method[i];\n+            if (!EXCLUDE.contains(m.getName())) {\n+                RealVector u = (RealVector) createParameter(RealVector.class);\n+                Class<?>[] paramType = m.getParameterTypes();\n+                Object[] param = new Object[paramType.length];\n+                for (int j = 0; j < paramType.length; j++) {\n+                    param[j] = createParameter(paramType[j]);\n+                }\n+                callMethod(m, u, param);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testGetEntry() {\n+        RealVector u = createVector();\n+        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        for (int i = 0; i < DIM; i++) {\n+            Assert.assertTrue(equals(u.getEntry(i), v.getEntry(i)));\n+        }\n+    }\n+\n+    @Test(expected = MathUnsupportedOperationException.class)\n+    public void testSetEntry() {\n+        RealVector u = createVector();\n+        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        for (int i = 0; i < DIM; i++) {\n+            v.setEntry(i, 0d);\n+        }\n+    }\n+\n+    @Test\n+    public void testGetSubVector() {\n+        RealVector u = createVector();\n+        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        for (int i = 0; i < DIM; i++) {\n+            for (int n = 1; n < DIM - i; n++) {\n+                RealVector exp = u.getSubVector(i, n);\n+                RealVector act = v.getSubVector(i, n);\n+                Assert.assertTrue(equals(exp, act));\n+            }\n+        }\n+    }\n+\n+    @Test(expected = MathUnsupportedOperationException.class)\n+    public void testSetSubVector() {\n+        RealVector u = createVector();\n+        RealVector v = AbstractRealVector.unmodifiableRealVector(u);\n+        v.setSubVector(0, new ArrayRealVector());\n+    }\n+\n+    @Test\n+    public void testIterator() {\n+        RealVector u = createVector();\n+        Iterator<Entry> i = u.iterator();\n+        RealVector v = AbstractRealVector.unmodifiableRealVector(u.copy());\n+        Iterator<Entry> j = v.iterator();\n+        boolean flag;\n+        while (i.hasNext()) {\n+            Assert.assertTrue(j.hasNext());\n+            Entry exp = i.next();\n+            Entry act = j.next();\n+            Assert.assertTrue(equals(exp.getIndex(), act.getIndex()));\n+            Assert.assertTrue(equals(exp.getValue(), act.getValue()));\n+            exp.setIndex(RANDOM.nextInt(DIM));\n+            act.setIndex(RANDOM.nextInt(DIM));\n+            flag = false;\n+            try {\n+                act.setValue(RANDOM.nextDouble());\n+            } catch (MathUnsupportedOperationException e) {\n+                flag = true;\n+            }\n+            Assert.assertTrue(\"exception should have been thrown\", flag);\n+        }\n+        Assert.assertFalse(j.hasNext());\n+    }\n+\n+    @Test\n+    public void testSparseIterator() {\n+        RealVector u = createVector();\n+        Iterator<Entry> i = u.sparseIterator();\n+        RealVector v = AbstractRealVector.unmodifiableRealVector(u.copy());\n+        Iterator<Entry> j = v.sparseIterator();\n+        boolean flag;\n+        while (i.hasNext()) {\n+            Assert.assertTrue(j.hasNext());\n+            Entry exp = i.next();\n+            Entry act = j.next();\n+            Assert.assertTrue(equals(exp.getIndex(), act.getIndex()));\n+            Assert.assertTrue(equals(exp.getValue(), act.getValue()));\n+            exp.setIndex(RANDOM.nextInt(DIM));\n+            act.setIndex(RANDOM.nextInt(DIM));\n+            flag = false;\n+            try {\n+                act.setValue(RANDOM.nextDouble());\n+            } catch (MathUnsupportedOperationException e) {\n+                flag = true;\n+            }\n+            Assert.assertTrue(\"exception should have been thrown\", flag);\n+        }\n+        Assert.assertFalse(j.hasNext());\n+    }\n+}", "timestamp": 1314188151, "metainfo": ""}