{"sha": "f32c25c23ab75ae08a616621e8a060c7f9ec4e66", "log": "added all necessary multi-start optimizers types  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartScalarDifferentiableOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link ScalarDifferentiableOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartScalarDifferentiableOptimizer implements ScalarDifferentiableOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 9008747186334431824L;\n+\n+    /** Underlying classical optimizer. */\n+    private final ScalarDifferentiableOptimizer optimizer;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private ScalarPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartScalarDifferentiableOptimizer(final ScalarDifferentiableOptimizer optimizer,\n+                                                   final int starts,\n+                                                   final RandomVectorGenerator generator) {\n+        this.optimizer        = optimizer;\n+        this.totalEvaluations = 0;\n+        this.maxEvaluations   = Integer.MAX_VALUE;\n+        this.starts           = starts;\n+        this.generator        = generator;\n+        this.optima           = null;\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(ScalarObjectiveFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(ScalarObjectiveFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(ScalarObjectiveFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public ScalarPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return (ScalarPointValuePair[]) optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ScalarConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ScalarConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ScalarPointValuePair optimize(final ScalarDifferentiableObjectiveFunction f,\n+                                         final GoalType goalType,\n+                                         double[] startPoint)\n+        throws ObjectiveException, OptimizationException {\n+\n+        optima = new ScalarPointValuePair[starts];\n+        totalEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optima[i] = optimizer.optimize(f, goalType,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (ObjectiveException obe) {\n+                optima[i] = null;\n+            } catch (OptimizationException ope) {\n+                optima[i] = null;\n+            }\n+\n+            totalEvaluations += optimizer.getEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<ScalarPointValuePair>() {\n+            public int compare(final ScalarPointValuePair o1, final ScalarPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartScalarOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link ScalarOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartScalarOptimizer implements ScalarOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 6648351778723282863L;\n+\n+    /** Underlying classical optimizer. */\n+    private final ScalarOptimizer optimizer;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private ScalarPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartScalarOptimizer(final ScalarOptimizer optimizer, final int starts,\n+                                     final RandomVectorGenerator generator) {\n+        this.optimizer        = optimizer;\n+        this.totalEvaluations = 0;\n+        this.maxEvaluations   = Integer.MAX_VALUE;\n+        this.starts           = starts;\n+        this.generator        = generator;\n+        this.optima           = null;\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(ScalarObjectiveFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(ScalarObjectiveFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(ScalarObjectiveFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public ScalarPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return (ScalarPointValuePair[]) optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(ScalarConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ScalarConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ScalarPointValuePair optimize(final ScalarObjectiveFunction f,\n+                                         final GoalType goalType,\n+                                         double[] startPoint)\n+        throws ObjectiveException, OptimizationException {\n+\n+        optima = new ScalarPointValuePair[starts];\n+        totalEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optima[i] = optimizer.optimize(f, goalType,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (ObjectiveException obe) {\n+                optima[i] = null;\n+            } catch (OptimizationException ope) {\n+                optima[i] = null;\n+            }\n+\n+            totalEvaluations += optimizer.getEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<ScalarPointValuePair>() {\n+            public int compare(final ScalarPointValuePair o1, final ScalarPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartVectorialDifferentiableOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link VectorialDifferentiableOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartVectorialDifferentiableOptimizer implements VectorialDifferentiableOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -6671992853686531955L;\n+\n+    /** Underlying classical optimizer. */\n+    private final VectorialDifferentiableOptimizer optimizer;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of jacobian evaluations already performed for all starts. */\n+    private int totalJacobianEvaluations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private VectorialPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartVectorialDifferentiableOptimizer(final VectorialDifferentiableOptimizer optimizer,\n+                                                      final int starts,\n+                                                      final RandomVectorGenerator generator) {\n+        this.optimizer                = optimizer;\n+        this.totalEvaluations         = 0;\n+        this.totalJacobianEvaluations = 0;\n+        this.maxEvaluations           = Integer.MAX_VALUE;\n+        this.starts                   = starts;\n+        this.generator                = generator;\n+        this.optima                   = null;\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(ScalarObjectiveFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(ScalarObjectiveFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(ScalarObjectiveFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(ScalarObjectiveFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public VectorialPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return (VectorialPointValuePair[]) optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getJacobianEvaluations() {\n+        return totalJacobianEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(VectorialConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialPointValuePair optimize(final VectorialDifferentiableObjectiveFunction f,\n+                                            final double[] target, final double[] weights,\n+                                            final double[] startPoint)\n+        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+\n+        optima = new VectorialPointValuePair[starts];\n+        totalEvaluations = 0;\n+        totalJacobianEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optima[i] = optimizer.optimize(f, target, weights,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (ObjectiveException obe) {\n+                optima[i] = null;\n+            } catch (OptimizationException ope) {\n+                optima[i] = null;\n+            }\n+\n+            totalEvaluations         += optimizer.getEvaluations();\n+            totalJacobianEvaluations += optimizer.getJacobianEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<VectorialPointValuePair>() {\n+            public int compare(final VectorialPointValuePair o1, final VectorialPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                return Double.compare(weightedResidual(o1), weightedResidual(o2));\n+            }\n+            private double weightedResidual(final VectorialPointValuePair pv) {\n+                final double[] value = pv.getValueRef();\n+                double sum = 0;\n+                for (int i = 0; i < value.length; ++i) {\n+                    final double ri = value[i] - target[i];\n+                    sum += weights[i] * ri * ri;\n+                }\n+                return sum;\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}", "timestamp": 1237152811, "metainfo": ""}