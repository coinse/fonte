{"sha": "b00700c7fb5be634207941ac73dbf44f8ae01314", "log": "Fixed checkstyle, javadoc, findbugs and eclipse warnings.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/filter/KalmanFilter.java\n+++ b/src/main/java/org/apache/commons/math/filter/KalmanFilter.java\n  * @version $Id$\n  */\n public class KalmanFilter {\n-    /** Serializable version identifier. */\n-    private static final long serialVersionUID = 4878026651422612760L;\n     /** The process model used by this filter instance. */\n     private final ProcessModel processModel;\n     /** The measurement model used by this filter instance. */\n      */\n     public void correct(final RealVector z) {\n         // sanity checks\n-        if (z != null &&\n-            z.getDimension() != measurementMatrix.getRowDimension()) {\n+        MathUtils.checkNotNull(z);\n+        if (z.getDimension() != measurementMatrix.getRowDimension()) {\n             throw new DimensionMismatchException(z.getDimension(),\n                                                  measurementMatrix.getRowDimension());\n         }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/PolygonsSet.java\n \n     }\n \n+    /** Private extension of Segment allowing comparison. */\n     private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n \n         /** Sorting key. */\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java\n \n     }\n \n-    /** {@inheritDoc} */\n-    public abstract AbstractRegion<S, T> buildNew(BSPTree<S> newTree);\n-\n     /** Build a convex region from an array of bounding hyperplanes.\n      * @param hyperplanes array of bounding hyperplanes (if null, an\n      * empty region will be built)\n         }\n \n     }\n+\n+    /** {@inheritDoc} */\n+    public abstract AbstractRegion<S, T> buildNew(BSPTree<S> newTree);\n \n     /** Recursively build a tree by inserting cut sub-hyperplanes.\n      * @param node current tree node (it is a leaf node at the beginning\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n         public int compareTo(DoubleIndex o) {\n             return Double.compare(value, o.value);\n         }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean equals(Object other) {\n+\n+            if (this == other) {\n+                return true;\n+            }\n+\n+            if (other instanceof DoubleIndex) {\n+                return Double.compare(value, ((DoubleIndex) other).value) == 0;\n+            }\n+\n+            return false;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public int hashCode() {\n+            long bits = Double.doubleToLongBits(value);\n+            return (int) ((1438542 ^ (bits >>> 32) ^ bits) & 0xffffffff);\n+        }\n+\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n      *\n      * @param points the points to cluster\n      * @param k the number of clusters to split the data into\n-     * @param maxIterations the maximum number of iterations to run the algorithm\n-     *     for.  If negative, no maximum will be used\n+     * @param numTrials number of trial runs\n+     * @param maxIterationsPerTrial the maximum number of iterations to run the algorithm\n+     *     for at each trial run.  If negative, no maximum will be used\n      * @return a list of clusters containing the points\n      * @throws MathIllegalArgumentException if the data points are null or the number\n      *     of clusters is larger than the number of data points\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n      * Check all entries of the input array are strictly positive.\n      *\n      * @param in Array to be tested.\n-     * @exception NotStrictlyPositiveException if one entry is not positive.\n+     * @exception MathIllegalArgumentException if one entry is not positive.\n      */\n     private void checkPositive(double[] in) {\n         for (int i = 0; i < in.length; i++) {\n      * Check all entries of the input array are >= 0.\n      *\n      * @param in Array to be tested.\n-     * @exception NotPositiveException if one entry is negative.\n+     * @exception MathIllegalArgumentException if one entry is negative.\n      */\n     private void checkNonNegative(long[] in) {\n         for (int i = 0; i < in.length; i++) {\n      * Check all entries of the input array are >= 0.\n      *\n      * @param in Array to be tested.\n-     * @exception NotPositiveException if one entry is negative.\n+     * @exception MathIllegalArgumentException if one entry is negative.\n      */\n     private void checkNonNegative(long[][] in) {\n         for (int i = 0; i < in.length; i ++) {", "timestamp": 1309115586, "metainfo": ""}