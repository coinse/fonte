{"sha": "84f1ef1d4578d2a8be6972e7172b308277911faa", "log": "- refactored top level of Exception hierarchy, - added getPatern(), getArguments() and getMessage(Locale)   (names chosen for consistency with java.text.MessageFormat) - deprecated some raw constructors as the top level exception are too   coarse grained and intended only as base classes for easier to use classes - added several constructors for use by more fine grained derived classes  ", "commit": "\n--- a/src/java/org/apache/commons/math/ConvergenceException.java\n+++ b/src/java/org/apache/commons/math/ConvergenceException.java\n public class ConvergenceException extends MathException implements Serializable{\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -3657394299929217890L;\n-    \n+    private static final long serialVersionUID = 7426445244781020663L;\n+\n     /**\n      * Default constructor.\n      */\n     public ConvergenceException() {\n-        this(null, null);\n+        super(\"Convergence failed\", new Object[0]);\n     }\n     \n     /**\n      * Construct an exception with the given message.\n-     * @param message descriptive error message. \n+     * @param message descriptive error message\n+     * @deprecated as of 1.2, replaced by {@link #ConvergenceException(String, Object[])}\n      */\n     public ConvergenceException(String message) {\n-        this(message, null);\n+        super(message);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public ConvergenceException(String pattern, Object[] arguments) {\n+        super(pattern, arguments);\n     }\n \n     /**\n      * Construct an exception with the given message and root cause.\n-     * @param message descriptive error message.\n-     * @param cause root cause.\n+     * @param message descriptive error message\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @deprecated as of 1.2, replaced by {@link #ConvergenceException(String, Object[], Throwable)}\n      */\n     public ConvergenceException(String message, Throwable cause) {\n         super(message, cause);\n \n     /**\n      * Create an exception with a given root cause.\n-     * @param throwable caught exception causing this problem\n+     * @param cause  the exception or error that caused this exception to be thrown\n      */\n-    public ConvergenceException(Throwable throwable) {\n-        this(null, throwable);\n+    public ConvergenceException(Throwable cause) {\n+        super(cause);\n     }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public ConvergenceException(String pattern, Object[] arguments, Throwable cause) {\n+        super(pattern, arguments, cause);\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n  */\n public class FunctionEvaluationException extends MathException  {\n     \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -317289374378977972L;\n-    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7619974756160279127L;\n+\n     /** Argument causing function evaluation failure */\n     private double argument = Double.NaN;\n     \n     /**\n      * Construct an exception indicating the argument value\n-     * that caused the function evaluation to fail.  Generates an exception\n-     * message of the form \"Evaluation failed for argument = \" + argument.\n+     * that caused the function evaluation to fail.\n      * \n      * @param argument  the failing function argument \n      */\n     public FunctionEvaluationException(double argument) {\n-        this(argument, \"Evaluation failed for argument = \" + argument);\n+        super(\"Evaluation failed for argument = {0}\",\n+              new Object[] { new Double(argument) });\n+        this.argument = argument;\n     }\n     \n     /**\n      * Construct an exception using the given argument and message\n-     * text.  The message text of the exception will start with \n-     * <code>message</code> and be followed by \n-     * \" Evaluation failed for argument = \" + argument.\n+     * text.\n      * \n      * @param argument  the failing function argument \n      * @param message  the exception message text\n+     * @deprecated as of 1.2, replaced by {@link #FunctionEvaluationException(double, String, Object[])\n      */\n     public FunctionEvaluationException(double argument, String message) {\n-        this(argument, message, null);\n+        super(message);\n+        this.argument = argument;\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument \n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public FunctionEvaluationException(double argument,\n+                                       String pattern, Object[] arguments) {\n+        super(pattern, arguments);\n+        this.argument = argument;\n     }\n \n     /**\n      * Construct an exception with the given argument, message and root cause.\n-     * The message text of the exception will start with  <code>message</code>\n-     * and be followed by \" Evaluation failed for argument = \" + argument.\n      * \n      * @param argument  the failing function argument \n      * @param message descriptive error message\n      * @param cause root cause.\n+     * @deprecated as of 1.2, replaced by {@link #FunctionEvaluationException(double, String, Object[], Throwable)}\n      */\n-    public FunctionEvaluationException(double argument, String message, \n-            Throwable cause) {\n-        super(message + \" Evaluation failed for argument=\" + argument, cause);\n+    public FunctionEvaluationException(double argument,\n+                                       String message, Throwable cause) {\n+        super(message, cause);\n         this.argument = argument;\n     }\n-    \n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument \n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public FunctionEvaluationException(double argument,\n+                                       String pattern, Object[] arguments,\n+                                       Throwable cause) {\n+        super(pattern, arguments, cause);\n+        this.argument = argument;\n+    }\n+\n     /**\n      * Returns the function argument that caused this exception.\n      * \n     public double getArgument() {\n         return this.argument;\n     }\n+\n }\n--- a/src/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/java/org/apache/commons/math/MathConfigurationException.java\n  * Signals a configuration problem with any of the factory methods.\n  * @version $Revision$ $Date$\n  */\n-public class MathConfigurationException extends MathException implements Serializable {\n-    \n+public class MathConfigurationException extends MathException implements Serializable{\n+\n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -7958299004965931723L;\n-\n+    private static final long serialVersionUID = -4056541384141349722L;\n     /**\n      * Default constructor.\n      */\n     public MathConfigurationException() {\n-        this(null, null);\n+        super();\n+    }\n+    \n+    /**\n+     * Construct an exception with the given message.\n+     * @param message descriptive error message\n+     * @deprecated as of 1.2, replaced by {@link #MathConfigurationException(String, Object[])}\n+     */\n+    public MathConfigurationException(String message) {\n+        super(message);\n     }\n \n     /**\n-     * Construct an exception with the given message.\n-     * @param message message describing the problem\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n      */\n-    public MathConfigurationException(final String message) {\n-        this(message, null);\n+    public MathConfigurationException(String pattern, Object[] arguments) {\n+        super(pattern, arguments);\n     }\n \n     /**\n      * Construct an exception with the given message and root cause.\n-     * @param message message describing the problem\n-     * @param throwable caught exception causing this problem\n+     * @param message descriptive error message\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @deprecated as of 1.2, replaced by {@link #MathConfigurationException(String, Object[], Throwable)}\n      */\n-    public MathConfigurationException(\n-        final String message,\n-        final Throwable throwable) {\n-        super(message, throwable);\n+    public MathConfigurationException(String message, Throwable cause) {\n+        super(message, cause);\n     }\n \n     /**\n-     * Construct an exception with the given root cause.\n-     * @param throwable caught exception causing this problem\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n      */\n-    public MathConfigurationException(final Throwable throwable) {\n-        this(null, throwable);\n+    public MathConfigurationException(Throwable cause) {\n+        super(cause);\n     }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public MathConfigurationException(String pattern, Object[] arguments, Throwable cause) {\n+        super(pattern, arguments, cause);\n+    }\n+\n }\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n \n import java.io.PrintStream;\n import java.io.PrintWriter;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n \n \n /**\n public class MathException extends Exception {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -8594613561393443827L;\n-    \n+    private static final long serialVersionUID = -8602234299177097102L;\n+\n     /**\n      * Does JDK support nested exceptions?\n      */\n         }\n         JDK_SUPPORTS_NESTED = flag;\n     }\n-    \n+\n+    private static ResourceBundle cachedResources = null;\n+ \n+    /**\n+     * Pattern used to build the message.\n+     */\n+    private final String pattern;\n+\n+    /**\n+     * Arguments used to build the message.\n+     */\n+    private final Object[] arguments;\n+\n     /**\n      * Root cause of the exception\n      */\n     private final Throwable rootCause;\n     \n+    /**\n+     * Translate a string to a given locale.\n+     * @param s string to translate\n+     * @param locale locale into which to translate the string\n+     * @return translated string or original string\n+     * for unsupported locales or unknown strings\n+     */\n+    private static String translate(String s, Locale locale) {\n+        try {\n+            if ((cachedResources == null) || (! cachedResources.getLocale().equals(locale))) {\n+                // caching the resource bundle\n+                cachedResources =\n+                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n+            }\n+\n+            if (cachedResources.getLocale().equals(locale)) {\n+                // the value of the resource is the translated string\n+                return cachedResources.getString(s);\n+            }\n+            \n+        } catch (MissingResourceException mre) {\n+            // do nothing here\n+        }\n+\n+        // the locale is not supported or the resource is unknown\n+        // don't translate and fall back to using the string as is\n+        return s;\n+\n+    }\n+\n     /**\n      * Constructs a new <code>MathException</code> with no\n      * detail message.\n      */\n     public MathException() {\n         super();\n+        this.pattern   = null;\n+        this.arguments = new Object[0];\n         this.rootCause = null;\n     }\n     \n      * detail message.\n      *\n      * @param msg  the error message.\n+     * @deprecated as of 1.2, replaced by {@link #MathException(String, Object[])}\n      */\n     public MathException(String msg) {\n         super(msg);\n+        this.pattern   = msg;\n+        this.arguments = new Object[0];\n         this.rootCause = null;\n     }\n-    \n+\n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathException(String pattern, Object[] arguments) {\n+      super(new MessageFormat(pattern, Locale.US).format(arguments));\n+      this.pattern   = pattern;\n+      this.arguments = arguments;\n+      this.rootCause = null;\n+    }\n+\n     /**\n      * Constructs a new <code>MathException</code> with specified\n      * nested <code>Throwable</code> root cause.\n      */\n     public MathException(Throwable rootCause) {\n         super((rootCause == null ? null : rootCause.getMessage()));\n+        this.pattern   = getMessage();\n+        this.arguments = new Object[0];\n         this.rootCause = rootCause;\n     }\n     \n      * @param msg  the error message.\n      * @param rootCause  the exception or error that caused this exception\n      *                   to be thrown.\n+     * @deprecated as of 1.2, replaced by {@link #MathException(String, Object[], Throwable)}\n      */\n     public MathException(String msg, Throwable rootCause) {\n         super(msg);\n+        this.pattern   = msg;\n+        this.arguments = new Object[0];\n         this.rootCause = rootCause;\n     }\n-    \n+\n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public MathException(String pattern, Object[] arguments, Throwable rootCause) {\n+      super(new MessageFormat(pattern, Locale.US).format(arguments));\n+      this.pattern   = pattern;\n+      this.arguments = arguments;\n+      this.rootCause = rootCause;\n+    }\n+\n+    /** Gets the pattern used to build the message of this throwable.\n+     *\n+     * @return the pattern used to build the message of this throwable\n+     */\n+    public String getPattern() {\n+        return pattern;\n+    }\n+\n+    /** Gets the arguments used to build the message of this throwable.\n+     *\n+     * @return the arguments used to build the message of this throwable\n+     */\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    /** Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated\n+     * \n+     * @return localized message\n+     */\n+    public String getMessage(Locale locale) {\n+        if (pattern == null) {\n+            return null;\n+        }\n+        return new MessageFormat(translate(pattern, locale), locale).format(arguments);\n+    }\n+\n     /**\n      * Gets the cause of this throwable.\n      * \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+// \n+//   http://www.apache.org/licenses/LICENSE-2.0\n+// \n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.commons.math;\n+\n+import java.util.ListResourceBundle;\n+\n+/** French localization message resources for the commons-math library.\n+ * @version $Revision:$\n+ */\n+public class MessagesResources_fr\n+  extends ListResourceBundle {\n+\n+  /** Simple constructor.\n+   */\n+  public MessagesResources_fr() {\n+  }\n+\n+  public Object[][] getContents() {\n+    return (Object[][]) contents.clone();\n+  }\n+\n+  static final Object[][] contents = {\n+\n+    // org.apache.commons.math.FunctionEvaluationException\n+    { \"Evaluation failed for argument = {0}\",\n+      \"Erreur d''\\u00e9valuation pour l''argument {0}\" },\n+\n+    // org.apache.commons.math.DuplicateSampleAbscissaException\n+    { \"Abscissa {0} is duplicated at both indices {1} and {2}\",\n+      \"Abscisse {0} dupliqu\\u00e9e aux indices {1} et {2}\" },\n+\n+    // org.apache.commons.math.ConvergenceException\n+    { \"Convergence failed\",\n+      \"\\u00c9chec de convergence\" },\n+\n+    // org.apache.commons.math.ArgumentOutsideDomainException\n+    { \"Argument {0} outside domain [{1} ; {2}]\",\n+      \"Argument {0} hors du domaine [{1} ; {2}]\" },\n+\n+    // org.apache.commons.math.MaxIterationsExceededException\n+    { \"Maximal number of iterations ({0}) exceeded\",\n+      \"Nombre maximal d''it\\u00e9rations ({0}) d\\u00e9pass\\u00e9\" },\n+\n+    // org.apache.commons.math.fraction.FractionConversionException\n+    { \"Unable to convert {0} to fraction after {1} iterations\",\n+      \"Impossible de convertir {0} en fraction apr\\u00e8s {1} it\\u00e9rations\" },\n+\n+    // org.apache.commons.math.analysis.UnivariateRealSolverUtils\n+    { \"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4},\" +\n+          \" final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n+      \"Nombre d''it\\u00e9rations = {0}, it\\u00e9rations maximum = {1}, valeur initiale = {2},\" +\n+          \" borne inf\\u00e9rieure = {3}, borne sup\\u00e9rieure = {4},\" +\n+          \" valeur a finale = {5}, valeur b finale = {6}, f(a) = {7}, f(b) = {8}\" },\n+\n+    // org.apache.commons.math.util.ContinuedFraction\n+    { \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+      \"Divergence de fraction continue \\u00e0 l''infini pour la valeur {0}\" },\n+    { \"Continued fraction convergents failed to converge for value {0}\",\n+      \"\\u00c9chec de convergence de fraction continue pour la valeur {0}\" },\n+\n+    // org.apache.commons.math.util.DefaultTransformer\n+    { \"Conversion Exception in Transformation, Object is null\",\n+      \"Exception de conversion dans une transformation, l''objet est nul\" },\n+    { \"Conversion Exception in Transformation: {0}\",\n+      \"Exception de conversion dans une transformation : {0}\" },\n+\n+    // org.apache.commons.math.estimation.GaussNewtonEstimator\n+    { \"unable to converge in {0} iterations\",\n+      \"pas de convergence apr\\u00e8s {0} it\\u00e9rations\" },\n+\n+    // org.apache.commons.math.estimation.LevenbergMarquardtEstimator\n+    { \"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\",\n+      \"trop petite tol\\u00e9rance relative sur le co\\u00fbt ({0}), aucune r\\u00e9duction de la somme des carr\\u00e9s n''est possible\" },\n+    { \"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\",\n+      \"trop petite tol\\u00e9rance relative sur les param\\u00e8tres ({0}), aucune am\\u00e9lioration de la solution approximative n''est possible\" },\n+    { \"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\",\n+      \"trop petite tol\\u00e9rance sur l''orthogonalit\\u00e9 ({0}), la solution est orthogonale \\u00e0 la jacobienne\" },\n+    { \"maximal number of evaluations exceeded ({0})\",\n+      \"nombre maximal d''\\u00e9valuations d\\u00e9pass\\u00e9 ({0})\" },\n+\n+    // org.apache.commons.math.geometry.CardanEulerSingularityException\n+    { \"Cardan angles singularity\",\n+      \"singularit\\u00e9 d''angles de Cardan\" },\n+    { \"Euler angles singularity\",\n+      \"singularit\\u00e9 d''angles d''Euler\" },\n+\n+    // org.apache.commons.math.geometry.Rotation\n+    { \"a {0}x{1} matrix cannot be a rotation matrix\",\n+      \"une matrice {0}x{1} ne peut pas \\u00e9tre une matrice de rotation\" },\n+    { \"the closest orthogonal matrix has a negative determinant {0}\",\n+      \"la matrice orthogonale la plus proche a un d\\u00e9terminant n\\u00e9gatif {0}\" },\n+    { \"unable to orthogonalize matrix in {0} iterations\",\n+      \"impossible de rendre la matrice orthogonale en {0} it\\u00e9rations\" },\n+\n+    // org.apache.commons.math.ode.AdaptiveStepsizeIntegrator\n+    { \"minimal step size ({0}) reached, integration needs {1}\",\n+      \"pas minimal ({0}) atteint, l''int\\u00e9gration n\\u00e9cessite {1}\" },\n+\n+    // org.apache.commons.math.ode.GraggBulirschStoerIntegrator,\n+    // org.apache.commons.math.ode.RungeKuttaFehlbergIntegrator,\n+    // org.apache.commons.math.ode.RungeKuttaIntegrator\n+    { \"dimensions mismatch: ODE problem has dimension {0},\"\n+    + \" state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\"\n+    + \" et le vecteur d''\\u00e9tat ({1})\" },\n+    { \"too small integration interval: length = {0}\",\n+      \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n+\n+    // org.apache.commons.math.optimization.DirectSearchOptimizer\n+    { \"none of the {0} start points lead to convergence\",\n+      \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  }\n+\n+  };\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Locale;\n+\n+/**\n+ * @version $Revision: 480442 $ $Date: 2006-11-29 08:21:22 +0100 (mer., 29 nov. 2006) $\n+ */\n+public class ConvergenceExceptionTest extends TestCase {\n+\n+    public void testConstructor(){\n+        ConvergenceException ex = new ConvergenceException();\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertNotNull(ex.getMessage(Locale.FRENCH));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+    public void testConstructorPatternArguments(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { new Integer(6), new Integer(4) };\n+        ConvergenceException ex = new ConvergenceException(pattern, arguments);\n+        assertNull(ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+    public void testConstructorCause(){\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        ConvergenceException ex = new ConvergenceException(cause);\n+        assertEquals(cause, ex.getCause());\n+    }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { new Integer(6), new Integer(4) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n \n package org.apache.commons.math;\n \n+import java.util.Locale;\n+\n import junit.framework.TestCase;\n \n /**\n         FunctionEvaluationException ex = new FunctionEvaluationException(0.0);\n         assertNull(ex.getCause());\n         assertNotNull(ex.getMessage());\n-        assertEquals(0.0, ex.getArgument(), 0);\n-    }\n-    \n-    public void testConstructorMessage(){\n-        String msg = \"message\";\n-        FunctionEvaluationException  ex = new FunctionEvaluationException(0.0, msg);\n-        assertNull(ex.getCause());\n-        assertTrue(ex.getMessage().startsWith(msg));\n         assertTrue(ex.getMessage().indexOf(\"0\") > 0);\n         assertEquals(0.0, ex.getArgument(), 0);\n     }\n     \n-    public void testConstructorMessageCause(){\n-        String outMsg = \"outer message\";\n+    public void testConstructorPatternArguments(){\n+        String pattern = \"Evaluation failed for argument = {0}\";\n+        Object[] arguments = { new Double(0.0) };\n+        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);\n+        assertNull(ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"Evaluation failed for argument = {0}\";\n+        Object[] arguments = { new Double(0.0) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n-        FunctionEvaluationException ex = new FunctionEvaluationException(0, outMsg, cause);\n-        assertTrue(ex.getMessage().startsWith(outMsg));\n-        assertTrue(ex.getMessage().indexOf(\"0\") > 0);\n+        FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);\n         assertEquals(cause, ex.getCause());\n-        assertEquals(0.0, ex.getArgument(), 0);\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n+\n }\n--- a/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n \n import junit.framework.TestCase;\n \n+import java.util.Locale;\n+\n /**\n  * @version $Revision$ $Date$\n  */\n public class MathConfigurationExceptionTest extends TestCase {\n-    /**\n-     * \n-     */\n+\n     public void testConstructor(){\n         MathConfigurationException ex = new MathConfigurationException();\n         assertNull(ex.getCause());\n         assertNull(ex.getMessage());\n+        assertNull(ex.getMessage(Locale.FRENCH));\n     }\n     \n-    /**\n-     * \n-     */\n-    public void testConstructorMessage(){\n-        String msg = \"message\";\n-        MathConfigurationException ex = new MathConfigurationException(msg);\n+    public void testConstructorPatternArguments(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { new Integer(6), new Integer(4) };\n+        MathConfigurationException ex = new MathConfigurationException(pattern, arguments);\n         assertNull(ex.getCause());\n-        assertEquals(msg, ex.getMessage());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n     \n-    /**\n-     * \n-     */\n-    public void testConstructorMessageCause(){\n-        String outMsg = \"outer message\";\n-        String inMsg = \"inner message\";\n-        Exception cause = new Exception(inMsg);\n-        MathConfigurationException ex = new MathConfigurationException(outMsg, cause);\n-        assertEquals(outMsg, ex.getMessage());\n-        assertEquals(cause, ex.getCause());\n-    }\n-    \n-    /**\n-     * \n-     */\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathConfigurationException ex = new MathConfigurationException(cause);\n         assertEquals(cause, ex.getCause());\n     }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { new Integer(6), new Integer(4) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathExceptionTest.java\n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n import java.io.PrintWriter;\n+import java.util.Locale;\n \n /**\n  * @version $Revision$ $Date$\n  */\n public class MathExceptionTest extends TestCase {\n-    /**\n-     * \n-     */\n+\n     public void testConstructor(){\n         MathException ex = new MathException();\n         assertNull(ex.getCause());\n         assertNull(ex.getMessage());\n+        assertNull(ex.getMessage(Locale.FRENCH));\n     }\n     \n-    /**\n-     * \n-     */\n-    public void testConstructorMessage(){\n-        String msg = \"message\";\n-        MathException ex = new MathException(msg);\n+    public void testConstructorPatternArguments(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { new Integer(6), new Integer(4) };\n+        MathException ex = new MathException(pattern, arguments);\n         assertNull(ex.getCause());\n-        assertEquals(msg, ex.getMessage());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n     \n-    /**\n-     * \n-     */\n-    public void testConstructorMessageCause(){\n-        String outMsg = \"outer message\";\n-        String inMsg = \"inner message\";\n-        Exception cause = new Exception(inMsg);\n-        MathException ex = new MathException(outMsg, cause);\n-        assertEquals(outMsg, ex.getMessage());\n-        assertEquals(cause, ex.getCause());\n-    }\n-    \n-    /**\n-     * \n-     */\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathException ex = new MathException(cause);\n         assertEquals(cause, ex.getCause());\n+    }\n+\n+    public void testConstructorPatternArgumentsCause(){\n+        String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n+        Object[] arguments = { new Integer(6), new Integer(4) };\n+        String inMsg = \"inner message\";\n+        Exception cause = new Exception(inMsg);\n+        MathException ex = new MathException(pattern, arguments, cause);\n+        assertEquals(cause, ex.getCause());\n+        assertEquals(pattern, ex.getPattern());\n+        assertEquals(arguments.length, ex.getArguments().length);\n+        for (int i = 0; i < arguments.length; ++i) {\n+            assertEquals(arguments[i], ex.getArguments()[i]);\n+        }\n+        assertFalse(pattern.equals(ex.getMessage()));\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n     \n     /**\n     public void testPrintStackTrace() {\n         String outMsg = \"outer message\";\n         String inMsg = \"inner message\";\n-        MathException cause = new MathConfigurationException(inMsg);\n-        MathException ex = new MathException(outMsg, cause);\n+        MathException cause = new MathConfigurationException(inMsg, new Object[0]);\n+        MathException ex = new MathException(outMsg, new Object[0], cause);\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         PrintStream ps = new PrintStream(baos);\n         ex.printStackTrace(ps);\n     public void testSerialization() {\n         String outMsg = \"outer message\";\n         String inMsg = \"inner message\";\n-        MathException cause = new MathConfigurationException(inMsg);\n-        MathException ex = new MathException(outMsg, cause);\n+        MathException cause = new MathConfigurationException(inMsg, new Object[0]);\n+        MathException ex = new MathException(outMsg, new Object[0], cause);\n         MathException image = (MathException) TestUtils.serializeAndRecover(ex);\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         PrintStream ps = new PrintStream(baos);\n-        PrintWriter pw = new PrintWriter(ps, true);\n         ex.printStackTrace(ps);\n         String stack = baos.toString();\n         \n         ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n         PrintStream ps2 = new PrintStream(baos2);\n-        PrintWriter pw2 = new PrintWriter(ps2, true);\n         image.printStackTrace(ps2);\n         String stack2 = baos2.toString();\n         ", "timestamp": 1171306464, "metainfo": ""}