{"sha": "814629453f583055f6540fba3599e8620dfca4a2", "log": "Initial Addition of StatUtils. Some methods need review, implementation and possibly debugging   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.stat;\n+\n+/**\n+ * StatUtils provides easy static implementations of common double[] based\n+ * statistical methods. These return a single result value or in some cases, as\n+ * identified in the javadoc for each method, Double.NaN.\n+ *\n+ * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n+ */\n+public class StatUtils {\n+\n+\t/**\n+     * The sum of the values that have been added to Univariate.\n+     * @param values Is a double[] containing the values\n+     * @return the sum of the values or Double.NaN if the array is empty\n+\t */\n+\tpublic static double sum(double[] values) {\n+\t\tdouble accum = 0.0;\n+\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\taccum += values[i];\n+\t\t}\n+\t\treturn accum;\n+\t}\n+\n+\t/**\n+     * Returns the sum of the squares of the available values.\n+     * @param values Is a double[] containing the values\n+     * @return the sum of the squared values or Double.NaN if the array is empty\n+\t */\n+\tpublic static double sumSq(double[] values) {\n+\t\tdouble accum = 0.0;\n+\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\taccum += Math.pow(values[i], 2.0);\n+\t\t}\n+\t\treturn accum;\n+\t}\n+\n+\t/**\n+     * Returns the <a href=http://www.xycoon.com/arithmetic_mean.htm>\n+     * arithmetic mean </a> of the available values \n+     * @param values Is a double[] containing the values\n+     * @return the mean of the values or Double.NaN if the array is empty\n+\t */\n+\tpublic static double mean(double[] values) {\n+\t\treturn sum(values) / values.length;\n+\t}\n+\n+    /**\n+     *      \n+     * @param values Is a double[] containing the values\n+     * @return the result, Double.NaN if no values for an empty array \n+     * or 0.0 for a single value set.  \n+     */\n+    public static double standardDeviation(double[] values) {\n+        double stdDev = Double.NaN;\n+        if (values.length != 0) {\n+            stdDev = Math.sqrt(variance(values));\n+        }\n+        return (stdDev);\n+    }\n+    \n+\t/**\n+     * Returns the variance of the available values.\n+     * @param values Is a double[] containing the values\n+     * @return the result, Double.NaN if no values for an empty array \n+     * or 0.0 for a single value set.  \n+\t */\n+\tpublic static double variance(double[] values) {\n+\t\tdouble variance = Double.NaN;\n+        \n+\t\tif (values.length == 1) {\n+\t\t\tvariance = 0;\n+\t\t} else if (values.length > 1) {\n+\t\t\tdouble mean = mean(values);\n+\t\t\tdouble accum = 0.0;\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\taccum += Math.pow((values[i] - mean), 2.0);\n+\t\t\t}\n+\t\t\tvariance = accum / (values.length - 1);\n+\t\t}\n+\t\treturn variance;\n+\t}\n+\n+    /**\n+     * Returns the skewness of a collection of values.  Skewness is a \n+     * measure of the assymetry of a given distribution. \n+     * @param values Is a double[] containing the values\n+     * @return the skewness of the values or Double.NaN if the array is empty\n+     */\n+    public double skewness(double[] values) {\n+        // Initialize the skewness\n+        double skewness = Double.NaN;\n+\n+        // Get the mean and the standard deviation\n+        double mean = mean(values);\n+        double stdDev = standardDeviation(values);\n+\n+        // Sum the cubes of the distance from the mean divided by the \n+        // standard deviation\n+        double accum = 0.0;\n+        for (int i = 0; i < values.length; i++) {\n+            accum += Math.pow((values[i] - mean) / stdDev, 3.0);\n+        }\n+\n+        // Get N\n+        double n = values.length;\n+\n+        // Calculate skewness\n+        skewness = (n / ((n - 1) * (n - 2))) * accum;\n+\n+        return skewness;\n+    }\n+\n+    /**\n+     * Returns the kurtosis for this collection of values. Kurtosis is a \n+     * measure of the \"peakedness\" of a distribution.\n+     * @param values Is a double[] containing the values\n+     * @return the kurtosis of the values or Double.NaN if the array is empty\n+     */\n+    public double kurtosis(double[] values) {\n+        // Initialize the kurtosis\n+        double kurtosis = Double.NaN;\n+\n+        // Get the mean and the standard deviation\n+        double mean = mean(values);\n+        double stdDev = standardDeviation(values);\n+\n+        // Sum the ^4 of the distance from the mean divided by the \n+        // standard deviation\n+        double accum = 0.0;\n+        for (int i = 0; i < values.length; i++) {\n+            accum += Math.pow((values[i] - mean) / stdDev, 4.0);\n+        }\n+\n+        // Get N\n+        double n = values.length;\n+\n+        double coefficientOne = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n+        double termTwo = ((3 * Math.pow(n - 1, 2.0)) \n+                           / ((n - 2) * (n - 3))); \n+        // Calculate kurtosis\n+        kurtosis = (coefficientOne * accum) - termTwo;\n+\n+        return kurtosis;\n+    }\n+    \n+\t/**\n+     * Returns the maximum of the available values\n+     * @param values Is a double[] containing the values\n+\t * @return the maximum of the values or Double.NaN if the array is empty\n+\t */\n+\tpublic static double max(double[] values) {\n+\t\tdouble max = Double.NaN;\n+\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tmax = values[i];\n+\t\t\t} else {\n+\t\t\t\tmax = Math.max(max, values[i]);\n+\t\t\t}\n+\t\t}\n+\t\treturn max;\n+\t}\n+\n+\t/**\n+     * Returns the minimum of the available values\n+     * @param values Is a double[] containing the values\n+\t * @return the minimum of the values or Double.NaN if the array is empty\n+\t */\n+\tpublic static double min(double[] values) {\n+\t\tdouble min = Double.NaN;\n+\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\tif (i == 0) {\n+\t\t\t\tmin = values[i];\n+\t\t\t} else {\n+\t\t\t\tmin = Math.min(min, values[i]);\n+\t\t\t}\n+\t\t}\n+\t\treturn min;\n+\t}\n+    \n+    /** \n+     * Returns the mode of the values that have been added.  The mode is\n+     * the element which occurs with the most frequency\n+     * @return the mode\n+     */\n+    public static double mode(){\n+        // Mode depends on a refactor Freq class\n+        String msg = \"mode() is not yet implemented\";\n+        throw new UnsupportedOperationException(msg);\n+    }\n+    \n+    /** \n+     * Returns the mode of the values that have been added.  The mode is\n+     * the element which occurs with the most frequency\n+     * @return the mode\n+     */\n+    public static double median(double[] values){\n+        // Mode depends on a refactor Freq class\n+        String msg = \"median() is not yet implemented\";\n+        throw new UnsupportedOperationException(msg);\n+    }\n+}", "timestamp": 1055890538, "metainfo": ""}