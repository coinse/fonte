{"sha": "b5e1c855deb58ee74b5d08907ddd489409c893c9", "log": "improved test coverage  ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/RotationOrderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.math.geometry.RotationOrder;\n+\n+import junit.framework.*;\n+\n+public class RotationOrderTest\n+  extends TestCase {\n+\n+  public RotationOrderTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testName() {\n+\n+    RotationOrder[] orders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX,\n+      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+    };\n+\n+    for (int i = 0; i < orders.length; ++i) {\n+      assertEquals(getFieldName(orders[i]), orders[i].toString());\n+    }\n+\n+  }\n+\n+  private String getFieldName(RotationOrder order) {\n+    try {\n+      Field[] fields = RotationOrder.class.getFields();\n+      for (int i = 0; i < fields.length; ++i) {\n+        if (fields[i].get(null) == order) {\n+          return fields[i].getName();\n+        }\n+      }\n+    } catch (IllegalAccessException iae) {\n+      // ignored\n+    }\n+    return \"unknown\";\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(RotationOrderTest.class);\n+  }\n+\n+}\n--- a/src/test/org/apache/commons/math/geometry/RotationTest.java\n+++ b/src/test/org/apache/commons/math/geometry/RotationTest.java\n     checkVector(r.getAxis(), Vector3D.plusJ);\n     checkAngle(r.getAngle(), Math.PI);\n \n+    checkVector(new Rotation().getAxis(), Vector3D.plusI);\n+\n+  }\n+\n+  public void testRevert() {\n+    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);\n+    Rotation reverted = r.revert();\n+    checkRotation(r.applyTo(reverted), 1, 0, 0, 0);\n+    checkRotation(reverted.applyTo(r), 1, 0, 0, 0);\n+    assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);\n+    assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);\n   }\n \n   public void testVectorOnePair() {\n     checkVector(r.applyTo(u.multiply(v.getNorm())), v.multiply(u.getNorm()));\n \n     checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);\n+\n+    try {\n+        new Rotation(u, new Vector3D());\n+        fail(\"an exception should have been thrown\");\n+      } catch (ArithmeticException e) {\n+      } catch (Exception e) {\n+        fail(\"unexpected exception\");\n+    }\n \n   }\n \n     }\n     checkAngle(r.getAngle(), Math.PI);\n \n+    double sqrt = Math.sqrt(2) / 2;\n+    r = new Rotation(Vector3D.plusI,  Vector3D.plusJ,\n+                     new Vector3D(0.5, 0.5,  sqrt),\n+                     new Vector3D(0.5, 0.5, -sqrt));\n+    checkRotation(r, sqrt, 0.5, 0.5, 0);\n+\n+    r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2));\n+    checkRotation(r, sqrt, -sqrt, 0, 0);\n+\n+    checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);\n+\n+    try {\n+        new Rotation(u1, u2, new Vector3D(), v2);\n+        fail(\"an exception should have been thrown\");\n+      } catch (ArithmeticException e) {\n+      } catch (Exception e) {\n+        fail(\"unexpected exception\");\n+    }\n+\n   }\n \n   public void testMatrix()\n     throws NotARotationMatrixException {\n+\n+    try {\n+      new Rotation(new double[][] {\n+                     { 0.0, 1.0, 0.0 },\n+                     { 1.0, 0.0, 0.0 }\n+                   }, 1.0e-7);\n+    } catch (NotARotationMatrixException nrme) {\n+      // expected behavior\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+\n+    try {\n+      new Rotation(new double[][] {\n+                     {  0.445888,  0.797184, -0.407040 },\n+                     {  0.821760, -0.184320,  0.539200 },\n+                     { -0.354816,  0.574912,  0.737280 }\n+                   }, 1.0e-7);\n+    } catch (NotARotationMatrixException nrme) {\n+      // expected behavior\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+\n+    try {\n+        new Rotation(new double[][] {\n+                       {  0.4,  0.8, -0.4 },\n+                       { -0.4,  0.6,  0.7 },\n+                       {  0.8, -0.2,  0.5 }\n+                     }, 1.0e-15);\n+      } catch (NotARotationMatrixException nrme) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"wrong exception caught: \" + e.getMessage());\n+      }\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 {  0.445888,  0.797184, -0.407040 },\n+                                 { -0.354816,  0.574912,  0.737280 },\n+                                 {  0.821760, -0.184320,  0.539200 }\n+                               }, 1.0e-10),\n+                  0.8, 0.288, 0.384, 0.36);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 {  0.539200,  0.737280,  0.407040 },\n+                                 {  0.184320, -0.574912,  0.797184 },\n+                                 {  0.821760, -0.354816, -0.445888 }\n+                              }, 1.0e-10),\n+                  0.36, 0.8, 0.288, 0.384);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 { -0.445888,  0.797184, -0.407040 },\n+                                 {  0.354816,  0.574912,  0.737280 },\n+                                 {  0.821760,  0.184320, -0.539200 }\n+                               }, 1.0e-10),\n+                  0.384, 0.36, 0.8, 0.288);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 { -0.539200,  0.737280,  0.407040 },\n+                                 { -0.184320, -0.574912,  0.797184 },\n+                                 {  0.821760,  0.354816,  0.445888 }\n+                               }, 1.0e-10),\n+                  0.288, 0.384, 0.36, 0.8);\n \n     double[][] m1 = { { 0.0, 1.0, 0.0 },\n                       { 0.0, 0.0, 1.0 },\n       RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n     };\n \n-    RotationOrder[] EulerOrders = {\n-      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n-      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n-    };\n-\n     for (int i = 0; i < CardanOrders.length; ++i) {\n       for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n         for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {\n           for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n-            Rotation r = new Rotation(CardanOrders[i],\n-                                      alpha1, alpha2, alpha3);\n+            Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3);\n             double[] angles = r.getAngles(CardanOrders[i]);\n             checkAngle(angles[0], alpha1);\n             checkAngle(angles[1], alpha2);\n         }\n       }\n     }\n+\n+    RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+          };\n \n     for (int i = 0; i < EulerOrders.length; ++i) {\n       for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n \n   }\n \n+  public void testSingularities()\n+    throws CardanEulerSingularityException {\n+\n+    RotationOrder[] CardanOrders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+    };\n+\n+    double[] singularCardanAngle = { Math.PI / 2, -Math.PI / 2 };\n+    for (int i = 0; i < CardanOrders.length; ++i) {\n+      for (int j = 0; j < singularCardanAngle.length; ++j) {\n+        Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);\n+        try {\n+          r.getAngles(CardanOrders[i]);\n+          fail(\"an exception should have been caught\");\n+        } catch (CardanEulerSingularityException cese) {\n+          // expected behavior\n+        } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+      }\n+    }\n+\n+    RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+          };\n+\n+    double[] singularEulerAngle = { 0, Math.PI };\n+    for (int i = 0; i < EulerOrders.length; ++i) {\n+      for (int j = 0; j < singularEulerAngle.length; ++j) {\n+        Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);\n+        try {\n+          r.getAngles(EulerOrders[i]);\n+          fail(\"an exception should have been caught\");\n+        } catch (CardanEulerSingularityException cese) {\n+          // expected behavior\n+        } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+      }\n+    }\n+\n+\n+  }\n+\n   public void testQuaternion() {\n+\n     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n     double n = 23.5;\n     Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),\n         }\n       }\n     }\n+\n+    r1 = new Rotation( 0.288,  0.384,  0.36,  0.8, false);\n+    checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3());\n+\n   }\n \n   public void testCompose() {\n     assertTrue(Math.abs(a1 - a2) < 1.0e-10);\n   }\n \n+  private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {\n+    Rotation reference = new Rotation(q0, q1, q2, q3, false);\n+    assertEquals(0, r.applyInverseTo(reference).getAngle(), 1.0e-12);\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(RotationTest.class);\n   }\n--- a/src/test/org/apache/commons/math/geometry/Vector3DTest.java\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DTest.java\n     super(name);\n   }\n \n+  public void testConstructors() {\n+      double r = Math.sqrt(2) /2;\n+      checkVector(new Vector3D(2, new Vector3D(Math.PI / 3, -Math.PI / 4)),\n+                  r, r * Math.sqrt(3), -2 * r);\n+      checkVector(new Vector3D(2, Vector3D.plusI,\n+                              -3, Vector3D.minusK),\n+                  2, 0, 3);\n+      checkVector(new Vector3D(2, Vector3D.plusI,\n+                               5, Vector3D.plusJ,\n+                              -3, Vector3D.minusK),\n+                  2, 5, 3);\n+      checkVector(new Vector3D(2, Vector3D.plusI,\n+                               5, Vector3D.plusJ,\n+                               5, Vector3D.minusJ,\n+                               -3, Vector3D.minusK),\n+                  2, 0, 3);\n+  }\n+\n   public void testCoordinates() {\n     Vector3D v = new Vector3D(1, 2, 3);\n     assertTrue(Math.abs(v.getX() - 1) < 1.0e-12);\n     Vector3D v1 = new Vector3D(1, 2, 3);\n     Vector3D v2 = new Vector3D(-3, -2, -1);\n     v1 = v1.subtract(v2);\n-    checkVector(v1, new Vector3D(4, 4, 4));\n+    checkVector(v1, 4, 4, 4);\n \n-    checkVector(v2.subtract(v1), new Vector3D(-7, -6, -5));\n+    checkVector(v2.subtract(v1), -7, -6, -5);\n+    checkVector(v2.subtract(3, v1), -15, -14, -13);\n \n   }\n \n     Vector3D v1 = new Vector3D(1, 2, 3);\n     Vector3D v2 = new Vector3D(-3, -2, -1);\n     v1 = v1.add(v2);\n-    checkVector(v1, new Vector3D(-2, 0, 2));\n+    checkVector(v1, -2, 0, 2);\n \n-    checkVector(v2.add(v1), new Vector3D(-5, -2, 1));\n+    checkVector(v2.add(v1), -5, -2, 1);\n+    checkVector(v2.add(3, v1), -9, -2, 5);\n \n   }\n \n   public void testScalarProduct() {\n     Vector3D v = new Vector3D(1, 2, 3);\n     v = v.multiply(3);\n-    checkVector(v, new Vector3D(3, 6, 9));\n+    checkVector(v, 3, 6, 9);\n \n-    checkVector(v.multiply(0.5), new Vector3D(1.5, 3, 4.5));\n+    checkVector(v.multiply(0.5), 1.5, 3, 4.5);\n \n   }\n \n     assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);\n \n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    checkVector(v3, new Vector3D(3, -10, -1));\n+    checkVector(v3, 3, -10, -1);\n \n     assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);\n     assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);\n \n   }\n \n-  private void checkVector(Vector3D v1, Vector3D v2) {\n-    assertTrue(v1.subtract(v2).getNorm() < 1.0e-12);\n+  public void testNormalize() {\n+    assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);\n+    try {\n+        new Vector3D().normalize();\n+        fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException ae) {\n+        // expected behavior\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+  }\n+\n+  public void testOrthogonal() {\n+      Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);\n+      assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);\n+      Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);\n+      assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);\n+      Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2);\n+      assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);\n+      try {\n+          new Vector3D(0, 0, 0).orthogonal();\n+          fail(\"an exception should have been thrown\");\n+      } catch (ArithmeticException ae) {\n+          // expected behavior\n+      } catch (Exception e) {\n+          fail(\"wrong exception caught: \" + e.getMessage());\n+      }\n+  }\n+\n+  public void testAngle() {\n+     assertEquals(0.22572612855273393616, \n+                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),\n+                  1.0e-12);\n+     assertEquals(7.98595620686106654517199e-8, \n+                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),\n+                  1.0e-12);\n+     assertEquals(3.14159257373023116985197793156, \n+                  Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),\n+                  1.0e-12);\n+     try {\n+         Vector3D.angle(new Vector3D(), Vector3D.plusI);\n+         fail(\"an exception should have been thrown\");\n+     } catch (ArithmeticException ae) {\n+         // expected behavior\n+     } catch (Exception e) {\n+         fail(\"wrong exception caught: \" + e.getMessage());\n+     }\n+  }\n+\n+  private void checkVector(Vector3D v, double x, double y, double z) {\n+      assertEquals(x, v.getX(), 1.0e-12);\n+      assertEquals(y, v.getY(), 1.0e-12);\n+      assertEquals(z, v.getZ(), 1.0e-12);\n   }\n   \n   public static Test suite() {", "timestamp": 1189435242, "metainfo": ""}