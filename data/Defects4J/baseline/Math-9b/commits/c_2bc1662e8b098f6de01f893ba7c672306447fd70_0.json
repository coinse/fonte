{"sha": "2bc1662e8b098f6de01f893ba7c672306447fd70", "log": "added fast cubic root computation JIRA: MATH-375  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n      */\n     private static final double EIGHTHES[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};\n \n+    /* Table of 2^((n+2)/3) */\n+    private static final double CBRTTWO[] = { 0.6299605249474366,\n+                                            0.7937005259840998, \n+                                            1.0, \n+                                            1.2599210498948732, \n+                                            1.5874010519681994 };\n+\n     // Initialize tables\n     static {\n         int i;\n      */\n     public static double sqrt(final double a) {\n         return Math.sqrt(a);\n-    }\n-\n-    /** Compute the cubic root of a number.\n-     * @param a number on which evaluation is done\n-     * @return cubic root of a\n-     */\n-    public static double cbrt(final double a) {\n-        return Math.cbrt(a);\n     }\n \n     /** Compute the hyperbolic cosine of a number.\n                 ya = aa + tmp - tmp;\n                 yb = aa - ya + ab;\n \n-                if (hiPrec != null) {\n-                    hiPrec[0] = ya;\n-                    hiPrec[1] = yb;\n-                }\n-\n                 return ya + yb;\n             }\n         }\n       return atan(ra, rb, x<0);\n     }\n \n+    /** Compute the cubic root of a number.\n+     * @param a number on which evaluation is done\n+     * @return cubic root of a\n+     */\n+    public static double cbrt(double x) {\n+      /* Convert input double to bits */\n+      long inbits = Double.doubleToLongBits(x);\n+      int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n+      boolean subnormal = false;\n+\n+      if (exponent == -1023) {\n+          if (x == 0) {\n+              return x;\n+          }\n+\n+          /* Subnormal, so normalize */\n+          subnormal = true;\n+          x *= 1.8014398509481984E16;  // 2^54\n+          inbits = Double.doubleToLongBits(x);\n+          exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n+      }\n+\n+      if (exponent == 1024) {\n+          // Nan or infinity.  Don't care which.\n+          return x;\n+      }\n+\n+      /* Divide the exponent by 3 */\n+      int exp3 = exponent / 3;\n+\n+      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n+      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | \n+                                          (long)(((exp3 + 1023) & 0x7ff)) << 52);\n+\n+      /* This will be a number between 1 and 2 */\n+      final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n+      \n+      /* Estimate the cube root of mant by polynomial */\n+      double est = -0.010714690733195933;\n+      est = est * mant + 0.0875862700108075;\n+      est = est * mant + -0.3058015757857271;\n+      est = est * mant + 0.7249995199969751;\n+      est = est * mant + 0.5039018405998233;\n+\n+      est *= CBRTTWO[exponent % 3 + 2];\n+\n+      // est should now be good to about 15 bits of precision.   Do 2 rounds of \n+      // Newton's method to get closer,  this should get us full double precision\n+      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n+      final double xs = x / (p2*p2*p2); \n+      est += (xs - est*est*est) / (3*est*est);\n+      est += (xs - est*est*est) / (3*est*est);\n+\n+      // Do one round of Newton's method in extended precision to get the last bit right.\n+      double temp = est * 1073741824.0;\n+      double ya = est + temp - temp;\n+      double yb = est - ya;\n+\n+      double za = ya * ya;\n+      double zb = ya * yb * 2.0 + yb * yb;\n+      temp = za * 1073741824.0;\n+      double temp2 = za + temp - temp;\n+      zb += (za - temp2);\n+      za = temp2;\n+\n+      zb = za * yb + ya * zb + zb * yb;\n+      za = za * ya;\n+\n+      double na = xs - za;\n+      double nb = -(na - xs + za);\n+      nb -= zb;\n+\n+      est += (na+nb)/(3*est*est);\n+\n+      /* Scale by a power of two, so this is exact. */\n+      est *= p2;\n+\n+      if (subnormal) {\n+          est *= 3.814697265625E-6;  // 2^-18\n+      }\n+\n+      return est;\n+    }\n+\n     /**\n      *  Convert degrees to radians, with error of less than 0.5 ULP\n      *  @param x angle in degrees\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n     }\n \n     @Test\n+    public void testCbrtAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i=0; i<10000; i++) {\n+            double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble(); \n+\n+            double tst = FastMath.cbrt(x);\n+            double ref = cbrt(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"cbrt() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    private Dfp cbrt(Dfp x) {\n+      boolean negative=false;\n+\n+      if (x.lessThan(field.getZero())) {\n+          negative = true;\n+          x = x.negate();\n+      }\n+\n+      Dfp y = DfpMath.pow(x, field.getOne().divide(3));\n+\n+      if (negative) {\n+          y = y.negate();\n+      }\n+\n+      return y;\n+    }\n+\n+    @Test\n     public void testToDegrees() {\n         double maxerrulp = 0.0;\n         for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n             x = 0;\n             time = System.currentTimeMillis();\n             for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.cbrt(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.cbrt \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n                 x += FastMath.cbrt(i / 1000000.0);\n             time = System.currentTimeMillis() - time;\n             System.out.println(\"FastMath.cbrt \" + time + \"\\t\" + x);", "timestamp": 1284224250, "metainfo": ""}