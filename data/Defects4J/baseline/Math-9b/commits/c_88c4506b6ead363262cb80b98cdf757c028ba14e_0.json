{"sha": "88c4506b6ead363262cb80b98cdf757c028ba14e", "log": "Added applyTo and applyInverseTo methods in the Rotation class that handle directly arrays instead of Vector3D instances.  Patch provided by Jan Kotek.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n \n   }\n \n+  /** Apply the rotation to a vector stored in an array.\n+   * @param in an array with three items which stores vector to rotate\n+   * @param out an array with three items to put result to (it can be the same\n+   * array as in)\n+   */\n+  public void applyTo(final double[] in, final double[] out) {\n+\n+      final double x = in[0];\n+      final double y = in[1];\n+      final double z = in[2];\n+\n+      final double s = q1 * x + q2 * y + q3 * z;\n+\n+      out[0] = 2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x;\n+      out[1] = 2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y;\n+      out[2] = 2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z;\n+\n+  }\n+\n   /** Apply the inverse of the rotation to a vector.\n    * @param u vector to apply the inverse of the rotation to\n    * @return a new vector which such that u is its image by the rotation\n     return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n                         2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n                         2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the inverse of the rotation to a vector stored in an array.\n+   * @param in an array with three items which stores vector to rotate\n+   * @param out an array with three items to put result to (it can be the same\n+   * array as in)\n+   */\n+  public void applyInverseTo(final double[] in, final double[] out) {\n+\n+      final double x = in[0];\n+      final double y = in[1];\n+      final double z = in[2];\n+\n+      final double s = q1 * x + q2 * y + q3 * z;\n+      final double m0 = -q0;\n+\n+      out[0] = 2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x;\n+      out[1] = 2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y;\n+      out[2] = 2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z;\n \n   }\n \n--- a/src/test/java/org/apache/commons/math/geometry/euclidean/threed/RotationTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threed/RotationTest.java\n   }\n \n   @Test\n+  public void testArray() {\n+\n+      Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+\n+      for (double x = -0.9; x < 0.9; x += 0.2) {\n+          for (double y = -0.9; y < 0.9; y += 0.2) {\n+              for (double z = -0.9; z < 0.9; z += 0.2) {\n+                  Vector3D u = new Vector3D(x, y, z);\n+                  Vector3D v = r.applyTo(u);\n+                  double[] inOut = new double[] { x, y, z };\n+                  r.applyTo(inOut, inOut);\n+                  Assert.assertEquals(v.getX(), inOut[0], 1.0e-10);\n+                  Assert.assertEquals(v.getY(), inOut[1], 1.0e-10);\n+                  Assert.assertEquals(v.getZ(), inOut[2], 1.0e-10);\n+                  r.applyInverseTo(inOut, inOut);\n+                  Assert.assertEquals(u.getX(), inOut[0], 1.0e-10);\n+                  Assert.assertEquals(u.getY(), inOut[1], 1.0e-10);\n+                  Assert.assertEquals(u.getZ(), inOut[2], 1.0e-10);\n+              }\n+          }\n+      }\n+\n+  }\n+\n+  @Test\n   public void testApplyInverseTo() {\n \n     Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);", "timestamp": 1320958974, "metainfo": ""}