{"sha": "fc502e010f685cb0bc5d125aaaae52890a16848a", "log": "MATH-849: new implementation of double Gamma.logGamma(double x) for x < 8.0. This greatly improves the accurarcy, from more than 130 ulps down to 3 ulps. Unit tests updated accordingly.    ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math3/special/Gamma.java\n package org.apache.commons.math3.special;\n \n import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.util.ContinuedFraction;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n+ * <p>\n  * This is a utility class that provides computation methods related to the\n- * Gamma family of functions.\n+ * &Gamma; (Gamma) family of functions.\n+ * </p>\n+ * <p>\n+ * Implementation of {@link #invGamma1pm1(double)} and\n+ * {@link #logGamma1p(double)} is based on the algorithms described in\n+ * <ul>\n+ * <li><a href=\"http://dx.doi.org/10.1145/22721.23109\">Didonato and Morris\n+ * (1986)</a>, <em>Computation of the Incomplete Gamma Function Ratios and\n+ *     their Inverse</em>, TOMS 12(4), 377-393,</li>\n+ * <li><a href=\"http://dx.doi.org/10.1145/131766.131776\">Didonato and Morris\n+ * (1992)</a>, <em>Algorithm 708: Significant Digit Computation of the\n+ *     Incomplete Beta Function Ratios</em>, TOMS 18(3), 360-373,</li>\n+ * </ul>\n+ * and implemented in the\n+ * <a href=\"http://www.dtic.mil/docs/citations/ADA476840\">NSWC Library of Mathematical Functions</a>,\n+ * available\n+ * <a href=\"http://www.ualberta.ca/CNS/RESEARCH/Software/NumericalNSWC/site.html\">here</a>.\n+ * This library is \"approved for public release\", and the\n+ * <a href=\"http://www.dtic.mil/dtic/pdf/announcements/CopyrightGuidance.pdf\">Copyright guidance</a>\n+ * indicates that unless otherwise stated in the code, all FORTRAN functions in\n+ * this library are license free. Since no such notice appears in the code these\n+ * functions can safely be ported to Commons-Math.\n+ * </p>\n  *\n  * @version $Id$\n  */\n     /** S limit. */\n     private static final double S_LIMIT = 1e-5;\n \n+    /*\n+     * Constants for the computation of double invGamma1pm1(double).\n+     * Copied from DGAM1 in the NSWC library.\n+     */\n+\n+    /** The constant {@code A0} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_A0 = .611609510448141581788E-08;\n+\n+    /** The constant {@code A1} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_A1 = .624730830116465516210E-08;\n+\n+    /** The constant {@code B1} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B1 = .203610414066806987300E+00;\n+\n+    /** The constant {@code B2} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B2 = .266205348428949217746E-01;\n+\n+    /** The constant {@code B3} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B3 = .493944979382446875238E-03;\n+\n+    /** The constant {@code B4} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B4 = -.851419432440314906588E-05;\n+\n+    /** The constant {@code B5} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B5 = -.643045481779353022248E-05;\n+\n+    /** The constant {@code B6} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B6 = .992641840672773722196E-06;\n+\n+    /** The constant {@code B7} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B7 = -.607761895722825260739E-07;\n+\n+    /** The constant {@code B8} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_B8 = .195755836614639731882E-09;\n+\n+    /** The constant {@code P0} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_P0 = .6116095104481415817861E-08;\n+\n+    /** The constant {@code P1} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_P1 = .6871674113067198736152E-08;\n+\n+    /** The constant {@code P2} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_P2 = .6820161668496170657918E-09;\n+\n+    /** The constant {@code P3} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_P3 = .4686843322948848031080E-10;\n+\n+    /** The constant {@code P4} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_P4 = .1572833027710446286995E-11;\n+\n+    /** The constant {@code P5} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_P5 = -.1249441572276366213222E-12;\n+\n+    /** The constant {@code P6} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_P6 = .4343529937408594255178E-14;\n+\n+    /** The constant {@code Q1} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_Q1 = .3056961078365221025009E+00;\n+\n+    /** The constant {@code Q2} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_Q2 = .5464213086042296536016E-01;\n+\n+    /** The constant {@code Q3} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_Q3 = .4956830093825887312020E-02;\n+\n+    /** The constant {@code Q4} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_Q4 = .2692369466186361192876E-03;\n+\n+    /** The constant {@code C} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C = -.422784335098467139393487909917598E+00;\n+\n+    /** The constant {@code C0} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C0 = .577215664901532860606512090082402E+00;\n+\n+    /** The constant {@code C1} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C1 = -.655878071520253881077019515145390E+00;\n+\n+    /** The constant {@code C2} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C2 = -.420026350340952355290039348754298E-01;\n+\n+    /** The constant {@code C3} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C3 = .166538611382291489501700795102105E+00;\n+\n+    /** The constant {@code C4} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C4 = -.421977345555443367482083012891874E-01;\n+\n+    /** The constant {@code C5} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C5 = -.962197152787697356211492167234820E-02;\n+\n+    /** The constant {@code C6} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C6 = .721894324666309954239501034044657E-02;\n+\n+    /** The constant {@code C7} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C7 = -.116516759185906511211397108401839E-02;\n+\n+    /** The constant {@code C8} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C8 = -.215241674114950972815729963053648E-03;\n+\n+    /** The constant {@code C9} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C9 = .128050282388116186153198626328164E-03;\n+\n+    /** The constant {@code C10} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C10 = -.201348547807882386556893914210218E-04;\n+\n+    /** The constant {@code C11} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C11 = -.125049348214267065734535947383309E-05;\n+\n+    /** The constant {@code C12} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C12 = .113302723198169588237412962033074E-05;\n+\n+    /** The constant {@code C13} defined in {@code DGAM1}. */\n+    private static final double INV_GAMMA1P_M1_C13 = -.205633841697760710345015413002057E-06;\n+\n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n     private Gamma() {}\n \n     /**\n-     * Returns the natural logarithm of the gamma function &#915;(x).\n-     *\n-     * The implementation of this method is based on:\n+     * <p>\n+     * Returns the value of log&nbsp;&Gamma;(x) for x&nbsp;&gt;&nbsp;0.\n+     * </p>\n+     * <p>\n+     * For x &lt; 8, the implementation is based on the double precision\n+     * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n+     * {@code DGAMLN}. For x &ge; 8, the implementation is based on\n+     * </p>\n      * <ul>\n-     * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">\n-     * Gamma Function</a>, equation (28).</li>\n+     * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma\n+     *     Function</a>, equation (28).</li>\n      * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n-     * Lanczos Approximation</a>, equations (1) through (5).</li>\n+     *     Lanczos Approximation</a>, equations (1) through (5).</li>\n      * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n-     * the computation of the convergent Lanczos complex Gamma approximation\n-     * </a></li>\n+     *     the computation of the convergent Lanczos complex Gamma\n+     *     approximation</a></li>\n      * </ul>\n      *\n-     * @param x Value.\n-     * @return log(&#915;(x))\n+     * @param x argument.\n+     * @return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\n+     * {@code x <= 0.0}.\n      */\n     public static double logGamma(double x) {\n         double ret;\n \n         if (Double.isNaN(x) || (x <= 0.0)) {\n             ret = Double.NaN;\n+        } else if (x < 0.5) {\n+            return logGamma1p(x) - FastMath.log(x);\n+        } else if (x <= 2.5) {\n+            return logGamma1p((x - 0.5) - 0.5);\n+        } else if (x < 8.0) {\n+            final int n = (int) FastMath.floor(x - 1.5);\n+            double prod = 1.0;\n+            for (int i = 1; i <= n; i++) {\n+                prod *= x - i;\n+            }\n+            return logGamma1p(x - (n + 1)) + FastMath.log(prod);\n         } else {\n             double sum = lanczos(x);\n             double tmp = x + LANCZOS_G + .5;\n         }\n         return sum + LANCZOS[0];\n     }\n+\n+    /**\n+     * Returns the value of 1 / &Gamma;(1 + x) - 1 for -0&#46;5 &le; x &le;\n+     * 1&#46;5. This implementation is based on the double precision\n+     * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n+     * {@code DGAM1}.\n+     *\n+     * @param x the argument\n+     * @return the value of {@code 1.0 / Gamma(1.0 + x) - 1.0}\n+     * @throws NumberIsTooSmallException if {@code x < -0.5}\n+     * @throws NumberIsTooLargeException if {@code x > 1.5}\n+     */\n+    public static double invGamma1pm1(final double x) {\n+\n+        if (x < -0.5) {\n+            throw new NumberIsTooSmallException(x, -0.5, true);\n+        }\n+        if (x > 1.5) {\n+            throw new NumberIsTooLargeException(x, 1.5, true);\n+        }\n+\n+        final double ret;\n+        final double t = x <= 0.5 ? x : (x - 0.5) - 0.5;\n+        if (t < 0.0) {\n+            final double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1;\n+            double b = INV_GAMMA1P_M1_B8;\n+            b = INV_GAMMA1P_M1_B7 + t * b;\n+            b = INV_GAMMA1P_M1_B6 + t * b;\n+            b = INV_GAMMA1P_M1_B5 + t * b;\n+            b = INV_GAMMA1P_M1_B4 + t * b;\n+            b = INV_GAMMA1P_M1_B3 + t * b;\n+            b = INV_GAMMA1P_M1_B2 + t * b;\n+            b = INV_GAMMA1P_M1_B1 + t * b;\n+            b = 1.0 + t * b;\n+\n+            double c = INV_GAMMA1P_M1_C13 + t * (a / b);\n+            c = INV_GAMMA1P_M1_C12 + t * c;\n+            c = INV_GAMMA1P_M1_C11 + t * c;\n+            c = INV_GAMMA1P_M1_C10 + t * c;\n+            c = INV_GAMMA1P_M1_C9 + t * c;\n+            c = INV_GAMMA1P_M1_C8 + t * c;\n+            c = INV_GAMMA1P_M1_C7 + t * c;\n+            c = INV_GAMMA1P_M1_C6 + t * c;\n+            c = INV_GAMMA1P_M1_C5 + t * c;\n+            c = INV_GAMMA1P_M1_C4 + t * c;\n+            c = INV_GAMMA1P_M1_C3 + t * c;\n+            c = INV_GAMMA1P_M1_C2 + t * c;\n+            c = INV_GAMMA1P_M1_C1 + t * c;\n+            c = INV_GAMMA1P_M1_C + t * c;\n+            if (x > 0.5) {\n+                ret = t * c / x;\n+            } else {\n+                ret = x * ((c + 0.5) + 0.5);\n+            }\n+        } else {\n+            double p = INV_GAMMA1P_M1_P6;\n+            p = INV_GAMMA1P_M1_P5 + t * p;\n+            p = INV_GAMMA1P_M1_P4 + t * p;\n+            p = INV_GAMMA1P_M1_P3 + t * p;\n+            p = INV_GAMMA1P_M1_P2 + t * p;\n+            p = INV_GAMMA1P_M1_P1 + t * p;\n+            p = INV_GAMMA1P_M1_P0 + t * p;\n+\n+            double q = INV_GAMMA1P_M1_Q4;\n+            q = INV_GAMMA1P_M1_Q3 + t * q;\n+            q = INV_GAMMA1P_M1_Q2 + t * q;\n+            q = INV_GAMMA1P_M1_Q1 + t * q;\n+            q = 1.0 + t * q;\n+\n+            double c = INV_GAMMA1P_M1_C13 + (p / q) * t;\n+            c = INV_GAMMA1P_M1_C12 + t * c;\n+            c = INV_GAMMA1P_M1_C11 + t * c;\n+            c = INV_GAMMA1P_M1_C10 + t * c;\n+            c = INV_GAMMA1P_M1_C9 + t * c;\n+            c = INV_GAMMA1P_M1_C8 + t * c;\n+            c = INV_GAMMA1P_M1_C7 + t * c;\n+            c = INV_GAMMA1P_M1_C6 + t * c;\n+            c = INV_GAMMA1P_M1_C5 + t * c;\n+            c = INV_GAMMA1P_M1_C4 + t * c;\n+            c = INV_GAMMA1P_M1_C3 + t * c;\n+            c = INV_GAMMA1P_M1_C2 + t * c;\n+            c = INV_GAMMA1P_M1_C1 + t * c;\n+            c = INV_GAMMA1P_M1_C0 + t * c;\n+\n+            if (x > 0.5) {\n+                ret = (t / x) * ((c - 0.5) - 0.5);\n+            } else {\n+                ret = x * c;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns the value of log &Gamma;(1 + x) for -0&#46;5 &le; x &le; 1&#46;5.\n+     * This implementation is based on the double precision implementation in\n+     * the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGMLN1}.\n+     *\n+     * @param x the argument\n+     * @return the value of {@code log(Gamma(1 + x))}\n+     * @throws NumberIsTooSmallException if {@code x < -0.5}\n+     * @throws NumberIsTooLargeException if {@code x > 1.5}\n+     */\n+    public static double logGamma1p(final double x) {\n+\n+        if (x < -0.5) {\n+            throw new NumberIsTooSmallException(x, -0.5, true);\n+        }\n+        if (x > 1.5) {\n+            throw new NumberIsTooLargeException(x, 1.5, true);\n+        }\n+\n+        return -FastMath.log1p(invGamma1pm1(x));\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/special/GammaTest.java\n+++ b/src/test/java/org/apache/commons/math3/special/GammaTest.java\n \n     @Test\n     public void testLogGamma() {\n-        final int ulps = 130;\n+        final int ulps = 3;\n         for (int i = 0; i < LOG_GAMMA_REF.length; i++) {\n             final double[] data = LOG_GAMMA_REF[i];\n             final double x = data[0];", "timestamp": 1346221221, "metainfo": ""}