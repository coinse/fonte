{"sha": "18823c8809d03d49ae7f1b77d4eb368fbeabc121", "log": "MATH-707 Class name change:   \"BaseAbstractSimpleBoundsScalarOptimizer\" -> \"BaseAbstractMultivariateSimpleBoundsOptimizer\"   \"BaseSimpleBoundsMultivariateRealOptimizer\" -> \"BaseMultivariateSimpleBoundsOptimizer\"   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateSimpleBoundsOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+\n+/**\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-FastMath. Users of the API are advised to base their code on\n+ * the following interfaces:\n+ * <ul>\n+ *  <li>{@link org.apache.commons.math.optimization.MultivariateRealOptimizer}</li>\n+ *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer}</li>\n+ * </ul>\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public interface BaseMultivariateSimpleBoundsOptimizer<FUNC extends MultivariateFunction>\n+    extends BaseMultivariateRealOptimizer<FUNC> {\n+    /**\n+     * Optimize an objective function.\n+     *\n+     * @param f Objective function.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n+     * @param startPoint Start point for optimization.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @param lowerBound Lower bound for each of the parameters.\n+     * @param upperBound Upper bound for each of the parameters.\n+     * @return the point/value pair giving the optimal value for objective\n+     * function.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array sizes are wrong.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * {@code f}, {@code goalType} or {@code startPoint} is {@code null}.\n+     * @throws org.apache.commons.math.exception.NumberIsTooSmallException if any\n+     * of the initial values is less than its lower bound.\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException if any\n+     * of the initial values is greater than its upper bound.\n+     */\n+    RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                double[] startPoint,\n+                                double[] lowerBound, double[] upperBound);\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n  * @since 3.0\n  */\n public class BOBYQAOptimizer\n-    extends BaseAbstractSimpleBoundsScalarOptimizer<MultivariateFunction>\n+    extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>\n     implements MultivariateRealOptimizer {\n     /** Minimum dimension of the problem: {@value} */\n     public static final int MINIMUM_PROBLEM_DIMENSION = 2;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.BaseMultivariateSimpleBoundsOptimizer;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.ConvergenceChecker;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions,\n+ * subject to simple bounds: The valid range of the parameters is an interval.\n+ * The interval can possibly be infinite (in one or both directions).\n+ * This base class handles the boiler-plate methods associated to thresholds\n+ * settings, iterations and evaluations counting.\n+ *\n+ * @param <FUNC> Type of the objective function to be optimized.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public abstract class BaseAbstractMultivariateSimpleBoundsOptimizer<FUNC extends MultivariateFunction>\n+    extends BaseAbstractMultivariateOptimizer<FUNC>\n+    implements BaseMultivariateRealOptimizer<FUNC>,\n+               BaseMultivariateSimpleBoundsOptimizer<FUNC> {\n+    /** Lower bounds. */\n+    private double[] lowerBound;\n+    /** Upper bounds. */\n+    private double[] upperBound;\n+\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence checker is set to a\n+     * {@link org.apache.commons.math.optimization.SimpleScalarValueChecker} and\n+     * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n+     *\n+     * @see BaseAbstractMultivariateOptimizer#BaseAbstractMultivariateOptimizer()\n+     */\n+    protected BaseAbstractMultivariateSimpleBoundsOptimizer() {}\n+\n+    /**\n+     * @param checker Convergence checker.\n+     */\n+    protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\n+        super(checker);\n+    }\n+\n+    /**\n+     * @return the lower bounds.\n+     */\n+    public double[] getLowerBound() {\n+        return lowerBound.clone();\n+    }\n+\n+    /**\n+     * @return the upper bounds.\n+     */\n+    public double[] getUpperBound() {\n+        return upperBound.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                       double[] startPoint) {\n+        return optimize(maxEval, f, goalType, startPoint, null, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                       double[] startPoint,\n+                                       double[] lower, double[] upper) {\n+        // Checks.\n+        final int dim = startPoint.length;\n+        if (lower != null) {\n+            if (lower.length != dim) {\n+                throw new DimensionMismatchException(lower.length, dim);\n+            }\n+            for (int i = 0; i < dim; i++) {\n+                final double v = startPoint[i];\n+                final double lo = lower[i];\n+                if (v < lo) {\n+                    throw new NumberIsTooSmallException(v, lo, true);\n+                }\n+            }\n+        }\n+        if (upper != null) {\n+            if (upper.length != dim) {\n+                throw new DimensionMismatchException(upper.length, dim);\n+            }\n+            for (int i = 0; i < dim; i++) {\n+                final double v = startPoint[i];\n+                final double hi = upper[i];\n+                if (v > hi) {\n+                    throw new NumberIsTooLargeException(v, hi, true);\n+                }\n+            }\n+        }\n+\n+        // Initialization.\n+        if (lower == null) {\n+            lowerBound = new double[dim];\n+            for (int i = 0; i < dim; i++) {\n+                lowerBound[i] = Double.NEGATIVE_INFINITY;\n+            }\n+        } else {\n+            lowerBound = lower.clone();\n+        }\n+        if (upper == null) {\n+            upperBound = new double[dim];\n+            for (int i = 0; i < dim; i++) {\n+                upperBound[i] = Double.POSITIVE_INFINITY;\n+            }\n+        } else {\n+            upperBound = upper.clone();\n+        }\n+\n+        // Base class method performs the non bound-specific initializations.\n+        return super.optimize(maxEval, f, goalType, startPoint);\n+    }\n+}", "timestamp": 1323430360, "metainfo": ""}