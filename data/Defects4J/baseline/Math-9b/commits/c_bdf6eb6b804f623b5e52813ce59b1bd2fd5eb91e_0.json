{"sha": "bdf6eb6b804f623b5e52813ce59b1bd2fd5eb91e", "log": "Merged PoissonDistribution and PoissonDistributionImpl (MATH-711). Merged TDistribution and TDistributionImpl (MATH-711). Merged WeibullDistribution and WeibullDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n      * distribution.\n      *\n      * @return the variance (possibly Double.POSITIVE_INFINITY as\n-     * for certain cases in {@link TDistributionImpl}) or\n+     * for certain cases in {@link TDistribution}) or\n      * Double.NaN if it's not defined\n      */\n     public double getNumericalVariance() {\n--- a/src/main/java/org/apache/commons/math/distribution/Distribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/Distribution.java\n      * distribution.\n      *\n      * @return the variance (possibly Double.POSITIVE_INFINITY as\n-     * for certain cases in {@link TDistributionImpl}) or\n+     * for certain cases in {@link TDistribution}) or\n      * Double.NaN if it's not defined\n      */\n     double getNumericalVariance();\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n \n /**\n- * Interface representing the Poisson Distribution.\n+ * Implementation of the Poisson distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/PoissonDistribution.html\">\n- * Poisson distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Poisson_distribution\">Poisson distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/PoissonDistribution.html\">Poisson distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface PoissonDistribution extends IntegerDistribution {\n+public class PoissonDistribution extends AbstractIntegerDistribution\n+    implements Serializable {\n+    /**\n+     * Default maximum number of iterations for cumulative probability calculations.\n+     * @since 2.1\n+     */\n+    public static final int DEFAULT_MAX_ITERATIONS = 10000000;\n+\n+    /**\n+     * Default convergence criterion.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_EPSILON = 1e-12;\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3349935121172596109L;\n+\n+    /** Distribution used to compute normal approximation. */\n+    private final NormalDistribution normal;\n+\n+    /** Mean of the distribution. */\n+    private final double mean;\n+\n+    /**\n+     * Maximum number of iterations for cumulative probability. Cumulative\n+     * probabilities are estimated using either Lanczos series approximation of\n+     * {@link Gamma#regularizedGammaP(double, double, double, int)}\n+     * or continued fraction approximation of\n+     * {@link Gamma#regularizedGammaQ(double, double, double, int)}.\n+     */\n+    private final int maxIterations;\n+\n+    /** Convergence criterion for cumulative probability. */\n+    private final double epsilon;\n+\n+    /**\n+     * Creates a new Poisson distribution with specified mean.\n+     *\n+     * @param p the Poisson mean\n+     * @throws NotStrictlyPositiveException if {@code p <= 0}.\n+     */\n+    public PoissonDistribution(double p) {\n+        this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n+    }\n+\n+    /**\n+     * Creates a new Poisson distribution with specified mean, convergence\n+     * criterion and maximum number of iterations.\n+     *\n+     * @param p Poisson mean.\n+     * @param epsilon Convergence criterion for cumulative probabilities.\n+     * @param maxIterations the maximum number of iterations for cumulative\n+     * probabilities.\n+     * @since 2.1\n+     */\n+    public PoissonDistribution(double p, double epsilon, int maxIterations) {\n+        if (p <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n+        }\n+        mean = p;\n+        normal = new NormalDistribution(p, FastMath.sqrt(p));\n+        this.epsilon = epsilon;\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /**\n+     * Creates a new Poisson distribution with the specified mean and\n+     * convergence criterion.\n+     *\n+     * @param p Poisson mean.\n+     * @param epsilon Convergence criterion for cumulative probabilities.\n+     * @since 2.1\n+     */\n+    public PoissonDistribution(double p, double epsilon) {\n+        this(p, epsilon, DEFAULT_MAX_ITERATIONS);\n+    }\n+\n+    /**\n+     * Creates a new Poisson distribution with the specified mean and maximum\n+     * number of iterations.\n+     *\n+     * @param p Poisson mean.\n+     * @param maxIterations Maximum number of iterations for cumulative\n+     * probabilities.\n+     * @since 2.1\n+     */\n+    public PoissonDistribution(double p, int maxIterations) {\n+        this(p, DEFAULT_EPSILON, maxIterations);\n+    }\n+\n     /**\n      * Get the mean for the distribution.\n      *\n      * @return the mean for the distribution.\n      */\n-    double getMean();\n-\n-    /**\n-     * Calculates the Poisson distribution function using a normal approximation.\n-     *\n-     * @param x the upper bound, inclusive\n-     * @return the distribution function value calculated using a normal approximation\n-     */\n-    double normalApproximateProbability(int x) ;\n+    public double getMean() {\n+        return mean;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double probability(int x) {\n+        double ret;\n+        if (x < 0 || x == Integer.MAX_VALUE) {\n+            ret = 0.0;\n+        } else if (x == 0) {\n+            ret = FastMath.exp(-mean);\n+        } else {\n+            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x)\n+                  - SaddlePointExpansion.getDeviancePart(x, mean))\n+                  / FastMath.sqrt(MathUtils.TWO_PI * x);\n+        }\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double cumulativeProbability(int x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        if (x == Integer.MAX_VALUE) {\n+            return 1;\n+        }\n+        return Gamma.regularizedGammaQ((double) x + 1, mean, epsilon,\n+                                       maxIterations);\n+    }\n+\n+    /**\n+     * Calculates the Poisson distribution function using a normal\n+     * approximation. The {@code N(mean, sqrt(mean))} distribution is used\n+     * to approximate the Poisson distribution. The computation uses\n+     * \"half-correction\" (evaluating the normal distribution function at\n+     * {@code x + 0.5}).\n+     *\n+     * @param x Upper bound, inclusive.\n+     * @return the distribution function value calculated using a normal\n+     * approximation.\n+     */\n+    public double normalApproximateProbability(int x)  {\n+        // calculate the probability using half-correction\n+        return normal.cumulativeProbability(x + 0.5);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description</strong>:\n+     * <ul>\n+     *  <li>For small means, uses simulation of a Poisson process\n+     *   using Uniform deviates, as described\n+     *   <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here</a>.\n+     *   The Poisson process (and hence value returned) is bounded by 1000 * mean.\n+     *  </li>\n+     *  <li>For large means, uses the rejection algorithm described in\n+     *   <quote>\n+     *    Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     *    <strong>Computing</strong> vol. 26 pp. 197-207.\n+     *   </quote>\n+     *  </li>\n+     * </ul>\n+     * </p>\n+     *\n+     * @return a random value.\n+     * @since 2.2\n+     */\n+    @Override\n+    public int sample()  {\n+        return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */    @Override\n+    protected int getDomainUpperBound(double p) {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the mean parameter.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is positive infinity,\n+     * regardless of the parameter values. There is no integer infinity,\n+     * so this method returns {@code Integer.MAX_VALUE} and\n+     * {@link #isSupportUpperBoundInclusive()} returns {@code true}.\n+     *\n+     * @return upper bound of the support (always {@code Integer.MAX_VALUE} for\n+     * positive infinity)\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code p}, the mean is {@code p}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code p}, the variance is {@code p}.\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        return getMean();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return true;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * Student's t-Distribution.\n+ * Implementation of Student's t-distribution.\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/Studentst-Distribution.html\">\n- * Student's t-Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Student&apos;s_t-distribution\">Student's t-distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/Studentst-Distribution.html\">Student's t-distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface TDistribution extends ContinuousDistribution {\n-    /**\n-     * Access the number of degrees of freedom.\n+public class TDistribution extends AbstractContinuousDistribution\n+    implements Serializable  {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5852615386664158222L;\n+    /** The degrees of freedom. */\n+    private final double degreesOfFreedom;\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a t distribution using the given degrees of freedom and the\n+     * specified inverse cumulative probability absolute accuracy.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}\n+     * @since 2.1\n+     */\n+    public TDistribution(double degreesOfFreedom, double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        if (degreesOfFreedom <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n+                                                   degreesOfFreedom);\n+        }\n+        this.degreesOfFreedom = degreesOfFreedom;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Create a t distribution using the given degrees of freedom.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}\n+     */\n+    public TDistribution(double degreesOfFreedom)\n+        throws NotStrictlyPositiveException {\n+        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Access the degrees of freedom.\n      *\n      * @return the degrees of freedom.\n      */\n-    double getDegreesOfFreedom();\n+    public double getDegreesOfFreedom() {\n+        return degreesOfFreedom;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        final double n = degreesOfFreedom;\n+        final double nPlus1Over2 = (n + 1) / 2;\n+        return FastMath.exp(Gamma.logGamma(nPlus1Over2)\n+                            - 0.5 * (FastMath.log(FastMath.PI)\n+                                     + FastMath.log(n))\n+                            - Gamma.logGamma(n/2)\n+                            - nPlus1Over2 * FastMath.log(1 + x * x /n));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x) {\n+        double ret;\n+        if (x == 0) {\n+            ret = 0.5;\n+        } else {\n+            double t =\n+                Beta.regularizedBeta(\n+                    degreesOfFreedom / (degreesOfFreedom + (x * x)),\n+                    0.5 * degreesOfFreedom,\n+                    0.5);\n+            if (x < 0.0) {\n+                ret = 0.5 * t;\n+            } else {\n+                ret = 1.0 - 0.5 * t;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code Double.NEGATIVE_INFINITY} when {@code p = 0}\n+     * and {@code Double.POSITIVE_INFINITY} when {@code p = 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) {\n+        if (p == 0) {\n+            return Double.NEGATIVE_INFINITY;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return -Double.MAX_VALUE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always negative infinity no matter the\n+     * parameters.\n+     *\n+     * @return lower bound of the support (always\n+     * {@code Double.NEGATIVE_INFINITY})\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n+     * parameters.\n+     *\n+     * @return upper bound of the support (always\n+     * {@code Double.POSITIVE_INFINITY})\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For degrees of freedom parameter {@code df}, the mean is\n+     * <ul>\n+     *  <li>if {@code df > 1} then {@code 0},</li>\n+     * <li>else undefined ({@code Double.NaN}).</li>\n+     * </ul>\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double df = getDegreesOfFreedom();\n+\n+        if (df > 1) {\n+            return 0;\n+        }\n+\n+        return Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For degrees of freedom parameter {@code df}, the variance is\n+     * <ul>\n+     *  <li>if {@code df > 2} then {@code df / (df - 2)},</li>\n+     *  <li>if {@code 1 < df <= 2} then positive infinity\n+     *  ({@code Double.POSITIVE_INFINITY}),</li>\n+     *  <li>else undefined ({@code Double.NaN}).</li>\n+     * </ul>\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double df = getDegreesOfFreedom();\n+\n+        if (df > 2) {\n+            return df / (df - 2);\n+        }\n+\n+        if (df > 1 && df <= 2) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+\n+        return Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n \n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * Weibull Distribution.  This interface defines the two parameter form of the\n- * distribution as defined by\n+ * Implementation of the Weibull distribution. This implementation uses the\n+ * two parameter form of the distribution defined by\n  * <a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n  * Weibull Distribution</a>, equations (1) and (2).\n  *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n- * Weibull Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n- * @since 1.1\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Weibull_distribution\">Weibull distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">Weibull distribution (MathWorld)</a>\n+ * @since 1.1 (changed to concrete class in 3.0)\n  * @version $Id$\n  */\n-public interface WeibullDistribution extends ContinuousDistribution {\n-    /**\n-     * Access the shape parameter.\n-     *\n-     * @return the shape parameter.\n-     */\n-    double getShape();\n-\n-    /**\n-     * Access the scale parameter.\n-     *\n-     * @return the scale parameter.\n-     */\n-    double getScale();\n+public class WeibullDistribution extends AbstractContinuousDistribution\n+    implements Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+    /** The shape parameter. */\n+    private final double shape;\n+    /** The scale parameter. */\n+    private final double scale;\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a Weibull distribution with the given shape and scale and a\n+     * location equal to zero.\n+     *\n+     * @param alpha Shape parameter.\n+     * @param beta Scale parameter.\n+     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n+     * {@code beta <= 0}.\n+     */\n+    public WeibullDistribution(double alpha, double beta)\n+        throws NotStrictlyPositiveException {\n+        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a Weibull distribution with the given shape, scale and inverse\n+     * cumulative probability accuracy and a location equal to zero.\n+     *\n+     * @param alpha Shape parameter.\n+     * @param beta Scale parameter.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n+     * {@code beta <= 0}.\n+     * @since 2.1\n+     */\n+    public WeibullDistribution(double alpha, double beta,\n+                                   double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        if (alpha <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE,\n+                                                   alpha);\n+        }\n+        if (beta <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE,\n+                                                   beta);\n+        }\n+        scale = beta;\n+        shape = alpha;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x) {\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            ret = 1.0 - FastMath.exp(-FastMath.pow(x / scale, shape));\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Access the shape parameter, {@code alpha}.\n+     *\n+     * @return the shape parameter, {@code alpha}.\n+     */\n+    public double getShape() {\n+        return shape;\n+    }\n+\n+    /**\n+     * Access the scale parameter, {@code beta}.\n+     *\n+     * @return the scale parameter, {@code beta}.\n+     */\n+    public double getScale() {\n+        return scale;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+\n+        final double xscale = x / scale;\n+        final double xscalepow = FastMath.pow(xscale, shape - 1);\n+\n+        /*\n+         * FastMath.pow(x / scale, shape) =\n+         * FastMath.pow(xscale, shape) =\n+         * FastMath.pow(xscale, shape - 1) * xscale\n+         */\n+        final double xscalepowshape = xscalepow * xscale;\n+\n+        return (shape / scale) * xscalepow * FastMath.exp(-xscalepowshape);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code 0} when {@code p == 0} and\n+     * {@code Double.POSITIVE_INFINITY} when {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) {\n+        double ret;\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0.0, 1.0);\n+        } else if (p == 0) {\n+            ret = 0.0;\n+        } else  if (p == 1) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);\n+        }\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /** {@inheritDoc} */    @Override\n+    protected double getInitialDomain(double p) {\n+        // use median\n+        return FastMath.pow(scale * FastMath.log(2.0), 1.0 / shape);\n+    }\n+\n+    /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy.\n+     * @since 2.1\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always\n+     * {@code Double.POSITIVE_INFINITY})\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The mean is {@code scale * Gamma(1 + (1 / shape))}, where {@code Gamma()}\n+     * is the Gamma-function.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double sh = getShape();\n+        final double sc = getScale();\n+\n+        return sc * FastMath.exp(Gamma.logGamma(1 + (1 / sh)));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The variance is {@code scale^2 * Gamma(1 + (2 / shape)) - mean^2}\n+     * where {@code Gamma()} is the Gamma-function.\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double sh = getShape();\n+        final double sc = getScale();\n+        final double mn = getNumericalMean();\n+\n+        return (sc * sc) *\n+            FastMath.exp(Gamma.logGamma(1 + (2 / sh))) -\n+            (mn * mn);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.HypergeometricDistribution;\n import org.apache.commons.math.distribution.IntegerDistribution;\n import org.apache.commons.math.distribution.PascalDistribution;\n-import org.apache.commons.math.distribution.TDistributionImpl;\n-import org.apache.commons.math.distribution.WeibullDistributionImpl;\n+import org.apache.commons.math.distribution.TDistribution;\n+import org.apache.commons.math.distribution.WeibullDistribution;\n import org.apache.commons.math.distribution.ZipfDistributionImpl;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n     }\n \n     /**\n-     * Generates a random value from the {@link TDistributionImpl T Distribution}.\n+     * Generates a random value from the {@link TDistribution T Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public double nextT(double df) {\n-        return nextInversionDeviate(new TDistributionImpl(df));\n-    }\n-\n-    /**\n-     * Generates a random value from the {@link WeibullDistributionImpl Weibull Distribution}.\n+        return nextInversionDeviate(new TDistribution(df));\n+    }\n+\n+    /**\n+     * Generates a random value from the {@link WeibullDistribution Weibull Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public double nextWeibull(double shape, double scale) {\n-        return nextInversionDeviate(new WeibullDistributionImpl(shape, scale));\n+        return nextInversionDeviate(new WeibullDistribution(shape, scale));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.distribution.TDistribution;\n-import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n      * @throws MathException if an error occurs estimating probabilities\n      */\n     public RealMatrix getCorrelationPValues() throws MathException {\n-        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n+        TDistribution tDistribution = new TDistribution(nObs - 2);\n         int nVars = correlationMatrix.getColumnDimension();\n         double[][] out = new double[nVars][nVars];\n         for (int i = 0; i < nVars; i++) {\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.distribution.TDistribution;\n-import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.StatUtils;\n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n /**\n  * Implements t-test statistics defined in the {@link TTest} interface.\n  * <p>\n- * Uses commons-math {@link org.apache.commons.math.distribution.TDistributionImpl}\n+ * Uses commons-math {@link org.apache.commons.math.distribution.TDistribution}\n  * implementation to estimate exact p-values.</p>\n  *\n  * @version $Id$\n     protected double tTest(double m, double mu, double v, double n)\n         throws MathException {\n         double t = FastMath.abs(t(m, mu, v, n));\n-        TDistribution distribution = new TDistributionImpl(n - 1);\n+        TDistribution distribution = new TDistribution(n - 1);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n \n         double t = FastMath.abs(t(m1, m2, v1, v2, n1, n2));\n         double degreesOfFreedom = 0;\n         degreesOfFreedom = df(v1, v2, n1, n2);\n-        TDistribution distribution = new TDistributionImpl(degreesOfFreedom);\n+        TDistribution distribution = new TDistribution(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n \n         throws MathException {\n         double t = FastMath.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));\n         double degreesOfFreedom = n1 + n2 - 2;\n-        TDistribution distribution = new TDistributionImpl(degreesOfFreedom);\n+        TDistribution distribution = new TDistribution(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.distribution.TDistribution;\n-import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n             ybar = y;\n         } else {\n             if( hasIntercept ){\n-                final double fact1 = 1.0 + (double) n;\n-                final double fact2 = ((double) n) / (1.0 + (double) n);\n+                final double fact1 = 1.0 + n;\n+                final double fact2 = (n) / (1.0 + n);\n                 final double dx = x - xbar;\n                 final double dy = y - ybar;\n                 sumXX += dx * dx * fact2;\n     public void removeData(final double x,final double y) {\n         if (n > 0) {\n             if (hasIntercept) {\n-                final double fact1 = (double) n - 1.0;\n-                final double fact2 = ((double) n) / ((double) n - 1.0);\n+                final double fact1 = n - 1.0;\n+                final double fact2 = (n) / (n - 1.0);\n                 final double dx = x - xbar;\n                 final double dy = y - ybar;\n                 sumXX -= dx * dx * fact2;\n                 xbar -= dx / fact1;\n                 ybar -= dy / fact1;\n             } else {\n-                final double fact1 = (double) n - 1.0;\n+                final double fact1 = n - 1.0;\n                 sumXX -= x * x;\n                 sumYY -= y * y;\n                 sumXY -= x * y;\n             return Double.NaN;\n         }\n         return FastMath.sqrt(\n-            getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));\n+            getMeanSquareError() * ((1d / n) + (xbar * xbar) / sumXX));\n     }\n \n     /**\n             throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,\n                                           alpha, 0, 1);\n         }\n-        TDistribution distribution = new TDistributionImpl(n - 2);\n+        TDistribution distribution = new TDistribution(n - 2);\n         return getSlopeStdErr() *\n             distribution.inverseCumulativeProbability(1d - alpha / 2d);\n     }\n      * @throws MathException if the significance level can not be computed.\n      */\n     public double getSignificance() throws MathException {\n-        TDistribution distribution = new TDistributionImpl(n - 2);\n+        TDistribution distribution = new TDistribution(n - 2);\n         return 2d * (1.0 - distribution.cumulativeProbability(\n                     FastMath.abs(getSlope()) / getSlopeStdErr()));\n     }\n           if( FastMath.abs( sumXX ) > Precision.SAFE_MIN ){\n               final double[] params = new double[]{ getIntercept(), getSlope() };\n               final double mse = getMeanSquareError();\n-              final double _syy = sumYY + sumY * sumY / ((double) n);\n+              final double _syy = sumYY + sumY * sumY / (n);\n               final double[] vcv = new double[]{\n-                mse * (xbar *xbar /sumXX + 1.0 / ((double) n)),\n+                mse * (xbar *xbar /sumXX + 1.0 / (n)),\n                 -xbar*mse/sumXX,\n                 mse/sumXX };\n               return new RegressionResults(\n                       params, new double[][]{vcv}, true, n, 2,\n                       sumY, _syy, getSumSquaredErrors(),true,false);\n           }else{\n-              final double[] params = new double[]{ sumY/((double) n), Double.NaN };\n+              final double[] params = new double[]{ sumY/(n), Double.NaN };\n               //final double mse = getMeanSquareError();\n               final double[] vcv = new double[]{\n-                ybar / ((double) n - 1.0),\n+                ybar / (n - 1.0),\n                 Double.NaN,\n                 Double.NaN };\n               return new RegressionResults(\n                 if( variablesToInclude[0] != 1 && variablesToInclude[0] != 0 ){\n                      throw new OutOfRangeException( variablesToInclude[0],0,1 );\n                 }\n-                final double _mean = sumY * sumY / ((double) n);\n+                final double _mean = sumY * sumY / (n);\n                 final double _syy = sumYY + _mean;\n                 if( variablesToInclude[0] == 0 ){\n                     //just the mean\n-                    final double[] vcv = new double[]{ sumYY/((double)((n-1)*n)) };\n+                    final double[] vcv = new double[]{ sumYY/(((n-1)*n)) };\n                     final double[] params = new double[]{ ybar };\n                     return new RegressionResults(\n                       params, new double[][]{vcv}, true, n, 1,\n \n                 }else if( variablesToInclude[0] == 1){\n                     //final double _syy = sumYY + sumY * sumY / ((double) n);\n-                    final double _sxx = sumXX + sumX * sumX / ((double) n);\n-                    final double _sxy = sumXY + sumX * sumY / ((double) n);\n+                    final double _sxx = sumXX + sumX * sumX / (n);\n+                    final double _sxy = sumXY + sumX * sumY / (n);\n                     final double _sse = FastMath.max(0d, _syy - _sxy * _sxy / _sxx);\n-                    final double _mse = _sse/((double)(n-1));\n+                    final double _mse = _sse/((n-1));\n                     if( !Double.isNaN(_sxx) ){\n                         final double[] vcv = new double[]{ _mse / _sxx };\n                         final double[] params = new double[]{ _sxy/_sxx };\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n      */\n     @Override\n     public IntegerDistribution makeDistribution() {\n-        return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);\n+        return new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);\n     }\n \n     /**\n      */\n     @Test\n     public void testNormalApproximateProbability() throws Exception {\n-        PoissonDistribution dist = new PoissonDistributionImpl(100);\n+        PoissonDistribution dist = new PoissonDistribution(100);\n         double result = dist.normalApproximateProbability(110)\n                 - dist.normalApproximateProbability(89);\n         Assert.assertEquals(0.706281887248, result, 1E-10);\n \n-        dist = new PoissonDistributionImpl(10000);\n+        dist = new PoissonDistribution(10000);\n         result = dist.normalApproximateProbability(10200)\n         - dist.normalApproximateProbability(9899);\n         Assert.assertEquals(0.820070051552, result, 1E-10);\n      */\n     @Test\n     public void testDegenerateInverseCumulativeProbability() throws Exception {\n-        PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);\n+        PoissonDistribution dist = new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);\n         Assert.assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));\n         Assert.assertEquals(-1, dist.inverseCumulativeProbability(0d));\n     }\n \n     @Test(expected=NotStrictlyPositiveException.class)\n     public void testNegativeMean() {\n-        new PoissonDistributionImpl(-1);\n+        new PoissonDistribution(-1);\n     }\n \n     @Test\n     public void testMean() {\n-        PoissonDistribution dist = new PoissonDistributionImpl(10.0);\n+        PoissonDistribution dist = new PoissonDistribution(10.0);\n         Assert.assertEquals(10.0, dist.getMean(), 0.0);\n     }\n \n     public void testLargeMeanCumulativeProbability() {\n         double mean = 1.0;\n         while (mean <= 10000000.0) {\n-            PoissonDistribution dist = new PoissonDistributionImpl(mean);\n+            PoissonDistribution dist = new PoissonDistribution(mean);\n \n             double x = mean * 2.0;\n             double dx = x / 10.0;\n     @Test\n     public void testCumulativeProbabilitySpecial() throws Exception {\n         PoissonDistribution dist;\n-        dist = new PoissonDistributionImpl(9120);\n+        dist = new PoissonDistribution(9120);\n         checkProbability(dist, 9075);\n         checkProbability(dist, 9102);\n-        dist = new PoissonDistributionImpl(5058);\n+        dist = new PoissonDistribution(5058);\n         checkProbability(dist, 5044);\n-        dist = new PoissonDistributionImpl(6986);\n+        dist = new PoissonDistribution(6986);\n         checkProbability(dist, 6950);\n     }\n \n     public void testLargeMeanInverseCumulativeProbability() throws Exception {\n         double mean = 1.0;\n         while (mean <= 100000.0) { // Extended test value: 1E7.  Reduced to limit run time.\n-            PoissonDistribution dist = new PoissonDistributionImpl(mean);\n+            PoissonDistribution dist = new PoissonDistribution(mean);\n             double p = 0.1;\n             double dp = p;\n             while (p < .99) {\n     public void testMoments() {\n         final double tol = 1e-9;\n         PoissonDistribution dist;\n-        \n-        dist = new PoissonDistributionImpl(1);\n+\n+        dist = new PoissonDistribution(1);\n         Assert.assertEquals(dist.getNumericalMean(), 1, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 1, tol); \n-        \n-        dist = new PoissonDistributionImpl(11.23);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1, tol);\n+\n+        dist = new PoissonDistribution(11.23);\n         Assert.assertEquals(dist.getNumericalMean(), 11.23, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 11.23, tol);\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/TDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public TDistribution makeDistribution() {\n-        return new TDistributionImpl(5.0);\n+        return new TDistribution(5.0);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n      */\n     @Test\n     public void testCumulativeProbabilityAgainstStackOverflow() throws Exception {\n-        TDistributionImpl td = new TDistributionImpl(5.);\n+        TDistribution td = new TDistribution(5.);\n         td.cumulativeProbability(.1);\n         td.cumulativeProbability(.01);\n     }\n \n     @Test\n     public void testSmallDf() throws Exception {\n-        setDistribution(new TDistributionImpl(1d));\n+        setDistribution(new TDistribution(1d));\n         // quantiles computed using R version 2.9.2\n         setCumulativeTestPoints(new double[] {-318.308838986, -31.8205159538, -12.7062047362,\n                 -6.31375151468, -3.07768353718, 318.308838986, 31.8205159538, 12.7062047362,\n \n     @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions() {\n-        new TDistributionImpl(0);\n+        new TDistribution(0);\n     }\n-    \n+\n     @Test\n     public void testMoments() {\n         final double tol = 1e-9;\n         TDistribution dist;\n-        \n-        dist = new TDistributionImpl(1);\n+\n+        dist = new TDistribution(1);\n         Assert.assertTrue(Double.isNaN(dist.getNumericalMean()));\n         Assert.assertTrue(Double.isNaN(dist.getNumericalVariance()));\n-        \n-        dist = new TDistributionImpl(1.5);\n+\n+        dist = new TDistribution(1.5);\n         Assert.assertEquals(dist.getNumericalMean(), 0, tol);\n         Assert.assertTrue(Double.isInfinite(dist.getNumericalVariance()));\n-        \n-        dist = new TDistributionImpl(5);\n+\n+        dist = new TDistribution(5);\n         Assert.assertEquals(dist.getNumericalMean(), 0, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol);        \n+        Assert.assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol);\n     }\n \n     /*\n         return;\n     }\n     private double[] makeNistResults(double[] args, int df){\n-        TDistribution td =  new TDistributionImpl(df);\n+        TDistribution td =  new TDistribution(df);\n         double[] res  = new double[ args.length ];\n         for( int i = 0 ; i < res.length ; i++){\n             res[i] = 1.0 - td.cumulativeProbability(args[i]);\n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public WeibullDistribution makeDistribution() {\n-        return new WeibullDistributionImpl(1.2, 2.1);\n+        return new WeibullDistribution(1.2, 2.1);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n \n     @Test\n     public void testAlpha() {\n-        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);\n+        WeibullDistribution dist = new WeibullDistribution(1, 2);\n         Assert.assertEquals(1, dist.getShape(), 0);\n         try {\n-            dist = new WeibullDistributionImpl(0, 2);\n+            dist = new WeibullDistribution(0, 2);\n             Assert.fail(\"NotStrictlyPositiveException expected\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n \n     @Test\n     public void testBeta() {\n-        WeibullDistribution dist = new WeibullDistributionImpl(1, 2);\n+        WeibullDistribution dist = new WeibullDistribution(1, 2);\n         Assert.assertEquals(2, dist.getScale(), 0);\n         try {\n-            dist = new WeibullDistributionImpl(1, 0);\n+            dist = new WeibullDistribution(1, 0);\n             Assert.fail(\"NotStrictlyPositiveException expected\");\n         } catch (NotStrictlyPositiveException e) {\n             // Expected.\n     public void testMoments() {\n         final double tol = 1e-9;\n         WeibullDistribution dist;\n-        \n-        dist = new WeibullDistributionImpl(2.5, 3.5);\n+\n+        dist = new WeibullDistribution(2.5, 3.5);\n         // In R: 3.5*gamma(1+(1/2.5)) (or emperically: mean(rweibull(10000, 2.5, 3.5)))\n         Assert.assertEquals(dist.getNumericalMean(), 3.5 * FastMath.exp(Gamma.logGamma(1 + (1 / 2.5))), tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) * \n+        Assert.assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) *\n                 FastMath.exp(Gamma.logGamma(1 + (2 / 2.5))) -\n-                (dist.getNumericalMean() * dist.getNumericalMean()), tol); \n-        \n-        dist = new WeibullDistributionImpl(10.4, 2.222);\n+                (dist.getNumericalMean() * dist.getNumericalMean()), tol);\n+\n+        dist = new WeibullDistribution(10.4, 2.222);\n         Assert.assertEquals(dist.getNumericalMean(), 2.222 * FastMath.exp(Gamma.logGamma(1 + (1 / 10.4))), tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) * \n+        Assert.assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) *\n                 FastMath.exp(Gamma.logGamma(1 + (2 / 10.4))) -\n                 (dist.getNumericalMean() * dist.getNumericalMean()), tol);\n     }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.PascalDistribution;\n import org.apache.commons.math.distribution.PascalDistributionTest;\n import org.apache.commons.math.distribution.PoissonDistribution;\n-import org.apache.commons.math.distribution.PoissonDistributionImpl;\n-import org.apache.commons.math.distribution.TDistributionImpl;\n-import org.apache.commons.math.distribution.WeibullDistributionImpl;\n+import org.apache.commons.math.distribution.PoissonDistribution;\n+import org.apache.commons.math.distribution.TDistribution;\n+import org.apache.commons.math.distribution.WeibullDistribution;\n import org.apache.commons.math.distribution.ZipfDistributionImpl;\n import org.apache.commons.math.distribution.ZipfDistributionTest;\n import org.apache.commons.math.stat.Frequency;\n          *  Start with upper and lower tail bins.\n          *  Lower bin = [0, lower); Upper bin = [upper, +inf).\n          */\n-        PoissonDistribution poissonDistribution = new PoissonDistributionImpl(mean);\n+        PoissonDistribution poissonDistribution = new PoissonDistribution(mean);\n         int lower = 1;\n         while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n             lower++;\n     public void testNextGamma() throws Exception {\n         double[] quartiles;\n         long[] counts;\n-        \n+\n         // Tests shape > 1, one case in the rejection sampling\n         quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(4, 2));\n         counts = new long[4];\n             TestUtils.updateCounts(value, counts, quartiles);\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n-        \n-        // Tests shape <= 1, another case in the rejection sampling        \n+\n+        // Tests shape <= 1, another case in the rejection sampling\n         quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(0.3, 3));\n         counts = new long[4];\n         randomData.reSeed(1000);\n \n     @Test\n     public void testNextT() throws Exception {\n-        double[] quartiles = TestUtils.getDistributionQuartiles(new TDistributionImpl(10));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new TDistribution(10));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n \n     @Test\n     public void testNextWeibull() throws Exception {\n-        double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistribution(1.2, 2.1));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n--- a/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.distribution.TDistribution;\n-import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.util.FastMath;\n          fillUpper(rPMatrix, 0d);\n          TestUtils.assertEquals(\"correlation p values\", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);\n     }\n-    \n+\n     /**\n      * Test p-value near 0. JIRA: MATH-371\n      */\n          * Post fix, p-values diminish smoothly, vanishing at dimension = 127.\n          * Tested value is ~1E-303.\n          */\n-        int dimension = 120; \n+        int dimension = 120;\n         double[][] data = new double[dimension][2];\n         for (int i = 0; i < dimension; i++) {\n             data[i][0] = i;\n         PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);\n         Assert.assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0);\n     }\n-    \n+\n \n     /**\n      * Constant column\n      */\n     @Test\n     public void testStdErrorConsistency() throws Exception {\n-        TDistribution tDistribution = new TDistributionImpl(45);\n+        TDistribution tDistribution = new TDistribution(45);\n         RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n         RealMatrix rValues = corrInstance.getCorrelationMatrix();", "timestamp": 1322313807, "metainfo": ""}