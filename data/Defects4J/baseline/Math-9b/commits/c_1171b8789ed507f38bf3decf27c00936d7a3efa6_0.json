{"sha": "1171b8789ed507f38bf3decf27c00936d7a3efa6", "log": "added DenseFieldMatrix  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/DenseFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Cache-friendly implementation of FieldMatrix using a flat arrays to store\n+ * square blocks of the matrix.\n+ * <p>\n+ * This implementation is specially designed to be cache-friendly. Square blocks are\n+ * stored as small arrays and allow efficient traversal of data both in row major direction\n+ * and columns major direction, one block at a time. This greatly increases performances\n+ * for algorithms that use crossed directions loops like multiplication or transposition.\n+ * </p>\n+ * <p>\n+ * The size of square blocks is a static parameter. It may be tuned according to the cache\n+ * size of the target computer processor. As a rule of thumbs, it should be the largest\n+ * value that allows three blocks to be simultaneously cached (this is necessary for example\n+ * for matrix multiplication). The default value is to use 36x36 blocks.\n+ * </p>\n+ * <p>\n+ * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks\n+ * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square\n+ * blocks are flattened in row major order in single dimension arrays which are therefore\n+ * {@link #BLOCK_SIZE}<sup>2</sup> elements long for regular blocks. The blocks are themselves\n+ * organized in row major order.\n+ * </p>\n+ * <p>\n+ * As an example, for a block size of 36x36, a 100x60 matrix would be stored in 6 blocks.\n+ * Block 0 would be a Field[1296] array holding the upper left 36x36 square, block 1 would be\n+ * a Field[1296] array holding the upper center 36x36 square, block 2 would be a Field[1008]\n+ * array holding the upper right 36x28 rectangle, block 3 would be a Field[864] array holding\n+ * the lower left 24x36 rectangle, block 4 would be a Field[864] array holding the lower center\n+ * 24x36 rectangle and block 5 would be a Field[672] array holding the lower right 24x28\n+ * rectangle.\n+ * </p>\n+ * <p>\n+ * The layout complexity overhead versus simple mapping of matrices to java\n+ * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads\n+ * to up to 3-fold improvements for matrices of moderate to large size.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DenseFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -4602336630143123183L;\n+\n+    /** Block size. */\n+    public static final int BLOCK_SIZE = 36;\n+\n+    /** Blocks of matrix entries. */\n+    private final T blocks[][];\n+\n+    /** Number of rows of the matrix. */\n+    private final int rows;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columns;\n+\n+    /** Number of block rows of the matrix. */\n+    private final int blockRows;\n+\n+    /** Number of block columns of the matrix. */\n+    private final int blockColumns;\n+\n+    /**\n+     * Create a new matrix with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public DenseFieldMatrix(final Field<T> field, final int rows, final int columns)\n+        throws IllegalArgumentException {\n+\n+        super(field, rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // allocate storage blocks, taking care of smaller ones at right and bottom\n+        blocks = createBlocksLayout(field, rows, columns);\n+\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from raw layout data.\n+     * <p>The input array <em>must</em> already be in raw layout.</p>\n+     * <p>Calling this constructor is equivalent to call:\n+     * <pre>matrix = new DenseFieldMatrix<T>(getField(), rawData.length, rawData[0].length,\n+     *                                   toBlocksLayout(rawData), false);</pre>\n+     * </p>\n+     * @param rawData data for new matrix, in raw layout\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #DenseFieldMatrix(int, int, T[][], boolean)\n+     */\n+    public DenseFieldMatrix(final T[][] rawData)\n+        throws IllegalArgumentException {\n+        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from block layout data.\n+     * <p>The input array <em>must</em> already be in blocks layout.</p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @param blockData data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #createBlocksLayout(int, int)\n+     * @see #toBlocksLayout(T[][])\n+     * @see #DenseFieldMatrix(T[][])\n+     */\n+    public DenseFieldMatrix(final int rows, final int columns,\n+                           final T[][] blockData, final boolean copyArray)\n+        throws IllegalArgumentException {\n+\n+        super(extractField(blockData), rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        if (copyArray) {\n+            // allocate storage blocks, taking care of smaller ones at right and bottom\n+            blocks = buildArray(getField(), blockRows * blockColumns, -1);\n+        } else {\n+            // reference existing array\n+            blocks = blockData;\n+        }\n+\n+        int index = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n+                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"wrong array shape (block length = {0}, expected {1})\",\n+                            blockData[index].length, iHeight * blockWidth(jBlock));\n+                }\n+                if (copyArray) {\n+                    blocks[index] = blockData[index].clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a data array from raw layout to blocks layout.\n+     * <p>\n+     * Raw layout is the straightforward layout where element at row i and\n+     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n+     * is the layout used in {@link DenseFieldMatrix} instances, where the matrix\n+     * is split in square blocks (except at right and bottom side where blocks may\n+     * be rectangular to fit matrix size) and each block is stored in a flattened\n+     * one-dimensional array.\n+     * </p>\n+     * <p>\n+     * This method creates an array in blocks layout from an input array in raw layout.\n+     * It can be used to provide the array argument of the {@link\n+     * DenseFieldMatrix#DenseFieldMatrix(int, int, T[][], boolean)} constructor.\n+     * </p>\n+     * @param rawData data array in raw layout\n+     * @return a new data array containing the same entries but in blocks layout\n+     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n+     *  (not all rows have the same length)\n+     * @see #createBlocksLayout(int, int)\n+     * @see #DenseFieldMatrix(int, int, T[][], boolean)\n+     */\n+    public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData)\n+        throws IllegalArgumentException {\n+\n+        final int rows         = rawData.length;\n+        final int columns      = rawData[0].length;\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // safety checks\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int length = rawData[i].length;\n+            if (length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        columns, length); \n+            }\n+        }\n+\n+        // convert array\n+        final Field<T> field = extractField(rawData);\n+        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+\n+                // allocate new block\n+                final T[] block = buildArray(field, iHeight * jWidth);\n+                blocks[blockIndex] = block;\n+\n+                // copy data\n+                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n+                }\n+\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /**\n+     * Create a data array in blocks layout.\n+     * <p>\n+     * This method can be used to create the array argument of the {@link\n+     * DenseFieldMatrix#DenseFieldMatrix(int, int, T[][], boolean)} constructor.\n+     * </p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @return a new data array in blocks layout\n+     * @see #toBlocksLayout(T[][])\n+     * @see #DenseFieldMatrix(int, int, T[][], boolean)\n+     */\n+    public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field,\n+                                                                       final int rows, final int columns) {\n+\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+                blocks[blockIndex] = buildArray(field, iHeight * jWidth);\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new DenseFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+\n+        // create an empty matrix\n+        DenseFieldMatrix<T> copied = new DenseFieldMatrix<T>(getField(), rows, columns);\n+\n+        // copy the blocks\n+        for (int i = 0; i < blocks.length; ++i) {\n+            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n+        }\n+\n+        return copied;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> add(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((DenseFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkAdditionCompatible(m);\n+\n+            final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, columns);\n+\n+            // perform addition block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform addition on the current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+                    final T[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k].add(m.getEntry(p, q));\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public DenseFieldMatrix<T> add(final DenseFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform addition block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            final T[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].add(mBlock[k]);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((DenseFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkSubtractionCompatible(m);\n+\n+            final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, columns);\n+\n+            // perform subtraction block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform subtraction on the current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+                    final T[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k].subtract(m.getEntry(p, q));\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public DenseFieldMatrix<T> subtract(final DenseFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            final T[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].subtract(mBlock[k]);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarAdd(final T d)\n+        throws IllegalArgumentException {\n+\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].add(d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarMultiply(final T d)\n+        throws IllegalArgumentException {\n+\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].multiply(d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((DenseFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkMultiplicationCompatible(m);\n+\n+            final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, m.getColumnDimension());\n+            final T zero = getField().getZero();\n+\n+            // perform multiplication block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+\n+                    // select current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+\n+                    // perform multiplication on current block\n+                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                        final int kWidth      = blockWidth(kBlock);\n+                        final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                        final int rStart      = kBlock * BLOCK_SIZE;\n+                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                            final int lStart = (p - pStart) * kWidth;\n+                            final int lEnd   = lStart + kWidth;\n+                            for (int q = qStart; q < qEnd; ++q) {\n+                                T sum = zero;\n+                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                    sum = sum.add(tBlock[l].multiply(m.getEntry(r, q)));\n+                                }\n+                                outBlock[k] = outBlock[k].add(sum);\n+                                ++k;\n+                            }\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public DenseFieldMatrix<T> multiply(DenseFieldMatrix<T> m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, m.columns);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+                final int jWidth2 = jWidth  + jWidth;\n+                final int jWidth3 = jWidth2 + jWidth;\n+                final int jWidth4 = jWidth3 + jWidth;\n+\n+                // select current block\n+                final T[] outBlock = out.blocks[blockIndex];\n+\n+                // perform multiplication on current block\n+                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                    final int kWidth = blockWidth(kBlock);\n+                    final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                    final T[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        final int lStart = (p - pStart) * kWidth;\n+                        final int lEnd   = lStart + kWidth;\n+                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n+                            T sum = zero;\n+                            int l = lStart;\n+                            int n = nStart;\n+                            while (l < lEnd - 3) {\n+                                sum = sum.\n+                                      add(tBlock[l].multiply(mBlock[n])).\n+                                      add(tBlock[l + 1].multiply(mBlock[n + jWidth])).\n+                                      add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).\n+                                      add(tBlock[l + 3].multiply(mBlock[n + jWidth3]));\n+                                l += 4;\n+                                n += jWidth4;\n+                            }\n+                            while (l < lEnd) {\n+                                sum = sum.add(tBlock[l++].multiply(mBlock[n]));\n+                                n += jWidth;\n+                            }\n+                            outBlock[k] = outBlock[k].add(sum);\n+                            ++k;\n+                        }\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[][] getData() {\n+\n+        final T[][] data = buildArray(getField(), getRowDimension(), getColumnDimension());\n+        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n+\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            int regularPos   = 0;\n+            int lastPos      = 0;\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final T[] dataP = data[p];\n+                int blockIndex = iBlock * blockColumns;\n+                int dataPos    = 0;\n+                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n+                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n+                    dataPos += BLOCK_SIZE;\n+                }\n+                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n+                regularPos += BLOCK_SIZE;\n+                lastPos    += lastColumns;\n+            }\n+        }\n+\n+        return data;\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+\n+        // create the output matrix\n+        final DenseFieldMatrix<T> out =\n+            new DenseFieldMatrix<T>(getField(), endRow - startRow + 1, endColumn - startColumn + 1);\n+\n+        // compute blocks shifts\n+        final int blockStartRow    = startRow    / BLOCK_SIZE;\n+        final int rowsShift        = startRow    % BLOCK_SIZE;\n+        final int blockStartColumn = startColumn / BLOCK_SIZE;\n+        final int columnsShift     = startColumn % BLOCK_SIZE;\n+\n+        // perform extraction block-wise, to ensure good cache behavior\n+        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+            final int iHeight = out.blockHeight(iBlock);\n+            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+\n+                // handle one block of the output matrix\n+                final int      outIndex = iBlock * out.blockColumns + jBlock;\n+                final T[] outBlock = out.blocks[outIndex];\n+                final int      index    = pBlock * blockColumns + qBlock;\n+                final int      width    = blockWidth(qBlock);\n+\n+                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n+                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;\n+                if (heightExcess > 0) {\n+                    // the submatrix block spans on two blocks rows from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n+                                      0, heightExcess,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                    }\n+                } else {\n+                    // the submatrix block spans on one block row from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                    }\n+               }\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /**\n+     * Copy a part of a block into another one\n+     * <p>This method can be called only when the specified part fits in both\n+     * blocks, no verification is done here.</p>\n+     * @param srcBlock source block\n+     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param srcStartRow start row in the source block\n+     * @param srcEndRow end row (exclusive) in the source block\n+     * @param srcStartColumn start column in the source block\n+     * @param srcEndColumn end column (exclusive) in the source block\n+     * @param dstBlock destination block\n+     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param dstStartRow start row in the destination block\n+     * @param dstStartColumn start column in the destination block\n+     */\n+    private void copyBlockPart(final T[] srcBlock, final int srcWidth,\n+                               final int srcStartRow, final int srcEndRow,\n+                               final int srcStartColumn, final int srcEndColumn,\n+                               final T[] dstBlock, final int dstWidth,\n+                               final int dstStartRow, final int dstStartColumn) {\n+        final int length = srcEndColumn - srcStartColumn;\n+        int srcPos = srcStartRow * srcWidth + srcStartColumn;\n+        int dstPos = dstStartRow * dstWidth + dstStartColumn;\n+        for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {\n+            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n+            srcPos += srcWidth;\n+            dstPos += dstWidth;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        final int refLength = subMatrix[0].length;\n+        if (refLength < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n+        }\n+        final int endRow    = row + subMatrix.length - 1;\n+        final int endColumn = column + refLength - 1;\n+        checkSubMatrixIndex(row, endRow, column, endColumn);\n+        for (final T[] subRow : subMatrix) {\n+            if (subRow.length != refLength) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        refLength, subRow.length); \n+            }\n+        }\n+\n+        // compute blocks bounds\n+        final int blockStartRow    = row / BLOCK_SIZE;\n+        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockStartColumn = column / BLOCK_SIZE;\n+        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n+            final int iHeight  = blockHeight(iBlock);\n+            final int firstRow = iBlock * BLOCK_SIZE;\n+            final int iStart   = Math.max(row,    firstRow);\n+            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+\n+            for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n+                final int jWidth      = blockWidth(jBlock);\n+                final int firstColumn = jBlock * BLOCK_SIZE;\n+                final int jStart      = Math.max(column,    firstColumn);\n+                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jLength     = jEnd - jStart;\n+\n+                // handle one block, row by row\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int i = iStart; i < iEnd; ++i) {\n+                    System.arraycopy(subMatrix[i - row], jStart - column,\n+                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n+                                     jLength);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), 1, columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        T[] outBlock = out.blocks[outBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = outBlock.length - outIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n+                outBlock = out.blocks[++outBlockIndex];\n+                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n+                outIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n+                outIndex += jWidth;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRowMatrix(row, (DenseFieldMatrix<T>) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setRowMatrix(row, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param matrix row matrix (must have one row and the same number of columns\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance row\n+     */\n+    public void setRowMatrix(final int row, final DenseFieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow   = row - iBlock * BLOCK_SIZE;\n+        int mBlockIndex  = 0;\n+        int mIndex       = 0;\n+        T[] mBlock  = matrix.blocks[mBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = mBlock.length - mIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n+                mBlock = matrix.blocks[++mBlockIndex];\n+                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n+                mIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n+                mIndex += jWidth;\n+           }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, 1);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        T[] outBlock = out.blocks[outBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (outIndex >= outBlock.length) {\n+                    outBlock = out.blocks[++outBlockIndex];\n+                    outIndex = 0;\n+                }\n+                outBlock[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumnMatrix(column, (DenseFieldMatrix<T>) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setColumnMatrix(column, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param matrix column matrix (must have one column and the same number of rows\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance column\n+     */\n+    void setColumnMatrix(final int column, final DenseFieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int mBlockIndex = 0;\n+        int mIndex      = 0;\n+        T[] mBlock = matrix.blocks[mBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (mIndex >= mBlock.length) {\n+                    mBlock = matrix.blocks[++mBlockIndex];\n+                    mIndex = 0;\n+                }\n+                block[i * jWidth + jColumn] = mBlock[mIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldVector<T> getRowVector(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final T[] outData = buildArray(getField(), columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return new FieldVectorImpl<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowVector(final int row, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRow(row, ((FieldVectorImpl<T>) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setRowVector(row, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldVector<T> getColumnVector(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final T[] outData = buildArray(getField(), rows);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                outData[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return new FieldVectorImpl<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnVector(final int column, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumn(column, ((FieldVectorImpl<T>) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setColumnVector(column, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final T[] out = buildArray(getField(), columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRow(final int row, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final T[] out = buildArray(getField(), rows);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                out[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumn(final int column, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                block[i * jWidth + jColumn] = array[outIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            return blocks[iBlock * blockColumns + jBlock][k];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+            blockIJ[k] = blockIJ[k].add(increment);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+            blockIJ[k] = blockIJ[k].multiply(factor);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), nCols, nRows);\n+\n+        // perform transpose block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n+            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n+\n+                // transpose current block\n+                final T[] outBlock = out.blocks[blockIndex];\n+                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n+                final int      pStart   = iBlock * BLOCK_SIZE;\n+                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      qStart   = jBlock * BLOCK_SIZE;\n+                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    final int lInc = pEnd - pStart;\n+                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n+                        outBlock[k++] = tBlock[l];\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rows;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columns;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != columns) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, columns);\n+        }\n+        final T[] out = buildArray(getField(), rows);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                final T[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      qStart = jBlock * BLOCK_SIZE;\n+                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    T sum = zero;\n+                    int q = qStart;\n+                    while (q < qEnd - 3) {\n+                        sum = sum.\n+                              add(block[k].multiply(v[q])).\n+                              add(block[k + 1].multiply(v[q + 1])).\n+                              add(block[k + 2].multiply(v[q + 2])).\n+                              add(block[k + 3].multiply(v[q + 3]));\n+                        k += 4;\n+                        q += 4;\n+                    }\n+                    while (q < qEnd) {\n+                        sum = sum.add(block[k++].multiply(v[q++]));\n+                    }\n+                    out[p] = out[p].add(sum);\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != rows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, rows);\n+        }\n+        final T[] out = buildArray(getField(), columns);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth  = blockWidth(jBlock);\n+            final int jWidth2 = jWidth  + jWidth;\n+            final int jWidth3 = jWidth2 + jWidth;\n+            final int jWidth4 = jWidth3 + jWidth;\n+            final int qStart = jBlock * BLOCK_SIZE;\n+            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final T[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      pStart = iBlock * BLOCK_SIZE;\n+                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                for (int q = qStart; q < qEnd; ++q) {\n+                    int k = q - qStart;\n+                    T sum = zero;\n+                    int p = pStart;\n+                    while (p < pEnd - 3) {\n+                        sum = sum.\n+                              add(block[k].multiply(v[p])).\n+                              add(block[k + jWidth].multiply(v[p + 1])).\n+                              add(block[k + jWidth2].multiply(v[p + 2])).\n+                              add(block[k + jWidth3].multiply(v[p + 3]));\n+                        k += jWidth4;\n+                        p += 4;\n+                    }\n+                    while (p < pEnd) {\n+                        sum = sum.add(block[k].multiply(v[p++]));\n+                        k += jWidth;\n+                    }\n+                    out[q] = out[q].add(sum);\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final T[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final T[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Get the height of a block.\n+     * @param blockRow row index (in block sense) of the block\n+     * @return height (number of rows) of the block\n+     */\n+    private int blockHeight(final int blockRow) {\n+        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+    /**\n+     * Get the width of a block.\n+     * @param blockColumn column index (in block sense) of the block\n+     * @return width (number of columns) of the block\n+     */\n+    private int blockWidth(final int blockColumn) {\n+        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixUtils.java\n \n package org.apache.commons.math.linear;\n \n+import java.lang.reflect.Array;\n import java.math.BigDecimal;\n import java.util.Arrays;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n \n /**\n  * A collection of static methods that operate on or return matrices.\n     }\n \n     /**\n+     * Returns a {@link FieldMatrix} with specified dimensions.\n+     * <p>The matrix elements are all set to field.getZero().</p>\n+     * @param field field to which the matrix elements belong\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @return  FieldMatrix with specified dimensions\n+     * @see #createFieldMatrix(FieldElement[][])\n+     * @since 2.0\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field,\n+                                                                               final int rows,\n+                                                                               final int columns) {\n+        return new DenseFieldMatrix<T>(field, rows, columns);\n+    }\n+\n+    /**\n      * Returns a {@link RealMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n      * \n      */\n     public static RealMatrix createRealMatrix(double[][] data) {\n         return new DenseRealMatrix(data);\n+    }\n+\n+    /**\n+     * Returns a {@link FieldMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     * </p>\n+     * @param data input array\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createFieldMatrix(Field, int, int)\n+     * @since 2.0\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) {\n+        return new DenseFieldMatrix<T>(data);\n     }\n \n     /**\n         }\n         return m;\n     }\n+\n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     * @throws IllegalArgumentException if dimension is not positive\n+     * @since 2.0\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n+        final T zero = field.getZero();\n+        final T one  = field.getOne();\n+        final T[][] d = (T[][]) Array.newInstance(zero.getClass(), dimension, dimension);\n+        for (int row = 0; row < dimension; row++) {\n+            final T[] dRow = d[row];\n+            Arrays.fill(dRow, zero);\n+            dRow[row] = one;\n+        }\n+        return new FieldMatrixImpl<T>(d, false);\n+    }\n+\n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     * @throws IllegalArgumentException if dimension is not positive\n+     * @since 1.1\n+     * @deprecated since 2.0, replaced by {@link #createFieldIdentityMatrix(Field, int)}\n+     */\n+    @Deprecated\n+    public static BigMatrix createBigIdentityMatrix(int dimension) {\n+        final BigDecimal[][] d = new BigDecimal[dimension][dimension];\n+        for (int row = 0; row < dimension; row++) {\n+            final BigDecimal[] dRow = d[row];\n+            Arrays.fill(dRow, BigMatrixImpl.ZERO);\n+            dRow[row] = BigMatrixImpl.ONE;\n+        }\n+        return new BigMatrixImpl(d, false);\n+    }\n     \n     /**\n      * Returns a diagonal matrix with specified elements.\n     }\n     \n     /**\n+     * Returns a diagonal matrix with specified elements.\n+     *\n+     * @param diagonal diagonal elements of the matrix (the array elements\n+     * will be copied)\n+     * @return diagonal matrix\n+     * @since 2.0\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createFieldDiagonalMatrix(final T[] diagonal) {\n+        final FieldMatrix<T> m =\n+            createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n+        for (int i = 0; i < diagonal.length; ++i) {\n+            m.setEntry(i, i, diagonal[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n      * Returns a {@link BigMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n      * \n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if data is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n     public static BigMatrix createBigMatrix(double[][] data) {\n         return new BigMatrixImpl(data);\n     }\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if data is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n     public static BigMatrix createBigMatrix(BigDecimal[][] data) {\n         return new BigMatrixImpl(data);\n     }\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if <code>data</code> is null\n      * @see #createRealMatrix(double[][])\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n     public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {\n         return new BigMatrixImpl(data, copyArray);\n     }\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if data is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n     public static BigMatrix createBigMatrix(String[][] data) {\n         return new BigMatrixImpl(data);\n     }\n      */\n     public static RealVector createRealVector(double[] data) {\n         return new RealVectorImpl(data, true);\n+    }\n+    \n+    /**\n+     * Creates a {@link FieldVector} using the data from the input array. \n+     * \n+     * @param data the input data\n+     * @return a data.length FieldVector\n+     * @throws IllegalArgumentException if <code>data</code> is empty\n+     * @throws NullPointerException if <code>data</code>is null\n+     */\n+    public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n+        return new FieldVectorImpl<T>(data, true);\n     }\n     \n     /**\n     }\n     \n     /**\n+     * Creates a row {@link FieldMatrix} using the data from the input\n+     * array. \n+     * \n+     * @param rowData the input row data\n+     * @return a 1 x rowData.length FieldMatrix\n+     * @throws IllegalArgumentException if <code>rowData</code> is empty\n+     * @throws NullPointerException if <code>rowData</code>is null\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createRowFieldMatrix(final T[] rowData) {\n+        final int nCols = rowData.length;\n+        final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            m.setEntry(0, i, rowData[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n      * Creates a row {@link BigMatrix} using the data from the input\n      * array. \n      * \n      * @return a 1 x rowData.length BigMatrix\n      * @throws IllegalArgumentException if <code>rowData</code> is empty\n      * @throws NullPointerException if <code>rowData</code>is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n     public static BigMatrix createRowBigMatrix(double[] rowData) {\n         final int nCols = rowData.length;\n         final BigDecimal[][] data = new BigDecimal[1][nCols];\n      * @return a 1 x rowData.length BigMatrix\n      * @throws IllegalArgumentException if <code>rowData</code> is empty\n      * @throws NullPointerException if <code>rowData</code>is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n     public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {\n         final int nCols = rowData.length;\n         final BigDecimal[][] data = new BigDecimal[1][nCols];\n      * @return a 1 x rowData.length BigMatrix\n      * @throws IllegalArgumentException if <code>rowData</code> is empty\n      * @throws NullPointerException if <code>rowData</code>is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n     public static BigMatrix createRowBigMatrix(String[] rowData) {\n         final int nCols = rowData.length;\n         final BigDecimal[][] data = new BigDecimal[1][nCols];\n     }\n     \n     /**\n+     * Creates a column {@link FieldMatrix} using the data from the input\n+     * array.\n+     * \n+     * @param columnData  the input column data\n+     * @return a columnData x 1 FieldMatrix\n+     * @throws IllegalArgumentException if <code>columnData</code> is empty\n+     * @throws NullPointerException if <code>columnData</code>is null\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createColumnFieldMatrix(final T[] columnData) {\n+        final int nRows = columnData.length;\n+        final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            m.setEntry(i, 0, columnData[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n      * Creates a column {@link BigMatrix} using the data from the input\n      * array.\n      * \n      * @return a columnData x 1 BigMatrix\n      * @throws IllegalArgumentException if <code>columnData</code> is empty\n      * @throws NullPointerException if <code>columnData</code>is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n     public static BigMatrix createColumnBigMatrix(double[] columnData) {\n         final int nRows = columnData.length;\n         final BigDecimal[][] data = new BigDecimal[nRows][1];\n      * @return a columnData x 1 BigMatrix\n      * @throws IllegalArgumentException if <code>columnData</code> is empty\n      * @throws NullPointerException if <code>columnData</code>is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n     public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {\n         final int nRows = columnData.length;\n         final BigDecimal[][] data = new BigDecimal[nRows][1];\n      * @return a columnData x 1 BigMatrix\n      * @throws IllegalArgumentException if <code>columnData</code> is empty\n      * @throws NullPointerException if <code>columnData</code>is null\n-     */\n+     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n     public static BigMatrix createColumnBigMatrix(String[] columnData) {\n         int nRows = columnData.length;\n         final BigDecimal[][] data = new BigDecimal[nRows][1];\n         return new BigMatrixImpl(data, false);\n     }\n     \n-    /**\n-     * Returns <code>dimension x dimension</code> identity matrix.\n-     *\n-     * @param dimension dimension of identity matrix to generate\n-     * @return identity matrix\n-     * @throws IllegalArgumentException if dimension is not positive\n-     * @since 1.1\n-     */\n-    public static BigMatrix createBigIdentityMatrix(int dimension) {\n-        final BigDecimal[][] d = new BigDecimal[dimension][dimension];\n-        for (int row = 0; row < dimension; row++) {\n-            final BigDecimal[] dRow = d[row];\n-            Arrays.fill(dRow, BigMatrixImpl.ZERO);\n-            dRow[row] = BigMatrixImpl.ONE;\n-        }\n-        return new BigMatrixImpl(d, false);\n-    }\n-    \n }\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/DenseFieldMatrixTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.linear.decomposition.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.decomposition.NonSquareMatrixException;\n+\n+/**\n+ * Test cases for the {@link DenseFieldMatrix} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+\n+public final class DenseFieldMatrixTest extends TestCase {\n+    \n+    // 3 x 3 identity matrix\n+    protected Fraction[][] id = {\n+            {new Fraction(1),new Fraction(0),new Fraction(0)},\n+            {new Fraction(0),new Fraction(1),new Fraction(0)},\n+            {new Fraction(0),new Fraction(0),new Fraction(1)}\n+    };\n+    \n+    // Test data for group operations\n+    protected Fraction[][] testData = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3)},\n+            {new Fraction(1),new Fraction(0),new Fraction(8)}\n+    };\n+    protected Fraction[][] testDataLU = {\n+            {new Fraction(2), new Fraction(5), new Fraction(3)},\n+            {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)},\n+            {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}\n+    };\n+    protected Fraction[][] testDataPlus2 = {\n+            {new Fraction(3),new Fraction(4),new Fraction(5)},\n+            {new Fraction(4),new Fraction(7),new Fraction(5)},\n+            {new Fraction(3),new Fraction(2),new Fraction(10)}\n+    };\n+    protected Fraction[][] testDataMinus = {\n+            {new Fraction(-1),new Fraction(-2),new Fraction(-3)},\n+            {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, \n+            {new Fraction(-1),new Fraction(0),new Fraction(-8)}\n+    };\n+    protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};\n+    protected Fraction[][] testDataInv = {\n+            {new Fraction(-40),new Fraction(16),new Fraction(9)},\n+            {new Fraction(13),new Fraction(-5),new Fraction(-3)},\n+            {new Fraction(5),new Fraction(-2),new Fraction(-1)}\n+    };\n+    protected Fraction[] preMultTest = {new Fraction(8), new Fraction(12), new Fraction(33)};\n+    protected Fraction[][] testData2 = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3)}\n+    };\n+    protected Fraction[][] testData2T = {\n+            {new Fraction(1),new Fraction(2)},\n+            {new Fraction(2),new Fraction(5)},\n+            {new Fraction(3),new Fraction(3)}\n+    };\n+    protected Fraction[][] testDataPlusInv = {\n+            {new Fraction(-39),new Fraction(18),new Fraction(12)},\n+            {new Fraction(15),new Fraction(0),new Fraction(0)},\n+            {new Fraction(6),new Fraction(-2),new Fraction(7)}\n+    };\n+    \n+    // lu decomposition tests\n+    protected Fraction[][] luData = {\n+            {new Fraction(2),new Fraction(3),new Fraction(3)},\n+            {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(6),new Fraction(9),new Fraction(8)}\n+    };\n+    protected Fraction[][] luDataLUDecomposition = {\n+            {new Fraction(6),new Fraction(9),new Fraction(8)},\n+            {new Fraction(0),new Fraction(5),new Fraction(7)},\n+            {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)}\n+    };\n+    \n+    // singular matrices\n+    protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };\n+    protected Fraction[][] bigSingular = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},\n+            {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},\n+            {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)},\n+            {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}\n+    }; // 4th row = 1st + 2nd\n+    protected Fraction[][] detData = {\n+            {new Fraction(1),new Fraction(2),new Fraction(3)},\n+            {new Fraction(4),new Fraction(5),new Fraction(6)},\n+            {new Fraction(7),new Fraction(8),new Fraction(10)}\n+    };\n+    protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};\n+    \n+    // vectors\n+    protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};\n+    protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};\n+    \n+    // submatrix accessor tests\n+    protected Fraction[][] subTestData = {\n+            {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n+            {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},\n+            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)},\n+            {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}\n+    }; \n+    // array selections\n+    protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};\n+    protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};\n+    protected Fraction[][] subRows03Cols123 = {\n+            {new Fraction(2), new Fraction(3), new Fraction(4)},\n+            {new Fraction(5), new Fraction(6), new Fraction(7)}\n+    };\n+    // effective permutations\n+    protected Fraction[][] subRows20Cols123 = {\n+            {new Fraction(4), new Fraction(6), new Fraction(8)},\n+            {new Fraction(2), new Fraction(3), new Fraction(4)}\n+    };\n+    protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}};\n+    // contiguous ranges\n+    protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}};\n+    protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}};\n+    protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}};\n+    // row matrices\n+    protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}};\n+    protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}};\n+    // column matrices\n+    protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};\n+    protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};\n+    \n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+    \n+    public DenseFieldMatrixTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DenseFieldMatrixTest.class);\n+        suite.setName(\"DenseFieldMatrix<Fraction> Tests\");\n+        return suite;\n+    }\n+    \n+    /** test dimensions */\n+    public void testDimensions() {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        Random r = new Random(66636328996002l);\n+        DenseFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83);\n+        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(m1.getData());\n+        assertEquals(m1, m2);\n+        DenseFieldMatrix<Fraction> m3 = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> m4 = new DenseFieldMatrix<Fraction>(m3.getData());\n+        assertEquals(m3, m4);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> mInv = new DenseFieldMatrix<Fraction>(testDataInv);\n+        FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n+        Fraction[][] sumEntries = mPlusMInv.getData();\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testDataInv);\n+        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));        \n+        try {\n+            m.subtract(new DenseFieldMatrix<Fraction>(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> mInv = new DenseFieldMatrix<Fraction>(testDataInv);\n+        DenseFieldMatrix<Fraction> identity = new DenseFieldMatrix<Fraction>(id);\n+        DenseFieldMatrix<Fraction> m2 = new DenseFieldMatrix<Fraction>(testData2);\n+        TestUtils.assertEquals(m.multiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.multiply(m), identity);\n+        TestUtils.assertEquals(m.multiply(identity), m);\n+        TestUtils.assertEquals(identity.multiply(mInv), mInv);\n+        TestUtils.assertEquals(m2.multiply(identity), m2); \n+        try {\n+            m.multiply(new DenseFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    }\n+\n+    public void testSeveralBlocks() {\n+\n+        FieldMatrix<Fraction> m =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41);\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            for (int j = 0; j < m.getColumnDimension(); ++j) {\n+                m.setEntry(i, j, new Fraction(i * 11 + j, 11));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mT = m.transpose();\n+        assertEquals(m.getRowDimension(), mT.getColumnDimension());\n+        assertEquals(m.getColumnDimension(), mT.getRowDimension());\n+        for (int i = 0; i < mT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mT.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(j, i), mT.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mPm = m.add(m);\n+        for (int i = 0; i < mPm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mPmMm = mPm.subtract(m);\n+        for (int i = 0; i < mPmMm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mPmMm.getColumnDimension(); ++j) {\n+                assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mTm = mT.multiply(m);\n+        for (int i = 0; i < mTm.getRowDimension(); ++i) {\n+            for (int j = 0; j < mTm.getColumnDimension(); ++j) {\n+                Fraction sum = Fraction.ZERO;\n+                for (int k = 0; k < mT.getColumnDimension(); ++k) {\n+                    sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11)));\n+                }\n+                assertEquals(sum, mTm.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> mmT = m.multiply(mT);\n+        for (int i = 0; i < mmT.getRowDimension(); ++i) {\n+            for (int j = 0; j < mmT.getColumnDimension(); ++j) {\n+                Fraction sum = Fraction.ZERO;\n+                for (int k = 0; k < m.getColumnDimension(); ++k) {\n+                    sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11)));\n+                }\n+                assertEquals(sum, mmT.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20);\n+        for (int i = 0; i < sub1.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub1.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40);\n+        for (int i = 0; i < sub2.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub2.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5);\n+        for (int i = 0; i < sub3.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub3.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j));\n+            }\n+        }\n+\n+        FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35);\n+        for (int i = 0; i < sub4.getRowDimension(); ++i) {\n+            for (int j = 0; j < sub4.getColumnDimension(); ++j) {\n+                assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j));\n+            }\n+        }\n+\n+    }\n+\n+    //Additional Test for DenseFieldMatrix<Fraction>Test.testMultiply\n+\n+    private Fraction[][] d3 = new Fraction[][] {\n+            {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},\n+            {new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}\n+    };\n+    private Fraction[][] d4 = new Fraction[][] {\n+            {new Fraction(1)},\n+            {new Fraction(2)},\n+            {new Fraction(3)},\n+            {new Fraction(4)}\n+    };\n+    private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n+     \n+    public void testMultiply2() { \n+       FieldMatrix<Fraction> m3 = new DenseFieldMatrix<Fraction>(d3);   \n+       FieldMatrix<Fraction> m4 = new DenseFieldMatrix<Fraction>(d4);\n+       FieldMatrix<Fraction> m5 = new DenseFieldMatrix<Fraction>(d5);\n+       TestUtils.assertEquals(m3.multiply(m4), m5);\n+   }  \n+        \n+    /** test trace */\n+    public void testTrace() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(id);\n+        assertEquals(new Fraction(3),m.getTrace());\n+        m = new DenseFieldMatrix<Fraction>(testData2);\n+        try {\n+            m.getTrace();\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    /** test scalarAdd */\n+    public void testScalarAdd() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(new DenseFieldMatrix<Fraction>(testDataPlus2),\n+                               m.scalarAdd(new Fraction(2)));\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(testVector, m.operate(testVector));\n+        TestUtils.assertEquals(testVector, m.operate(new FieldVectorImpl<Fraction>(testVector)).getData());\n+        m = new DenseFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.operate(testVector);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+\n+    public void testOperateLarge() {\n+        int p = (3 * DenseFieldMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * DenseFieldMatrix.BLOCK_SIZE) / 2;\n+        int r =  2 * DenseFieldMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n+        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n+        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < r; ++i) {\n+            TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i)));\n+        }\n+    }\n+\n+    public void testOperatePremultiplyLarge() {\n+        int p = (3 * DenseFieldMatrix.BLOCK_SIZE) / 2;\n+        int q = (5 * DenseFieldMatrix.BLOCK_SIZE) / 2;\n+        int r =  2 * DenseFieldMatrix.BLOCK_SIZE;\n+        Random random = new Random(111007463902334l);\n+        FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q);\n+        FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r);\n+        FieldMatrix<Fraction> m1m2 = m1.multiply(m2);\n+        for (int i = 0; i < p; ++i) {\n+            TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i)));\n+        }\n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        FieldMatrix<Fraction> a = new DenseFieldMatrix<Fraction>(new Fraction[][] {\n+                { new Fraction(1), new Fraction(2) },\n+                { new Fraction(3), new Fraction(4) },\n+                { new Fraction(5), new Fraction(6) }\n+        });\n+        Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( new Fraction(3), b[0]);\n+        assertEquals( new Fraction(7), b[1]);\n+        assertEquals(new Fraction(11), b[2]);\n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData); \n+        FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n+        FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n+        TestUtils.assertEquals(mIT, mTI);\n+        m = new DenseFieldMatrix<Fraction>(testData2);\n+        FieldMatrix<Fraction> mt = new DenseFieldMatrix<Fraction>(testData2T);\n+        TestUtils.assertEquals(mt, m.transpose());\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.preMultiply(testVector), preMultTest);\n+        TestUtils.assertEquals(m.preMultiply(new FieldVectorImpl<Fraction>(testVector).getData()),\n+                               preMultTest);\n+        m = new DenseFieldMatrix<Fraction>(bigSingular);\n+        try {\n+            m.preMultiply(testVector);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        FieldMatrix<Fraction> m3 = new DenseFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m4 = new DenseFieldMatrix<Fraction>(d4);\n+        FieldMatrix<Fraction> m5 = new DenseFieldMatrix<Fraction>(d5);\n+        TestUtils.assertEquals(m4.preMultiply(m3), m5);\n+        \n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> mInv = new DenseFieldMatrix<Fraction>(testDataInv);\n+        DenseFieldMatrix<Fraction> identity = new DenseFieldMatrix<Fraction>(id);\n+        TestUtils.assertEquals(m.preMultiply(mInv), identity);\n+        TestUtils.assertEquals(mInv.preMultiply(m), identity);\n+        TestUtils.assertEquals(m.preMultiply(identity), m);\n+        TestUtils.assertEquals(identity.preMultiply(mInv), mInv);\n+        try {\n+            m.preMultiply(new DenseFieldMatrix<Fraction>(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // ignored\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        TestUtils.assertEquals(m.getRow(0), testDataRow1);\n+        TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n+        try {\n+            m.getRow(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+        try {\n+            m.getColumn(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    public void testGetEntry() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        assertEquals(m.getEntry(0,1),new Fraction(2));\n+        try {\n+            m.getEntry(10, 4);\n+            fail (\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+        \n+    /** test examples in user guide */\n+    public void testExamples() {\n+        // Create a real matrix with two rows and three columns\n+        Fraction[][] matrixData = {\n+                {new Fraction(1),new Fraction(2),new Fraction(3)},\n+                {new Fraction(2),new Fraction(5),new Fraction(3)}\n+        };\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(matrixData);\n+        // One more with three rows, two columns\n+        Fraction[][] matrixData2 = {\n+                {new Fraction(1),new Fraction(2)},\n+                {new Fraction(2),new Fraction(5)},\n+                {new Fraction(1), new Fraction(7)}\n+        };\n+        FieldMatrix<Fraction> n = new DenseFieldMatrix<Fraction>(matrixData2);\n+        // Now multiply m by n\n+        FieldMatrix<Fraction> p = m.multiply(n);\n+        assertEquals(2, p.getRowDimension());\n+        assertEquals(2, p.getColumnDimension());\n+        // Invert p\n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        assertEquals(2, pInverse.getRowDimension());\n+        assertEquals(2, pInverse.getColumnDimension());\n+        \n+        // Solve example\n+        Fraction[][] coefficientsData = {\n+                {new Fraction(2), new Fraction(3), new Fraction(-2)},\n+                {new Fraction(-1), new Fraction(7), new Fraction(6)},\n+                {new Fraction(4), new Fraction(-3), new Fraction(-5)}\n+        };\n+        FieldMatrix<Fraction> coefficients = new DenseFieldMatrix<Fraction>(coefficientsData);\n+        Fraction[] constants = {new Fraction(1), new Fraction(-2), new Fraction(1)};\n+        Fraction[] solution = new FieldLUDecompositionImpl<Fraction>(coefficients).getSolver().solve(constants);\n+        assertEquals(new Fraction(2).multiply(solution[0]).\n+                     add(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(2).multiply(solution[2])),\n+                     constants[0]);\n+        assertEquals(new Fraction(-1).multiply(solution[0]).\n+                     add(new Fraction(7).multiply(solution[1])).\n+                     add(new Fraction(6).multiply(solution[2])),\n+                     constants[1]);\n+        assertEquals(new Fraction(4).multiply(solution[0]).\n+                     subtract(new Fraction(3).multiply(solution[1])).\n+                     subtract(new Fraction(5).multiply(solution[2])),\n+                     constants[2]);   \n+        \n+    }\n+    \n+    // test submatrix accessors\n+    public void testGetSubMatrix() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n+        checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n+        checkGetSubMatrix(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int startRow, int endRow, int startColumn, int endColumn,\n+                                   boolean mustFail) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn);\n+            assertEquals(new DenseFieldMatrix<Fraction>(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                                   int[] selectedRows, int[] selectedColumns,\n+                                   boolean mustFail) {\n+        try {\n+            FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns);\n+            assertEquals(new DenseFieldMatrix<Fraction>(reference), sub);\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetSetMatrixLarge() {\n+        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1));\n+\n+        m.setSubMatrix(sub.getData(), 2, 2);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3));\n+\n+    }\n+\n+    public void testCopySubMatrix() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n+        checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        \n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, -1, 1, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 2, true);\n+        checkCopy(m, null,  1, 0, 2, 4, true);\n+        checkCopy(m, null, new int[] {},    new int[] { 0 }, true);\n+        checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true);\n+    }\n+\n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int startRow, int endRow, int startColumn, int endColumn,\n+                           boolean mustFail) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                             new Fraction[1][1] :\n+                             new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub);\n+            assertEquals(new DenseFieldMatrix<Fraction>(reference), new DenseFieldMatrix<Fraction>(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+    \n+    private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n+                           int[] selectedRows, int[] selectedColumns,\n+                           boolean mustFail) {\n+        try {\n+            Fraction[][] sub = (reference == null) ?\n+                    new Fraction[1][1] :\n+                    new Fraction[reference.length][reference[0].length];\n+            m.copySubMatrix(selectedRows, selectedColumns, sub);\n+            assertEquals(new DenseFieldMatrix<Fraction>(reference), new DenseFieldMatrix<Fraction>(sub));\n+            if (mustFail) {\n+                fail(\"Expecting MatrixIndexException\");\n+            }\n+        } catch (MatrixIndexException e) {\n+            if (!mustFail) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    public void testGetRowMatrix() {\n+        FieldMatrix<Fraction> m     = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow0 = new DenseFieldMatrix<Fraction>(subRow0);\n+        FieldMatrix<Fraction> mRow3 = new DenseFieldMatrix<Fraction>(subRow3);\n+        assertEquals(\"Row0\", mRow0, m.getRowMatrix(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n+        try {\n+            m.getRowMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowMatrix() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mRow3 = new DenseFieldMatrix<Fraction>(subRow3);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowMatrix(0, mRow3);\n+        assertEquals(mRow3, m.getRowMatrix(0));\n+        try {\n+            m.setRowMatrix(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGetSetRowMatrixLarge() {\n+        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1));\n+\n+        m.setRowMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowMatrix(2));\n+\n+    }\n+    \n+    public void testGetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn1 = new DenseFieldMatrix<Fraction>(subColumn1);\n+        FieldMatrix<Fraction> mColumn3 = new DenseFieldMatrix<Fraction>(subColumn3);\n+        assertEquals(mColumn1, m.getColumnMatrix(1));\n+        assertEquals(mColumn3, m.getColumnMatrix(3));\n+        try {\n+            m.getColumnMatrix(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnMatrix(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnMatrix() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldMatrix<Fraction> mColumn3 = new DenseFieldMatrix<Fraction>(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnMatrix(1));\n+        m.setColumnMatrix(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnMatrix(1));\n+        try {\n+            m.setColumnMatrix(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnMatrix(0, m);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnMatrixLarge() {\n+        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldMatrix<Fraction> sub =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1));\n+\n+        m.setColumnMatrix(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnMatrix(2));\n+\n+    }\n+    \n+    public void testGetRowVector() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow0 = new FieldVectorImpl<Fraction>(subRow0[0]);\n+        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        assertEquals(mRow0, m.getRowVector(0));\n+        assertEquals(mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRowVector() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mRow3 = new FieldVectorImpl<Fraction>(subRow3[0]);\n+        assertNotSame(mRow3, m.getRowMatrix(0));\n+        m.setRowVector(0, mRow3);\n+        assertEquals(mRow3, m.getRowVector(0));\n+        try {\n+            m.setRowVector(-1, mRow3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRowVector(0, new FieldVectorImpl<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowVectorLarge() {\n+        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldVector<Fraction> sub = new FieldVectorImpl<Fraction>(n, new Fraction(1));\n+\n+        m.setRowVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getRowVector(2));\n+\n+    }\n+    \n+    public void testGetColumnVector() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertEquals(mColumn1, m.getColumnVector(1));\n+        assertEquals(mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumnVector() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        FieldVector<Fraction> mColumn3 = columnToVector(subColumn3);\n+        assertNotSame(mColumn3, m.getColumnVector(1));\n+        m.setColumnVector(1, mColumn3);\n+        assertEquals(mColumn3, m.getColumnVector(1));\n+        try {\n+            m.setColumnVector(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumnVector(0, new FieldVectorImpl<Fraction>(FractionField.getInstance(), 5));\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnVectorLarge() {\n+        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        FieldVector<Fraction> sub = new FieldVectorImpl<Fraction>(n, new Fraction(1));\n+\n+        m.setColumnVector(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        assertEquals(sub, m.getColumnVector(2));\n+\n+    }\n+    \n+    private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new FieldVectorImpl<Fraction>(data, false);\n+    }\n+\n+    public void testGetRow() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        checkArrays(subRow0[0], m.getRow(0));\n+        checkArrays(subRow3[0], m.getRow(3));\n+        try {\n+            m.getRow(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRow(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetRow() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        assertTrue(subRow3[0][0] != m.getRow(0)[0]);\n+        m.setRow(0, subRow3[0]);\n+        checkArrays(subRow3[0], m.getRow(0));\n+        try {\n+            m.setRow(-1, subRow3[0]);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setRow(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetRowLarge() {\n+        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        Fraction[] sub = new Fraction[n];\n+        Arrays.fill(sub, new Fraction(1));\n+\n+        m.setRow(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (i != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getRow(2));\n+\n+    }\n+    \n+    public void testGetColumn() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn1 = columnToArray(subColumn1);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        checkArrays(mColumn1, m.getColumn(1));\n+        checkArrays(mColumn3, m.getColumn(3));\n+        try {\n+            m.getColumn(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumn(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSetColumn() {\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(subTestData);\n+        Fraction[] mColumn3 = columnToArray(subColumn3);\n+        assertTrue(mColumn3[0] != m.getColumn(1)[0]);\n+        m.setColumn(1, mColumn3);\n+        checkArrays(mColumn3, m.getColumn(1));\n+        try {\n+            m.setColumn(-1, mColumn3);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.setColumn(0, new Fraction[5]);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetSetColumnLarge() {\n+        int n = 3 * DenseFieldMatrix.BLOCK_SIZE;\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), n, n);\n+        Fraction[] sub = new Fraction[n];\n+        Arrays.fill(sub, new Fraction(1));\n+\n+        m.setColumn(2, sub);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < n; ++j) {\n+                if (j != 2) {\n+                    assertEquals(new Fraction(0), m.getEntry(i, j));\n+                } else {\n+                    assertEquals(new Fraction(1), m.getEntry(i, j));\n+                }\n+            }\n+        }\n+        checkArrays(sub, m.getColumn(2));\n+\n+    }\n+    \n+    private Fraction[] columnToArray(Fraction[][] column) {\n+        Fraction[] data = new Fraction[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return data;\n+    }\n+\n+    private void checkArrays(Fraction[] expected, Fraction[] actual) {\n+        assertEquals(expected.length, actual.length);\n+        for (int i = 0; i < expected.length; ++i) {\n+            assertEquals(expected[i], actual[i]);            \n+        }\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        DenseFieldMatrix<Fraction> m1 = (DenseFieldMatrix<Fraction>) m.copy();\n+        DenseFieldMatrix<Fraction> mt = (DenseFieldMatrix<Fraction>) m.transpose();\n+        assertTrue(m.hashCode() != mt.hashCode());\n+        assertEquals(m.hashCode(), m1.hashCode());\n+        assertEquals(m, m);\n+        assertEquals(m, m1);\n+        assertFalse(m.equals(null));\n+        assertFalse(m.equals(mt));\n+        assertFalse(m.equals(new DenseFieldMatrix<Fraction>(bigSingular))); \n+    }\n+    \n+    public void testToString() {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        assertEquals(\"DenseFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n+    }\n+    \n+    public void testSetSubMatrix() throws Exception {\n+        DenseFieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(testData);\n+        m.setSubMatrix(detData2,1,1);\n+        FieldMatrix<Fraction> expected = new DenseFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(detData2,0,0);\n+        expected = new DenseFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n+        assertEquals(expected, m);  \n+        \n+        m.setSubMatrix(testDataPlus2,0,0);      \n+        expected = new DenseFieldMatrix<Fraction>\n+            (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});\n+        assertEquals(expected, m);   \n+        \n+        // javadoc example\n+        DenseFieldMatrix<Fraction> matrix =\n+            new DenseFieldMatrix<Fraction>(new Fraction[][] {\n+                    {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n+                    {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)},\n+                    {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)}\n+            });\n+        matrix.setSubMatrix(new Fraction[][] {\n+                {new Fraction(3), new Fraction(4)},\n+                {new Fraction(5), new Fraction(6)}\n+        }, 1, 1);\n+        expected =\n+            new DenseFieldMatrix<Fraction>(new Fraction[][] {\n+                    {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)},\n+                    {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},\n+                    {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}\n+            });\n+        assertEquals(expected, matrix);   \n+\n+        // dimension overflow\n+        try {  \n+            m.setSubMatrix(testData,1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        // dimension underflow\n+        try {  \n+            m.setSubMatrix(testData,-1,1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        try {  \n+            m.setSubMatrix(testData,1,-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException e) {\n+            // expected\n+        }\n+        \n+        // null\n+        try {\n+            m.setSubMatrix(null,1,1);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        // ragged\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+       \n+        // empty\n+        try {\n+            m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    public void testWalk() {\n+        int rows    = 150;\n+        int columns = 75;\n+\n+        FieldMatrix<Fraction> m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor());\n+        GetVisitor getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor());\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor);\n+        assertEquals(rows * columns, getVisitor.getCount());\n+\n+        m = new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2);\n+        getVisitor = new GetVisitor();\n+        m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n+        assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n+        for (int i = 0; i < rows; ++i) {\n+            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n+        }\n+        for (int j = 0; j < columns; ++j) {\n+            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n+        }\n+\n+    }\n+    \n+    private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n+        private static final long serialVersionUID = 6586716383170553060L;\n+        public SetVisitor() {\n+            super(Fraction.ZERO);\n+        }\n+        @Override\n+        public Fraction visit(int i, int j, Fraction value) {\n+            return new Fraction(i * 11 + j, 11);\n+        }\n+    }\n+\n+    private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> {\n+        private static final long serialVersionUID = 8363001284977267825L;\n+        private int count;\n+        public GetVisitor() {\n+            super(Fraction.ZERO);\n+            count = 0;\n+        }\n+        @Override\n+        public void visit(int i, int j, Fraction value) {\n+            ++count;\n+            assertEquals(new Fraction(i * 11 + j, 11), value);\n+        }\n+        public int getCount() {\n+            return count;\n+        }\n+    }\n+\n+    private DenseFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) {\n+        DenseFieldMatrix<Fraction> m =\n+            new DenseFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns);\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < columns; ++j) {\n+                int p = r.nextInt(20) - 10;\n+                int q = r.nextInt(20) - 10;\n+                if (q == 0) {\n+                    q = 1;\n+                }\n+                m.setEntry(i, j, new Fraction(p, q));\n+            }\n+        }\n+        return m;\n+    }\n+    \n+}\n+", "timestamp": 1240258789, "metainfo": ""}