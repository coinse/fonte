{"sha": "41598b038509e9cdb7f6dbeefdb2a2876d2708a6", "log": "added fraction class and fraction formatting classes.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Representation of a rational number.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Revision: $ $Date: $\n+ */\n+public class Fraction extends Number implements Comparable {\n+\n+    /** A fraction representing \"1 / 1\". */\n+    public static final Fraction ONE = new Fraction(1, 1);\n+\n+    /** A fraction representing \"0 / 1\". */\n+    public static final Fraction ZERO = new Fraction(0, 1);\n+    \n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 65382027393090L;\n+    \n+    /** The denominator. */\n+    private int denominator;\n+    \n+    /** The numerator. */\n+    private int numerator;\n+\n+    /**\n+     * Create a fraction given the double value.\n+     * @param value the double value to convert to a fraction.\n+     * @throws ConvergenceException if the continued fraction failed to\n+     *         converge.\n+     */\n+    public Fraction(double value) throws ConvergenceException {\n+        this(value, 1.0e-5, 100);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * @param value the double value to convert to a fraction.\n+     * @param epsilon maximum error allowed.  The resulting fraction is within\n+     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxIterations maximum number of convergents\n+     * @throws ConvergenceException if the continued fraction failed to\n+     *         converge.\n+     */\n+    public Fraction(double value, double epsilon, int maxIterations)\n+        throws ConvergenceException\n+    {\n+        double r0 = value;\n+        int a0 = (int)Math.floor(r0);\n+        \n+        int p0 = 1;\n+        int q0 = 0;\n+        int p1 = a0;\n+        int q1 = 1;\n+\n+        int p2 = 0;\n+        int q2 = 1;\n+\n+        int n = 0;\n+        boolean stop = false;\n+        do {\n+            ++n;\n+            double r1 = 1.0 / (r0 - a0);\n+            int a1 = (int)Math.floor(r1);\n+            p2 = (a1 * p1) + p0;\n+            q2 = (a1 * q1) + q0;\n+            \n+            double convergent = (double)p2 / (double)q2;\n+            if (n < maxIterations && Math.abs(convergent - value) > epsilon) {\n+                p0 = p1;\n+                p1 = p2;\n+                q0 = q1;\n+                q1 = q2;\n+                a0 = a1;\n+                r0 = r1;\n+            } else {\n+                stop = true;\n+            }\n+        } while (!stop);\n+\n+        if (n >= maxIterations) {\n+            throw new ConvergenceException(\n+                    \"Unable to convert double to fraction\");\n+        }\n+        \n+        this.numerator = p2;\n+        this.denominator = q2;\n+        reduce();\n+    }\n+    \n+    /**\n+     * Create a fraction given the numerator and denominator.  The fraction is\n+     * reduced to lowest terms.\n+     * @param num the numerator.\n+     * @param den the denominator.\n+     */\n+    public Fraction(int num, int den) {\n+        super();\n+        this.numerator = num;\n+        this.denominator = den;\n+        reduce();\n+    }\n+    \n+    /**\n+     * Returns the absolute value of this fraction.\n+     * @return the absolute value.\n+     */\n+    public Fraction abs() {\n+        Fraction ret;\n+        if (numerator >= 0) {\n+            ret = this;\n+        } else {\n+            ret = negate();\n+        }\n+        return ret;        \n+    }\n+    \n+    /**\n+     * Return the sum of this fraction and the given fraction.  The returned\n+     * fraction is reduced to lowest terms.\n+     *\n+     * @param rhs the other fraction.\n+     * @return the fraction sum in lowest terms.\n+     */\n+    public Fraction add(Fraction rhs) {\n+        int den = MathUtils.lcm(denominator, rhs.denominator);\n+        int num = (numerator * (den / denominator)) +\n+            (rhs.numerator * (den / rhs.denominator));\n+        return new Fraction(num, den);\n+    }\n+    \n+    /**\n+     * Compares this object to another based on size.\n+     * @param object the object to compare to\n+     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n+     *         than <tt>object</tt>, 0 if they are equal.\n+     */\n+    public int compareTo(Object object) {\n+        int ret = 0;\n+        \n+        if (this != object) { \n+            Fraction other = (Fraction)object;\n+            double first = doubleValue();\n+            double second = other.doubleValue();\n+            \n+            if (first < second) {\n+                ret = -1;\n+            } else if (first > second) {\n+                ret = 1;\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Return the quotient of this fraction and the given fraction.  The\n+     * returned fraction is reduced to lowest terms.\n+     * @param rhs the other fraction.\n+     * @return the fraction quotient in lowest terms.\n+     */\n+    public Fraction divide(Fraction rhs) {\n+        return multiply(rhs.reciprocal());\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * @return the fraction as a <tt>double</tt>\n+     */\n+    public double doubleValue() {\n+        return (double)numerator / (double)denominator;\n+    }\n+    \n+    /**\n+     * Test for the equality of two fractions.  If the lowest term\n+     * numerator and denominators are the same for both fractions, the two\n+     * fractions are considered to be equal.\n+     * @param other fraction to test for equality to this fraction\n+     * @return true if two fractions are equal, false if object is\n+     *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal\n+     *         to this fraction instance.\n+     */\n+    public boolean equals(Object other) {\n+        boolean ret;\n+        \n+        if (this == other) { \n+            ret = true;\n+        } else if (other == null) {\n+            ret = false;\n+        } else {\n+            try {\n+                // since fractions are always in lowest terms, numerators and\n+                // denominators can be compared directly for equality.\n+                Fraction rhs = (Fraction)other;\n+                ret = (numerator == rhs.numerator) &&\n+                    (denominator == rhs.denominator);\n+            } catch (ClassCastException ex) {\n+                // ignore exception\n+                ret = false;\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * @return the fraction as a <tt>float</tt>\n+     */\n+    public float floatValue() {\n+        return (float)doubleValue();\n+    }\n+    \n+    /**\n+     * Access the denominator.\n+     * @return the denominator.\n+     */\n+    public int getDenominator() {\n+        return denominator;\n+    }\n+    \n+    /**\n+     * Access the numerator.\n+     * @return the numerator.\n+     */\n+    public int getNumerator() {\n+        return numerator;\n+    }\n+    \n+    /**\n+     * Gets a hashCode for the fraction.\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        return 37 * (37 * 17 + getNumerator()) + getDenominator();\n+    }\n+    \n+    /**\n+     * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n+     * of the fraction.\n+     * @return the whole number fraction part\n+     */\n+    public int intValue() {\n+        return (int)doubleValue();\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n+     * of the fraction.\n+     * @return the whole number fraction part\n+     */\n+    public long longValue() {\n+        return (long)doubleValue();\n+    }\n+    \n+    /**\n+     * Return the product of this fraction and the given fraction.  The returned\n+     * fraction is reduced to lowest terms.\n+     * @param rhs the other fraction.\n+     * @return the fraction product in lowest terms.\n+     */\n+    public Fraction multiply(Fraction rhs) {\n+        return new Fraction(numerator * rhs.numerator, \n+                denominator * rhs.denominator);\n+    }\n+    \n+    /**\n+     * Return the additive inverse of this fraction.\n+     * @return the negation of this fraction.\n+     */\n+    public Fraction negate() {\n+        return new Fraction(-numerator, denominator);\n+    }\n+\n+    /**\n+     * Return the multiplicative inverse of this fraction.\n+     * @return the reciprocal fraction\n+     */\n+    public Fraction reciprocal() {\n+        return new Fraction(denominator, numerator);\n+    }\n+    \n+    /**\n+     * Return the difference between this fraction and the given fraction.  The\n+     * returned fraction is reduced to lowest terms.\n+     * @param rhs the other fraction.\n+     * @return the fraction difference in lowest terms.\n+     */\n+    public Fraction subtract(Fraction rhs) {\n+        return add(rhs.negate());\n+    }\n+    \n+    /**\n+     * Reduce this fraction to lowest terms.  This is accomplished by dividing\n+     * both numerator and denominator by their greatest common divisor.\n+     */\n+    private void reduce() {\n+        // reduce numerator and denominator by greatest common denominator.\n+        int d = MathUtils.gcd(numerator, denominator);\n+        if (d > 1) {\n+            numerator /= d;\n+            denominator /= d;\n+        }\n+\n+        // move sign to numerator.\n+        if (denominator < 0) {\n+            numerator *= -1;\n+            denominator *= -1;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * Formats a Fraction number in proper format or improper format.  The number\n+ * format for each of the whole number, numerator and, denominator can be\n+ * configured.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Revision: 1.10 $ $Date: 2004-09-20 23:45:55 -0500 (Mon, 20 Sep 2004) $\n+ */\n+public class FractionFormat extends Format implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -6337346779577272306L;\n+\n+    /** The format used for the denominator. */\n+    private NumberFormat denominatorFormat;\n+\n+    /** The format used for the numerator. */\n+    private NumberFormat numeratorFormat;\n+    \n+    /**\n+     * Create an improper formatting instance with the default number format\n+     * for the numerator and denominator.  \n+     */\n+    public FractionFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * both the numerator and denominator.\n+     * @param format the custom format for both the numerator and denominator.\n+     */\n+    public FractionFormat(NumberFormat format) {\n+        this(format, (NumberFormat)format.clone());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * the numerator and a custom number format for the denominator.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public FractionFormat(NumberFormat numeratorFormat,\n+            NumberFormat denominatorFormat)\n+    {\n+        super();\n+        this.numeratorFormat = numeratorFormat;\n+        this.denominatorFormat = denominatorFormat;\n+    }\n+\n+    /**\n+     * This static method calls formatFraction() on a default instance of\n+     * FractionFormat.\n+     *\n+     * @param f Fraction object to format\n+     * @return A formatted fraction in proper form.\n+     */\n+    public static String formatFraction(Fraction f) {\n+    \treturn getImproperInstance().format(f);\n+    }\n+    \n+    /**\n+     * Get the set of locales for which complex formats are available.  This\n+     * is the same set as the {@link NumberFormat} set. \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static FractionFormat getImproperInstance() {\n+        return getImproperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static FractionFormat getImproperInstance(Locale locale) {\n+        NumberFormat f = getDefaultNumberFormat(locale);\n+        return new FractionFormat(f);\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static FractionFormat getProperInstance() {\n+        return getProperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static FractionFormat getProperInstance(Locale locale) {\n+        NumberFormat f = getDefaultNumberFormat(locale);\n+        return new ProperFractionFormat(f);\n+    }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing is the\n+     * maximum number of fraction digits, which is set to 2.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of fraction digits, which is set to 2.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n+        NumberFormat nf = NumberFormat.getIntegerInstance(locale);\n+        return nf;\n+    }\n+    \n+    /**\n+     * Formats a {@link Fraction} object to produce a string.  The fraction is\n+     * output in improper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        getNumeratorFormat().format(fraction.getNumerator(), toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,\n+            pos);\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats a object to produce a string.  <code>obj</code> must be either a \n+     * {@link Fraction} object or a {@link Number} object.  Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos)\n+    {\n+        StringBuffer ret = null;\n+        \n+        if (obj instanceof Fraction) {\n+            ret = format( (Fraction)obj, toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            try {\n+                ret = format( new Fraction(((Number)obj).doubleValue()),\n+                    toAppendTo, pos);\n+            } catch (ConvergenceException ex) {\n+                throw new IllegalArgumentException(\n+                    \"Cannot convert given object to a fraction.\");\n+            }\n+        } else { \n+            throw new IllegalArgumentException(\n+                \"Cannot format given object as a fraction\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the denominator format.\n+     * @return the denominator format.\n+     */\n+    public NumberFormat getDenominatorFormat() {\n+        return denominatorFormat;\n+    }\n+    \n+    /**\n+     * Access the numerator format.\n+     * @return the numerator format.\n+     */\n+    public NumberFormat getNumeratorFormat() {\n+        return numeratorFormat;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Fraction} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Fraction} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Fraction parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Fraction result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new ParseException(\"Unparseable fraction number: \\\"\" +\n+                source + \"\\\"\", parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Fraction} object.  This method\n+     * expects the string to be formatted as an improper fraction.  \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Fraction} object.\n+     */\n+    public Fraction parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse numerator\n+        Number num = getNumeratorFormat().parse(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a fraction\n+            return new Fraction(num.intValue(), 1);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        Number den = getDenominatorFormat().parse(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        return new Fraction(num.intValue(), den.intValue());\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+    \n+    /**\n+     * Modify the denominator format.\n+     * @param format the new denominator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setDenominatorFormat(NumberFormat format) {\n+        if (format == null) {\n+            throw new IllegalArgumentException(\n+                \"denominator format can not be null.\");\n+        }\n+        this.denominatorFormat = format;\n+    }\n+    \n+    /**\n+     * Modify the numerator format.\n+     * @param format the new numerator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setNumeratorFormat(NumberFormat format) {\n+        if (format == null) {\n+            throw new IllegalArgumentException(\n+                \"numerator format can not be null.\");\n+        }\n+        this.numeratorFormat = format;\n+    }\n+     \n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    protected static void parseAndIgnoreWhitespace(\n+        String source, ParsePosition pos)\n+    {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    protected static char parseNextCharacter(String source, ParsePosition pos) {\n+         int index = pos.getIndex();\n+         int n = source.length();\n+         char ret = 0;\n+\n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Formats a Fraction number in proper format.  The number format for each of\n+ * the whole number, numerator and, denominator can be configured.\n+ * \n+ * @author Apache Software Foundation\n+ * @version $Revision: $ $Date: $\n+ */\n+public class ProperFractionFormat extends FractionFormat {\n+    \n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -6337346779577272307L;\n+    \n+    /** The format used for the whole number. */\n+    private NumberFormat wholeFormat;\n+\n+    /**\n+     * Create a proper formatting instance with the default number format for\n+     * the whole, numerator, and denominator.  \n+     */\n+    public ProperFractionFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for the\n+     * whole, numerator, and denominator.\n+     * @param format the custom format for the whole, numerator, and\n+     *        denominator.\n+     */\n+    public ProperFractionFormat(NumberFormat format) {\n+        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for each\n+     * of the whole, numerator, and denominator.\n+     * @param wholeFormat the custom format for the whole.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public ProperFractionFormat(NumberFormat wholeFormat,\n+            NumberFormat numeratorFormat,\n+            NumberFormat denominatorFormat)\n+    {\n+        super(numeratorFormat, denominatorFormat);\n+        setWholeFormat(wholeFormat);\n+    }\n+    \n+    /**\n+     * Formats a {@link Fraction} object to produce a string.  The fraction\n+     * is output in proper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        int num = fraction.getNumerator();\n+        int den = fraction.getDenominator();\n+        int whole = num / den;\n+        num = num % den;\n+        \n+        if (whole != 0) {\n+            getWholeFormat().format(whole, toAppendTo, pos);\n+            toAppendTo.append(' ');\n+            num = Math.abs(num);\n+        }\n+        getNumeratorFormat().format(num, toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(den, toAppendTo,\n+            pos);\n+        \n+        return toAppendTo;\n+    }\n+\n+    /**\n+     * Access the whole format.\n+     * @return the whole format.\n+     */\n+    public NumberFormat getWholeFormat() {\n+        return wholeFormat;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Fraction} object.  This method\n+     * expects the string to be formatted as a proper fraction.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Fraction} object.\n+     */\n+    public Fraction parse(String source, ParsePosition pos) {\n+        // try to parse improper fraction\n+        Fraction ret = super.parse(source, pos);\n+        if (ret != null) {\n+            return ret;\n+        }\n+        \n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse whole\n+        Number whole = getWholeFormat().parse(source, pos);\n+        if (whole == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+        \n+        // parse numerator\n+        Number num = getNumeratorFormat().parse(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a fraction\n+            return new Fraction(num.intValue(), 1);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        Number den = getDenominatorFormat().parse(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        int w = whole.intValue();\n+        int n = num.intValue();\n+        int d = den.intValue();\n+        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n+    }\n+    \n+    /**\n+     * Modify the whole format.\n+     * @param format The new whole format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setWholeFormat(NumberFormat format) {\n+        if (format == null) {\n+            throw new IllegalArgumentException(\n+                \"whole format can not be null.\");\n+        }\n+        this.wholeFormat = format;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n /*\n- * Copyright 2003-2004 The Apache Software Foundation.\n+ * Copyright 2003-2005 The Apache Software Foundation.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n  *\n- * @version $Revision: 1.20 $ $Date: 2004/10/14 04:01:04 $\n+ * @version $Revision: 1.20 $ $Date$\n  */\n public final class MathUtils {\n     \n     public static boolean equals(double x, double y) {\n         return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n     }\n+\n+    /**\n+     * Returns the least common multiple between two integer values.\n+     * @param a the first integer value.\n+     * @param b the second integer value.\n+     * @return the least common multiple between a and b.\n+     */\n+    public static int lcm(int a, int b) {\n+        return Math.abs(a / gcd(a, b) * b);\n+    }\n+\n+    /**\n+     * Returns the greatest common divisor between two integer values.\n+     * @param a the first integer value.\n+     * @param b the second integer value.\n+     * @return the greatest common divisor between a and b.\n+     */\n+    public static int gcd(int a, int b) {\n+        int ret;\n+        \n+        if (a == 0) {\n+            ret = Math.abs(b);\n+        } else if (b == 0) {\n+            ret = Math.abs(a);\n+        } else if (a < 0) {\n+            ret = gcd(-a, b);\n+        } else if (b < 0) {\n+            ret = gcd(a, -b);\n+        } else {\n+            int r = 0;\n+            while(b > 0){\n+                r = a % b;\n+                a = b;\n+                b = r;\n+            }\n+            ret = a;\n+        }\n+        return ret;\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/fraction/FractionFormatTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.text.ParseException;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+public class FractionFormatTest extends TestCase {\n+ \n+\tFractionFormat properFormat = null;\n+\tFractionFormat improperFormat = null;\n+\n+    protected Locale getLocale() {\n+        return Locale.getDefault();\n+    }\n+\n+\tprotected void setUp() throws Exception {\n+\t\tproperFormat = FractionFormat.getProperInstance(getLocale());\n+\t\timproperFormat = FractionFormat.getImproperInstance(getLocale());\n+\t}\n+   \n+    public void testFormat() {\n+        Fraction c = new Fraction(1, 2);\n+        String expected = \"1 / 2\";\n+        \n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n+\tpublic void testFormatNegative() {\n+        Fraction c = new Fraction(-1, 2);\n+        String expected = \"-1 / 2\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+\n+\tpublic void testFormatZero() {\n+        Fraction c = new Fraction(0, 1);\n+        String expected = \"0 / 1\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+\t}\n+    \n+    public void testFormatImproper() {\n+        Fraction c = new Fraction(5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"5 / 3\", actual);\n+    }\n+    \n+    public void testFormatImproperNegative() {\n+        Fraction c = new Fraction(-5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"-1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"-5 / 3\", actual);\n+    }\n+    \n+    public void testParse() {\n+        String source = \"1 / 2\";\n+\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNegative() {\n+\n+        try {\n+            String source = \"-1 / 2\";\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+\n+            source = \"1 / -2\";\n+            c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseProper() {\n+        String source = \"1 2 / 3\";\n+\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(5, c.getNumerator());\n+            assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperNegative() {\n+        String source = \"-1 2 / 3\";\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-5, c.getNumerator());\n+            assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/fraction/FractionTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: $ $Date: $\n+ */\n+public class FractionTest extends TestCase {\n+\n+    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {\n+        assertEquals(expectedNumerator, actual.getNumerator());\n+        assertEquals(expectedDenominator, actual.getDenominator());\n+    }\n+    \n+    public void testConstructor() {\n+        assertFraction(0, 1, new Fraction(0, 1));\n+        assertFraction(0, 1, new Fraction(0, 2));\n+        assertFraction(0, 1, new Fraction(0, -1));\n+        assertFraction(1, 2, new Fraction(1, 2));\n+        assertFraction(1, 2, new Fraction(2, 4));\n+        assertFraction(-1, 2, new Fraction(-1, 2));\n+        assertFraction(-1, 2, new Fraction(1, -2));\n+        assertFraction(-1, 2, new Fraction(-2, 4));\n+        assertFraction(-1, 2, new Fraction(2, -4));\n+    }\n+    \n+    public void testConstructorDouble() {\n+        try {\n+            assertFraction(1, 2, new Fraction(0.5));\n+            assertFraction(1, 3, new Fraction(1.0 / 3.0));\n+            assertFraction(17, 100, new Fraction(17.0 / 100.0));\n+            assertFraction(317, 100, new Fraction(317.0 / 100.0));\n+            assertFraction(-1, 2, new Fraction(-0.5));\n+            assertFraction(-1, 3, new Fraction(-1.0 / 3.0));\n+            assertFraction(-17, 100, new Fraction(17.0 / -100.0));\n+            assertFraction(-317, 100, new Fraction(-317.0 / 100.0));\n+        } catch (ConvergenceException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testAbs() {\n+        Fraction a = new Fraction(10, 21);\n+        Fraction b = new Fraction(-10, 21);\n+        Fraction c = new Fraction(10, -21);\n+        \n+        assertFraction(10, 21, a.abs());\n+        assertFraction(10, 21, b.abs());\n+        assertFraction(10, 21, c.abs());\n+    }\n+    \n+    public void testAdd() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 1, a.add(a));\n+        assertFraction(7, 6, a.add(b));\n+        assertFraction(7, 6, b.add(a));\n+        assertFraction(4, 3, b.add(b));\n+    }\n+    \n+    public void testDivide() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 1, a.divide(a));\n+        assertFraction(3, 4, a.divide(b));\n+        assertFraction(4, 3, b.divide(a));\n+        assertFraction(1, 1, b.divide(b));\n+    }\n+    \n+    public void testMultiply() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 4, a.multiply(a));\n+        assertFraction(1, 3, a.multiply(b));\n+        assertFraction(1, 3, b.multiply(a));\n+        assertFraction(4, 9, b.multiply(b));\n+    }\n+    \n+    public void testSubtract() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(0, 1, a.subtract(a));\n+        assertFraction(-1, 6, a.subtract(b));\n+        assertFraction(1, 6, b.subtract(a));\n+        assertFraction(0, 1, b.subtract(b));\n+    }\n+}\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n /*\n- * Copyright 2003-2004 The Apache Software Foundation.\n+ * Copyright 2003-2005 The Apache Software Foundation.\n  * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n /**\n  * Test cases for the MathUtils class.\n  *\n- * @version $Revision: 1.15 $ $Date: 2004/10/14 04:01:04 $\n+ * @version $Revision: 1.15 $ $Date$\n  */\n-\n public final class MathUtilsTest extends TestCase {\n \n     public MathUtilsTest(String name) {\n             }\n         } \n     }\n+    \n+    public void testGcd() {\n+        int a = 30;\n+        int b = 50;\n+        int c = 77;\n+\n+        assertEquals(0, MathUtils.gcd(0, 0));\n+        \n+        assertEquals(b, MathUtils.gcd( 0,  b));\n+        assertEquals(a, MathUtils.gcd( a,  0));\n+        assertEquals(b, MathUtils.gcd( 0, -b));\n+        assertEquals(a, MathUtils.gcd(-a,  0));\n+        \n+        assertEquals(10, MathUtils.gcd( a,  b));\n+        assertEquals(10, MathUtils.gcd(-a,  b));\n+        assertEquals(10, MathUtils.gcd( a, -b));\n+        assertEquals(10, MathUtils.gcd(-a, -b));\n+        \n+        assertEquals(1, MathUtils.gcd( a,  c));\n+        assertEquals(1, MathUtils.gcd(-a,  c));\n+        assertEquals(1, MathUtils.gcd( a, -c));\n+        assertEquals(1, MathUtils.gcd(-a, -c));\n+    }\n+    \n+    public void testLcm() {\n+        int a = 30;\n+        int b = 50;\n+        int c = 77;\n+        \n+        assertEquals(0, MathUtils.lcm(0, b));\n+        assertEquals(0, MathUtils.lcm(a, 0));\n+        assertEquals(b, MathUtils.lcm(1, b));\n+        assertEquals(a, MathUtils.lcm(a, 1));\n+        assertEquals(150, MathUtils.lcm(a, b));\n+        assertEquals(150, MathUtils.lcm(-a, b));\n+        assertEquals(150, MathUtils.lcm(a, -b));\n+        assertEquals(2310, MathUtils.lcm(a, c));\n+    }\n }", "timestamp": 1107582585, "metainfo": ""}