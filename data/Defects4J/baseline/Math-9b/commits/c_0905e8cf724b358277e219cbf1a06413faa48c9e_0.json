{"sha": "0905e8cf724b358277e219cbf1a06413faa48c9e", "log": "tighten checkstyle rules: declaring multiple variables in one statement is now forbidden  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n                             final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n \n-        int i = 1;\n-        double s, olds, t, oldt;\n-\n         clearResult();\n         verifyInterval(min, max);\n         verifyIterationCount();\n \n         TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n         if (minimalIterationCount == 1) {\n-            s = (4 * qtrap.stage(f, min, max, 1) - qtrap.stage(f, min, max, 0)) / 3.0;\n+            final double s = (4 * qtrap.stage(f, min, max, 1) - qtrap.stage(f, min, max, 0)) / 3.0;\n             setResult(s, 1);\n             return result;\n         }\n         // Simpson's rule requires at least two trapezoid stages.\n-        olds = 0;\n-        oldt = qtrap.stage(f, min, max, 0);\n-        while (i <= maximalIterationCount) {\n-            t = qtrap.stage(f, min, max, i);\n-            s = (4 * t - oldt) / 3.0;\n+        double olds = 0;\n+        double oldt = qtrap.stage(f, min, max, 0);\n+        for (int i = 1; i <= maximalIterationCount; ++i) {\n+            final double t = qtrap.stage(f, min, max, i);\n+            final double s = (4 * t - oldt) / 3.0;\n             if (i >= minimalIterationCount) {\n                 final double delta = Math.abs(s - olds);\n                 final double rLimit =\n             }\n             olds = s;\n             oldt = t;\n-            i++;\n         }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n                  final double min, final double max, final int n)\n         throws FunctionEvaluationException {\n \n-        long i, np;\n-        double x, spacing, sum = 0;\n-\n         if (n == 0) {\n             s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n             return s;\n         } else {\n-            np = 1L << (n-1);           // number of new points in this stage\n-            spacing = (max - min) / np; // spacing between adjacent new points\n-            x = min + 0.5 * spacing;    // the first new point\n-            for (i = 0; i < np; i++) {\n+            final long np = 1L << (n-1);           // number of new points in this stage\n+            double sum = 0;\n+            final double spacing = (max - min) / np; // spacing between adjacent new points\n+            double x = min + 0.5 * spacing;    // the first new point\n+            for (long i = 0; i < np; i++) {\n                 sum += f.value(x);\n                 x += spacing;\n             }\n                             final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n \n-        int i = 1;\n-        double t, oldt;\n-\n         clearResult();\n         verifyInterval(min, max);\n         verifyIterationCount();\n \n-        oldt = stage(f, min, max, 0);\n-        while (i <= maximalIterationCount) {\n-            t = stage(f, min, max, i);\n+        double oldt = stage(f, min, max, 0);\n+        for (int i = 1; i <= maximalIterationCount; ++i) {\n+            final double t = stage(f, min, max, i);\n             if (i >= minimalIterationCount) {\n                 final double delta = Math.abs(t - oldt);\n                 final double rLimit =\n                 }\n             }\n             oldt = t;\n-            i++;\n         }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n          * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n          *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\n          */\n-        double a[], c[];\n-\n         PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n \n         /**\n          * <p>\n          * Note x[], y[], a[] have the same length but c[]'s size is one less.</p>\n          */\n-        c = new double[x.length-1];\n-        for (int i = 0; i < c.length; i++) {\n-            c[i] = x[i];\n-        }\n-        a = computeDividedDifference(x, y);\n+        final double[] c = new double[x.length-1];\n+        System.arraycopy(x, 0, c, 0, c.length);\n \n+        final double[] a = computeDividedDifference(x, y);\n         return new PolynomialFunctionNewtonForm(a, c);\n \n     }\n      * @return a fresh copy of the divided difference array\n      * @throws DuplicateSampleAbscissaException if any abscissas coincide\n      */\n-    protected static double[] computeDividedDifference(double x[], double y[])\n+    protected static double[] computeDividedDifference(final double x[], final double y[])\n         throws DuplicateSampleAbscissaException {\n-\n-        int i, j, n;\n-        double divdiff[], a[], denominator;\n \n         PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n \n-        n = x.length;\n-        divdiff = new double[n];\n-        for (i = 0; i < n; i++) {\n-            divdiff[i] = y[i];      // initialization\n-        }\n+        final double[] divdiff = y.clone(); // initialization\n \n-        a = new double [n];\n+        final int n = x.length;\n+        final double[] a = new double [n];\n         a[0] = divdiff[0];\n-        for (i = 1; i < n; i++) {\n-            for (j = 0; j < n-i; j++) {\n-                denominator = x[j+i] - x[j];\n+        for (int i = 1; i < n; i++) {\n+            for (int j = 0; j < n-i; j++) {\n+                final double denominator = x[j+i] - x[j];\n                 if (denominator == 0.0) {\n                     // This happens only when two abscissas are identical.\n                     throw new DuplicateSampleAbscissaException(x[j], j, j+i);\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n                 // and http://en.wikipedia.org/wiki/Weighted_least_squares\n                 // (section \"Weighted least squares\")\n                 double sumWeights = 0;\n-                double sumX = 0, sumXSquared = 0, sumY = 0, sumXY = 0;\n+                double sumX = 0;\n+                double sumXSquared = 0;\n+                double sumY = 0;\n+                double sumXY = 0;\n                 double denom = Math.abs(1.0 / (xval[edge] - x));\n                 for (int k = ileft; k <= iright; ++k) {\n                     final double xk   = xval[k];\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n \n         // Copy data samples.\n         samples = new HashMap<RealVector, Double>(yval.length);\n-        for (int i = 0, max = xval.length; i < max; i++) {\n-            if (xval[i].length != dimension) {\n-                throw new DimensionMismatchException(xval.length, yval.length);\n-            }\n-\n-            samples.put(new ArrayRealVector(xval[i]), yval[i]);\n+        for (int i = 0; i < xval.length; ++i) {\n+            final double[] xvalI = xval[i];\n+            if ( xvalI.length != dimension) {\n+                throw new DimensionMismatchException(xvalI.length, dimension);\n+            }\n+\n+            samples.put(new ArrayRealVector(xvalI), yval[i]);\n         }\n \n         microsphere = new ArrayList<MicrosphereSurfaceElement>(microsphereElements);\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n     private double coefficients[];\n \n     /**\n-     * Interpolating points (abscissas) and the function values at these points.\n-     */\n-    private double x[], y[];\n+     * Interpolating points (abscissas).\n+     */\n+    private double x[];\n+\n+    /**\n+     * Function values at interpolating points.\n+     */\n+    private double y[];\n \n     /**\n      * Whether the polynomial coefficients are available.\n     public static double evaluate(double x[], double y[], double z) throws\n         DuplicateSampleAbscissaException, IllegalArgumentException {\n \n-        int i, j, n, nearest = 0;\n-        double value, c[], d[], tc, td, divider, w, dist, min_dist;\n-\n         verifyInterpolationArray(x, y);\n \n-        n = x.length;\n-        c = new double[n];\n-        d = new double[n];\n-        min_dist = Double.POSITIVE_INFINITY;\n-        for (i = 0; i < n; i++) {\n+        int nearest = 0;\n+        final int n = x.length;\n+        final double[] c = new double[n];\n+        final double[] d = new double[n];\n+        double min_dist = Double.POSITIVE_INFINITY;\n+        for (int i = 0; i < n; i++) {\n             // initialize the difference arrays\n             c[i] = y[i];\n             d[i] = y[i];\n             // find out the abscissa closest to z\n-            dist = Math.abs(z - x[i]);\n+            final double dist = Math.abs(z - x[i]);\n             if (dist < min_dist) {\n                 nearest = i;\n                 min_dist = dist;\n         }\n \n         // initial approximation to the function value at z\n-        value = y[nearest];\n-\n-        for (i = 1; i < n; i++) {\n-            for (j = 0; j < n-i; j++) {\n-                tc = x[j] - z;\n-                td = x[i+j] - z;\n-                divider = x[j] - x[i+j];\n+        double value = y[nearest];\n+\n+        for (int i = 1; i < n; i++) {\n+            for (int j = 0; j < n-i; j++) {\n+                final double tc = x[j] - z;\n+                final double td = x[i+j] - z;\n+                final double divider = x[j] - x[i+j];\n                 if (divider == 0.0) {\n                     // This happens only when two abscissas are identical.\n                     throw new DuplicateSampleAbscissaException(x[i], i, i+j);\n                 }\n                 // update the difference arrays\n-                w = (c[j+1] - d[j]) / divider;\n+                final double w = (c[j+1] - d[j]) / divider;\n                 c[j] = tc * w;\n                 d[j] = td * w;\n             }\n      * @throws ArithmeticException if any abscissas coincide\n      */\n     protected void computeCoefficients() throws ArithmeticException {\n-        int i, j, n;\n-        double c[], tc[], d, t;\n-\n-        n = degree() + 1;\n+\n+        final int n = degree() + 1;\n         coefficients = new double[n];\n-        for (i = 0; i < n; i++) {\n+        for (int i = 0; i < n; i++) {\n             coefficients[i] = 0.0;\n         }\n \n         // c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])\n-        c = new double[n+1];\n+        final double[] c = new double[n+1];\n         c[0] = 1.0;\n-        for (i = 0; i < n; i++) {\n-            for (j = i; j > 0; j--) {\n+        for (int i = 0; i < n; i++) {\n+            for (int j = i; j > 0; j--) {\n                 c[j] = c[j-1] - c[j] * x[i];\n             }\n             c[0] *= -x[i];\n             c[i+1] = 1;\n         }\n \n-        tc = new double[n];\n-        for (i = 0; i < n; i++) {\n+        final double[] tc = new double[n];\n+        for (int i = 0; i < n; i++) {\n             // d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])\n-            d = 1;\n-            for (j = 0; j < n; j++) {\n+            double d = 1;\n+            for (int j = 0; j < n; j++) {\n                 if (i != j) {\n                     d *= x[i] - x[j];\n                 }\n                     }\n                 }\n             }\n-            t = y[i] / d;\n+            final double t = y[i] / d;\n             // Lagrange polynomial is the sum of n terms, each of which is a\n             // polynomial of degree n-1. tc[] are the coefficients of the i-th\n             // numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).\n             tc[n-1] = c[n];     // actually c[n] = 1\n             coefficients[n-1] += t * tc[n-1];\n-            for (j = n-2; j >= 0; j--) {\n+            for (int j = n-2; j >= 0; j--) {\n                 tc[j] = c[j+1] + tc[j+1] * x[i];\n                 coefficients[j] += t * tc[j];\n             }\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n     private double coefficients[];\n \n     /**\n-     * Members of c[] are called centers of the Newton polynomial.\n+     * Centers of the Newton polynomial.\n+     */\n+    private double c[];\n+\n+    /**\n      * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n      * i.e. a[i] = coefficients[i].\n      */\n-    private double a[], c[];\n+    private double a[];\n \n     /**\n      * Whether the polynomial coefficients are available.\n      * It also uses nested multiplication but takes O(N^2) time.\n      */\n     protected void computeCoefficients() {\n-        int i, j, n = degree();\n+        final int n = degree();\n \n         coefficients = new double[n+1];\n-        for (i = 0; i <= n; i++) {\n+        for (int i = 0; i <= n; i++) {\n             coefficients[i] = 0.0;\n         }\n \n         coefficients[0] = a[n];\n-        for (i = n-1; i >= 0; i--) {\n-            for (j = n-i; j > 0; j--) {\n+        for (int i = n-1; i >= 0; i--) {\n+            for (int j = n-i; j > 0; j--) {\n                 coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];\n             }\n             coefficients[0] = a[i] - c[i] * coefficients[0];\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n         // x1 is the last approximation and an interpolation point in (x0, x2)\n         // x is the new root approximation and new x1 for next round\n         // d01, d12, d012 are divided differences\n-        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n-        double d01, d12, d012, c1, delta, xplus, xminus, tolerance;\n-\n-        x0 = min; y0 = f.value(x0);\n-        x2 = max; y2 = f.value(x2);\n-        x1 = 0.5 * (x0 + x2); y1 = f.value(x1);\n+\n+        double x0 = min;\n+        double y0 = f.value(x0);\n+        double x2 = max;\n+        double y2 = f.value(x2);\n+        double x1 = 0.5 * (x0 + x2);\n+        double y1 = f.value(x1);\n \n         // check for zeros before verifying bracketing\n-        if (y0 == 0.0) { return min; }\n-        if (y2 == 0.0) { return max; }\n+        if (y0 == 0.0) {\n+            return min;\n+        }\n+        if (y2 == 0.0) {\n+            return max;\n+        }\n         verifyBracketing(min, max, f);\n \n-        int i = 1;\n-        oldx = Double.POSITIVE_INFINITY;\n-        while (i <= maximalIterationCount) {\n+        double oldx = Double.POSITIVE_INFINITY;\n+        for (int i = 1; i <= maximalIterationCount; ++i) {\n             // Muller's method employs quadratic interpolation through\n             // x0, x1, x2 and x is the zero of the interpolating parabola.\n             // Due to bracketing condition, this parabola must have two\n             // real roots and we choose one in [x0, x2] to be x.\n-            d01 = (y1 - y0) / (x1 - x0);\n-            d12 = (y2 - y1) / (x2 - x1);\n-            d012 = (d12 - d01) / (x2 - x0);\n-            c1 = d01 + (x1 - x0) * d012;\n-            delta = c1 * c1 - 4 * y1 * d012;\n-            xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n-            xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n+            final double d01 = (y1 - y0) / (x1 - x0);\n+            final double d12 = (y2 - y1) / (x2 - x1);\n+            final double d012 = (d12 - d01) / (x2 - x0);\n+            final double c1 = d01 + (x1 - x0) * d012;\n+            final double delta = c1 * c1 - 4 * y1 * d012;\n+            final double xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n+            final double xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n             // xplus and xminus are two roots of parabola and at least\n             // one of them should lie in (x0, x2)\n-            x = isSequence(x0, xplus, x2) ? xplus : xminus;\n-            y = f.value(x);\n+            final double x = isSequence(x0, xplus, x2) ? xplus : xminus;\n+            final double y = f.value(x);\n \n             // check for convergence\n-            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n             if (Math.abs(x - oldx) <= tolerance) {\n                 setResult(x, i);\n                 return result;\n                 y1 = f.value(x1);\n                 oldx = Double.POSITIVE_INFINITY;\n             }\n-            i++;\n         }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n         // x2 is the last root approximation\n         // x is the new approximation and new x2 for next round\n         // x0 < x1 < x2 does not hold here\n-        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n-        double q, A, B, C, delta, denominator, tolerance;\n-\n-        x0 = min; y0 = f.value(x0);\n-        x1 = max; y1 = f.value(x1);\n-        x2 = 0.5 * (x0 + x1); y2 = f.value(x2);\n+\n+        double x0 = min;\n+        double y0 = f.value(x0);\n+        double x1 = max;\n+        double y1 = f.value(x1);\n+        double x2 = 0.5 * (x0 + x1);\n+        double y2 = f.value(x2);\n \n         // check for zeros before verifying bracketing\n         if (y0 == 0.0) { return min; }\n         if (y1 == 0.0) { return max; }\n         verifyBracketing(min, max, f);\n \n-        int i = 1;\n-        oldx = Double.POSITIVE_INFINITY;\n-        while (i <= maximalIterationCount) {\n+        double oldx = Double.POSITIVE_INFINITY;\n+        for (int i = 1; i <= maximalIterationCount; ++i) {\n             // quadratic interpolation through x0, x1, x2\n-            q = (x2 - x1) / (x1 - x0);\n-            A = q * (y2 - (1 + q) * y1 + q * y0);\n-            B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n-            C = (1 + q) * y2;\n-            delta = B * B - 4 * A * C;\n+            final double q = (x2 - x1) / (x1 - x0);\n+            final double a = q * (y2 - (1 + q) * y1 + q * y0);\n+            final double b = (2 * q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n+            final double c = (1 + q) * y2;\n+            final double delta = b * b - 4 * a * c;\n+            double x;\n+            final double denominator;\n             if (delta >= 0.0) {\n                 // choose a denominator larger in magnitude\n-                double dplus = B + Math.sqrt(delta);\n-                double dminus = B - Math.sqrt(delta);\n+                double dplus = b + Math.sqrt(delta);\n+                double dminus = b - Math.sqrt(delta);\n                 denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;\n             } else {\n                 // take the modulus of (B +/- Math.sqrt(delta))\n-                denominator = Math.sqrt(B * B - delta);\n+                denominator = Math.sqrt(b * b - delta);\n             }\n             if (denominator != 0) {\n-                x = x2 - 2.0 * C * (x2 - x1) / denominator;\n+                x = x2 - 2.0 * c * (x2 - x1) / denominator;\n                 // perturb x if it exactly coincides with x1 or x2\n                 // the equality tests here are intentional\n                 while (x == x1 || x == x2) {\n                 x = min + Math.random() * (max - min);\n                 oldx = Double.POSITIVE_INFINITY;\n             }\n-            y = f.value(x);\n+            final double y = f.value(x);\n \n             // check for convergence\n-            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n             if (Math.abs(x - oldx) <= tolerance) {\n                 setResult(x, i);\n                 return result;\n             }\n \n             // prepare the next iteration\n-            x0 = x1; y0 = y1;\n-            x1 = x2; y1 = y2;\n-            x2 = x; y2 = y;\n+            x0 = x1;\n+            y0 = y1;\n+            x1 = x2;\n+            y1 = y2;\n+            x2 = x;\n+            y2 = y;\n             oldx = x;\n-            i++;\n         }\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n         // [x1, x2] is the bracketing interval in each iteration\n         // x3 is the midpoint of [x1, x2]\n         // x is the new root approximation and an endpoint of the new interval\n-        double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;\n-\n-        x1 = min; y1 = f.value(x1);\n-        x2 = max; y2 = f.value(x2);\n+        double x1 = min;\n+        double y1 = f.value(x1);\n+        double x2 = max;\n+        double y2 = f.value(x2);\n \n         // check for zeros before verifying bracketing\n-        if (y1 == 0.0) { return min; }\n-        if (y2 == 0.0) { return max; }\n+        if (y1 == 0.0) {\n+            return min;\n+        }\n+        if (y2 == 0.0) {\n+            return max;\n+        }\n         verifyBracketing(min, max, f);\n \n         int i = 1;\n-        oldx = Double.POSITIVE_INFINITY;\n+        double oldx = Double.POSITIVE_INFINITY;\n         while (i <= maximalIterationCount) {\n             // calculate the new root approximation\n-            x3 = 0.5 * (x1 + x2);\n-            y3 = f.value(x3);\n+            final double x3 = 0.5 * (x1 + x2);\n+            final double y3 = f.value(x3);\n             if (Math.abs(y3) <= functionValueAccuracy) {\n                 setResult(x3, i);\n                 return result;\n             }\n-            delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n-            correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n-                         (x3 - x1) / Math.sqrt(delta);\n-            x = x3 - correction;                // correction != 0\n-            y = f.value(x);\n+            final double delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n+            final double correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n+                                      (x3 - x1) / Math.sqrt(delta);\n+            final double x = x3 - correction;                // correction != 0\n+            final double y = f.value(x);\n \n             // check for convergence\n-            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            final double tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n             if (Math.abs(x - oldx) <= tolerance) {\n                 setResult(x, i);\n                 return result;\n             // Ridders' method guarantees x1 < x < x2\n             if (correction > 0.0) {             // x1 < x < x3\n                 if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {\n-                    x2 = x; y2 = y;\n+                    x2 = x;\n+                    y2 = y;\n                 } else {\n-                    x1 = x; x2 = x3;\n-                    y1 = y; y2 = y3;\n+                    x1 = x;\n+                    x2 = x3;\n+                    y1 = y;\n+                    y2 = y3;\n                 }\n             } else {                            // x3 < x < x2\n                 if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {\n-                    x1 = x; y1 = y;\n+                    x1 = x;\n+                    y1 = y;\n                 } else {\n-                    x1 = x3; x2 = x;\n-                    y1 = y3; y2 = y;\n+                    x1 = x3;\n+                    x2 = x;\n+                    y1 = y3;\n+                    y2 = y;\n                 }\n             }\n             oldx = x;\n--- a/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n     protected void updateJacobian() {\n         incrementJacobianEvaluationsCounter();\n         Arrays.fill(jacobian, 0);\n-        for (int i = 0, index = 0; i < rows; i++) {\n+        int index = 0;\n+        for (int i = 0; i < rows; i++) {\n             WeightedMeasurement wm = measurements[i];\n             double factor = -Math.sqrt(wm.getWeight());\n             for (int j = 0; j < cols; ++j) {\n         }\n \n         cost = 0;\n-        for (int i = 0, index = 0; i < rows; i++, index += cols) {\n+        int index = 0;\n+        for (int i = 0; i < rows; i++, index += cols) {\n             WeightedMeasurement wm = measurements[i];\n             double residual = wm.getResidual();\n             residuals[i] = Math.sqrt(wm.getWeight()) * residual;\n--- a/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n     lmDir       = new double[cols];\n \n     // local variables\n-    double   delta   = 0, xNorm = 0;\n+    double   delta   = 0;\n+    double   xNorm = 0;\n     double[] diag    = new double[cols];\n     double[] oldX    = new double[cols];\n     double[] oldRes  = new double[rows];\n           double s  = jacNorm[pj];\n           if (s != 0) {\n             double sum = 0;\n-            for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+            int index = pj;\n+            for (int i = 0; i <= j; ++i) {\n               sum += jacobian[index] * residuals[i];\n+              index += cols;\n             }\n             maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n           }\n           int pj = permutation[j];\n           double dirJ = lmDir[pj];\n           work1[j] = 0;\n-          for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+          int index = pj;\n+          for (int i = 0; i <= j; ++i) {\n             work1[i] += jacobian[index] * dirJ;\n+            index += cols;\n           }\n         }\n         double coeff1 = 0;\n     for (int k = rank - 1; k >= 0; --k) {\n       int pk = permutation[k];\n       double ypk = lmDir[pk] / diagR[pk];\n-      for (int i = 0, index = pk; i < k; ++i, index += cols) {\n+      int index = pk;\n+      for (int i = 0; i < k; ++i) {\n         lmDir[permutation[i]] -= ypk * jacobian[index];\n+        index += cols;\n       }\n       lmDir[pk] = ypk;\n     }\n     // if the jacobian is not rank deficient, the Newton step provides\n     // a lower bound, parl, for the zero of the function,\n     // otherwise set this bound to zero\n-    double sum2, parl = 0;\n+    double sum2;\n+    double parl = 0;\n     if (rank == solvedCols) {\n       for (int j = 0; j < solvedCols; ++j) {\n         int pj = permutation[j];\n       for (int j = 0; j < solvedCols; ++j) {\n         int pj = permutation[j];\n         double sum = 0;\n-        for (int i = 0, index = pj; i < j; ++i, index += cols) {\n+        int index = pj;\n+        for (int i = 0; i < j; ++i) {\n           sum += jacobian[index] * work1[permutation[i]];\n+          index += cols;\n         }\n         double s = (work1[pj] - sum) / diagR[pj];\n         work1[pj] = s;\n     for (int j = 0; j < solvedCols; ++j) {\n       int pj = permutation[j];\n       double sum = 0;\n-      for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+      int index = pj;\n+      for (int i = 0; i <= j; ++i) {\n         sum += jacobian[index] * qy[i];\n+        index += cols;\n       }\n       sum /= diag[pj];\n       sum2 += sum * sum;\n         // appropriate element in the current row of d\n         if (lmDiag[k] != 0) {\n \n-          double sin, cos;\n+          final double sin;\n+          final double cos;\n           double rkk = jacobian[k * cols + pk];\n           if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n-            double cotan = rkk / lmDiag[k];\n+            final double cotan = rkk / lmDiag[k];\n             sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n             cos   = sin * cotan;\n           } else {\n-            double tan = lmDiag[k] / rkk;\n+            final double tan = lmDiag[k] / rkk;\n             cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n             sin = cos * tan;\n           }\n           // compute the modified diagonal element of R and\n           // the modified element of (Qty,0)\n           jacobian[k * cols + pk] = cos * rkk + sin * lmDiag[k];\n-          double temp = cos * work[k] + sin * qtbpj;\n+          final double temp = cos * work[k] + sin * qtbpj;\n           qtbpj = -sin * work[k] + cos * qtbpj;\n           work[k] = temp;\n \n           // accumulate the tranformation in the row of s\n           for (int i = k + 1; i < solvedCols; ++i) {\n             double rik = jacobian[i * cols + pk];\n-            temp = cos * rik + sin * lmDiag[i];\n+            final double temp2 = cos * rik + sin * lmDiag[i];\n             lmDiag[i] = -sin * rik + cos * lmDiag[i];\n-            jacobian[i * cols + pk] = temp;\n+            jacobian[i * cols + pk] = temp2;\n           }\n \n         }\n       int pk = permutation[k];\n       int kDiag = k * cols + pk;\n       double gamma = 0;\n-      for (int i = k, index = kDiag; i < rows; ++i, index += cols) {\n+      int index = kDiag;\n+      for (int i = k; i < rows; ++i) {\n         gamma += jacobian[index] * y[i];\n+        index += cols;\n       }\n       gamma *= beta[pk];\n-      for (int i = k, index = kDiag; i < rows; ++i, index += cols) {\n+      index = kDiag;\n+      for (int i = k; i < rows; ++i) {\n         y[i] -= gamma * jacobian[index];\n+        index += cols;\n       }\n     }\n   }\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n         // convert array\n         final Field<T> field = extractField(rawData);\n         final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n             final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n                 blocks[blockIndex] = block;\n \n                 // copy data\n-                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                int index = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n                     System.arraycopy(rawData[p], qStart, block, index, jWidth);\n-                }\n+                    index += jWidth;\n+                }\n+\n+                ++blockIndex;\n \n             }\n         }\n         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n         final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n             final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n                 blocks[blockIndex] = buildArray(field, iHeight * jWidth);\n+                ++blockIndex;\n             }\n         }\n \n                     final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n                     final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n-                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                    int k = 0;\n+                    for (int p = pStart; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q) {\n                             outBlock[k] = tBlock[k].add(m.getEntry(p, q));\n+                            ++k;\n                         }\n                     }\n \n                     final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n                     final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n-                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                    int k = 0;\n+                    for (int p = pStart; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q) {\n                             outBlock[k] = tBlock[k].subtract(m.getEntry(p, q));\n+                            ++k;\n                         }\n                     }\n \n                         final int kWidth      = blockWidth(kBlock);\n                         final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                         final int rStart      = kBlock * BLOCK_SIZE;\n-                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        int k = 0;\n+                        for (int p = pStart; p < pEnd; ++p) {\n                             final int lStart = (p - pStart) * kWidth;\n                             final int lEnd   = lStart + kWidth;\n                             for (int q = qStart; q < qEnd; ++q) {\n                                 T sum = zero;\n-                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                int r = rStart;\n+                                for (int l = lStart; l < lEnd; ++l) {\n                                     sum = sum.add(tBlock[l].multiply(m.getEntry(r, q)));\n+                                    ++r;\n                                 }\n                                 outBlock[k] = outBlock[k].add(sum);\n                                 ++k;\n                     final int kWidth = blockWidth(kBlock);\n                     final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                     final T[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n-                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    int k = 0;\n+                    for (int p = pStart; p < pEnd; ++p) {\n                         final int lStart = (p - pStart) * kWidth;\n                         final int lEnd   = lStart + kWidth;\n                         for (int nStart = 0; nStart < jWidth; ++nStart) {\n         final int columnsShift     = startColumn % BLOCK_SIZE;\n \n         // perform extraction block-wise, to ensure good cache behavior\n-        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+        int pBlock = blockStartRow;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n             final int iHeight = out.blockHeight(iBlock);\n-            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+            int qBlock = blockStartColumn;\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                 final int jWidth = out.blockWidth(jBlock);\n \n                 // handle one block of the output matrix\n                     }\n                }\n \n-            }\n+                ++qBlock;\n+            }\n+\n+            ++pBlock;\n+\n         }\n \n         return out;\n                 final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n                 final int      qStart   = jBlock * BLOCK_SIZE;\n                 final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n                     final int lInc = pEnd - pStart;\n-                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n-                        outBlock[k++] = tBlock[l];\n+                    int l = p - pStart;\n+                    for (int q = qStart; q < qEnd; ++q) {\n+                        outBlock[k] = tBlock[l];\n+                        ++k;\n+                        l+= lInc;\n                     }\n                 }\n \n                 final T[] block  = blocks[iBlock * blockColumns + jBlock];\n                 final int      qStart = jBlock * BLOCK_SIZE;\n                 final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n                     T sum = zero;\n                     int q = qStart;\n                     while (q < qEnd - 3) {\n                     final int qStart = jBlock * BLOCK_SIZE;\n                     final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                    int k = (p - pStart) * jWidth;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n                     final int qStart = jBlock * BLOCK_SIZE;\n                     final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                    int k = (p - pStart) * jWidth;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n                     final int qStart = Math.max(startColumn, q0);\n                     final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n                     final int qStart = Math.max(startColumn, q0);\n                     final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final T[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n     public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final T[] block = blocks[blockIndex];\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n-                    }\n-                }\n+                        ++k;\n+                    }\n+                }\n+                ++blockIndex;\n             }\n         }\n         return visitor.end();\n     public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final T[] block = blocks[blockIndex];\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n-                    }\n-                }\n+                        ++k;\n+                    }\n+                }\n+                ++blockIndex;\n             }\n         }\n         return visitor.end();\n                 final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final T[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n             }\n                 final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final T[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n \n         // convert array\n         final double[][] blocks = new double[blockRows * blockColumns][];\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n             final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n                 blocks[blockIndex] = block;\n \n                 // copy data\n-                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                int index = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n                     System.arraycopy(rawData[p], qStart, block, index, jWidth);\n-                }\n+                    index += jWidth;\n+                }\n+\n+                ++blockIndex;\n \n             }\n         }\n         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n         final double[][] blocks = new double[blockRows * blockColumns][];\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart  = iBlock * BLOCK_SIZE;\n             final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n             final int iHeight = pEnd - pStart;\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final int jWidth = qEnd - qStart;\n                 blocks[blockIndex] = new double[iHeight * jWidth];\n+                ++blockIndex;\n             }\n         }\n \n                     final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n                     final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n-                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                    int k = 0;\n+                    for (int p = pStart; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q) {\n                             outBlock[k] = tBlock[k] + m.getEntry(p, q);\n+                            ++k;\n                         }\n                     }\n \n                     final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n                     final int      qStart   = jBlock * BLOCK_SIZE;\n                     final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n-                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                    int k = 0;\n+                    for (int p = pStart; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q) {\n                             outBlock[k] = tBlock[k] - m.getEntry(p, q);\n+                            ++k;\n                         }\n                     }\n \n                         final int kWidth      = blockWidth(kBlock);\n                         final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                         final int rStart      = kBlock * BLOCK_SIZE;\n-                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        int k = 0;\n+                        for (int p = pStart; p < pEnd; ++p) {\n                             final int lStart = (p - pStart) * kWidth;\n                             final int lEnd   = lStart + kWidth;\n                             for (int q = qStart; q < qEnd; ++q) {\n                                 double sum = 0;\n-                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                int r = rStart;\n+                                for (int l = lStart; l < lEnd; ++l) {\n                                     sum += tBlock[l] * m.getEntry(r, q);\n+                                    ++r;\n                                 }\n-                                outBlock[k++] += sum;\n+                                outBlock[k] += sum;\n+                                ++k;\n                             }\n                         }\n                     }\n                     final int kWidth = blockWidth(kBlock);\n                     final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                     final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n-                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    int k = 0;\n+                    for (int p = pStart; p < pEnd; ++p) {\n                         final int lStart = (p - pStart) * kWidth;\n                         final int lEnd   = lStart + kWidth;\n                         for (int nStart = 0; nStart < jWidth; ++nStart) {\n                                 sum += tBlock[l++] * mBlock[n];\n                                 n += jWidth;\n                             }\n-                            outBlock[k++] += sum;\n+                            outBlock[k] += sum;\n+                            ++k;\n                         }\n                     }\n                 }\n         final int columnsShift     = startColumn % BLOCK_SIZE;\n \n         // perform extraction block-wise, to ensure good cache behavior\n-        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+        int pBlock = blockStartRow;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n             final int iHeight = out.blockHeight(iBlock);\n-            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+            int qBlock = blockStartColumn;\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                 final int jWidth = out.blockWidth(jBlock);\n \n                 // handle one block of the output matrix\n                     }\n                }\n \n-            }\n+                ++qBlock;\n+\n+            }\n+\n+            ++pBlock;\n+\n         }\n \n         return out;\n                 final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n                 final int      qStart   = jBlock * BLOCK_SIZE;\n                 final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n                     final int lInc = pEnd - pStart;\n-                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n-                        outBlock[k++] = tBlock[l];\n+                    int l = p - pStart;\n+                    for (int q = qStart; q < qEnd; ++q) {\n+                        outBlock[k] = tBlock[l];\n+                        ++k;\n+                        l+= lInc;\n                     }\n                 }\n \n                 final double[] block  = blocks[iBlock * blockColumns + jBlock];\n                 final int      qStart = jBlock * BLOCK_SIZE;\n                 final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n                     double sum = 0;\n                     int q = qStart;\n                     while (q < qEnd - 3) {\n                     final int qStart = jBlock * BLOCK_SIZE;\n                     final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                    int k = (p - pStart) * jWidth;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n                     final int qStart = jBlock * BLOCK_SIZE;\n                     final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                    int k = (p - pStart) * jWidth;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n                     final int qStart = Math.max(startColumn, q0);\n                     final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n                     final int qStart = Math.max(startColumn, q0);\n                     final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                     final double[] block = blocks[iBlock * blockColumns + jBlock];\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n              }\n     public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final double[] block = blocks[blockIndex];\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n-                    }\n-                }\n+                        ++k;\n+                    }\n+                }\n+                ++blockIndex;\n             }\n         }\n         return visitor.end();\n     public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n         throws MatrixVisitorException {\n         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n-        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n             final int pStart = iBlock * BLOCK_SIZE;\n             final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n-            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                 final int qStart = jBlock * BLOCK_SIZE;\n                 final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                 final double[] block = blocks[blockIndex];\n-                for (int p = pStart, k = 0; p < pEnd; ++p) {\n-                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                int k = 0;\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n-                    }\n-                }\n+                        ++k;\n+                    }\n+                }\n+                ++blockIndex;\n             }\n         }\n         return visitor.end();\n                 final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final double[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         block[k] = visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n             }\n                 final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n                 final double[] block = blocks[iBlock * blockColumns + jBlock];\n                 for (int p = pStart; p < pEnd; ++p) {\n-                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                    int k = (p - p0) * jWidth + qStart - q0;\n+                    for (int q = qStart; q < qEnd; ++q) {\n                         visitor.visit(p, q, block[k]);\n+                        ++k;\n                     }\n                 }\n             }\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n \n         // sort the realEigenvalues in decreasing order\n         Arrays.sort(realEigenvalues);\n-        for (int i = 0, j = realEigenvalues.length - 1; i < j; ++i, --j) {\n+        int j = realEigenvalues.length - 1;\n+        for (int i = 0; i < j; ++i) {\n             final double tmp = realEigenvalues[i];\n             realEigenvalues[i] = realEigenvalues[j];\n             realEigenvalues[j] = tmp;\n+            --j;\n         }\n \n     }\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            for (int i = 0, j = 4 * n - 1; i < j; i += 4, j -= 4) {\n+            int j = 4 * n - 1;\n+            for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n+                j -= 4;\n             }\n             return true;\n         }\n         // the least diagonal element in the twisted factorization\n         int r = m - 1;\n         double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n-        for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {\n+        int sixI = 0;\n+        for (int i = 0; i < m - 1; ++i) {\n             final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\n             if (absG < minG) {\n                 r = i;\n                 minG = absG;\n             }\n+            sixI += 6;\n         }\n \n         // solve the singular system by ignoring the equation\n                                                        final double lambda) {\n         final int nM1 = d.length - 1;\n         double si = -lambda;\n-        for (int i = 0, sixI = 0; i < nM1; ++i, sixI += 6) {\n+        int sixI = 0;\n+        for (int i = 0; i < nM1; ++i) {\n             final double di   = d[i];\n             final double li   = l[i];\n             final double diP1 = di + si;\n             work[sixI + 1]    = diP1;\n             work[sixI + 2]    = liP1;\n             si = li * liP1 * si - lambda;\n+            sixI += 6;\n         }\n         work[6 * nM1 + 1] = d[nM1] + si;\n         work[6 * nM1]     = si;\n                                                         final double lambda) {\n         final int nM1 = d.length - 1;\n         double pi = d[nM1] - lambda;\n-        for (int i = nM1 - 1, sixI = 6 * i; i >= 0; --i, sixI -= 6) {\n+        int sixI = 6 * (nM1 - 1);\n+        for (int i = nM1 - 1; i >= 0; --i) {\n             final double di   = d[i];\n             final double li   = l[i];\n             final double diP1 = di * li * li + pi;\n             work[sixI + 10]   = diP1;\n             work[sixI +  5]   = li * t;\n             pi = pi * t - lambda;\n+            sixI -= 6;\n         }\n         work[3] = pi;\n         work[4] = pi;\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n                     final double   factor = 1.0 / rDiag[j];\n                     final double[] yJ     = y[j];\n                     final double[] xBlock = xBlocks[jBlock * cBlocks + kBlock];\n-                    for (int k = 0, index = (j - jStart) * kWidth; k < kWidth; ++k, ++index) {\n-                        yJ[k]        *= factor;\n-                        xBlock[index] = yJ[k];\n+                    int index = (j - jStart) * kWidth;\n+                    for (int k = 0; k < kWidth; ++k) {\n+                        yJ[k]          *= factor;\n+                        xBlock[index++] = yJ[k];\n                     }\n \n                     final double[] qrtJ = qrt[j];\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n                                                   objective.length, rows);\n         }\n         cost = 0;\n-        for (int i = 0, index = 0; i < rows; i++, index += cols) {\n+        int index = 0;\n+        for (int i = 0; i < rows; i++) {\n             final double residual = targetValues[i] - objective[i];\n             residuals[i] = residual;\n             cost += residualsWeights[i] * residual * residual;\n+            index += cols;\n         }\n         cost = Math.sqrt(cost);\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n         lmDir       = new double[cols];\n \n         // local point\n-        double   delta   = 0, xNorm = 0;\n+        double   delta   = 0;\n+        double   xNorm   = 0;\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n         // if the jacobian is not rank deficient, the Newton step provides\n         // a lower bound, parl, for the zero of the function,\n         // otherwise set this bound to zero\n-        double sum2, parl = 0;\n+        double sum2;\n+        double parl = 0;\n         if (rank == solvedCols) {\n             for (int j = 0; j < solvedCols; ++j) {\n                 int pj = permutation[j];\n                 // appropriate element in the current row of d\n                 if (lmDiag[k] != 0) {\n \n-                    double sin, cos;\n+                    final double sin;\n+                    final double cos;\n                     double rkk = jacobian[k][pk];\n                     if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n-                        double cotan = rkk / lmDiag[k];\n+                        final double cotan = rkk / lmDiag[k];\n                         sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n                         cos   = sin * cotan;\n                     } else {\n-                        double tan = lmDiag[k] / rkk;\n+                        final double tan = lmDiag[k] / rkk;\n                         cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n                         sin = cos * tan;\n                     }\n                     // compute the modified diagonal element of R and\n                     // the modified element of (Qty,0)\n                     jacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n-                    double temp = cos * work[k] + sin * qtbpj;\n+                    final double temp = cos * work[k] + sin * qtbpj;\n                     qtbpj = -sin * work[k] + cos * qtbpj;\n                     work[k] = temp;\n \n                     // accumulate the tranformation in the row of s\n                     for (int i = k + 1; i < solvedCols; ++i) {\n                         double rik = jacobian[i][pk];\n-                        temp = cos * rik + sin * lmDiag[i];\n+                        final double temp2 = cos * rik + sin * lmDiag[i];\n                         lmDiag[i] = -sin * rik + cos * lmDiag[i];\n-                        jacobian[i][pk] = temp;\n+                        jacobian[i][pk] = temp2;\n                     }\n \n                 }\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n     protected double[] fct(double f[])\n         throws IllegalArgumentException {\n \n-        double A, B, C, F1, x[], F[] = new double[f.length];\n-\n-        int N = f.length - 1;\n-        if (!FastFourierTransformer.isPowerOf2(N)) {\n+        final double transformed[] = new double[f.length];\n+\n+        final int n = f.length - 1;\n+        if (!FastFourierTransformer.isPowerOf2(n)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"{0} is not a power of 2 plus one\",\n                     f.length);\n         }\n-        if (N == 1) {       // trivial case\n-            F[0] = 0.5 * (f[0] + f[1]);\n-            F[1] = 0.5 * (f[0] - f[1]);\n-            return F;\n+        if (n == 1) {       // trivial case\n+            transformed[0] = 0.5 * (f[0] + f[1]);\n+            transformed[1] = 0.5 * (f[0] - f[1]);\n+            return transformed;\n         }\n \n         // construct a new array and perform FFT on it\n-        x = new double[N];\n-        x[0] = 0.5 * (f[0] + f[N]);\n-        x[N >> 1] = f[N >> 1];\n-        F1 = 0.5 * (f[0] - f[N]);   // temporary variable for F[1]\n-        for (int i = 1; i < (N >> 1); i++) {\n-            A = 0.5 * (f[i] + f[N-i]);\n-            B = Math.sin(i * Math.PI / N) * (f[i] - f[N-i]);\n-            C = Math.cos(i * Math.PI / N) * (f[i] - f[N-i]);\n-            x[i] = A - B;\n-            x[N-i] = A + B;\n-            F1 += C;\n+        final double[] x = new double[n];\n+        x[0] = 0.5 * (f[0] + f[n]);\n+        x[n >> 1] = f[n >> 1];\n+        double t1 = 0.5 * (f[0] - f[n]);   // temporary variable for transformed[1]\n+        for (int i = 1; i < (n >> 1); i++) {\n+            final double a = 0.5 * (f[i] + f[n-i]);\n+            final double b = Math.sin(i * Math.PI / n) * (f[i] - f[n-i]);\n+            final double c = Math.cos(i * Math.PI / n) * (f[i] - f[n-i]);\n+            x[i] = a - b;\n+            x[n-i] = a + b;\n+            t1 += c;\n         }\n         FastFourierTransformer transformer = new FastFourierTransformer();\n         Complex y[] = transformer.transform(x);\n \n         // reconstruct the FCT result for the original array\n-        F[0] = y[0].getReal();\n-        F[1] = F1;\n-        for (int i = 1; i < (N >> 1); i++) {\n-            F[2*i] = y[i].getReal();\n-            F[2*i+1] = F[2*i-1] - y[i].getImaginary();\n-        }\n-        F[N] = y[N >> 1].getReal();\n-\n-        return F;\n+        transformed[0] = y[0].getReal();\n+        transformed[1] = t1;\n+        for (int i = 1; i < (n >> 1); i++) {\n+            transformed[2 * i]     = y[i].getReal();\n+            transformed[2 * i + 1] = transformed[2 * i - 1] - y[i].getImaginary();\n+        }\n+        transformed[n] = y[n >> 1].getReal();\n+\n+        return transformed;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n     protected Complex[] fft(Complex data[])\n         throws IllegalArgumentException {\n \n-        int i, j, k, m, N = data.length;\n-        Complex A, B, C, D, E, F, z, f[] = new Complex[N];\n+        final int n = data.length;\n+        final Complex f[] = new Complex[n];\n \n         // initial simple cases\n         verifyDataSet(data);\n-        if (N == 1) {\n+        if (n == 1) {\n             f[0] = data[0];\n             return f;\n         }\n-        if (N == 2) {\n+        if (n == 2) {\n             f[0] = data[0].add(data[1]);\n             f[1] = data[0].subtract(data[1]);\n             return f;\n         }\n \n         // permute original data array in bit-reversal order\n-        j = 0;\n-        for (i = 0; i < N; i++) {\n-            f[i] = data[j];\n-            k = N >> 1;\n-            while (j >= k && k > 0) {\n-                j -= k; k >>= 1;\n-            }\n-            j += k;\n+        int ii = 0;\n+        for (int i = 0; i < n; i++) {\n+            f[i] = data[ii];\n+            int k = n >> 1;\n+            while (ii >= k && k > 0) {\n+                ii -= k; k >>= 1;\n+            }\n+            ii += k;\n         }\n \n         // the bottom base-4 round\n-        for (i = 0; i < N; i += 4) {\n-            A = f[i].add(f[i+1]);\n-            B = f[i+2].add(f[i+3]);\n-            C = f[i].subtract(f[i+1]);\n-            D = f[i+2].subtract(f[i+3]);\n-            E = C.add(D.multiply(Complex.I));\n-            F = C.subtract(D.multiply(Complex.I));\n-            f[i] = A.add(B);\n-            f[i+2] = A.subtract(B);\n+        for (int i = 0; i < n; i += 4) {\n+            final Complex a = f[i].add(f[i+1]);\n+            final Complex b = f[i+2].add(f[i+3]);\n+            final Complex c = f[i].subtract(f[i+1]);\n+            final Complex d = f[i+2].subtract(f[i+3]);\n+            final Complex e1 = c.add(d.multiply(Complex.I));\n+            final Complex e2 = c.subtract(d.multiply(Complex.I));\n+            f[i] = a.add(b);\n+            f[i+2] = a.subtract(b);\n             // omegaCount indicates forward or inverse transform\n-            f[i+1] = roots.isForward() ? F : E;\n-            f[i+3] = roots.isForward() ? E : F;\n+            f[i+1] = roots.isForward() ? e2 : e1;\n+            f[i+3] = roots.isForward() ? e1 : e2;\n         }\n \n         // iterations from bottom to top take O(N*logN) time\n-        for (i = 4; i < N; i <<= 1) {\n-            m = N / (i<<1);\n-            for (j = 0; j < N; j += i<<1) {\n-                for (k = 0; k < i; k++) {\n+        for (int i = 4; i < n; i <<= 1) {\n+            final int m = n / (i<<1);\n+            for (int j = 0; j < n; j += i<<1) {\n+                for (int k = 0; k < i; k++) {\n                     //z = f[i+j+k].multiply(roots.getOmega(k*m));\n                     final int k_times_m = k*m;\n                     final double omega_k_times_m_real = roots.getOmegaReal(k_times_m);\n                     final double omega_k_times_m_imaginary = roots.getOmegaImaginary(k_times_m);\n                     //z = f[i+j+k].multiply(omega[k*m]);\n-                    z = new Complex(\n+                    final Complex z = new Complex(\n                         f[i+j+k].getReal() * omega_k_times_m_real -\n                         f[i+j+k].getImaginary() * omega_k_times_m_imaginary,\n                         f[i+j+k].getReal() * omega_k_times_m_imaginary +\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n      */\n     protected double[] fst(double f[]) throws IllegalArgumentException {\n \n-        double A, B, x[], F[] = new double[f.length];\n+        final double transformed[] = new double[f.length];\n \n         FastFourierTransformer.verifyDataSet(f);\n         if (f[0] != 0.0) {\n                     \"first element is not 0: {0}\",\n                     f[0]);\n         }\n-        int N = f.length;\n-        if (N == 1) {       // trivial case\n-            F[0] = 0.0;\n-            return F;\n+        final int n = f.length;\n+        if (n == 1) {       // trivial case\n+            transformed[0] = 0.0;\n+            return transformed;\n         }\n \n         // construct a new array and perform FFT on it\n-        x = new double[N];\n+        final double[] x = new double[n];\n         x[0] = 0.0;\n-        x[N >> 1] = 2.0 * f[N >> 1];\n-        for (int i = 1; i < (N >> 1); i++) {\n-            A = Math.sin(i * Math.PI / N) * (f[i] + f[N-i]);\n-            B = 0.5 * (f[i] - f[N-i]);\n-            x[i] = A + B;\n-            x[N-i] = A - B;\n+        x[n >> 1] = 2.0 * f[n >> 1];\n+        for (int i = 1; i < (n >> 1); i++) {\n+            final double a = Math.sin(i * Math.PI / n) * (f[i] + f[n-i]);\n+            final double b = 0.5 * (f[i] - f[n-i]);\n+            x[i]     = a + b;\n+            x[n - i] = a - b;\n         }\n         FastFourierTransformer transformer = new FastFourierTransformer();\n         Complex y[] = transformer.transform(x);\n \n         // reconstruct the FST result for the original array\n-        F[0] = 0.0;\n-        F[1] = 0.5 * y[0].getReal();\n-        for (int i = 1; i < (N >> 1); i++) {\n-            F[2*i] = -y[i].getImaginary();\n-            F[2*i+1] = y[i].getReal() + F[2*i-1];\n-        }\n-\n-        return F;\n+        transformed[0] = 0.0;\n+        transformed[1] = 0.5 * y[0].getReal();\n+        for (int i = 1; i < (n >> 1); i++) {\n+            transformed[2 * i]     = -y[i].getImaginary();\n+            transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1];\n+        }\n+\n+        return transformed;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n         long result = 1;\n         if (n <= 61) {\n             // For n <= 61, the naive implementation cannot overflow.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n                 result = result * i / j;\n+                i++;\n             }\n         } else if (n <= 66) {\n             // For n > 61 but n <= 66, the result cannot overflow,\n             // but we must take care not to overflow intermediate values.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n                 // We know that (result * i) is divisible by j,\n                 // but (result * i) may overflow, so we split j:\n                 // Filter out the gcd, d, so j/d and i/d are integer.\n                 // result is divisible by (j/d) because (j/d)\n                 // is relative prime to (i/d) and is a divisor of\n                 // result * (i/d).\n-                long d = gcd(i, j);\n+                final long d = gcd(i, j);\n                 result = (result / (j / d)) * (i / d);\n+                i++;\n             }\n         } else {\n             // For n > 66, a result overflow might occur, so we check\n             // the multiplication, taking care to not overflow\n             // unnecessary.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n-                long d = gcd(i, j);\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n+                final long d = gcd(i, j);\n                 result = mulAndCheck(result / (j / d), i / d);\n+                i++;\n             }\n         }\n         return result;\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n             return missingEntries;\n         }\n \n-        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+        int j = index;\n+        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n             j = probe(perturb, j);\n             index = j & mask;\n             if (containsKey(key, index)) {\n             return false;\n         }\n \n-        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+        int j = index;\n+        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n             j = probe(perturb, j);\n             index = j & mask;\n             if (containsKey(key, index)) {\n             return missingEntries;\n         }\n \n-        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+        int j = index;\n+        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n             j = probe(perturb, j);\n             index = j & mask;\n             if (containsKey(key, index)) {\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n             return missingEntries;\n         }\n \n-        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+        int j = index;\n+        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n             j = probe(perturb, j);\n             index = j & mask;\n             if (containsKey(key, index)) {\n             return false;\n         }\n \n-        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+        int j = index;\n+        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n             j = probe(perturb, j);\n             index = j & mask;\n             if (containsKey(key, index)) {\n             return missingEntries;\n         }\n \n-        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+        int j = index;\n+        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n             j = probe(perturb, j);\n             index = j & mask;\n             if (containsKey(key, index)) {", "timestamp": 1255704715, "metainfo": ""}