{"sha": "63cf9886ebf4befc8d3c276445f85dd5e7ed05a7", "log": "JIRA: MATH-607 Adding support for UpdatingMultipleLinearRegression to SimpleRegression  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     // CHECKSTYLE: stop JavadocVariable\n \n     ARGUMENT_OUTSIDE_DOMAIN(\"Argument {0} outside domain [{1} ; {2}]\"),\n+    ARRAY_SIZE_EXCEEDS_MAX_VARIABLES(\"array size cannot be greater than {0}\"),\n     ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1(\"array sizes should have difference 1 ({0} != {1} + 1)\"),\n     ARRAY_SUMS_TO_ZERO(\"array sums to zero\"),\n     ASSYMETRIC_EIGEN_NOT_SUPPORTED(\"eigen decomposition of assymetric matrices not supported yet\"),\n     INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS(\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\"),\n     INVALID_ITERATIONS_LIMITS(\"invalid iteration limits: min={0}, max={1}\"),\n     INVALID_MAX_ITERATIONS(\"bad value for maximum iterations number: {0}\"),\n+    NOT_ENOUGH_DATA_REGRESSION(\"the number of observations is not sufficient to conduct regression\"),\n     INVALID_REGRESSION_ARRAY(\"input data array length = {0} does not match the number of observations = {1} and the number of regressors = {2}\"),\n     INVALID_REGRESSION_OBSERVATION(\"length of regressor array = {0} does not match the number of variables = {1} in the model\"),\n     INVALID_ROUNDING_METHOD(\"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\"),\n     NO_RESULT_AVAILABLE(\"no result available\"),\n     NO_SUCH_MATRIX_ENTRY(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\"),\n     NULL_NOT_ALLOWED(\"null is not allowed\"), /* keep */\n+    ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED(\"A null or zero length array not allowed\"),\n     COVARIANCE_MATRIX(\"covariance matrix\"), /* keep */\n     DENOMINATOR(\"denominator\"), /* keep */\n     DENOMINATOR_FORMAT(\"denominator format\"), /* keep */\n--- a/src/main/java/org/apache/commons/math/stat/regression/RegressionResults.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/RegressionResults.java\n         this.globalFitInfo = new double[5];\n         Arrays.fill(this.globalFitInfo, Double.NaN);\n \n-        if (rank > 2) {\n+        if (rank > 0) {\n             this.globalFitInfo[SST_IDX] = containsConstant ?\n                     (sumysq - sumy * sumy / ((double) nobs)) : sumysq;\n         }\n--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Estimates an ordinary least squares regression model\n  *\n  * @version $Id$\n  */\n-public class SimpleRegression implements Serializable {\n+public class SimpleRegression implements Serializable, UpdatingMultipleLinearRegression {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3004689053607543335L;\n     * Secondary constructor which allows the user the ability to include/exclude const\n     * @param includeIntercept boolean flag, true includes an intercept\n     */\n-    public SimpleRegression(boolean includeIntercept){\n+    public SimpleRegression(boolean includeIntercept) {\n         super();\n         hasIntercept = includeIntercept;\n     }\n      * @param x independent variable value\n      * @param y dependent variable value\n      */\n-    public void addData(final double x, final double y){\n+    public void addData(final double x,final double y) {\n         if (n == 0) {\n             xbar = x;\n             ybar = y;\n      * @param x independent variable value\n      * @param y dependent variable value\n      */\n-    public void removeData(double x, double y) {\n+    public void removeData(final double x,final double y) {\n         if (n > 0) {\n             if (hasIntercept) {\n                 final double fact1 = (double) n - 1.0;\n      * data.</p>\n      *\n      * @param data array of observations to be added\n-     */\n-    public void addData(double[][] data) {\n+     * @throws ModelSpecificationException if the length of {@code data[i]} is not\n+     * greater than or equal to 2\n+     */\n+    public void addData(final double[][] data) {\n         for (int i = 0; i < data.length; i++) {\n+            if( data[i].length < 2 ){\n+               throw new ModelSpecificationException(LocalizedFormats.INVALID_REGRESSION_OBSERVATION,\n+                    data[i].length, 2);\n+            }\n             addData(data[i][0], data[i][1]);\n         }\n-    }\n-\n+        return;\n+    }\n+\n+    /**\n+     * Adds one observation to the regression model.\n+     *\n+     * @param x the independent variables which form the design matrix\n+     * @param y the dependent or response variable\n+     * @throws ModelSpecificationException if the length of {@code x} does not equal\n+     * the number of independent variables in the model\n+     */\n+    public void addObservation(final double[] x,final double y) throws ModelSpecificationException{\n+        if( x == null || x.length == 0 ){\n+            throw new ModelSpecificationException(LocalizedFormats.INVALID_REGRESSION_OBSERVATION,x!=null?x.length:0, 1);\n+        }\n+        addData( x[0], y );\n+        return;\n+    }\n+\n+    /**\n+     * Adds a series of observations to the regression model. The lengths of\n+     * x and y must be the same and x must be rectangular.\n+     *\n+     * @param x a series of observations on the independent variables\n+     * @param y a series of observations on the dependent variable\n+     * The length of x and y must be the same\n+     * @throws ModelSpecificationException if {@code x} is not rectangular, does not match\n+     * the length of {@code y} or does not contain sufficient data to estimate the model\n+     */\n+    public void addObservations(final double[][] x,final double[] y) {\n+        if ((x == null) || (y == null) || (x.length != y.length)) {\n+            throw new ModelSpecificationException(\n+                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n+                  (x == null) ? 0 : x.length,\n+                  (y == null) ? 0 : y.length);\n+        }\n+        boolean obsOk=true;\n+        for( int i = 0 ; i < x.length; i++){\n+            if( x[i] == null || x[i].length == 0 ){\n+                obsOk = false;\n+            }\n+        }\n+        if( !obsOk ){\n+            throw new ModelSpecificationException(\n+                  LocalizedFormats.NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS,\n+                  0, 1);\n+        }\n+        for( int i = 0 ; i < x.length ; i++){\n+            addData( x[i][0], y[i] );\n+        }\n+        return;\n+    }\n \n     /**\n      * Removes observations represented by the elements in <code>data</code>.\n      * @param x input <code>x</code> value\n      * @return predicted <code>y</code> value\n      */\n-    public double predict(double x) {\n-        double b1 = getSlope();\n+    public double predict(final double x) {\n+        final double b1 = getSlope();\n         if (hasIntercept) {\n             return getIntercept(b1) + b1 * x;\n         }\n      *\n      * @return true if constant exists, false otherwise\n      */\n-    public boolean hasIntercept(){\n+    public boolean hasIntercept() {\n         return hasIntercept;\n     }\n \n      * @return half-width of 95% confidence interval for the slope estimate\n      * @throws MathException if the confidence interval can not be computed.\n      */\n-    public double getSlopeConfidenceInterval(double alpha)\n+    public double getSlopeConfidenceInterval(final double alpha)\n         throws MathException {\n         if (alpha >= 1 || alpha <= 0) {\n             throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,\n     * @param slope current slope\n     * @return the intercept of the regression line\n     */\n-    private double getIntercept(double slope){\n+    private double getIntercept(final double slope) {\n       if( hasIntercept){\n         return (sumY - slope * sumX) / n;\n       }\n      * @param slope regression slope estimate\n      * @return sum of squared deviations of predicted y values\n      */\n-    private double getRegressionSumSquares(double slope) {\n+    private double getRegressionSumSquares(final double slope) {\n         return slope * slope * sumXX;\n     }\n+\n+    /**\n+     * Performs a regression on data present in buffers and outputs a RegressionResults object\n+     * @return RegressionResults acts as a container of regression output\n+     * @throws ModelSpecificationException if the model is not correctly specified\n+     */\n+    public RegressionResults regress() throws ModelSpecificationException{\n+        if( hasIntercept ){\n+          if( n < 3 ){\n+              throw new NoDataException( LocalizedFormats.NOT_ENOUGH_DATA_REGRESSION );\n+          }\n+          if( FastMath.abs( sumXX ) > MathUtils.SAFE_MIN ){\n+              final double[] params = new double[]{ getIntercept(), getSlope() };\n+              final double mse = getMeanSquareError();\n+              final double _syy = sumYY + sumY * sumY / ((double) n);\n+              final double[] vcv = new double[]{\n+                mse * (xbar *xbar /sumXX + 1.0 / ((double) n)),\n+                -xbar*mse/sumXX,\n+                mse/sumXX };\n+              return new RegressionResults(\n+                      params, new double[][]{vcv}, true, n, 2,\n+                      sumY, _syy, getSumSquaredErrors(),true,false);\n+          }else{\n+              final double[] params = new double[]{ sumY/((double) n), Double.NaN };\n+              //final double mse = getMeanSquareError();\n+              final double[] vcv = new double[]{\n+                ybar / ((double) n - 1.0),\n+                Double.NaN,\n+                Double.NaN };\n+              return new RegressionResults(\n+                      params, new double[][]{vcv}, true, n, 1,\n+                      sumY, sumYY, getSumSquaredErrors(),true,false);\n+          }\n+        }else{\n+          if( n < 2 ){\n+              throw new NoDataException( LocalizedFormats.NOT_ENOUGH_DATA_REGRESSION );\n+          }\n+          if( !Double.isNaN(sumXX) ){\n+          final double[] vcv = new double[]{ getMeanSquareError() / sumXX };\n+          final double[] params = new double[]{ sumXY/sumXX };\n+          return new RegressionResults(\n+                      params, new double[][]{vcv}, true, n, 1,\n+                      sumY, sumYY, getSumSquaredErrors(),false,false);\n+          }else{\n+          final double[] vcv = new double[]{Double.NaN };\n+          final double[] params = new double[]{ Double.NaN };\n+          return new RegressionResults(\n+                      params, new double[][]{vcv}, true, n, 1,\n+                      Double.NaN, Double.NaN, Double.NaN,false,false);\n+          }\n+        }\n+    }\n+\n+    /**\n+     * Performs a regression on data present in buffers including only regressors\n+     * indexed in variablesToInclude and outputs a RegressionResults object\n+     * @param variablesToInclude an array of indices of regressors to include\n+     * @return RegressionResults acts as a container of regression output\n+     * @throws ModelSpecificationException if the model is not correctly specified\n+     * @throws MathIllegalArgumentException if the variablesToInclude array is null or zero length\n+     * @throws OutOfRangeException if a requested variable is not present in model\n+     */\n+    public RegressionResults regress(int[] variablesToInclude) throws ModelSpecificationException{\n+        if( variablesToInclude == null || variablesToInclude.length == 0){\n+          throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED);\n+        }\n+        if( variablesToInclude.length > 2 || (variablesToInclude.length > 1 && !hasIntercept) ){\n+            throw new ModelSpecificationException(\n+                    LocalizedFormats.ARRAY_SIZE_EXCEEDS_MAX_VARIABLES,\n+                    (variablesToInclude.length > 1 && !hasIntercept) ? 1 : 2);\n+        }\n+\n+        if( hasIntercept ){\n+            if( variablesToInclude.length == 2 ){\n+                if( variablesToInclude[0] == 1 ){\n+                    throw new ModelSpecificationException(LocalizedFormats.NOT_INCREASING_SEQUENCE);\n+                }else if( variablesToInclude[0] != 0 ){\n+                    throw new OutOfRangeException( variablesToInclude[0], 0,1 );\n+                }\n+                if( variablesToInclude[1] != 1){\n+                     throw new OutOfRangeException( variablesToInclude[0], 0,1 );\n+                }\n+                return regress();\n+            }else{\n+                if( variablesToInclude[0] != 1 && variablesToInclude[0] != 0 ){\n+                     throw new OutOfRangeException( variablesToInclude[0],0,1 );\n+                }\n+                final double _mean = sumY * sumY / ((double) n);\n+                final double _syy = sumYY + _mean;\n+                if( variablesToInclude[0] == 0 ){\n+                    //just the mean\n+                    final double[] vcv = new double[]{ sumYY/((double)((n-1)*n)) };\n+                    final double[] params = new double[]{ ybar };\n+                    return new RegressionResults(\n+                      params, new double[][]{vcv}, true, n, 1,\n+                      sumY, _syy+_mean, sumYY,true,false);\n+\n+                }else if( variablesToInclude[0] == 1){\n+                    //final double _syy = sumYY + sumY * sumY / ((double) n);\n+                    final double _sxx = sumXX + sumX * sumX / ((double) n);\n+                    final double _sxy = sumXY + sumX * sumY / ((double) n);\n+                    final double _sse = FastMath.max(0d, _syy - _sxy * _sxy / _sxx);\n+                    final double _mse = _sse/((double)(n-1));\n+                    if( !Double.isNaN(_sxx) ){\n+                        final double[] vcv = new double[]{ _mse / _sxx };\n+                        final double[] params = new double[]{ _sxy/_sxx };\n+                        return new RegressionResults(\n+                                    params, new double[][]{vcv}, true, n, 1,\n+                                    sumY, _syy, _sse,false,false);\n+                    }else{\n+                        final double[] vcv = new double[]{Double.NaN };\n+                        final double[] params = new double[]{ Double.NaN };\n+                        return new RegressionResults(\n+                                    params, new double[][]{vcv}, true, n, 1,\n+                                    Double.NaN, Double.NaN, Double.NaN,false,false);\n+                    }\n+                }\n+            }\n+        }else{\n+            if( variablesToInclude[0] != 0 ){\n+                throw new OutOfRangeException(variablesToInclude[0],0,0);\n+            }\n+            return regress();\n+        }\n+\n+        return null;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/stat/regression/UpdatingMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/UpdatingMultipleLinearRegression.java\n      * @throws ModelSpecificationException if {@code x} is not rectangular, does not match\n      * the length of {@code y} or does not contain sufficient data to estimate the model\n      */\n-    void addObservations(double[][] x, double[] y);\n+    void addObservations(double[][] x, double[] y) throws ModelSpecificationException;\n \n     /**\n      * Clears internal buffers and resets the regression model. This means all\n--- a/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n             {5, -1 }, {6, 12 }\n     };\n \n-    \n-    /*\n-     * Data from NIST NOINT1 \n+\n+    /*\n+     * Data from NIST NOINT1\n      */\n     private double[][] noint1 = {\n         {130.0,60.0},\n         {137.0,67.0},\n         {138.0,68.0},\n         {139.0,69.0},\n-        {140.0,70.0}        \n-    };\n-    \n-    /*\n-     * Data from NIST NOINT2 \n-     * \n+        {140.0,70.0}\n+    };\n+\n+    /*\n+     * Data from NIST NOINT2\n+     *\n      */\n     private double[][] noint2 = {\n         {3.0,4},\n         {4,5},\n         {4,6}\n     };\n-    \n+\n+    @Test\n+    public void testRegressIfaceMethod(){\n+        final SimpleRegression regression = new SimpleRegression(true);\n+        final UpdatingMultipleLinearRegression iface = regression;\n+        final SimpleRegression regressionNoint = new SimpleRegression( false );\n+        final SimpleRegression regressionIntOnly= new SimpleRegression( false );\n+        for (int i = 0; i < data.length; i++) {\n+            iface.addObservation( new double[]{data[i][1]}, data[i][0]);\n+            regressionNoint.addData(data[i][1], data[i][0]);\n+            regressionIntOnly.addData(1.0, data[i][0]);\n+        }\n+\n+        //should not be null\n+        final RegressionResults fullReg = iface.regress( );\n+        Assert.assertTrue(fullReg != null);\n+        Assert.assertEquals(\"intercept\", regression.getIntercept(), fullReg.getParameterEstimate(0), 1.0e-16);\n+        Assert.assertEquals(\"intercept std err\",regression.getInterceptStdErr(), fullReg.getStdErrorOfEstimate(0),1.0E-16);\n+        Assert.assertEquals(\"slope\", regression.getSlope(), fullReg.getParameterEstimate(1), 1.0e-16);\n+        Assert.assertEquals(\"slope std err\",regression.getSlopeStdErr(), fullReg.getStdErrorOfEstimate(1),1.0E-16);\n+        Assert.assertEquals(\"number of observations\",regression.getN(), fullReg.getN());\n+        Assert.assertEquals(\"r-square\",regression.getRSquare(), fullReg.getRSquared(), 1.0E-16);\n+        Assert.assertEquals(\"SSR\", regression.getRegressionSumSquares(), fullReg.getRegressionSumSquares() ,1.0E-16);\n+        Assert.assertEquals(\"MSE\", regression.getMeanSquareError(), fullReg.getMeanSquareError() ,1.0E-16);\n+        Assert.assertEquals(\"SSE\", regression.getSumSquaredErrors(), fullReg.getErrorSumSquares() ,1.0E-16);\n+\n+\n+        final RegressionResults noInt   = iface.regress( new int[]{1} );\n+        Assert.assertTrue(noInt != null);\n+        Assert.assertEquals(\"slope\", regressionNoint.getSlope(), noInt.getParameterEstimate(0), 1.0e-12);\n+        Assert.assertEquals(\"slope std err\",regressionNoint.getSlopeStdErr(), noInt.getStdErrorOfEstimate(0),1.0E-16);\n+        Assert.assertEquals(\"number of observations\",regressionNoint.getN(), noInt.getN());\n+        Assert.assertEquals(\"r-square\",regressionNoint.getRSquare(), noInt.getRSquared(), 1.0E-16);\n+        Assert.assertEquals(\"SSR\", regressionNoint.getRegressionSumSquares(), noInt.getRegressionSumSquares() ,1.0E-8);\n+        Assert.assertEquals(\"MSE\", regressionNoint.getMeanSquareError(), noInt.getMeanSquareError() ,1.0E-16);\n+        Assert.assertEquals(\"SSE\", regressionNoint.getSumSquaredErrors(), noInt.getErrorSumSquares() ,1.0E-16);\n+\n+        final RegressionResults onlyInt = iface.regress( new int[]{0} );\n+        Assert.assertTrue( onlyInt != null );\n+        Assert.assertEquals(\"slope\", regressionIntOnly.getSlope(), onlyInt.getParameterEstimate(0), 1.0e-12);\n+        Assert.assertEquals(\"slope std err\",regressionIntOnly.getSlopeStdErr(), onlyInt.getStdErrorOfEstimate(0),1.0E-12);\n+        Assert.assertEquals(\"number of observations\",regressionIntOnly.getN(), onlyInt.getN());\n+        Assert.assertEquals(\"r-square\",regressionIntOnly.getRSquare(), onlyInt.getRSquared(), 1.0E-14);\n+        Assert.assertEquals(\"SSE\", regressionIntOnly.getSumSquaredErrors(), onlyInt.getErrorSumSquares() ,1.0E-8);\n+        Assert.assertEquals(\"SSR\", regressionIntOnly.getRegressionSumSquares(), onlyInt.getRegressionSumSquares() ,1.0E-8);\n+        Assert.assertEquals(\"MSE\", regressionIntOnly.getMeanSquareError(), onlyInt.getMeanSquareError() ,1.0E-8);\n+\n+    }\n+\n     @Test\n     public void testNoInterceot_noint2(){\n          SimpleRegression regression = new SimpleRegression(false);\n          regression.addData(noint2[0][1], noint2[0][0]);\n          regression.addData(noint2[1][1], noint2[1][0]);\n          regression.addData(noint2[2][1], noint2[2][0]);\n-         Assert.assertEquals(\"slope\", 0.727272727272727, \n+         Assert.assertEquals(\"slope\", 0.727272727272727,\n                  regression.getSlope(), 10E-12);\n          Assert.assertEquals(\"slope std err\", 0.420827318078432E-01,\n                 regression.getSlopeStdErr(),10E-12);\n         Assert.assertEquals(\"SSE\", 0.272727272727273,\n             regression.getSumSquaredErrors(),10E-9);\n     }\n-    \n-    @Test \n+\n+    @Test\n     public void testNoIntercept_noint1(){\n         SimpleRegression regression = new SimpleRegression(false);\n         for (int i = 0; i < noint1.length; i++) {\n             regression.getMeanSquareError(), 10E-10);\n         Assert.assertEquals(\"SSE\", 127.272727272727,\n             regression.getSumSquaredErrors(),10E-9);\n-            \n-    }  \n-    \n+\n+    }\n+\n     @Test\n     public void testNorris() {\n         SimpleRegression regression = new SimpleRegression();", "timestamp": 1316748971, "metainfo": ""}