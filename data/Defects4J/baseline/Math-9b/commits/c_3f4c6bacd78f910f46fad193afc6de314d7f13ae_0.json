{"sha": "3f4c6bacd78f910f46fad193afc6de314d7f13ae", "log": "1. Minor changes to Javadoc of SYMMLQ implementation, following Pr. M. A. Saunders review. 2. Added Michael Saunders as a contributor in the POM.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n  * definite (but <em>must</em> be self-adjoint). The work per iteration is very\n  * slightly less if shift = 0.\n  * </p>\n- * <h3>Peconditioning</h3>\n+ * <h3>Preconditioning</h3>\n  * <p>\n- * Preconditioning may reduce the number of iterations required. The solver is\n+ * Preconditioning may reduce the number of iterations required. The solver may be\n  * provided with a positive definite preconditioner M = C &middot; C<sup>T</sup>\n- * that is known to approximate (A - shift &middot; I) in some sense, while\n+ * that is known to approximate (A - shift &middot; I) in some sense, where\n  * systems of the form M &middot; y = x can be solved efficiently. Then SYMMLQ\n  * will implicitly solve the system of equations P &middot; (A - shift &middot;\n  * I) &middot; P<sup>T</sup> &middot; xhat = P &middot; b, i.e. Ahat &middot;\n  * In the present context, an iteration should be understood as one evaluation\n  * of the matrix-vector product A &middot; x. The initialization phase therefore\n  * counts as one iteration. If the user requires checks on the symmetry of A,\n- * this entails one further matrix-vector product by iteration. This further\n- * product is <em>not</em> accounted for in the iteration count. In other words,\n- * the number of iterations required to reach convergence will be identical,\n- * whether checks have been required or not.\n+ * this entails one further matrix-vector product in the initial phase. This\n+ * further product is <em>not</em> accounted for in the iteration count. In\n+ * other words, the number of iterations required to reach convergence will be\n+ * identical, whether checks have been required or not.\n  * </p>\n  * <p>\n  * The present definition of the iteration count differs from that adopted in\n  * the original FOTRAN code, where the initialization phase was <em>not</em>\n  * taken into account.\n+ * </p>\n+ * <h3><a id=\"initguess\">Initial guess of the solution</a></h3>\n+ * <p>\n+ * The {@code x} parameter in\n+ * <ul>\n+ * <li>{@link #solve(RealLinearOperator, RealVector, RealVector)},</li>\n+ * <li>{@link #solve(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector)}},</li>\n+ * <li>{@link #solveInPlace(RealLinearOperator, RealVector, RealVector)},</li>\n+ * <li>{@link #solveInPlace(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector)},</li>\n+ * <li>{@link #solveInPlace(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector, boolean, double)},</li>\n+ * </ul>\n+ * should not be considered as an initial guess, as it is set to zero in the\n+ * initial phase. If x<sub>0</sub> is known to be a good approximation to x, one\n+ * should compute r<sub>0</sub> = b - A &middot; x, solve A &middot; dx = r0,\n+ * and set x = x<sub>0</sub> + dx.\n  * </p>\n  * <h3><a id=\"context\">Exception context</a></h3>\n  * <p>\n      * 1. Preconditioning\n      *    ---------------\n      * The Lanczos iterations associated with Ahat and bhat read\n-     *   beta[1] = |P . b|\n-     *   v[1] = P.b / beta[1]\n+     *   beta[1] = ||P * b||\n+     *   v[1] = P * b / beta[1]\n      *   beta[k+1] * v[k+1] = Ahat * v[k] - alpha[k] * v[k] - beta[k] * v[k-1]\n      *                      = P * (A - shift * I) * P' * v[k] - alpha[k] * v[k]\n      *                        - beta[k] * v[k-1]\n      * 3. Accounting for the goodb flag\n      *    -----------------------------\n      * When goodb is set to true, the component of xL along b is computed\n-     * separately. From Page and Saunders (1975), equation (5.9), we have\n+     * separately. From Paige and Saunders (1975), equation (5.9), we have\n      *   wbar[k+1] = s[k] * wbar[k] - c[k] * v[k+1],\n      *   wbar[1] = v[1].\n      * Introducing wbar2[k] = wbar[k] - s[1] * ... * s[k-1] * v[1], it can\n-     * easily be verified by induction that what follows the same recursive\n+     * easily be verified by induction that wbar2 follows the same recursive\n      * relation\n      *   wbar2[k+1] = s[k] * wbar2[k] - c[k] * v[k+1],\n      *   wbar2[1] = 0,\n          * @param m Preconditioner (can be {@code null}).\n          * @param b Right-hand side vector.\n          * @param x Vector to be updated with the solution. {@code x} should not\n-         * be considered as an initial guess, as it is set to 0 in the\n-         * initialization phase.\n+         * be considered as an initial guess (<a href=\"#initguess\">more</a>).\n          * @param goodb Usually {@code false}, except if {@code x} is expected\n          * to contain a large multiple of {@code b}.\n          * @param shift The amount to be subtracted to all diagonal elements of\n      * @param delta &delta; parameter for the default stopping criterion.\n      * @param check {@code true} if self-adjointedness of both matrix and\n      * preconditioner should be checked. This entails an extra matrix-vector\n-     * product at each iteration.\n+     * product in the initial phase.\n      */\n     public SymmLQ(final int maxIterations, final double delta,\n                   final boolean check) {\n      * @param delta &delta; parameter for the default stopping criterion.\n      * @param check {@code true} if self-adjointedness of both matrix and\n      * preconditioner should be checked. This entails an extra matrix-vector\n-     * product at each iteration.\n+     * product in the initial phase.\n      */\n     public SymmLQ(final IterationManager manager, final double delta,\n                   final boolean check) {\n      * @param m Preconditioner (can be {@code null}).\n      * @param b Right-hand side vector.\n      * @param x Not meaningful in this implementation. Should not be considered\n-     * as an initial guess.\n+     * as an initial guess (<a href=\"#initguess\">more</a>).\n      * @return A new vector containing the solution.\n      * @throws NullArgumentException if one of the parameters is {@code null}.\n      * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n      * @param a Linear operator A of the system.\n      * @param b Right-hand side vector.\n      * @param x Not meaningful in this implementation. Should not be considered\n-     * as an initial guess.\n+     * as an initial guess (<a href=\"#initguess\">more</a>).\n      * @return A new vector containing the solution.\n      * @throws NullArgumentException if one of the parameters is {@code null}.\n      * @throws NonSquareOperatorException if {@code a} is not square.\n      * @param m Preconditioner (can be {@code null}).\n      * @param b Right-hand side vector.\n      * @param x Vector to be updated with the solution. {@code x} should not be\n-     * considered as an initial guess, as it is set to 0 in the initialization\n-     * phase.\n+     * considered as an initial guess (<a href=\"#initguess\">more</a>).\n      * @return A reference to {@code x} (shallow copy) updated with the\n      * solution.\n      * @throws NullArgumentException if one of the parameters is {@code null}.\n      * @param m Preconditioner (can be {@code null}).\n      * @param b Right-hand side vector.\n      * @param x Vector to be updated with the solution. {@code x} should not be\n-     * considered as an initial guess, as it is set to 0 in the initialization\n-     * phase.\n+     * considered as an initial guess (<a href=\"#initguess\">more</a>).\n      * @param goodb Usually {@code false}, except if {@code x} is expected to\n      * contain a large multiple of {@code b}.\n      * @param shift The amount to be subtracted to all diagonal elements of A.\n      * @param a Linear operator A of the system.\n      * @param b Right-hand side vector.\n      * @param x Vector to be updated with the solution. {@code x} should not be\n-     * considered as an initial guess, as it is set to 0 in the initialization\n-     * phase.\n+     * considered as an initial guess (<a href=\"#initguess\">more</a>).\n      * @return A reference to {@code x} (shallow copy) updated with the\n      * solution.\n      * @throws NullArgumentException if one of the parameters is {@code null}.", "timestamp": 1319528228, "metainfo": ""}