{"sha": "60c93e73be76beece194a332b25e375973408a95", "log": "Replaced Raw types by Parameterized types where appropriate. The various ArrayList, HashSet and HashMap used in math have be restricted to the content they are intended for. This removes lots of warnings that have appeared after the switch to Java 5, and improves safety (for example the categories used by OneWayAnova are guaranteed to be double arrays at compile time). Two difficult cases where not handled here: the Frequency class and the Fitness interface. The first one mixes types and needs to be studied before any change is attempted. The second one generates some side effects on the overall package which is still under development.  ", "commit": "\n--- a/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n+++ b/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n package org.apache.commons.math.estimation;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n \n /**\n      * Build an empty instance without parameters nor measurements.\n      */\n     public SimpleEstimationProblem() {\n-        parameters   = new ArrayList();\n-        measurements = new ArrayList();\n+        parameters   = new ArrayList<EstimatedParameter>();\n+        measurements = new ArrayList<WeightedMeasurement>();\n     }\n \n     /** \n     public EstimatedParameter[] getUnboundParameters() {\n \n         // filter the unbound parameters\n-        List unbound = new ArrayList(parameters.size());\n-        for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {\n-            EstimatedParameter p = (EstimatedParameter) iterator.next();\n+        List<EstimatedParameter> unbound = new ArrayList<EstimatedParameter>(parameters.size());\n+        for (EstimatedParameter p : parameters) {\n             if (! p.isBound()) {\n                 unbound.add(p);\n             }\n     }\n \n     /** Estimated parameters. */\n-    private final List parameters;\n+    private final List<EstimatedParameter> parameters;\n \n     /** Measurements. */\n-    private final List measurements;\n+    private final List<WeightedMeasurement> measurements;\n \n }\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n-public class Fraction extends Number implements Comparable {\n+public class Fraction extends Number implements Comparable<Fraction> {\n \n     /** A fraction representing \"1 / 1\". */\n     public static final Fraction ONE = new Fraction(1, 1);\n     public static final Fraction ZERO = new Fraction(0, 1);\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -8958519416450949235L;\n+    private static final long serialVersionUID = -5731055832688548463L;\n     \n     /** The denominator. */\n     private final int denominator;\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n-    public int compareTo(Object object) {\n+    public int compareTo(Fraction object) {\n         int ret = 0;\n         \n         if (this != object) { \n-            Fraction other = (Fraction)object;\n             double first = doubleValue();\n-            double second = other.doubleValue();\n+            double second = object.doubleValue();\n             \n             if (first < second) {\n                 ret = -1;\n--- a/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n                                    double maxCheckInterval,\n                                    double convergence,\n                                    int maxIterationCount) {\n-    switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);\n+    switchesHandler.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);\n   }\n \n   /** Get all the switching functions that have been added to the integrator.\n    * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n    * @see #clearSwitchingFunctions()\n    */\n-  public Collection getSwitchingFunctions() {\n+  public Collection<SwitchState> getSwitchingFunctions() {\n       return switchesHandler.getSwitchingFunctions();\n   }\n \n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n package org.apache.commons.math.ode;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n import java.io.Serializable;\n \n  * get the model value at any time or to navigate through the\n  * data).</p>\n  *\n- * <p>If problem modelization is done with several separate\n+ * <p>If problem modeling is done with several separate\n  * integration phases for contiguous intervals, the same\n  * ContinuousOutputModel can be used as step handler for all\n  * integration phases as long as they are performed in order and in\n  * the same direction. As an example, one can extrapolate the\n  * trajectory of a satellite with one model (i.e. one set of\n  * differential equations) up to the beginning of a maneuver, use\n- * another more complex model including thrusters modelization and\n+ * another more complex model including thrusters modeling and\n  * accurate attitude control during the maneuver, and revert to the\n  * first model after the end of the maneuver. If the same continuous\n  * output model handles the steps of all integration phases, the user\n    * Build an empty continuous output model.\n    */\n   public ContinuousOutputModel() {\n-    steps = new ArrayList();\n+    steps = new ArrayList<StepInterpolator>();\n     reset();\n   }\n \n \n     }\n \n-    for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {\n-      steps.add(((AbstractStepInterpolator) iter.next()).copy());\n+    for (StepInterpolator interpolator : model.steps) {\n+      steps.add(interpolator.copy());\n     }\n \n     index = steps.size() - 1;\n   public void handleStep(StepInterpolator interpolator, boolean isLast)\n     throws DerivativeException {\n \n-    AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;\n-\n     if (steps.size() == 0) {\n       initialTime = interpolator.getPreviousTime();\n       forward     = interpolator.isForward();\n     }\n \n-    steps.add(ai.copy());\n+    steps.add(interpolator.copy());\n \n     if (isLast) {\n-      finalTime = ai.getCurrentTime();\n+      finalTime = interpolator.getCurrentTime();\n       index     = steps.size() - 1;\n     }\n \n    * @return interpolation point time\n    */\n   public double getInterpolatedTime() {\n-    return ((StepInterpolator) steps.get(index)).getInterpolatedTime();\n+    return steps.get(index).getInterpolatedTime();\n   }\n     \n   /** Set the time of the interpolated point.\n     try {\n       // initialize the search with the complete steps table\n       int iMin = 0;\n-      StepInterpolator sMin = (StepInterpolator) steps.get(iMin);\n+      StepInterpolator sMin = steps.get(iMin);\n       double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());\n \n       int iMax = steps.size() - 1;\n-      StepInterpolator sMax = (StepInterpolator) steps.get(iMax);\n+      StepInterpolator sMax = steps.get(iMax);\n       double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());\n \n       // handle points outside of the integration interval\n       while (iMax - iMin > 5) {\n \n         // use the last estimated index as the splitting index\n-        StepInterpolator si = (StepInterpolator) steps.get(index);\n+        StepInterpolator si = steps.get(index);\n         int location = locatePoint(time, si);\n         if (location < 0) {\n           iMax = index;\n \n         // compute a new estimate of the index in the reduced table slice\n         int iMed = (iMin + iMax) / 2;\n-        StepInterpolator sMed = (StepInterpolator) steps.get(iMed);\n+        StepInterpolator sMed = steps.get(iMed);\n         double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n \n         if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {\n \n       // now the table slice is very small, we perform an iterative search\n       index = iMin;\n-      while ((index <= iMax) &&\n-             (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {\n+      while ((index <= iMax) && (locatePoint(time, steps.get(index)) > 0)) {\n         ++index;\n       }\n \n-      StepInterpolator si = (StepInterpolator) steps.get(index);\n-\n-      si.setInterpolatedTime(time);\n+      steps.get(index).setInterpolatedTime(time);\n \n     } catch (DerivativeException de) {\n       throw new RuntimeException(\"unexpected DerivativeException caught: \" +\n    * @return state vector at time {@link #getInterpolatedTime}\n    */\n   public double[] getInterpolatedState() {\n-    return ((StepInterpolator) steps.get(index)).getInterpolatedState();\n+    return steps.get(index).getInterpolatedState();\n   }\n \n   /** Compare a step interval and a double. \n   private int index;\n \n   /** Steps table. */\n-  private List steps;\n+  private List<StepInterpolator> steps;\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 2259286184268533249L;\n+  private static final long serialVersionUID = -1417964919405031606L;\n \n }\n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n    * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n    * @see #clearSwitchingFunctions()\n    */\n-  public Collection getSwitchingFunctions();\n+  public Collection<SwitchState> getSwitchingFunctions();\n \n   /** Remove all the switching functions that have been added to the integrator.\n    * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n                                    double maxCheckInterval,\n                                    double convergence,\n                                    int maxIterationCount) {\n-    switchesHandler.add(function, maxCheckInterval, convergence, maxIterationCount);\n+    switchesHandler.addSwitchingFunction(function, maxCheckInterval, convergence, maxIterationCount);\n   }\n \n   /** Get all the switching functions that have been added to the integrator.\n    * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n    * @see #clearSwitchingFunctions()\n    */\n-  public Collection getSwitchingFunctions() {\n+  public Collection<SwitchState> getSwitchingFunctions() {\n       return switchesHandler.getSwitchingFunctions();\n   }\n \n--- a/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.List;\n \n import org.apache.commons.math.ConvergenceException;\n    * Create an empty handler\n    */\n   public SwitchingFunctionsHandler() {\n-    functions   = new ArrayList();\n+    functions   = new ArrayList<SwitchState>();\n     first       = null;\n     initialized = false;\n   }\n    * @see #getSwitchingFunctions()\n    * @see #clearSwitchingFunctions()\n    */\n-  public void add(SwitchingFunction function, double maxCheckInterval,\n-                  double convergence, int maxIterationCount) {\n+  public void addSwitchingFunction(SwitchingFunction function, double maxCheckInterval,\n+                                   double convergence, int maxIterationCount) {\n     functions.add(new SwitchState(function, maxCheckInterval,\n                                   convergence, maxIterationCount));\n   }\n \n   /** Get all the switching functions that have been added to the handler.\n    * @return an unmodifiable collection of the added switching functions\n-   * @see #add(SwitchingFunction, double, double, int)\n+   * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n    * @see #clearSwitchingFunctions()\n    */\n-  public Collection getSwitchingFunctions() {\n+  public Collection<SwitchState> getSwitchingFunctions() {\n       return Collections.unmodifiableCollection(functions);\n   }\n \n   /** Remove all the switching functions that have been added to the handler.\n-   * @see #add(SwitchingFunction, double, double, int)\n+   * @see #addSwitchingFunction(SwitchingFunction, double, double, int)\n    * @see #getSwitchingFunctions()\n    */\n   public void clearSwitchingFunctions() {\n         double t0 = interpolator.getPreviousTime();\n         interpolator.setInterpolatedTime(t0);\n         double [] y = interpolator.getInterpolatedState();\n-        for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-          ((SwitchState) iter.next()).reinitializeBegin(t0, y);\n+        for (SwitchState state : functions) {\n+          state.reinitializeBegin(t0, y);\n         }\n \n         initialized = true;\n       }\n \n       // check events occurrence\n-      for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-\n-        SwitchState state = (SwitchState) iter.next();\n+      for (SwitchState state : functions) {\n+\n         if (state.evaluateStep(interpolator)) {\n           if (first == null) {\n             first = state;\n   public void stepAccepted(double t, double[] y)\n     throws IntegratorException {\n     try {\n-      for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-        ((SwitchState) iter.next()).stepAccepted(t, y);\n+      for (SwitchState state : functions) {\n+        state.stepAccepted(t, y);\n       }\n     } catch (SwitchException se) {\n       throw new IntegratorException(se);\n    * @return true if the integration should be stopped\n    */\n   public boolean stop() {\n-    for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-      if (((SwitchState) iter.next()).stop()) {\n+    for (SwitchState state : functions) {\n+      if (state.stop()) {\n         return true;\n       }\n     }\n   public boolean reset(double t, double[] y) throws IntegratorException {\n       try {\n           boolean resetDerivatives = false;\n-          for (Iterator iter = functions.iterator(); iter.hasNext();) {\n-              if (((SwitchState) iter.next()).reset(t, y)) {\n+          for (SwitchState state : functions) {\n+              if (state.reset(t, y)) {\n                   resetDerivatives = true;\n               }\n           }\n   }\n \n   /** Switching functions. */\n-  private List functions;\n+  private List<SwitchState> functions;\n \n   /** First active switching function. */\n   private SwitchState first;\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n     }\n \n     /** Comparator for {@link PointCostPair PointCostPair} objects. */\n-    private static Comparator pointCostPairComparator = new Comparator() {\n-        public int compare(Object o1, Object o2) {\n+    private static Comparator<PointCostPair> pointCostPairComparator =\n+        new Comparator<PointCostPair>() {\n+        public int compare(PointCostPair o1, PointCostPair o2) {\n             if (o1 == null) {\n                 return (o2 == null) ? 0 : +1;\n             } else if (o2 == null) {\n                 return -1;\n             }\n-            double cost1 = ((PointCostPair) o1).getCost();\n-            double cost2 = ((PointCostPair) o2).getCost();\n-            return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);\n+            return (o1.getCost() < o2.getCost()) ? -1 : ((o1 == o2) ? 0 : +1);\n         }\n     };\n \n--- a/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n import java.util.List;\n \n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n \n /**\n  * Represents an <a href=\"http://random.mat.sbg.ac.at/~ste/dipl/node11.html\">\n      * \n      * @return List of bin statistics\n      */\n-    List getBinStats();\n+    List<SummaryStatistics> getBinStats();\n \n     /**\n      * Returns the array of upper bounds for the bins.  Bins are: <br/>\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -6773236347582113490L;\n+    private static final long serialVersionUID = 5729073523949762654L;\n \n     /** List of SummaryStatistics objects characterizing the bins */\n-    private List binStats = null;\n+    private List<SummaryStatistics> binStats = null;\n \n     /** Sample statistics */\n     private SummaryStatistics sampleStats = null;\n      * Creates a new EmpiricalDistribution with the default bin count.\n      */\n     public EmpiricalDistributionImpl() {\n-        binStats = new ArrayList();\n+        binStats = new ArrayList<SummaryStatistics>();\n     }\n \n     /**\n      */\n     public EmpiricalDistributionImpl(int binCount) {\n         this.binCount = binCount;\n-        binStats = new ArrayList();\n+        binStats = new ArrayList<SummaryStatistics>();\n     }\n \n      /**\n             double val = 0.0d;\n             while ((str = inputStream.readLine()) != null) {\n                 val = Double.parseDouble(str);\n-                SummaryStatistics stats =\n-                    (SummaryStatistics) binStats.get(findBin(min, val, delta));\n+                SummaryStatistics stats = binStats.get(findBin(min, val, delta));\n                 stats.addValue(val);\n             }\n \n             throws IOException {\n             for (int i = 0; i < inputArray.length; i++) {\n                 SummaryStatistics stats =\n-                    (SummaryStatistics) binStats.get(\n-                            findBin(min, inputArray[i], delta));\n+                    binStats.get(findBin(min, inputArray[i], delta));\n                 stats.addValue(inputArray[i]);\n             }\n         }\n         // Assign upperBounds based on bin counts\n         upperBounds = new double[binCount];\n         upperBounds[0] =\n-        ((double)((SummaryStatistics)binStats.get(0)).getN())/\n-        (double)sampleStats.getN();\n+        ((double) binStats.get(0).getN()) / (double) sampleStats.getN();\n         for (int i = 1; i < binCount-1; i++) {\n             upperBounds[i] = upperBounds[i-1] +\n-            ((double)((SummaryStatistics)binStats.get(i)).getN())/\n-            (double)sampleStats.getN();\n+            ((double) binStats.get(i).getN()) / (double) sampleStats.getN();\n         }\n         upperBounds[binCount-1] = 1.0d;\n     }\n         // Use this to select the bin and generate a Gaussian within the bin\n         for (int i = 0; i < binCount; i++) {\n            if (x <= upperBounds[i]) {\n-               SummaryStatistics stats = (SummaryStatistics)binStats.get(i);\n+               SummaryStatistics stats = binStats.get(i);\n                if (stats.getN() > 0) {\n                    if (stats.getStandardDeviation() > 0) {  // more than one obs\n                         return randomData.nextGaussian\n      * \n      * @return List of bin statistics.\n      */\n-    public List getBinStats() {\n+    public List<SummaryStatistics> getBinStats() {\n         return binStats;\n     }\n \n--- a/src/java/org/apache/commons/math/random/RandomData.java\n+++ b/src/java/org/apache/commons/math/random/RandomData.java\n      * @param k size of the sample\n      * @return random sample of k elements from c\n      */\n-    Object[] nextSample(Collection c, int k);\n+    Object[] nextSample(Collection<?> c, int k);\n }\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n      * @param k sample size.\n      * @return the random sample.\n      */\n-    public Object[] nextSample(Collection c, int k) {\n+    public Object[] nextSample(Collection<?> c, int k) {\n         int len = c.size();\n         if (k > len) {\n             throw new IllegalArgumentException\n--- a/src/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n+++ b/src/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n      */\n-    public double anovaFValue(Collection categoryData)\n+    public double anovaFValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException;\n \n     /**\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n      */\n-    public double anovaPValue(Collection categoryData)\n+    public double anovaPValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException;\n \n     /**\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n     */\n-    public boolean anovaTest(Collection categoryData, double alpha)\n+    public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n         throws IllegalArgumentException, MathException;\n \n }\n--- a/src/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n  */\n package org.apache.commons.math.stat.inference;\n \n+import java.util.Collection;\n+\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.distribution.FDistribution;\n+import org.apache.commons.math.distribution.FDistributionImpl;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n-\n-import org.apache.commons.math.distribution.FDistribution;\n-import org.apache.commons.math.distribution.FDistributionImpl;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n \n \n /**\n      * are as defined <a href=\"http://faculty.vassar.edu/lowry/ch13pt1.html\">\n      * here</a></p>\n      */\n-    public double anovaFValue(Collection categoryData)\n+    public double anovaFValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException {\n         AnovaStats a = anovaStats(categoryData);\n         return a.F;\n      * where <code>F</code> is the F value and <code>cumulativeProbability</code>\n      * is the commons-math implementation of the F distribution.</p>\n      */\n-    public double anovaPValue(Collection categoryData)\n+    public double anovaPValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException {\n         AnovaStats a = anovaStats(categoryData);\n         FDistribution fdist = new FDistributionImpl(a.dfbg, a.dfwg);\n      * is the commons-math implementation of the F distribution.</p>\n      * <p>True is returned iff the estimated p-value is less than alpha.</p>\n      */\n-    public boolean anovaTest(Collection categoryData, double alpha)\n+    public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n         throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw new IllegalArgumentException(\"bad significance level: \" + alpha);\n      * preconditions specified in the interface definition\n      * @throws MathException if an error occurs computing the Anova stats\n      */\n-    private AnovaStats anovaStats(Collection categoryData)\n+    private AnovaStats anovaStats(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException {\n \n         // check if we have enough categories\n         }\n         \n         // check if each category has enough data and all is double[]\n-        for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {\n-            double[] array;\n-            try {\n-                array = (double[])iterator.next();\n-            } catch (ClassCastException ex) {\n-                throw new IllegalArgumentException(\n-                        \"ANOVA: categoryData contains non-double[] elements.\");\n-            }\n+        for (double[] array : categoryData) {\n             if (array.length <= 1) {\n                 throw new IllegalArgumentException(\n                         \"ANOVA: one element of categoryData has fewer than 2 values.\");\n         SumOfSquares totsumsq = new SumOfSquares();\n         int totnum = 0;\n         \n-        for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {\n-            double[] data = (double[])iterator.next();\n+        for (double[] data : categoryData) {\n \n             Sum sum = new Sum();\n             SumOfSquares sumsq = new SumOfSquares();\n--- a/src/java/org/apache/commons/math/stat/inference/TestUtils.java\n+++ b/src/java/org/apache/commons/math/stat/inference/TestUtils.java\n      *\n      * @since 1.2\n      */\n-    public static double oneWayAnovaFValue(Collection categoryData)\n+    public static double oneWayAnovaFValue(Collection<double[]> categoryData)\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaFValue(categoryData);\n     }\n      * \n      * @since 1.2\n      */\n-    public static double oneWayAnovaPValue(Collection categoryData)\n+    public static double oneWayAnovaPValue(Collection<double[]> categoryData)\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaPValue(categoryData);\n     }\n      *\n      * @since 1.2\n      */\n-    public static boolean oneWayAnovaTest(Collection categoryData, double alpha)\n+    public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaTest(categoryData, alpha);\n     }\n--- a/src/java/org/apache/commons/math/util/TransformerMap.java\n+++ b/src/java/org/apache/commons/math/util/TransformerMap.java\n public class TransformerMap implements NumberTransformer, Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -942772950698439883L;\n-    \n+    private static final long serialVersionUID = 4605318041528645258L;\n+\n     /**\n      * A default Number Transformer for Numbers and numeric Strings.\n      */\n     /**\n      * The internal Map.\n      */\n-    private Map map = null;\n+    private Map<Class<?>, NumberTransformer> map = null;\n \n     /**\n-     * \n+     * Build a map containing only the default transformer.\n      */\n     public TransformerMap() {\n-        map = new HashMap();\n+        map = new HashMap<Class<?>, NumberTransformer>();\n         defaultTransformer = new DefaultTransformer();\n     }\n \n      * @param key Class to check\n      * @return true|false\n      */\n-    public boolean containsClass(Class key) {\n+    public boolean containsClass(Class<?> key) {\n         return map.containsKey(key);\n     }\n \n      * @param key The Class of the object\n      * @return the mapped NumberTransformer or null.\n      */\n-    public NumberTransformer getTransformer(Class key) {\n+    public NumberTransformer getTransformer(Class<?> key) {\n         return (NumberTransformer) map.get(key);\n     }\n \n      * @param transformer The NumberTransformer\n      * @return the replaced transformer if one is present\n      */\n-    public Object putTransformer(Class key, NumberTransformer transformer) {\n+    public NumberTransformer putTransformer(Class<?> key, NumberTransformer transformer) {\n         return map.put(key, transformer);\n     }\n \n      * @return the removed transformer if one is present or\n      * null if none was present.\n      */\n-    public Object removeTransformer(Class key) {\n+    public NumberTransformer removeTransformer(Class<?> key) {\n         return map.remove(key);\n     }\n \n      * Returns the Set of Classes used as keys in the map.\n      * @return Set of Classes\n      */\n-    public Set classes() {\n+    public Set<Class<?>> classes() {\n         return map.keySet();\n     }\n \n      * in the map.\n      * @return Set of NumberTransformers\n      */\n-    public Collection transformers() {\n+    public Collection<NumberTransformer> transformers() {\n         return map.values();\n     }\n \n--- a/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n \n import java.util.ArrayList;\n import java.util.HashSet;\n-import java.util.Iterator;\n-\n-import org.apache.commons.math.estimation.EstimatedParameter;\n-import org.apache.commons.math.estimation.EstimationException;\n-import org.apache.commons.math.estimation.EstimationProblem;\n-import org.apache.commons.math.estimation.GaussNewtonEstimator;\n-import org.apache.commons.math.estimation.WeightedMeasurement;\n-\n-import junit.framework.*;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n   private static class LinearProblem extends SimpleEstimationProblem {\n \n     public LinearProblem(LinearMeasurement[] measurements) {\n-      HashSet set = new HashSet();\n+      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();\n       for (int i = 0; i < measurements.length; ++i) {\n         addMeasurement(measurements[i]);\n         EstimatedParameter[] parameters = measurements[i].getParameters();\n           set.add(parameters[j]);\n         }\n       }\n-      for (Iterator iterator = set.iterator(); iterator.hasNext();) {\n-        addParameter((EstimatedParameter) iterator.next());\n+      for (EstimatedParameter p : set) {\n+        addParameter(p);\n       }\n     }\n \n     public Circle(double cx, double cy) {\n       this.cx = new EstimatedParameter(\"cx\", cx);\n       this.cy = new EstimatedParameter(new EstimatedParameter(\"cy\", cy));\n-      points  = new ArrayList();\n+      points  = new ArrayList<PointModel>();\n     }\n \n     public void addPoint(double px, double py) {\n \n     public double getPartialRadiusX() {\n       double dRdX = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdX += ((PointModel) iterator.next()).getPartialDiX();\n+      for (PointModel point : points) {\n+        dRdX += point.getPartialDiX();\n       }\n       return dRdX / points.size();\n     }\n \n     public double getPartialRadiusY() {\n       double dRdY = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdY += ((PointModel) iterator.next()).getPartialDiY();\n+      for (PointModel point : points) {\n+        dRdY += point.getPartialDiY();\n       }\n       return dRdY / points.size();\n     }\n \n    public double getRadius() {\n       double r = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        r += ((PointModel) iterator.next()).getCenterDistance();\n+      for (PointModel point : points) {\n+        r += point.getCenterDistance();\n       }\n       return r / points.size();\n     }\n \n     private EstimatedParameter cx;\n     private EstimatedParameter cy;\n-    private ArrayList points;\n+    private ArrayList<PointModel> points;\n \n   }\n \n--- a/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n package org.apache.commons.math.estimation;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Set;\n-\n-import org.apache.commons.math.estimation.EstimatedParameter;\n-import org.apache.commons.math.estimation.EstimationException;\n-import org.apache.commons.math.estimation.EstimationProblem;\n-import org.apache.commons.math.estimation.LevenbergMarquardtEstimator;\n-import org.apache.commons.math.estimation.WeightedMeasurement;\n-\n-import junit.framework.*;\n+import java.util.HashSet;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n     }\n \n     public EstimatedParameter[] getAllParameters() {\n-      HashMap map = new HashMap();\n+      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();\n       for (int i = 0; i < measurements.length; ++i) {\n         EstimatedParameter[] parameters = measurements[i].getParameters();\n         for (int j = 0; j < parameters.length; ++j) {\n-          map.put(parameters[j], null);\n+          set.add(parameters[j]);\n         }\n       }\n-      Set set = map.keySet();\n       return (EstimatedParameter[]) set.toArray(new EstimatedParameter[set.size()]);\n     }\n   \n     public Circle(double cx, double cy) {\n       this.cx = new EstimatedParameter(\"cx\", cx);\n       this.cy = new EstimatedParameter(\"cy\", cy);\n-      points  = new ArrayList();\n+      points  = new ArrayList<PointModel>();\n     }\n \n     public void addPoint(double px, double py) {\n \n     public double getPartialRadiusX() {\n       double dRdX = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdX += ((PointModel) iterator.next()).getPartialDiX();\n+      for (PointModel point : points) {\n+        dRdX += point.getPartialDiX();\n       }\n       return dRdX / points.size();\n     }\n \n     public double getPartialRadiusY() {\n       double dRdY = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdY += ((PointModel) iterator.next()).getPartialDiY();\n+      for (PointModel point : points) {\n+        dRdY += point.getPartialDiY();\n       }\n       return dRdY / points.size();\n     }\n \n    public double getRadius() {\n       double r = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        r += ((PointModel) iterator.next()).getCenterDistance();\n+      for (PointModel point : points) {\n+        r += point.getCenterDistance();\n       }\n       return r / points.size();\n     }\n \n     private EstimatedParameter cx;\n     private EstimatedParameter cy;\n-    private ArrayList points;\n+    private ArrayList<PointModel> points;\n \n   }\n \n--- a/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n  */\n package org.apache.commons.math.random;\n \n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n import java.io.BufferedReader;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.net.URL;\n import java.util.ArrayList;\n-import java.util.Iterator;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n \n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.TestUtils;\n                 new BufferedReader(new InputStreamReader(\n                         url.openStream()));\n         String str = null;\n-        ArrayList list = new ArrayList();\n+        ArrayList<Double> list = new ArrayList<Double>();\n         while ((str = in.readLine()) != null) {\n             list.add(Double.valueOf(str));\n         }\n         \n         dataArray = new double[list.size()];\n         int i = 0;\n-        for (Iterator iter = list.iterator(); iter.hasNext();) {\n-            dataArray[i] = ((Double)iter.next()).doubleValue();\n+        for (Double data : list) {\n+            dataArray[i] = data.doubleValue();\n             i++;\n         }                 \n     }\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n        long[] observed = {0,0,0,0,0,0,0,0,0,0};\n        double[] expected = {100,100,100,100,100,100,100,100,100,100};\n        \n-       HashSet cPop = new HashSet();  //{0,1,2,3,4}\n+       HashSet<Object> cPop = new HashSet<Object>();  //{0,1,2,3,4}\n        for (int i = 0; i < 5; i++) {\n            cPop.add(Integer.toString(i));\n        }\n        \n        Object[] sets = new Object[10]; // 2-sets from 5\n        for (int i = 0; i < 10; i ++) {\n-           HashSet hs = new HashSet();\n+           HashSet<Object> hs = new HashSet<Object>();\n            hs.add(c[i][0]);\n            hs.add(c[i][1]);\n            sets[i] = hs;\n             testStatistic.chiSquare(expected,observed) < 27.88);  \n        \n        // Make sure sample of size = size of collection returns same collection\n-       HashSet hs = new HashSet();\n+       HashSet<Object> hs = new HashSet<Object>();\n        hs.add(\"one\");\n        Object[] one = randomData.nextSample(hs,1);\n        String oneString = (String) one[0];\n        \n        // Make sure we fail for empty collection\n        try {\n-           hs = new HashSet();\n+           hs = new HashSet<Object>();\n            one = randomData.nextSample(hs,0);\n            fail(\"n = k = 0, expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     private int findSample(Object[] u, Object[] samp) {\n         for (int i = 0; i < u.length; i++) {\n-            HashSet set = (HashSet) u[i];\n-            HashSet sampSet = new HashSet();\n+            HashSet<Object> set = (HashSet<Object>) u[i];\n+            HashSet<Object> sampSet = new HashSet<Object>();\n             for (int j = 0; j < samp.length; j++) {\n                 sampSet.add(samp[j]);\n             }\n--- a/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n import java.lang.reflect.Method;\n import java.net.URL;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.Map;\n+\n+import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n-\n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n     \n     private SummaryStatistics summaries;\n     \n-    private Map certifiedValues;\n+    private Map<String, Double> certifiedValues;\n     \n     protected void setUp() throws Exception {\n         descriptives = new DescriptiveStatistics();\n         summaries = new SummaryStatistics();\n-        certifiedValues = new HashMap();\n+        certifiedValues = new HashMap<String, Double>();\n         \n         loadData();\n     }\n     }\n     \n     public void testCertifiedValues() {\n-        Iterator iter = certifiedValues.keySet().iterator();\n-\n-        while (iter.hasNext()) {\n-            String name = iter.next().toString();\n+        for (String name : certifiedValues.keySet()) {\n             Double expectedValue = (Double)certifiedValues.get(name);\n \n             Double summariesValue = getProperty(summaries, name);\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n      * Holds a reference to a list - GENERICs are going to make\n      * our lives easier here as we could only accept List<Number>\n      */\n-    protected List list;\n+    protected List<Object> list;\n \n     /** Number Transformer maps Objects to Number for us. */\n     protected NumberTransformer transformer;\n      * No argument Constructor\n      */\n     public ListUnivariateImpl(){\n-        this(new ArrayList());\n+        this(new ArrayList<Object>());\n     }\n     \n     /**\n      * Construct a ListUnivariate with a specific List.\n      * @param list The list that will back this DescriptiveStatistics\n      */\n-    public ListUnivariateImpl(List list) {\n+    public ListUnivariateImpl(List<Object> list) {\n         this(list, new DefaultTransformer());\n     }\n     \n      * @param list The list that will back this DescriptiveStatistics\n      * @param transformer the number transformer used to convert the list items.\n      */\n-    public ListUnivariateImpl(List list, NumberTransformer transformer) {\n+    public ListUnivariateImpl(List<Object> list, NumberTransformer transformer) {\n         super();\n         this.list = list;\n         this.transformer = transformer;\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n     \n     /** test stats */\n     public void testStats() {\n-        List externalList = new ArrayList();\n+        List<Object> externalList = new ArrayList<Object>();\n         \n         DescriptiveStatistics u = new ListUnivariateImpl( externalList ); \n \n     }     \n     \n     public void testN0andN1Conditions() throws Exception {\n-        List list = new ArrayList();\n+        List<Object> list = new ArrayList<Object>();\n         \n         DescriptiveStatistics u = new ListUnivariateImpl( list );\n                 \n     }\n \n     public void testProductAndGeometricMean() throws Exception {\n-        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());\n         u.setWindowSize(10);\n                 \n         u.addValue( 1.0 );\n--- a/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n \n     /** test stats */\n     public void testStats() {\n-        List externalList = new ArrayList();\n+        List<Object> externalList = new ArrayList<Object>();\n \n         DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);\n \n     }\n \n     public void testN0andN1Conditions() throws Exception {\n-        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);\n+        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n \n         assertTrue(\n             \"Mean of n = 0 set should be NaN\",\n \n     public void testSkewAndKurtosis() {\n         ListUnivariateImpl u =\n-            new ListUnivariateImpl(new ArrayList(), transformers);\n+            new ListUnivariateImpl(new ArrayList<Object>(), transformers);\n \n         u.addObject(\"12.5\");\n         u.addObject(new Integer(12));\n     }\n \n     public void testProductAndGeometricMean() throws Exception {\n-        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n         u.setWindowSize(10);\n \n         u.addValue(1.0);\n--- a/src/test/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n \n     protected OneWayAnova testStatistic = new OneWayAnovaImpl();\n     \n-    private char[] wrongArray = { 'a', 'b', 'c' };\n     private double[] emptyArray = {};\n \n     private double[] classA =\n \n     public void testAnovaFValue() throws Exception {\n         // Target comparison values computed using R version 2.6.0 (Linux version)\n-        List threeClasses = new ArrayList();\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classA);\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n         assertEquals(\"ANOVA F-value\",  24.67361709460624,\n                  testStatistic.anovaFValue(threeClasses), 1E-12);\n \n-        List twoClasses = new ArrayList();\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n         \n         assertEquals(\"ANOVA F-value\",  0.0150579150579,\n                  testStatistic.anovaFValue(twoClasses), 1E-12);\n \n-        // now try some input hashes which should fail\n-        List wrongContents = new ArrayList();\n-        wrongContents.add(classC);\n-        wrongContents.add(wrongArray);\n-        try {\n-            testStatistic.anovaFValue(wrongContents);\n-            fail(\"non double[] hash value for key classX, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }  \n-\n-        List emptyContents = new ArrayList();\n+        List<double[]> emptyContents = new ArrayList<double[]>();\n         emptyContents.add(emptyArray);\n         emptyContents.add(classC);\n         try {\n             // expected\n         }  \n \n-        List tooFew = new ArrayList();\n+        List<double[]> tooFew = new ArrayList<double[]>();\n         tooFew.add(classA);\n         try {\n             testStatistic.anovaFValue(tooFew);\n \n     public void testAnovaPValue() throws Exception {\n         // Target comparison values computed using R version 2.6.0 (Linux version)\n-        List threeClasses = new ArrayList();\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classA);\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n         assertEquals(\"ANOVA P-value\", 6.959446E-06,\n                  testStatistic.anovaPValue(threeClasses), 1E-12);\n \n-        List twoClasses = new ArrayList();\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n         \n \n     public void testAnovaTest() throws Exception {\n         // Target comparison values computed using R version 2.3.1 (Linux version)\n-        List threeClasses = new ArrayList();\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classA);\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n \n         assertTrue(\"ANOVA Test P<0.01\", testStatistic.anovaTest(threeClasses, 0.01));\n \n-        List twoClasses = new ArrayList();\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n         \n--- a/src/test/org/apache/commons/math/stat/inference/TestUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/TestUtilsTest.java\n     private double[] classC =\n       {110.0, 115.0, 111.0, 117.0, 128.0};\n     \n-    private List classes = new ArrayList();\n+    private List<double[]> classes = new ArrayList<double[]>();\n     private OneWayAnova oneWayAnova = new OneWayAnovaImpl();\n     \n     public void testOneWayAnovaUtils() throws Exception {", "timestamp": 1211139443, "metainfo": ""}