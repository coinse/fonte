{"sha": "e129944033ea3d8ff38c8c7a1b001bf7ad0fae1e", "log": "JIRA:MATH-678 Adding this testfile as a record, most tests are commented out  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/BatteryNISTTest.java\n+/*\n+ * Copyright 2011 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import junit.framework.Assert;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.optimization.direct.BOBYQAOptimizer;\n+import org.apache.commons.math.optimization.direct.PowellOptimizer;\n+import org.apache.commons.math.optimization.general.AbstractScalarDifferentiableOptimizer;\n+import org.apache.commons.math.optimization.general.ConjugateGradientFormula;\n+import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Test;\n+\n+/**\n+ * an ever growing set of tests from NIST\n+ * http://www.itl.nist.gov/div898/strd/nls/nls_main.shtml\n+ * @author gregs\n+ */\n+public class BatteryNISTTest {\n+\n+    public static double[] lanczosNIST = {\n+        2.5134, 0.00000,\n+        2.0443, 5.00000e-2,\n+        1.6684, 1.00000e-1,\n+        1.3664, 1.50000e-1,\n+        1.1232, 2.00000e-1,\n+        0.9269, 2.50000e-1,\n+        0.7679, 3.00000e-1,\n+        0.6389, 3.50000e-1,\n+        0.5338, 4.00000e-1,\n+        0.4479, 4.50000e-1,\n+        0.3776, 5.00000e-1,\n+        0.3197, 5.50000e-1,\n+        0.2720, 6.00000e-1,\n+        0.2325, 6.50000e-1,\n+        0.1997, 7.00000e-1,\n+        0.1723, 7.50000e-1,\n+        0.1493, 8.00000e-1,\n+        0.1301, 8.50000e-1,\n+        0.1138, 9.00000e-1,\n+        0.1000, 9.50000e-1,\n+        0.0883, 1.00000,\n+        0.0783, 1.05000,\n+        0.0698, 1.10000,\n+        0.0624, 1.15000};\n+    /* the lanzcos objective function -------------------------------*/\n+    private final nistMVRF lanczosObjectFunc = new nistMVRF(lanczosNIST, 1, 24, 6) {\n+\n+        @Override\n+        protected double partialDeriv(double[] point, int idx) {\n+            double cy, cx, r, ret = 0.0, d;\n+            int ptr = 0, ptr1;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                ptr1 = 0;\n+                d = 0.0;\n+                for (int j = 0; j < 3; j++) {\n+                    d += point[ptr1++] * FastMath.exp(-cx * point[ptr1++]);\n+                }\n+                r = cy - d;\n+                if (idx == 0) {\n+                    ret -= (2.0 * r) * FastMath.exp(-cx * point[1]);\n+                } else if (idx == 1) {\n+                    ret += (2.0 * r) * FastMath.exp(-cx * point[1]) * cx * point[0];\n+                } else if (idx == 2) {\n+                    ret -= (2.0 * r) * FastMath.exp(-cx * point[3]);\n+                } else if (idx == 3) {\n+                    ret += (2.0 * r) * FastMath.exp(-cx * point[3]) * cx * point[2];\n+                } else if (idx == 4) {\n+                    ret -= (2.0 * r) * FastMath.exp(-cx * point[5]);\n+                } else {\n+                    ret += (2.0 * r) * FastMath.exp(-cx * point[5]) * cx * point[4];\n+                }\n+            }\n+            return (ret);\n+        }\n+\n+        public double value(double[] point) {\n+            double ret = 0.0, err, d, cx, cy;\n+            int ptr = 0, ptr1 = 0;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                d = 0.0;\n+                ptr1 = 0;\n+                for (int j = 0; j < 3; j++) {\n+                    d += point[ptr1++] * FastMath.exp(-cx * point[ptr1++]);\n+                }\n+                err = cy - d;\n+                ret += err * err;\n+            }\n+            return (ret);\n+        }\n+\n+        @Override\n+        protected double[] getGradient(double[] point) {\n+            Arrays.fill(gradient, 0.0);\n+            double cy, cx, r, d = 0;\n+            int ptr = 0, ptr1;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                ptr1 = 0;\n+                d = 0.0;\n+                for (int j = 0; j < 3; j++) {\n+                    d += point[ptr1++] * FastMath.exp(-cx * point[ptr1++]);\n+                }\n+                r = cy - d;\n+                gradient[0] -= (2.0 * r) * FastMath.exp(-cx * point[1]);\n+                gradient[1] += (2.0 * r) * FastMath.exp(-cx * point[1]) * cx * point[0];\n+\n+                gradient[2] -= (2.0 * r) * FastMath.exp(-cx * point[3]);\n+                gradient[3] += (2.0 * r) * FastMath.exp(-cx * point[3]) * cx * point[2];\n+\n+                gradient[4] -= (2.0 * r) * FastMath.exp(-cx * point[5]);\n+                gradient[5] += (2.0 * r) * FastMath.exp(-cx * point[5]) * cx * point[4];\n+            }\n+            return this.gradient;\n+        }\n+    };\n+\n+   /* chwirut1 data ------------------------*/\n+    public static double[] chwirut1NIST = {\n+        92.9000, 0.5000,\n+        78.7000, 0.6250,\n+        64.2000, 0.7500,\n+        64.9000, 0.8750,\n+        57.1000, 1.0000,\n+        43.3000, 1.2500,\n+        31.1000, 1.7500,\n+        23.6000, 2.2500,\n+        31.0500, 1.7500,\n+        23.7750, 2.2500,\n+        17.7375, 2.7500,\n+        13.8000, 3.2500,\n+        11.5875, 3.7500,\n+        9.4125, 4.2500,\n+        7.7250, 4.7500,\n+        7.3500, 5.2500,\n+        8.0250, 5.7500,\n+        90.6000, 0.5000,\n+        76.9000, 0.6250,\n+        71.6000, 0.7500,\n+        63.6000, 0.8750,\n+        54.0000, 1.0000,\n+        39.2000, 1.2500,\n+        29.3000, 1.7500,\n+        21.4000, 2.2500,\n+        29.1750, 1.7500,\n+        22.1250, 2.2500,\n+        17.5125, 2.7500,\n+        14.2500, 3.2500,\n+        9.4500, 3.7500,\n+        9.1500, 4.2500,\n+        7.9125, 4.7500,\n+        8.4750, 5.2500,\n+        6.1125, 5.7500,\n+        80.0000, 0.5000,\n+        79.0000, 0.6250,\n+        63.8000, 0.7500,\n+        57.2000, 0.8750,\n+        53.2000, 1.0000,\n+        42.5000, 1.2500,\n+        26.8000, 1.7500,\n+        20.4000, 2.2500,\n+        26.8500, 1.7500,\n+        21.0000, 2.2500,\n+        16.4625, 2.7500,\n+        12.5250, 3.2500,\n+        10.5375, 3.7500,\n+        8.5875, 4.2500,\n+        7.1250, 4.7500,\n+        6.1125, 5.2500,\n+        5.9625, 5.7500,\n+        74.1000, 0.5000,\n+        67.3000, 0.6250,\n+        60.8000, 0.7500,\n+        55.5000, 0.8750,\n+        50.3000, 1.0000,\n+        41.0000, 1.2500,\n+        29.4000, 1.7500,\n+        20.4000, 2.2500,\n+        29.3625, 1.7500,\n+        21.1500, 2.2500,\n+        16.7625, 2.7500,\n+        13.2000, 3.2500,\n+        10.8750, 3.7500,\n+        8.1750, 4.2500,\n+        7.3500, 4.7500,\n+        5.9625, 5.2500,\n+        5.6250, 5.7500,\n+        81.5000, .5000,\n+        62.4000, .7500,\n+        32.5000, 1.5000,\n+        12.4100, 3.0000,\n+        13.1200, 3.0000,\n+        15.5600, 3.0000,\n+        5.6300, 6.0000,\n+        78.0000, .5000,\n+        59.9000, .7500,\n+        33.2000, 1.5000,\n+        13.8400, 3.0000,\n+        12.7500, 3.0000,\n+        14.6200, 3.0000,\n+        3.9400, 6.0000,\n+        76.8000, .5000,\n+        61.0000, .7500,\n+        32.9000, 1.5000,\n+        13.8700, 3.0000,\n+        11.8100, 3.0000,\n+        13.3100, 3.0000,\n+        5.4400, 6.0000,\n+        78.0000, .5000,\n+        63.5000, .7500,\n+        33.8000, 1.5000,\n+        12.5600, 3.0000,\n+        5.6300, 6.0000,\n+        12.7500, 3.0000,\n+        13.1200, 3.0000,\n+        5.4400, 6.0000,\n+        76.8000, .5000,\n+        60.0000, .7500,\n+        47.8000, 1.0000,\n+        32.0000, 1.5000,\n+        22.2000, 2.0000,\n+        22.5700, 2.0000,\n+        18.8200, 2.5000,\n+        13.9500, 3.0000,\n+        11.2500, 4.0000,\n+        9.0000, 5.0000,\n+        6.6700, 6.0000,\n+        75.8000, .5000,\n+        62.0000, .7500,\n+        48.8000, 1.0000,\n+        35.2000, 1.5000,\n+        20.0000, 2.0000,\n+        20.3200, 2.0000,\n+        19.3100, 2.5000,\n+        12.7500, 3.0000,\n+        10.4200, 4.0000,\n+        7.3100, 5.0000,\n+        7.4200, 6.0000,\n+        70.5000, .5000,\n+        59.5000, .7500,\n+        48.5000, 1.0000,\n+        35.8000, 1.5000,\n+        21.0000, 2.0000,\n+        21.6700, 2.0000,\n+        21.0000, 2.5000,\n+        15.6400, 3.0000,\n+        8.1700, 4.0000,\n+        8.5500, 5.0000,\n+        10.1200, 6.0000,\n+        78.0000, .5000,\n+        66.0000, .6250,\n+        62.0000, .7500,\n+        58.0000, .8750,\n+        47.7000, 1.0000,\n+        37.8000, 1.2500,\n+        20.2000, 2.2500,\n+        21.0700, 2.2500,\n+        13.8700, 2.7500,\n+        9.6700, 3.2500,\n+        7.7600, 3.7500,\n+        5.4400, 4.2500,\n+        4.8700, 4.7500,\n+        4.0100, 5.2500,\n+        3.7500, 5.7500,\n+        24.1900, 3.0000,\n+        25.7600, 3.0000,\n+        18.0700, 3.0000,\n+        11.8100, 3.0000,\n+        12.0700, 3.0000,\n+        16.1200, 3.0000,\n+        70.8000, .5000,\n+        54.7000, .7500,\n+        48.0000, 1.0000,\n+        39.8000, 1.5000,\n+        29.8000, 2.0000,\n+        23.7000, 2.5000,\n+        29.6200, 2.0000,\n+        23.8100, 2.5000,\n+        17.7000, 3.0000,\n+        11.5500, 4.0000,\n+        12.0700, 5.0000,\n+        8.7400, 6.0000,\n+        80.7000, .5000,\n+        61.3000, .7500,\n+        47.5000, 1.0000,\n+        29.0000, 1.5000,\n+        24.0000, 2.0000,\n+        17.7000, 2.5000,\n+        24.5600, 2.0000,\n+        18.6700, 2.5000,\n+        16.2400, 3.0000,\n+        8.7400, 4.0000,\n+        7.8700, 5.0000,\n+        8.5100, 6.0000,\n+        66.7000, .5000,\n+        59.2000, .7500,\n+        40.8000, 1.0000,\n+        30.7000, 1.5000,\n+        25.7000, 2.0000,\n+        16.3000, 2.5000,\n+        25.9900, 2.0000,\n+        16.9500, 2.5000,\n+        13.3500, 3.0000,\n+        8.6200, 4.0000,\n+        7.2000, 5.0000,\n+        6.6400, 6.0000,\n+        13.6900, 3.0000,\n+        81.0000, .5000,\n+        64.5000, .7500,\n+        35.5000, 1.5000,\n+        13.3100, 3.0000,\n+        4.8700, 6.0000,\n+        12.9400, 3.0000,\n+        5.0600, 6.0000,\n+        15.1900, 3.0000,\n+        14.6200, 3.0000,\n+        15.6400, 3.0000,\n+        25.5000, 1.7500,\n+        25.9500, 1.7500,\n+        81.7000, .5000,\n+        61.6000, .7500,\n+        29.8000, 1.7500,\n+        29.8100, 1.7500,\n+        17.1700, 2.7500,\n+        10.3900, 3.7500,\n+        28.4000, 1.7500,\n+        28.6900, 1.7500,\n+        81.3000, .5000,\n+        60.9000, .7500,\n+        16.6500, 2.7500,\n+        10.0500, 3.7500,\n+        28.9000, 1.7500,\n+        28.9500, 1.7500\n+    };\n+\n+    /* the chwirut1 objective function */\n+    private final nistMVRF chwirut1ObjectFunc = new chwirut(chwirut1NIST, 1, 214, 3);\n+\n+    //http://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Chwirut2.dat\n+    public static double[] chwirut2NIST = {\n+        92.9000, 0.500,\n+        57.1000, 1.000,\n+        31.0500, 1.750,\n+        11.5875, 3.750,\n+        8.0250, 5.750,\n+        63.6000, 0.875,\n+        21.4000, 2.250,\n+        14.2500, 3.250,\n+        8.4750, 5.250,\n+        63.8000, 0.750,\n+        26.8000, 1.750,\n+        16.4625, 2.750,\n+        7.1250, 4.750,\n+        67.3000, 0.625,\n+        41.0000, 1.250,\n+        21.1500, 2.250,\n+        8.1750, 4.250,\n+        81.5000, .500,\n+        13.1200, 3.000,\n+        59.9000, .750,\n+        14.6200, 3.000,\n+        32.9000, 1.500,\n+        5.4400, 6.000,\n+        12.5600, 3.000,\n+        5.4400, 6.000,\n+        32.0000, 1.500,\n+        13.9500, 3.000,\n+        75.8000, .500,\n+        20.0000, 2.000,\n+        10.4200, 4.000,\n+        59.5000, .750,\n+        21.6700, 2.000,\n+        8.5500, 5.000,\n+        62.0000, .750,\n+        20.2000, 2.250,\n+        7.7600, 3.750,\n+        3.7500, 5.750,\n+        11.8100, 3.000,\n+        54.7000, .750,\n+        23.7000, 2.500,\n+        11.5500, 4.000,\n+        61.3000, .750,\n+        17.7000, 2.500,\n+        8.7400, 4.000,\n+        59.2000, .750,\n+        16.3000, 2.500,\n+        8.6200, 4.000,\n+        81.0000, .500,\n+        4.8700, 6.000,\n+        14.6200, 3.000,\n+        81.7000, .500,\n+        17.1700, 2.750,\n+        81.3000, .500,\n+        28.9000, 1.750\n+    };\n+    \n+    /* the chwirut 2 objective --------------------------------------------------*/\n+    private final nistMVRF chwirut2ObjectFunc = new chwirut(chwirut2NIST, 1, 54, 3);\n+    \n+    //http://www.itl.nist.gov/div898/strd/nls/data/LINKS/DATA/Misra1a.dat\n+    //y               x\n+    private static double[] misra1aNIST = {\n+        10.07, 77.6,\n+        14.73, 114.9,\n+        17.94, 141.1,\n+        23.93, 190.8,\n+        29.61, 239.9,\n+        35.18, 289.0,\n+        40.02, 332.8,\n+        44.82, 378.4,\n+        50.76, 434.8,\n+        55.05, 477.3,\n+        61.01, 536.8,\n+        66.40, 593.1,\n+        75.47, 689.1,\n+        81.78, 760.0\n+    };\n+\n+    /* the misra1a objective function */\n+    private final nistMVRF misra1aObjectFunc = new nistMVRF(misra1aNIST, 1, 14, 2) {\n+\n+        @Override\n+        protected double partialDeriv(double[] point, int idx) {\n+            double cy, cx, r, ret = 0.0;\n+            int ptr = 0;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                r = cy - point[0] * (1.0 - FastMath.exp(-cx * point[1]));\n+                if (idx == 0) {\n+                    ret -= (2.0 * r) * (1.0 - FastMath.exp(-cx * point[1]));\n+                } else {\n+                    ret -= (2.0 * r) * cx * point[0] * FastMath.exp(-cx * point[1]);\n+                }\n+            }\n+            return (ret);\n+        }\n+\n+        public double value(double[] point) {\n+            double ret = 0.0, err;\n+            int ptr = 0;\n+            for (int i = 0; i < this.nobs; i++) {\n+                err = data[ptr++] - point[0] * (1.0 - FastMath.exp(-data[ptr++] * point[1]));\n+                ret += err * err;\n+            }\n+            return (ret);\n+        }\n+\n+        @Override\n+        protected double[] getGradient(double[] point) {\n+            Arrays.fill(gradient, 0.0);\n+            double cy, cx, r;\n+            int ptr = 0;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                r = cy - point[0] * (1.0 - FastMath.exp(-cx * point[1]));\n+                gradient[0] -= (2.0 * r) * (1.0 - FastMath.exp(-cx * point[1]));\n+                gradient[1] -= (2.0 * r) * cx * point[0] * FastMath.exp(-cx * point[1]);\n+            }\n+            return this.gradient;\n+        }\n+    };\n+    private static double[] correctParamMisra1a = {2.3894212918e2, 5.5015643181E-4};\n+    private static double[] correctParamChwirut2 = {1.6657666537e-1, 5.1653291286e-3, 1.2150007096e-2};\n+    private static double[] correctParamChwirut1 = {1.9027818370e-1, 6.1314004477e-3, 1.0530908399e-2};\n+    private static double[] correctParamLanczos = {8.6816414977e-2, 9.5498101505e-01, 8.4400777463E-01, 2.9515951832, 1.5825685901, 4.9863565084};\n+\n+    @Test\n+    public void lanczosTest() {\n+        //first check to see that the NIST Object function is being replicated correctly\n+        double obj = this.lanczosObjectFunc.value(correctParamLanczos);\n+        Assert.assertEquals(1.6117193594E-08, obj, 1.0e-8);\n+\n+        double[] grad = this.lanczosObjectFunc.getGradient(correctParamLanczos);\n+        double[] grad2 = new double[6];\n+        grad2[0] = this.lanczosObjectFunc.partialDeriv(correctParamLanczos, 0);\n+        grad2[1] = this.lanczosObjectFunc.partialDeriv(correctParamLanczos, 1);\n+        grad2[2] = this.lanczosObjectFunc.partialDeriv(correctParamLanczos, 2);\n+        grad2[3] = this.lanczosObjectFunc.partialDeriv(correctParamLanczos, 3);\n+        grad2[4] = this.lanczosObjectFunc.partialDeriv(correctParamLanczos, 4);\n+        grad2[5] = this.lanczosObjectFunc.partialDeriv(correctParamLanczos, 5);\n+        TestUtils.assertEquals(\"Grads...\", grad, grad2, 1.0e-12);\n+\n+        double[] n_grad = this.getGradient(lanczosObjectFunc, correctParamLanczos, 1.0e-5);\n+        //System.out.println(\"g = \" + grad[0] + \" ng = \" + n_grad[0]);\n+        //System.out.println(\"g = \" + grad[1] + \" ng = \" + n_grad[1]);\n+        if (FastMath.abs(grad[0] - n_grad[0]) > FastMath.max(1.0e-6, 1.0e-6 * (grad[0] + n_grad[0]) / 2.0)) {\n+            Assert.fail(\"Check gradient at 1\");\n+        }\n+        if (FastMath.abs(grad[1] - n_grad[1]) > FastMath.max(1.0e-6, 1.0e-6 * (grad[1] + n_grad[1]) / 2.0)) {\n+            Assert.fail(\"Check gradient at 2\");\n+        }\n+        if (FastMath.abs(grad[2] - n_grad[2]) > FastMath.max(1.0e-6, 1.0e-6 * (grad[2] + n_grad[2]) / 2.0)) {\n+            Assert.fail(\"Check gradient at 2\");\n+        }\n+        if (FastMath.abs(grad[3] - n_grad[3]) > FastMath.max(1.0e-6, 1.0e-6 * (grad[3] + n_grad[3]) / 2.0)) {\n+            Assert.fail(\"Check gradient at 2\");\n+        }\n+        if (FastMath.abs(grad[4] - n_grad[4]) > FastMath.max(1.0e-6, 1.0e-6 * (grad[4] + n_grad[4]) / 2.0)) {\n+            Assert.fail(\"Check gradient at 2\");\n+        }\n+        if (FastMath.abs(grad[5] - n_grad[5]) > FastMath.max(1.0e-6, 1.0e-6 * (grad[5] + n_grad[5]) / 2.0)) {\n+            Assert.fail(\"Check gradient at 2\");\n+        }\n+        return;\n+    }\n+\n+    //@Test\n+    public void lanczos_BOBYQA() {\n+        double[] bobyqa = run(new BOBYQAOptimizer(10),\n+                lanczosObjectFunc, new double[]{1.2,0.3,5.6,5.5,6.5,7.6});\n+        TestUtils.assertEquals(correctParamLanczos, bobyqa, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void lanczosTest_cgPolakRibiere() {\n+        double[] cgPolakRibiere = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                lanczosObjectFunc, new double[]{1.2,0.3,5.6,5.5,6.5,7.6});\n+        TestUtils.assertEquals(correctParamLanczos, cgPolakRibiere, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void lanczosTest_cgPolakRibiere2() {\n+        double[] cgPolakRibiere2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                lanczosObjectFunc, new double[]{0.5,0.7,3.6,4.2,4,6.3});\n+        TestUtils.assertEquals(correctParamLanczos, cgPolakRibiere2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void lanczosTest_cgFletcherReeves() {\n+        double[] cgFletcherReeves = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                lanczosObjectFunc, new double[]{1.2,0.3,5.6,5.5,6.5,7.6});\n+        TestUtils.assertEquals(correctParamLanczos, cgFletcherReeves, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void lanczosTest_cgFletcherReeves2() {\n+        double[] cgFletcherReeves2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                lanczosObjectFunc, new double[]{0.5,0.7,3.6,4.2,4,6.3});\n+        TestUtils.assertEquals(correctParamLanczos, cgFletcherReeves2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void lanczosTest_powell() {\n+        double[] resPowell = run(new PowellOptimizer(1.0e-8, 1.0e-8), lanczosObjectFunc,\n+                new double[]{1.2,0.3,5.6,5.5,6.5,7.6});\n+        TestUtils.assertEquals(correctParamLanczos, resPowell, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void lanczosTest_powell2() {\n+        double[] resPowell2 = run(new PowellOptimizer(1.0e-8, 1.0e-8), lanczosObjectFunc,\n+                new double[]{0.5,0.7,3.6,4.2,4,6.3});\n+        TestUtils.assertEquals(correctParamLanczos, resPowell2, 1.0e-8);\n+    }\n+\n+    @Test\n+    public void chwirut1Test() {\n+        //first check to see that the NIST Object function is being replicated correctly\n+        double obj = this.chwirut1ObjectFunc.value(correctParamChwirut1);\n+        Assert.assertEquals(2.3844771393e3, obj, 1.0e-8);\n+\n+        double[] grad = this.chwirut1ObjectFunc.getGradient(correctParamChwirut1);\n+        double[] grad2 = new double[3];\n+        grad2[0] = this.chwirut1ObjectFunc.partialDeriv(correctParamChwirut1, 0);\n+        grad2[1] = this.chwirut1ObjectFunc.partialDeriv(correctParamChwirut1, 1);\n+        grad2[2] = this.chwirut1ObjectFunc.partialDeriv(correctParamChwirut1, 2);\n+        TestUtils.assertEquals(\"Grads...\", grad, grad2, 1.0e-12);\n+        return;\n+    }\n+\n+    //@Test\n+    public void chwirut1_BOBYQA() {\n+        double[] bobyqa = run(new BOBYQAOptimizer(5),\n+                chwirut1ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut1, bobyqa, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut1Test_cgPolakRibiere() {\n+        double[] cgPolakRibiere = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                chwirut1ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut1, cgPolakRibiere, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut1Test_cgPolakRibiere2() {\n+        double[] cgPolakRibiere2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                chwirut1ObjectFunc, new double[]{0.15, 0.008, 0.01});\n+        TestUtils.assertEquals(correctParamChwirut1, cgPolakRibiere2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut1Test_cgFletcherReeves() {\n+        double[] cgFletcherReeves = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                chwirut1ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut1, cgFletcherReeves, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut1Test_cgFletcherReeves2() {\n+        double[] cgFletcherReeves2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                chwirut1ObjectFunc, new double[]{0.15, 0.008, 0.01});\n+        TestUtils.assertEquals(correctParamChwirut1, cgFletcherReeves2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut1Test_powell() {\n+        double[] resPowell = run(new PowellOptimizer(1.0e-8, 1.0e-8), chwirut1ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut1, resPowell, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut1Test_powell2() {\n+        double[] resPowell2 = run(new PowellOptimizer(1.0e-8, 1.0e-8), chwirut1ObjectFunc, new double[]{0.15, 0.08, 0.01});\n+        TestUtils.assertEquals(correctParamChwirut1, resPowell2, 1.0e-8);\n+    }\n+\n+    @Test\n+    public void chwirut2Test() {\n+        //first check to see that the NIST Object function is being replicated correctly\n+        double obj = this.chwirut2ObjectFunc.value(correctParamChwirut2);\n+        Assert.assertEquals(5.1304802941e02, obj, 1.0e-8);\n+\n+        double[] grad = this.chwirut2ObjectFunc.getGradient(correctParamChwirut2);\n+        double[] grad2 = new double[3];\n+        grad2[0] = this.chwirut2ObjectFunc.partialDeriv(correctParamChwirut2, 0);\n+        grad2[1] = this.chwirut2ObjectFunc.partialDeriv(correctParamChwirut2, 1);\n+        grad2[2] = this.chwirut2ObjectFunc.partialDeriv(correctParamChwirut2, 2);\n+        TestUtils.assertEquals(\"Grads...\", grad, grad2, 1.0e-12);\n+        return;\n+    }\n+\n+    //@Test\n+    public void chwirut2_BOBYQA() {\n+        double[] bobyqa = run(new BOBYQAOptimizer(5),\n+                chwirut2ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut2, bobyqa, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut2Test_cgPolakRibiere() {\n+        double[] cgPolakRibiere = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                chwirut2ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut2, cgPolakRibiere, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut2Test_cgPolakRibiere2() {\n+        double[] cgPolakRibiere2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                chwirut2ObjectFunc, new double[]{0.15, 0.008, 0.01});\n+        TestUtils.assertEquals(correctParamChwirut2, cgPolakRibiere2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut2Test_cgFletcherReeves() {\n+        double[] cgFletcherReeves = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                chwirut2ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut2, cgFletcherReeves, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut2Test_cgFletcherReeves2() {\n+        double[] cgFletcherReeves2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                chwirut2ObjectFunc, new double[]{0.15, 0.008, 0.01});\n+        TestUtils.assertEquals(correctParamChwirut2, cgFletcherReeves2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut2Test_powell() {\n+        double[] resPowell = run(new PowellOptimizer(1.0e-8, 1.0e-8), chwirut2ObjectFunc, new double[]{0.1, 0.01, 0.02});\n+        TestUtils.assertEquals(correctParamChwirut2, resPowell, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void chwirut2Test_powell2() {\n+        double[] resPowell2 = run(new PowellOptimizer(1.0e-8, 1.0e-8), chwirut2ObjectFunc, new double[]{0.15, 0.08, 0.01});\n+        TestUtils.assertEquals(correctParamChwirut2, resPowell2, 1.0e-8);\n+    }\n+\n+    @Test\n+    public void misra1aTest() {\n+        //first check to see that the NIST Object function is being replicated correctly\n+        double obj = this.misra1aObjectFunc.value(correctParamMisra1a);\n+        Assert.assertEquals(1.2455138894e-01, obj, 1.0e-8);\n+\n+        double[] grad = this.misra1aObjectFunc.getGradient(correctParamMisra1a);\n+        double[] grad2 = new double[2];\n+        grad2[0] = this.misra1aObjectFunc.partialDeriv(correctParamMisra1a, 0);\n+        grad2[1] = this.misra1aObjectFunc.partialDeriv(correctParamMisra1a, 1);\n+\n+        TestUtils.assertEquals(\"Grads...\", grad, grad2, 1.0e-12);\n+\n+//        double[] n_grad = this.getGradient(misra1aObjectFunc, correctParamMisra1a, 1.0e-5);\n+//        System.out.println(\"g = \" + grad[0] + \" ng = \" + n_grad[0]);\n+//        System.out.println(\"g = \" + grad[1] + \" ng = \" + n_grad[1]);\n+//        if( FastMath.abs(grad[0] - n_grad[0] ) > FastMath.max(1.0e-6, 1.0e-6 * (grad[0]+n_grad[0])/2.0) ){\n+//            Assert.fail(\"Check gradient at 1\");\n+//        }\n+//        if( FastMath.abs(grad[1] - n_grad[1] ) > FastMath.max(1.0e-6, 1.0e-6 * (grad[1]+n_grad[1])/2.0) ){\n+//            Assert.fail(\"Check gradient at 2\");\n+//        }\n+        return;\n+    }\n+\n+    //@Test\n+    public void misra1a_BOBYQA() {\n+        double[] bobyqa = run(new BOBYQAOptimizer(4),\n+                misra1aObjectFunc, new double[]{500.0, 0.0001});\n+        TestUtils.assertEquals(correctParamMisra1a, bobyqa, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void misra1aTest_cgPolakRibiere() {\n+        double[] cgPolakRibiere = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                misra1aObjectFunc, new double[]{500.0, 0.0001});\n+        TestUtils.assertEquals(correctParamMisra1a, cgPolakRibiere, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void misra1aTest_cgPolakRibiere2() {\n+        double[] cgPolakRibiere2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE),\n+                misra1aObjectFunc, new double[]{250.0, 0.0005});\n+        TestUtils.assertEquals(correctParamMisra1a, cgPolakRibiere2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void misra1aTest_cgFletcherReeves() {\n+        double[] cgFletcherReeves = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                misra1aObjectFunc, new double[]{500.0, 0.0001});\n+        TestUtils.assertEquals(correctParamMisra1a, cgFletcherReeves, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void misra1aTest_cgFletcherReeves2() {\n+        double[] cgFletcherReeves2 = run(new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.FLETCHER_REEVES),\n+                misra1aObjectFunc, new double[]{250.0, 0.0005});\n+        TestUtils.assertEquals(correctParamMisra1a, cgFletcherReeves2, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void misra1aTest_powell() {\n+        double[] resPowell = run(new PowellOptimizer(1.0e-8, 1.0e-8), misra1aObjectFunc, new double[]{500.0, 0.0001});\n+        TestUtils.assertEquals(correctParamMisra1a, resPowell, 1.0e-8);\n+    }\n+\n+    //@Test\n+    public void misra1aTest_powell2() {\n+        double[] resPowell2 = run(new PowellOptimizer(1.0e-8, 1.0e-8), misra1aObjectFunc, new double[]{250.0, 0.0005});\n+        TestUtils.assertEquals(correctParamMisra1a, resPowell2, 1.0e-8);\n+    }\n+\n+    /* numerical gradients */\n+    private double[] getGradient(nistMVRF func, double[] xo, double eps) {\n+        double[] ret = new double[func.getNumberOfParameters()];\n+        for (int i = 0; i < ret.length; i++) {\n+            final double tmp = xo[i];\n+            xo[i] += eps;\n+            ret[i] = func.value(xo);\n+            xo[i] = tmp - eps;\n+            ret[i] -= func.value(xo);\n+            ret[i] /= (2.0 * eps);\n+            xo[i] = tmp;\n+        }\n+        return (ret);\n+    }\n+    \n+    /* generic test runner */\n+    private double[] run(MultivariateRealOptimizer optim, DifferentiableMultivariateRealFunction func, double[] start) {\n+        return (optim.optimize(1000000, func, GoalType.MINIMIZE, start).getPointRef());\n+    }\n+    /* generic test runner for AbstractScalarDifferentiableOptimizer */\n+    private double[] run(AbstractScalarDifferentiableOptimizer optim, DifferentiableMultivariateRealFunction func, double[] start) {\n+        return (optim.optimize(1000000, func, GoalType.MINIMIZE, start).getPointRef());\n+    }\n+\n+    /* base objective function class for these tests */\n+    private abstract static class nistMVRF implements DifferentiableMultivariateRealFunction {\n+        protected final MultivariateRealFunction[] mrf;\n+        protected final MultivariateVectorialFunction mvf = new MultivariateVectorialFunction() {\n+\n+            public double[] value(double[] point) throws IllegalArgumentException {\n+                return getGradient(point);\n+            }\n+        };\n+        protected double[] gradient;\n+        protected double[] data;\n+        protected int nvars;\n+        protected int nobs;\n+        protected int nparams;\n+\n+        public int getNumberOfParameters() {\n+            return nparams;\n+        }\n+\n+        public nistMVRF(double[] data, int nvars, int nobs, int nparams) {\n+            if ((nvars + 1) * nobs != data.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        LocalizedFormats.INVALID_REGRESSION_ARRAY, data.length, nobs, nvars);\n+            }\n+            this.nobs = nobs;\n+            this.nvars = nvars;\n+            this.gradient = new double[nparams];\n+            this.nparams = nparams;\n+            this.data = data;\n+            mrf = new MultivariateRealFunction[nvars];\n+            for (int i = 0; i < nvars; i++) {\n+                final int idx = i;\n+                mrf[i] = new MultivariateRealFunction() {\n+\n+                    private int myIdx = idx;\n+\n+                    public double value(double[] point) {\n+                        return partialDeriv(point, myIdx);\n+                    }\n+                };\n+            }\n+        }\n+\n+        public MultivariateVectorialFunction gradient() {\n+            return mvf;\n+        }\n+\n+        public MultivariateRealFunction partialDerivative(int k) {\n+            return mrf[k];\n+        }\n+\n+        protected abstract double partialDeriv(double[] point, int idx);\n+\n+        protected abstract double[] getGradient(double[] point);\n+    }\n+\n+    /* since there are multiple chwirut tests create an object       */\n+    private static class chwirut extends nistMVRF {\n+\n+        public chwirut(double[] data, int nvars, int nobs, int nparams) {\n+            super(data, nvars, nobs, nparams);\n+        }\n+\n+        @Override\n+        protected double partialDeriv(double[] point, int idx) {\n+            double cy, cx, r, ret = 0.0, d;\n+            int ptr = 0;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                d = (point[1] + point[2] * cx);\n+                r = cy - FastMath.exp(-cx * point[0]) / d;\n+                if (idx == 0) {\n+                    ret -= (2.0 * r * r) * cx;\n+                } else if (idx == 1) {\n+                    ret += (2.0 * r * r) / d;\n+                } else {\n+                    ret += (2.0 * r * r) * cx / d;\n+                }\n+            }\n+            return (ret);\n+        }\n+\n+        public double value(double[] point) {\n+            double ret = 0.0, err, cx, cy;\n+            int ptr = 0;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                err = cy - (FastMath.exp(-cx * point[0]) / (point[1] + point[2] * cx));\n+                ret += err * err;\n+            }\n+            return (ret);\n+        }\n+\n+        @Override\n+        protected double[] getGradient(double[] point) {\n+            Arrays.fill(gradient, 0.0);\n+            double cy, cx, r, d;\n+            int ptr = 0;\n+            for (int i = 0; i < this.nobs; i++) {\n+                cy = data[ptr++];\n+                cx = data[ptr++];\n+                d = (point[1] + point[2] * cx);\n+                r = cy - FastMath.exp(-cx * point[0]) / d;\n+                gradient[0] -= (2.0 * r * r) * cx;\n+                gradient[1] += (2.0 * r * r) / d;\n+                gradient[2] += (2.0 * r * r) * cx / d;\n+            }\n+            return this.gradient;\n+        }\n+    };\n+}", "timestamp": 1317434463, "metainfo": ""}