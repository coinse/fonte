{"sha": "b998c2fe8687c0fa38a0f0de9c15985fa9d70dc8", "log": "improve both numerical accuracy and speed by using optimized loops in reversed row order (i.e. from higher orders to lower orders) directly on matrix data.  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n import java.util.Arrays;\n \n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor;\n-import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n \n /**\n  * This class implements an interpolator for integrators using Nordsieck representation.\n     private double[] scaled;\n \n     /** Nordsieck vector. */\n-    private RealMatrix nordsieck;\n+    private Array2DRowRealMatrix nordsieck;\n \n     /** Simple constructor.\n      * This constructor builds an instance that is not usable yet, the\n             scaled = interpolator.scaled.clone();\n         }\n         if (interpolator.nordsieck != null) {\n-            nordsieck = interpolator.nordsieck.copy();\n+            nordsieck = new Array2DRowRealMatrix(interpolator.nordsieck.getDataRef(), true);\n         }\n     }\n \n      * nordsieck vector\n      */\n     public void reinitialize(final double referenceTime, final double scalingH,\n-                             final double[] scaled, final RealMatrix nordsieck) {\n+                             final double[] scaled, final Array2DRowRealMatrix nordsieck) {\n         this.referenceTime = referenceTime;\n         this.scalingH      = scalingH;\n         this.scaled        = scaled;\n      * @param scalingH new step size to use in the scaled and nordsieck arrays\n      */\n     public void rescale(final double scalingH) {\n+\n         final double ratio = scalingH / this.scalingH;\n         for (int i = 0; i < scaled.length; ++i) {\n             scaled[i] *= ratio;\n         }\n-        nordsieck.walkInOptimizedOrder(new Rescaler(ratio));\n+\n+        final double[][] nData = nordsieck.getDataRef();\n+        double power = ratio;\n+        for (int i = 0; i < nData.length; ++i) {\n+            power *= ratio;\n+            final double[] nDataI = nData[i];\n+            for (int j = 0; j < nDataI.length; ++j) {\n+                nDataI[j] *= power;\n+            }\n+        }\n+\n         this.scalingH = scalingH;\n+\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n+\n         final double x = interpolatedTime - referenceTime;\n-        nordsieck.walkInOptimizedOrder(new StateEstimator(x, x / scalingH));\n-    }\n-\n-    /** State estimator. */\n-    private class StateEstimator implements RealMatrixPreservingVisitor {\n-\n-        /** Scaling factor for derivative. */\n-        private final double scale;\n-\n-        /** First order power. */\n-        private final double lowPower;\n-\n-        /** High order powers. */\n-        private final double[] highPowers;\n-\n-        /** Simple constructor.\n-         * @param scale scaling factor for derivative\n-         * @param theta normalized interpolation abscissa within the step\n-         */\n-        public StateEstimator(final double scale, final double theta) {\n-            this.scale = scale;\n-            lowPower   = theta;\n-            highPowers = new double[nordsieck.getRowDimension()];\n-            double thetaN = theta;\n-            for (int i = 0; i < highPowers.length; ++i) {\n-                thetaN *= theta;\n-                highPowers[i] = thetaN;\n+        final double normalizedAbscissa = x / scalingH;\n+\n+        Arrays.fill(interpolatedState, 0.0);\n+        Arrays.fill(interpolatedDerivatives, 0.0);\n+\n+        // apply Taylor formula for high order to low order,\n+        // for the sake of numerical accuracy\n+        final double[][] nData = nordsieck.getDataRef();\n+        for (int i = nData.length - 1; i >= 0; --i) {\n+            final int order = i + 2;\n+            final double[] nDataI = nData[i];\n+            final double power = Math.pow(normalizedAbscissa, order);\n+            for (int j = 0; j < nDataI.length; ++j) {\n+                final double d = nDataI[j] * power;\n+                interpolatedState[j]       += d;\n+                interpolatedDerivatives[j] += order * d;\n             }\n         }\n \n-        /** {@inheritDoc} */\n-        public void start(int rows, int columns,\n-                          int startRow, int endRow, int startColumn, int endColumn) {\n-            Arrays.fill(interpolatedState, 0.0);\n-            Arrays.fill(interpolatedDerivatives, 0.0);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void visit(int row, int column, double value) {\n-            final double d = value * highPowers[row];\n-            interpolatedState[column]       += d;\n-            interpolatedDerivatives[column] += (row + 2) * d;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public double end() {\n-            for (int j = 0; j < currentState.length; ++j) {\n-                interpolatedState[j] += currentState[j] + scaled[j] * lowPower;\n-                interpolatedDerivatives[j] =\n-                    (interpolatedDerivatives[j] + scaled[j] * lowPower) / scale;\n-            }\n-            return 0;\n-        }\n-\n-    }\n-\n-    /** Visitor rescaling the Nordsieck vector. */\n-    private class Rescaler extends DefaultRealMatrixChangingVisitor {\n-\n-        /** Powers of the rescaling ratio. */\n-        private final double[] powers;\n-\n-        /** Simple constructor.\n-         * @param ratio rescaling ratio\n-         */\n-        public Rescaler(final double ratio) {\n-            powers = new double[nordsieck.getRowDimension()];\n-            double f = ratio;\n-            for (int i = 0; i < powers.length; ++i) {\n-                f *= ratio;\n-                powers[i] = f;\n-            }\n-        }\n-\n-        /** {@inheritDoc} */\n-        @Override\n-        public double visit(final int row, final int column, final double value) {\n-            return value * powers[row];\n-        }\n-        \n+        for (int j = 0; j < currentState.length; ++j) {\n+            interpolatedState[j] += currentState[j] + scaled[j] * normalizedAbscissa;\n+            interpolatedDerivatives[j] =\n+                (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;\n+        }\n+\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public void writeExternal(final ObjectOutput out)\n         throws IOException {\n-\n-        // save the state of the base class\n         writeBaseExternal(out);\n-\n-        // save the local attributes\n-        final int n = (currentState == null) ? -1 : currentState.length;\n-        if (scaled == null) {\n-            out.writeBoolean(false);\n-        } else {\n-            out.writeBoolean(true);\n-            for (int j = 0; j < n; ++j) {\n-                out.writeDouble(scaled[j]);\n-            }\n-        }\n-\n-        if (nordsieck == null) {\n-            out.writeBoolean(false);\n-        } else {\n-            out.writeBoolean(true);\n-            final int rows = nordsieck.getRowDimension();\n-            out.writeInt(rows);\n-            for (int i = 0; i < rows; ++i) {\n-                for (int j = 0; j < n; ++j) {\n-                    out.writeDouble(nordsieck.getEntry(i, j));\n-                }\n-            }\n-        }\n-\n     }\n \n     /** {@inheritDoc} */\n         // read the base class \n         final double t = readBaseExternal(in);\n \n-        // read the local attributes\n-        final int n = (currentState == null) ? -1 : currentState.length;\n-        final boolean hasScaled = in.readBoolean();\n-        if (hasScaled) {\n-            scaled = new double[n];\n-            for (int j = 0; j < n; ++j) {\n-                scaled[j] = in.readDouble();\n-            }\n-        } else {\n-            scaled = null;\n-        }\n-\n-        final boolean hasNordsieck = in.readBoolean();\n-        if (hasNordsieck) {\n-            final int rows = in.readInt();\n-            final double[][] nData = new double[rows][n];\n-            for (int i = 0; i < rows; ++i) {\n-                final double[] nI = nData[i];\n-                for (int j = 0; j < n; ++j) {\n-                    nI[j] = in.readDouble();\n-                }\n-            }\n-            nordsieck = new Array2DRowRealMatrix(nData, false);\n-        } else {\n-            nordsieck = null;\n-        }\n-\n-        if (hasScaled && hasNordsieck) {\n+        if ((scaled != null) && (nordsieck != null)) {\n             // we can now set the interpolated time and state\n             setInterpolatedTime(t);\n         }", "timestamp": 1246225869, "metainfo": ""}