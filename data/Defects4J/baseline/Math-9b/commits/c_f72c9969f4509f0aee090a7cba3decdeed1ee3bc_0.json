{"sha": "f72c9969f4509f0aee090a7cba3decdeed1ee3bc", "log": "Added a solver for Dfp-based (i.e. high accuracy) functions.  JIRA: MATH-636  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/dfp/BracketingNthOrderBrentSolverDFP.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.dfp;\n+\n+\n+import org.apache.commons.math.analysis.solvers.AllowedSolutions;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This class implements a modification of the <a\n+ * href=\"http://mathworld.wolfram.com/BrentsMethod.html\"> Brent algorithm</a>.\n+ * <p>\n+ * The changes with respect to the original Brent algorithm are:\n+ * <ul>\n+ *   <li>the returned value is chosen in the current interval according\n+ *   to user specified {@link AllowedSolutions},</li>\n+ *   <li>the maximal order for the invert polynomial root search is\n+ *   user-specified instead of being invert quadratic only</li>\n+ * </ul>\n+ * </p>\n+ * The given interval must bracket the root.\n+ *\n+ * @version $Id$\n+ */\n+public class BracketingNthOrderBrentSolverDFP {\n+\n+   /** Maximal aging triggering an attempt to balance the bracketing interval. */\n+    private static final int MAXIMAL_AGING = 2;\n+\n+    /** Maximal order. */\n+    private final int maximalOrder;\n+\n+    /** Function value accuracy. */\n+    private final Dfp functionValueAccuracy;\n+\n+    /** Absolute accuracy. */\n+    private final Dfp absoluteAccuracy;\n+\n+    /** Relative accuracy. */\n+    private final Dfp relativeAccuracy;\n+\n+    /** Evaluations counter. */\n+    private final Incrementor evaluations = new Incrementor();\n+\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param functionValueAccuracy Function value accuracy.\n+     * @param maximalOrder maximal order.\n+     * @exception NumberIsTooSmallException if maximal order is lower than 2\n+     */\n+    public BracketingNthOrderBrentSolverDFP(final Dfp relativeAccuracy,\n+                                            final Dfp absoluteAccuracy,\n+                                            final Dfp functionValueAccuracy,\n+                                            final int maximalOrder)\n+        throws NumberIsTooSmallException {\n+        if (maximalOrder < 2) {\n+            throw new NumberIsTooSmallException(maximalOrder, 2, true);\n+        }\n+        this.maximalOrder = maximalOrder;\n+        this.absoluteAccuracy = absoluteAccuracy;\n+        this.relativeAccuracy = relativeAccuracy;\n+        this.functionValueAccuracy = functionValueAccuracy;\n+    }\n+\n+    /** Get the maximal order.\n+     * @return maximal order\n+     */\n+    public int getMaximalOrder() {\n+        return maximalOrder;\n+    }\n+\n+    /**\n+     * Get the maximal number of function evaluations.\n+     *\n+     * @return the maximal number of function evaluations.\n+     */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /**\n+     * Get the number of evaluations of the objective function.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@code optimize} method. It is 0 if the method has not been\n+     * called yet.\n+     *\n+     * @return the number of evaluations of the objective function.\n+     */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /**\n+     * Get the absolute accuracy.\n+     * @return absolute accuracy\n+     */\n+    public Dfp getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+\n+    /**\n+     * Get the relative accuracy.\n+     * @return relative accuracy\n+     */\n+    public Dfp getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /**\n+     * Get the function accuracy.\n+     * @return function accuracy\n+     */\n+    public Dfp getFunctionValueAccuracy() {\n+        return functionValueAccuracy;\n+    }\n+\n+    /**\n+     * Solve for a zero in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n+                     final Dfp min, final Dfp max, final AllowedSolutions allowedSolutions) {\n+        return solve(maxEval, f, min, max, min.add(max).divide(2), allowedSolutions);\n+    }\n+\n+    /**\n+     * Solve for a zero in the given interval, start at {@code startValue}.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n+     * accept as solutions.\n+     * @return a value where the function is zero.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments do not satisfy the requirements specified by the solver.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException if\n+     * the allowed number of evaluations is exceeded.\n+     */\n+    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n+                     final Dfp min, final Dfp max, final Dfp startValue,\n+                     final AllowedSolutions allowedSolutions) {\n+\n+        // Checks.\n+        MathUtils.checkNotNull(f);\n+\n+        // Reset.\n+        evaluations.setMaximalCount(maxEval);\n+        evaluations.resetCount();\n+        Dfp zero = startValue.getZero();\n+        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n+\n+        // prepare arrays with the first points\n+        final Dfp[] x = new Dfp[maximalOrder + 1];\n+        final Dfp[] y = new Dfp[maximalOrder + 1];\n+        x[0] = min;\n+        x[1] = startValue;\n+        x[2] = max;\n+\n+        // evaluate initial guess\n+        evaluations.incrementCount();\n+        y[1] = f.value(x[1]);\n+        if (y[1].isZero()) {\n+            // return the initial guess if it is a perfect root.\n+            return x[1];\n+        }\n+\n+        // evaluate first  endpoint\n+        evaluations.incrementCount();\n+        y[0] = f.value(x[0]);\n+        if (y[0].isZero()) {\n+            // return the first endpoint if it is a perfect root.\n+            return x[0];\n+        }\n+\n+        int nbPoints;\n+        int signChangeIndex;\n+        if (y[0].multiply(y[1]).negativeOrNull()) {\n+\n+            // reduce interval if it brackets the root\n+            nbPoints        = 2;\n+            signChangeIndex = 1;\n+\n+        } else {\n+\n+            // evaluate second endpoint\n+            evaluations.incrementCount();\n+            y[2] = f.value(x[2]);\n+            if (y[2].isZero()) {\n+                // return the second endpoint if it is a perfect root.\n+                return x[2];\n+            }\n+\n+            if (y[1].multiply(y[2]).negativeOrNull()) {\n+                // use all computed point as a start sampling array for solving\n+                nbPoints        = 3;\n+                signChangeIndex = 2;\n+            } else {\n+                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n+                                                y[0].toDouble(), y[2].toDouble());\n+            }\n+\n+        }\n+\n+        // prepare a work array for inverse polynomial interpolation\n+        final Dfp[] tmpX = new Dfp[x.length];\n+\n+        // current tightest bracketing of the root\n+        Dfp xA    = x[signChangeIndex - 1];\n+        Dfp yA    = y[signChangeIndex - 1];\n+        Dfp absXA = xA.abs();\n+        Dfp absYA = yA.abs();\n+        int agingA   = 0;\n+        Dfp xB    = x[signChangeIndex];\n+        Dfp yB    = y[signChangeIndex];\n+        Dfp absXB = xB.abs();\n+        Dfp absYB = yB.abs();\n+        int agingB   = 0;\n+\n+        // search loop\n+        while (true) {\n+\n+            // check convergence of bracketing interval\n+            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n+            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n+            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n+            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n+                maxY.lessThan(functionValueAccuracy)) {\n+                switch (allowedSolutions) {\n+                case ANY_SIDE :\n+                    return absYA.lessThan(absYB) ? xA : xB;\n+                case LEFT_SIDE :\n+                    return xA;\n+                case RIGHT_SIDE :\n+                    return xB;\n+                case BELOW_SIDE :\n+                    return yA.lessThan(zero) ? xA : xB;\n+                case ABOVE_SIDE :\n+                    return yA.lessThan(zero) ? xB : xA;\n+                default :\n+                    // this should never happen\n+                    throw new MathInternalError(null);\n+                }\n+            }\n+\n+            // target for the next evaluation point\n+            Dfp targetY;\n+            if (agingA >= MAXIMAL_AGING) {\n+                // we keep updating the high bracket, try to compensate this\n+                targetY = yB.divide(16).negate();\n+            } else if (agingB >= MAXIMAL_AGING) {\n+                // we keep updating the low bracket, try to compensate this\n+                targetY = yA.divide(16).negate();\n+            } else {\n+                // bracketing is balanced, try to find the root itself\n+                targetY = zero;\n+            }\n+\n+            // make a few attempts to guess a root,\n+            Dfp nextX;\n+            int start = 0;\n+            int end   = nbPoints;\n+            do {\n+\n+                // guess a value for current target, using inverse polynomial interpolation\n+                System.arraycopy(x, start, tmpX, start, end - start);\n+                nextX = guessX(targetY, tmpX, y, start, end);\n+\n+                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n+                    // the guessed root is not strictly inside of the tightest bracketing interval\n+\n+                    // the guessed root is either not strictly inside the interval or it\n+                    // is a NaN (which occurs when some sampling points share the same y)\n+                    // we try again with a lower interpolation order\n+                    if (signChangeIndex - start >= end - signChangeIndex) {\n+                        // we have more points before the sign change, drop the lowest point\n+                        ++start;\n+                    } else {\n+                        // we have more points after sign change, drop the highest point\n+                        --end;\n+                    }\n+\n+                    // we need to do one more attempt\n+                    nextX = nan;\n+\n+                }\n+\n+            } while (nextX.isNaN() && (end - start > 1));\n+\n+            if (nextX.isNaN()) {\n+                // fall back to bisection\n+                nextX = xA.add(xB.subtract(xA).divide(2));\n+                start = signChangeIndex - 1;\n+                end   = signChangeIndex;\n+            }\n+\n+            // evaluate the function at the guessed root\n+            evaluations.incrementCount();\n+            final Dfp nextY = f.value(nextX);\n+            if (nextY.isZero()) {\n+                // we have found an exact root, since it is not an approximation\n+                // we don't need to bother about the allowed solutions setting\n+                return nextX;\n+            }\n+\n+            if ((nbPoints > 2) && (end - start != nbPoints)) {\n+\n+                // we have been forced to ignore some points to keep bracketing,\n+                // they are probably too far from the root, drop them from now on\n+                nbPoints = end - start;\n+                System.arraycopy(x, start, x, 0, nbPoints);\n+                System.arraycopy(y, start, y, 0, nbPoints);\n+                signChangeIndex -= start;\n+\n+            } else  if (nbPoints == x.length) {\n+\n+                // we have to drop one point in order to insert the new one\n+                nbPoints--;\n+\n+                // keep the tightest bracketing interval as centered as possible\n+                if (signChangeIndex >= (x.length + 1) / 2) {\n+                    // we drop the lowest point, we have to shift the arrays and the index\n+                    System.arraycopy(x, 1, x, 0, nbPoints);\n+                    System.arraycopy(y, 1, y, 0, nbPoints);\n+                    --signChangeIndex;\n+                }\n+\n+            }\n+\n+            // insert the last computed point\n+            //(by construction, we know it lies inside the tightest bracketing interval)\n+            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n+            x[signChangeIndex] = nextX;\n+            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n+            y[signChangeIndex] = nextY;\n+            ++nbPoints;\n+\n+            // update the bracketing interval\n+            if (nextY.multiply(yA).negativeOrNull()) {\n+                // the sign change occurs before the inserted point\n+                xB = nextX;\n+                yB = nextY;\n+                absYB = yB.abs();\n+                ++agingA;\n+                agingB = 0;\n+            } else {\n+                // the sign change occurs after the inserted point\n+                xA = nextX;\n+                yA = nextY;\n+                absYA = yA.abs();\n+                agingA = 0;\n+                ++agingB;\n+\n+                // update the sign change index\n+                signChangeIndex++;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n+     * <p>\n+     * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q\n+     * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>),\n+     * Q(y<sub>i</sub>) = x<sub>i</sub>.\n+     * </p>\n+     * @param targetY target value for y\n+     * @param x reference points abscissas for interpolation,\n+     * note that this array <em>is</em> modified during computation\n+     * @param y reference points ordinates for interpolation\n+     * @param start start index of the points to consider (inclusive)\n+     * @param end end index of the points to consider (exclusive)\n+     * @return guessed root (will be a NaN if two points share the same y)\n+     */\n+    private Dfp guessX(final Dfp targetY, final Dfp[] x, final Dfp[] y,\n+                       final int start, final int end) {\n+\n+        // compute Q Newton coefficients by divided differences\n+        for (int i = start; i < end - 1; ++i) {\n+            final int delta = i + 1 - start;\n+            for (int j = end - 1; j > i; --j) {\n+                x[j] = x[j].subtract(x[j-1]).divide(y[j].subtract(y[j - delta]));\n+            }\n+        }\n+\n+        // evaluate Q(targetY)\n+        Dfp x0 = targetY.getZero();\n+        for (int j = end - 1; j >= start; --j) {\n+            x0 = x[j].add(x0.multiply(targetY.subtract(y[j])));\n+        }\n+\n+        return x0;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/dfp/UnivariateDfpFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.dfp;\n+\n+import org.apache.commons.math.exception.MathUserException;\n+\n+/**\n+ * An interface representing a univariate {@link Dfp} function.\n+ *\n+ * @version $Id$\n+ */\n+public interface UnivariateDfpFunction {\n+\n+    /**\n+     * Compute the value of the function.\n+     *\n+     * @param x Point at which the function value should be computed.\n+     * @return the value.\n+     * @throws IllegalArgumentException when the activated method itself can\n+     * ascertain that preconditions, specified in the API expressed at the\n+     * level of the activated method, have been violated.  In the vast\n+     * majority of cases where Commons-Math throws IllegalArgumentException,\n+     * it is the result of argument checking of actual parameters immediately\n+     * passed to a method.\n+     * @throws MathUserException when the method may encounter errors during evaluation.\n+     * This should be thrown only in circumstances where, at the level of the\n+     * activated function, IllegalArgumentException is not appropriate and it\n+     * should indicate that while formal preconditions of the method have not\n+     * been violated, an irrecoverable error has occurred evaluating a\n+     * function at some (usually lower) level of the call stack.\n+     * Convergence failures, runtime exceptions (even IllegalArgumentException)\n+     * in user code or lower level methods can cause (and should be wrapped in)\n+     * a MathUserException.\n+     */\n+    Dfp value(Dfp x) throws MathUserException;\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/dfp/BracketingNthOrderBrentSolverDFPTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.dfp;\n+\n+import org.apache.commons.math.analysis.solvers.AllowedSolutions;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Test case for {@link BracketingNthOrderBrentSolverDFP bracketing n<sup>th</sup> order Brent} solver.\n+ *\n+ * @version $Id$\n+ */\n+public final class BracketingNthOrderBrentSolverDFPTest {\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testInsufficientOrder3() {\n+        new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,\n+                                             functionValueAccuracy, 1);\n+    }\n+\n+    @Test\n+    public void testConstructorOK() {\n+        BracketingNthOrderBrentSolverDFP solver =\n+                new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,\n+                                                     functionValueAccuracy, 2);\n+        Assert.assertEquals(2, solver.getMaximalOrder());\n+    }\n+\n+    @Test\n+    public void testConvergenceOnFunctionAccuracy() {\n+        BracketingNthOrderBrentSolverDFP solver =\n+                new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,\n+                                                     field.newDfp(1.0e-20), 20);\n+        UnivariateDfpFunction f = new UnivariateDfpFunction() {\n+            public Dfp value(Dfp x) {\n+                Dfp one     = field.getOne();\n+                Dfp oneHalf = one.divide(2);\n+                Dfp xMo     = x.subtract(one);\n+                Dfp xMh     = x.subtract(oneHalf);\n+                Dfp xPh     = x.add(oneHalf);\n+                Dfp xPo     = x.add(one);\n+                return xMo.multiply(xMh).multiply(x).multiply(xPh).multiply(xPo);\n+            }\n+        };\n+\n+        Dfp result = solver.solve(20, f, field.newDfp(0.2), field.newDfp(0.9),\n+                                  field.newDfp(0.4), AllowedSolutions.BELOW_SIDE);\n+        Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));\n+        Assert.assertTrue(f.value(result).negativeOrNull());\n+        Assert.assertTrue(result.subtract(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).positiveOrNull());\n+        result = solver.solve(20, f, field.newDfp(-0.9), field.newDfp(-0.2),\n+                              field.newDfp(-0.4), AllowedSolutions.ABOVE_SIDE);\n+        Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));\n+        Assert.assertTrue(f.value(result).positiveOrNull());\n+        Assert.assertTrue(result.add(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).negativeOrNull());\n+    }\n+\n+    @Test\n+    public void testNeta() {\n+\n+        // the following test functions come from Beny Neta's paper:\n+        // \"Several New Methods for solving Equations\"\n+        // intern J. Computer Math Vol 23 pp 265-282\n+        // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF\n+        for (AllowedSolutions allowed : AllowedSolutions.values()) {\n+            check(new UnivariateDfpFunction() {\n+                public Dfp value(Dfp x) {\n+                    return DfpMath.sin(x).subtract(x.divide(2));\n+                }\n+            }, 200, -2.0, 2.0, allowed);\n+\n+            check(new UnivariateDfpFunction() {\n+                public Dfp value(Dfp x) {\n+                    return DfpMath.pow(x, 5).add(x).subtract(field.newDfp(10000));\n+                }\n+            }, 200, -5.0, 10.0, allowed);\n+\n+            check(new UnivariateDfpFunction() {\n+                public Dfp value(Dfp x) {\n+                    return x.sqrt().subtract(field.getOne().divide(x)).subtract(field.newDfp(3));\n+                }\n+            }, 200, 0.001, 10.0, allowed);\n+\n+            check(new UnivariateDfpFunction() {\n+                public Dfp value(Dfp x) {\n+                    return DfpMath.exp(x).add(x).subtract(field.newDfp(20));\n+                }\n+            }, 200, -5.0, 5.0, allowed);\n+\n+            check(new UnivariateDfpFunction() {\n+                public Dfp value(Dfp x) {\n+                    return DfpMath.log(x).add(x.sqrt()).subtract(field.newDfp(5));\n+                }\n+            }, 200, 0.001, 10.0, allowed);\n+\n+            check(new UnivariateDfpFunction() {\n+                public Dfp value(Dfp x) {\n+                    return x.subtract(field.getOne()).multiply(x).multiply(x).subtract(field.getOne());\n+                }\n+            }, 200, -0.5, 1.5, allowed);\n+        }\n+\n+    }\n+\n+    private void check(UnivariateDfpFunction f, int maxEval, double min, double max,\n+                       AllowedSolutions allowedSolutions) {\n+        BracketingNthOrderBrentSolverDFP solver =\n+                new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,\n+                                                     functionValueAccuracy, 20);\n+        Dfp xResult = solver.solve(maxEval, f, field.newDfp(min), field.newDfp(max),\n+                                   allowedSolutions);\n+        Dfp yResult = f.value(xResult);\n+        switch (allowedSolutions) {\n+        case ANY_SIDE :\n+            Assert.assertTrue(yResult.abs().lessThan(functionValueAccuracy.multiply(2)));\n+            break;\n+        case LEFT_SIDE : {\n+            boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult);\n+            Assert.assertTrue(increasing ? yResult.negativeOrNull() : yResult.positiveOrNull());\n+            break;\n+        }\n+        case RIGHT_SIDE : {\n+            boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult);\n+            Assert.assertTrue(increasing ? yResult.positiveOrNull() : yResult.negativeOrNull());\n+            break;\n+        }\n+        case BELOW_SIDE :\n+            Assert.assertTrue(yResult.negativeOrNull());\n+            break;\n+        case ABOVE_SIDE :\n+            Assert.assertTrue(yResult.positiveOrNull());\n+            break;\n+        default :\n+            // this should never happen\n+            throw new MathInternalError(null);\n+        }\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        field                 = new DfpField(50);\n+        absoluteAccuracy      = field.newDfp(1.0e-45);\n+        relativeAccuracy      = field.newDfp(1.0e-45);\n+        functionValueAccuracy = field.newDfp(1.0e-45);\n+    }\n+\n+    private DfpField field;\n+    private Dfp      absoluteAccuracy;\n+    private Dfp      relativeAccuracy;\n+    private Dfp      functionValueAccuracy;\n+\n+}", "timestamp": 1311954456, "metainfo": ""}