{"sha": "0205f258448edf94193b64eeae38f8601706195e", "log": "[MATH-644] cleanup of HypergeometricDistribution and symmetry fix for upperCumulativeProbability, reported by marzieh.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n-import org.apache.commons.math3.util.ArithmeticUtils;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n         } else if (x >= domain[1]) {\n             ret = 1.0;\n         } else {\n-            ret = innerCumulativeProbability(domain[0], x, 1, populationSize,\n-                                             numberOfSuccesses, sampleSize);\n+            ret = innerCumulativeProbability(domain[0], x, 1);\n         }\n \n         return ret;\n     }\n \n     /**\n-     * For this distribution, {@code X}, defined by the given hypergeometric\n-     * distribution parameters, this method returns {@code P(X = x)}.\n-     *\n-     * @param x Value at which the PMF is evaluated.\n-     * @param n the population size.\n-     * @param m number of successes in the population.\n-     * @param k the sample size.\n-     * @return PMF for the distribution.\n-     */\n-    private double probability(int n, int m, int k, int x) {\n-        return FastMath.exp(ArithmeticUtils.binomialCoefficientLog(m, x) +\n-               ArithmeticUtils.binomialCoefficientLog(n - m, k - x) -\n-               ArithmeticUtils.binomialCoefficientLog(n, k));\n-    }\n-\n-    /**\n      * For this distribution, {@code X}, this method returns {@code P(X >= x)}.\n      *\n      * @param x Value at which the CDF is evaluated.\n         double ret;\n \n         final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n-        if (x < domain[0]) {\n+        if (x <= domain[0]) {\n             ret = 1.0;\n         } else if (x > domain[1]) {\n             ret = 0.0;\n         } else {\n-            ret = innerCumulativeProbability(domain[1], x, -1, populationSize,\n-                                             numberOfSuccesses, sampleSize);\n+            ret = innerCumulativeProbability(domain[1], x, -1);\n         }\n \n         return ret;\n      * @param x1 Inclusive upper bound.\n      * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n      * 0 indicates summing from x1 to x0).\n-     * @param n the population size.\n-     * @param m number of successes in the population.\n-     * @param k the sample size.\n      * @return {@code P(x0 <= X <= x1)}.\n      */\n-    private double innerCumulativeProbability(int x0, int x1, int dx,\n-                                              int n, int m, int k) {\n-        double ret = probability(n, m, k, x0);\n+    private double innerCumulativeProbability(int x0, int x1, int dx) {\n+        double ret = probability(x0);\n         while (x0 != x1) {\n             x0 += dx;\n-            ret += probability(n, m, k, x0);\n+            ret += probability(x0);\n         }\n         return ret;\n     }", "timestamp": 1338507286, "metainfo": ""}