{"sha": "eb0e423884d22b4a9cfd0daf00349ccdb1552178", "log": "MATH-827 New \"IterativeLegendreGaussIntegrator\" class that performs the same algorithm as the current \"LegendreGaussIntegrator\" but uses the recently added Gauss   integration framework (in package \"o.a.c.m.analysis.integration.gauss\") for the underlying integration computations.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/IterativeLegendreGaussIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.integration.gauss.GaussIntegratorFactory;\n+import org.apache.commons.math3.analysis.integration.gauss.GaussIntegrator;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * This algorithm divides the integration interval into equally-sized\n+ * sub-interval and on each of them performs a\n+ * <a href=\"http://mathworld.wolfram.com/Legendre-GaussQuadrature.html\">\n+ * Legendre-Gauss</a> quadrature.\n+ *\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+\n+public class IterativeLegendreGaussIntegrator\n+    extends BaseAbstractUnivariateIntegrator {\n+    /** Factory that computes the points and weights. */\n+    private static final GaussIntegratorFactory factory\n+        = new GaussIntegratorFactory();\n+    /** Number of integration points (per interval). */\n+    private final int numberOfPoints;\n+\n+    /**\n+     * Builds an integrator with given accuracies and iterations counts.\n+     *\n+     * @param n Number of integration points.\n+     * @param relativeAccuracy Relative accuracy of the result.\n+     * @param absoluteAccuracy Absolute accuracy of the result.\n+     * @param minimalIterationCount Minimum number of iterations.\n+     * @param maximalIterationCount Maximum number of iterations.\n+     * @throws NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive.\n+     * @throws NumberIsTooSmallException if maximal number of iterations\n+     * is smaller than or equal to the minimal number of iterations.\n+     */\n+    public IterativeLegendreGaussIntegrator(final int n,\n+                                            final double relativeAccuracy,\n+                                            final double absoluteAccuracy,\n+                                            final int minimalIterationCount,\n+                                            final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n+        super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n+        numberOfPoints = n;\n+    }\n+\n+    /**\n+     * Builds an integrator with given accuracies.\n+     *\n+     * @param n Number of integration points.\n+     * @param relativeAccuracy Relative accuracy of the result.\n+     * @param absoluteAccuracy Absolute accuracy of the result.\n+     */\n+    public IterativeLegendreGaussIntegrator(final int n,\n+                                            final double relativeAccuracy,\n+                                            final double absoluteAccuracy) {\n+        this(n, relativeAccuracy, absoluteAccuracy,\n+             DEFAULT_MIN_ITERATIONS_COUNT, DEFAULT_MAX_ITERATIONS_COUNT);\n+    }\n+\n+    /**\n+     * Builds an integrator with given iteration counts.\n+     *\n+     * @param n Number of integration points.\n+     * @param minimalIterationCount Minimum number of iterations.\n+     * @param maximalIterationCount Maximum number of iterations.\n+     * @throws NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive.\n+     * @throws NumberIsTooSmallException if maximal number of iterations\n+     * is smaller than or equal to the minimal number of iterations.\n+     */\n+    public IterativeLegendreGaussIntegrator(final int n,\n+                                            final int minimalIterationCount,\n+                                            final int maximalIterationCount) {\n+        this(n, DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY,\n+             minimalIterationCount, maximalIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double doIntegrate()\n+        throws TooManyEvaluationsException, MaxCountExceededException {\n+        // Compute first estimate with a single step.\n+        double oldt = stage(1);\n+\n+        int n = 2;\n+        while (true) {\n+            // Improve integral with a larger number of steps.\n+            final double t = stage(n);\n+\n+            // Estimate the error.\n+            final double delta = FastMath.abs(t - oldt);\n+            final double limit =\n+                FastMath.max(getAbsoluteAccuracy(),\n+                             getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n+\n+            // check convergence\n+            if (iterations.getCount() + 1 >= getMinimalIterationCount() && \n+                delta <= limit) {\n+                return t;\n+            }\n+\n+            // Prepare next iteration.\n+            final double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / numberOfPoints));\n+            n = FastMath.max((int) (ratio * n), n + 1);\n+            oldt = t;\n+            iterations.incrementCount();\n+        }\n+    }\n+\n+    /**\n+     * Compute the n-th stage integral.\n+     *\n+     * @param n Number of steps.\n+     * @return the value of n-th stage integral.\n+     * @throws TooManyEvaluationsException if the maximum number of evaluations\n+     * is exceeded.\n+     */\n+    private double stage(final int n)\n+        throws TooManyEvaluationsException {\n+        // Function to be integrated is stored in the base class.\n+        final UnivariateFunction f = new UnivariateFunction() {\n+                public double value(double x) {\n+                    return computeObjectiveValue(x);\n+                }\n+            };\n+        \n+        final double min = getMin();\n+        final double max = getMax();\n+        final double step = (max - min) / n;\n+\n+        double sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            // Integrate over each sub-interval [a, b].\n+            final double a = min + i * step;\n+            final double b = a + step;\n+            final GaussIntegrator g = factory.legendreHighPrecision(numberOfPoints, a, b);\n+            sum += g.integrate(f);\n+        }\n+\n+        return sum;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/IterativeLegendreGaussIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math3.analysis.QuinticFunction;\n+import org.apache.commons.math3.analysis.SinFunction;\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class IterativeLegendreGaussIntegratorTest {\n+\n+    @Test\n+    public void testSinFunction() {\n+        UnivariateFunction f = new SinFunction();\n+        BaseAbstractUnivariateIntegrator integrator\n+            = new IterativeLegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = FastMath.PI; expected = 2;\n+        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n+                             FastMath.abs(expected * integrator.getRelativeAccuracy()));\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = -FastMath.PI/3; max = 0; expected = -0.5;\n+        tolerance = FastMath.max(integrator.getAbsoluteAccuracy(),\n+                FastMath.abs(expected * integrator.getRelativeAccuracy()));\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+    }\n+\n+    @Test\n+    public void testQuinticFunction() {\n+        UnivariateFunction f = new QuinticFunction();\n+        UnivariateIntegrator integrator =\n+                new IterativeLegendreGaussIntegrator(3,\n+                                                     BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY,\n+                                                     BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY,\n+                                                     BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT,\n+                                                     64);\n+        double min, max, expected, result;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertEquals(expected, result, 1.0e-16);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertEquals(expected, result, 1.0e-16);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        result = integrator.integrate(10000, f, min, max);\n+        Assert.assertEquals(expected, result, 1.0e-16);\n+    }\n+\n+    @Test\n+    public void testExactIntegration() {\n+        Random random = new Random(86343623467878363l);\n+        for (int n = 2; n < 6; ++n) {\n+            IterativeLegendreGaussIntegrator integrator =\n+                new IterativeLegendreGaussIntegrator(n,\n+                                                     BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY,\n+                                                     BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY,\n+                                                     BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT,\n+                                                     64);\n+\n+            // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly\n+            for (int degree = 0; degree <= 2 * n - 1; ++degree) {\n+                for (int i = 0; i < 10; ++i) {\n+                    double[] coeff = new double[degree + 1];\n+                    for (int k = 0; k < coeff.length; ++k) {\n+                        coeff[k] = 2 * random.nextDouble() - 1;\n+                    }\n+                    PolynomialFunction p = new PolynomialFunction(coeff);\n+                    double result    = integrator.integrate(10000, p, -5.0, 15.0);\n+                    double reference = exactIntegration(p, -5.0, 15.0);\n+                    Assert.assertEquals(n + \" \" + degree + \" \" + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference)));\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testIssue464() {\n+        final double value = 0.2;\n+        UnivariateFunction f = new UnivariateFunction() {\n+            public double value(double x) {\n+                return (x >= 0 && x <= 5) ? value : 0.0;\n+            }\n+        };\n+        IterativeLegendreGaussIntegrator gauss\n+            = new IterativeLegendreGaussIntegrator(5, 3, 100);\n+\n+        // due to the discontinuity, integration implies *many* calls\n+        double maxX = 0.32462367623786328;\n+        Assert.assertEquals(maxX * value, gauss.integrate(Integer.MAX_VALUE, f, -10, maxX), 1.0e-7);\n+        Assert.assertTrue(gauss.getEvaluations() > 37000000);\n+        Assert.assertTrue(gauss.getIterations() < 30);\n+\n+        // setting up limits prevents such large number of calls\n+        try {\n+            gauss.integrate(1000, f, -10, maxX);\n+            Assert.fail(\"expected TooManyEvaluationsException\");\n+        } catch (TooManyEvaluationsException tmee) {\n+            // expected\n+            Assert.assertEquals(1000, tmee.getMax());\n+        }\n+\n+        // integrating on the two sides should be simpler\n+        double sum1 = gauss.integrate(1000, f, -10, 0);\n+        int eval1   = gauss.getEvaluations();\n+        double sum2 = gauss.integrate(1000, f, 0, maxX);\n+        int eval2   = gauss.getEvaluations();\n+        Assert.assertEquals(maxX * value, sum1 + sum2, 1.0e-7);\n+        Assert.assertTrue(eval1 + eval2 < 200);\n+\n+    }\n+\n+    private double exactIntegration(PolynomialFunction p, double a, double b) {\n+        final double[] coeffs = p.getCoefficients();\n+        double yb = coeffs[coeffs.length - 1] / coeffs.length;\n+        double ya = yb;\n+        for (int i = coeffs.length - 2; i >= 0; --i) {\n+            yb = yb * b + coeffs[i] / (i + 1);\n+            ya = ya * a + coeffs[i] / (i + 1);\n+        }\n+        return yb * b - ya * a;\n+    }\n+}", "timestamp": 1342994180, "metainfo": ""}