{"sha": "7f7c4852c00878beb0fe92627700ad52ed51f261", "log": "[MATH-848] Fixed Schur transformation for certain input matrices, changed index parameter names to indicate their purpose.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n \n         // Outer loop over eigenvalue index\n         int iteration = 0;\n-        int idx = n - 1;\n-        while (idx >= 0) {\n+        int iu = n - 1;\n+        while (iu >= 0) {\n \n             // Look for single small sub-diagonal element\n-            final int l = findSmallSubDiagonalElement(idx, norm);\n+            final int il = findSmallSubDiagonalElement(iu, norm);\n \n             // Check for convergence\n-            if (l == idx) {\n+            if (il == iu) {\n                 // One root found\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                idx--;\n+                matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n+                iu--;\n                 iteration = 0;\n-            } else if (l == idx - 1) {\n+            } else if (il == iu - 1) {\n                 // Two roots found\n-                shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n-                double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;\n-                double q = p * p + shift.w;\n-                double z = FastMath.sqrt(FastMath.abs(q));\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;\n-                shift.x = matrixT[idx][idx];\n+                double p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n+                double q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n+                matrixT[iu][iu] += shift.exShift;\n+                matrixT[iu - 1][iu - 1] += shift.exShift;\n \n                 if (q >= 0) {\n+                    double z = FastMath.sqrt(FastMath.abs(q));\n                     if (p >= 0) {\n                         z = p + z;\n                     } else {\n                         z = p - z;\n                     }\n-                    shift.x = matrixT[idx][idx - 1];\n-                    double s = FastMath.abs(shift.x) + FastMath.abs(z);\n-                    p = shift.x / s;\n+                    final double x = matrixT[iu][iu - 1];\n+                    final double s = FastMath.abs(x) + FastMath.abs(z);\n+                    p = x / s;\n                     q = z / s;\n-                    double r = FastMath.sqrt(p * p + q * q);\n+                    final double r = FastMath.sqrt(p * p + q * q);\n                     p = p / r;\n                     q = q / r;\n \n                     // Row modification\n-                    for (int j = idx - 1; j < n; j++) {\n-                        z = matrixT[idx - 1][j];\n-                        matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];\n-                        matrixT[idx][j] = q * matrixT[idx][j] - p * z;\n+                    for (int j = iu - 1; j < n; j++) {\n+                        z = matrixT[iu - 1][j];\n+                        matrixT[iu - 1][j] = q * z + p * matrixT[iu][j];\n+                        matrixT[iu][j] = q * matrixT[iu][j] - p * z;\n                     }\n \n                     // Column modification\n-                    for (int i = 0; i <= idx; i++) {\n-                        z = matrixT[i][idx - 1];\n-                        matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];\n-                        matrixT[i][idx] = q * matrixT[i][idx] - p * z;\n+                    for (int i = 0; i <= iu; i++) {\n+                        z = matrixT[i][iu - 1];\n+                        matrixT[i][iu - 1] = q * z + p * matrixT[i][iu];\n+                        matrixT[i][iu] = q * matrixT[i][iu] - p * z;\n                     }\n \n                     // Accumulate transformations\n                     for (int i = 0; i <= n - 1; i++) {\n-                        z = matrixP[i][idx - 1];\n-                        matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];\n-                        matrixP[i][idx] = q * matrixP[i][idx] - p * z;\n-                    }\n-                }\n-                idx -= 2;\n+                        z = matrixP[i][iu - 1];\n+                        matrixP[i][iu - 1] = q * z + p * matrixP[i][iu];\n+                        matrixP[i][iu] = q * matrixP[i][iu] - p * z;\n+                    }\n+                }\n+                iu -= 2;\n                 iteration = 0;\n             } else {\n                 // No convergence yet\n-\n-                computeShift(l, idx, iteration, shift);\n+                computeShift(il, iu, iteration, shift);\n \n                 // stop transformation after too many iterations\n                 if (++iteration > MAX_ITERATIONS) {\n                                                         MAX_ITERATIONS);\n                 }\n \n-                // Look for two consecutive small sub-diagonal elements\n-                int m = idx - 2;\n-\n                 // the initial houseHolder vector for the QR step\n                 final double[] hVec = new double[3];\n \n-                while (m >= l) {\n-                    double z = matrixT[m][m];\n-                    hVec[2] = shift.x - z;\n-                    double s = shift.y - z;\n-                    hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];\n-                    hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;\n-                    hVec[2] = matrixT[m + 2][m + 1];\n-                    s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n-\n-                    if (m == l) {\n-                        break;\n-                    }\n-\n-                    for (int i = 0; i < hVec.length; i++) {\n-                        hVec[i] /= s;\n-                    }\n-\n-                    final double lhs = FastMath.abs(matrixT[m][m - 1]) *\n-                            (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n-\n-                    final double rhs = FastMath.abs(hVec[0]) *\n-                            (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) +\n-                             FastMath.abs(matrixT[m + 1][m + 1]));\n-\n-                    if (lhs < epsilon * rhs) {\n-                        break;\n-                    }\n-                    m--;\n-                }\n-\n-                performDoubleQRStep(l, m, idx, shift, hVec);\n+                final int im = initQRStep(il, iu, shift, hVec);\n+                performDoubleQRStep(il, im, iu, shift, hVec);\n             }\n         }\n     }\n         int l = startIdx;\n         while (l > 0) {\n             double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n-            if (Precision.equals(s, 0.0, epsilon)) {\n+            if (s == 0.0) {\n                 s = norm;\n             }\n             if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n             for (int i = 0; i <= idx; i++) {\n                 matrixT[i][i] -= shift.x;\n             }\n-            double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n-            shift.x = shift.y = 0.75 * s;\n+            final double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n+            shift.x = 0.75 * s;\n+            shift.y = 0.75 * s;\n             shift.w = -0.4375 * s * s;\n         }\n \n         if (iteration == 30) {\n             double s = (shift.y - shift.x) / 2.0;\n             s = s * s + shift.w;\n-            if (Precision.compareTo(s, 0.0d, epsilon) > 0) {\n+            if (s > 0.0) {\n                 s = FastMath.sqrt(s);\n                 if (shift.y < shift.x) {\n                     s = -s;\n     }\n \n     /**\n-     * Perform a double QR step involving rows l:idx and columns m:n\n-     *\n-     * @param l the index of the small sub-diagonal element\n-     * @param m the start index for the QR step\n-     * @param idx the current eigenvalue index\n+     * Initialize the householder vectors for the QR step.\n+     *\n+     * @param il the index of the small sub-diagonal element\n+     * @param iu the current eigenvalue index\n      * @param shift shift information holder\n      * @param hVec the initial houseHolder vector\n-     */\n-    private void performDoubleQRStep(final int l, final int m, final int idx,\n+     * @return the start index for the QR step\n+     */\n+    private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec) {\n+        // Look for two consecutive small sub-diagonal elements\n+        int im = iu - 2;\n+        while (im >= il) {\n+            final double z = matrixT[im][im];\n+            final double r = shift.x - z;\n+            double s = shift.y - z;\n+            hVec[0] = (r * s - shift.w) / matrixT[im + 1][im] + matrixT[im][im + 1];\n+            hVec[1] = matrixT[im + 1][im + 1] - z - r - s;\n+            hVec[2] = matrixT[im + 2][im + 1];\n+\n+            if (im == il) {\n+                break;\n+            }\n+\n+            final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n+            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n+                                                        FastMath.abs(z) +\n+                                                        FastMath.abs(matrixT[im + 1][im + 1]));\n+\n+            if (lhs < epsilon * rhs) {\n+                break;\n+            }\n+            im--;\n+        }\n+\n+        return im;\n+    }\n+\n+    /**\n+     * Perform a double QR step involving rows l:idx and columns m:n\n+     *\n+     * @param il the index of the small sub-diagonal element\n+     * @param im the start index for the QR step\n+     * @param iu the current eigenvalue index\n+     * @param shift shift information holder\n+     * @param hVec the initial houseHolder vector\n+     */\n+    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                      final ShiftInfo shift, final double[] hVec) {\n \n         final int n = matrixT.length;\n         double q = hVec[1];\n         double r = hVec[2];\n \n-        for (int k = m; k <= idx - 1; k++) {\n-            boolean notlast = k != idx - 1;\n-            if (k != m) {\n+        for (int k = im; k <= iu - 1; k++) {\n+            boolean notlast = k != (iu - 1);\n+            if (k != im) {\n                 p = matrixT[k][k - 1];\n                 q = matrixT[k + 1][k - 1];\n                 r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                     r = r / shift.x;\n                 }\n             }\n-            if (Precision.equals(shift.x, 0.0, epsilon)) {\n+            if (shift.x == 0.0) {\n                 break;\n             }\n             double s = FastMath.sqrt(p * p + q * q + r * r);\n             if (p < 0.0) {\n                 s = -s;\n             }\n-            if (!Precision.equals(s, 0.0, epsilon)) {\n-                if (k != m) {\n+            if (s != 0.0) {\n+                if (k != im) {\n                     matrixT[k][k - 1] = -s * shift.x;\n-                } else if (l != m) {\n+                } else if (il != im) {\n                     matrixT[k][k - 1] = -matrixT[k][k - 1];\n                 }\n                 p = p + s;\n                 }\n \n                 // Column modification\n-                for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {\n+                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                     p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                     if (notlast) {\n                         p = p + z * matrixT[i][k + 2];\n         }  // k loop\n \n         // clean up pollution due to round-off errors\n-        for (int i = m+2; i <= idx; i++) {\n+        for (int i = im + 2; i <= iu; i++) {\n             matrixT[i][i-2] = 0.0;\n-            if (i > m+2) {\n+            if (i > im + 2) {\n                 matrixT[i][i-3] = 0.0;\n             }\n         }\n--- a/src/test/java/org/apache/commons/math3/linear/EigenDecompositionTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/EigenDecompositionTest.java\n         }\n     }\n     \n+    @Test\n+    public void testMath848() {\n+        double[][] data = {\n+                { 0.1849449280, -0.0646971046,  0.0774755812, -0.0969651755, -0.0692648806,  0.3282344352, -0.0177423074,  0.2063136340},\n+                {-0.0742700134, -0.0289063030, -0.0017269460, -0.0375550146, -0.0487737922, -0.2616837868, -0.0821201295, -0.2530000167},\n+                { 0.2549910127,  0.0995733692, -0.0009718388,  0.0149282808,  0.1791878897, -0.0823182816,  0.0582629256,  0.3219545182},\n+                {-0.0694747557, -0.1880649148, -0.2740630911,  0.0720096468, -0.1800836914, -0.3518996425,  0.2486747833,  0.6257938167},\n+                { 0.0536360918, -0.1339297778,  0.2241579764, -0.0195327484, -0.0054103808,  0.0347564518,  0.5120802482, -0.0329902864},\n+                {-0.5933332356, -0.2488721082,  0.2357173629,  0.0177285473,  0.0856630593, -0.3567126300, -0.1600668126, -0.1010899621},\n+                {-0.0514349819, -0.0854319435,  0.1125050061,  0.0063453560, -0.2250000688, -0.2209343090,  0.1964623477, -0.1512329924},\n+                { 0.0197395947, -0.1997170581, -0.1425959019, -0.2749477910, -0.0969467073,  0.0603688520, -0.2826905192,  0.1794315473}};\n+        RealMatrix m = MatrixUtils.createRealMatrix(data);\n+        checkUnsymmetricMatrix(m);\n+    }\n+\n     /**\n      * Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by\n      * checking: A*V = V*D\n--- a/src/test/java/org/apache/commons/math3/linear/SchurTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/SchurTransformerTest.java\n         }\n     }\n \n+    @Test\n+    public void testMath848() {\n+        double[][] data = {\n+                { 0.1849449280, -0.0646971046,  0.0774755812, -0.0969651755, -0.0692648806,  0.3282344352, -0.0177423074,  0.2063136340},\n+                {-0.0742700134, -0.0289063030, -0.0017269460, -0.0375550146, -0.0487737922, -0.2616837868, -0.0821201295, -0.2530000167},\n+                { 0.2549910127,  0.0995733692, -0.0009718388,  0.0149282808,  0.1791878897, -0.0823182816,  0.0582629256,  0.3219545182},\n+                {-0.0694747557, -0.1880649148, -0.2740630911,  0.0720096468, -0.1800836914, -0.3518996425,  0.2486747833,  0.6257938167},\n+                { 0.0536360918, -0.1339297778,  0.2241579764, -0.0195327484, -0.0054103808,  0.0347564518,  0.5120802482, -0.0329902864},\n+                {-0.5933332356, -0.2488721082,  0.2357173629,  0.0177285473,  0.0856630593, -0.3567126300, -0.1600668126, -0.1010899621},\n+                {-0.0514349819, -0.0854319435,  0.1125050061,  0.0063453560, -0.2250000688, -0.2209343090,  0.1964623477, -0.1512329924},\n+                { 0.0197395947, -0.1997170581, -0.1425959019, -0.2749477910, -0.0969467073,  0.0603688520, -0.2826905192,  0.1794315473}};\n+        RealMatrix m = MatrixUtils.createRealMatrix(data);\n+        RealMatrix s = checkAEqualPTPt(m);\n+        checkSchurForm(s);\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Test helpers\n     ///////////////////////////////////////////////////////////////////////////\n         RealMatrix result = p.multiply(t).multiply(pT);\n \n         double norm = result.subtract(matrix).getNorm();\n-        Assert.assertEquals(0, norm, 1.0e-10);\n+        Assert.assertEquals(0, norm, 1.0e-9);\n         \n         return t;\n     }", "timestamp": 1348428842, "metainfo": ""}