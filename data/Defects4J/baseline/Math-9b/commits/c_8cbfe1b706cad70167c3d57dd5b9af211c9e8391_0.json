{"sha": "8cbfe1b706cad70167c3d57dd5b9af211c9e8391", "log": "Merged EmpiricalDistributionImpl into EmpiricalDistribution, updated javadoc. JIRA: MATH-670  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/random/EmpiricalDistribution.java\n \n package org.apache.commons.math.random;\n \n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n import java.io.IOException;\n-import java.io.File;\n+import java.io.InputStreamReader;\n+import java.io.Serializable;\n import java.net.URL;\n+import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Represents an <a href=\"http://random.mat.sbg.ac.at/~ste/dipl/node11.html\">\n+ * Represents an <a href=\"http://http://en.wikipedia.org/wiki/Empirical_distribution_function\">\n  * empirical probability distribution</a> -- a probability distribution derived\n  * from observed data without making any assumptions about the functional form\n  * of the population distribution that the data come from.<p>\n- * Implementations of this interface maintain data structures, called\n+ * An <code>EmpiricalDistribution</code> maintains data structures, called\n  * <i>distribution digests</i>, that describe empirical distributions and\n  * support the following operations: <ul>\n  * <li>loading the distribution from a file of observed data values</li>\n  *     as well as the observations within each bin</li>\n  * <li>generating random values from the distribution</li>\n  * </ul>\n- * Applications can use <code>EmpiricalDistribution</code> implementations to\n- * build grouped frequency histograms representing the input data or to\n- * generate random values \"like\" those in the input file -- i.e., the values\n- * generated will follow the distribution of the values in the file.</p>\n+ * Applications can use <code>EmpiricalDistribution</code> to build grouped\n+ * frequency histograms representing the input data or to generate random values\n+ * \"like\" those in the input file -- i.e., the values generated will follow the\n+ * distribution of the values in the file.</p>\n+ * <p>The implementation uses what amounts to the\n+ * <a href=\"http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html\">\n+ * Variable Kernel Method</a> with Gaussian smoothing:<p>\n+ * <strong>Digesting the input file</strong>\n+ * <ol><li>Pass the file once to compute min and max.</li>\n+ * <li>Divide the range from min-max into <code>binCount</code> \"bins.\"</li>\n+ * <li>Pass the data file again, computing bin counts and univariate\n+ *     statistics (mean, std dev.) for each of the bins </li>\n+ * <li>Divide the interval (0,1) into subintervals associated with the bins,\n+ *     with the length of a bin's subinterval proportional to its count.</li></ol>\n+ * <strong>Generating random values from the distribution</strong><ol>\n+ * <li>Generate a uniformly distributed value in (0,1) </li>\n+ * <li>Select the subinterval to which the value belongs.\n+ * <li>Generate a random Gaussian value with mean = mean of the associated\n+ *     bin and std dev = std dev of associated bin.</li></ol></p><p>\n+ *<strong>USAGE NOTES:</strong><ul>\n+ *<li>The <code>binCount</code> is set by default to 1000.  A good rule of thumb\n+ *    is to set the bin count to approximately the length of the input file divided\n+ *    by 10. </li>\n+ *<li>The input file <i>must</i> be a plain text file containing one valid numeric\n+ *    entry per line.</li>\n+ * </ul></p>\n  *\n  * @version $Id$\n  */\n-public interface EmpiricalDistribution {\n-\n-    /**\n+public class EmpiricalDistribution implements Serializable {\n+\n+    /** Default bin count */\n+    public static final int DEFAULT_BIN_COUNT = 1000;\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5729073523949762654L;\n+\n+    /** List of SummaryStatistics objects characterizing the bins */\n+    private final List<SummaryStatistics> binStats;\n+\n+    /** Sample statistics */\n+    private SummaryStatistics sampleStats = null;\n+\n+    /** Max loaded value */\n+    private double max = Double.NEGATIVE_INFINITY;\n+\n+    /** Min loaded value */\n+    private double min = Double.POSITIVE_INFINITY;\n+\n+    /** Grid size */\n+    private double delta = 0d;\n+\n+    /** number of bins */\n+    private final int binCount;\n+\n+    /** is the distribution loaded? */\n+    private boolean loaded = false;\n+\n+    /** upper bounds of subintervals in (0,1) \"belonging\" to the bins */\n+    private double[] upperBounds = null;\n+\n+    /** RandomDataImpl instance to use in repeated calls to getNext() */\n+    private final RandomDataImpl randomData;\n+\n+    /**\n+     * Creates a new EmpiricalDistribution with the default bin count.\n+     */\n+    public EmpiricalDistribution() {\n+        this(DEFAULT_BIN_COUNT, new RandomDataImpl());\n+    }\n+\n+    /**\n+     * Creates a new EmpiricalDistribution with the specified bin count.\n+     *\n+     * @param binCount number of bins\n+     */\n+    public EmpiricalDistribution(int binCount) {\n+        this(binCount, new RandomDataImpl());\n+    }\n+\n+    /**\n+     * Creates a new EmpiricalDistribution with the specified bin count using the\n+     * provided {@link RandomGenerator} as the source of random data.\n+     *\n+     * @param binCount number of bins\n+     * @param generator random data generator (may be null, resulting in default JDK generator)\n+     * @since 3.0\n+     */\n+    public EmpiricalDistribution(int binCount, RandomGenerator generator) {\n+        this.binCount = binCount;\n+        randomData = new RandomDataImpl(generator);\n+        binStats = new ArrayList<SummaryStatistics>();\n+    }\n+\n+    /**\n+     * Creates a new EmpiricalDistribution with default bin count using the\n+     * provided {@link RandomGenerator} as the source of random data.\n+     *\n+     * @param generator random data generator (may be null, resulting in default JDK generator)\n+     * @since 3.0\n+     */\n+    public EmpiricalDistribution(RandomGenerator generator) {\n+        this(DEFAULT_BIN_COUNT, generator);\n+    }\n+\n+    /**\n+     * Creates a new EmpiricalDistribution with the specified bin count using the\n+     * provided {@link RandomDataImpl} instance as the source of random data.\n+     *\n+     * @param binCount number of bins\n+     * @param randomData random data generator (may be null, resulting in default JDK generator)\n+     * @since 3.0\n+     */\n+    public EmpiricalDistribution(int binCount, RandomDataImpl randomData) {\n+        this.binCount = binCount;\n+        this.randomData = randomData;\n+        binStats = new ArrayList<SummaryStatistics>();\n+    }\n+\n+    /**\n+     * Creates a new EmpiricalDistribution with default bin count using the\n+     * provided {@link RandomDataImpl} as the source of random data.\n+     *\n+     * @param randomData random data generator (may be null, resulting in default JDK generator)\n+     * @since 3.0\n+     */\n+    public EmpiricalDistribution(RandomDataImpl randomData) {\n+        this(DEFAULT_BIN_COUNT, randomData);\n+    }\n+\n+     /**\n      * Computes the empirical distribution from the provided\n      * array of numbers.\n      *\n-     * @param dataArray the data array\n-     */\n-    void load(double[] dataArray);\n+     * @param in the input data array\n+     * @exception NullArgumentException if in is null\n+     */\n+    public void load(double[] in) throws NullArgumentException {\n+        DataAdapter da = new ArrayDataAdapter(in);\n+        try {\n+            da.computeStats();\n+            fillBinStats(in);\n+        } catch (IOException e) {\n+            throw new MathIllegalStateException(e, LocalizedFormats.SIMPLE_MESSAGE, e.getLocalizedMessage());\n+        }\n+        loaded = true;\n+\n+    }\n+\n+    /**\n+     * Computes the empirical distribution using data read from a URL.\n+     * @param url  url of the input file\n+     *\n+     * @throws IOException if an IO error occurs\n+     * @throws NullArgumentException if url is null\n+     */\n+    public void load(URL url) throws IOException, NullArgumentException {\n+        MathUtils.checkNotNull(url);\n+        BufferedReader in =\n+            new BufferedReader(new InputStreamReader(url.openStream()));\n+        try {\n+            DataAdapter da = new StreamDataAdapter(in);\n+            da.computeStats();\n+            if (sampleStats.getN() == 0) {\n+                throw new ZeroException(LocalizedFormats.URL_CONTAINS_NO_DATA, url);\n+            }\n+            in = new BufferedReader(new InputStreamReader(url.openStream()));\n+            fillBinStats(in);\n+            loaded = true;\n+        } finally {\n+           try {\n+               in.close();\n+           } catch (IOException ex) {\n+               // ignore\n+           }\n+        }\n+    }\n \n     /**\n      * Computes the empirical distribution from the input file.\n      * @throws IOException if an IO error occurs\n      * @throws NullArgumentException if file is null\n      */\n-    void load(File file) throws IOException;\n-\n-    /**\n-     * Computes the empirical distribution using data read from a URL.\n-     *\n-     * @param url url of the input file\n-     * @throws IOException if an IO error occurs\n-     * @throws NullArgumentException if url is null\n-     */\n-    void load(URL url) throws IOException, NullArgumentException;\n+    public void load(File file) throws IOException, NullArgumentException {\n+        MathUtils.checkNotNull(file);\n+        BufferedReader in = new BufferedReader(new FileReader(file));\n+        try {\n+            DataAdapter da = new StreamDataAdapter(in);\n+            da.computeStats();\n+            in = new BufferedReader(new FileReader(file));\n+            fillBinStats(in);\n+            loaded = true;\n+        } finally {\n+            try {\n+                in.close();\n+            } catch (IOException ex) {\n+                // ignore\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Provides methods for computing <code>sampleStats</code> and\n+     * <code>beanStats</code> abstracting the source of data.\n+     */\n+    private abstract class DataAdapter{\n+\n+        /**\n+         * Compute bin stats.\n+         *\n+         * @throws IOException  if an error occurs computing bin stats\n+         */\n+        public abstract void computeBinStats() throws IOException;\n+\n+        /**\n+         * Compute sample statistics.\n+         *\n+         * @throws IOException if an error occurs computing sample stats\n+         */\n+        public abstract void computeStats() throws IOException;\n+\n+    }\n+\n+    /**\n+     * Factory of <code>DataAdapter</code> objects. For every supported source\n+     * of data (array of doubles, file, etc.) an instance of the proper object\n+     * is returned.\n+     */\n+    private class DataAdapterFactory{\n+        /**\n+         * Creates a DataAdapter from a data object\n+         *\n+         * @param in object providing access to the data\n+         * @return DataAdapter instance\n+         */\n+        public DataAdapter getAdapter(Object in) {\n+            if (in instanceof BufferedReader) {\n+                BufferedReader inputStream = (BufferedReader) in;\n+                return new StreamDataAdapter(inputStream);\n+            } else if (in instanceof double[]) {\n+                double[] inputArray = (double[]) in;\n+                return new ArrayDataAdapter(inputArray);\n+            } else {\n+                throw new MathIllegalArgumentException(\n+                      LocalizedFormats.INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE,\n+                      in.getClass().getName(),\n+                      BufferedReader.class.getName(), double[].class.getName());\n+            }\n+        }\n+    }\n+    /**\n+     * <code>DataAdapter</code> for data provided through some input stream\n+     */\n+    private class StreamDataAdapter extends DataAdapter{\n+\n+        /** Input stream providing access to the data */\n+        private BufferedReader inputStream;\n+\n+        /**\n+         * Create a StreamDataAdapter from a BufferedReader\n+         *\n+         * @param in BufferedReader input stream\n+         */\n+        public StreamDataAdapter(BufferedReader in){\n+            super();\n+            inputStream = in;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void computeBinStats() throws IOException {\n+            String str = null;\n+            double val = 0.0d;\n+            while ((str = inputStream.readLine()) != null) {\n+                val = Double.parseDouble(str);\n+                SummaryStatistics stats = binStats.get(findBin(val));\n+                stats.addValue(val);\n+            }\n+\n+            inputStream.close();\n+            inputStream = null;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void computeStats() throws IOException {\n+            String str = null;\n+            double val = 0.0;\n+            sampleStats = new SummaryStatistics();\n+            while ((str = inputStream.readLine()) != null) {\n+                val = Double.valueOf(str).doubleValue();\n+                sampleStats.addValue(val);\n+            }\n+            inputStream.close();\n+            inputStream = null;\n+        }\n+    }\n+\n+    /**\n+     * <code>DataAdapter</code> for data provided as array of doubles.\n+     */\n+    private class ArrayDataAdapter extends DataAdapter {\n+\n+        /** Array of input  data values */\n+        private double[] inputArray;\n+\n+        /**\n+         * Construct an ArrayDataAdapter from a double[] array\n+         *\n+         * @param in double[] array holding the data\n+         * @throws NullArgumentException if in is null\n+         */\n+        public ArrayDataAdapter(double[] in) throws NullArgumentException {\n+            super();\n+            MathUtils.checkNotNull(in);\n+            inputArray = in;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void computeStats() throws IOException {\n+            sampleStats = new SummaryStatistics();\n+            for (int i = 0; i < inputArray.length; i++) {\n+                sampleStats.addValue(inputArray[i]);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void computeBinStats() throws IOException {\n+            for (int i = 0; i < inputArray.length; i++) {\n+                SummaryStatistics stats =\n+                    binStats.get(findBin(inputArray[i]));\n+                stats.addValue(inputArray[i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Fills binStats array (second pass through data file).\n+     *\n+     * @param in object providing access to the data\n+     * @throws IOException  if an IO error occurs\n+     */\n+    private void fillBinStats(Object in) throws IOException {\n+        // Set up grid\n+        min = sampleStats.getMin();\n+        max = sampleStats.getMax();\n+        delta = (max - min)/(Double.valueOf(binCount)).doubleValue();\n+\n+        // Initialize binStats ArrayList\n+        if (!binStats.isEmpty()) {\n+            binStats.clear();\n+        }\n+        for (int i = 0; i < binCount; i++) {\n+            SummaryStatistics stats = new SummaryStatistics();\n+            binStats.add(i,stats);\n+        }\n+\n+        // Filling data in binStats Array\n+        DataAdapterFactory aFactory = new DataAdapterFactory();\n+        DataAdapter da = aFactory.getAdapter(in);\n+        da.computeBinStats();\n+\n+        // Assign upperBounds based on bin counts\n+        upperBounds = new double[binCount];\n+        upperBounds[0] =\n+        ((double) binStats.get(0).getN()) / (double) sampleStats.getN();\n+        for (int i = 1; i < binCount-1; i++) {\n+            upperBounds[i] = upperBounds[i-1] +\n+            ((double) binStats.get(i).getN()) / (double) sampleStats.getN();\n+        }\n+        upperBounds[binCount-1] = 1.0d;\n+    }\n+\n+    /**\n+     * Returns the index of the bin to which the given value belongs\n+     *\n+     * @param value  the value whose bin we are trying to find\n+     * @return the index of the bin containing the value\n+     */\n+    private int findBin(double value) {\n+        return FastMath.min(\n+                FastMath.max((int) FastMath.ceil((value- min) / delta) - 1, 0),\n+                binCount - 1);\n+        }\n \n     /**\n      * Generates a random value from this distribution.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n      * @return the random value.\n-     *\n-     * @throws IllegalStateException if the distribution has not been loaded\n-     */\n-    double getNextValue() throws IllegalStateException;\n-\n-\n-    /**\n-     * Returns a\n-     * {@link org.apache.commons.math.stat.descriptive.StatisticalSummary}\n-     * describing this distribution.\n+     * @throws MathIllegalStateException if the distribution has not been loaded\n+     */\n+    public double getNextValue() throws MathIllegalStateException {\n+\n+        if (!loaded) {\n+            throw new MathIllegalStateException(LocalizedFormats.DISTRIBUTION_NOT_LOADED);\n+        }\n+\n+        // Start with a uniformly distributed random number in (0,1)\n+        double x = randomData.nextUniform(0,1);\n+\n+        // Use this to select the bin and generate a Gaussian within the bin\n+        for (int i = 0; i < binCount; i++) {\n+           if (x <= upperBounds[i]) {\n+               SummaryStatistics stats = binStats.get(i);\n+               if (stats.getN() > 0) {\n+                   if (stats.getStandardDeviation() > 0) {  // more than one obs\n+                        return randomData.nextGaussian\n+                            (stats.getMean(),stats.getStandardDeviation());\n+                   } else {\n+                       return stats.getMean(); // only one obs in bin\n+                   }\n+               }\n+           }\n+        }\n+        throw new MathIllegalStateException(LocalizedFormats.NO_BIN_SELECTED);\n+    }\n+\n+    /**\n+     * Returns a {@link StatisticalSummary} describing this distribution.\n      * <strong>Preconditions:</strong><ul>\n-     * <li>the distribution must be loaded before invoking this method</li>\n-     * </ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n      *\n      * @return the sample statistics\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n-    StatisticalSummary getSampleStats() throws IllegalStateException;\n+    public StatisticalSummary getSampleStats() {\n+        return sampleStats;\n+    }\n+\n+    /**\n+     * Returns the number of bins.\n+     *\n+     * @return the number of bins.\n+     */\n+    public int getBinCount() {\n+        return binCount;\n+    }\n+\n+    /**\n+     * Returns a List of {@link SummaryStatistics} instances containing\n+     * statistics describing the values in each of the bins.  The list is\n+     * indexed on the bin number.\n+     *\n+     * @return List of bin statistics.\n+     */\n+    public List<SummaryStatistics> getBinStats() {\n+        return binStats;\n+    }\n+\n+    /**\n+     * <p>Returns a fresh copy of the array of upper bounds for the bins.\n+     * Bins are: <br/>\n+     * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n+     *  (upperBounds[binCount-2], upperBounds[binCount-1] = max].</p>\n+     *\n+     * <p>Note: In versions 1.0-2.0 of commons-math, this method\n+     * incorrectly returned the array of probability generator upper\n+     * bounds now returned by {@link #getGeneratorUpperBounds()}.</p>\n+     *\n+     * @return array of bin upper bounds\n+     * @since 2.1\n+     */\n+    public double[] getUpperBounds() {\n+        double[] binUpperBounds = new double[binCount];\n+        binUpperBounds[0] = min + delta;\n+        for (int i = 1; i < binCount - 1; i++) {\n+            binUpperBounds[i] = binUpperBounds[i-1] + delta;\n+        }\n+        binUpperBounds[binCount - 1] = max;\n+        return binUpperBounds;\n+    }\n+\n+    /**\n+     * <p>Returns a fresh copy of the array of upper bounds of the subintervals\n+     * of [0,1] used in generating data from the empirical distribution.\n+     * Subintervals correspond to bins with lengths proportional to bin counts.</p>\n+     *\n+     * <p>In versions 1.0-2.0 of commons-math, this array was (incorrectly) returned\n+     * by {@link #getUpperBounds()}.</p>\n+     *\n+     * @since 2.1\n+     * @return array of upper bounds of subintervals used in data generation\n+     */\n+    public double[] getGeneratorUpperBounds() {\n+        int len = upperBounds.length;\n+        double[] out = new double[len];\n+        System.arraycopy(upperBounds, 0, out, 0, len);\n+        return out;\n+    }\n \n     /**\n      * Property indicating whether or not the distribution has been loaded.\n      *\n      * @return true if the distribution has been loaded\n      */\n-    boolean isLoaded();\n-\n-     /**\n-     * Returns the number of bins.\n-     *\n-     * @return the number of bins\n-     */\n-    int getBinCount();\n-\n-    /**\n-     * Returns a list of\n-     * {@link org.apache.commons.math.stat.descriptive.SummaryStatistics}\n-     * containing statistics describing the values in each of the bins.  The\n-     * List is indexed on the bin number.\n-     *\n-     * @return List of bin statistics\n-     */\n-    List<SummaryStatistics> getBinStats();\n-\n-    /**\n-     * Returns the array of upper bounds for the bins.  Bins are: <br/>\n-     * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n-     *  (upperBounds[binCount-2], upperBounds[binCount-1] = max].\n-     *\n-     * @return array of bin upper bounds\n-     */\n-    double[] getUpperBounds();\n-\n+    public boolean isLoaded() {\n+        return loaded;\n+    }\n+\n+    /**\n+     * Reseeds the random number generator used by {@link #getNextValue()}.\n+     *\n+     * @param seed random generator seed\n+     * @since 3.0\n+     */\n+    public void reSeed(long seed) {\n+        randomData.reSeed(seed);\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/main/java/org/apache/commons/math/random/ValueServer.java\n      * @throws IOException if an I/O error occurs reading the input file\n      */\n     public void computeDistribution() throws IOException {\n-        computeDistribution(EmpiricalDistributionImpl.DEFAULT_BIN_COUNT);\n+        computeDistribution(EmpiricalDistribution.DEFAULT_BIN_COUNT);\n     }\n \n     /**\n      */\n     public void computeDistribution(int binCount)\n             throws IOException {\n-        empiricalDistribution = new EmpiricalDistributionImpl(binCount, randomData);\n+        empiricalDistribution = new EmpiricalDistribution(binCount, randomData);\n         empiricalDistribution.load(valuesFileURL);\n         mu = empiricalDistribution.getSampleStats().getMean();\n         sigma = empiricalDistribution.getSampleStats().getStandardDeviation();\n--- a/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n \n public final class EmpiricalDistributionTest {\n \n-    protected EmpiricalDistributionImpl empiricalDistribution = null;\n-    protected EmpiricalDistributionImpl empiricalDistribution2 = null;\n+    protected EmpiricalDistribution empiricalDistribution = null;\n+    protected EmpiricalDistribution empiricalDistribution2 = null;\n     protected File file = null;\n     protected URL url = null;\n     protected double[] dataArray = null;\n \n     @Before\n     public void setUp() throws IOException {\n-        empiricalDistribution = new EmpiricalDistributionImpl(100);\n+        empiricalDistribution = new EmpiricalDistribution(100);\n         url = getClass().getResource(\"testData.txt\");\n \n-        empiricalDistribution2 = new EmpiricalDistributionImpl(100);\n+        empiricalDistribution2 = new EmpiricalDistribution(100);\n         BufferedReader in =\n                 new BufferedReader(new InputStreamReader(\n                         url.openStream()));\n      */\n     @Test\n     public void testGridTooFine() throws Exception {\n-        empiricalDistribution = new EmpiricalDistributionImpl(1001);\n+        empiricalDistribution = new EmpiricalDistribution(1001);\n         tstGen(0.1);\n-        empiricalDistribution2 = new EmpiricalDistributionImpl(1001);\n+        empiricalDistribution2 = new EmpiricalDistribution(1001);\n         tstDoubleGen(0.1);\n     }\n \n      */\n     @Test\n     public void testGridTooFat() throws Exception {\n-        empiricalDistribution = new EmpiricalDistributionImpl(1);\n+        empiricalDistribution = new EmpiricalDistribution(1);\n         tstGen(5); // ridiculous tolerance; but ridiculous grid size\n                    // really just checking to make sure we do not bomb\n-        empiricalDistribution2 = new EmpiricalDistributionImpl(1);\n+        empiricalDistribution2 = new EmpiricalDistribution(1);\n         tstDoubleGen(5);\n     }\n \n     @Test\n     public void testBinIndexOverflow() throws Exception {\n         double[] x = new double[] {9474.94326071674, 2080107.8865462579};\n-        new EmpiricalDistributionImpl().load(x);\n+        new EmpiricalDistribution().load(x);\n     }\n \n     @Test\n     public void testSerialization() {\n         // Empty\n-        EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n+        EmpiricalDistribution dist = new EmpiricalDistribution();\n         EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);\n         verifySame(dist, dist2);\n \n \n     @Test(expected=NullArgumentException.class)\n     public void testLoadNullDoubleArray() {\n-       new EmpiricalDistributionImpl().load((double[]) null);\n+       new EmpiricalDistribution().load((double[]) null);\n     }\n \n     @Test(expected=NullArgumentException.class)\n     public void testLoadNullURL() throws Exception {\n-        new EmpiricalDistributionImpl().load((URL) null);\n+        new EmpiricalDistribution().load((URL) null);\n     }\n \n     @Test(expected=NullArgumentException.class)\n     public void testLoadNullFile() throws Exception {\n-        new EmpiricalDistributionImpl().load((File) null);\n+        new EmpiricalDistribution().load((File) null);\n     }\n \n     /**\n     @Test\n     public void testGetBinUpperBounds() {\n         double[] testData = {0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10};\n-        EmpiricalDistributionImpl dist = new EmpiricalDistributionImpl(5);\n+        EmpiricalDistribution dist = new EmpiricalDistribution(5);\n         dist.load(testData);\n         double[] expectedBinUpperBounds = {2, 4, 6, 8, 10};\n         double[] expectedGeneratorUpperBounds = {4d/13d, 7d/13d, 9d/13d, 11d/13d, 1};\n         double[] testData = {0, 1, 2, 3, 4};\n         RandomGenerator generator = new RandomAdaptorTest.ConstantGenerator(0.5);\n         \n-        EmpiricalDistribution dist = new EmpiricalDistributionImpl(5, generator);\n+        EmpiricalDistribution dist = new EmpiricalDistribution(5, generator);\n         dist.load(testData);\n         for (int i = 0; i < 5; i++) {\n             Assert.assertEquals(2.0, dist.getNextValue(), 0d);\n         }\n         \n         // Verify no NPE with null generator argument\n-        dist = new EmpiricalDistributionImpl(5, (RandomGenerator) null);\n+        dist = new EmpiricalDistribution(5, (RandomGenerator) null);\n         dist.load(testData);\n         dist.getNextValue();\n     }", "timestamp": 1328642972, "metainfo": ""}