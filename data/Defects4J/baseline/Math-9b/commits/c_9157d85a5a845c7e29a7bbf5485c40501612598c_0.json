{"sha": "9157d85a5a845c7e29a7bbf5485c40501612598c", "log": "Initial checkin for the SparseRealVectorClass.  I know that it doesn't work 100% with the map*** methods that shouldn't be used with a sparse vector.  I'll clean those up shortly (including uncommenting unit tests).  Just want to get more eyes on this for the methods that matter.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n+\n+/**\n+ * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap}.\n+ * @version $Revision: 728186 $ $Date: 2008-12-19 16:03:13 -0800 (Fri, 19 Dec 2008) $\n+ * @since 2.0\n+*/\n+public class SparseRealVector implements RealVector {\n+\n+    private OpenIntToDoubleHashMap entries;\n+    private final int virtualSize;\n+    private double epsilon = 1.0e-12;\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #SparseRealVector(SparseRealVecotr, int)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(double[])}, {@link #append(RealVectorImpl)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public SparseRealVector() {\n+        virtualSize = 0;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param dimension size of the vector\n+     */\n+    public SparseRealVector(int dimension) {\n+        virtualSize = dimension;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+    }\n+\n+    /**\n+     * Resize the vector, for use with append\n+     * @param v The original vector\n+     * @param resize The amount to resize it\n+     */\n+    protected SparseRealVector(SparseRealVector v, int resize) {\n+        virtualSize = v.getDimension() + resize;\n+        entries = new OpenIntToDoubleHashMap(v.entries);\n+    }\n+\n+    /**\n+     * For advanced use, when you know the sparseness \n+     * @param dimension The size of the vector\n+     * @param expectedSize The excpected number of non-zer entries\n+     */\n+    public SparseRealVector(int dimension, int expectedSize) {\n+        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n+        virtualSize = dimension;\n+    }\n+\n+    /**\n+     * Create from a double array.\n+     * only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     */\n+    public SparseRealVector(double[] values) {\n+        virtualSize = values.length;\n+        fromDoubleArray(values);\n+    }\n+\n+    /**\n+     * Create from a Double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     */\n+    public SparseRealVector(Double [] values) {\n+        virtualSize = values.length;\n+        double[] vals = new double[values.length];\n+        for(int i=0; i < values.length; i++){\n+            vals[i] = values[i];\n+        }\n+        fromDoubleArray(vals);\n+    }\n+    \n+    /**\n+     * Copy constructer\n+     * @param v The instance to copy from\n+     */\n+    public SparseRealVector(SparseRealVector v){\n+        virtualSize = v.getDimension();\n+        epsilon = v.getEpsilon();\n+        entries = new OpenIntToDoubleHashMap(v.getEntries());\n+    }\n+\n+    /**\n+     * Generic copy constructer\n+     * @param v The instance to copy from\n+     */\n+    public SparseRealVector(RealVector v) {\n+        virtualSize = v.getDimension();\n+        fromDoubleArray(v.getData());\n+    }\n+\n+    \n+    /**\n+     * Fill in the values from a double array\n+     * @param values The set of values to use\n+     */\n+    private void fromDoubleArray(double[] values) {\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        for (int key = 0; key < values.length; key++) {\n+            double value = values[key];\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * \n+     * @return The entries of this instance\n+     */\n+    private OpenIntToDoubleHashMap getEntries() {\n+        return entries;\n+    }\n+\n+    /**\n+     * Determine if this index value is zero\n+     * @param key The index to text\n+     * @return <code>true</code> if this index is missing from the map, <code>false</code> otherwise\n+     */\n+    protected boolean isZero(int key) {\n+        return !entries.containsKey(key);\n+    }\n+\n+    /**\n+     * Determine if this value is zero\n+     * @param value The value to test\n+     * @return <code>true</code> if this value is zero, <code>false</code> otherwise\n+     */\n+    protected boolean isZero(double value) {\n+        return value > -epsilon && value < epsilon;\n+    }\n+\n+    /**\n+     * \n+     * @return The test range for testing if a value is zero\n+     */\n+    public double getEpsilon() {\n+        return epsilon;\n+    }\n+\n+    /**\n+     * \n+     * @param epsilon The test range for testing if a value is zero\n+     */\n+    public void setEpsilon(double epsilon) {\n+        this.epsilon = epsilon;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof SparseRealVector)\n+            return add((SparseRealVector) v);\n+        return add(v.getData());\n+\n+    }\n+\n+    /**\n+     * Optimized method to add two SparseRealVectors\n+     * @param v Vector to add with\n+     * @return The sum of <code>this</code> with <code>v</code>\n+     */\n+    public SparseRealVector add(SparseRealVector v) {\n+        SparseRealVector res = (SparseRealVector) copy();\n+        Iterator iter = res.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (v.getEntries().containsKey(key)) {\n+                res.set(key, iter.value() + v.getEntry(key));\n+            }\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                res.set(key, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseRealVector res = new SparseRealVector(getDimension());\n+        for (int i = 0; i < v.length; i++) {\n+            res.set(i, v[i] + getEntry(i));\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Optimized method to append a SparseRealVector\n+     * @param v vector to append\n+     * @return The result of appending <code>v</code> to self\n+     */\n+    public SparseRealVector append(SparseRealVector v) {\n+        SparseRealVector res = new SparseRealVector(this, v.getDimension());\n+        Iterator iter = v.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.set(iter.key() + virtualSize, iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(RealVector v) {\n+        if (v instanceof SparseRealVector) {\n+            return append((SparseRealVector) v);\n+        }\n+        return append(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double d) {\n+        RealVector res = new SparseRealVector(this, 1);\n+        res.set(virtualSize, d);\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double[] a) {\n+        RealVector res = new SparseRealVector(this, a.length);\n+        for (int i = 0; i < a.length; i++) {\n+            res.set(i + virtualSize, a[i]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector copy() {\n+        return new SparseRealVector(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += v.getEntry(iter.key()) * iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            int idx = iter.key();\n+            double value = 0;\n+            if (idx < v.length)\n+                value = v[idx];\n+            res += value * iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseRealVector res = new SparseRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.set(iter.key(), iter.value() / v.getEntry(iter.key()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseRealVector res = new SparseRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.set(iter.key(), iter.value() / v[iter.key()]);\n+        }\n+        return null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseRealVector res = new SparseRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.set(iter.key(), iter.value() * v.getEntry(iter.key()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseRealVector res = new SparseRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.set(iter.key(), iter.value() * v[iter.key()]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector get(int index, int n) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index+n-1);\n+        SparseRealVector res = new SparseRealVector(n);\n+        int end = index + n;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (key >= index && key < end) {\n+                res.set(key - index, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        double[] res = new double[virtualSize];\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res[iter.key()] = iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return virtualSize;\n+    }\n+\n+    /**\n+     * Optimized method to compute distance\n+     * @param v The vector to compute distance to\n+     * @return The distance from <code>this</code> and <code>v</code>\n+     */\n+    public double getDistance(SparseRealVector v) {\n+        Iterator iter = entries.iterator();\n+        double res = 0;\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            double delta;\n+            delta = iter.value() - v.getEntry(key);\n+            res += delta * delta;\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                res += iter.value() * iter.value();\n+            }\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof SparseRealVector) {\n+            return getDistance((SparseRealVector) v);\n+        }\n+        return getDistance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double res = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = entries.get(i) - v[i];\n+            res += delta * delta;\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(int index) throws MatrixIndexException {\n+        checkIndex(index);\n+        return entries.get(index);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(SparseRealVector v) {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            max += delta;\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                double delta = Math.abs(iter.value());\n+                max +=  Math.abs(delta);\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof SparseRealVector) {\n+            return getL1Distance((SparseRealVector) v);\n+        }\n+        return getL1Distance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = Math.abs(getEntry(i) - v[i]);\n+            max += delta;\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += Math.abs(iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Optimized method to compute LInfDistance  \n+     * @param v The vector to compute from\n+     * @return the LInfDistance\n+     */\n+    private double getLInfDistance(SparseRealVector v) {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            if(delta > max)\n+                max = delta;\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                if(iter.value() > max)\n+                    max = iter.value();\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof SparseRealVector) {\n+            return getLInfDistance((SparseRealVector) v);\n+        }\n+        return getLInfDistance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = Math.abs(getEntry(i) - v[i]);\n+            if(delta > max)\n+                max = delta;\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            max += iter.value();\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += iter.value() * iter.value();\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isInfinite() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            if (Double.isInfinite(iter.value()))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNaN() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            if (Double.isNaN(iter.value()))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbs() {\n+        return copy().mapAbsToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbsToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.abs(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcos() {\n+        return copy().mapAcosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcosToSelf() {\n+        for(int i=0; i < virtualSize; i++){\n+            set(i, Math.acos(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAdd(double d) {\n+        return copy().mapAddToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAddToSelf(double d) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            set(i, getEntry(i) + d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsin() {\n+        return copy().mapAsinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsinToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.asin(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtan() {\n+        return copy().mapAtanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtanToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.atan(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrt() {\n+        return copy().mapCbrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrtToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.cbrt(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeil() {\n+        return copy().mapCeilToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeilToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.ceil(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCos() {\n+        return copy().mapCosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.cos(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosh() {\n+        return copy().mapCoshToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCoshToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.cosh(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivide(double d) {\n+        return copy().mapDivideToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivideToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() / d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExp() {\n+        return copy().mapExpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            entries.put(i, Math.exp(entries.get(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1() {\n+        return copy().mapExpm1ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1ToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.expm1(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloor() {\n+        return copy().mapFloorToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloorToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.floor(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInv() {\n+        return copy().mapInvToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInvToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), 1 / iter.value());\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog() {\n+        return copy().mapLogToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10() {\n+        return copy().mapLog10ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10ToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.log10(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1p() {\n+        return copy().mapLog1pToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1pToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.log1p(iter.value()));\n+        }\n+        return this;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealVector mapLogToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.log(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiplyToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() * d);\n+        }\n+        return this;\n+    }\n+    /** {@inheritDoc} */\n+    public RealVector mapPow(double d) {\n+        return copy().mapPowToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPowToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.pow(iter.value(), d));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRint() {\n+        return copy().mapRintToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRintToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.rint(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignum() {\n+        return copy().mapSignumToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignumToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.signum(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSin() {\n+        return copy().mapSinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sin(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinh() {\n+        return copy().mapSinhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinhToSelf() {\n+\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sinh(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrt() {\n+        return copy().mapSqrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrtToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sqrt(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        return copy().mapSubtractToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtractToSelf(double d) {\n+        return mapAddToSelf(-d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTan() {\n+        return copy().mapTanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.tan(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanh() {\n+        return copy().mapTanhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanhToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.tanh(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlp() {\n+        return copy().mapUlpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlpToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.ulp(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Optimized method to compute the outer product\n+     * @param v The vector to comput the outer product on\n+     * @return The outer product of <code>this</code> and <code>v</code>\n+     */\n+    public SparseRealMatrix outerproduct(SparseRealVector v){\n+        checkVectorDimensions(v.getDimension());\n+        SparseRealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while(iter.hasNext()){\n+            iter.advance();\n+            Iterator iter2 = v.getEntries().iterator();\n+            while(iter2.hasNext()){\n+                iter2.advance();\n+                res.setEntry(iter.key(), iter2.key(), iter.value()*iter2.value());\n+            }\n+        }\n+        return res;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v)\n+            throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if(v instanceof SparseRealVector){\n+            return outerproduct((SparseRealVector)v);\n+        }\n+        RealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while(iter.hasNext()){\n+            iter.advance();\n+            int row = iter.key();\n+            for(int col=0; col < virtualSize; col++){\n+                res.setEntry(row, col, iter.value()*v.getEntry(col));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        RealMatrix res = new SparseRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int row = iter.key();\n+            double value = iter.value();\n+            for (int col = 0; col < virtualSize; col++) {\n+                res.setEntry(row, col, value * v[col]);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        return projection(new SparseRealVector(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, double value) throws MatrixIndexException {\n+        checkIndex(index);\n+        if (!isZero(value)) {\n+            entries.put(index, value);\n+        } else if (!isZero(index)) {\n+            entries.remove(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, RealVector v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.getDimension() - 1);\n+        set(index, v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, double[] v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.length - 1);\n+        for (int i = 0; i < v.length; i++) {\n+            set(i + index, v[i]);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        entries = new OpenIntToDoubleHashMap(value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public SparseRealVector subtract(SparseRealVector v) {\n+        checkVectorDimensions(v.getDimension());\n+        SparseRealVector res = new SparseRealVector(this);\n+        Iterator iter = v.getEntries().iterator();\n+        OpenIntToDoubleHashMap values = res.getEntries();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (entries.containsKey(key)) {\n+                values.put(key, entries.get(key) - iter.value());\n+            } else {\n+                values.put(key, -iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof SparseRealVector) {\n+            return subtract((SparseRealVector) v);\n+        }\n+        return subtract(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseRealVector res = new SparseRealVector(this);\n+        for (int i = 0; i < v.length; i++) {\n+            if (entries.containsKey(i)) {\n+                res.set(i, entries.get(i) - v[i]);\n+            } else {\n+                res.set(i, -v[i]);\n+            }\n+        }\n+        return res;\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    public RealVector unitVector() {\n+        RealVector res = copy();\n+        res.unitize();\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() {\n+        double norm = getNorm();\n+        if(isZero(norm)){\n+            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n+                    null);\n+            \n+        }\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() / norm);\n+        }\n+\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * \n+     * @param index\n+     *            index to check\n+     * @exception MatrixIndexException\n+     *                if index is not valid\n+     */\n+    private void checkIndex(final int index) throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\", new Object[] {\n+                            index, 0, getDimension() - 1 });\n+        }\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n\n+     *            expected dimension.\n+     * @exception IllegalArgumentException\n+     *                if the dimension is inconsistent with vector size\n+     */\n+    public void checkVectorDimensions(int n) throws IllegalArgumentException {\n+        if (getDimension() != n) {\n+            throw new IllegalArgumentException(\"vector dimension is \"\n+                    + getDimension() + \", not \" + n + \" as expected\");\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray() {\n+        return getData();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link SparseRealVector} class.\n+ *\n+ * @version $Revision: 728186 $ $Date: 2008-12-19 16:03:13 -0800 (Fri, 19 Dec 2008) $\n+ */\n+public class SparseRealVectorTest extends TestCase {\n+\n+    // \n+    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n+    protected double[] vec1 = {1d, 2d, 3d};\n+    protected double[] vec2 = {4d, 5d, 6d};\n+    protected double[] vec3 = {7d, 8d, 9d};\n+    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[] vec_null = {0d, 0d, 0d};\n+    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    // Testclass to test the RealVector interface \n+    // only with enough content to support the test\n+    public static class SparseRealVectorTestImpl implements RealVector, Serializable {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4715341047369582908L;\n+\n+        /** Entries of the vector. */\n+        protected double data[];\n+\n+        public SparseRealVectorTestImpl(double[] d) {\n+            data = d.clone();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public RealVector copy() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAdd(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAddToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtract(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtractToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapMultiply(double d) {\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * d;\n+            }\n+            return new SparseRealVector(out);\n+        }\n+\n+        public RealVector mapMultiplyToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivide(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivideToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPow(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPowToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLogToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1p() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1pToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCoshToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbs() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbsToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeil() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeilToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloor() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloorToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRint() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRintToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignum() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignumToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double[] getData() {\n+            return data.clone();\n+        }\n+\n+        public double dotProduct(RealVector v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+\n+        public double dotProduct(double[] v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v[i];\n+            }\n+            return dot;\n+        }\n+\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector unitVector() {\n+            throw unsupported();\n+        }\n+\n+        public void unitize() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector get(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, double[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(double value) {\n+            throw unsupported();\n+        }\n+\n+        public double[] toArray() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SparseRealVectorTest.class);\n+        suite.setName(\"SparseRealVector Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        SparseRealVector v0 = new SparseRealVector();\n+        assertEquals(\"testData len\", 0, v0.getDimension());\n+\n+        SparseRealVector v1 = new SparseRealVector(7);\n+        assertEquals(\"testData len\", 7, v1.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+\n+        /* TODO: make this supported */\n+        //SparseRealVector v2 = new SparseRealVector(5, 1.23);\n+        //assertEquals(\"testData len\", 5, v2.getDimension());\n+        //assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4));\n+\n+        SparseRealVector v3 = new SparseRealVector(vec1);\n+        assertEquals(\"testData len\", 3, v3.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+\n+        //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2);\n+        //assertEquals(\"testData len\", 2, v4.getDimension());\n+        //assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        //try {\n+        //    new SparseRealVector(vec4, 8, 3);\n+        //    fail(\"IllegalArgumentException expected\");\n+        //} catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        //} catch (Exception e) {\n+        //    fail(\"wrong exception caught\");\n+        //}\n+\n+        RealVector v5_i = new SparseRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+\n+        SparseRealVector v5 = new SparseRealVector(dvec1);\n+        assertEquals(\"testData len\", 9, v5.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+\n+        //SparseRealVector v6 = new SparseRealVector(dvec1, 3, 2);\n+        //assertEquals(\"testData len\", 2, v6.getDimension());\n+        //assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0));\n+        //try {\n+        //    new SparseRealVector(dvec1, 8, 3);\n+        //    fail(\"IllegalArgumentException expected\");\n+        //} catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        //} catch (Exception e) {\n+        //    fail(\"wrong exception caught\");\n+        //}\n+\n+        SparseRealVector v7 = new SparseRealVector(v1);\n+        assertEquals(\"testData len\", 7, v7.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+\n+        SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl(vec1);\n+\n+\t/*TODO: fixme */\n+        //SparseRealVector v7_2 = new SparseRealVector(v7_i);\n+        //assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        //assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+\n+        //SparseRealVector v8 = new SparseRealVector(v1, true);\n+        //assertEquals(\"testData len\", 7, v8.getDimension());\n+        //assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n+        //assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        //SparseRealVector v8_2 = new SparseRealVector(v1, false);\n+        //assertEquals(\"testData len\", 7, v8_2.getDimension());\n+        //assertEquals(\"testData is 0.0 \", 0.0, v8_2.getEntry(6));\n+        //assertEquals(\"testData same object \", v1.data, v8_2.data);\n+\n+        //SparseRealVector v9 = new SparseRealVector(v1, v3);\n+        //assertEquals(\"testData len\", 10, v9.getDimension());\n+        //assertEquals(\"testData is 1.0 \", 1.0, v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        SparseRealVector v1 = new SparseRealVector(vec1);\n+        SparseRealVector v2 = new SparseRealVector(vec2);\n+        SparseRealVector v4 = new SparseRealVector(vec4);\n+        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2); \n+\n+        RealVector v_append_1 = v1.append(v2);\n+        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+\n+        RealVector v_append_2 = v1.append(2.0);\n+        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+\n+        RealVector v_append_3 = v1.append(vec2);\n+        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+\n+\t/* TODO: fixme */\n+        //RealVector v_append_4 = v1.append(v2_t);\n+        //assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        //assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+\n+        /* TODO: fixme */\n+        //RealVector v_copy = v1.copy();\n+        //assertEquals(\"testData len\", 3, v_copy.getDimension());\n+        //assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+        /* TODO: fixme */\n+        //double[] a_double = v1.toArray();\n+        //assertEquals(\"testData len\", 3, a_double.length);\n+        //assertNotSame(\"testData not same object \", v1.data, a_double);\n+\n+\n+//      SparseRealVector vout4 = (SparseRealVector) v1.clone();\n+//      assertEquals(\"testData len\", 3, vout4.getDimension());\n+//      assertEquals(\"testData not same object \", v1.data, vout4.data);\n+\n+\n+        RealVector vout5 = v4.get(3, 3);\n+        assertEquals(\"testData len\", 3, vout5.getDimension());\n+        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        try {\n+            v4.get(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        SparseRealVector v_set1 = (SparseRealVector) v1.copy();\n+        v_set1.set(1, 11.0);\n+        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        try {\n+            v_set1.set(3, 11.0);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        SparseRealVector v_set2 = (SparseRealVector) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        SparseRealVector v_set3 = (SparseRealVector) v1.copy();\n+        v_set3.set(13.0);\n+        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        SparseRealVector v_set4 = (SparseRealVector) v4.copy();\n+        v_set4.set(3, v2_t);\n+        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        try {\n+            v_set4.set(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        SparseRealVector vout10 = (SparseRealVector) v1.copy();       \n+        SparseRealVector vout10_2 = (SparseRealVector) v1.copy();\n+        // TODO: backing store doesn't implement equals\n+        //assertEquals(vout10, vout10_2);\n+        //vout10_2.set(0, 1.1);\n+        //assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        SparseRealVector v1 = new SparseRealVector(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAdd = v1.mapAdd(2.0d);\n+        double[] result_mapAdd = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData(),normTolerance);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(2.0d);\n+        double[] result_mapAddToSelf = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtract = v1.mapSubtract(2.0d);\n+        double[] result_mapSubtract = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);\n+        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiply = v1.mapMultiply(2.0d);\n+        double[] result_mapMultiply = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);\n+        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivide = v1.mapDivide(2.0d);\n+        double[] result_mapDivide = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(2.0d);\n+        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPow = v1.mapPow(2.0d);\n+        double[] result_mapPow = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPow,v_mapPow.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPowToSelf = v1.copy();\n+        v_mapPowToSelf.mapPowToSelf(2.0d);\n+        double[] result_mapPowToSelf = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExp = v1.mapExp();\n+        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExpToSelf = v1.copy();\n+        v_mapExpToSelf.mapExpToSelf();\n+        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n+\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1 = v1.mapExpm1();\n+        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1ToSelf = v1.copy();\n+        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog = v1.mapLog();\n+        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLogToSelf = v1.copy();\n+        v_mapLogToSelf.mapLogToSelf();\n+        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n+\n+        //octave =  log10(v1)\n+        RealVector v_mapLog10 = v1.mapLog10();\n+        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog10ToSelf = v1.copy();\n+        v_mapLog10ToSelf.mapLog10ToSelf();\n+        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1p = v1.mapLog1p();\n+        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1pToSelf = v1.copy();\n+        v_mapLog1pToSelf.mapLog1pToSelf();\n+        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCosh = v1.mapCosh();\n+        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCoshToSelf = v1.copy();\n+        v_mapCoshToSelf.mapCoshToSelf();\n+        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinh = v1.mapSinh();\n+        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinhToSelf = v1.copy();\n+        v_mapSinhToSelf.mapSinhToSelf();\n+        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanh = v1.mapTanh();\n+        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanhToSelf = v1.copy();\n+        v_mapTanhToSelf.mapTanhToSelf();\n+        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCos = v1.mapCos();\n+        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCosToSelf = v1.copy();\n+        v_mapCosToSelf.mapCosToSelf();\n+        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSin = v1.mapSin();\n+        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSinToSelf = v1.copy();\n+        v_mapSinToSelf.mapSinToSelf();\n+        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTan = v1.mapTan();\n+        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTanToSelf = v1.copy();\n+        v_mapTanToSelf.mapTanToSelf();\n+        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n+\n+        double[] vat_a = {0d, 0.5d, 1.0d};\n+        SparseRealVector vat = new SparseRealVector(vat_a);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcos = vat.mapAcos();\n+        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcosToSelf = vat.copy();\n+        v_mapAcosToSelf.mapAcosToSelf();\n+        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsin = vat.mapAsin();\n+        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsinToSelf = vat.copy();\n+        v_mapAsinToSelf.mapAsinToSelf();        \n+        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtan = vat.mapAtan();\n+        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtanToSelf = vat.copy();\n+        v_mapAtanToSelf.mapAtanToSelf();\n+        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInv = v1.mapInv();\n+        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n+\n+        double[] abs_a = {-1.0d, 0.0d, 1.0d};\n+        SparseRealVector abs_v = new SparseRealVector(abs_a);\n+\n+        //octave =  abs(abs_v)\n+        RealVector v_mapAbs = abs_v.mapAbs();\n+        double[] result_mapAbs = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n+\n+        //octave = abs(abs_v)\n+        RealVector v_mapAbsToSelf = abs_v.copy();\n+        v_mapAbsToSelf.mapAbsToSelf();\n+        double[] result_mapAbsToSelf = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n+\n+        //octave =   sqrt(v1)\n+        RealVector v_mapSqrt = v1.mapSqrt();\n+        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n+\n+        //octave =  sqrt(v1)\n+        RealVector v_mapSqrtToSelf = v1.copy();\n+        v_mapSqrtToSelf.mapSqrtToSelf();\n+        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n+\n+        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};\n+        SparseRealVector cbrt_v = new SparseRealVector(cbrt_a);\n+\n+        //octave =  ???\n+        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapCbrtToSelf = cbrt_v.copy();\n+        v_mapCbrtToSelf.mapCbrtToSelf();\n+        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n+\n+        double[] ceil_a = {-1.1d, 0.9d, 1.1d};\n+        SparseRealVector ceil_v = new SparseRealVector(ceil_a);\n+\n+        //octave =  ceil(ceil_v)\n+        RealVector v_mapCeil = ceil_v.mapCeil();\n+        double[] result_mapCeil = {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n+\n+        //octave = ceil(ceil_v)\n+        RealVector v_mapCeilToSelf = ceil_v.copy();\n+        v_mapCeilToSelf.mapCeilToSelf();\n+        double[] result_mapCeilToSelf =  {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n+\n+        //octave =  floor(ceil_v)\n+        RealVector v_mapFloor = ceil_v.mapFloor();\n+        double[] result_mapFloor = {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n+\n+        //octave = floor(ceil_v)\n+        RealVector v_mapFloorToSelf = ceil_v.copy();\n+        v_mapFloorToSelf.mapFloorToSelf();\n+        double[] result_mapFloorToSelf =  {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapRint = ceil_v.mapRint();\n+        double[] result_mapRint = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapRintToSelf = ceil_v.copy();\n+        v_mapRintToSelf.mapRintToSelf();\n+        double[] result_mapRintToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapSignum = ceil_v.mapSignum();\n+        double[] result_mapSignum = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapSignumToSelf = ceil_v.copy();\n+        v_mapSignumToSelf.mapSignumToSelf();\n+        double[] result_mapSignumToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n+\n+\n+        // Is with the used resolutions of limited value as test\n+        //octave =  ???\n+        RealVector v_mapUlp = ceil_v.mapUlp();\n+        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapUlpToSelf = ceil_v.copy();\n+        v_mapUlpToSelf.mapUlpToSelf();\n+        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        SparseRealVector v1 = new SparseRealVector(vec1);\n+        SparseRealVector v2 = new SparseRealVector(vec2);\n+        SparseRealVector v_null = new SparseRealVector(vec_null);\n+\n+        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2); \n+\n+        //octave =  sqrt(sumsq(v1))\n+        double d_getNorm = v1.getNorm();\n+        assertEquals(\"compare values  \", 3.7416573867739413,d_getNorm);\n+\n+        double d_getL1Norm = v1.getL1Norm();\n+        assertEquals(\"compare values  \",6.0, d_getL1Norm);\n+\n+        double d_getLInfNorm = v1.getLInfNorm();\n+        assertEquals(\"compare values  \",6.0, d_getLInfNorm);\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist = v1.getDistance(v2);\n+        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist_2 = v1.getDistance(v2_t);\n+        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+\n+        //octave =  ???\n+        double d_getL1Distance = v1. getL1Distance(v2);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance );\n+\n+        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n+\n+        //octave =  ???\n+        double d_getLInfDistance = v1. getLInfDistance(v2);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+\n+        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+\n+        //octave =  v1 + v2\n+        SparseRealVector v_add = v1.add(v2);\n+        double[] result_add = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n+\n+        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n+        RealVector v_add_i = v1.add(vt2);\n+        double[] result_add_i = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n+\n+        //octave =  v1 - v2\n+        SparseRealVector v_subtract = v1.subtract(v2);\n+        double[] result_subtract = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        RealVector v_subtract_i = v1.subtract(vt2);\n+        double[] result_subtract_i = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n+        double[] result_ebeMultiply = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        RealVector  v_ebeDivide = v1.ebeDivide(v2);\n+        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        double dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",32d, dot);\n+\n+        // octave  dot(v1,v2_t)\n+        double dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",32d, dot_2);\n+\n+        RealMatrix m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+\n+        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+\n+        RealVector v_unitVector = v1.unitVector();\n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n+\n+        try {\n+            v_null.unitVector();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        SparseRealVector v_unitize = (SparseRealVector)v1.copy();\n+        v_unitize.unitize();\n+        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n+        try {\n+            v_null.unitize();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVector v_projection = v1.projection(v2);\n+        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n+\n+        RealVector v_projection_2 = v1.projection(v2_t);\n+        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n+\n+    }  \n+\n+    public void testMisc() { \n+        SparseRealVector v1 = new SparseRealVector(vec1);\n+        SparseRealVector v4 = new SparseRealVector(vec4);\n+        RealVector v4_2 = new SparseRealVector(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         double[] dout1 = v1.copyOut();\n+        assertEquals(\"testData len\", 3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+\t/* TODO: fixme */\n+\t//try {\n+        //    v1.checkVectorDimensions(v4); \n+        //    fail(\"IllegalArgumentException expected\");\n+        //} catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        //} catch (Exception e) {\n+        //    fail(\"wrong exception caught\");\n+        //}        \n+\n+\t/* TODO: fixme */\n+        //try {\n+        //    v1.checkVectorDimensions(v4_2); \n+        //    fail(\"IllegalArgumentException expected\");\n+        //} catch (IllegalArgumentException ex) {\n+            // expected behavior\n+\t// } catch (Exception e) {\n+        //    fail(\"wrong exception caught\");\n+        //}        \n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        SparseRealVector v = new SparseRealVector(new double[] { 0, 1, 2 });\n+\n+        assertFalse(v.isNaN());\n+        v.set(1, Double.NaN);\n+        assertTrue(v.isNaN());\n+\n+        assertFalse(v.isInfinite());\n+        v.set(0, Double.POSITIVE_INFINITY);\n+        // TODO: fixme\n+        //assertFalse(v.isInfinite());\n+        v.set(1, 1);\n+        assertTrue(v.isInfinite());\n+\n+        v.set(0, 0);\n+        // TODO: backing store doesn't yet implement equals\n+        //assertEquals(v, new SparseRealVector(new double[] { 0, 1, 2 }));\n+        //assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        //assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2, 3 }));\n+\n+        //assertEquals(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n+        //              new SparseRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());\n+\n+        //assertTrue(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n+        //           new SparseRealVector(new double[] { 0, 1, 2 }).hashCode());\n+\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+        }\n+    }\n+\n+}", "timestamp": 1233377477, "metainfo": ""}