{"sha": "19502baded28216a3e0e93343e7d723aa1f9a7b5", "log": "Extended StepNormalizer with normalization mode and bounds settings.  JIRA: MATH-595  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n package org.apache.commons.math.ode.sampling;\n \n import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.ode.sampling.FixedStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  *\n  * <p>The stepsize used is selected at construction time. The {@link\n  * FixedStepHandler#handleStep handleStep} method of the underlying\n- * {@link FixedStepHandler} object is called at the beginning time of\n- * the integration t0 and also at times t0+h, t0+2h, ... If the\n- * integration range is an integer multiple of the stepsize, then the\n- * last point handled will be the endpoint of the integration tend, if\n- * not, the last point will belong to the interval [tend - h ;\n- * tend].</p>\n- *\n- * <p>There is no constraint on the integrator, it can use any\n- * timestep it needs (time steps longer or shorter than the fixed time\n- * step and non-integer ratios are all allowed).</p>\n+ * {@link FixedStepHandler} object is called at normalized times. The\n+ * normalized times can be influenced by the {@link StepNormalizerMode} and\n+ * {@link StepNormalizerBounds}.</p>\n+ *\n+ * <p>There is no constraint on the integrator, it can use any time step\n+ * it needs (time steps longer or shorter than the fixed time step and\n+ * non-integer ratios are all allowed).</p>\n+ *\n+ * <p>\n+ * <table border=\"1\" align=\"center\">\n+ * <tr BGCOLOR=\"#CCCCFF\"><td colspan=6><font size=\"+2\">Examples (step size = 0.5)</font></td></tr>\n+ * <tr BGCOLOR=\"#EEEEFF\"><font size=\"+1\"><td>Start time</td><td>End time</td>\n+ *  <td>Direction</td><td>{@link StepNormalizerMode Mode}</td>\n+ *  <td>{@link StepNormalizerBounds Bounds}</td><td>Output</td></font></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>0.8, 1.3, 1.8, 2.3, 2.8</td></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>0.3, 0.8, 1.3, 1.8, 2.3, 2.8</td></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>0.8, 1.3, 1.8, 2.3, 2.8, 3.1</td></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.1</td></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.1</td></tr>\n+ * <tr><td>0.3</td><td>3.1</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.1</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>0.0</td><td>3.0</td><td>forward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>2.6, 2.1, 1.6, 1.1, 0.6</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>3.1, 2.6, 2.1, 1.6, 1.1, 0.6</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>2.6, 2.1, 1.6, 1.1, 0.6, 0.3</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>3.1, 2.6, 2.1, 1.6, 1.1, 0.6, 0.3</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>3.0, 2.5, 2.0, 1.5, 1.0, 0.5</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>3.1, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3</td></tr>\n+ * <tr><td>3.1</td><td>0.3</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>3.1, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#INCREMENT INCREMENT}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#NEITHER NEITHER}</td><td>2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#FIRST FIRST}</td><td>3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#LAST LAST}</td><td>2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * <tr><td>3.0</td><td>0.0</td><td>backward</td><td>{@link StepNormalizerMode#MULTIPLES MULTIPLES}</td><td>{@link StepNormalizerBounds#BOTH BOTH}</td><td>3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0</td></tr>\n+ * </table>\n+ * </p>\n  *\n  * @see StepHandler\n  * @see FixedStepHandler\n+ * @see StepNormalizerMode\n+ * @see StepNormalizerBounds\n  * @version $Id$\n  * @since 1.2\n  */\n \n public class StepNormalizer implements StepHandler {\n-\n     /** Fixed time step. */\n     private double h;\n \n     /** Underlying step handler. */\n     private final FixedStepHandler handler;\n \n+    /** First step time. */\n+    private double firstTime;\n+\n     /** Last step time. */\n     private double lastTime;\n \n-    /** Last State vector. */\n+    /** Last state vector. */\n     private double[] lastState;\n \n-    /** Last Derivatives vector. */\n+    /** Last derivatives vector. */\n     private double[] lastDerivatives;\n \n     /** Integration direction indicator. */\n     private boolean forward;\n \n+    /** The step normalizer bounds settings to use. */\n+    private final StepNormalizerBounds bounds;\n+\n+    /** The step normalizer mode to use. */\n+    private final StepNormalizerMode mode;\n+\n+    /** Simple constructor. Uses {@link StepNormalizerMode#INCREMENT INCREMENT}\n+     * mode, and {@link StepNormalizerBounds#FIRST FIRST} bounds setting, for\n+     * backwards compatibility.\n+     * @param h fixed time step (sign is not used)\n+     * @param handler fixed time step handler to wrap\n+     */\n+    public StepNormalizer(final double h, final FixedStepHandler handler) {\n+        this(h, handler, StepNormalizerMode.INCREMENT,\n+             StepNormalizerBounds.FIRST);\n+    }\n+\n+    /** Simple constructor. Uses {@link StepNormalizerBounds#FIRST FIRST}\n+     * bounds setting.\n+     * @param h fixed time step (sign is not used)\n+     * @param handler fixed time step handler to wrap\n+     * @param mode step normalizer mode to use\n+     * @since 3.0\n+     */\n+    public StepNormalizer(final double h, final FixedStepHandler handler,\n+                          final StepNormalizerMode mode) {\n+        this(h, handler, mode, StepNormalizerBounds.FIRST);\n+    }\n+\n+    /** Simple constructor. Uses {@link StepNormalizerMode#INCREMENT INCREMENT}\n+     * mode.\n+     * @param h fixed time step (sign is not used)\n+     * @param handler fixed time step handler to wrap\n+     * @param bounds step normalizer bounds setting to use\n+     * @since 3.0\n+     */\n+    public StepNormalizer(final double h, final FixedStepHandler handler,\n+                          final StepNormalizerBounds bounds) {\n+        this(h, handler, StepNormalizerMode.INCREMENT, bounds);\n+    }\n+\n     /** Simple constructor.\n      * @param h fixed time step (sign is not used)\n      * @param handler fixed time step handler to wrap\n-     */\n-    public StepNormalizer(final double h, final FixedStepHandler handler) {\n+     * @param mode step normalizer mode to use\n+     * @param bounds step normalizer bounds setting to use\n+     * @since 3.0\n+     */\n+    public StepNormalizer(final double h, final FixedStepHandler handler,\n+                          final StepNormalizerMode mode,\n+                          final StepNormalizerBounds bounds) {\n         this.h       = FastMath.abs(h);\n         this.handler = handler;\n+        this.mode    = mode;\n+        this.bounds  = bounds;\n         reset();\n     }\n \n      * handled.\n      */\n     public void reset() {\n+        firstTime       = Double.NaN;\n         lastTime        = Double.NaN;\n         lastState       = null;\n         lastDerivatives = null;\n      * @throws MathUserException this exception is propagated to the\n      * caller if the underlying user function triggers one\n      */\n-    public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n-        throws MathUserException {\n-\n+    public void handleStep(final StepInterpolator interpolator,\n+                           final boolean isLast) throws MathUserException {\n+        // The first time, update the last state with the start information.\n         if (lastState == null) {\n-\n+            firstTime = interpolator.getPreviousTime();\n             lastTime = interpolator.getPreviousTime();\n             interpolator.setInterpolatedTime(lastTime);\n             lastState = interpolator.getInterpolatedState().clone();\n             lastDerivatives = interpolator.getInterpolatedDerivatives().clone();\n \n-            // take the integration direction into account\n+            // Take the integration direction into account.\n             forward = interpolator.getCurrentTime() >= lastTime;\n-            if (! forward) {\n-                h = -h;\n+            if (!forward) h = -h;\n+        }\n+\n+        double nextTime = (mode == StepNormalizerMode.INCREMENT) ?\n+                          lastTime + h :\n+                          (FastMath.floor(lastTime / h) + 1) * h;\n+        boolean nextInStep = isNextInStep(nextTime, interpolator);\n+        while (nextInStep) {\n+            // Output the stored previous step.\n+            doNormalizedStep(false);\n+\n+            // Store the next step as last step.\n+            storeStep(interpolator, nextTime);\n+\n+            // Move on to the next step.\n+            nextTime += h;\n+            nextInStep = isNextInStep(nextTime, interpolator);\n+        }\n+\n+        if (isLast) {\n+            // There will be no more steps. The stored one should be given to\n+            // the handler. We may have to output one more step. Only the last\n+            // one of those should be flagged as being the last.\n+            boolean addLast = bounds.lastIncluded() &&\n+                              lastTime != interpolator.getCurrentTime();\n+            doNormalizedStep(!addLast);\n+            if (addLast) {\n+                storeStep(interpolator, interpolator.getCurrentTime());\n+                doNormalizedStep(true);\n             }\n-\n         }\n-\n-        double nextTime = lastTime + h;\n-        boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n-        while (nextInStep) {\n-\n-            // output the stored previous step\n-            handler.handleStep(lastTime, lastState, lastDerivatives, false);\n-\n-            // store the next step\n-            lastTime = nextTime;\n-            interpolator.setInterpolatedTime(lastTime);\n-            System.arraycopy(interpolator.getInterpolatedState(), 0,\n-                             lastState, 0, lastState.length);\n-            System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n-                             lastDerivatives, 0, lastDerivatives.length);\n-\n-            nextTime  += h;\n-            nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n-\n-        }\n-\n-        if (isLast) {\n-            // there will be no more steps,\n-            // the stored one should be flagged as being the last\n-            handler.handleStep(lastTime, lastState, lastDerivatives, true);\n-        }\n-\n-    }\n-\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the next normalized time is in the\n+     * current step.\n+     * @param nextTime the next normalized time\n+     * @param interpolator interpolator for the last accepted step, to use to\n+     * get the end time of the current step\n+     * @return value indicating whether the next normalized time is in the\n+     * current step\n+     */\n+    private boolean isNextInStep(double nextTime,\n+                                 StepInterpolator interpolator) {\n+        return forward ? nextTime <= interpolator.getCurrentTime()\n+                       : nextTime >= interpolator.getCurrentTime();\n+    }\n+\n+    /**\n+     * Invokes the underlying step handler for the current normalized step.\n+     * @param isLast true if the step is the last one\n+     * @throws MathUserException this exception is propagated to the\n+     * caller if the underlying user function triggers one\n+     */\n+    private void doNormalizedStep(boolean isLast) throws MathUserException {\n+        if (!bounds.firstIncluded() && firstTime == lastTime) return;\n+        handler.handleStep(lastTime, lastState, lastDerivatives, isLast);\n+    }\n+\n+    /** Stores the interpolated information for the given time in the current\n+     * state.\n+     * @param interpolator interpolator for the last accepted step, to use to\n+     * get the interpolated information\n+     * @param t the time for which to store the interpolated information\n+     */\n+    private void storeStep(StepInterpolator interpolator, double t) {\n+        lastTime = t;\n+        interpolator.setInterpolatedTime(lastTime);\n+        System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                         lastState, 0, lastState.length);\n+        System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n+                         lastDerivatives, 0, lastDerivatives.length);\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizerBounds.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+/** {@link StepNormalizer Step normalizer} bounds settings. They influence\n+ * whether the underlying fixed step size step handler is called for the first\n+ * and last points. Note that if the last point coincides with a normalized\n+ * point, then the underlying fixed step size step handler is always called,\n+ * regardless of these settings.\n+ * @see StepNormalizer\n+ * @see StepNormalizerMode\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public enum StepNormalizerBounds {\n+    /** Do not include the first and last points. */\n+    NEITHER(false, false),\n+\n+    /** Include the first point, but not the last point. */\n+    FIRST(true, false),\n+\n+    /** Include the last point, but not the first point. */\n+    LAST(false, true),\n+\n+    /** Include both the first and last points. */\n+    BOTH(true, true);\n+\n+    /** Whether the first point should be passed to the underlying fixed\n+     * step size step handler.\n+     */\n+    private final boolean first;\n+\n+    /** Whether the last point should be passed to the underlying fixed\n+     * step size step handler.\n+     */\n+    private final boolean last;\n+\n+    /**\n+     * Simple constructor.\n+     * @param first Whether the first point should be passed to the\n+     * underlying fixed step size step handler.\n+     * @param last Whether the last point should be passed to the\n+     * underlying fixed step size step handler.\n+     */\n+    private StepNormalizerBounds(final boolean first, final boolean last) {\n+        this.first = first;\n+        this.last = last;\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the first point should be passed\n+     * to the underlying fixed step size step handler.\n+     * @return value indicating whether the first point should be passed\n+     * to the underlying fixed step size step handler.\n+     */\n+    public boolean firstIncluded() {\n+        return first;\n+    }\n+\n+    /**\n+     * Returns a value indicating whether the last point should be passed\n+     * to the underlying fixed step size step handler.\n+     * @return value indicating whether the last point should be passed\n+     * to the underlying fixed step size step handler.\n+     */\n+    public boolean lastIncluded() {\n+        return last;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizerMode.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+\n+/** {@link StepNormalizer Step normalizer} modes. Determines how the step size\n+ * is interpreted.\n+ * @see StepNormalizer\n+ * @see StepNormalizerBounds\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public enum StepNormalizerMode {\n+    /**\n+     * Steps are fixed increments of the start value. In other words, they\n+     * are relative to the start value.\n+     *\n+     * <p>If the integration start time is t0, then the points handled by\n+     * the underlying fixed step size step handler are t0 (depending on\n+     * the {@link StepNormalizerBounds bounds settings}), t0+h, t0+2h, ...</p>\n+     *\n+     * <p>If the integration range is an integer multiple of the step size\n+     * (h), then the last point handled will be the end point of the\n+     * integration (tend). If not, the last point may be the end point\n+     * tend, or it may be a point belonging to the interval [tend - h ;\n+     * tend], depending on the {@link StepNormalizerBounds bounds settings}.\n+     * </p>\n+     *\n+     * @see StepNormalizer\n+     * @see StepNormalizerBounds\n+     */\n+    INCREMENT,\n+\n+    /** Steps are multiples of a fixed value. In other words, they are\n+     * relative to the first multiple of the step size that is encountered\n+     * after the start value.\n+     *\n+     * <p>If the integration start time is t0, and the first multiple of\n+     * the fixed step size that is encountered is t1, then the points\n+     * handled by the underlying fixed step size step handler are t0\n+     * (depending on the {@link StepNormalizerBounds bounds settings}), t1,\n+     * t1+h, t1+2h, ...</p>\n+     *\n+     * <p>If the end point of the integration range (tend) is an integer\n+     * multiple of the step size (h) added to t1, then the last point\n+     * handled will be the end point of the integration (tend). If not,\n+     * the last point may be the end point tend, or it may be a point\n+     * belonging to the interval [tend - h ; tend], depending on the\n+     * {@link StepNormalizerBounds bounds settings}.</p>\n+     *\n+     * @see StepNormalizer\n+     * @see StepNormalizerBounds\n+     */\n+    MULTIPLES;\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerOutputOverlapTest.java\n+package org.apache.commons.math.ode.sampling;\n+\n+/** Step normalizer output tests, for problems where the first and last points\n+ * are overlap fixed points.\n+ */\n+public class StepNormalizerOutputOverlapTest extends StepNormalizerOutputTestBase {\n+    @Override\n+    protected double getStart() {\n+        return 0.0;\n+    }\n+\n+    @Override\n+    protected double getEnd() {\n+        return 10.0;\n+    }\n+\n+    @Override\n+    protected double[] getExpInc() {\n+        return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,\n+                              4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,\n+                              9.0, 9.5, 10.0 };\n+    }\n+\n+    @Override\n+    protected double[] getExpIncRev() {\n+        return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5,\n+                              6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,\n+                              2.0, 1.5, 1.0, 0.5, 0.0 };\n+    }\n+\n+    @Override\n+    protected double[] getExpMul() {\n+        return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,\n+                              4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,\n+                              9.0, 9.5, 10.0 };\n+    }\n+\n+    @Override\n+    protected double[] getExpMulRev() {\n+        return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5,\n+                              6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,\n+                              2.0, 1.5, 1.0, 0.5, 0.0 };\n+    }\n+\n+    @Override\n+    protected int[][] getO() {\n+        return new int[][] {{1, 0}, {1, 0}, {0, 0}, {0, 0},\n+                            {1, 0}, {1, 0}, {0, 0}, {0, 0},\n+                            {1, 0}, {1, 0}, {0, 0}, {0, 0},\n+                            {1, 0}, {1, 0}, {0, 0}, {0, 0}};\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerOutputTest.java\n+package org.apache.commons.math.ode.sampling;\n+\n+/** Step normalizer output tests, for problems where the first and last points\n+ * are not fixed points.\n+ */\n+public class StepNormalizerOutputTest extends StepNormalizerOutputTestBase {\n+    @Override\n+    protected double getStart() {\n+        return 0.3;\n+    }\n+\n+    @Override\n+    protected double getEnd() {\n+        return 10.1;\n+    }\n+\n+    @Override\n+    protected double[] getExpInc() {\n+        return new double[] { 0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.3, 3.8, 4.3,\n+                              4.8, 5.3, 5.8, 6.3, 6.8, 7.3, 7.8, 8.3, 8.8,\n+                              9.3, 9.8, 10.1 };\n+    }\n+\n+    @Override\n+    protected double[] getExpIncRev() {\n+        return new double[] { 10.1, 9.6, 9.1, 8.6, 8.1, 7.6, 7.1, 6.6,\n+                              6.1, 5.6, 5.1, 4.6, 4.1, 3.6, 3.1, 2.6,\n+                              2.1, 1.6, 1.1, 0.6, 0.3 };\n+    }\n+\n+    @Override\n+    protected double[] getExpMul() {\n+        return new double[] { 0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,\n+                              4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5,\n+                              9.0, 9.5, 10.0, 10.1 };\n+    }\n+\n+    @Override\n+    protected double[] getExpMulRev() {\n+        return new double[] { 10.1, 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0,\n+                              6.5, 6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5,\n+                              2.0, 1.5, 1.0, 0.5, 0.3 };\n+    }\n+\n+    @Override\n+    protected int[][] getO() {\n+        return new int[][] {{1, 1}, {1, 1}, {0, 1}, {0, 1},\n+                            {1, 0}, {1, 0}, {0, 0}, {0, 0},\n+                            {1, 1}, {1, 1}, {0, 1}, {0, 1},\n+                            {1, 0}, {1, 0}, {0, 0}, {0, 0}};\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/sampling/StepNormalizerOutputTestBase.java\n+package org.apache.commons.math.ode.sampling;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n+import org.junit.Test;\n+\n+/** Base class for step normalizer output tests. */\n+public abstract class StepNormalizerOutputTestBase\n+    implements FirstOrderDifferentialEquations, FixedStepHandler\n+{\n+    /** The normalized output time values. */\n+    private List<Double> output;\n+\n+    /**\n+     * Returns the start time.\n+     * @return the start time\n+     */\n+    protected abstract double getStart();\n+\n+    /**\n+     * Returns the end time.\n+     * @return the end time\n+     */\n+    protected abstract double getEnd();\n+\n+    /**\n+     * Returns the expected normalized output time values for increment mode.\n+     * @return the expected normalized output time values for increment mode\n+     */\n+    protected abstract double[] getExpInc();\n+\n+    /**\n+     * Returns the expected reversed normalized output time values for\n+     * increment mode.\n+     * @return the expected reversed normalized output time values for\n+     * increment mode\n+     */\n+    protected abstract double[] getExpIncRev();\n+\n+    /**\n+     * Returns the expected normalized output time values for multiples mode.\n+     * @return the expected normalized output time values for multiples mode\n+     */\n+    protected abstract double[] getExpMul();\n+\n+    /**\n+     * Returns the expected reversed normalized output time values for\n+     * multiples mode.\n+     * @return the expected reversed normalized output time values for\n+     * multiples mode\n+     */\n+    protected abstract double[] getExpMulRev();\n+\n+    /**\n+     * Returns the offsets for the unit tests below, in the order they are\n+     * given below. For each test, the left and right offsets are returned.\n+     * @return the offsets for the unit tests below, in the order they are\n+     * given below\n+     */\n+    protected abstract int[][] getO();\n+\n+    /**\n+     * Get the array, given left and right offsets.\n+     * @param a the input array\n+     * @param offsetL the left side offset\n+     * @param offsetR the right side offset\n+     * @return the modified array\n+     */\n+    private double[] getArray(double[] a, int offsetL, int offsetR) {\n+        double[] copy = new double[a.length - offsetR - offsetL];\n+        System.arraycopy(a, offsetL, copy, 0, copy.length);\n+        return copy;\n+    }\n+\n+    @Test\n+    public void testIncNeither() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpInc(), getO()[0][0], getO()[0][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.NEITHER, exp, false);\n+    }\n+\n+    @Test\n+    public void testIncNeitherRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpIncRev(), getO()[1][0], getO()[1][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.NEITHER, exp, true);\n+    }\n+\n+    @Test\n+    public void testIncFirst() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpInc(), getO()[2][0], getO()[2][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.FIRST, exp, false);\n+    }\n+\n+    @Test\n+    public void testIncFirstRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpIncRev(), getO()[3][0], getO()[3][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.FIRST, exp, true);\n+    }\n+\n+    @Test\n+    public void testIncLast() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpInc(), getO()[4][0], getO()[4][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.LAST, exp, false);\n+    }\n+\n+    @Test\n+    public void testIncLastRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpIncRev(), getO()[5][0], getO()[5][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.LAST, exp, true);\n+    }\n+\n+    @Test\n+    public void testIncBoth() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpInc(), getO()[6][0], getO()[6][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.BOTH, exp, false);\n+    }\n+\n+    @Test\n+    public void testIncBothRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpIncRev(), getO()[7][0], getO()[7][1]);\n+        doTest(StepNormalizerMode.INCREMENT, StepNormalizerBounds.BOTH, exp, true);\n+    }\n+\n+    @Test\n+    public void testMulNeither() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMul(), getO()[8][0], getO()[8][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.NEITHER, exp, false);\n+    }\n+\n+    @Test\n+    public void testMulNeitherRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMulRev(), getO()[9][0], getO()[9][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.NEITHER, exp, true);\n+    }\n+\n+    @Test\n+    public void testMulFirst() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMul(), getO()[10][0], getO()[10][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.FIRST, exp, false);\n+    }\n+\n+    @Test\n+    public void testMulFirstRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMulRev(), getO()[11][0], getO()[11][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.FIRST, exp, true);\n+    }\n+\n+    @Test\n+    public void testMulLast() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMul(), getO()[12][0], getO()[12][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.LAST, exp, false);\n+    }\n+\n+    @Test\n+    public void testMulLastRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMulRev(), getO()[13][0], getO()[13][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.LAST, exp, true);\n+    }\n+\n+    @Test\n+    public void testMulBoth() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMul(), getO()[14][0], getO()[14][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.BOTH, exp, false);\n+    }\n+\n+    @Test\n+    public void testMulBothRev() throws MathUserException, IntegratorException {\n+        double[] exp = getArray(getExpMulRev(), getO()[15][0], getO()[15][1]);\n+        doTest(StepNormalizerMode.MULTIPLES, StepNormalizerBounds.BOTH, exp, true);\n+    }\n+\n+    /**\n+     * The actual step normalizer output test code, shared by all the unit\n+     * tests.\n+     *\n+     * @param mode the step normalizer mode to use\n+     * @param bounds the step normalizer bounds setting to use\n+     * @param expected the expected output (normalized time points)\n+     * @param reverse whether to reverse the integration direction\n+     */\n+    private void doTest(StepNormalizerMode mode, StepNormalizerBounds bounds,\n+                        double[] expected, boolean reverse)\n+        throws MathUserException, IntegratorException\n+    {\n+        // Forward test.\n+        FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(\n+                                                        1e-8, 1.0, 1e-5, 1e-5);\n+        integ.addStepHandler(new StepNormalizer(0.5, this, mode, bounds));\n+        double[] y   = {0.0};\n+        double start = reverse ? getEnd()   : getStart();\n+        double end   = reverse ? getStart() : getEnd();\n+        output       = new ArrayList<Double>();\n+        integ.integrate(this, start, y, end, y);\n+        double[] actual = new double[output.size()];\n+        for(int i = 0; i < actual.length; i++) {\n+            actual[i] = output.get(i);\n+        }\n+        assertArrayEquals(expected, actual, 1e-5);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return 1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void computeDerivatives(double t, double[] y, double[] yDot)\n+        throws MathUserException {\n+        yDot[0] = y[0];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void handleStep(double t, double[] y, double[] yDot, boolean isLast)\n+        throws MathUserException {\n+        output.add(t);\n+    }\n+}", "timestamp": 1308671243, "metainfo": ""}