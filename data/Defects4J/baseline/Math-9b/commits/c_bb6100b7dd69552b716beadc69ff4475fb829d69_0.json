{"sha": "bb6100b7dd69552b716beadc69ff4475fb829d69", "log": "Added a getRuntimeClass method to the Field interface.  This interface allows using a complete hierarchy of fields sharing a common interface.  JIRA: MATH-284  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/Field.java\n+++ b/src/main/java/org/apache/commons/math/Field.java\n      */\n     T getOne();\n \n+    /**\n+     * Returns the runtime class of the FieldElement. \n+     * \n+     * @return The {@code Class} object that represents the runtime\n+     *         class of this object.\n+     */\n+    Class<? extends FieldElement<T>> getRuntimeClass();\n+\n }\n--- a/src/main/java/org/apache/commons/math/complex/ComplexField.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexField.java\n import java.io.Serializable;\n \n import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n \n /**\n  * Representation of the complex numbers field.\n         return Complex.ZERO;\n     }\n \n+    /** {@inheritDoc} */\n+    public Class<? extends FieldElement<Complex>> getRuntimeClass() {\n+        return Complex.class;\n+    }\n+\n     // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n--- a/src/main/java/org/apache/commons/math/dfp/DfpField.java\n+++ b/src/main/java/org/apache/commons/math/dfp/DfpField.java\n package org.apache.commons.math.dfp;\n \n import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n \n /** Field for Decimal floating point instances.\n  * @version $Id$\n         return one;\n     }\n \n+    /** {@inheritDoc} */\n+    public Class<? extends FieldElement<Dfp>> getRuntimeClass() {\n+        return Dfp.class;\n+    }\n+\n     /** Get the constant 2.\n      * @return a {@link Dfp} with value 2\n      */\n--- a/src/main/java/org/apache/commons/math/fraction/BigFractionField.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionField.java\n import java.io.Serializable;\n \n import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n \n /**\n  * Representation of the fractional numbers  without any overflow field.\n         return BigFraction.ZERO;\n     }\n \n+    /** {@inheritDoc} */\n+    public Class<? extends FieldElement<BigFraction>> getRuntimeClass() {\n+        return BigFraction.class;\n+    }\n     // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n--- a/src/main/java/org/apache/commons/math/fraction/FractionField.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionField.java\n import java.io.Serializable;\n \n import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n \n /**\n  * Representation of the fractional numbers field.\n         return Fraction.ZERO;\n     }\n \n+    /** {@inheritDoc} */\n+    public Class<? extends FieldElement<Fraction>> getRuntimeClass() {\n+        return Fraction.class;\n+    }\n     // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n                                                                   final int rows,\n                                                                   final int columns) {\n         if (columns < 0) {\n-            T[] dummyRow = (T[]) Array.newInstance(field.getZero().getClass(), 0);\n+            T[] dummyRow = (T[]) Array.newInstance(field.getRuntimeClass(), 0);\n             return (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n         }\n         T[][] array =\n-            (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { rows, columns });\n+            (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });\n         for (int i = 0; i < array.length; ++i) {\n             Arrays.fill(array[i], field.getZero());\n         }\n     protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field,\n                                                                 final int length) {\n         @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n-        T[] array = (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n     }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n      */\n     @SuppressWarnings(\"unchecked\") // field is of type T\n     private T[] buildArray(final int length) {\n-        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        return (T[]) Array.newInstance(field.getRuntimeClass(), length);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecomposition.java\n                 }\n \n                 @SuppressWarnings(\"unchecked\") // field is of type T\n-                final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n+                final T[] bp = (T[]) Array.newInstance(field.getRuntimeClass(), m);\n \n                 // Apply permutations to b\n                 for (int row = 0; row < m; row++) {\n \n             @SuppressWarnings(\"unchecked\")\n             // field is of type T\n-            final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(),\n+            final T[] bp = (T[]) Array.newInstance(field.getRuntimeClass(),\n                                                    m);\n \n             // Apply permutations to b\n \n             // Apply permutations to b\n             @SuppressWarnings(\"unchecked\") // field is of type T\n-            final T[][] bp = (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { m, nColB });\n+            final T[][] bp = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { m, nColB });\n             for (int row = 0; row < m; row++) {\n                 final T[] bpRow = bp[row];\n                 final int pRow = pivot[row];\n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n         createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n         final T zero = field.getZero();\n         final T one  = field.getOne();\n-        @SuppressWarnings(\"unchecked\") // zero is type T\n-        final T[][] d = (T[][]) Array.newInstance(zero.getClass(), new int[] { dimension, dimension });\n+        @SuppressWarnings(\"unchecked\")\n+        final T[][] d = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { dimension, dimension });\n         for (int row = 0; row < dimension; row++) {\n             final T[] dRow = d[row];\n             Arrays.fill(dRow, zero);\n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n      */\n     @SuppressWarnings(\"unchecked\") // field is type T\n     private T[] buildArray(final int length) {\n-        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        return (T[]) Array.newInstance(field.getRuntimeClass(), length);\n     }\n \n \n--- a/src/main/java/org/apache/commons/math/util/BigRealField.java\n+++ b/src/main/java/org/apache/commons/math/util/BigRealField.java\n import java.io.Serializable;\n \n import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n \n /**\n  * Representation of real numbers with arbitrary precision field.\n         return BigReal.ZERO;\n     }\n \n+    /** {@inheritDoc} */\n+    public Class<? extends FieldElement<BigReal>> getRuntimeClass() {\n+        return BigReal.class;\n+    }\n+\n     // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n      */\n     @SuppressWarnings(\"unchecked\") // field is of type T\n     private T[] buildArray(final int length) {\n-        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        return (T[]) Array.newInstance(field.getRuntimeClass(), length);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n          */\n         @SuppressWarnings(\"unchecked\") // field is of type T\n         private T[] buildArray(final int length) {\n-            return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+            return (T[]) Array.newInstance(field.getRuntimeClass(), length);\n         }\n \n         public FieldVectorTestImpl(T[] d) {", "timestamp": 1317482100, "metainfo": ""}