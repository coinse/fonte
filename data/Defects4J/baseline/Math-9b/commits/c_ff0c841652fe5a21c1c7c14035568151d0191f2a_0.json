{"sha": "ff0c841652fe5a21c1c7c14035568151d0191f2a", "log": "MATH-764 MATH-823 Allow explicit setting of RNG (parameter of the constructor). Removed dependency on \"RandomDataImpl\" for the \"sample\" method.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n import org.apache.commons.math3.random.RandomDataImpl;\n import org.apache.commons.math3.util.FastMath;\n \n implements IntegerDistribution, Serializable {\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n-\n-    /**\n-     * RandomData instance used to generate samples from the distribution.\n-     */\n+     /**\n+      * RandomData instance used to generate samples from the distribution.\n+      * @deprecated As of 3.1, to be removed in 4.0. Please use the\n+      * {@link #random} instance variable instead.\n+      */\n     protected final RandomDataImpl randomData = new RandomDataImpl();\n-\n-    /** Default constructor. */\n-    protected AbstractIntegerDistribution() { }\n+    /** RNG instance used to generate samples from the distribution. */\n+    protected final RandomGenerator random;\n+\n+    /**\n+     * @deprecated As of 3.1, to be removed in 4.0. Please use\n+     * {@link #AbstractIntegerDistribution(RandomGenerator)} instead.\n+     */\n+    @Deprecated\n+    protected AbstractIntegerDistribution() {\n+        // Legacy users are only allowed to access the deprecated \"randomData\".\n+        // New users are forbidden to use this constructor.\n+        random = null;\n+    }\n+    /**\n+     * @param rng Random number generator.\n+     */\n+    protected AbstractIntegerDistribution(RandomGenerator rng) {\n+        random = rng;\n+    }\n \n     /**\n      * {@inheritDoc}\n \n     /** {@inheritDoc} */\n     public void reseedRandomGenerator(long seed) {\n-        randomData.reSeed(seed);\n+        random.setSeed(seed);\n     }\n \n     /**\n      * inversion method</a>.\n      */\n     public int sample() {\n-        return randomData.nextInversionDeviate(this);\n+        return inverseCumulativeProbability(random.nextDouble());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractRealDistribution.java\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n import org.apache.commons.math3.random.RandomDataImpl;\n import org.apache.commons.math3.util.FastMath;\n \n implements RealDistribution, Serializable {\n     /** Default accuracy. */\n     public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n-\n-    /** RandomData instance used to generate samples from the distribution. */\n+     /**\n+      * RandomData instance used to generate samples from the distribution.\n+      * @deprecated As of 3.1, to be removed in 4.0. Please use the\n+      * {@link #random} instance variable instead.\n+      */\n     protected final RandomDataImpl randomData = new RandomDataImpl();\n-\n+    /** RNG instance used to generate samples from the distribution. */\n+    protected final RandomGenerator random;\n     /** Solver absolute accuracy for inverse cumulative computation */\n     private double solverAbsoluteAccuracy = SOLVER_DEFAULT_ABSOLUTE_ACCURACY;\n \n-    /** Default constructor. */\n-    protected AbstractRealDistribution() { }\n+    /**\n+     * @deprecated As of 3.1, to be removed in 4.0. Please use\n+     * {@link #AbstractRealDistribution(RandomGenerator)} instead.\n+     */\n+    @Deprecated\n+    protected AbstractRealDistribution() {\n+        // Legacy users are only allowed to access the deprecated \"randomData\".\n+        // New users are forbidden to use this constructor.\n+        random = null;\n+    }\n+    /**\n+     * @param rng Random number generator.\n+     */\n+    protected AbstractRealDistribution(RandomGenerator rng) {\n+        random = rng;\n+    }\n \n     /**\n      * {@inheritDoc}\n \n     /** {@inheritDoc} */\n     public void reseedRandomGenerator(long seed) {\n-        randomData.reSeed(seed);\n+        random.setSeed(seed);\n     }\n \n     /**\n      * </a>\n      */\n     public double sample() {\n-        return randomData.nextInversionDeviate(this);\n+        return inverseCumulativeProbability(random.nextDouble());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/distribution/BetaDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/BetaDistribution.java\n import org.apache.commons.math3.special.Gamma;\n import org.apache.commons.math3.special.Beta;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implements the Beta distribution.\n      *\n      * @param alpha First shape parameter (must be positive).\n      * @param beta Second shape parameter (must be positive).\n+     */\n+    public BetaDistribution(double alpha, double beta) {\n+        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Build a new instance.\n+     *\n+     * @param alpha First shape parameter (must be positive).\n+     * @param beta Second shape parameter (must be positive).\n      * @param inverseCumAccuracy Maximum absolute error in inverse\n      * cumulative probability estimates (defaults to\n      * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n      * @since 2.1\n      */\n     public BetaDistribution(double alpha, double beta, double inverseCumAccuracy) {\n+        this(new Well19937c(), alpha, beta, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a &beta; distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param alpha First shape parameter (must be positive).\n+     * @param beta Second shape parameter (must be positive).\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @since 3.1\n+     */\n+    public BetaDistribution(RandomGenerator rng,\n+                            double alpha,\n+                            double beta,\n+                            double inverseCumAccuracy) {\n+        super(rng);\n+\n         this.alpha = alpha;\n         this.beta = beta;\n         z = Double.NaN;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n-    }\n-\n-    /**\n-     * Build a new instance.\n-     *\n-     * @param alpha First shape parameter (must be positive).\n-     * @param beta Second shape parameter (must be positive).\n-     */\n-    public BetaDistribution(double alpha, double beta) {\n-        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.special.Beta;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the binomial distribution.\n      * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     public BinomialDistribution(int trials, double p) {\n+        this(new Well19937c(), trials, p);\n+    }\n+\n+    /**\n+     * Creates a binomial distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param trials Number of trials.\n+     * @param p Probability of success.\n+     * @throws NotPositiveException if {@code trials < 0}.\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n+     * @since 3.1\n+     */\n+    public BinomialDistribution(RandomGenerator rng,\n+                                int trials,\n+                                double p) {\n+        super(rng);\n+\n         if (trials < 0) {\n             throw new NotPositiveException(LocalizedFormats.NUMBER_OF_TRIALS,\n                                            trials);\n--- a/src/main/java/org/apache/commons/math3/distribution/CauchyDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/CauchyDistribution.java\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the Cauchy distribution.\n      * @since 2.1\n      */\n     public CauchyDistribution(double median, double scale,\n-                                  double inverseCumAccuracy) {\n+                              double inverseCumAccuracy) {\n+        this(new Well19937c(), median, scale, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a Cauchy distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param median Median for this distribution.\n+     * @param scale Scale parameter for this distribution.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code scale <= 0}.\n+     * @since 3.1\n+     */\n+    public CauchyDistribution(RandomGenerator rng,\n+                              double median,\n+                              double scale,\n+                              double inverseCumAccuracy) {\n+        super(rng);\n         if (scale <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);\n         }\n--- a/src/main/java/org/apache/commons/math3/distribution/ChiSquaredDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/ChiSquaredDistribution.java\n  * limitations under the License.\n  */\n package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the chi-squared distribution.\n      * @since 2.1\n      */\n     public ChiSquaredDistribution(double degreesOfFreedom,\n-                                      double inverseCumAccuracy) {\n+                                  double inverseCumAccuracy) {\n+        this(new Well19937c(), degreesOfFreedom, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom and\n+     * inverse cumulative probability accuracy.\n+     *\n+     * @param rng Random number generator.\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @since 3.1\n+     */\n+    public ChiSquaredDistribution(RandomGenerator rng,\n+                                  double degreesOfFreedom,\n+                                  double inverseCumAccuracy) {\n+        super(rng);\n+\n         gamma = new GammaDistribution(degreesOfFreedom / 2, 2);\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n      *\n      * For this distribution {@code P(X = x)} always evaluates to 0.\n      *\n-     * @return 0\n+     * @return zero.\n      */\n     public double probability(double x) {\n-        return 0.0;\n+        return 0;\n     }\n \n     /** {@inheritDoc} */\n     /**\n      * {@inheritDoc}\n      *\n-     * For {@code k} degrees of freedom, the variance is {@code 2 * k}.\n-     *\n-     * @return {@inheritDoc}\n+     * @return {@code 2 * k}, where {@code k} is the number of degrees of freedom.\n      */\n     public double getNumericalVariance() {\n         return 2 * getDegreesOfFreedom();\n      * The lower bound of the support is always 0 no matter the\n      * degrees of freedom.\n      *\n-     * @return lower bound of the support (always 0)\n+     * @return zero.\n      */\n     public double getSupportLowerBound() {\n         return 0;\n      * The upper bound of the support is always positive infinity no matter the\n      * degrees of freedom.\n      *\n-     * @return upper bound of the support (always Double.POSITIVE_INFINITY)\n+     * @return {@code Double.POSITIVE_INFINITY}.\n      */\n     public double getSupportUpperBound() {\n         return Double.POSITIVE_INFINITY;\n--- a/src/main/java/org/apache/commons/math3/distribution/ExponentialDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/ExponentialDistribution.java\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.ArithmeticUtils;\n+import org.apache.commons.math3.util.ResizableDoubleArray;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the exponential distribution.\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 2401296428283614780L;\n+    /**\n+     * Used when generating Exponential samples.\n+     * Table containing the constants\n+     * q_i = sum_{j=1}^i (ln 2)^j/j! = ln 2 + (ln 2)^2/2 + ... + (ln 2)^i/i!\n+     * until the largest representable fraction below 1 is exceeded.\n+     *\n+     * Note that\n+     * 1 = 2 - 1 = exp(ln 2) - 1 = sum_{n=1}^infty (ln 2)^n / n!\n+     * thus q_i -> 1 as i -> +inf,\n+     * so the higher i, the closer to one we get (the series is not alternating).\n+     *\n+     * By trying, n = 16 in Java is enough to reach 1.0.\n+     */\n+    private static final double[] EXPONENTIAL_SA_QI;\n     /** The mean of this distribution. */\n     private final double mean;\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n-     * Create a exponential distribution with the given mean.\n+     * Initialize tables.\n+     */\n+    static {\n+        /**\n+         * Filling EXPONENTIAL_SA_QI table.\n+         * Note that we don't want qi = 0 in the table.\n+         */\n+        final double LN2 = FastMath.log(2);\n+        double qi = 0;\n+        int i = 1;\n+\n+        /**\n+         * ArithmeticUtils provides factorials up to 20, so let's use that\n+         * limit together with Precision.EPSILON to generate the following\n+         * code (a priori, we know that there will be 16 elements, but it is\n+         * better to not hardcode it).\n+         */\n+        final ResizableDoubleArray ra = new ResizableDoubleArray(20);\n+\n+        while (qi < 1) {\n+            qi += FastMath.pow(LN2, i) / ArithmeticUtils.factorial(i);\n+            ra.addElement(qi);\n+            ++i;\n+        }\n+\n+        EXPONENTIAL_SA_QI = ra.getElements();\n+    }\n+\n+    /**\n+     * Create an exponential distribution with the given mean.\n      * @param mean mean of this distribution.\n      */\n     public ExponentialDistribution(double mean) {\n     }\n \n     /**\n-     * Create a exponential distribution with the given mean.\n+     * Create an exponential distribution with the given mean.\n      *\n      * @param mean Mean of this distribution.\n      * @param inverseCumAccuracy Maximum absolute error in inverse\n      * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n      * @since 2.1\n      */\n-    public ExponentialDistribution(double mean, double inverseCumAccuracy)\n+    public ExponentialDistribution(double mean, double inverseCumAccuracy) {\n+        this(new Well19937c(), mean, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates an exponential distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param mean Mean of this distribution.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n+     * @since 3.1\n+     */\n+    public ExponentialDistribution(RandomGenerator rng,\n+                                   double mean,\n+                                   double inverseCumAccuracy)\n         throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (mean <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n         }\n      */\n     @Override\n     public double sample() {\n-        return randomData.nextExponential(mean);\n+        // Step 1:\n+        double a = 0;\n+        double u = random.nextDouble();\n+\n+        // Step 2 and 3:\n+        while (u < 0.5) {\n+            a += EXPONENTIAL_SA_QI[0];\n+            u *= 2;\n+        }\n+\n+        // Step 4 (now u >= 0.5):\n+        u += u - 1;\n+\n+        // Step 5:\n+        if (u <= EXPONENTIAL_SA_QI[0]) {\n+            return mean * (a + u);\n+        }\n+\n+        // Step 6:\n+        int i = 0; // Should be 1, be we iterate before it in while using 0\n+        double u2 = random.nextDouble();\n+        double umin = u2;\n+\n+        // Step 7 and 8:\n+        do {\n+            ++i;\n+            u2 = random.nextDouble();\n+\n+            if (u2 < umin) {\n+                umin = u2;\n+            }\n+\n+            // Step 8:\n+        } while (u > EXPONENTIAL_SA_QI[i]); // Ensured to exit since EXPONENTIAL_SA_QI[MAX] = 1\n+\n+        return mean * (a + umin * EXPONENTIAL_SA_QI[0]);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.special.Beta;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the F-distribution.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -8516354193418641566L;\n-\n     /** The numerator degrees of freedom. */\n     private final double numeratorDegreesOfFreedom;\n-\n     /** The numerator degrees of freedom. */\n     private final double denominatorDegreesOfFreedom;\n-\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n-\n     /** Cached numerical variance */\n     private double numericalVariance = Double.NaN;\n-\n     /** Whether or not the numerical variance has been calculated */\n     private boolean numericalVarianceIsCalculated = false;\n \n     /**\n-     * Create a F distribution using the given degrees of freedom.\n+     * Creates an F distribution using the given degrees of freedom.\n+     *\n      * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n      * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n      * @throws NotStrictlyPositiveException if\n      * {@code denominatorDegreesOfFreedom <= 0}.\n      */\n     public FDistribution(double numeratorDegreesOfFreedom,\n-                             double denominatorDegreesOfFreedom)\n+                         double denominatorDegreesOfFreedom)\n         throws NotStrictlyPositiveException {\n         this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\n              DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n-     * Create an F distribution using the given degrees of freedom\n+     * Creates an F distribution using the given degrees of freedom\n      * and inverse cumulative probability accuracy.\n+     *\n      * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n      * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n      * @param inverseCumAccuracy the maximum absolute error in inverse\n      * cumulative probability estimates.\n-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n      * @throws NotStrictlyPositiveException if\n      * {@code numeratorDegreesOfFreedom <= 0} or\n      * {@code denominatorDegreesOfFreedom <= 0}.\n      * @since 2.1\n      */\n     public FDistribution(double numeratorDegreesOfFreedom,\n-                             double denominatorDegreesOfFreedom,\n-                             double inverseCumAccuracy)\n+                         double denominatorDegreesOfFreedom,\n+                         double inverseCumAccuracy)\n         throws NotStrictlyPositiveException {\n+        this(new Well19937c(), numeratorDegreesOfFreedom,\n+             denominatorDegreesOfFreedom, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates an F distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param numeratorDegreesOfFreedom Numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom Denominator degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates.\n+     * @throws NotStrictlyPositiveException if\n+     * {@code numeratorDegreesOfFreedom <= 0} or\n+     * {@code denominatorDegreesOfFreedom <= 0}.\n+     * @since 3.1\n+     */\n+    public FDistribution(RandomGenerator rng,\n+                         double numeratorDegreesOfFreedom,\n+                         double denominatorDegreesOfFreedom,\n+                         double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (numeratorDegreesOfFreedom <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                    numeratorDegreesOfFreedom);\n--- a/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.special.Gamma;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the Gamma distribution.\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20120524L;\n-\n     /** The shape parameter. */\n     private final double shape;\n-\n     /** The scale parameter. */\n     private final double scale;\n-\n     /**\n      * The constant value of {@code shape + g + 0.5}, where {@code g} is the\n      * Lanczos constant {@link Gamma#LANCZOS_G}.\n      */\n     private final double shiftedShape;\n-\n     /**\n      * The constant value of\n      * {@code shape / scale * sqrt(e / (2 * pi * (shape + g + 0.5))) / L(shape)},\n      * calculation.\n      */\n     private final double densityPrefactor1;\n-\n     /**\n      * The constant value of\n      * {@code shape * sqrt(e / (2 * pi * (shape + g + 0.5))) / L(shape)},\n      * calculation.\n      */\n     private final double densityPrefactor2;\n-\n     /**\n      * Lower bound on {@code y = x / scale} for the selection of the computation\n      * method in {@link #density(double)}. For {@code y <= minY}, the natural\n      * calculation overflows.\n      */\n     private final double minY;\n-\n     /**\n      * Upper bound on {@code log(y)} ({@code y = x / scale}) for the selection\n      * of the computation method in {@link #density(double)}. For\n      * {@code log(y) >= maxLogY}, the natural calculation overflows.\n      */\n     private final double maxLogY;\n-\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n      */\n     public GammaDistribution(double shape, double scale, double inverseCumAccuracy)\n         throws NotStrictlyPositiveException {\n+        this(new Well19937c(), shape, scale, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a Gamma distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param shape the shape parameter\n+     * @param scale the scale parameter\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0} or\n+     * {@code scale <= 0}.\n+     * @since 3.1\n+     */\n+    public GammaDistribution(RandomGenerator rng,\n+                             double shape,\n+                             double scale,\n+                             double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (shape <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);\n         }\n      */\n     @Override\n     public double sample()  {\n-        return randomData.nextGamma(shape, scale);\n+        if (shape < 1) {\n+            // [1]: p. 228, Algorithm GS\n+\n+            while (true) {\n+                // Step 1:\n+                final double u = random.nextDouble();\n+                final double bGS = 1 + shape / FastMath.E;\n+                final double p = bGS * u;\n+\n+                if (p <= 1) {\n+                    // Step 2:\n+\n+                    final double x = FastMath.pow(p, 1 / shape);\n+                    final double u2 = random.nextDouble();\n+\n+                    if (u2 > FastMath.exp(-x)) {\n+                        // Reject\n+                        continue;\n+                    } else {\n+                        return scale * x;\n+                    }\n+                } else {\n+                    // Step 3:\n+\n+                    final double x = -1 * FastMath.log((bGS - p) / shape);\n+                    final double u2 = random.nextDouble();\n+\n+                    if (u2 > FastMath.pow(x, shape - 1)) {\n+                        // Reject\n+                        continue;\n+                    } else {\n+                        return scale * x;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Now shape >= 1\n+\n+        final double d = shape - 0.333333333333333333;\n+        final double c = 1 / (3 * FastMath.sqrt(d));\n+\n+        while (true) {\n+            final double x = random.nextGaussian();\n+            final double v = (1 + c * x) * (1 + c * x) * (1 + c * x);\n+\n+            if (v <= 0) {\n+                continue;\n+            }\n+\n+            final double x2 = x * x;\n+            final double u = random.nextDouble();\n+\n+            // Squeeze\n+            if (u < 1 - 0.0331 * x2 * x2) {\n+                return scale * d * v;\n+            }\n+\n+            if (FastMath.log(u) < 0.5 * x2 + d * (1 - v + FastMath.log(v))) {\n+                return scale * d * v;\n+            }\n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the hypergeometric distribution.\n public class HypergeometricDistribution extends AbstractIntegerDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -436928820673516179L;\n-\n     /** The number of successes in the population. */\n     private final int numberOfSuccesses;\n-\n     /** The population size. */\n     private final int populationSize;\n-\n     /** The sample size. */\n     private final int sampleSize;\n-\n     /** Cached numerical variance */\n     private double numericalVariance = Double.NaN;\n-\n     /** Whether or not the numerical variance has been calculated */\n     private boolean numericalVarianceIsCalculated = false;\n \n      */\n     public HypergeometricDistribution(int populationSize, int numberOfSuccesses, int sampleSize)\n     throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n+        this(new Well19937c(), populationSize, numberOfSuccesses, sampleSize);\n+    }\n+\n+    /**\n+     * Creates a new hypergeometric distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param populationSize Population size.\n+     * @param numberOfSuccesses Number of successes in the population.\n+     * @param sampleSize Sample size.\n+     * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n+     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n+     * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\n+     * or {@code sampleSize > populationSize}.\n+     * @since 3.1\n+     */\n+    public HypergeometricDistribution(RandomGenerator rng,\n+                                      int populationSize,\n+                                      int numberOfSuccesses,\n+                                      int sampleSize)\n+    throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n+        super(rng);\n+\n         if (populationSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE,\n                                                    populationSize);\n         final double N = getPopulationSize();\n         final double m = getNumberOfSuccesses();\n         final double n = getSampleSize();\n-        return ( n * m * (N - n) * (N - m) ) / ( (N * N * (N - 1)) );\n+        return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));\n     }\n \n     /**\n      */\n     public int getSupportLowerBound() {\n         return FastMath.max(0,\n-                getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n+                            getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.special.Erf;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the log-normal (gaussian) distribution.\n     private final double solverAbsoluteAccuracy;\n \n     /**\n-     * Create a log-normal distribution using the specified scale and shape.\n-     *\n-     * @param scale the scale parameter of this distribution\n-     * @param shape the shape parameter of this distribution\n-     * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n-     */\n-    public LogNormalDistribution(double scale, double shape)\n-        throws NotStrictlyPositiveException {\n-        this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n-    }\n-\n-    /**\n-     * Create a log-normal distribution using the specified scale, shape and\n-     * inverse cumulative distribution accuracy.\n-     *\n-     * @param scale the scale parameter of this distribution\n-     * @param shape the shape parameter of this distribution\n-     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n-     * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n-     */\n-    public LogNormalDistribution(double scale, double shape,\n-        double inverseCumAccuracy) throws NotStrictlyPositiveException {\n-        if (shape <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);\n-        }\n-\n-        this.scale = scale;\n-        this.shape = shape;\n-        this.solverAbsoluteAccuracy = inverseCumAccuracy;\n-    }\n-\n-    /**\n      * Create a log-normal distribution, where the mean and standard deviation\n      * of the {@link NormalDistribution normally distributed} natural\n      * logarithm of the log-normal distribution are equal to zero and one\n      */\n     public LogNormalDistribution() {\n         this(0, 1);\n+    }\n+\n+    /**\n+     * Create a log-normal distribution using the specified scale and shape.\n+     *\n+     * @param scale the scale parameter of this distribution\n+     * @param shape the shape parameter of this distribution\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n+     */\n+    public LogNormalDistribution(double scale, double shape)\n+        throws NotStrictlyPositiveException {\n+        this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a log-normal distribution using the specified scale, shape and\n+     * inverse cumulative distribution accuracy.\n+     *\n+     * @param scale the scale parameter of this distribution\n+     * @param shape the shape parameter of this distribution\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n+     */\n+    public LogNormalDistribution(double scale, double shape, double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        this(new Well19937c(), scale, shape, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a log-normal distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param scale Scale parameter of this distribution.\n+     * @param shape Shape parameter of this distribution.\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n+     */\n+    public LogNormalDistribution(RandomGenerator rng,\n+                                 double scale,\n+                                 double shape,\n+                                 double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        super(rng);\n+\n+        if (shape <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);\n+        }\n+\n+        this.scale = scale;\n+        this.shape = shape;\n+        this.solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n     /** {@inheritDoc} */\n     @Override\n     public double sample()  {\n-        double n = randomData.nextGaussian(0, 1);\n+        final double n = random.nextGaussian();\n         return FastMath.exp(scale + shape * n);\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/NormalDistribution.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.special.Erf;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the normal (gaussian) distribution.\n     private final double solverAbsoluteAccuracy;\n \n     /**\n+     * Create a normal distribution with mean equal to zero and standard\n+     * deviation equal to one.\n+     */\n+    public NormalDistribution() {\n+        this(0, 1);\n+    }\n+\n+    /**\n      * Create a normal distribution using the given mean and standard deviation.\n      *\n      * @param mean Mean for this distribution.\n      */\n     public NormalDistribution(double mean, double sd, double inverseCumAccuracy)\n         throws NotStrictlyPositiveException {\n+        this(new Well19937c(), mean, sd, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a normal distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param mean Mean for this distribution.\n+     * @param sd Standard deviation for this distribution.\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n+     * @since 3.1\n+     */\n+    public NormalDistribution(RandomGenerator rng,\n+                              double mean,\n+                              double sd,\n+                              double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (sd <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n         }\n     }\n \n     /**\n-     * Create a normal distribution with mean equal to zero and standard\n-     * deviation equal to one.\n-     */\n-    public NormalDistribution() {\n-        this(0, 1);\n-    }\n-\n-    /**\n      * Access the mean.\n      *\n      * @return the mean for this distribution.\n      *\n      * For this distribution {@code P(X = x)} always evaluates to 0.\n      *\n-     * @return 0\n+     * @return zero.\n      */\n     public double probability(double x) {\n-        return 0.0;\n+        return 0;\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     @Override\n     public double sample()  {\n-        return randomData.nextGaussian(mean, standardDeviation);\n+        return standardDeviation * random.nextGaussian() + mean;\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/PascalDistribution.java\n import org.apache.commons.math3.special.Beta;\n import org.apache.commons.math3.util.ArithmeticUtils;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * <p>\n      * @param p Probability of success.\n      * @throws NotStrictlyPositiveException if the number of successes is not positive\n      * @throws OutOfRangeException if the probability of success is not in the\n-     * range [0, 1]\n+     * range {@code [0, 1]}.\n      */\n     public PascalDistribution(int r, double p)\n         throws NotStrictlyPositiveException, OutOfRangeException {\n+        this(new Well19937c(), r, p);\n+    }\n+\n+    /**\n+     * Create a Pascal distribution with the given number of successes and\n+     * probability of success.\n+     *\n+     * @param rng Random number generator.\n+     * @param r Number of successes.\n+     * @param p Probability of success.\n+     * @throws NotStrictlyPositiveException if the number of successes is not positive\n+     * @throws OutOfRangeException if the probability of success is not in the\n+     * range {@code [0, 1]}.\n+     * @since 3.1\n+     */\n+    public PascalDistribution(RandomGenerator rng,\n+                              int r,\n+                              double p)\n+        throws NotStrictlyPositiveException, OutOfRangeException {\n+        super(rng);\n+\n         if (r <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n-                                           r);\n+                                                   r);\n         }\n         if (p < 0 || p > 1) {\n             throw new OutOfRangeException(p, 0, 1);\n         return true;\n     }\n }\n-\n--- a/src/main/java/org/apache/commons/math3/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/PoissonDistribution.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.special.Gamma;\n import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.ArithmeticUtils;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the Poisson distribution.\n      * @since 2.1\n      */\n     public static final int DEFAULT_MAX_ITERATIONS = 10000000;\n-\n     /**\n      * Default convergence criterion.\n      * @since 2.1\n      */\n     public static final double DEFAULT_EPSILON = 1e-12;\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -3349935121172596109L;\n-\n     /** Distribution used to compute normal approximation. */\n     private final NormalDistribution normal;\n-\n+    /** Distribution needed for the {@link #sample()} method. */\n+    private final ExponentialDistribution exponential;\n     /** Mean of the distribution. */\n     private final double mean;\n \n     /**\n      * Maximum number of iterations for cumulative probability. Cumulative\n-     * probabilities are estimated using either Lanczos series approximation of\n-     * {@link Gamma#regularizedGammaP(double, double, double, int)}\n+     * probabilities are estimated using either Lanczos series approximation\n+     * of {@link Gamma#regularizedGammaP(double, double, double, int)}\n      * or continued fraction approximation of\n      * {@link Gamma#regularizedGammaQ(double, double, double, int)}.\n      */\n      */\n     public PoissonDistribution(double p, double epsilon, int maxIterations)\n     throws NotStrictlyPositiveException {\n+        this(new Well19937c(), p, epsilon, maxIterations);\n+    }\n+\n+    /**\n+     * Creates a new Poisson distribution with specified mean, convergence\n+     * criterion and maximum number of iterations.\n+     *\n+     * @param rng Random number generator.\n+     * @param p Poisson mean.\n+     * @param epsilon Convergence criterion for cumulative probabilities.\n+     * @param maxIterations the maximum number of iterations for cumulative\n+     * probabilities.\n+     * @throws NotStrictlyPositiveException if {@code p <= 0}.\n+     * @since 3.1\n+     */\n+    public PoissonDistribution(RandomGenerator rng,\n+                               double p,\n+                               double epsilon,\n+                               int maxIterations)\n+    throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (p <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n         }\n         mean = p;\n-        normal = new NormalDistribution(p, FastMath.sqrt(p));\n         this.epsilon = epsilon;\n         this.maxIterations = maxIterations;\n+\n+        // Use the same RNG instance as the parent class.\n+        normal = new NormalDistribution(rng, p, FastMath.sqrt(p),\n+                                        NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+        exponential = new ExponentialDistribution(rng, 1,\n+                                                  ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n      */\n     @Override\n     public int sample() {\n-        return (int) FastMath.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n+        return (int) FastMath.min(nextPoisson(mean), Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * @param meanPoisson Mean of the Poisson distribution.\n+     * @return the next sample.\n+     */\n+    private long nextPoisson(double meanPoisson) {\n+        final double pivot = 40.0d;\n+        if (meanPoisson < pivot) {\n+            double p = FastMath.exp(-meanPoisson);\n+            long n = 0;\n+            double r = 1.0d;\n+            double rnd = 1.0d;\n+\n+            while (n < 1000 * meanPoisson) {\n+                rnd = random.nextDouble();\n+                r = r * rnd;\n+                if (r >= p) {\n+                    n++;\n+                } else {\n+                    return n;\n+                }\n+            }\n+            return n;\n+        } else {\n+            final double lambda = FastMath.floor(meanPoisson);\n+            final double lambdaFractional = meanPoisson - lambda;\n+            final double logLambda = FastMath.log(lambda);\n+            final double logLambdaFactorial = ArithmeticUtils.factorialLog((int) lambda);\n+            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n+            final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1));\n+            final double halfDelta = delta / 2;\n+            final double twolpd = 2 * lambda + delta;\n+            final double a1 = FastMath.sqrt(FastMath.PI * twolpd) * FastMath.exp(1 / 8 * lambda);\n+            final double a2 = (twolpd / delta) * FastMath.exp(-delta * (1 + delta) / twolpd);\n+            final double aSum = a1 + a2 + 1;\n+            final double p1 = a1 / aSum;\n+            final double p2 = a2 / aSum;\n+            final double c1 = 1 / (8 * lambda);\n+\n+            double x = 0;\n+            double y = 0;\n+            double v = 0;\n+            int a = 0;\n+            double t = 0;\n+            double qr = 0;\n+            double qa = 0;\n+            for (;;) {\n+                final double u = random.nextDouble();\n+                if (u <= p1) {\n+                    final double n = random.nextGaussian();\n+                    x = n * FastMath.sqrt(lambda + halfDelta) - 0.5d;\n+                    if (x > delta || x < -lambda) {\n+                        continue;\n+                    }\n+                    y = x < 0 ? FastMath.floor(x) : FastMath.ceil(x);\n+                    final double e = exponential.sample();\n+                    v = -e - (n * n / 2) + c1;\n+                } else {\n+                    if (u > p1 + p2) {\n+                        y = lambda;\n+                        break;\n+                    } else {\n+                        x = delta + (twolpd / delta) * exponential.sample();\n+                        y = FastMath.ceil(x);\n+                        v = -exponential.sample() - delta * (x + 1) / twolpd;\n+                    }\n+                }\n+                a = x < 0 ? 1 : 0;\n+                t = y * (y + 1) / (2 * lambda);\n+                if (v < -t && a == 0) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                qr = t * ((2 * y + 1) / (6 * lambda) - 1);\n+                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));\n+                if (v < qa) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                if (v > qr) {\n+                    continue;\n+                }\n+                if (v < y * logLambda - ArithmeticUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+            }\n+            return y2 + (long) y;\n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/distribution/TDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/TDistribution.java\n import org.apache.commons.math3.special.Beta;\n import org.apache.commons.math3.special.Gamma;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of Student's t-distribution.\n     private final double solverAbsoluteAccuracy;\n \n     /**\n+     * Create a t distribution using the given degrees of freedom.\n+     *\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}\n+     */\n+    public TDistribution(double degreesOfFreedom)\n+        throws NotStrictlyPositiveException {\n+        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n      * Create a t distribution using the given degrees of freedom and the\n      * specified inverse cumulative probability absolute accuracy.\n      *\n      */\n     public TDistribution(double degreesOfFreedom, double inverseCumAccuracy)\n         throws NotStrictlyPositiveException {\n+        this(new Well19937c(), degreesOfFreedom, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a t distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param degreesOfFreedom Degrees of freedom.\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}\n+     * @since 3.1\n+     */\n+    public TDistribution(RandomGenerator rng,\n+                         double degreesOfFreedom,\n+                         double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (degreesOfFreedom <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                    degreesOfFreedom);\n         }\n         this.degreesOfFreedom = degreesOfFreedom;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n-    }\n-\n-    /**\n-     * Create a t distribution using the given degrees of freedom.\n-     *\n-     * @param degreesOfFreedom Degrees of freedom.\n-     * @throws NotStrictlyPositiveException if {@code degreesOfFreedom <= 0}\n-     */\n-    public TDistribution(double degreesOfFreedom)\n-        throws NotStrictlyPositiveException {\n-        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/distribution/TriangularDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/TriangularDistribution.java\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the triangular real distribution.\n public class TriangularDistribution extends AbstractRealDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20120112L;\n-\n     /** Lower limit of this distribution (inclusive). */\n     private final double a;\n-\n     /** Upper limit of this distribution (inclusive). */\n     private final double b;\n-\n     /** Mode of this distribution. */\n     private final double c;\n-\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n-     * Create a triangular real distribution using the given lower limit,\n+     * Creates a triangular real distribution using the given lower limit,\n      * upper limit, and mode.\n      *\n      * @param a Lower limit of this distribution (inclusive).\n      * @param b Upper limit of this distribution (inclusive).\n      * @param c Mode of this distribution.\n-     * @throws NumberIsTooLargeException if {@code a >= b} or if {@code c > b}\n-     * @throws NumberIsTooSmallException if {@code c < a}\n+     * @throws NumberIsTooLargeException if {@code a >= b} or if {@code c > b}.\n+     * @throws NumberIsTooSmallException if {@code c < a}.\n      */\n     public TriangularDistribution(double a, double c, double b)\n         throws NumberIsTooLargeException, NumberIsTooSmallException {\n+        this(new Well19937c(), a, c, b);\n+    }\n+\n+    /**\n+     * Creates a triangular distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param a Lower limit of this distribution (inclusive).\n+     * @param b Upper limit of this distribution (inclusive).\n+     * @param c Mode of this distribution.\n+     * @throws NumberIsTooLargeException if {@code a >= b} or if {@code c > b}.\n+     * @throws NumberIsTooSmallException if {@code c < a}.\n+     * @since 3.1\n+     */\n+    public TriangularDistribution(RandomGenerator rng,\n+                                  double a,\n+                                  double c,\n+                                  double b)\n+        throws NumberIsTooLargeException, NumberIsTooSmallException {\n+        super(rng);\n+\n         if (a >= b) {\n             throw new NumberIsTooLargeException(\n                             LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\n \n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.FastMath;\n \n /**\n  * Implementation of the uniform integer distribution.\n public class UniformIntegerDistribution extends AbstractIntegerDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20120109L;\n-\n     /** Lower bound (inclusive) of this distribution. */\n     private final int lower;\n-\n     /** Upper bound (inclusive) of this distribution. */\n     private final int upper;\n \n      * @param upper Upper bound (inclusive) of this distribution.\n      * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      */\n-    public UniformIntegerDistribution(int lower, int upper) throws NumberIsTooLargeException {\n+    public UniformIntegerDistribution(int lower, int upper)\n+        throws NumberIsTooLargeException {\n+        this(new Well19937c(), lower, upper);\n+    }\n+\n+    /**\n+     * Creates a new uniform integer distribution using the given lower and\n+     * upper bounds (both inclusive).\n+     *\n+     * @param rng Random number generator.\n+     * @param lower Lower bound (inclusive) of this distribution.\n+     * @param upper Upper bound (inclusive) of this distribution.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @since 3.1\n+     */\n+    public UniformIntegerDistribution(RandomGenerator rng,\n+                                      int lower,\n+                                      int upper)\n+        throws NumberIsTooLargeException {\n+        super(rng);\n+\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(\n                             LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n     /** {@inheritDoc} */\n     @Override\n     public int sample() {\n-        return randomData.nextInt(lower, upper);\n+        final double r = random.nextDouble();\n+        final double scaled = r * upper + (1 - r) * lower + r;\n+        return (int) FastMath.floor(scaled);\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n \n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the uniform real distribution.\n public class UniformRealDistribution extends AbstractRealDistribution {\n     /** Default inverse cumulative probability accuracy. */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20120109L;\n-\n     /** Lower bound of this distribution (inclusive). */\n     private final double lower;\n-\n     /** Upper bound of this distribution (exclusive). */\n     private final double upper;\n-\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a standard uniform real distribution with lower bound (inclusive)\n+     * equal to zero and upper bound (exclusive) equal to one.\n+     */\n+    public UniformRealDistribution() {\n+        this(0, 1);\n+    }\n \n     /**\n      * Create a uniform real distribution using the given lower and upper\n     }\n \n     /**\n-     * Create a normal distribution using the given mean, standard deviation and\n-     * inverse cumulative distribution accuracy.\n+     * Create a uniform distribution.\n      *\n      * @param lower Lower bound of this distribution (inclusive).\n      * @param upper Upper bound of this distribution (exclusive).\n      */\n     public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy)\n         throws NumberIsTooLargeException {\n+        this(new  Well19937c(), lower, upper, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a uniform distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param lower Lower bound of this distribution (inclusive).\n+     * @param upper Upper bound of this distribution (exclusive).\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @since 3.1\n+     */\n+    public UniformRealDistribution(RandomGenerator rng,\n+                                   double lower,\n+                                   double upper,\n+                                   double inverseCumAccuracy)\n+        throws NumberIsTooLargeException {\n+        super(rng);\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(\n                             LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n     }\n \n     /**\n-     * Create a standard uniform real distribution with lower bound (inclusive)\n-     * equal to zero and upper bound (exclusive) equal to one.\n-     */\n-    public UniformRealDistribution() {\n-        this(0, 1);\n-    }\n-\n-    /**\n      * {@inheritDoc}\n      *\n      * For this distribution {@code P(X = x)} always evaluates to 0.\n     /** {@inheritDoc} */\n     @Override\n     public double sample()  {\n-        return randomData.nextUniform(lower, upper, true);\n+        final double u = random.nextDouble();\n+        return u * upper + (1 - u) * lower;\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.special.Gamma;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the Weibull distribution. This implementation uses the\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 8589540077390120676L;\n-\n     /** The shape parameter. */\n     private final double shape;\n-\n     /** The scale parameter. */\n     private final double scale;\n-\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n-\n     /** Cached numerical mean */\n     private double numericalMean = Double.NaN;\n-\n     /** Whether or not the numerical mean has been calculated */\n     private boolean numericalMeanIsCalculated = false;\n-\n     /** Cached numerical variance */\n     private double numericalVariance = Double.NaN;\n-\n     /** Whether or not the numerical variance has been calculated */\n     private boolean numericalVarianceIsCalculated = false;\n \n      * @since 2.1\n      */\n     public WeibullDistribution(double alpha, double beta,\n-                                   double inverseCumAccuracy)\n+                               double inverseCumAccuracy) {\n+        this(new Well19937c(), alpha, beta, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a Weibull distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param alpha Shape parameter.\n+     * @param beta Scale parameter.\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates\n+     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n+     * {@code beta <= 0}.\n+     * @since 3.1\n+     */\n+    public WeibullDistribution(RandomGenerator rng,\n+                               double alpha,\n+                               double beta,\n+                               double inverseCumAccuracy)\n         throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (alpha <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE,\n                                                    alpha);\n--- a/src/main/java/org/apache/commons/math3/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/ZipfDistribution.java\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n \n /**\n  * Implementation of the Zipf distribution.\n public class ZipfDistribution extends AbstractIntegerDistribution {\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -140627372283420404L;\n-\n     /** Number of elements. */\n     private final int numberOfElements;\n-\n     /** Exponent parameter of the distribution. */\n     private final double exponent;\n-\n     /** Cached numerical mean */\n     private double numericalMean = Double.NaN;\n-\n     /** Whether or not the numerical mean has been calculated */\n     private boolean numericalMeanIsCalculated = false;\n-\n     /** Cached numerical variance */\n     private double numericalVariance = Double.NaN;\n-\n     /** Whether or not the numerical variance has been calculated */\n     private boolean numericalVarianceIsCalculated = false;\n \n      * @exception NotStrictlyPositiveException if {@code numberOfElements <= 0}\n      * or {@code exponent <= 0}.\n      */\n-    public ZipfDistribution(final int numberOfElements, final double exponent)\n+    public ZipfDistribution(final int numberOfElements, final double exponent) {\n+        this(new Well19937c(), numberOfElements, exponent);\n+    }\n+\n+    /**\n+     * Creates a Zipf distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param numberOfElements Number of elements.\n+     * @param exponent Exponent.\n+     * @exception NotStrictlyPositiveException if {@code numberOfElements <= 0}\n+     * or {@code exponent <= 0}.\n+     * @since 3.1\n+     */\n+    public ZipfDistribution(RandomGenerator rng,\n+                            int numberOfElements,\n+                            double exponent)\n         throws NotStrictlyPositiveException {\n+        super(rng);\n+\n         if (numberOfElements <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n                                                    numberOfElements);\n--- a/src/test/java/org/apache/commons/math3/distribution/AbstractIntegerDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math3/distribution/AbstractIntegerDistributionTest.java\n \n         private final double p = 1d/6d;\n \n+        public DiceDistribution() {\n+            super(null);\n+        }\n+\n         public double probability(int x) {\n             if (x < 1 || x > 6) {\n                 return 0;\n--- a/src/test/java/org/apache/commons/math3/distribution/AbstractRealDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math3/distribution/AbstractRealDistributionTest.java\n         final double x3 = 3.0;\n         final double p12 = 0.5;\n         final AbstractRealDistribution distribution;\n-        distribution = new AbstractRealDistribution() {\n+        distribution = new AbstractRealDistribution(null) {\n             private static final long serialVersionUID = 1L;\n \n             public double cumulativeProbability(final double x) {\n         final double p12 = 1.0 / 3.0;\n         final double p23 = 2.0 / 3.0;\n         final AbstractRealDistribution distribution;\n-        distribution = new AbstractRealDistribution() {\n+        distribution = new AbstractRealDistribution(null) {\n             private static final long serialVersionUID = 1L;\n \n             public double cumulativeProbability(final double x) {", "timestamp": 1342745025, "metainfo": ""}