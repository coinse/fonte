{"sha": "b1a443193116341440f41344780d1fca85de9a11", "log": "Removed deprecated code.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface ExponentialDistribution extends ContinuousDistribution, HasDensity<Double> {\n-    /**\n-     * Modify the mean.\n-     * @param mean the new mean.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setMean(double mean);\n-\n+public interface ExponentialDistribution extends ContinuousDistribution {\n     /**\n      * Access the mean.\n+     *\n      * @return the mean.\n      */\n     double getMean();\n \n     /**\n      * Return the probability density for a particular point.\n-     * @param x  The point at which the density should be computed.\n-     * @return  The pdf at point x.\n+     *\n+     * @param x Point at which the density should be computed.\n+     * @return the pdf at point {@code x}.\n      */\n-    double density(Double x);\n+    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n  */\n public class ExponentialDistributionImpl extends AbstractContinuousDistribution\n     implements ExponentialDistribution, Serializable {\n-\n     /**\n      * Default inverse cumulative probability accuracy\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n-\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 2401296428283614780L;\n-\n     /** The mean of this distribution. */\n     private double mean;\n-\n     /** Inverse cumulative probability accuracy */\n     private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a exponential distribution with the given mean.\n      * @param mean mean of this distribution.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n      * @since 2.1\n      */\n     public ExponentialDistributionImpl(double mean, double inverseCumAccuracy) {\n-        super();\n-        setMeanInternal(mean);\n+        if (mean <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n+        }\n+        this.mean = mean;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /**\n-     * Modify the mean.\n-     * @param mean the new mean.\n-     * @throws IllegalArgumentException if <code>mean</code> is not positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setMean(double mean) {\n-        setMeanInternal(mean);\n-    }\n-    /**\n-     * Modify the mean.\n-     * @param newMean the new mean.\n-     * @throws IllegalArgumentException if <code>newMean</code> is not positive.\n-     */\n-    private void setMeanInternal(double newMean) {\n-        if (newMean <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_MEAN, newMean);\n-        }\n-        this.mean = newMean;\n-    }\n-\n-    /**\n      * Access the mean.\n+     *\n      * @return the mean.\n      */\n     public double getMean() {\n     /**\n      * Return the probability density for a particular point.\n      *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @deprecated - use density(double)\n-     */\n-    public double density(Double x) {\n-        return density(x.doubleValue());\n-    }\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n+     * @param x Point at which the density should be computed.\n+     * @return the pdf at point {@code x}.\n      * @since 2.1\n      */\n     @Override\n      * </ul>\n      *\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF for this distribution.\n+     * @return the CDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     */\n-    public double cumulativeProbability(double x) throws MathException{\n+     * computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n         double ret;\n         if (x <= 0.0) {\n             ret = 0.0;\n \n     /**\n      * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     * that {@code P(X < x) = p}.\n+     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.\n      *\n      * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n      * @throws MathException if the inverse cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if p < 0 or p > 1.\n+     * computed due to convergence or other numerical errors.\n+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.\n      */\n     @Override\n     public double inverseCumulativeProbability(double p) throws MathException {\n         double ret;\n \n         if (p < 0.0 || p > 1.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n+            throw new OutOfRangeException(p, 0.0, 1.0);\n         } else if (p == 1.0) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n      * <p><strong>Algorithm Description</strong>: Uses the <a\n      * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n      * Method</a> to generate exponentially distributed random values from\n-     * uniform deviates. </p>\n-     *\n-     * @return random value\n+     * uniform deviates.</p>\n+     *\n+     * @return a random value.\n+     * @throws MathException if an error occurs generating the random value.\n      * @since 2.2\n-     * @throws MathException if an error occurs generating the random value\n      */\n     @Override\n     public double sample() throws MathException {\n     }\n \n     /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * Access the domain value lower bound, based on {@code p}, used to\n      * bracket a CDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n         // NOTE: exponential is skewed to the left\n         // NOTE: therefore, P(X < &mu;) > .5\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             // use mean\n             return mean;\n         } else {\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n         // TODO: what should really happen here is not derive from AbstractContinuousDistribution\n         // TODO: because the inverse cumulative distribution is simple.\n         // Exponential is skewed to the left, therefore, P(X < &mu;) > .5\n-        if (p < .5) {\n+        if (p < 0.5) {\n             // use 1/2 mean\n-            return mean * .5;\n+            return mean * 0.5;\n         } else {\n             // use mean\n             return mean;\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n      *\n-     * @return the solver absolute accuracy\n+     * @return the solver absolute accuracy.\n      * @since 2.1\n      */\n     @Override\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Test cases for ExponentialDistribution.\n     public void testMeanAccessors() {\n         ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();\n         assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);\n-        distribution.setMean(2d);\n-        assertEquals(2d, distribution.getMean(), Double.MIN_VALUE);\n+    }\n+\n+    public void testPreconditions() {\n         try {\n-            distribution.setMean(0);\n-            fail(\"Expecting IllegalArgumentException for 0 mean\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n+            ExponentialDistribution distribution = new ExponentialDistributionImpl(0);\n+        } catch (NotStrictlyPositiveException e) {\n+            // Expected.\n         }\n     }\n-\n }", "timestamp": 1285589902, "metainfo": ""}