{"sha": "370a7835419930860cb1708e4653647c04b6512b", "log": "MATH-430 Removed redundant \"mapXxx\" methods. Upgraded tests to Junit4 (MATH-423). Some test used \"assertEquals\" without a tolerance (strict equality between floating point numbers); this failed with Junit4.    ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Ceil.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * {@code ceil} function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class Ceil implements UnivariateRealFunction {\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return FastMath.ceil(x);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Floor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * {@code floor} function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class Floor implements UnivariateRealFunction {\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return FastMath.floor(x);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Rint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * {@code rint} function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class Rint implements UnivariateRealFunction {\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return FastMath.rint(x);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Signum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * {@code signum} function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class Signum implements UnivariateRealFunction {\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return FastMath.signum(x);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Ulp.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * {@code ulp} function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class Ulp implements UnivariateRealFunction {\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return FastMath.ulp(x);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.analysis.BinaryFunction;\n-import org.apache.commons.math.analysis.ComposableFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n         return maxIndex < 0 ? Double.NaN : getEntry(maxIndex);\n     }\n \n-    /** {@inheritDoc} */\n-    public RealVector mapAbs() {\n-        return copy().mapAbsToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapAbsToSelf() {\n-        return mapToSelf(ComposableFunction.ABS);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapAcos() {\n-        return copy().mapAcosToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapAcosToSelf() {\n-        return mapToSelf(ComposableFunction.ACOS);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapAsin() {\n-        return copy().mapAsinToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapAsinToSelf() {\n-        return mapToSelf(ComposableFunction.ASIN);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapAtan() {\n-        return copy().mapAtanToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapAtanToSelf() {\n-        return mapToSelf(ComposableFunction.ATAN);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCbrt() {\n-        return copy().mapCbrtToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCbrtToSelf() {\n-        return mapToSelf(ComposableFunction.CBRT);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCeil() {\n-        return copy().mapCeilToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCeilToSelf() {\n-        return mapToSelf(ComposableFunction.CEIL);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCos() {\n-        return copy().mapCosToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCosToSelf() {\n-        return mapToSelf(ComposableFunction.COS);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCosh() {\n-        return copy().mapCoshToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapCoshToSelf() {\n-        return mapToSelf(ComposableFunction.COSH);\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiplyToSelf(double d){\n+        return mapToSelf(BinaryFunction.MULTIPLY.fix1stArgument(d));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        return copy().mapSubtractToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtractToSelf(double d){\n+        return mapAddToSelf(-d);\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector mapExp() {\n-        return copy().mapExpToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapExpToSelf() {\n-        return mapToSelf(ComposableFunction.EXP);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapExpm1() {\n-        return copy().mapExpm1ToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapExpm1ToSelf() {\n-        return mapToSelf(ComposableFunction.EXPM1);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapFloor() {\n-        return copy().mapFloorToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapFloorToSelf() {\n-        return mapToSelf(ComposableFunction.FLOOR);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapInv() {\n-        return copy().mapInvToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapInvToSelf() {\n-        return mapToSelf(ComposableFunction.INVERT);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapLog() {\n-        return copy().mapLogToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapLogToSelf() {\n-        return mapToSelf(ComposableFunction.LOG);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapLog10() {\n-        return copy().mapLog10ToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapLog10ToSelf() {\n-        return mapToSelf(ComposableFunction.LOG10);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapLog1p() {\n-        return copy().mapLog1pToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapLog1pToSelf() {\n-        return mapToSelf(ComposableFunction.LOG1P);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapMultiply(double d) {\n-        return copy().mapMultiplyToSelf(d);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapMultiplyToSelf(double d){\n-        return mapToSelf(BinaryFunction.MULTIPLY.fix1stArgument(d));\n-    }\n-\n-    /** {@inheritDoc} */\n     public RealVector mapPow(double d) {\n         return copy().mapPowToSelf(d);\n     }\n     /** {@inheritDoc} */\n     public RealVector mapPowToSelf(double d){\n         return mapToSelf(BinaryFunction.POW.fix2ndArgument(d));\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapRint() {\n-        return copy().mapRintToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapRintToSelf() {\n-        return mapToSelf(ComposableFunction.RINT);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSignum() {\n-        return copy().mapSignumToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSignumToSelf() {\n-        return mapToSelf(ComposableFunction.SIGNUM);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSin() {\n-        return copy().mapSinToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSinToSelf() {\n-        return mapToSelf(ComposableFunction.SIN);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSinh() {\n-        return copy().mapSinhToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSinhToSelf() {\n-        return mapToSelf(ComposableFunction.SINH);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSqrt() {\n-        return copy().mapSqrtToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSqrtToSelf() {\n-        return mapToSelf(ComposableFunction.SQRT);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSubtract(double d) {\n-        return copy().mapSubtractToSelf(d);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapSubtractToSelf(double d){\n-        return mapAddToSelf(-d);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapTan() {\n-        return copy().mapTanToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapTanToSelf() {\n-        return mapToSelf(ComposableFunction.TAN);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapTanh() {\n-        return copy().mapTanhToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapTanhToSelf() {\n-        return mapToSelf(ComposableFunction.TANH);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapUlp() {\n-        return copy().mapUlpToSelf();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector mapUlpToSelf() {\n-        return mapToSelf(ComposableFunction.ULP);\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector map(UnivariateRealFunction function) {\n         return copy().mapToSelf(function);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapToSelf(UnivariateRealFunction function) {\n         Iterator<Entry> it = (function.value(0) == 0) ? sparseIterator() : iterator();\n         Entry e;\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n import java.util.Arrays;\n import java.util.Iterator;\n \n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n \n     /** {@inheritDoc} */\n     @Override\n-    public AbstractRealVector copy() {\n+    public ArrayRealVector copy() {\n         return new ArrayRealVector(this, true);\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n+    public ArrayRealVector map(UnivariateRealFunction function) {\n+        return copy().mapToSelf(function);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public ArrayRealVector mapToSelf(UnivariateRealFunction function) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = function.value(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n     public RealVector mapAddToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] + d;\n     public RealVector mapDivideToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] / d;\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapPowToSelf(double d) {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.pow(data[i], d);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapExpToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.exp(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapExpm1ToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.expm1(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapLogToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.log(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapLog10ToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.log10(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapLog1pToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.log1p(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapCoshToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.cosh(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapSinhToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.sinh(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapTanhToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.tanh(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapCosToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.cos(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapSinToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.sin(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapTanToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.tan(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapAcosToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.acos(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapAsinToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.asin(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapAtanToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.atan(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapInvToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = 1.0 / data[i];\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapAbsToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.abs(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapSqrtToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.sqrt(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapCbrtToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.cbrt(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapCeilToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.ceil(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapFloorToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.floor(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapRintToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.rint(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapSignumToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.signum(data[i]);\n-        }\n-        return this;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector mapUlpToSelf() {\n-        for (int i = 0; i < data.length; i++) {\n-            data[i] = FastMath.ulp(data[i]);\n         }\n         return this;\n     }\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n     RealVector mapPowToSelf(double d);\n \n     /**\n-     * Map the {@link Math#exp(double)} function to each entry.\n-     *\n-     * @return a mapped copy of the vector.\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapExp();\n-\n-    /**\n-     * Map {@link Math#exp(double)} operation to each entry.\n-     * The instance is changed in-place.\n-     *\n-     * @return the mapped vector.\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapExpToSelf();\n-\n-    /**\n-     * Map the {@link Math#expm1(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapExpm1();\n-\n-    /**\n-     * Map the {@link Math#expm1(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapExpm1ToSelf();\n-\n-    /**\n-     * Map the {@link Math#log(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapLog();\n-\n-    /**\n-     * Map the {@link Math#log(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapLogToSelf();\n-\n-    /**\n-     * Map the {@link Math#log10(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapLog10();\n-\n-    /**\n-     * Map the {@link Math#log10(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapLog10ToSelf();\n-\n-    /**\n-     * Map the {@link Math#log1p(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapLog1p();\n-\n-    /**\n-     * Map the {@link Math#log1p(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapLog1pToSelf();\n-\n-    /**\n-     * Map the {@link Math#cosh(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCosh();\n-\n-    /**\n-     * Map the {@link Math#cosh(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCoshToSelf();\n-\n-    /**\n-     * Map the {@link Math#sinh(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSinh();\n-\n-    /**\n-     * Map the {@link Math#sinh(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSinhToSelf();\n-\n-    /**\n-     * Map the {@link Math#tanh(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapTanh();\n-\n-    /**\n-     * Map the {@link Math#tanh(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapTanhToSelf();\n-\n-    /**\n-     * Map the {@link Math#cos(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCos();\n-\n-    /**\n-     * Map the {@link Math#cos(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCosToSelf();\n-\n-    /**\n-     * Map the {@link Math#sin(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSin();\n-\n-    /**\n-     * Map the {@link Math#sin(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSinToSelf();\n-\n-    /**\n-     * Map the {@link Math#tan(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapTan();\n-\n-    /**\n-     * Map the {@link Math#tan(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapTanToSelf();\n-\n-    /**\n-     * Map the {@link Math#acos(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAcos();\n-\n-    /**\n-     * Map the {@link Math#acos(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAcosToSelf();\n-\n-    /**\n-     * Map the {@link Math#asin(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAsin();\n-\n-    /**\n-     * Map the {@link Math#asin(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAsinToSelf();\n-\n-    /**\n-     * Map the {@link Math#atan(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAtan();\n-\n-    /**\n-     * Map the {@link Math#atan(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAtanToSelf();\n-\n-    /**\n-     * Map the 1/x function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapInv();\n-\n-    /**\n-     * Map the 1/x function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapInvToSelf();\n-\n-    /**\n-     * Map the {@link Math#abs(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAbs();\n-\n-    /**\n-     * Map the {@link Math#abs(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapAbsToSelf();\n-\n-    /**\n-     * Map the {@link Math#sqrt(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSqrt();\n-\n-    /**\n-     * Map the {@link Math#sqrt(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSqrtToSelf();\n-\n-    /**\n-     * Map the {@link Math#cbrt(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCbrt();\n-\n-    /**\n-     * Map the {@link Math#cbrt(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCbrtToSelf();\n-\n-    /**\n-     * Map the {@link Math#ceil(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCeil();\n-\n-    /**\n-     * Map the {@link Math#ceil(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapCeilToSelf();\n-\n-    /**\n-     * Map the {@link Math#floor(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapFloor();\n-\n-    /**\n-     * Map the {@link Math#floor(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapFloorToSelf();\n-\n-    /**\n-     * Map the {@link Math#rint(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapRint();\n-\n-    /**\n-     * Map the {@link Math#rint(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapRintToSelf();\n-\n-    /**\n-     * Map the {@link Math#signum(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSignum();\n-\n-    /**\n-     * Map the {@link Math#signum(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapSignumToSelf();\n-\n-    /**\n-     * Map the {@link Math#ulp(double)} function to each entry.\n-     * @return a vector containing the result of applying the function to each entry\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #map(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapUlp();\n-\n-    /**\n-     * Map the {@link Math#ulp(double)} function to each entry.\n-     * <p>The instance <strong>is</strong> changed by this method.</p>\n-     * @return for convenience, return this\n-     * @deprecated in 2.2 (to be removed in 3.0). Please use\n-     * {@link #mapToSelf(UnivariateRealFunction)} directly with\n-     * the function classes in package\n-     * {@link org.apache.commons.math.analysis.function}.\n-     */\n-    RealVector mapUlpToSelf();\n-\n-    /**\n      * Element-by-element multiplication.\n      * @param v vector by which instance elements must be multiplied\n      * @return a vector containing this[i] * v[i] for all i\n--- a/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n \n package org.apache.commons.math.linear;\n \n-import junit.framework.TestCase;\n+import org.junit.Test;\n+import org.junit.Assert;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.linear.RealVector.Entry;\n import org.apache.commons.math.util.FastMath;\n /**\n  *\n  */\n-public class AbstractRealVectorTest extends TestCase {\n+public class AbstractRealVectorTest {\n     private double[] vec1 = { 1d, 2d, 3d, 4d, 5d };\n     private double[] vec2 = { -3d, 0d, 0d, 2d, 1d };\n \n             return this;\n         }\n \n-        @Override\n-        public RealVector mapInvToSelf() {\n-            for(int i=0; i<values.length; i++) {\n-                values[i] = 1/values[i];\n-            }\n-            return this;\n-        }\n \n         public RealVector ebeMultiply(RealVector v) {\n             throw unsupported();\n     }\n \n     private static void assertEquals(double[] d1, double[] d2) {\n-        assertEquals(d1.length, d2.length);\n-        for(int i=0; i<d1.length; i++) assertEquals(d1[i], d2[i]);\n-    }\n-\n+        Assert.assertEquals(d1.length, d2.length);\n+        for(int i=0; i<d1.length; i++) Assert.assertEquals(d1[i], d2[i], 0);\n+    }\n+\n+    @Test\n     public void testMap() throws Exception {\n         double[] vec1Squared = { 1d, 4d, 9d, 16d, 25d };\n         RealVector v = new TestVectorImpl(vec1.clone());\n         assertEquals(vec1Squared, w.getData());\n     }\n \n+    @Test\n     public void testIterator() throws Exception {\n         RealVector v = new TestVectorImpl(vec2.clone());\n         Entry e;\n         int i = 0;\n         for(Iterator<Entry> it = v.iterator(); it.hasNext() && (e = it.next()) != null; i++) {\n-            assertEquals(vec2[i], e.getValue());\n-        }\n-    }\n-\n+            Assert.assertEquals(vec2[i], e.getValue(), 0);\n+        }\n+    }\n+\n+    @Test\n     public void testSparseIterator() throws Exception {\n         RealVector v = new TestVectorImpl(vec2.clone());\n         Entry e;\n         int i = 0;\n         double[] nonDefaultV2 = { -3d, 2d, 1d };\n         for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; i++) {\n-            assertEquals(nonDefaultV2[i], e.getValue());\n+            Assert.assertEquals(nonDefaultV2[i], e.getValue(), 0);\n         }\n         double [] onlyOne = {0d, 1.0, 0d};\n         v = new TestVectorImpl(onlyOne);\n         for(Iterator<Entry> it = v.sparseIterator(); it.hasNext() && (e = it.next()) != null; ) {\n-            assertEquals(onlyOne[1], e.getValue());\n+            Assert.assertEquals(onlyOne[1], e.getValue(), 0);\n         }\n         \n     }\n \n+    @Test\n     public void testClone() throws Exception {\n         double[] d = new double[1000000];\n         Random r = new Random(1234);\n         for(int i=0;i<d.length; i++) d[i] = r.nextDouble();\n-        assertTrue(new ArrayRealVector(d).getNorm() > 0);\n+        Assert.assertTrue(new ArrayRealVector(d).getNorm() > 0);\n         double[] c = d.clone();\n         c[0] = 1;\n-        assertNotSame(c[0], d[0]);\n+        Assert.assertNotSame(c[0], d[0]);\n         d[0] = 1;\n-        assertEquals(new ArrayRealVector(d).getNorm(), new ArrayRealVector(c).getNorm());\n+        Assert.assertEquals(new ArrayRealVector(d).getNorm(), new ArrayRealVector(c).getNorm(), 0);\n         long cloneTime = 0;\n         long setAndAddTime = 0;\n         for(int i=0; i<10; i++) {\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n \n import java.io.Serializable;\n import java.util.Iterator;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.analysis.function.Abs;\n+import org.apache.commons.math.analysis.function.Acosh;\n+import org.apache.commons.math.analysis.function.Acos;\n+import org.apache.commons.math.analysis.function.Asinh;\n+import org.apache.commons.math.analysis.function.Asin;\n+import org.apache.commons.math.analysis.function.Atanh;\n+import org.apache.commons.math.analysis.function.Atan;\n+import org.apache.commons.math.analysis.function.Cbrt;\n+import org.apache.commons.math.analysis.function.Cosh;\n+import org.apache.commons.math.analysis.function.Cos;\n+import org.apache.commons.math.analysis.function.Exp;\n+import org.apache.commons.math.analysis.function.Expm1;\n+import org.apache.commons.math.analysis.function.Inverse;\n+import org.apache.commons.math.analysis.function.Log10;\n+import org.apache.commons.math.analysis.function.Log1p;\n+import org.apache.commons.math.analysis.function.Log;\n+import org.apache.commons.math.analysis.function.Pow;\n+import org.apache.commons.math.analysis.function.Sinh;\n+import org.apache.commons.math.analysis.function.Sin;\n+import org.apache.commons.math.analysis.function.Sqrt;\n+import org.apache.commons.math.analysis.function.Tanh;\n+import org.apache.commons.math.analysis.function.Tan;\n+import org.apache.commons.math.analysis.function.Floor;\n+import org.apache.commons.math.analysis.function.Ceil;\n+import org.apache.commons.math.analysis.function.Rint;\n+import org.apache.commons.math.analysis.function.Signum;\n+import org.apache.commons.math.analysis.function.Ulp;\n \n /**\n  * Test cases for the {@link ArrayRealVector} class.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class ArrayRealVectorTest extends TestCase {\n+public class ArrayRealVectorTest {\n \n     //\n     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n             throw unsupported();\n         }\n \n-        public RealVector mapExp() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapExpToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapExpm1() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapExpm1ToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapLog() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapLogToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapLog10() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapLog10ToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapLog1p() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapLog1pToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCosh() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCoshToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSinh() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSinhToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapTanh() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapTanhToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCos() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCosToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSin() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSinToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapTan() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapTanToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAcos() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAcosToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAsin() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAsinToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAtan() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAtanToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapInv() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapInvToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAbs() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapAbsToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSqrt() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSqrtToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCbrt() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCbrtToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCeil() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapCeilToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapFloor() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapFloorToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapRint() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapRintToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSignum() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapSignumToSelf() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapUlp() {\n-            throw unsupported();\n-        }\n-\n-        public RealVector mapUlpToSelf() {\n-            throw unsupported();\n-        }\n-\n         public RealVector ebeMultiply(RealVector v) {\n             throw unsupported();\n         }\n \n     }\n \n+    @Test\n     public void testConstructors() {\n \n         ArrayRealVector v0 = new ArrayRealVector();\n-        assertEquals(\"testData len\", 0, v0.getDimension());\n+        Assert.assertEquals(\"testData len\", 0, v0.getDimension());\n \n         ArrayRealVector v1 = new ArrayRealVector(7);\n-        assertEquals(\"testData len\", 7, v1.getDimension());\n-        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+        Assert.assertEquals(\"testData len\", 7, v1.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6), 0);\n \n         ArrayRealVector v2 = new ArrayRealVector(5, 1.23);\n-        assertEquals(\"testData len\", 5, v2.getDimension());\n-        assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4));\n+        Assert.assertEquals(\"testData len\", 5, v2.getDimension());\n+        Assert.assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4), 0);\n \n         ArrayRealVector v3 = new ArrayRealVector(vec1);\n-        assertEquals(\"testData len\", 3, v3.getDimension());\n-        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+        Assert.assertEquals(\"testData len\", 3, v3.getDimension());\n+        Assert.assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1), 0);\n \n         ArrayRealVector v3_bis = new ArrayRealVector(vec1, true);\n-        assertEquals(\"testData len\", 3, v3_bis.getDimension());\n-        assertEquals(\"testData is 2.0 \", 2.0, v3_bis.getEntry(1));\n-        assertNotSame(v3_bis.getDataRef(), vec1);\n-        assertNotSame(v3_bis.getData(), vec1);\n+        Assert.assertEquals(\"testData len\", 3, v3_bis.getDimension());\n+        Assert.assertEquals(\"testData is 2.0 \", 2.0, v3_bis.getEntry(1), 0);\n+        Assert.assertNotSame(v3_bis.getDataRef(), vec1);\n+        Assert.assertNotSame(v3_bis.getData(), vec1);\n \n         ArrayRealVector v3_ter = new ArrayRealVector(vec1, false);\n-        assertEquals(\"testData len\", 3, v3_ter.getDimension());\n-        assertEquals(\"testData is 2.0 \", 2.0, v3_ter.getEntry(1));\n-        assertSame(v3_ter.getDataRef(), vec1);\n-        assertNotSame(v3_ter.getData(), vec1);\n+        Assert.assertEquals(\"testData len\", 3, v3_ter.getDimension());\n+        Assert.assertEquals(\"testData is 2.0 \", 2.0, v3_ter.getEntry(1), 0);\n+        Assert.assertSame(v3_ter.getDataRef(), vec1);\n+        Assert.assertNotSame(v3_ter.getData(), vec1);\n \n         ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2);\n-        assertEquals(\"testData len\", 2, v4.getDimension());\n-        assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        Assert.assertEquals(\"testData len\", 2, v4.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0), 0);\n         try {\n             new ArrayRealVector(vec4, 8, 3);\n-            fail(\"IllegalArgumentException expected\");\n+            Assert.fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         RealVector v5_i = new ArrayRealVector(dvec1);\n-        assertEquals(\"testData len\", 9, v5_i.getDimension());\n-        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+        Assert.assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        Assert.assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8), 0);\n \n         ArrayRealVector v5 = new ArrayRealVector(dvec1);\n-        assertEquals(\"testData len\", 9, v5.getDimension());\n-        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+        Assert.assertEquals(\"testData len\", 9, v5.getDimension());\n+        Assert.assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8), 0);\n \n         ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2);\n-        assertEquals(\"testData len\", 2, v6.getDimension());\n-        assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0));\n+        Assert.assertEquals(\"testData len\", 2, v6.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0), 0);\n         try {\n             new ArrayRealVector(dvec1, 8, 3);\n-            fail(\"IllegalArgumentException expected\");\n+            Assert.fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         ArrayRealVector v7 = new ArrayRealVector(v1);\n-        assertEquals(\"testData len\", 7, v7.getDimension());\n-        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+        Assert.assertEquals(\"testData len\", 7, v7.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6), 0);\n \n         RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);\n \n         ArrayRealVector v7_2 = new ArrayRealVector(v7_i);\n-        assertEquals(\"testData len\", 3, v7_2.getDimension());\n-        assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+        Assert.assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1), 0);\n \n         ArrayRealVector v8 = new ArrayRealVector(v1, true);\n-        assertEquals(\"testData len\", 7, v8.getDimension());\n-        assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n-        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+        Assert.assertEquals(\"testData len\", 7, v8.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6), 0);\n+        Assert.assertNotSame(\"testData not same object \", v1.data, v8.data);\n \n         ArrayRealVector v8_2 = new ArrayRealVector(v1, false);\n-        assertEquals(\"testData len\", 7, v8_2.getDimension());\n-        assertEquals(\"testData is 0.0 \", 0.0, v8_2.getEntry(6));\n-        assertEquals(\"testData same object \", v1.data, v8_2.data);\n+        Assert.assertEquals(\"testData len\", 7, v8_2.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 0.0, v8_2.getEntry(6), 0);\n+        Assert.assertEquals(\"testData same object \", v1.data, v8_2.data);\n \n         ArrayRealVector v9 = new ArrayRealVector(v1, v3);\n-        assertEquals(\"testData len\", 10, v9.getDimension());\n-        assertEquals(\"testData is 1.0 \", 1.0, v9.getEntry(7));\n+        Assert.assertEquals(\"testData len\", 10, v9.getDimension());\n+        Assert.assertEquals(\"testData is 1.0 \", 1.0, v9.getEntry(7), 0);\n \n         ArrayRealVector v10 = new ArrayRealVector(v2, new RealVectorTestImpl(vec3));\n-        assertEquals(\"testData len\", 8, v10.getDimension());\n-        assertEquals(\"testData is 1.23 \", 1.23, v10.getEntry(4));\n-        assertEquals(\"testData is 7.0 \", 7.0, v10.getEntry(5));\n+        Assert.assertEquals(\"testData len\", 8, v10.getDimension());\n+        Assert.assertEquals(\"testData is 1.23 \", 1.23, v10.getEntry(4), 0);\n+        Assert.assertEquals(\"testData is 7.0 \", 7.0, v10.getEntry(5), 0);\n \n         ArrayRealVector v11 = new ArrayRealVector(new RealVectorTestImpl(vec3), v2);\n-        assertEquals(\"testData len\", 8, v11.getDimension());\n-        assertEquals(\"testData is 9.0 \", 9.0, v11.getEntry(2));\n-        assertEquals(\"testData is 1.23 \", 1.23, v11.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 8, v11.getDimension());\n+        Assert.assertEquals(\"testData is 9.0 \", 9.0, v11.getEntry(2), 0);\n+        Assert.assertEquals(\"testData is 1.23 \", 1.23, v11.getEntry(3), 0);\n \n         ArrayRealVector v12 = new ArrayRealVector(v2, vec3);\n-        assertEquals(\"testData len\", 8, v12.getDimension());\n-        assertEquals(\"testData is 1.23 \", 1.23, v12.getEntry(4));\n-        assertEquals(\"testData is 7.0 \", 7.0, v12.getEntry(5));\n+        Assert.assertEquals(\"testData len\", 8, v12.getDimension());\n+        Assert.assertEquals(\"testData is 1.23 \", 1.23, v12.getEntry(4), 0);\n+        Assert.assertEquals(\"testData is 7.0 \", 7.0, v12.getEntry(5), 0);\n \n         ArrayRealVector v13 = new ArrayRealVector(vec3, v2);\n-        assertEquals(\"testData len\", 8, v13.getDimension());\n-        assertEquals(\"testData is 9.0 \", 9.0, v13.getEntry(2));\n-        assertEquals(\"testData is 1.23 \", 1.23, v13.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 8, v13.getDimension());\n+        Assert.assertEquals(\"testData is 9.0 \", 9.0, v13.getEntry(2), 0);\n+        Assert.assertEquals(\"testData is 1.23 \", 1.23, v13.getEntry(3), 0);\n \n         ArrayRealVector v14 = new ArrayRealVector(vec3, vec4);\n-        assertEquals(\"testData len\", 12, v14.getDimension());\n-        assertEquals(\"testData is 9.0 \", 9.0, v14.getEntry(2));\n-        assertEquals(\"testData is 1.0 \", 1.0, v14.getEntry(3));\n-\n-   }\n-\n+        Assert.assertEquals(\"testData len\", 12, v14.getDimension());\n+        Assert.assertEquals(\"testData is 9.0 \", 9.0, v14.getEntry(2), 0);\n+        Assert.assertEquals(\"testData is 1.0 \", 1.0, v14.getEntry(3), 0);\n+\n+    }\n+\n+    @Test\n     public void testDataInOut() {\n \n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n         RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n \n         RealVector v_append_1 = v1.append(v2);\n-        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n-        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3), 0);\n \n         RealVector v_append_2 = v1.append(2.0);\n-        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n-        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        Assert.assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3), 0);\n \n         RealVector v_append_3 = v1.append(vec2);\n-        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n-        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        Assert.assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3), 0);\n \n         RealVector v_append_4 = v1.append(v2_t);\n-        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n-        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3), 0);\n \n         RealVector v_append_5 = v1.append((RealVector) v2);\n-        assertEquals(\"testData len\", 6, v_append_5.getDimension());\n-        assertEquals(\"testData is 4.0 \", 4.0, v_append_5.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 6, v_append_5.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 4.0, v_append_5.getEntry(3), 0);\n \n         RealVector v_copy = v1.copy();\n-        assertEquals(\"testData len\", 3, v_copy.getDimension());\n-        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+        Assert.assertEquals(\"testData len\", 3, v_copy.getDimension());\n+        Assert.assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n \n         double[] a_double = v1.toArray();\n-        assertEquals(\"testData len\", 3, a_double.length);\n-        assertNotSame(\"testData not same object \", v1.data, a_double);\n+        Assert.assertEquals(\"testData len\", 3, a_double.length);\n+        Assert.assertNotSame(\"testData not same object \", v1.data, a_double);\n \n \n //      ArrayRealVector vout4 = (ArrayRealVector) v1.clone();\n-//      assertEquals(\"testData len\", 3, vout4.getDimension());\n-//      assertEquals(\"testData not same object \", v1.data, vout4.data);\n+//      Assert.assertEquals(\"testData len\", 3, vout4.getDimension());\n+//      Assert.assertEquals(\"testData not same object \", v1.data, vout4.data);\n \n \n         RealVector vout5 = v4.getSubVector(3, 3);\n-        assertEquals(\"testData len\", 3, vout5.getDimension());\n-        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        Assert.assertEquals(\"testData len\", 3, vout5.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1), 0);\n         try {\n             v4.getSubVector(3, 7);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayRealVector v_set1 = (ArrayRealVector) v1.copy();\n         v_set1.setEntry(1, 11.0);\n-        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        Assert.assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1), 0);\n         try {\n             v_set1.setEntry(3, 11.0);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayRealVector v_set2 = (ArrayRealVector) v4.copy();\n         v_set2.set(3, v1);\n-        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n-        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        Assert.assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3), 0);\n+        Assert.assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6), 0);\n         try {\n             v_set2.set(7, v1);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayRealVector v_set3 = (ArrayRealVector) v1.copy();\n         v_set3.set(13.0);\n-        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+        Assert.assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2), 0);\n \n         try {\n             v_set3.getEntry(23);\n-            fail(\"ArrayIndexOutOfBoundsException expected\");\n+            Assert.fail(\"ArrayIndexOutOfBoundsException expected\");\n         } catch (ArrayIndexOutOfBoundsException ex) {\n             // expected behavior\n         }\n \n         ArrayRealVector v_set4 = (ArrayRealVector) v4.copy();\n         v_set4.setSubVector(3, v2_t);\n-        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n-        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        Assert.assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3), 0);\n+        Assert.assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6), 0);\n         try {\n             v_set4.setSubVector(7, v2_t);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         ArrayRealVector vout10 = (ArrayRealVector) v1.copy();\n         ArrayRealVector vout10_2 = (ArrayRealVector) v1.copy();\n-        assertEquals(vout10, vout10_2);\n+        Assert.assertEquals(vout10, vout10_2);\n         vout10_2.setEntry(0, 1.1);\n-        assertNotSame(vout10, vout10_2);\n+        Assert.assertNotSame(vout10, vout10_2);\n \n     }\n \n+    @Test\n     public void testMapFunctions() {\n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n \n         assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n \n         //octave =  exp(v1)\n-        RealVector v_mapExp = v1.mapExp();\n+        RealVector v_mapExp = v1.map(new Exp());\n         double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n         assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n \n         //octave =  exp(v1)\n         RealVector v_mapExpToSelf = v1.copy();\n-        v_mapExpToSelf.mapExpToSelf();\n+        v_mapExpToSelf.mapToSelf(new Exp());\n         double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n         assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n \n \n         //octave =  ???\n-        RealVector v_mapExpm1 = v1.mapExpm1();\n+        RealVector v_mapExpm1 = v1.map(new Expm1());\n         double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n         assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n \n         //octave =  ???\n         RealVector v_mapExpm1ToSelf = v1.copy();\n-        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        v_mapExpm1ToSelf.mapToSelf(new Expm1());\n         double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n         assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n \n         //octave =  log(v1)\n-        RealVector v_mapLog = v1.mapLog();\n+        RealVector v_mapLog = v1.map(new Log());\n         double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n         assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n \n         //octave =  log(v1)\n         RealVector v_mapLogToSelf = v1.copy();\n-        v_mapLogToSelf.mapLogToSelf();\n+        v_mapLogToSelf.mapToSelf(new Log());\n         double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n         assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n \n         //octave =  log10(v1)\n-        RealVector v_mapLog10 = v1.mapLog10();\n+        RealVector v_mapLog10 = v1.map(new Log10());\n         double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n         assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n \n         //octave =  log(v1)\n         RealVector v_mapLog10ToSelf = v1.copy();\n-        v_mapLog10ToSelf.mapLog10ToSelf();\n+        v_mapLog10ToSelf.mapToSelf(new Log10());\n         double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n         assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n \n         //octave =  ???\n-        RealVector v_mapLog1p = v1.mapLog1p();\n+        RealVector v_mapLog1p = v1.map(new Log1p());\n         double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n         assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n \n         //octave =  ???\n         RealVector v_mapLog1pToSelf = v1.copy();\n-        v_mapLog1pToSelf.mapLog1pToSelf();\n+        v_mapLog1pToSelf.mapToSelf(new Log1p());\n         double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n         assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n \n         //octave =  cosh(v1)\n-        RealVector v_mapCosh = v1.mapCosh();\n+        RealVector v_mapCosh = v1.map(new Cosh());\n         double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n         assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n \n         //octave =  cosh(v1)\n         RealVector v_mapCoshToSelf = v1.copy();\n-        v_mapCoshToSelf.mapCoshToSelf();\n+        v_mapCoshToSelf.mapToSelf(new Cosh());\n         double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n         assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n \n         //octave =  sinh(v1)\n-        RealVector v_mapSinh = v1.mapSinh();\n+        RealVector v_mapSinh = v1.map(new Sinh());\n         double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n         assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n \n         //octave =  sinh(v1)\n         RealVector v_mapSinhToSelf = v1.copy();\n-        v_mapSinhToSelf.mapSinhToSelf();\n+        v_mapSinhToSelf.mapToSelf(new Sinh());\n         double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n         assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n \n         //octave =  tanh(v1)\n-        RealVector v_mapTanh = v1.mapTanh();\n+        RealVector v_mapTanh = v1.map(new Tanh());\n         double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n         assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n \n         //octave =  tanh(v1)\n         RealVector v_mapTanhToSelf = v1.copy();\n-        v_mapTanhToSelf.mapTanhToSelf();\n+        v_mapTanhToSelf.mapToSelf(new Tanh());\n         double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n         assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n \n         //octave =  cos(v1)\n-        RealVector v_mapCos = v1.mapCos();\n+        RealVector v_mapCos = v1.map(new Cos());\n         double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n         assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n \n         //octave =  cos(v1)\n         RealVector v_mapCosToSelf = v1.copy();\n-        v_mapCosToSelf.mapCosToSelf();\n+        v_mapCosToSelf.mapToSelf(new Cos());\n         double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n         assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n \n         //octave =  sin(v1)\n-        RealVector v_mapSin = v1.mapSin();\n+        RealVector v_mapSin = v1.map(new Sin());\n         double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n         assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n \n         //octave =  sin(v1)\n         RealVector v_mapSinToSelf = v1.copy();\n-        v_mapSinToSelf.mapSinToSelf();\n+        v_mapSinToSelf.mapToSelf(new Sin());\n         double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n         assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n \n         //octave =  tan(v1)\n-        RealVector v_mapTan = v1.mapTan();\n+        RealVector v_mapTan = v1.map(new Tan());\n         double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n         assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n \n         //octave =  tan(v1)\n         RealVector v_mapTanToSelf = v1.copy();\n-        v_mapTanToSelf.mapTanToSelf();\n+        v_mapTanToSelf.mapToSelf(new Tan());\n         double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n         assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n \n         ArrayRealVector vat = new ArrayRealVector(vat_a);\n \n         //octave =  acos(vat)\n-        RealVector v_mapAcos = vat.mapAcos();\n+        RealVector v_mapAcos = vat.map(new Acos());\n         double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n         assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n \n         //octave =  acos(vat)\n         RealVector v_mapAcosToSelf = vat.copy();\n-        v_mapAcosToSelf.mapAcosToSelf();\n+        v_mapAcosToSelf.mapToSelf(new Acos());\n         double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n         assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n \n         //octave =  asin(vat)\n-        RealVector v_mapAsin = vat.mapAsin();\n+        RealVector v_mapAsin = vat.map(new Asin());\n         double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n         assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n \n         //octave =  asin(vat)\n         RealVector v_mapAsinToSelf = vat.copy();\n-        v_mapAsinToSelf.mapAsinToSelf();\n+        v_mapAsinToSelf.mapToSelf(new Asin());\n         double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n         assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n \n         //octave =  atan(vat)\n-        RealVector v_mapAtan = vat.mapAtan();\n+        RealVector v_mapAtan = vat.map(new Atan());\n         double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n         assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n \n         //octave =  atan(vat)\n         RealVector v_mapAtanToSelf = vat.copy();\n-        v_mapAtanToSelf.mapAtanToSelf();\n+        v_mapAtanToSelf.mapToSelf(new Atan());\n         double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n         assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n \n         //octave =  v1 .^-1\n-        RealVector v_mapInv = v1.mapInv();\n+        RealVector v_mapInv = v1.map(new Inverse());\n         double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n         assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n \n         //octave =  v1 .^-1\n         RealVector v_mapInvToSelf = v1.copy();\n-        v_mapInvToSelf.mapInvToSelf();\n+        v_mapInvToSelf.mapToSelf(new Inverse());\n         double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n         assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n \n         ArrayRealVector abs_v = new ArrayRealVector(abs_a);\n \n         //octave =  abs(abs_v)\n-        RealVector v_mapAbs = abs_v.mapAbs();\n+        RealVector v_mapAbs = abs_v.map(new Abs());\n         double[] result_mapAbs = {1d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n \n         //octave = abs(abs_v)\n         RealVector v_mapAbsToSelf = abs_v.copy();\n-        v_mapAbsToSelf.mapAbsToSelf();\n+        v_mapAbsToSelf.mapToSelf(new Abs());\n         double[] result_mapAbsToSelf = {1d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n \n         //octave =   sqrt(v1)\n-        RealVector v_mapSqrt = v1.mapSqrt();\n+        RealVector v_mapSqrt = v1.map(new Sqrt());\n         double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n         assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n \n         //octave =  sqrt(v1)\n         RealVector v_mapSqrtToSelf = v1.copy();\n-        v_mapSqrtToSelf.mapSqrtToSelf();\n+        v_mapSqrtToSelf.mapToSelf(new Sqrt());\n         double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n         assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n \n         ArrayRealVector cbrt_v = new ArrayRealVector(cbrt_a);\n \n         //octave =  ???\n-        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        RealVector v_mapCbrt = cbrt_v.map(new Cbrt());\n         double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n         assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapCbrtToSelf = cbrt_v.copy();\n-        v_mapCbrtToSelf.mapCbrtToSelf();\n+        v_mapCbrtToSelf.mapToSelf(new Cbrt());\n         double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n         assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n \n         ArrayRealVector ceil_v = new ArrayRealVector(ceil_a);\n \n         //octave =  ceil(ceil_v)\n-        RealVector v_mapCeil = ceil_v.mapCeil();\n+        RealVector v_mapCeil = ceil_v.map(new Ceil());\n         double[] result_mapCeil = {-1d,1d,2d};\n         assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n \n         //octave = ceil(ceil_v)\n         RealVector v_mapCeilToSelf = ceil_v.copy();\n-        v_mapCeilToSelf.mapCeilToSelf();\n+        v_mapCeilToSelf.mapToSelf(new Ceil());\n         double[] result_mapCeilToSelf =  {-1d,1d,2d};\n         assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n \n         //octave =  floor(ceil_v)\n-        RealVector v_mapFloor = ceil_v.mapFloor();\n+        RealVector v_mapFloor = ceil_v.map(new Floor());\n         double[] result_mapFloor = {-2d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n \n         //octave = floor(ceil_v)\n         RealVector v_mapFloorToSelf = ceil_v.copy();\n-        v_mapFloorToSelf.mapFloorToSelf();\n+        v_mapFloorToSelf.mapToSelf(new Floor());\n         double[] result_mapFloorToSelf =  {-2d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n \n         //octave =  ???\n-        RealVector v_mapRint = ceil_v.mapRint();\n+        RealVector v_mapRint = ceil_v.map(new Rint());\n         double[] result_mapRint = {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapRintToSelf = ceil_v.copy();\n-        v_mapRintToSelf.mapRintToSelf();\n+        v_mapRintToSelf.mapToSelf(new Rint());\n         double[] result_mapRintToSelf =  {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n \n         //octave =  ???\n-        RealVector v_mapSignum = ceil_v.mapSignum();\n+        RealVector v_mapSignum = ceil_v.map(new Signum());\n         double[] result_mapSignum = {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapSignumToSelf = ceil_v.copy();\n-        v_mapSignumToSelf.mapSignumToSelf();\n+        v_mapSignumToSelf.mapToSelf(new Signum());\n         double[] result_mapSignumToSelf =  {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n \n \n         // Is with the used resolutions of limited value as test\n         //octave =  ???\n-        RealVector v_mapUlp = ceil_v.mapUlp();\n+        RealVector v_mapUlp = ceil_v.map(new Ulp());\n         double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n         assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapUlpToSelf = ceil_v.copy();\n-        v_mapUlpToSelf.mapUlpToSelf();\n+        v_mapUlpToSelf.mapToSelf(new Ulp());\n         double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n         assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n-\n     }\n \n+    @Test\n     public void testBasicFunctions() {\n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n         ArrayRealVector v2 = new ArrayRealVector(vec2);\n \n         // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n         double d_getNorm = v5.getNorm();\n-        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n+        Assert.assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm, normTolerance);\n \n         // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n         double d_getL1Norm = v5.getL1Norm();\n-        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n+        Assert.assertEquals(\"compare values  \", 17.0, d_getL1Norm, normTolerance);\n \n         // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n         double d_getLInfNorm = v5.getLInfNorm();\n-        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n+        Assert.assertEquals(\"compare values  \", 6.0, d_getLInfNorm, normTolerance);\n \n \n         //octave =  sqrt(sumsq(v1-v2))\n         double dist = v1.getDistance(v2);\n-        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+        Assert.assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist, normTolerance);\n \n         //octave =  sqrt(sumsq(v1-v2))\n         double dist_2 = v1.getDistance(v2_t);\n-        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+        Assert.assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2, normTolerance);\n \n         //octave =  sqrt(sumsq(v1-v2))\n         double dist_3 = v1.getDistance((RealVector) v2);\n-        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3 );\n+        Assert.assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3, normTolerance);\n \n         //octave =  ???\n         double d_getL1Distance = v1. getL1Distance(v2);\n-        assertEquals(\"compare values  \",9d, d_getL1Distance );\n-\n-        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n-        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n-\n-        double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);\n-        assertEquals(\"compare values  \",9d, d_getL1Distance_3 );\n+        Assert.assertEquals(\"compare values  \", 9d, d_getL1Distance, normTolerance);\n+\n+        double d_getL1Distance_2 = v1.getL1Distance(v2_t);\n+        Assert.assertEquals(\"compare values  \", 9d, d_getL1Distance_2, normTolerance);\n+\n+        double d_getL1Distance_3 = v1.getL1Distance((RealVector) v2);\n+        Assert.assertEquals(\"compare values  \", 9d, d_getL1Distance_3, normTolerance);\n \n         //octave =  ???\n-        double d_getLInfDistance = v1. getLInfDistance(v2);\n-        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+        double d_getLInfDistance = v1.getLInfDistance(v2);\n+        Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance, normTolerance);\n \n         double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n-        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+        Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance_2, normTolerance);\n \n         double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n-        assertEquals(\"compare values  \",3d, d_getLInfDistance_3 );\n+        Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance_3, normTolerance);\n \n         //octave =  v1 + v2\n         ArrayRealVector v_add = v1.add(v2);\n         double[] result_add = {5d, 7d, 9d};\n-        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n+        assertClose(\"compare vect\" ,v_add.getData(), result_add, normTolerance);\n \n         RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n         RealVector v_add_i = v1.add(vt2);\n \n         // octave  dot(v1,v2)\n         double dot =  v1.dotProduct(v2);\n-        assertEquals(\"compare val \",32d, dot);\n+        Assert.assertEquals(\"compare val \",32d, dot, normTolerance);\n \n         // octave  dot(v1,v2_t)\n         double dot_2 =  v1.dotProduct(v2_t);\n-        assertEquals(\"compare val \",32d, dot_2);\n+        Assert.assertEquals(\"compare val \",32d, dot_2, normTolerance);\n \n         RealMatrix m_outerProduct = v1.outerProduct(v2);\n-        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0), normTolerance);\n \n         RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n-        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0), normTolerance);\n \n         RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n-        assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0), normTolerance);\n \n         RealVector v_unitVector = v1.unitVector();\n         RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n \n         try {\n             v_null.unitVector();\n-            fail(\"Expecting ArithmeticException\");\n+            Assert.fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n             // expected behavior\n         }\n         assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n         try {\n             v_null.unitize();\n-            fail(\"Expecting ArithmeticException\");\n+            Assert.fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n             // expected behavior\n         }\n \n     }\n \n+    @Test\n     public void testMisc() {\n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n         ArrayRealVector v4 = new ArrayRealVector(vec4);\n         RealVector v4_2 = new ArrayRealVector(vec4);\n \n         String out1 = v1.toString();\n-        assertTrue(\"some output \",  out1.length()!=0);\n+        Assert.assertTrue(\"some output \",  out1.length()!=0);\n         /*\n          double[] dout1 = v1.copyOut();\n-        assertEquals(\"testData len\", 3, dout1.length);\n-        assertNotSame(\"testData not same object \", v1.data, dout1);\n+        Assert.assertEquals(\"testData len\", 3, dout1.length);\n+        Assert.assertNotSame(\"testData not same object \", v1.data, dout1);\n          */\n         try {\n             v1.checkVectorDimensions(2);\n-            fail(\"IllegalArgumentException expected\");\n+            Assert.fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         }\n \n        try {\n             v1.checkVectorDimensions(v4);\n-            fail(\"IllegalArgumentException expected\");\n+            Assert.fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         }\n \n         try {\n             v1.checkVectorDimensions(v4_2);\n-            fail(\"IllegalArgumentException expected\");\n+            Assert.fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         }\n \n     }\n \n+    @Test\n     public void testPredicates() {\n \n         ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });\n \n-        assertFalse(v.isNaN());\n+        Assert.assertFalse(v.isNaN());\n         v.setEntry(1, Double.NaN);\n-        assertTrue(v.isNaN());\n-\n-        assertFalse(v.isInfinite());\n+        Assert.assertTrue(v.isNaN());\n+\n+        Assert.assertFalse(v.isInfinite());\n         v.setEntry(0, Double.POSITIVE_INFINITY);\n-        assertFalse(v.isInfinite());\n+        Assert.assertFalse(v.isInfinite());\n         v.setEntry(1, 1);\n-        assertTrue(v.isInfinite());\n+        Assert.assertTrue(v.isInfinite());\n         v.setEntry(0, 1);\n-        assertFalse(v.isInfinite());\n+        Assert.assertFalse(v.isInfinite());\n \n         v.setEntry(0, 0);\n-        assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));\n-        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));\n-        assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));\n-\n-        assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n+        Assert.assertEquals(v, new ArrayRealVector(new double[] { 0, 1, 2 }));\n+        Assert.assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));\n+        Assert.assertNotSame(v, new ArrayRealVector(new double[] { 0, 1, 2, 3 }));\n+\n+        Assert.assertEquals(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n                      new ArrayRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());\n \n-        assertTrue(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n+        Assert.assertTrue(new ArrayRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n                    new ArrayRealVector(new double[] { 0, 1, 2 }).hashCode());\n \n-        assertTrue(v.equals(v));\n-        assertTrue(v.equals(v.copy()));\n-        assertFalse(v.equals(null));\n-        assertFalse(v.equals(v.getDataRef()));\n-        assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1)));\n-        assertTrue(v.equals(v.getSubVector(0, v.getDimension())));\n+        Assert.assertTrue(v.equals(v));\n+        Assert.assertTrue(v.equals(v.copy()));\n+        Assert.assertFalse(v.equals(null));\n+        Assert.assertFalse(v.equals(v.getDataRef()));\n+        Assert.assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1)));\n+        Assert.assertTrue(v.equals(v.getSubVector(0, v.getDimension())));\n \n     }\n \n+    @Test\n     public void testSerial()  {\n         ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });\n-        assertEquals(v,TestUtils.serializeAndRecover(v));\n+        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));\n     }\n \n+    @Test\n     public void testZeroVectors() {\n-        assertEquals(0, new ArrayRealVector(new double[0]).getDimension());\n-        assertEquals(0, new ArrayRealVector(new double[0], true).getDimension());\n-        assertEquals(0, new ArrayRealVector(new double[0], false).getDimension());\n+        Assert.assertEquals(0, new ArrayRealVector(new double[0]).getDimension());\n+        Assert.assertEquals(0, new ArrayRealVector(new double[0], true).getDimension());\n+        Assert.assertEquals(0, new ArrayRealVector(new double[0], false).getDimension());\n     }\n \n+    @Test\n     public void testMinMax()  {\n         ArrayRealVector v1 = new ArrayRealVector(new double[] { 0, -6, 4, 12, 7 });\n-        assertEquals(1,  v1.getMinIndex());\n-        assertEquals(-6, v1.getMinValue(), 1.0e-12);\n-        assertEquals(3,  v1.getMaxIndex());\n-        assertEquals(12, v1.getMaxValue(), 1.0e-12);\n+        Assert.assertEquals(1,  v1.getMinIndex());\n+        Assert.assertEquals(-6, v1.getMinValue(), 1.0e-12);\n+        Assert.assertEquals(3,  v1.getMaxIndex());\n+        Assert.assertEquals(12, v1.getMaxValue(), 1.0e-12);\n         ArrayRealVector v2 = new ArrayRealVector(new double[] { Double.NaN, 3, Double.NaN, -2 });\n-        assertEquals(3,  v2.getMinIndex());\n-        assertEquals(-2, v2.getMinValue(), 1.0e-12);\n-        assertEquals(1,  v2.getMaxIndex());\n-        assertEquals(3, v2.getMaxValue(), 1.0e-12);\n+        Assert.assertEquals(3,  v2.getMinIndex());\n+        Assert.assertEquals(-2, v2.getMinValue(), 1.0e-12);\n+        Assert.assertEquals(1,  v2.getMaxIndex());\n+        Assert.assertEquals(3, v2.getMaxValue(), 1.0e-12);\n         ArrayRealVector v3 = new ArrayRealVector(new double[] { Double.NaN, Double.NaN });\n-        assertEquals(-1,  v3.getMinIndex());\n-        assertTrue(Double.isNaN(v3.getMinValue()));\n-        assertEquals(-1,  v3.getMaxIndex());\n-        assertTrue(Double.isNaN(v3.getMaxValue()));\n+        Assert.assertEquals(-1,  v3.getMinIndex());\n+        Assert.assertTrue(Double.isNaN(v3.getMinValue()));\n+        Assert.assertEquals(-1,  v3.getMaxIndex());\n+        Assert.assertTrue(Double.isNaN(v3.getMaxValue()));\n         ArrayRealVector v4 = new ArrayRealVector(new double[0]);\n-        assertEquals(-1,  v4.getMinIndex());\n-        assertTrue(Double.isNaN(v4.getMinValue()));\n-        assertEquals(-1,  v4.getMaxIndex());\n-        assertTrue(Double.isNaN(v4.getMaxValue()));\n+        Assert.assertEquals(-1,  v4.getMinIndex());\n+        Assert.assertTrue(Double.isNaN(v4.getMinValue()));\n+        Assert.assertEquals(-1,  v4.getMaxIndex());\n+        Assert.assertTrue(Double.isNaN(v4.getMaxValue()));\n     }\n \n \n     protected void assertClose(String msg, double[] m, double[] n,\n             double tolerance) {\n         if (m.length != n.length) {\n-            fail(\"vectors have different lengths\");\n+            Assert.fail(\"vectors have different lengths\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+            Assert.assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n         }\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n \n import java.io.Serializable;\n import java.util.Iterator;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.analysis.function.Abs;\n+import org.apache.commons.math.analysis.function.Acosh;\n+import org.apache.commons.math.analysis.function.Acos;\n+import org.apache.commons.math.analysis.function.Asinh;\n+import org.apache.commons.math.analysis.function.Asin;\n+import org.apache.commons.math.analysis.function.Atanh;\n+import org.apache.commons.math.analysis.function.Atan;\n+import org.apache.commons.math.analysis.function.Cbrt;\n+import org.apache.commons.math.analysis.function.Cosh;\n+import org.apache.commons.math.analysis.function.Cos;\n+import org.apache.commons.math.analysis.function.Exp;\n+import org.apache.commons.math.analysis.function.Expm1;\n+import org.apache.commons.math.analysis.function.Inverse;\n+import org.apache.commons.math.analysis.function.Log10;\n+import org.apache.commons.math.analysis.function.Log1p;\n+import org.apache.commons.math.analysis.function.Log;\n+import org.apache.commons.math.analysis.function.Pow;\n+import org.apache.commons.math.analysis.function.Sinh;\n+import org.apache.commons.math.analysis.function.Sin;\n+import org.apache.commons.math.analysis.function.Sqrt;\n+import org.apache.commons.math.analysis.function.Tanh;\n+import org.apache.commons.math.analysis.function.Tan;\n+import org.apache.commons.math.analysis.function.Floor;\n+import org.apache.commons.math.analysis.function.Ceil;\n+import org.apache.commons.math.analysis.function.Rint;\n+import org.apache.commons.math.analysis.function.Signum;\n+import org.apache.commons.math.analysis.function.Ulp;\n \n /**\n  * Test cases for the {@link OpenMapRealVector} class.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class SparseRealVectorTest extends TestCase {\n+public class SparseRealVectorTest {\n \n     //\n     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n             throw unsupported();\n         }\n \n-        @Override\n-        public RealVector mapExp() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapExpToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapExpm1() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapExpm1ToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapLog() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapLogToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapLog10() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapLog10ToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapLog1p() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapLog1pToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCosh() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCoshToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSinh() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSinhToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapTanh() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapTanhToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCos() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCosToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSin() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSinToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapTan() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapTanToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAcos() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAcosToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAsin() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAsinToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAtan() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAtanToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapInv() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapInvToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAbs() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapAbsToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSqrt() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSqrtToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCbrt() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCbrtToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCeil() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapCeilToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapFloor() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapFloorToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapRint() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapRintToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSignum() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapSignumToSelf() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapUlp() {\n-            throw unsupported();\n-        }\n-\n-        @Override\n-        public RealVector mapUlpToSelf() {\n-            throw unsupported();\n-        }\n-\n         public RealVector ebeMultiply(RealVector v) {\n             throw unsupported();\n         }\n \n     }\n \n+    @Test\n     public void testConstructors() {\n \n         OpenMapRealVector v0 = new OpenMapRealVector();\n-        assertEquals(\"testData len\", 0, v0.getDimension());\n+        Assert.assertEquals(\"testData len\", 0, v0.getDimension());\n \n         OpenMapRealVector v1 = new OpenMapRealVector(7);\n-        assertEquals(\"testData len\", 7, v1.getDimension());\n-        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+        Assert.assertEquals(\"testData len\", 7, v1.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6), 0);\n \n         OpenMapRealVector v3 = new OpenMapRealVector(vec1);\n-        assertEquals(\"testData len\", 3, v3.getDimension());\n-        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+        Assert.assertEquals(\"testData len\", 3, v3.getDimension());\n+        Assert.assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1), 0);\n \n         //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2);\n-        //assertEquals(\"testData len\", 2, v4.getDimension());\n-        //assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        //Assert.assertEquals(\"testData len\", 2, v4.getDimension());\n+        //Assert.assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n         //try {\n         //    new SparseRealVector(vec4, 8, 3);\n-        //    fail(\"IllegalArgumentException expected\");\n+        //    Assert.fail(\"IllegalArgumentException expected\");\n         //} catch (IllegalArgumentException ex) {\n             // expected behavior\n         //}\n \n         RealVector v5_i = new OpenMapRealVector(dvec1);\n-        assertEquals(\"testData len\", 9, v5_i.getDimension());\n-        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+        Assert.assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        Assert.assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8), 0);\n \n         OpenMapRealVector v5 = new OpenMapRealVector(dvec1);\n-        assertEquals(\"testData len\", 9, v5.getDimension());\n-        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+        Assert.assertEquals(\"testData len\", 9, v5.getDimension());\n+        Assert.assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8), 0);\n \n         OpenMapRealVector v7 = new OpenMapRealVector(v1);\n-        assertEquals(\"testData len\", 7, v7.getDimension());\n-        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+        Assert.assertEquals(\"testData len\", 7, v7.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6), 0);\n \n         SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl(vec1);\n \n         OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i);\n-        assertEquals(\"testData len\", 3, v7_2.getDimension());\n-        assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+        Assert.assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1), 0);\n \n         OpenMapRealVector v8 = new OpenMapRealVector(v1);\n-        assertEquals(\"testData len\", 7, v8.getDimension());\n-        assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n+        Assert.assertEquals(\"testData len\", 7, v8.getDimension());\n+        Assert.assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6), 0);\n \n     }\n \n+    @Test\n     public void testDataInOut() {\n \n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n         SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n \n         RealVector v_append_1 = v1.append(v2);\n-        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n-        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3), 0);\n \n         RealVector v_append_2 = v1.append(2.0);\n-        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n-        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        Assert.assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3), 0);\n \n         RealVector v_append_3 = v1.append(vec2);\n-        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n-        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        Assert.assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3), 0);\n \n         RealVector v_append_4 = v1.append(v2_t);\n-        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n-        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+        Assert.assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3), 0);\n \n         RealVector vout5 = v4.getSubVector(3, 3);\n-        assertEquals(\"testData len\", 3, vout5.getDimension());\n-        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        Assert.assertEquals(\"testData len\", 3, vout5.getDimension());\n+        Assert.assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1), 0);\n         try {\n             v4.getSubVector(3, 7);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         OpenMapRealVector v_set1 = v1.copy();\n         v_set1.setEntry(1, 11.0);\n-        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        Assert.assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1), 0);\n         try {\n             v_set1.setEntry(3, 11.0);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         OpenMapRealVector v_set2 = v4.copy();\n         v_set2.setSubVector(3, v1);\n-        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n-        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        Assert.assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3), 0);\n+        Assert.assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6), 0);\n         try {\n             v_set2.setSubVector(7, v1);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         OpenMapRealVector v_set3 = v1.copy();\n         v_set3.set(13.0);\n-        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+        Assert.assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2), 0);\n \n         try {\n             v_set3.getEntry(23);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n         OpenMapRealVector v_set4 = v4.copy();\n         v_set4.setSubVector(3, v2_t);\n-        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n-        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        Assert.assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3), 0);\n+        Assert.assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6), 0);\n         try {\n             v_set4.setSubVector(7, v2_t);\n-            fail(\"OutOfRangeException expected\");\n+            Assert.fail(\"OutOfRangeException expected\");\n         } catch (OutOfRangeException ex) {\n             // expected behavior\n         }\n \n     }\n \n+    @Test\n     public void testMapFunctions() {\n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n \n         assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n \n         //octave =  exp(v1)\n-        RealVector v_mapExp = v1.mapExp();\n+        RealVector v_mapExp = v1.map(new Exp());\n         double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n         assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n \n         //octave =  exp(v1)\n         RealVector v_mapExpToSelf = v1.copy();\n-        v_mapExpToSelf.mapExpToSelf();\n+        v_mapExpToSelf.mapToSelf(new Exp());\n         double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n         assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n \n \n         //octave =  ???\n-        RealVector v_mapExpm1 = v1.mapExpm1();\n+        RealVector v_mapExpm1 = v1.map(new Expm1());\n         double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n         assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n \n         //octave =  ???\n         RealVector v_mapExpm1ToSelf = v1.copy();\n-        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        v_mapExpm1ToSelf.mapToSelf(new Expm1());\n         double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n         assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n \n         //octave =  log(v1)\n-        RealVector v_mapLog = v1.mapLog();\n+        RealVector v_mapLog = v1.map(new Log());\n         double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n         assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n \n         //octave =  log(v1)\n         RealVector v_mapLogToSelf = v1.copy();\n-        v_mapLogToSelf.mapLogToSelf();\n+        v_mapLogToSelf.mapToSelf(new Log());\n         double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n         assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n \n         //octave =  log10(v1)\n-        RealVector v_mapLog10 = v1.mapLog10();\n+        RealVector v_mapLog10 = v1.map(new Log10());\n         double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n         assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n \n         //octave =  log(v1)\n         RealVector v_mapLog10ToSelf = v1.copy();\n-        v_mapLog10ToSelf.mapLog10ToSelf();\n+        v_mapLog10ToSelf.mapToSelf(new Log10());\n         double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n         assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n \n         //octave =  ???\n-        RealVector v_mapLog1p = v1.mapLog1p();\n+        RealVector v_mapLog1p = v1.map(new Log1p());\n         double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n         assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n \n         //octave =  ???\n         RealVector v_mapLog1pToSelf = v1.copy();\n-        v_mapLog1pToSelf.mapLog1pToSelf();\n+        v_mapLog1pToSelf.mapToSelf(new Log1p());\n         double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n         assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n \n         //octave =  cosh(v1)\n-        RealVector v_mapCosh = v1.mapCosh();\n+        RealVector v_mapCosh = v1.map(new Cosh());\n         double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n         assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n \n         //octave =  cosh(v1)\n         RealVector v_mapCoshToSelf = v1.copy();\n-        v_mapCoshToSelf.mapCoshToSelf();\n+        v_mapCoshToSelf.mapToSelf(new Cosh());\n         double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n         assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n \n         //octave =  sinh(v1)\n-        RealVector v_mapSinh = v1.mapSinh();\n+        RealVector v_mapSinh = v1.map(new Sinh());\n         double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n         assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n \n         //octave =  sinh(v1)\n         RealVector v_mapSinhToSelf = v1.copy();\n-        v_mapSinhToSelf.mapSinhToSelf();\n+        v_mapSinhToSelf.mapToSelf(new Sinh());\n         double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n         assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n \n         //octave =  tanh(v1)\n-        RealVector v_mapTanh = v1.mapTanh();\n+        RealVector v_mapTanh = v1.map(new Tanh());\n         double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n         assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n \n         //octave =  tanh(v1)\n         RealVector v_mapTanhToSelf = v1.copy();\n-        v_mapTanhToSelf.mapTanhToSelf();\n+        v_mapTanhToSelf.mapToSelf(new Tanh());\n         double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n         assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n \n         //octave =  cos(v1)\n-        RealVector v_mapCos = v1.mapCos();\n+        RealVector v_mapCos = v1.map(new Cos());\n         double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n         assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n \n         //octave =  cos(v1)\n         RealVector v_mapCosToSelf = v1.copy();\n-        v_mapCosToSelf.mapCosToSelf();\n+        v_mapCosToSelf.mapToSelf(new Cos());\n         double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n         assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n \n         //octave =  sin(v1)\n-        RealVector v_mapSin = v1.mapSin();\n+        RealVector v_mapSin = v1.map(new Sin());\n         double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n         assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n \n         //octave =  sin(v1)\n         RealVector v_mapSinToSelf = v1.copy();\n-        v_mapSinToSelf.mapSinToSelf();\n+        v_mapSinToSelf.mapToSelf(new Sin());\n         double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n         assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n \n         //octave =  tan(v1)\n-        RealVector v_mapTan = v1.mapTan();\n+        RealVector v_mapTan = v1.map(new Tan());\n         double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n         assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n \n         //octave =  tan(v1)\n         RealVector v_mapTanToSelf = v1.copy();\n-        v_mapTanToSelf.mapTanToSelf();\n+        v_mapTanToSelf.mapToSelf(new Tan());\n         double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n         assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n \n         OpenMapRealVector vat = new OpenMapRealVector(vat_a);\n \n         //octave =  acos(vat)\n-        RealVector v_mapAcos = vat.mapAcos();\n+        RealVector v_mapAcos = vat.map(new Acos());\n         double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n         assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n \n         //octave =  acos(vat)\n         RealVector v_mapAcosToSelf = vat.copy();\n-        v_mapAcosToSelf.mapAcosToSelf();\n+        v_mapAcosToSelf.mapToSelf(new Acos());\n         double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n         assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n \n         //octave =  asin(vat)\n-        RealVector v_mapAsin = vat.mapAsin();\n+        RealVector v_mapAsin = vat.map(new Asin());\n         double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n         assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n \n         //octave =  asin(vat)\n         RealVector v_mapAsinToSelf = vat.copy();\n-        v_mapAsinToSelf.mapAsinToSelf();\n+        v_mapAsinToSelf.mapToSelf(new Asin());\n         double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n         assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n \n         //octave =  atan(vat)\n-        RealVector v_mapAtan = vat.mapAtan();\n+        RealVector v_mapAtan = vat.map(new Atan());\n         double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n         assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n \n         //octave =  atan(vat)\n         RealVector v_mapAtanToSelf = vat.copy();\n-        v_mapAtanToSelf.mapAtanToSelf();\n+        v_mapAtanToSelf.mapToSelf(new Atan());\n         double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n         assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n \n         //octave =  v1 .^-1\n-        RealVector v_mapInv = v1.mapInv();\n+        RealVector v_mapInv = v1.map(new Inverse());\n         double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n         assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n \n         //octave =  v1 .^-1\n         RealVector v_mapInvToSelf = v1.copy();\n-        v_mapInvToSelf.mapInvToSelf();\n+        v_mapInvToSelf.mapToSelf(new Inverse());\n         double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n         assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n \n         OpenMapRealVector abs_v = new OpenMapRealVector(abs_a);\n \n         //octave =  abs(abs_v)\n-        RealVector v_mapAbs = abs_v.mapAbs();\n+        RealVector v_mapAbs = abs_v.map(new Abs());\n         double[] result_mapAbs = {1d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n \n         //octave = abs(abs_v)\n         RealVector v_mapAbsToSelf = abs_v.copy();\n-        v_mapAbsToSelf.mapAbsToSelf();\n+        v_mapAbsToSelf.mapToSelf(new Abs());\n         double[] result_mapAbsToSelf = {1d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n \n         //octave =   sqrt(v1)\n-        RealVector v_mapSqrt = v1.mapSqrt();\n+        RealVector v_mapSqrt = v1.map(new Sqrt());\n         double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n         assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n \n         //octave =  sqrt(v1)\n         RealVector v_mapSqrtToSelf = v1.copy();\n-        v_mapSqrtToSelf.mapSqrtToSelf();\n+        v_mapSqrtToSelf.mapToSelf(new Sqrt());\n         double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n         assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n \n         OpenMapRealVector cbrt_v = new OpenMapRealVector(cbrt_a);\n \n         //octave =  ???\n-        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        RealVector v_mapCbrt = cbrt_v.map(new Cbrt());\n         double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n         assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapCbrtToSelf = cbrt_v.copy();\n-        v_mapCbrtToSelf.mapCbrtToSelf();\n+        v_mapCbrtToSelf.mapToSelf(new Cbrt());\n         double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n         assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n \n         OpenMapRealVector ceil_v = new OpenMapRealVector(ceil_a);\n \n         //octave =  ceil(ceil_v)\n-        RealVector v_mapCeil = ceil_v.mapCeil();\n+        RealVector v_mapCeil = ceil_v.map(new Ceil());\n         double[] result_mapCeil = {-1d,1d,2d};\n         assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n \n         //octave = ceil(ceil_v)\n         RealVector v_mapCeilToSelf = ceil_v.copy();\n-        v_mapCeilToSelf.mapCeilToSelf();\n+        v_mapCeilToSelf.mapToSelf(new Ceil());\n         double[] result_mapCeilToSelf =  {-1d,1d,2d};\n         assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n \n         //octave =  floor(ceil_v)\n-        RealVector v_mapFloor = ceil_v.mapFloor();\n+        RealVector v_mapFloor = ceil_v.map(new Floor());\n         double[] result_mapFloor = {-2d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n \n         //octave = floor(ceil_v)\n         RealVector v_mapFloorToSelf = ceil_v.copy();\n-        v_mapFloorToSelf.mapFloorToSelf();\n+        v_mapFloorToSelf.mapToSelf(new Floor());\n         double[] result_mapFloorToSelf =  {-2d,0d,1d};\n         assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n \n         //octave =  ???\n-        RealVector v_mapRint = ceil_v.mapRint();\n+        RealVector v_mapRint = ceil_v.map(new Rint());\n         double[] result_mapRint = {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapRintToSelf = ceil_v.copy();\n-        v_mapRintToSelf.mapRintToSelf();\n+        v_mapRintToSelf.mapToSelf(new Rint());\n         double[] result_mapRintToSelf =  {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n \n         //octave =  ???\n-        RealVector v_mapSignum = ceil_v.mapSignum();\n+        RealVector v_mapSignum = ceil_v.map(new Signum());\n         double[] result_mapSignum = {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapSignumToSelf = ceil_v.copy();\n-        v_mapSignumToSelf.mapSignumToSelf();\n+        v_mapSignumToSelf.mapToSelf(new Signum());\n         double[] result_mapSignumToSelf =  {-1d,1d,1d};\n         assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n \n \n         // Is with the used resolutions of limited value as test\n         //octave =  ???\n-        RealVector v_mapUlp = ceil_v.mapUlp();\n+        RealVector v_mapUlp = ceil_v.map(new Ulp());\n         double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n         assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n \n         //octave = ???\n         RealVector v_mapUlpToSelf = ceil_v.copy();\n-        v_mapUlpToSelf.mapUlpToSelf();\n+        v_mapUlpToSelf.mapToSelf(new Ulp());\n         double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n         assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n-\n     }\n \n+    @Test\n     public void testBasicFunctions() {\n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n         OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n \n         // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n         double d_getNorm = v5.getNorm();\n-        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n+        Assert.assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm, normTolerance);\n \n         // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n         double d_getL1Norm = v5.getL1Norm();\n-        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n+        Assert.assertEquals(\"compare values  \", 17.0, d_getL1Norm, normTolerance);\n \n         // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n         double d_getLInfNorm = v5.getLInfNorm();\n-        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n+        Assert.assertEquals(\"compare values  \", 6.0, d_getLInfNorm, normTolerance);\n \n         //octave =  sqrt(sumsq(v1-v2))\n         double dist = v1.getDistance(v2);\n-        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+        Assert.assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist, normTolerance);\n \n         //octave =  sqrt(sumsq(v1-v2))\n         double dist_2 = v1.getDistance(v2_t);\n-        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+        Assert.assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2, normTolerance);\n \n         //octave =  ???\n         double d_getL1Distance = v1. getL1Distance(v2);\n-        assertEquals(\"compare values  \",9d, d_getL1Distance );\n+        Assert.assertEquals(\"compare values  \", 9d, d_getL1Distance, normTolerance);\n \n         double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n-        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n+        Assert.assertEquals(\"compare values  \", 9d, d_getL1Distance_2, normTolerance);\n \n         //octave =  ???\n         double d_getLInfDistance = v1. getLInfDistance(v2);\n-        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+        Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance, normTolerance);\n \n         double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n-        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+        Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance_2, normTolerance);\n \n         //octave =  v1 + v2\n         OpenMapRealVector v_add = v1.add(v2);\n \n         // octave  dot(v1,v2)\n         double dot =  v1.dotProduct(v2);\n-        assertEquals(\"compare val \",32d, dot);\n+        Assert.assertEquals(\"compare val \",32d, dot, normTolerance);\n \n         // octave  dot(v1,v2_t)\n         double dot_2 =  v1.dotProduct(v2_t);\n-        assertEquals(\"compare val \",32d, dot_2);\n+        Assert.assertEquals(\"compare val \",32d, dot_2, normTolerance);\n \n         RealMatrix m_outerProduct = v1.outerProduct(v2);\n-        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0), normTolerance);\n \n         RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n-        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+        Assert.assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0), normTolerance);\n \n         RealVector v_unitVector = v1.unitVector();\n         RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n \n         try {\n             v_null.unitVector();\n-            fail(\"Expecting ArithmeticException\");\n+            Assert.fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n             // expected behavior\n         }\n         assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n         try {\n             v_null.unitize();\n-            fail(\"Expecting ArithmeticException\");\n+            Assert.fail(\"Expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {\n             // expected behavior\n         }\n \n     }\n \n+    @Test\n     public void testMisc() {\n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n \n         String out1 = v1.toString();\n-        assertTrue(\"some output \",  out1.length()!=0);\n+        Assert.assertTrue(\"some output \",  out1.length()!=0);\n         try {\n             v1.checkVectorDimensions(2);\n-            fail(\"IllegalArgumentException expected\");\n+            Assert.fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         }\n \n     }\n \n+    @Test\n     public void testPredicates() {\n \n         OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });\n \n-        assertFalse(v.isNaN());\n+        Assert.assertFalse(v.isNaN());\n         v.setEntry(1, Double.NaN);\n-        assertTrue(v.isNaN());\n-\n-        assertFalse(v.isInfinite());\n+        Assert.assertTrue(v.isNaN());\n+\n+        Assert.assertFalse(v.isInfinite());\n         v.setEntry(0, Double.POSITIVE_INFINITY);\n-        assertFalse(v.isInfinite()); // NaN has higher priority than infinity\n+        Assert.assertFalse(v.isInfinite()); // NaN has higher priority than infinity\n         v.setEntry(1, 1);\n-        assertTrue(v.isInfinite());\n+        Assert.assertTrue(v.isInfinite());\n \n         v.setEntry(0, 0);\n-        assertEquals(v, new OpenMapRealVector(new double[] { 0, 1, 2 }));\n-        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));\n-        assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2, 3 }));\n+        Assert.assertEquals(v, new OpenMapRealVector(new double[] { 0, 1, 2 }));\n+        Assert.assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2 + FastMath.ulp(2)}));\n+        Assert.assertNotSame(v, new OpenMapRealVector(new double[] { 0, 1, 2, 3 }));\n \n     }\n \n+    @Test\n     public void testSerial()  {\n         OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });\n-        assertEquals(v,TestUtils.serializeAndRecover(v));\n+        Assert.assertEquals(v,TestUtils.serializeAndRecover(v));\n     }\n \n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, double[] m, double[] n,\n             double tolerance) {\n         if (m.length != n.length) {\n-            fail(\"vectors have different lengths\");\n+            Assert.fail(\"vectors have different lengths\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+            Assert.assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n         }\n     }\n-\n }", "timestamp": 1290785068, "metainfo": ""}