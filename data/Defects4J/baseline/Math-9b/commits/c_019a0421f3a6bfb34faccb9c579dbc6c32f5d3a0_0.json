{"sha": "019a0421f3a6bfb34faccb9c579dbc6c32f5d3a0", "log": "MATH-815 Initial commit. Units test are yet to be added. This version also contains a bug. Code contributed by Jared Becksfort, included with modifications. [Cf. comments on JIRA.]   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractMultivariateRealDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+\n+/**\n+ * Base class for probability distributions on the multivariate reals.\n+ * Default implementations are provided for some of the methods that do\n+ * not vary from distribution to distribution.\n+ * \n+ */\n+public abstract class AbstractMultivariateRealDistribution\n+    implements MultivariateRealDistribution {\n+    /** The number of dimensions or columns in the multivariate distribution. */\n+    private final int numDimensions;\n+    /** RNG instance used to generate samples from the distribution. */\n+    protected final RandomGenerator random;\n+\n+    /**\n+     * @param rng Random number generator.\n+     * @param n Number of dimensions.\n+     */\n+    protected AbstractMultivariateRealDistribution(RandomGenerator rng,\n+                                                   int n) {\n+        random = rng;\n+        numDimensions = n;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void reseedRandomGenerator(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * \n+     * @return the number of dimensions in the multivariate distribution .\n+     */\n+    public int getDimensions() {\n+        return numDimensions;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract double[] sample();\n+\n+    /** {@inheritDoc} */\n+    public double[][] sample(final int sampleSize) {\n+        if (sampleSize <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                                                   sampleSize);\n+        }\n+        final double[][] out = new double[sampleSize][numDimensions];\n+        for (int i = 0; i < sampleSize; i++) {\n+            out[i] = sample();\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double probability(double[] x) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportConnected() {\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math3.linear.EigenDecomposition;\n+import org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.SingularMatrixException;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.stat.correlation.Covariance;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * Implementation of the multivariate normal (Gaussian) distribution.\n+ * \n+ * @see <a href=\"http://en.wikipedia.org/wiki/Multivariate_normal_distribution\">\n+ * Multivariate normal distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/MultivariateNormalDistribution.html\">\n+ * Multivariate normal distribution (MathWorld)</a>\n+ */\n+public class MultivariateNormalDistribution\n+    extends AbstractMultivariateRealDistribution {\n+    /** Vector of means. */\n+    private final double[] means;\n+    /** Covariance matrix. */\n+    private final RealMatrix covarianceMatrix;\n+    /** The matrix inverse of the covariance matrix. */\n+    private final RealMatrix covarianceMatrixInverse;\n+    /** The determinant of the covariance matrix. */\n+    private final double covarianceMatrixDeterminant;\n+    /** Matrix used in computation of samples. */\n+    private final RealMatrix samplingMatrix;\n+\n+    /**\n+     * Creates a multivariate normal distribution with the given mean vector and\n+     * covariance matrix.\n+     * <br/>\n+     * The number of dimensions is equal to the length of the mean vector\n+     * and to the number of rows and columns of the covariance matrix.\n+     * It is frequently written as \"p\" in formulae.\n+     * \n+     * @param means Vector of means.\n+     * @param covariances Covariance matrix.\n+     */\n+    public MultivariateNormalDistribution(final double[] means,\n+                                          final double[][] covariances)\n+        throws SingularMatrixException,\n+               DimensionMismatchException,\n+               NonPositiveDefiniteMatrixException {\n+        this(new Well19937c(), means, covariances);\n+    }\n+\n+    /**\n+     * Creates a multivariate normal distribution with the given mean vector and\n+     * covariance matrix.\n+     * <br/>\n+     * The number of dimensions is equal to the length of the mean vector\n+     * and to the number of rows and columns of the covariance matrix.\n+     * It is frequently written as \"p\" in formulae.\n+     * \n+     * @param rng Random Number Generator.\n+     * @param means Vector of means.\n+     * @param covariances Covariance matrix.\n+     */\n+    public MultivariateNormalDistribution(RandomGenerator rng,\n+                                          final double[] means,\n+                                          final double[][] covariances)\n+            throws SingularMatrixException,\n+                   DimensionMismatchException,\n+                   NonPositiveDefiniteMatrixException {\n+        super(rng, means.length);\n+\n+        final int dim = means.length;\n+\n+        if (covariances.length != dim) {\n+            throw new DimensionMismatchException(covariances.length, dim);\n+        }\n+\n+        for (int i = 0; i < dim; i++) {\n+            if (dim != covariances[i].length) {\n+                throw new DimensionMismatchException(covariances[i].length, dim);\n+            }\n+        }\n+\n+        this.means = MathArrays.copyOf(means);\n+\n+        covarianceMatrix = new Array2DRowRealMatrix(covariances);\n+\n+        // Covariance matrix eigen decomposition.\n+        final EigenDecomposition covMatDec = new EigenDecomposition(covarianceMatrix);\n+\n+        // Compute and store the inverse.\n+        covarianceMatrixInverse = covMatDec.getSolver().getInverse();\n+        // Compute and store the determinant.\n+        covarianceMatrixDeterminant = covMatDec.getDeterminant();\n+\n+        // Eigenvalues of the covariance matrix.\n+        final double[] covMatEigenvalues = covMatDec.getRealEigenvalues();\n+\n+        for (int i = 0; i < covMatEigenvalues.length; i++) {\n+            if (covMatEigenvalues[i] < 0) {\n+                throw new NonPositiveDefiniteMatrixException(covMatEigenvalues[i], i, 0);\n+            }\n+        }\n+\n+        // Matrix where each column is an eigenvector of the covariance matrix.\n+        final Array2DRowRealMatrix covMatEigenvectors = new Array2DRowRealMatrix(dim, dim);\n+        for (int v = 0; v < dim; v++) {\n+            final double[] evec = covMatDec.getEigenvector(v).toArray();\n+            covMatEigenvectors.setColumn(v, evec);\n+        }\n+\n+        final RealMatrix tmpMatrix = covMatEigenvectors.transpose();\n+\n+        // Scale each eigenvector by the square root of its eigenvalue.\n+        for (int row = 0; row < dim; row++) {\n+            final double factor = FastMath.sqrt(covMatEigenvalues[row]);\n+            for (int col = 0; col < dim; col++) {\n+                tmpMatrix.multiplyEntry(row, col, factor);\n+            }\n+        }\n+\n+        samplingMatrix = covMatEigenvectors.multiply(tmpMatrix);\n+    }\n+\n+    /**\n+     * Gets the mean vector.\n+     * \n+     * @return the mean vector.\n+     */\n+    public double[] getMeans() {\n+        return MathArrays.copyOf(means);\n+    }\n+\n+    /**\n+     * Gets the covariance matrix.\n+     * \n+     * @return the covariance matrix.\n+     */\n+    public RealMatrix getCovariances() {\n+        return covarianceMatrix.copy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(final double[] vals) throws DimensionMismatchException {\n+        final int dim = getDimensions();\n+        if (vals.length != dim) {\n+            throw new DimensionMismatchException(vals.length, dim);\n+        }\n+\n+        final double kernel = getKernel(vals);\n+\n+        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n+            FastMath.exp(kernel);\n+    }\n+\n+    /**\n+     * Gets the square root of each element on the diagonal of the covariance\n+     * matrix.\n+     * \n+     * @return the standard deviations.\n+     */\n+    public double[] getStandardDeviations() {\n+        final int dim = getDimensions();\n+        final double[] std = new double[dim];\n+        final double[][] s = covarianceMatrix.getData();\n+        for (int i = 0; i < dim; i++) {\n+            std[i] = FastMath.sqrt(s[i][i]);\n+        }\n+        return std;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] sample() {\n+        final int dim = getDimensions();\n+        final double[] normalVals = new double[dim];\n+\n+        for (int i = 0; i < dim; i++) {\n+            normalVals[i] = random.nextGaussian();\n+        }\n+\n+        final double[] vals = samplingMatrix.operate(normalVals);\n+\n+        for (int i = 0; i < dim; i++) {\n+            vals[i] += means[i];\n+        }\n+\n+        return vals;\n+    }\n+\n+    /**\n+     * Precomputes some of the multiplications used for determining densities.\n+     * \n+     * @param values Values at which to compute density.\n+     * @return the multiplication factor of density calculations.\n+     */\n+    private double getKernel(final double[] values) {\n+        double k = 0;\n+        for (int col = 0; col < values.length; col++) {\n+            for (int v = 0; v < values.length; v++) {\n+                k += covarianceMatrixInverse.getEntry(v, col)\n+                    * FastMath.pow(values[v] - means[v], 2);\n+            }\n+        }\n+        return -0.5 * k;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateRealDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+\n+/**\n+ * Base interface for multivariate distributions on the reals.\n+ * \n+ * This is based largely on the RealDistribution interface, but cumulative\n+ * distribution functions are not required because they are often quite\n+ * difficult to compute for multivariate distributions.\n+ */\n+public interface MultivariateRealDistribution {\n+    /**\n+     * For a random variable {@code X} whose values are distributed according to\n+     * this distribution, this method returns {@code P(X = x)}. In other words,\n+     * this method represents the probability mass function (PMF) for the\n+     * distribution.\n+     * \n+     * @param x Point at which the PMF is evaluated.\n+     * @return the value of the probability mass function at point {@code x}.\n+     */\n+    double probability(double[] x);\n+\n+    /**\n+     * Returns the probability density function (PDF) of this distribution\n+     * evaluated at the specified point {@code x}. In general, the PDF is the\n+     * derivative of the cumulative distribution function. If the derivative\n+     * does not exist at {@code x}, then an appropriate replacement should be\n+     * returned, e.g. {@code Double.POSITIVE_INFINITY}, {@code Double.NaN}, or\n+     * the limit inferior or limit superior of the difference quotient.\n+     * \n+     * @param x Point at which the PDF is evaluated.\n+     * @return the value of the probability density function at point {@code x}.\n+     */\n+    double density(double[] x) throws DimensionMismatchException;\n+\n+    /**\n+     * Access the lower bound of the support.\n+     * This method must return the same value as {@code inverseCumulativeProbability(0)}.\n+     * In other words, this method must return\n+     * <p>\n+     * <code>inf {x in R | P(X <= x) > 0}</code>.\n+     * </p>\n+     * \n+     * @return the lower bound of the support (might be\n+     * {@code Double.NEGATIVE_INFINITY}).\n+     */\n+    double getSupportLowerBound();\n+\n+    /**\n+     * Access the upper bound of the support.\n+     * This method must return the same value as {@code inverseCumulativeProbability(1)}.\n+     * In other words, this method must return\n+     * <p>\n+     * <code>inf {x in R | P(X <= x) = 1}</code>.\n+     * </p>\n+     * \n+     * @return the upper bound of the support (might be\n+     * {@code Double.POSITIVE_INFINITY}).\n+     */\n+    double getSupportUpperBound();\n+\n+    /**\n+     * Gets information about whether the lower bound of the support is\n+     * inclusive or not.\n+     * \n+     * @return whether the lower bound of the support is inclusive or not.\n+     */\n+    boolean isSupportLowerBoundInclusive();\n+\n+    /**\n+     * gets information about whether the upper bound of the support is\n+     * inclusive or not.\n+     * \n+     * @return whether the upper bound of the support is inclusive or not.\n+     */\n+    boolean isSupportUpperBoundInclusive();\n+\n+    /**\n+     * Gets information about whether the support is connected (i.e. all\n+     * values between the lower and upper bound of the support are included\n+     * in the support).\n+     * \n+     * @return whether the support is connected or not.\n+     */\n+    boolean isSupportConnected();\n+\n+    /**\n+     * Reseeds the random generator used to generate samples.\n+     * \n+     * @param seed Seed with which to initialize the random number generator.\n+     */\n+    void reseedRandomGenerator(long seed);\n+\n+    /**\n+     * Generates a random value vector sampled from this distribution.\n+     * \n+     * @return a random value vector.\n+     */\n+    double[] sample();\n+\n+    /**\n+     * Generates a list of a random value vectors from the distribution.\n+     * \n+     * @param sampleSize the number of random vectors to generate.\n+     * @return an array representing the random samples.\n+     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n+     * if {@code sampleSize} is not positive.\n+     */\n+    double[][] sample(int sampleSize) throws NotStrictlyPositiveException;\n+}", "timestamp": 1344435496, "metainfo": ""}