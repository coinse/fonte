{"sha": "4843259cfaa61a2b0c8f7b7eaf787e66fef4b111", "log": "Formatting (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n     /** Serializable version identifier. */\n     static final long serialVersionUID = 5138259215438106000L;\n \n-    /** roots of unity */\n+    /** The roots of unity. */\n     private RootsOfUnity roots = new RootsOfUnity();\n \n-    /**\n-     * Construct a default transformer.\n-     */\n+    /** Construct a default transformer. */\n     public FastFourierTransformer() {\n         super();\n     }\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] transform(double f[])\n+    public Complex[] transform(double[] f)\n         throws IllegalArgumentException {\n         return fft(f, false);\n     }\n     public Complex[] transform(UnivariateFunction f,\n                                double min, double max, int n)\n         throws IllegalArgumentException {\n-        double data[] = sample(f, min, max, n);\n+        double[] data = sample(f, min, max, n);\n         return fft(data, false);\n     }\n \n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] transform(Complex f[])\n+    public Complex[] transform(Complex[] f)\n         throws IllegalArgumentException {\n         roots.computeOmega(f.length);\n         return fft(f);\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] transform2(double f[])\n-        throws IllegalArgumentException {\n-\n-        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f, false), scaling_coefficient);\n+    public Complex[] transform2(double[] f)\n+        throws IllegalArgumentException {\n+\n+        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n+        return scaleArray(fft(f, false), scalingCoefficient);\n     }\n \n     /**\n                                 double min, double max, int n)\n         throws IllegalArgumentException {\n \n-        double data[] = sample(f, min, max, n);\n-        double scaling_coefficient = 1.0 / FastMath.sqrt(n);\n-        return scaleArray(fft(data, false), scaling_coefficient);\n+        double[] data = sample(f, min, max, n);\n+        double scalingCoefficient = 1.0 / FastMath.sqrt(n);\n+        return scaleArray(fft(data, false), scalingCoefficient);\n     }\n \n     /**\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] transform2(Complex f[])\n+    public Complex[] transform2(Complex[] f)\n         throws IllegalArgumentException {\n \n         roots.computeOmega(f.length);\n-        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f), scaling_coefficient);\n+        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n+        return scaleArray(fft(f), scalingCoefficient);\n     }\n \n     /**\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] inverseTransform(double f[])\n-        throws IllegalArgumentException {\n-\n-        double scaling_coefficient = 1.0 / f.length;\n-        return scaleArray(fft(f, true), scaling_coefficient);\n+    public Complex[] inverseTransform(double[] f)\n+        throws IllegalArgumentException {\n+\n+        double scalingCoefficient = 1.0 / f.length;\n+        return scaleArray(fft(f, true), scalingCoefficient);\n     }\n \n     /**\n                                       double min, double max, int n)\n         throws IllegalArgumentException {\n \n-        double data[] = sample(f, min, max, n);\n-        double scaling_coefficient = 1.0 / n;\n-        return scaleArray(fft(data, true), scaling_coefficient);\n+        double[] data = sample(f, min, max, n);\n+        double scalingCoefficient = 1.0 / n;\n+        return scaleArray(fft(data, true), scalingCoefficient);\n     }\n \n     /**\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] inverseTransform(Complex f[])\n+    public Complex[] inverseTransform(Complex[] f)\n         throws IllegalArgumentException {\n \n         roots.computeOmega(-f.length);    // pass negative argument\n-        double scaling_coefficient = 1.0 / f.length;\n-        return scaleArray(fft(f), scaling_coefficient);\n+        double scalingCoefficient = 1.0 / f.length;\n+        return scaleArray(fft(f), scalingCoefficient);\n     }\n \n     /**\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] inverseTransform2(double f[])\n-        throws IllegalArgumentException {\n-\n-        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f, true), scaling_coefficient);\n+    public Complex[] inverseTransform2(double[] f)\n+        throws IllegalArgumentException {\n+\n+        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n+        return scaleArray(fft(f, true), scalingCoefficient);\n     }\n \n     /**\n                                        double min, double max, int n)\n         throws IllegalArgumentException {\n \n-        double data[] = sample(f, min, max, n);\n-        double scaling_coefficient = 1.0 / FastMath.sqrt(n);\n-        return scaleArray(fft(data, true), scaling_coefficient);\n+        double[] data = sample(f, min, max, n);\n+        double scalingCoefficient = 1.0 / FastMath.sqrt(n);\n+        return scaleArray(fft(data, true), scalingCoefficient);\n     }\n \n     /**\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public Complex[] inverseTransform2(Complex f[])\n+    public Complex[] inverseTransform2(Complex[] f)\n         throws IllegalArgumentException {\n \n         roots.computeOmega(-f.length);    // pass negative argument\n-        double scaling_coefficient = 1.0 / FastMath.sqrt(f.length);\n-        return scaleArray(fft(f), scaling_coefficient);\n+        double scalingCoefficient = 1.0 / FastMath.sqrt(f.length);\n+        return scaleArray(fft(f), scalingCoefficient);\n     }\n \n     /**\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    protected Complex[] fft(double f[], boolean isInverse)\n+    protected Complex[] fft(double[] f, boolean isInverse)\n         throws IllegalArgumentException {\n \n         verifyDataSet(f);\n-        Complex F[] = new Complex[f.length];\n+        Complex[] transformed = new Complex[f.length];\n         if (f.length == 1) {\n-            F[0] = new Complex(f[0], 0.0);\n-            return F;\n+            transformed[0] = new Complex(f[0], 0.0);\n+            return transformed;\n         }\n \n         // Rather than the naive real to complex conversion, pack 2N\n         // real numbers into N complex numbers for better performance.\n-        int N = f.length >> 1;\n-        Complex c[] = new Complex[N];\n-        for (int i = 0; i < N; i++) {\n-            c[i] = new Complex(f[2*i], f[2*i+1]);\n-        }\n-        roots.computeOmega(isInverse ? -N : N);\n-        Complex z[] = fft(c);\n+        int n = f.length >> 1;\n+        Complex[] repacked = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            repacked[i] = new Complex(f[2 * i], f[2 * i + 1]);\n+        }\n+        roots.computeOmega(isInverse ? -n : n);\n+        Complex[] z = fft(repacked);\n \n         // reconstruct the FFT result for the original array\n-        roots.computeOmega(isInverse ? -2*N : 2*N);\n-        F[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);\n-        F[N] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);\n-        for (int i = 1; i < N; i++) {\n-            Complex A = z[N-i].conjugate();\n-            Complex B = z[i].add(A);\n-            Complex C = z[i].subtract(A);\n+        roots.computeOmega(isInverse ? -2 * n : 2 * n);\n+        transformed[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);\n+        transformed[n] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);\n+        for (int i = 1; i < n; i++) {\n+            Complex a = z[n - i].conjugate();\n+            Complex b = z[i].add(a);\n+            Complex c = z[i].subtract(a);\n             //Complex D = roots.getOmega(i).multiply(Complex.I);\n-            Complex D = new Complex(-roots.getOmegaImaginary(i),\n+            Complex d = new Complex(-roots.getOmegaImaginary(i),\n                                     roots.getOmegaReal(i));\n-            F[i] = B.subtract(C.multiply(D));\n-            F[2*N-i] = F[i].conjugate();\n-        }\n-\n-        return scaleArray(F, 0.5);\n+            transformed[i] = b.subtract(c.multiply(d));\n+            transformed[2 * n - i] = transformed[i].conjugate();\n+        }\n+\n+        return scaleArray(transformed, 0.5);\n     }\n \n     /**\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    protected Complex[] fft(Complex data[])\n+    protected Complex[] fft(Complex[] data)\n         throws IllegalArgumentException {\n \n         final int n = data.length;\n-        final Complex f[] = new Complex[n];\n+        final Complex[] f = new Complex[n];\n \n         // initial simple cases\n         verifyDataSet(data);\n \n         // the bottom base-4 round\n         for (int i = 0; i < n; i += 4) {\n-            final Complex a = f[i].add(f[i+1]);\n-            final Complex b = f[i+2].add(f[i+3]);\n-            final Complex c = f[i].subtract(f[i+1]);\n-            final Complex d = f[i+2].subtract(f[i+3]);\n+            final Complex a = f[i].add(f[i + 1]);\n+            final Complex b = f[i + 2].add(f[i + 3]);\n+            final Complex c = f[i].subtract(f[i + 1]);\n+            final Complex d = f[i + 2].subtract(f[i + 3]);\n             final Complex e1 = c.add(d.multiply(Complex.I));\n             final Complex e2 = c.subtract(d.multiply(Complex.I));\n             f[i] = a.add(b);\n-            f[i+2] = a.subtract(b);\n+            f[i + 2] = a.subtract(b);\n             // omegaCount indicates forward or inverse transform\n-            f[i+1] = roots.isForward() ? e2 : e1;\n-            f[i+3] = roots.isForward() ? e1 : e2;\n+            f[i + 1] = roots.isForward() ? e2 : e1;\n+            f[i + 3] = roots.isForward() ? e1 : e2;\n         }\n \n         // iterations from bottom to top take O(N*logN) time\n         for (int i = 4; i < n; i <<= 1) {\n-            final int m = n / (i<<1);\n-            for (int j = 0; j < n; j += i<<1) {\n+            final int m = n / (i << 1);\n+            for (int j = 0; j < n; j += i << 1) {\n                 for (int k = 0; k < i; k++) {\n                     //z = f[i+j+k].multiply(roots.getOmega(k*m));\n-                    final int k_times_m = k*m;\n-                    final double omega_k_times_m_real = roots.getOmegaReal(k_times_m);\n-                    final double omega_k_times_m_imaginary = roots.getOmegaImaginary(k_times_m);\n+                    final int km = k * m;\n+                    final double omegaKmReal = roots.getOmegaReal(km);\n+                    final double omegaKmImag = roots.getOmegaImaginary(km);\n                     //z = f[i+j+k].multiply(omega[k*m]);\n                     final Complex z = new Complex(\n-                        f[i+j+k].getReal() * omega_k_times_m_real -\n-                        f[i+j+k].getImaginary() * omega_k_times_m_imaginary,\n-                        f[i+j+k].getReal() * omega_k_times_m_imaginary +\n-                        f[i+j+k].getImaginary() * omega_k_times_m_real);\n-\n-                    f[i+j+k] = f[j+k].subtract(z);\n-                    f[j+k] = f[j+k].add(z);\n+                        f[i + j + k].getReal() * omegaKmReal\n+                        - f[i + j + k].getImaginary() * omegaKmImag,\n+                        f[i + j + k].getReal() * omegaKmImag\n+                        + f[i + j + k].getImaginary() * omegaKmReal);\n+\n+                    f[i + j + k] = f[j + k].subtract(z);\n+                    f[j + k] = f[j + k].add(z);\n                 }\n             }\n         }\n         }\n         verifyInterval(min, max);\n \n-        double s[] = new double[n];\n+        double[] s = new double[n];\n         double h = (max - min) / n;\n         for (int i = 0; i < n; i++) {\n             s[i] = f.value(min + i * h);\n      * @param d the real scaling coefficient\n      * @return a reference to the scaled array\n      */\n-    public static double[] scaleArray(double f[], double d) {\n+    public static double[] scaleArray(double[] f, double d) {\n         for (int i = 0; i < f.length; i++) {\n             f[i] *= d;\n         }\n      * @param d the real scaling coefficient\n      * @return a reference to the scaled array\n      */\n-    public static Complex[] scaleArray(Complex f[], double d) {\n+    public static Complex[] scaleArray(Complex[] f, double d) {\n         for (int i = 0; i < f.length; i++) {\n             f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n         }\n      * @param d the data array\n      * @throws IllegalArgumentException if array length is not power of 2\n      */\n-    public static void verifyDataSet(double d[]) throws IllegalArgumentException {\n+    public static void verifyDataSet(double[] d) throws IllegalArgumentException {\n         if (!isPowerOf2(d.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, d.length);\n      * @param o the data array\n      * @throws IllegalArgumentException if array length is not power of 2\n      */\n-    public static void verifyDataSet(Object o[]) throws IllegalArgumentException {\n+    public static void verifyDataSet(Object[] o) throws IllegalArgumentException {\n         if (!isPowerOf2(o.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, o.length);\n             }\n             if (vector.length != dimensionSize.length) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, vector.length,dimensionSize.length);\n+                        LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, vector.length, dimensionSize.length);\n             }\n \n             Object[] lastDimension = (Object[]) multiDimensionalComplexArray;\n         }\n \n         /**\n-         * Get the underlying storage array\n+         * Get the underlying storage array.\n          * @return underlying storage array\n          */\n         public Object getArray() {\n                 size *= dimensionSize[i];\n             }\n             int[][] vectorList = new int[size][dimensionSize.length];\n-            for (int[] nextVector: vectorList) {\n+            for (int[] nextVector : vectorList) {\n                 System.arraycopy(vector, 0, nextVector, 0,\n                                  dimensionSize.length);\n                 for (int i = 0; i < dimensionSize.length; i++) {\n                 }\n             }\n \n-            for (int[] nextVector: vectorList) {\n+            for (int[] nextVector : vectorList) {\n                 mdcm.set(get(nextVector), nextVector);\n             }\n         }\n       private boolean  isForward;\n \n       /**\n-       * Build an engine for computing then <sup>th</sup> roots of unity\n+       * Build an engine for computing then <sup>th</sup> roots of unity.\n        */\n       public RootsOfUnity() {\n \n         omegaImaginaryForward[0] = 0.0;\n         omegaImaginaryInverse[0] = 0.0;\n         for (int i = 1; i < absN; i++) {\n-          omegaReal[i] =\n-            omegaReal[i-1] * cosT + omegaImaginaryForward[i-1] * sinT;\n-          omegaImaginaryForward[i] =\n-             omegaImaginaryForward[i-1] * cosT - omegaReal[i-1] * sinT;\n+          omegaReal[i] = omegaReal[i - 1] * cosT\n+                         + omegaImaginaryForward[i - 1] * sinT;\n+          omegaImaginaryForward[i] = omegaImaginaryForward[i - 1] * cosT\n+                                     - omegaReal[i - 1] * sinT;\n           omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n         }\n         omegaCount = absN;\n       }\n \n       /**\n-       * Get the real part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * Get the real part of the k<sup>th</sup> n<sup>th</sup> root of unity.\n        * @param k index of the n<sup>th</sup> root of unity\n        * @return real part of the k<sup>th</sup> n<sup>th</sup> root of unity\n        * @throws IllegalStateException if no roots of unity have been computed yet\n       }\n \n       /**\n-       * Get the imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * Get the imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity.\n        * @param k index of the n<sup>th</sup> root of unity\n        * @return imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity\n        * @throws IllegalStateException if no roots of unity have been computed yet", "timestamp": 1322637748, "metainfo": ""}