{"sha": "83caf3972c8f49953e0e31e12542f57b7728f9f4", "log": "fixed spelling error: cummulative -> cumulative.   ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n  * implementations for some of the methods that do not vary from distribution\n  * to distribution.\n  *  \n- * @version $Revision: 1.17 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.18 $ $Date: 2004/02/18 04:04:18 $\n  */\n public abstract class AbstractContinuousDistribution\n     implements ContinuousDistribution {\n      * \n      * @param x0 the lower bound\n      * @param x1 the upper bound\n-     * @return the cummulative probability. \n+     * @return the cumulative probability. \n      */\n-    public double cummulativeProbability(double x0, double x1)\n+    public double cumulativeProbability(double x0, double x1)\n         throws MathException {\n-        return cummulativeProbability(x1) - cummulativeProbability(x0);\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n \n     /**\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n-    public double inverseCummulativeProbability(final double p)\n+    public double inverseCumulativeProbability(final double p)\n         throws MathException {\n         if (p < 0.0 || p > 1.0) {\n             throw new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n             new UnivariateRealFunction() {\n \n             public double value(double x) throws MathException {\n-                return cummulativeProbability(x) - p;\n+                return cumulativeProbability(x) - p;\n             }\n         };\n \n     /**\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n--- a/src/java/org/apache/commons/math/distribution/AbstractDiscreteDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractDiscreteDistribution.java\n  * implementations for some of the methods that do not vary from distribution\n  * to distribution.\n  *  \n- * @version $Revision: 1.9 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.10 $ $Date: 2004/02/18 04:04:18 $\n  */\n public abstract class AbstractDiscreteDistribution\n     implements DiscreteDistribution {\n      * For this disbution, X, this method returns P(x0 &le; X &le; x1).\n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n-     * @return the cummulative probability. \n+     * @return the cumulative probability. \n      */\n-    public double cummulativeProbability(int x0, int x1) throws MathException{\n-        return cummulativeProbability(x1) - \n-            cummulativeProbability(x0 - 1);\n+    public double cumulativeProbability(int x0, int x1) throws MathException{\n+        return cumulativeProbability(x1) - \n+            cumulativeProbability(x0 - 1);\n     }\n     \n     /**\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n-    public int inverseCummulativeProbability(final double p) throws MathException{\n+    public int inverseCumulativeProbability(final double p) throws MathException{\n         if (p < 0.0 || p > 1.0) {\n             throw new IllegalArgumentException(\n                 \"p must be between 0.0 and 1.0, inclusive.\");\n         double pm;\n         while (x0 < x1) {\n             int xm = x0 + (x1 - x0) / 2;\n-            pm = cummulativeProbability(xm);\n+            pm = cumulativeProbability(xm);\n             if (pm > p) {\n                 // update x1\n                 if (xm == x1) {\n         }\n         \n         // insure x0 is the correct critical point\n-        pm = cummulativeProbability(x0);\n+        pm = cumulativeProbability(x0);\n         while (pm > p) {\n             --x0;\n-            pm = cummulativeProbability(x0);\n+            pm = cumulativeProbability(x0);\n         }\n         \n         return x0;        \n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n /**\n  * The default implementation of {@link BinomialDistribution}.\n  * \n- * @version $Revision: 1.9 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.10 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class BinomialDistributionImpl\n     extends AbstractDiscreteDistribution\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      */\n-    public double cummulativeProbability(int x) throws MathException {\n+    public double cumulativeProbability(int x) throws MathException {\n         double ret;\n         if (x < 0) {\n             ret = 0.0;\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n /**\n  * The default implementation of {@link ChiSquaredDistribution}\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.13 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class ChiSquaredDistributionImpl\n     extends AbstractContinuousDistribution\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    public double cummulativeProbability(double x) throws MathException {\n-        return getGamma().cummulativeProbability(x);\n+    public double cumulativeProbability(double x) throws MathException {\n+        return getGamma().cumulativeProbability(x);\n     }\n         \n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n     /**\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n--- a/src/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n /**\n  * Base interface for various continuous distributions.\n  * \n- * @version $Revision: 1.10 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.11 $ $Date: 2004/02/18 04:04:18 $\n  */\n public interface ContinuousDistribution {\n     /**\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    double cummulativeProbability(double x) throws MathException;\n+    double cumulativeProbability(double x) throws MathException;\n \n     /**\n      * For this disbution, X, this method returns P(x0 &lt; X &lt; x1).\n      * @param x0 the lower bound\n      * @param x1 the upper bound\n-     * @return the cummulative probability. \n+     * @return the cumulative probability. \n      */\n-    double cummulativeProbability(double x0, double x1) throws MathException;\n+    double cumulativeProbability(double x0, double x1) throws MathException;\n     \n     /**\n      * For this disbution, X, this method returns x such that P(X &lt; x) = p.\n-     * @param p the cummulative probability.\n+     * @param p the cumulative probability.\n      * @return x. \n      */\n-    double inverseCummulativeProbability(double p) throws MathException;\n+    double inverseCumulativeProbability(double p) throws MathException;\n }\n--- a/src/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n /**\n  * Base interface for various discrete distributions.\n  * \n- * @version $Revision: 1.8 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.9 $ $Date: 2004/02/18 04:04:18 $\n  */\n public interface DiscreteDistribution {\n     /**\n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      */\n-    double cummulativeProbability(int x) throws MathException;\n+    double cumulativeProbability(int x) throws MathException;\n \n     /**\n      * For this disbution, X, this method returns P(x0 &le; X &le; x1).\n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n-     * @return the cummulative probability. \n+     * @return the cumulative probability. \n      */\n-    double cummulativeProbability(int x0, int x1) throws MathException;\n+    double cumulativeProbability(int x0, int x1) throws MathException;\n     \n     /**\n      * For this disbution, X, this method returns x such that P(X &le; x) <= p.\n-     * @param p the cummulative probability.\n+     * @param p the cumulative probability.\n      * @return x. \n      */\n-    int inverseCummulativeProbability(double p) throws MathException;\n+    int inverseCumulativeProbability(double p) throws MathException;\n }\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n /**\n  * The default implementation of {@link ExponentialDistribution}\n  * \n- * @version $Revision: 1.11 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.12 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class ExponentialDistributionImpl\n     implements ExponentialDistribution, Serializable  {\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n      */\n-    public double cummulativeProbability(double x) throws MathException{\n+    public double cumulativeProbability(double x) throws MathException{\n         double ret;\n         if (x <= 0.0) {\n             ret = 0.0;\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      */\n-    public double inverseCummulativeProbability(double p) throws MathException{\n+    public double inverseCumulativeProbability(double p) throws MathException{\n         double ret;\n         \n         if (p < 0.0 || p > 1.0) {\n      * For this disbution, X, this method returns P(x0 &lt; X &lt; x1).\n      * @param x0 the lower bound\n      * @param x1 the upper bound\n-     * @return the cummulative probability. \n+     * @return the cumulative probability. \n      */\n-    public double cummulativeProbability(double x0, double x1) throws MathException{\n-        return cummulativeProbability(x1) - cummulativeProbability(x0);\n+    public double cumulativeProbability(double x0, double x1) throws MathException{\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n }\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.FDistribution}.\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.13 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class FDistributionImpl\n     extends AbstractContinuousDistribution\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    public double cummulativeProbability(double x) throws MathException {\n+    public double cumulativeProbability(double x) throws MathException {\n         double ret;\n         if (x <= 0.0) {\n             ret = 0.0;\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n     /**\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n /**\n  * The default implementation of {@link GammaDistribution}\n  * \n- * @version $Revision: 1.15 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.16 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class GammaDistributionImpl extends AbstractContinuousDistribution\n     implements GammaDistribution, Serializable  {\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution. \n      */\n-    public double cummulativeProbability(double x) throws MathException{\n+    public double cumulativeProbability(double x) throws MathException{\n         double ret;\n     \n         if (x <= 0.0) {\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n     /**\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n /**\n  * The default implementation of {@link HypergeometricDistribution}.\n  * \n- * @version $Revision: 1.8 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.9 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class HypergeometricDistributionImpl extends AbstractDiscreteDistribution\n     implements HypergeometricDistribution, Serializable \n      * @param x the value at which the PDF is evaluated.\n      * @return PDF for this distribution. \n      */\n-    public double cummulativeProbability(int x) throws MathException{\n+    public double cumulativeProbability(int x) throws MathException{\n         double ret;\n         \n         int n = getPopulationSize();\n--- a/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n-/* ====================================================================\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 2004 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowledgement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowledgement may appear in the software itself,\n- *    if and wherever such third-party acknowledgements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their name without prior written\n- *    permission of the Apache Software Foundation.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-/**\n- * Normal (Gauss) Distribution.\n- * Instances of NormalDistribution objects should be created using\n- * {@link DistributionFactory#createNormalDistribution(double, double)}.<p>\n- * \n- * References:<p>\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/NormalDistribution.html\">\n- * Normal Distribution</a></li>\n- * </ul>\n- * \n- */\n-public interface NormalDistribution extends ContinuousDistribution {\n-\t/**\n-\t * Access the mean.\n-\t * @return mean for this distribution\n-\t */\n-\tdouble getMean();\n-\t/**\n-\t * Modify the mean.\n-\t * @param mean for this distribution\n-\t */\n-\tvoid setMean(double mean);\n-\t/**\n-\t * Access the standard deviation.\n-\t * @return standard deviation for this distribution\n-\t */\n-\tdouble getStandardDeviation();\n-\t/**\n-\t * Modify the standard deviation.\n-\t * @param sd standard deviation for this distribution\n-\t */\n-\tvoid setStandardDeviation(double sd);\n-\t\n-\t/**\n-\t * Access algorithm used to calculate cummulative probability\n-\t * @return cdfAlgorithm the value of cummulative probability\n-\t */\n-\tpublic NormalCDFAlgorithm getCdfAlgorithm();\n-\n-\t/**\n-\t * Modify the algorithm used to calculate cummulative probability\n-\t * @param normalCDF the algorithm used to calculate cummulative probability\n-\t */\n-\tpublic void setCdfAlgorithm(NormalCDFAlgorithm normalCDF);\n-}\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2004 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Normal (Gauss) Distribution.\n+ * Instances of NormalDistribution objects should be created using\n+ * {@link DistributionFactory#createNormalDistribution(double, double)}.<p>\n+ * \n+ * References:<p>\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/NormalDistribution.html\">\n+ * Normal Distribution</a></li>\n+ * </ul>\n+ * \n+ */\n+public interface NormalDistribution extends ContinuousDistribution {\n+\t/**\n+\t * Access the mean.\n+\t * @return mean for this distribution\n+\t */\n+\tdouble getMean();\n+\t/**\n+\t * Modify the mean.\n+\t * @param mean for this distribution\n+\t */\n+\tvoid setMean(double mean);\n+\t/**\n+\t * Access the standard deviation.\n+\t * @return standard deviation for this distribution\n+\t */\n+\tdouble getStandardDeviation();\n+\t/**\n+\t * Modify the standard deviation.\n+\t * @param sd standard deviation for this distribution\n+\t */\n+\tvoid setStandardDeviation(double sd);\n+\t\n+\t/**\n+\t * Access algorithm used to calculate cumulative probability\n+\t * @return cdfAlgorithm the value of cumulative probability\n+\t */\n+\tpublic NormalCDFAlgorithm getCdfAlgorithm();\n+\n+\t/**\n+\t * Modify the algorithm used to calculate cumulative probability\n+\t * @param normalCDF the algorithm used to calculate cumulative probability\n+\t */\n+\tpublic void setCdfAlgorithm(NormalCDFAlgorithm normalCDF);\n+}\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n-/* ====================================================================\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 2004 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowledgement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowledgement may appear in the software itself,\n- *    if and wherever such third-party acknowledgements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their name without prior written\n- *    permission of the Apache Software Foundation.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-import java.io.Serializable;\n-\n-/**\n- * Default implementation of\n- * {@link org.apache.commons.math.distribution.NormalDistribution}.<p>\n- * You can choose the algorithm used to calculate cummulative probability\n- * using method {@link #setCdfAlgorithm}. The deafault is the Cody algorithm \n- * {@link org.apache.commons.math.distribution.NormalCDFPreciseAlgorithm}\n- */\n-public class NormalDistributionImpl extends AbstractContinuousDistribution \n-\t\timplements NormalDistribution, Serializable {\n-\tprivate double mean = 0;\n-\tprivate double standardDeviation = 1;\n-\tprivate NormalCDFAlgorithm cdfAlgorithm = new NormalCDFPreciseAlgorithm();\n-\t\n-\t/**\n-\t * Create a normal distribution using the given mean and standard deviation.\n-\t * @param mean mean for this distribution\n-\t * @param sd standard deviation for this distribution\n-\t */\n-\tpublic NormalDistributionImpl(double mean, double sd){\n-\t\tsuper();\n-\t\tsetMean(mean);\n-\t\tsetStandardDeviation(sd);\n-\t}\n-\t/**\n-\t * Creates normal distribution with the mean equal to zero and standard\n-\t * deviation equal to one. \n-\t */\n-\tpublic NormalDistributionImpl(){\n-\t\tsuper();\n-\t\tsetMean(0.0);\n-\t\tsetStandardDeviation(1.0);\n-\t}\t\n-\t/**\n-\t * Access the mean.\n-\t * @return mean for this distribution\n-\t */\t\n-\tpublic double getMean() {\n-\t\treturn mean;\n-\t}\n-\t/**\n-\t * Modify the mean.\n-\t * @param mean for this distribution\n-\t */\n-\tpublic void setMean(double mean) {\n-\t\tthis.mean = mean;\n-\t}\n-\n-\t/**\n-\t * Access the standard deviation.\n-\t * @return standard deviation for this distribution\n-\t */\n-\tpublic double getStandardDeviation() {\n-\t\treturn standardDeviation;\n-\t}\n-\n-\t/**\n-\t * Modify the standard deviation.\n-\t * @param sd standard deviation for this distribution\n-\t */\n-\tpublic void setStandardDeviation(double sd) {\n-\t\tif (sd < 0.0) {\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2004 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.NormalDistribution}.<p>\n+ * You can choose the algorithm used to calculate cumulative probability\n+ * using method {@link #setCdfAlgorithm}. The deafault is the Cody algorithm \n+ * {@link org.apache.commons.math.distribution.NormalCDFPreciseAlgorithm}\n+ */\n+public class NormalDistributionImpl extends AbstractContinuousDistribution \n+\t\timplements NormalDistribution, Serializable {\n+\tprivate double mean = 0;\n+\tprivate double standardDeviation = 1;\n+\tprivate NormalCDFAlgorithm cdfAlgorithm = new NormalCDFPreciseAlgorithm();\n+\t\n+\t/**\n+\t * Create a normal distribution using the given mean and standard deviation.\n+\t * @param mean mean for this distribution\n+\t * @param sd standard deviation for this distribution\n+\t */\n+\tpublic NormalDistributionImpl(double mean, double sd){\n+\t\tsuper();\n+\t\tsetMean(mean);\n+\t\tsetStandardDeviation(sd);\n+\t}\n+\t/**\n+\t * Creates normal distribution with the mean equal to zero and standard\n+\t * deviation equal to one. \n+\t */\n+\tpublic NormalDistributionImpl(){\n+\t\tsuper();\n+\t\tsetMean(0.0);\n+\t\tsetStandardDeviation(1.0);\n+\t}\t\n+\t/**\n+\t * Access the mean.\n+\t * @return mean for this distribution\n+\t */\t\n+\tpublic double getMean() {\n+\t\treturn mean;\n+\t}\n+\t/**\n+\t * Modify the mean.\n+\t * @param mean for this distribution\n+\t */\n+\tpublic void setMean(double mean) {\n+\t\tthis.mean = mean;\n+\t}\n+\n+\t/**\n+\t * Access the standard deviation.\n+\t * @return standard deviation for this distribution\n+\t */\n+\tpublic double getStandardDeviation() {\n+\t\treturn standardDeviation;\n+\t}\n+\n+\t/**\n+\t * Modify the standard deviation.\n+\t * @param sd standard deviation for this distribution\n+\t */\n+\tpublic void setStandardDeviation(double sd) {\n+\t\tif (sd < 0.0) {\n \t\t\tthrow new IllegalArgumentException(\"Standard deviation must be\" +\n-\t\t\t\t\"positive or zero.\");\n-\t\t}\t\t\n-\t\tstandardDeviation = sd;\n-\t}\n-\n-\t/**\n-\t * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n-\t * @param x the value at which the CDF is evaluated.\n-\t * @return CDF evaluted at <code>x</code>. \n-\t */\n-\tpublic double cummulativeProbability(double x) {\n-\t\tdouble z = x;\n-\t\tif(standardDeviation > 0){\n-\t\t\tz = (x - mean)/standardDeviation;\n-\t\t}else{\n-\t\t\treturn 0.0;\n-\t\t}\n-\t\treturn cdfAlgorithm.cdf(z);\n-\t}\n-\n-\n-\t/**\n-\t * For this distribution, X, this method returns the critical point x, such\n-\t * that P(X &lt; x) = <code>p</code>.<p>\n-\t * Provided implementation is adopted from \n-     * <a href=\"http://www.r-project.org/\">R statistical package</a> function\n-     * <code>qnorm(...)</code>.<p>\n-\t * References:\n-\t * <ul>\n-\t * <li>\n-\t *  Beasley, J. D. and S. G. Springer (1977).\n-\t *  <a href=\"http://lib.stat.cmu.edu/apstat/111\">\n-\t *\tAlgorithm AS 111: The percentage points of the normal distribution</a>,\n-\t *\tApplied Statistics, 26, 118-121.\n-\t * </li>\n-\t * <li>\n-\t *  Wichura, M.J. (1988).\n-\t *  <a href=\"http://lib.stat.cmu.edu/apstat/241\">\n-\t *  Algorithm AS 241: The Percentage Points of the Normal Distribution.</a>\n-\t *  Applied Statistics, 37, 477-484.\n-\t * </li>\n-\t * </ul>\n-\t *\n-\t * @param p the desired probability\n-\t * @return x, such that P(X &lt; x) = <code>p</code>\n-\t */\n-\tpublic double inverseCummulativeProbability(double p) {\n-\t\tif (p < 0.0 || p > 1.0) {\n-\t\t\tthrow new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n-\t\t}\n-\t\t\n-\t\t//TODO is this ok?\n-\t\tif(standardDeviation == 0){\n-\t\t\treturn mean;\n-\t\t}\n-\t\t\n-\t\tdouble r, val;\t\t\n-\t\tdouble q = p - 0.5;\n-\n-\t\tif (Math.abs(q) <= .425) {/* 0.075 <= p <= 0.925 */\n-\t\t\tr = 0.180625 - q*q;\n-\t\t\tval =\n-\t\t\t\tq * (((((((r * 2509.0809287301226727 +\n-\t\t\t\t\t\t   33430.575583588128105) * r + 67265.770927008700853) * r +\n-\t\t\t\t\t\t 45921.953931549871457) * r + 13731.693765509461125) * r +\n-\t\t\t\t\t   1971.5909503065514427) * r + 133.14166789178437745) * r +\n-\t\t\t\t\t 3.387132872796366608)\n-\t\t\t\t/ (((((((r * 5226.495278852854561 +\n-\t\t\t\t\t\t 28729.085735721942674) * r + 39307.89580009271061) * r +\n-\t\t\t\t\t   21213.794301586595867) * r + 5394.1960214247511077) * r +\n-\t\t\t\t\t 687.1870074920579083) * r + 42.313330701600911252) * r + 1.);\n-\t\t}else { //closer than 0.075 from {0,1} boundary\n-\t\tif (q > 0)\n-\t\t\tr = 1 - p;\n-\t\telse\n-\t\t\tr = p;\n-\t\tr = Math.sqrt(- Math.log(r));\n-\t\tif (r <= 5.0) {\n-\t\t\tr += -1.6;\n-\t\t\tval = (((((((r * 7.7454501427834140764e-4 +\n-\t\t\t\t\t   0.0227238449892691845833) * r + 0.24178072517745061177) *\n-\t\t\t\t\t r + 1.27045825245236838258) * r +\n-\t\t\t\t\t3.64784832476320460504) * r + 5.7694972214606914055) *\n-\t\t\t\t  r + 4.6303378461565452959) * r +\n-\t\t\t\t 1.42343711074968357734)\n-\t\t\t\t/ (((((((r *\n-\t\t\t\t\t\t 1.05075007164441684324e-9 + 5.475938084995344946e-4) *\n-\t\t\t\t\t\tr + 0.0151986665636164571966) * r +\n-\t\t\t\t\t   0.14810397642748007459) * r + 0.68976733498510000455) *\n-\t\t\t\t\t r + 1.6763848301838038494) * r +\n-\t\t\t\t\t2.05319162663775882187) * r + 1.0);\n-\t\t}else { //very close to  0 or 1\n-\t\t\tr += -5.;\n-\t\t\tval = (((((((r * 2.01033439929228813265e-7 +\n-\t\t\t\t\t   2.71155556874348757815e-5) * r +\n-\t\t\t\t\t  0.0012426609473880784386) * r + 0.026532189526576123093) *\n-\t\t\t\t\tr + 0.29656057182850489123) * r +\n-\t\t\t\t   1.7848265399172913358) * r + 5.4637849111641143699) *\n-\t\t\t\t r + 6.6579046435011037772)\n-\t\t\t\t/ (((((((r *\n-\t\t\t\t\t\t 2.04426310338993978564e-15 + 1.4215117583164458887e-7)*\n-\t\t\t\t\t\tr + 1.8463183175100546818e-5) * r +\n-\t\t\t\t\t   7.868691311456132591e-4) * r + 0.0148753612908506148525)\n-\t\t\t\t\t * r + 0.13692988092273580531) * r +\n-\t\t\t\t\t0.59983220655588793769) * r + 1.0);\n-\t\t}\n-\t\tif(q < 0.0)\n-\t\t\tval = -val;\n-\t\t}\n-\t\treturn mean + standardDeviation*val;\n-\t}\n-\n-\n-\t/**\n-\t * Access algorithm used to calculate cummulative probability\n-\t * @return cdfAlgorithm the value of cummulative probability\n-\t */\n-\tpublic NormalCDFAlgorithm getCdfAlgorithm() {\n-\t\treturn cdfAlgorithm;\n-\t}\n-\n-\n-\t/**\n-\t * Modify the algorithm used to calculate cummulative probability\n-\t * @param normalCDF the algorithm used to calculate cummulative probability\n-\t */\n-\tpublic void setCdfAlgorithm(NormalCDFAlgorithm normalCDF) {\n-\t\tcdfAlgorithm = normalCDF;\n-\t}\n-\n-\t\n-\t/**\n-\t * Access the domain value lower bound, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCummulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return domain value lower bound, i.e.\n-\t *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n-\t */\n-\tprotected double getDomainLowerBound(double p) {\n-\t\treturn -Double.MAX_VALUE;\n-\t}\n-\n-\t/**\n-\t * Access the domain value upper bound, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCummulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return domain value upper bound, i.e.\n-\t *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n-\t */\n-\tprotected double getDomainUpperBound(double p) {\n-\t\treturn Double.MAX_VALUE;\n-\t}\n-\n-\t/**\n-\t * Access the initial domain value, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCummulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return initial domain value\n-\t */\n-\tprotected double getInitialDomain(double p) {\n-\t\treturn 0.0;\n-\t}\n-\n-\n-}\n+\t\t\t\t\"positive or zero.\");\n+\t\t}\t\t\n+\t\tstandardDeviation = sd;\n+\t}\n+\n+\t/**\n+\t * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n+\t * @param x the value at which the CDF is evaluated.\n+\t * @return CDF evaluted at <code>x</code>. \n+\t */\n+\tpublic double cumulativeProbability(double x) {\n+\t\tdouble z = x;\n+\t\tif(standardDeviation > 0){\n+\t\t\tz = (x - mean)/standardDeviation;\n+\t\t}else{\n+\t\t\treturn 0.0;\n+\t\t}\n+\t\treturn cdfAlgorithm.cdf(z);\n+\t}\n+\n+\n+\t/**\n+\t * For this distribution, X, this method returns the critical point x, such\n+\t * that P(X &lt; x) = <code>p</code>.<p>\n+\t * Provided implementation is adopted from \n+     * <a href=\"http://www.r-project.org/\">R statistical package</a> function\n+     * <code>qnorm(...)</code>.<p>\n+\t * References:\n+\t * <ul>\n+\t * <li>\n+\t *  Beasley, J. D. and S. G. Springer (1977).\n+\t *  <a href=\"http://lib.stat.cmu.edu/apstat/111\">\n+\t *\tAlgorithm AS 111: The percentage points of the normal distribution</a>,\n+\t *\tApplied Statistics, 26, 118-121.\n+\t * </li>\n+\t * <li>\n+\t *  Wichura, M.J. (1988).\n+\t *  <a href=\"http://lib.stat.cmu.edu/apstat/241\">\n+\t *  Algorithm AS 241: The Percentage Points of the Normal Distribution.</a>\n+\t *  Applied Statistics, 37, 477-484.\n+\t * </li>\n+\t * </ul>\n+\t *\n+\t * @param p the desired probability\n+\t * @return x, such that P(X &lt; x) = <code>p</code>\n+\t */\n+\tpublic double inverseCumulativeProbability(double p) {\n+\t\tif (p < 0.0 || p > 1.0) {\n+\t\t\tthrow new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n+\t\t}\n+\t\t\n+\t\t//TODO is this ok?\n+\t\tif(standardDeviation == 0){\n+\t\t\treturn mean;\n+\t\t}\n+\t\t\n+\t\tdouble r, val;\t\t\n+\t\tdouble q = p - 0.5;\n+\n+\t\tif (Math.abs(q) <= .425) {/* 0.075 <= p <= 0.925 */\n+\t\t\tr = 0.180625 - q*q;\n+\t\t\tval =\n+\t\t\t\tq * (((((((r * 2509.0809287301226727 +\n+\t\t\t\t\t\t   33430.575583588128105) * r + 67265.770927008700853) * r +\n+\t\t\t\t\t\t 45921.953931549871457) * r + 13731.693765509461125) * r +\n+\t\t\t\t\t   1971.5909503065514427) * r + 133.14166789178437745) * r +\n+\t\t\t\t\t 3.387132872796366608)\n+\t\t\t\t/ (((((((r * 5226.495278852854561 +\n+\t\t\t\t\t\t 28729.085735721942674) * r + 39307.89580009271061) * r +\n+\t\t\t\t\t   21213.794301586595867) * r + 5394.1960214247511077) * r +\n+\t\t\t\t\t 687.1870074920579083) * r + 42.313330701600911252) * r + 1.);\n+\t\t}else { //closer than 0.075 from {0,1} boundary\n+\t\tif (q > 0)\n+\t\t\tr = 1 - p;\n+\t\telse\n+\t\t\tr = p;\n+\t\tr = Math.sqrt(- Math.log(r));\n+\t\tif (r <= 5.0) {\n+\t\t\tr += -1.6;\n+\t\t\tval = (((((((r * 7.7454501427834140764e-4 +\n+\t\t\t\t\t   0.0227238449892691845833) * r + 0.24178072517745061177) *\n+\t\t\t\t\t r + 1.27045825245236838258) * r +\n+\t\t\t\t\t3.64784832476320460504) * r + 5.7694972214606914055) *\n+\t\t\t\t  r + 4.6303378461565452959) * r +\n+\t\t\t\t 1.42343711074968357734)\n+\t\t\t\t/ (((((((r *\n+\t\t\t\t\t\t 1.05075007164441684324e-9 + 5.475938084995344946e-4) *\n+\t\t\t\t\t\tr + 0.0151986665636164571966) * r +\n+\t\t\t\t\t   0.14810397642748007459) * r + 0.68976733498510000455) *\n+\t\t\t\t\t r + 1.6763848301838038494) * r +\n+\t\t\t\t\t2.05319162663775882187) * r + 1.0);\n+\t\t}else { //very close to  0 or 1\n+\t\t\tr += -5.;\n+\t\t\tval = (((((((r * 2.01033439929228813265e-7 +\n+\t\t\t\t\t   2.71155556874348757815e-5) * r +\n+\t\t\t\t\t  0.0012426609473880784386) * r + 0.026532189526576123093) *\n+\t\t\t\t\tr + 0.29656057182850489123) * r +\n+\t\t\t\t   1.7848265399172913358) * r + 5.4637849111641143699) *\n+\t\t\t\t r + 6.6579046435011037772)\n+\t\t\t\t/ (((((((r *\n+\t\t\t\t\t\t 2.04426310338993978564e-15 + 1.4215117583164458887e-7)*\n+\t\t\t\t\t\tr + 1.8463183175100546818e-5) * r +\n+\t\t\t\t\t   7.868691311456132591e-4) * r + 0.0148753612908506148525)\n+\t\t\t\t\t * r + 0.13692988092273580531) * r +\n+\t\t\t\t\t0.59983220655588793769) * r + 1.0);\n+\t\t}\n+\t\tif(q < 0.0)\n+\t\t\tval = -val;\n+\t\t}\n+\t\treturn mean + standardDeviation*val;\n+\t}\n+\n+\n+\t/**\n+\t * Access algorithm used to calculate cumulative probability\n+\t * @return cdfAlgorithm the value of cumulative probability\n+\t */\n+\tpublic NormalCDFAlgorithm getCdfAlgorithm() {\n+\t\treturn cdfAlgorithm;\n+\t}\n+\n+\n+\t/**\n+\t * Modify the algorithm used to calculate cumulative probability\n+\t * @param normalCDF the algorithm used to calculate cumulative probability\n+\t */\n+\tpublic void setCdfAlgorithm(NormalCDFAlgorithm normalCDF) {\n+\t\tcdfAlgorithm = normalCDF;\n+\t}\n+\n+\t\n+\t/**\n+\t * Access the domain value lower bound, based on <code>p</code>, used to\n+\t * bracket a CDF root.  This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p the desired probability for the critical value\n+\t * @return domain value lower bound, i.e.\n+\t *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+\t */\n+\tprotected double getDomainLowerBound(double p) {\n+\t\treturn -Double.MAX_VALUE;\n+\t}\n+\n+\t/**\n+\t * Access the domain value upper bound, based on <code>p</code>, used to\n+\t * bracket a CDF root.  This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p the desired probability for the critical value\n+\t * @return domain value upper bound, i.e.\n+\t *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+\t */\n+\tprotected double getDomainUpperBound(double p) {\n+\t\treturn Double.MAX_VALUE;\n+\t}\n+\n+\t/**\n+\t * Access the initial domain value, based on <code>p</code>, used to\n+\t * bracket a CDF root.  This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p the desired probability for the critical value\n+\t * @return initial domain value\n+\t */\n+\tprotected double getInitialDomain(double p) {\n+\t\treturn 0.0;\n+\t}\n+\n+\n+}\n--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.TDistribution}.\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/01/29 00:48:58 $\n+ * @version $Revision: 1.13 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class TDistributionImpl\n     extends AbstractContinuousDistribution\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF evaluted at <code>x</code>. \n      */\n-    public double cummulativeProbability(double x) throws MathException{\n+    public double cumulativeProbability(double x) throws MathException{\n         double ret;\n         if (x == 0.0) {\n             ret = 0.5;\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n     /**\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(double)} to find critical values.\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n--- a/src/java/org/apache/commons/math/stat/BivariateRegression.java\n+++ b/src/java/org/apache/commons/math/stat/BivariateRegression.java\n  * the necessary computations to return the requested statistic.</li>\n  * </ul>\n  *\n- * @version $Revision: 1.12 $ $Date: 2004/01/29 00:49:01 $\n+ * @version $Revision: 1.13 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class BivariateRegression implements Serializable {\n \n             throw new IllegalArgumentException();\n         }\n         return getSlopeStdErr()\n-            * getTDistribution().inverseCummulativeProbability(1d - alpha / 2d);\n+            * getTDistribution().inverseCumulativeProbability(1d - alpha / 2d);\n     }\n \n     /**\n     public double getSignificance() throws MathException {\n         return (\n             1d\n-                - getTDistribution().cummulativeProbability(\n+                - getTDistribution().cumulativeProbability(\n                     Math.abs(getSlope()) / getSlopeStdErr()));\n     }\n \n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n  * The values are ordered using the default (natural order), unless a  <code>Comparator</code>\n  *  is supplied in the constructor.\n  * \n- * @version $Revision: 1.13 $ $Date: 2004/02/16 06:32:47 $\n+ * @version $Revision: 1.14 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class Frequency implements Serializable {\n     \n     //-----------------------------------------------------------------------------------------\n     \n     /**\n-     * Returns the cummulative frequency of values less than or equal to v.\n+     * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n     }\n     \n      /**\n-     * Returns the cummulative frequency of values less than or equal to v.\n+     * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n     }\n     \n      /**\n-     * Returns the cummulative frequency of values less than or equal to v.\n+     * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n     }\n     \n     /**\n-     * Returns the cummulative frequency of values less than or equal to v.\n+     * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n      * \n     //----------------------------------------------------------------------------------------------\n     \n      /**\n-     * Returns the cummulative percentatge of values less than or equal to v\n+     * Returns the cumulative percentatge of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n     }\n     \n     /**\n-     * Returns the cummulative percentatge of values less than or equal to v\n+     * Returns the cumulative percentatge of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n     }\n     \n     /**\n-     * Returns the cummulative percentatge of values less than or equal to v\n+     * Returns the cumulative percentatge of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n     }\n     \n     /**\n-     * Returns the cummulative percentatge of values less than or equal to v\n+     * Returns the cumulative percentatge of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns 0 if v is not comparable to the values set.\n--- a/src/java/org/apache/commons/math/stat/TestStatisticImpl.java\n+++ b/src/java/org/apache/commons/math/stat/TestStatisticImpl.java\n /**\n  * Implements test statistics defined in the TestStatistic interface.\n  *\n- * @version $Revision: 1.11 $ $Date: 2004/01/25 21:30:41 $\n+ * @version $Revision: 1.12 $ $Date: 2004/02/18 04:04:18 $\n  */\n public class TestStatisticImpl implements TestStatistic, Serializable {\n \n             DistributionFactory.newInstance().createChiSquareDistribution(\n                 (double) expected.length - 1);\n         return 1\n-            - chiSquaredDistribution.cummulativeProbability(\n+            - chiSquaredDistribution.cumulativeProbability(\n                 chiSquare(expected, observed));\n     }\n \n         TDistribution tDistribution =\n             DistributionFactory.newInstance().createTDistribution(\n                 df(v1, v2, n1, n2));\n-        return 1.0 - tDistribution.cummulativeProbability(-t, t);\n+        return 1.0 - tDistribution.cumulativeProbability(-t, t);\n     }\n \n     /**\n         double t = Math.abs(t(m, mu, v, n));\n         TDistribution tDistribution =\n             DistributionFactory.newInstance().createTDistribution(n - 1);\n-        return 1.0 - tDistribution.cummulativeProbability(-t, t);\n+        return 1.0 - tDistribution.cumulativeProbability(-t, t);\n     }\n }\n--- a/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/BinomialDistributionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.10 $ $Date: 2004/01/29 00:48:59 $\n+ * @version $Revision: 1.11 $ $Date: 2004/02/18 04:04:17 $\n  */\n public class BinomialDistributionTest extends TestCase {\n     private BinomialDistribution b;\n         super.tearDown();\n     }\n \n-    public void testInverseCummulativeProbability001() {\n+    public void testInverseCumulativeProbability001() {\n         testValue(1, .001);\n     }\n \n         testValue(4, .100);\n     }\n \n-    public void testInverseCummulativeProbability999() {\n+    public void testInverseCumulativeProbability999() {\n         testValue(9, .999);\n     }\n \n         testValue(8, .900);\n     }\n \n-    public void testCummulativeProbability1() {\n+    public void testCumulativeProbability1() {\n         testProbability(1, .00014);\n     }\n \n         testProbability(9, .97175);\n     }\n \n-    public void testCummulativeProbability8() {\n+    public void testcumulativeProbability8() {\n         testProbability(8, .85069);\n     }\n \n     private void testProbability(int x, double expected) {\n         try {\n-            double actual = b.cummulativeProbability(x);\n+            double actual = b.cumulativeProbability(x);\n             assertEquals(expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n \n     private void testValue(int expected, double p) {\n         try {\n-            int actual = b.inverseCummulativeProbability(p);\n+            int actual = b.inverseCumulativeProbability(p);\n             assertEquals(expected, actual);\n-            assertTrue(b.cummulativeProbability(actual) <= p);\n-            assertTrue(b.cummulativeProbability(actual + 1) >= p);\n+            assertTrue(b.cumulativeProbability(actual) <= p);\n+            assertTrue(b.cumulativeProbability(actual + 1) >= p);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n             e.printStackTrace();\n--- a/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.11 $ $Date: 2004/01/29 00:48:59 $\n+ * @version $Revision: 1.12 $ $Date: 2004/02/18 04:04:17 $\n  */\n public class ChiSquareDistributionTest extends TestCase {\n     private ChiSquaredDistribution chiSquare;\n     \n     private void testProbability(double x, double expected){\n         try {\n-            double actual = chiSquare.cummulativeProbability(x);\n+            double actual = chiSquare.cumulativeProbability(x);\n             assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n         } catch (MathException e) {\n             e.printStackTrace();\n     \n     private void testValue(double p, double expected){\n         try {\n-            double actual = chiSquare.inverseCummulativeProbability(p);\n+            double actual = chiSquare.inverseCumulativeProbability(p);\n             assertEquals(\"value for \" + p, expected, actual, 10e-4);\n         } catch (MathException e) {\n             e.printStackTrace();\n--- a/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.10 $ $Date: 2004/01/29 00:48:59 $\n+ * @version $Revision: 1.11 $ $Date: 2004/02/18 04:04:17 $\n  */\n public class ExponentialDistributionTest extends TestCase {\n     private ExponentialDistribution exp;\n         super.tearDown();\n     }\n \n-    public void testInverseCummulativeProbability001() {\n+    public void testInverseCumulativeProbability001() {\n         testValue(.005003, .001);\n     }\n \n-    public void testInverseCummulativeProbability010() {\n+    public void testInverseCumulativeProbability010() {\n         testValue(0.050252, .010);\n     }\n \n-    public void testInverseCummulativeProbability025() {\n+    public void testInverseCumulativeProbability025() {\n         testValue(0.126589, .025);\n     }\n \n-    public void testInverseCummulativeProbability050() {\n+    public void testInverseCumulativeProbability050() {\n         testValue(0.256566, .050);\n     }\n \n-    public void testInverseCummulativeProbability100() {\n+    public void testInverseCumulativeProbability100() {\n         testValue(0.526803, .100);\n     }\n \n-    public void testInverseCummulativeProbability999() {\n+    public void testInverseCumulativeProbability999() {\n         testValue(34.5388, .999);\n     }\n \n-    public void testInverseCummulativeProbability990() {\n+    public void testInverseCumulativeProbability990() {\n         testValue(23.0259, .990);\n     }\n \n-    public void testInverseCummulativeProbability975() {\n+    public void testInverseCumulativeProbability975() {\n         testValue(18.4444, .975);\n     }\n \n-    public void testInverseCummulativeProbability950() {\n+    public void testInverseCumulativeProbability950() {\n         testValue(14.9787, .950);\n     }\n \n-    public void testInverseCummulativeProbability900() {\n+    public void testInverseCumulativeProbability900() {\n         testValue(11.5129, .900);\n     }\n \n-    public void testCummulativeProbability001() {\n+    public void testCumulativeProbability001() {\n         testProbability(0.005003, .001);\n     }\n \n-    public void testCummulativeProbability010() {\n+    public void testCumulativeProbability010() {\n         testProbability(0.050252, .010);\n     }\n \n-    public void testCummulativeProbability025() {\n+    public void testCumulativeProbability025() {\n         testProbability(0.126589, .025);\n     }\n \n-    public void testCummulativeProbability050() {\n+    public void testCumulativeProbability050() {\n         testProbability(0.256566, .050);\n     }\n \n-    public void testCummulativeProbability100() {\n+    public void testCumulativeProbability100() {\n         testProbability(0.526803, .100);\n     }\n \n-    public void testCummulativeProbability999() {\n+    public void testCumulativeProbability999() {\n         testProbability(34.5388, .999);\n     }\n \n-    public void testCummulativeProbability990() {\n+    public void testCumulativeProbability990() {\n         testProbability(23.0259, .990);\n     }\n \n-    public void testCummulativeProbability975() {\n+    public void testCumulativeProbability975() {\n         testProbability(18.4444, .975);\n     }\n \n-    public void testCummulativeProbability950() {\n+    public void testCumulativeProbability950() {\n         testProbability(14.9787, .950);\n     }\n \n-    public void testCummulativeProbability900() {\n+    public void testCumulativeProbability900() {\n         testProbability(11.5129, .900);\n     }\n \n-    public void testCummulativeProbabilityNegative() {\n+    public void testCumulativeProbabilityNegative() {\n         testProbability(-1.0, 0.0);\n     }\n \n-    public void testCummulativeProbabilityZero() {\n+    public void testCumulativeProbabilityZero() {\n         testProbability(0.0, 0.0);\n     }\n \n-    public void testInverseCummulativeProbabilityNegative() {\n+    public void testInverseCumulativeProbabilityNegative() {\n         testValue(Double.NaN, -1.0);\n     }\n \n-    public void testInverseCummulativeProbabilityZero() {\n+    public void testInverseCumulativeProbabilityZero() {\n         testValue(0.0, 0.0);\n     }\n \n-    public void testInverseCummulativeProbabilityOne() {\n+    public void testInverseCumulativeProbabilityOne() {\n         testValue(Double.POSITIVE_INFINITY, 1.0);\n     }\n \n-    public void testInverseCummulativeProbabilityPositive() {\n+    public void testInverseCumulativeProbabilityPositive() {\n         testValue(Double.NaN, 2.0);\n     }\n \n-    public void testCummulativeProbability2() {\n+    public void testCumulativeProbability2() {\n         try {\n-            double actual = exp.cummulativeProbability(0.25, 0.75);\n+            double actual = exp.cumulativeProbability(0.25, 0.75);\n             assertEquals(0.0905214, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n \n     private void testProbability(double x, double expected) {\n         try {\n-            double actual = exp.cummulativeProbability(x);\n+            double actual = exp.cumulativeProbability(x);\n             TestUtils.assertEquals(expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n \n     private void testValue(double expected, double p) {\n         try {\n-            double actual = exp.inverseCummulativeProbability(p);\n+            double actual = exp.inverseCumulativeProbability(p);\n             TestUtils.assertEquals(expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n--- a/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.9 $ $Date: 2004/01/29 00:48:59 $\n+ * @version $Revision: 1.10 $ $Date: 2004/02/18 04:04:17 $\n  */\n public class FDistributionTest extends TestCase {\n     private FDistribution f;\n \n     private void testProbability(double x, double expected) {\n         try {\n-            double actual = f.cummulativeProbability(x);\n+            double actual = f.cumulativeProbability(x);\n             assertEquals(\"probability for \" + x, expected, actual, 1e-3);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n \n     private void testValue(double expected, double p) {\n         try {\n-            double actual = f.inverseCummulativeProbability(p);\n+            double actual = f.inverseCumulativeProbability(p);\n             assertEquals(\"value for \" + p, expected, actual, 1e-2);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n--- a/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.12 $ $Date: 2004/01/29 00:48:59 $\n+ * @version $Revision: 1.13 $ $Date: 2004/02/18 04:04:17 $\n  */\n public class GammaDistributionTest extends TestCase {\n     public void testProbabilities() {\n                 DistributionFactory\n                     .newInstance()\n                     .createGammaDistribution(a, b)\n-                    .cummulativeProbability(x);\n+                    .cumulativeProbability(x);\n             assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n                 DistributionFactory\n                     .newInstance()\n                     .createGammaDistribution(a, b)\n-                    .inverseCummulativeProbability(p);\n+                    .inverseCumulativeProbability(p);\n             assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n--- a/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.8 $ $Date: 2004/01/29 00:48:59 $\n+ * @version $Revision: 1.9 $ $Date: 2004/02/18 04:04:17 $\n  */\n public class HypergeometricDistributionTest extends TestCase {\n     private HypergeometricDistribution h;\n         super.tearDown();\n     }\n \n-    public void testInverseCummulativeProbability001() {\n+    public void testInverseCumulativeProbability001() {\n         testValue(-1, .001);\n     }\n \n         testValue(0, .100);\n     }\n \n-    public void testInverseCummulativeProbability999() {\n+    public void testInverseCumulativeProbability999() {\n         testValue(4, .999);\n     }\n \n         testValue(3, .900);\n     }\n \n-    public void testCummulativeProbability0() {\n+    public void testCumulativeProbability0() {\n         testProbability(0, .00400);\n     }\n \n-    public void testCummulativeProbability1() {\n+    public void testCumulativeProbability1() {\n         testProbability(1, .10318);\n     }\n \n \n     private void testProbability(int x, double expected) {\n         try {\n-            double actual = h.cummulativeProbability(x);\n+            double actual = h.cumulativeProbability(x);\n             assertEquals(expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n \n     private void testValue(int expected, double p) {\n         try {\n-            int actual = h.inverseCummulativeProbability(p);\n+            int actual = h.inverseCumulativeProbability(p);\n             assertEquals(expected, actual);\n-            assertTrue(h.cummulativeProbability(actual) <= p);\n-            assertTrue(h.cummulativeProbability(actual + 1) >= p);\n+            assertTrue(h.cumulativeProbability(actual) <= p);\n+            assertTrue(h.cumulativeProbability(actual + 1) >= p);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n             e.printStackTrace();\n--- a/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n-/* ====================================================================\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 2004 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * \n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowledgement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowledgement may appear in the software itself,\n- *    if and wherever such third-party acknowledgements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their name without prior written\n- *    permission of the Apache Software Foundation.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-import org.apache.commons.math.MathException;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- *  Tests for NormalDistribution implementation\n- * \n- * \"True\" results are taken from R - the same as in Mathematica\n- *\n- */\n-public class NormalDistributionTest extends TestCase {\n-\t\n-\tprivate NormalDistribution z;\n-\tprivate static final double PRECISION = 10e-6;\t\n-\tprivate static final double M = 2.1;\n-\tprivate static final double SD = 1.4;\n-\t\n-\t/**\n-\t * Constructor for NormalDistributionTest.\n-\t * @param arg0\n-\t */\n-\tpublic NormalDistributionTest(String arg0) {\n-\t\tsuper(arg0);\n-\t}\n-\n-\tpublic static void main(String[] args) {\n-\t\tjunit.swingui.TestRunner.run(NormalDistributionTest.class);\n-\t}\n-\n-\tprotected void setUp() throws Exception {\n-\t\tsuper.setUp();\n-\t\tz = DistributionFactory.newInstance().createNormalDistribution(M, SD);\n-\t}\n-\n-\tprotected void tearDown() throws Exception {\n-\t\tsuper.tearDown();\n-\t\tz = null;\n-\t}\n-\n-\tpublic void testCummulativeProbabilitydoubleM_MINUS_2SD() throws MathException {\n-\t\ttestProbability(M - 2*SD, 0.02275013);\n-\t}\n-\n-\tpublic void testCummulativeProbabilitydoubleM_MINUS_SD() throws MathException {\n-\t\ttestProbability(M - SD, 0.1586553);\n-\t}\n-\n-\tpublic void testCummulativeProbabilitydoubleM() throws MathException {\n-\t\ttestProbability(M, 0.5);\n-\t}\n-\n-\tpublic void testCummulativeProbabilitydoubleM_PLUS_SD() throws MathException {\n-\t\ttestProbability(M + SD, 0.8413447);\n-\t}\n-\t\n-\tpublic void testCummulativeProbabilitydoubleM_PLUS_2SD() throws MathException {\n-\t\ttestProbability(M + 2*SD, 0.9772499);\n-\t}\n-\t\n-\tpublic void testCummulativeProbabilitydoubleM_PLUS_3SD() throws MathException {\n-\t\ttestProbability(M + 3*SD, 0.9986501);\n-\t}\n-\t\n-\tpublic void testCummulativeProbabilitydoubleM_PLUS_4SD() throws MathException {\n-\t\ttestProbability(M + 4*SD, 0.9999683);\n-\t}\n-\t\n-\tpublic void testCummulativeProbabilitydoubleM_PLUS_5SD() throws MathException {\n-\t\ttestProbability(M + 5*SD, 0.9999997);\n-\t}\n-\t\n-\tpublic void testInverseCummulativeProbability0() throws MathException {\n-\t\tassertEquals(Double.isNaN(z.inverseCummulativeProbability(0.0)), true);\n-\t}\n-\n-\tpublic void testInverseCummulativeProbability001() throws MathException {\n-\t\ttestValue(-2.226325, .001);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability010() throws MathException{\n-\t\ttestValue(-1.156887, .010);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability025() throws MathException{\n-\t\ttestValue(-0.6439496, .025);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability050() throws MathException{\n-\t\ttestValue(-0.2027951, .050);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability100() throws MathException{\n-\t\ttestValue(0.3058278, .100);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability900() throws MathException{\n-\t\ttestValue(3.894172, .900);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability950() throws MathException{\n-\t\ttestValue(4.402795, .950);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability975() throws MathException{\n-\t\ttestValue(4.84395, .975);\n-\t}\n-\n-\tpublic void testInverseCumulativeProbability990() throws MathException{\n-\t\ttestValue(5.356887, .990);\n-\t}\n-\n-\tpublic void testInverseCummulativeProbability999() throws MathException{\n-\t\ttestValue(6.426325, .999);\n-\t}\n-\n-\tpublic void testInverseCummulativeProbability1() throws MathException {\n-\t\tassertEquals(Double.isNaN(z.inverseCummulativeProbability(1.0)), true);\n-\t}\n-\n-\tpublic void testGetMean() {\n-\t\tassertEquals(M, z.getMean(), 0);\n-\t}\n-\n-\tpublic void testSetMean() throws MathException {\n-\t\tdouble mu = Math.random();\n-\t\tz.setMean(mu);\n-\t\tassertEquals(mu, z.getMean(), 0);\n-\t\tassertEquals(0.5d, z.cummulativeProbability(mu), PRECISION);\n-\t}\n-\n-\tpublic void testGetStandardDeviation() {\n-\t\tassertEquals(SD, z.getStandardDeviation(), 0);\t\n-\t}\n-\n-\tpublic void testSetStandardDeviation() throws MathException{\n-\t\tdouble sigma = 0.1d + Math.random();\n-\t\tz.setStandardDeviation(sigma);\n-\t\tassertEquals(sigma, z.getStandardDeviation(), 0);\n-\t\tassertEquals(0.84134475, z.cummulativeProbability(z.getMean() + z.getStandardDeviation()), PRECISION );\n-\t}\n-\n-\tpublic void testGetCdfAlgorithm() {\n-\t\tassertTrue(z.getCdfAlgorithm() != null);\n-\t}\n-\n-\tpublic void testSetCdfAlgorithm() {\n-\t\tz.setCdfAlgorithm(new NormalCDFFastAlgorithm());\n-\t\tassertTrue(z.getCdfAlgorithm() instanceof NormalCDFFastAlgorithm);\n-\t}\n-\t\n-\tprivate void testProbability(double x, double expected) throws MathException {\n-\t\tdouble actual = Double.NaN;\n-\t\tz.setCdfAlgorithm(new NormalCDFPreciseAlgorithm());\n-\t\tactual =  z.cummulativeProbability(x);\n-\t\tassertEquals(expected, actual, PRECISION);\n-\t\tz.setCdfAlgorithm(new NormalCDFFastAlgorithm());\n-\t\tactual =  z.cummulativeProbability(x);\n-\t\tassertEquals(expected, actual, PRECISION);\n-\t}\n-\n-\tprivate void testValue(double expected, double p) throws MathException {\n-\t\tdouble actual = z.inverseCummulativeProbability(p);\n-\t\tassertEquals(expected, actual, PRECISION);\n-\t}\n-\n-}\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2004 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their name without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ *  Tests for NormalDistribution implementation\n+ * \n+ * \"True\" results are taken from R - the same as in Mathematica\n+ *\n+ */\n+public class NormalDistributionTest extends TestCase {\n+\t\n+\tprivate NormalDistribution z;\n+\tprivate static final double PRECISION = 10e-6;\t\n+\tprivate static final double M = 2.1;\n+\tprivate static final double SD = 1.4;\n+\t\n+\t/**\n+\t * Constructor for NormalDistributionTest.\n+\t * @param arg0\n+\t */\n+\tpublic NormalDistributionTest(String arg0) {\n+\t\tsuper(arg0);\n+\t}\n+\n+\tpublic static void main(String[] args) {\n+\t\tjunit.swingui.TestRunner.run(NormalDistributionTest.class);\n+\t}\n+\n+\tprotected void setUp() throws Exception {\n+\t\tsuper.setUp();\n+\t\tz = DistributionFactory.newInstance().createNormalDistribution(M, SD);\n+\t}\n+\n+\tprotected void tearDown() throws Exception {\n+\t\tsuper.tearDown();\n+\t\tz = null;\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM_MINUS_2SD() throws MathException {\n+\t\ttestProbability(M - 2*SD, 0.02275013);\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM_MINUS_SD() throws MathException {\n+\t\ttestProbability(M - SD, 0.1586553);\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM() throws MathException {\n+\t\ttestProbability(M, 0.5);\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_SD() throws MathException {\n+\t\ttestProbability(M + SD, 0.8413447);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_2SD() throws MathException {\n+\t\ttestProbability(M + 2*SD, 0.9772499);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_3SD() throws MathException {\n+\t\ttestProbability(M + 3*SD, 0.9986501);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_4SD() throws MathException {\n+\t\ttestProbability(M + 4*SD, 0.9999683);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_5SD() throws MathException {\n+\t\ttestProbability(M + 5*SD, 0.9999997);\n+\t}\n+\t\n+\tpublic void testInverseCumulativeProbability0() throws MathException {\n+\t\tassertEquals(Double.isNaN(z.inverseCumulativeProbability(0.0)), true);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability001() throws MathException {\n+\t\ttestValue(-2.226325, .001);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability010() throws MathException{\n+\t\ttestValue(-1.156887, .010);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability025() throws MathException{\n+\t\ttestValue(-0.6439496, .025);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability050() throws MathException{\n+\t\ttestValue(-0.2027951, .050);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability100() throws MathException{\n+\t\ttestValue(0.3058278, .100);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability900() throws MathException{\n+\t\ttestValue(3.894172, .900);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability950() throws MathException{\n+\t\ttestValue(4.402795, .950);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability975() throws MathException{\n+\t\ttestValue(4.84395, .975);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability990() throws MathException{\n+\t\ttestValue(5.356887, .990);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability999() throws MathException{\n+\t\ttestValue(6.426325, .999);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability1() throws MathException {\n+\t\tassertEquals(Double.isNaN(z.inverseCumulativeProbability(1.0)), true);\n+\t}\n+\n+\tpublic void testGetMean() {\n+\t\tassertEquals(M, z.getMean(), 0);\n+\t}\n+\n+\tpublic void testSetMean() throws MathException {\n+\t\tdouble mu = Math.random();\n+\t\tz.setMean(mu);\n+\t\tassertEquals(mu, z.getMean(), 0);\n+\t\tassertEquals(0.5d, z.cumulativeProbability(mu), PRECISION);\n+\t}\n+\n+\tpublic void testGetStandardDeviation() {\n+\t\tassertEquals(SD, z.getStandardDeviation(), 0);\t\n+\t}\n+\n+\tpublic void testSetStandardDeviation() throws MathException{\n+\t\tdouble sigma = 0.1d + Math.random();\n+\t\tz.setStandardDeviation(sigma);\n+\t\tassertEquals(sigma, z.getStandardDeviation(), 0);\n+\t\tassertEquals(0.84134475, z.cumulativeProbability(z.getMean() + z.getStandardDeviation()), PRECISION );\n+\t}\n+\n+\tpublic void testGetCdfAlgorithm() {\n+\t\tassertTrue(z.getCdfAlgorithm() != null);\n+\t}\n+\n+\tpublic void testSetCdfAlgorithm() {\n+\t\tz.setCdfAlgorithm(new NormalCDFFastAlgorithm());\n+\t\tassertTrue(z.getCdfAlgorithm() instanceof NormalCDFFastAlgorithm);\n+\t}\n+\t\n+\tprivate void testProbability(double x, double expected) throws MathException {\n+\t\tdouble actual = Double.NaN;\n+\t\tz.setCdfAlgorithm(new NormalCDFPreciseAlgorithm());\n+\t\tactual =  z.cumulativeProbability(x);\n+\t\tassertEquals(expected, actual, PRECISION);\n+\t\tz.setCdfAlgorithm(new NormalCDFFastAlgorithm());\n+\t\tactual =  z.cumulativeProbability(x);\n+\t\tassertEquals(expected, actual, PRECISION);\n+\t}\n+\n+\tprivate void testValue(double expected, double p) throws MathException {\n+\t\tdouble actual = z.inverseCumulativeProbability(p);\n+\t\tassertEquals(expected, actual, PRECISION);\n+\t}\n+\n+}\n--- a/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.10 $ $Date: 2004/01/29 00:48:59 $\n+ * @version $Revision: 1.11 $ $Date: 2004/02/18 04:04:17 $\n  */\n public class TDistributionTest extends TestCase {\n     private TDistribution t;\n         super.tearDown();\n     }\n \n-    public void testInverseCummulativeProbability001() {\n+    public void testInverseCumulativeProbability001() {\n         testValue(-5.893, .001);\n     }\n \n         testValue(-1.476, .100);\n     }\n \n-    public void testInverseCummulativeProbability999() {\n+    public void testInverseCumulativeProbability999() {\n         testValue(5.893, .999);\n     }\n \n         testValue(1.476, .900);\n     }\n \n-    public void testCummulativeProbability001() {\n+    public void testCumulativeProbability001() {\n         testProbability(-5.893, .001);\n     }\n \n         testProbability(-1.476, .100);\n     }\n \n-    public void testCummulativeProbability999() {\n+    public void testCumulativeProbability999() {\n         testProbability(5.893, .999);\n     }\n \n \n     private void testProbability(double x, double expected) {\n         try {\n-            double actual = t.cummulativeProbability(x);\n+            double actual = t.cumulativeProbability(x);\n             assertEquals(expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n \n     private void testValue(double expected, double p) {\n         try {\n-            double actual = t.inverseCummulativeProbability(p);\n+            double actual = t.inverseCumulativeProbability(p);\n             assertEquals(expected, actual, 10e-4);\n         } catch (MathException e) {\n             // TODO Auto-generated catch block\n--- a/src/test/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/org/apache/commons/math/stat/FrequencyTest.java\n /**\n  * Test cases for the {@link Frequency} class.\n  *\n- * @version $Revision: 1.9 $ $Date: 2004/02/08 19:51:25 $\n+ * @version $Revision: 1.10 $ $Date: 2004/02/18 04:04:18 $\n  */\n \n public final class FrequencyTest extends TestCase {\n         assertEquals(\"two frequency count\",1,f.getCount(2));\n         assertEquals(\"three frequency count\",0,f.getCount(3));\n         assertEquals(\"total count\",4,f.getSumFreq());\n-        assertEquals(\"zero cummulative frequency\", 0, f.getCumFreq(0));\n-        assertEquals(\"one cummulative frequency\", 3,  f.getCumFreq(1));\n-        assertEquals(\"two cummulative frequency\", 4,  f.getCumFreq(2));\n-        assertEquals(\"two cummulative frequency\", 4,  f.getCumFreq(5));\n-        assertEquals(\"two cummulative frequency\", 0,  f.getCumFreq(\"foo\"));\n+        assertEquals(\"zero cumulative frequency\", 0, f.getCumFreq(0));\n+        assertEquals(\"one cumulative frequency\", 3,  f.getCumFreq(1));\n+        assertEquals(\"two cumulative frequency\", 4,  f.getCumFreq(2));\n+        assertEquals(\"two cumulative frequency\", 4,  f.getCumFreq(5));\n+        assertEquals(\"two cumulative frequency\", 0,  f.getCumFreq(\"foo\"));\n         f.clear();\n         assertEquals(\"total count\",0,f.getSumFreq());\n     }     ", "timestamp": 1077077058, "metainfo": ""}