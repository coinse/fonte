{"sha": "28f28f18ae42f154e9c43de8c3b78f85adf9b318", "log": "MATH-389 Duplicate code in \"MultivariateRealOptimizer\" and \"DifferentiableMultivariateRealOptimizer\" moved to new interface \"BaseMultivariateRealOptimizer\". New \"AbstractScalarOptimizer\" superclass allow implementations that do not use derivatives. Deprecated \"protected\" fields. \"NonLinearConjugateGradientOptimizer\" changed to make use of the newly added accessors instead of the \"protected\" fields.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/**\n+ * Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function.\n+ * This interface is mainly intended to enforce the internal coherence of\n+ * Commons-Math. Users of the API are advised to base their code on\n+ * {@link MultivariateRealOptimizer} or on\n+ * {@link DifferentiableMultivariateRealOptimizer}.\n+ *\n+ * @see MultivariateRealOptimizer\n+ * @see DifferentiableMultivariateRealOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public interface BaseMultivariateRealOptimizer<T extends MultivariateRealFunction> {\n+    /**\n+     * Set the maximal number of iterations of the algorithm.\n+     *\n+     * @param maxIterations Maximal number of algorithm iterations.\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /**\n+     * Get the maximal number of iterations of the algorithm.\n+     *\n+     * @return the maximal number of iterations.\n+     */\n+    int getMaxIterations();\n+\n+    /**\n+     * Set the maximal number of functions evaluations.\n+     *\n+     * @param maxEvaluations Maximal number of function evaluations.\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /**\n+     * Get the maximal number of functions evaluations.\n+     *\n+     * @return the maximal number of functions evaluations.\n+     */\n+    int getMaxEvaluations();\n+\n+    /**\n+     * Get the number of iterations realized by the algorithm.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     *\n+     * @return the number of iterations.\n+     */\n+    int getIterations();\n+\n+    /**\n+     * Get the number of evaluations of the objective function.\n+     *\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(T, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     *\n+     * @return the number of evaluations of the objective function.\n+     */\n+    int getEvaluations();\n+\n+    /**\n+     * Set the convergence checker.\n+     *\n+     * @param checker Object to use to check for convergence.\n+     */\n+    void setConvergenceChecker(RealConvergenceChecker checker);\n+\n+    /**\n+     * Get the convergence checker.\n+     *\n+     * @return the object used to check for convergence.\n+     */\n+    RealConvergenceChecker getConvergenceChecker();\n+\n+    /**\n+     * Optimize an objective function.\n+     *     \n+     * @param f Objective function.\n+     * @param goalType Type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}.\n+     * @param startPoint Start point for optimization.\n+     * @return the point/value pair giving the optimal value for objective function.\n+     * @throws FunctionEvaluationException if the objective function throws one during\n+     * the search.\n+     * @throws OptimizationException if the algorithm failed to converge.\n+     * @throws IllegalArgumentException if the start point dimension is wrong.\n+     */\n+    RealPointValuePair optimize(T f, GoalType goalType, double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException;\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public interface DifferentiableMultivariateRealOptimizer {\n-\n-    /** Set the maximal number of iterations of the algorithm.\n-     * @param maxIterations maximal number of function calls\n-     */\n-    void setMaxIterations(int maxIterations);\n-\n-    /** Get the maximal number of iterations of the algorithm.\n-     * @return maximal number of iterations\n-     */\n-    int getMaxIterations();\n-\n-    /** Get the number of iterations realized by the algorithm.\n-     * <p>\n+public interface DifferentiableMultivariateRealOptimizer\n+    extends BaseMultivariateRealOptimizer<DifferentiableMultivariateRealFunction> {\n+    /**\n+     * Get the number of evaluations of the objective function gradient.\n      * The number of evaluations corresponds to the last call to the\n      * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n      * method. It is 0 if the method has not been called yet.\n-     * </p>\n-     * @return number of iterations\n-     */\n-    int getIterations();\n-\n-    /** Set the maximal number of functions evaluations.\n-     * @param maxEvaluations maximal number of function evaluations\n-     */\n-    void setMaxEvaluations(int maxEvaluations);\n-\n-    /** Get the maximal number of functions evaluations.\n-     * @return maximal number of functions evaluations\n-     */\n-    int getMaxEvaluations();\n-\n-    /** Get the number of evaluations of the objective function.\n-     * <p>\n-     * The number of evaluations corresponds to the last call to the\n-     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n-     * method. It is 0 if the method has not been called yet.\n-     * </p>\n-     * @return number of evaluations of the objective function\n-     */\n-    int getEvaluations();\n-\n-    /** Get the number of evaluations of the objective function gradient.\n-     * <p>\n-     * The number of evaluations corresponds to the last call to the\n-     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n-     * method. It is 0 if the method has not been called yet.\n-     * </p>\n-     * @return number of evaluations of the objective function gradient\n+     *\n+     * @return the number of evaluations of the objective function gradient.\n      */\n     int getGradientEvaluations();\n-\n-    /** Set the convergence checker.\n-     * @param checker object to use to check for convergence\n-     */\n-    void setConvergenceChecker(RealConvergenceChecker checker);\n-\n-    /** Get the convergence checker.\n-     * @return object used to check for convergence\n-     */\n-    RealConvergenceChecker getConvergenceChecker();\n-\n-    /** Optimizes an objective function.\n-     * @param f objective function\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n-     * @param startPoint the start point for optimization\n-     * @return the point/value pair giving the optimal value for objective function\n-     * @exception FunctionEvaluationException if the objective function throws one during\n-     * the search\n-     * @exception OptimizationException if the algorithm failed to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n-     */\n-    RealPointValuePair optimize(DifferentiableMultivariateRealFunction f,\n-                                  GoalType goalType,\n-                                  double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public interface MultivariateRealOptimizer {\n-\n-    /** Set the maximal number of iterations of the algorithm.\n-     * @param maxIterations maximal number of algorithm iterations\n-     */\n-    void setMaxIterations(int maxIterations);\n-\n-    /** Get the maximal number of iterations of the algorithm.\n-     * @return maximal number of iterations\n-     */\n-    int getMaxIterations();\n-\n-    /** Set the maximal number of functions evaluations.\n-     * @param maxEvaluations maximal number of function evaluations\n-     */\n-    void setMaxEvaluations(int maxEvaluations);\n-\n-    /** Get the maximal number of functions evaluations.\n-     * @return maximal number of functions evaluations\n-     */\n-    int getMaxEvaluations();\n-\n-    /** Get the number of iterations realized by the algorithm.\n-     * <p>\n-     * The number of evaluations corresponds to the last call to the\n-     * {@link #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n-     * method. It is 0 if the method has not been called yet.\n-     * </p>\n-     * @return number of iterations\n-     */\n-    int getIterations();\n-\n-    /** Get the number of evaluations of the objective function.\n-     * <p>\n-     * The number of evaluations corresponds to the last call to the\n-     * {@link #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n-     * method. It is 0 if the method has not been called yet.\n-     * </p>\n-     * @return number of evaluations of the objective function\n-     */\n-    int getEvaluations();\n-\n-    /** Set the convergence checker.\n-     * @param checker object to use to check for convergence\n-     */\n-    void setConvergenceChecker(RealConvergenceChecker checker);\n-\n-    /** Get the convergence checker.\n-     * @return object used to check for convergence\n-     */\n-    RealConvergenceChecker getConvergenceChecker();\n-\n-    /** Optimizes an objective function.\n-     * @param f objective function\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n-     * @param startPoint the start point for optimization\n-     * @return the point/value pair giving the optimal value for objective function\n-     * @exception FunctionEvaluationException if the objective function throws one during\n-     * the search\n-     * @exception OptimizationException if the algorithm failed to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n-     */\n-    RealPointValuePair optimize(MultivariateRealFunction f,\n-                                  GoalType goalType,\n-                                  double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n-\n-}\n+public interface MultivariateRealOptimizer\n+    extends BaseMultivariateRealOptimizer<MultivariateRealFunction> {}\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n /**\n- * Base class for implementing optimizers for multivariate scalar functions.\n- * <p>This base class handles the boilerplate methods associated to thresholds\n- * settings, iterations and evaluations counting.</p>\n+ * Base class for implementing optimizers for multivariate scalar\n+ * differentiable functions.\n+ * It contains boiler-plate code for dealing with gradient evaluation.\n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public abstract class AbstractScalarDifferentiableOptimizer\n+    extends BaseAbstractScalarOptimizer<DifferentiableMultivariateRealFunction>\n     implements DifferentiableMultivariateRealOptimizer {\n+    /** Number of gradient evaluations. */\n+    private int gradientEvaluations;\n+    /** Objective function gradient. */\n+    private MultivariateVectorialFunction gradient;\n \n-    /** Default maximal number of iterations allowed. */\n-    public static final int DEFAULT_MAX_ITERATIONS = 100;\n-\n-    /** Convergence checker. */\n+    /** Convergence checker.\n+     * @deprecated in 2.2 (to be removed in 3.0). Please use the accessor\n+     * {@link BaseAbstractScalarOptimizer#getConvergenceChecker()} instead.\n+     */\n     protected RealConvergenceChecker checker;\n-\n     /**\n      * Type of optimization.\n      * @since 2.1\n+     * @deprecated in 2.2 (to be removed in 3.0). Please use the accessor\n+     * {@link BaseAbstractScalarOptimizer#getGoalType()} instead.\n      */\n     protected GoalType goal;\n-\n-    /** Current point set. */\n+    /** Current point set.\n+     * @deprecated in 2.2 (to be removed in 3.0).\n+     */\n     protected double[] point;\n \n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Number of iterations already performed. */\n-    private int iterations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-\n-    /** Number of evaluations already performed. */\n-    private int evaluations;\n-\n-    /** Number of gradient evaluations. */\n-    private int gradientEvaluations;\n-\n-    /** Objective function. */\n-    private DifferentiableMultivariateRealFunction function;\n-\n-    /** Objective function gradient. */\n-    private MultivariateVectorialFunction gradient;\n-\n-    /** Simple constructor with default settings.\n-     * <p>The convergence check is set to a {@link SimpleScalarValueChecker}\n-     * and the maximal number of evaluation is set to its default value.</p>\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleScalarValueChecker},\n+     * the allowed number of iterations and evaluations are set to their\n+     * default values.\n      */\n-    protected AbstractScalarDifferentiableOptimizer() {\n-        setConvergenceChecker(new SimpleScalarValueChecker());\n-        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n-        setMaxEvaluations(Integer.MAX_VALUE);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxIterations(int maxIterations) {\n-        this.maxIterations = maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxIterations() {\n-        return maxIterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getIterations() {\n-        return iterations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getMaxEvaluations() {\n-        return maxEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public int getEvaluations() {\n-        return evaluations;\n+    protected AbstractScalarDifferentiableOptimizer() {}\n+    /**\n+     * @param convergenceChecker Convergence checker.\n+     * @param maxIterations Maximum number of iterations.\n+     * @param maxEvaluations Maximum number of evaluations.\n+     */\n+    protected AbstractScalarDifferentiableOptimizer(RealConvergenceChecker checker,\n+                                                    int maxIterations,\n+                                                    int maxEvaluations) {\n+        super(checker, maxIterations, maxEvaluations);\n+        this.checker = checker; // Do not use (deprecated).\n     }\n \n     /** {@inheritDoc} */\n     public int getGradientEvaluations() {\n         return gradientEvaluations;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker convergenceChecker) {\n-        this.checker = convergenceChecker;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealConvergenceChecker getConvergenceChecker() {\n-        return checker;\n-    }\n-\n-    /** Increment the iterations counter by 1.\n-     * @exception OptimizationException if the maximal number\n-     * of iterations is exceeded\n-     */\n-    protected void incrementIterationsCounter()\n-        throws OptimizationException {\n-        if (++iterations > maxIterations) {\n-            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n-        }\n     }\n \n     /**\n         return gradient.value(evaluationPoint);\n     }\n \n-    /**\n-     * Compute the objective function value.\n-     * @param evaluationPoint point at which the objective function must be evaluated\n-     * @return objective function value at specified point\n-     * @exception FunctionEvaluationException if the function cannot be evaluated\n-     * or its dimension doesn't match problem dimension or the maximal number\n-     * of iterations is exceeded\n-     */\n-    protected double computeObjectiveValue(final double[] evaluationPoint)\n-        throws FunctionEvaluationException {\n-        if (++evaluations > maxEvaluations) {\n-            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n-                                                  evaluationPoint);\n-        }\n-        return function.value(evaluationPoint);\n-    }\n-\n     /** {@inheritDoc} */\n     public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n-                                         final GoalType goalType,\n-                                         final double[] startPoint)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-\n+                                       final GoalType goalType,\n+                                       final double[] startPoint)\n+        throws FunctionEvaluationException,\n+               OptimizationException {\n         // reset counters\n-        iterations          = 0;\n-        evaluations         = 0;\n         gradientEvaluations = 0;\n \n         // store optimization problem characteristics\n-        function = f;\n         gradient = f.gradient();\n-        goal     = goalType;\n-        point    = startPoint.clone();\n \n-        return doOptimize();\n+        goal = goalType; // Do not use (deprecated).\n+        point = startPoint.clone(); // Do not use (deprecated).\n \n+        return super.optimize(f, goalType, startPoint);\n     }\n-\n-    /** Perform the bulk of optimization algorithm.\n-     * @return the point/value pair giving the optimal value for objective function\n-     * @exception FunctionEvaluationException if the objective function throws one during\n-     * the search\n-     * @exception OptimizationException if the algorithm failed to converge\n-     * @exception IllegalArgumentException if the start point dimension is wrong\n-     */\n-    protected abstract RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n-\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate (not necessarily\n+ * differentiable) scalar functions.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public abstract class AbstractScalarOptimizer\n+    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    implements MultivariateRealOptimizer {\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleScalarValueChecker},\n+     * the allowed number of iterations and evaluations are set to their\n+     * default values.\n+     */\n+    protected AbstractScalarOptimizer() {}\n+    /**\n+     * @param convergenceChecker Convergence checker.\n+     * @param maxIterations Maximum number of iterations.\n+     * @param maxEvaluations Maximum number of evaluations.\n+     */\n+    protected AbstractScalarOptimizer(RealConvergenceChecker checker,\n+                                      int maxIterations,\n+                                      int maxEvaluations) {\n+        super(checker, maxIterations, maxEvaluations);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions.\n+ * This base class handles the boiler-plate methods associated to thresholds\n+ * settings, iterations and evaluations counting.\n+ * This class is mainly intended to enforce the internal coherence of\n+ * Commons-Math.\n+ * A class that implements an optimization algorithm should inherit from\n+ * {@link AbstractScalarOptimizer} or from\n+ * {@link AbstractScalarDifferentiableOptimizer}.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.2\n+ */\n+public abstract class BaseAbstractScalarOptimizer<T extends MultivariateRealFunction>\n+    implements BaseMultivariateRealOptimizer<T> {\n+    /** Default maximal number of iterations allowed ({@value}). */\n+    public static final int DEFAULT_MAX_ITERATIONS = 1000;\n+    /** Default maximal number of iterations allowed ({@value}). */\n+    public static final int DEFAULT_MAX_EVALUATIONS = 10000;\n+\n+    /** Convergence checker. */\n+    private RealConvergenceChecker checker;\n+    /** Type of optimization. */\n+    private GoalType goal;\n+    /** Initial guess. */\n+    private double[] start;\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+    /** Objective function. */\n+    private MultivariateRealFunction function;\n+\n+    /**\n+     * Simple constructor with default settings.\n+     * The convergence check is set to a {@link SimpleScalarValueChecker},\n+     * the allowed number of iterations and evaluations are set to their\n+     * default values.\n+     */\n+    protected BaseAbstractScalarOptimizer() {\n+        this(new SimpleScalarValueChecker(),\n+             DEFAULT_MAX_ITERATIONS,\n+             DEFAULT_MAX_EVALUATIONS);\n+    }\n+    /**\n+     * @param convergenceChecker Convergence checker.\n+     * @param maxIterations Maximum number of iterations.\n+     * @param maxEvaluations Maximum number of evaluations.\n+     */\n+    protected BaseAbstractScalarOptimizer(RealConvergenceChecker checker,\n+                                          int maxIterations,\n+                                          int maxEvaluations) {\n+        this.checker = checker;\n+        this.maxIterations = maxIterations;\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n+        this.checker = checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealConvergenceChecker getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /**\n+     * Increment the iterations counter by 1.\n+     * @throws OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+        }\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     * @param evaluationPoint point at which the objective function must be evaluated\n+     * @return objective function value at specified point\n+     * @throws FunctionEvaluationException if the function cannot be evaluated\n+     * or its dimension doesn't match problem dimension or the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected double computeObjectiveValue(double[] evaluationPoint)\n+        throws FunctionEvaluationException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  evaluationPoint);\n+        }\n+        return function.value(evaluationPoint);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(T f,\n+                                       GoalType goalType,\n+                                       double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        // reset counters\n+        iterations = 0;\n+        evaluations = 0;\n+\n+        // store optimization problem characteristics\n+        function = f;\n+        goal = goalType;\n+        start = startPoint.clone();\n+\n+        return doOptimize();\n+    }\n+\n+    /**\n+     * @return the optimization type.\n+     */\n+    public GoalType getGoalType() {\n+        return goal;\n+    }\n+\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double[] getStartPoint() {\n+        return start.clone();\n+    }\n+\n+    /**\n+     * Perform the bulk of optimization algorithm.\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @throws FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @throws OptimizationException if the algorithm failed to converge\n+     * @throws IllegalArgumentException if the start point dimension is wrong\n+     */\n+    protected abstract RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException, OptimizationException;\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n  */\n \n public class NonLinearConjugateGradientOptimizer\n-    extends AbstractScalarDifferentiableOptimizer\n-    implements DifferentiableMultivariateRealOptimizer {\n-\n+    extends AbstractScalarDifferentiableOptimizer {\n     /** Update formula for the beta parameter. */\n     private final ConjugateGradientFormula updateFormula;\n-\n     /** Preconditioner (may be null). */\n     private Preconditioner preconditioner;\n-\n     /** solver to use in the line search (may be null). */\n     private UnivariateRealSolver solver;\n-\n     /** Initial step used to bracket the optimum in line search. */\n     private double initialStep;\n+    /** Current point. */\n+    private double[] point;\n \n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link\n     protected RealPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n         try {\n-\n             // initialization\n             if (preconditioner == null) {\n                 preconditioner = new IdentityPreconditioner();\n             if (solver == null) {\n                 solver = new BrentSolver();\n             }\n+            point = getStartPoint();\n+            final GoalType goal = getGoalType();\n             final int n = point.length;\n             double[] r = computeObjectiveGradient(point);\n             if (goal == GoalType.MINIMIZE) {\n                 RealPointValuePair previous = current;\n                 current = new RealPointValuePair(point, objective);\n                 if (previous != null) {\n-                    if (checker.converged(getIterations(), previous, current)) {\n+                    if (getConvergenceChecker().converged(getIterations(), previous, current)) {\n                         // we have found an optimum\n                         return current;\n                     }", "timestamp": 1279924509, "metainfo": ""}