{"sha": "bae38c17a62f9ab0d9ba70b6b93a27ad9b8f148c", "log": "Forbid if/else/do/while/for without braces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n                     negative = true;\n                     continue;\n                 }\n-                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n+                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9') {\n                     sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n+                }\n             }\n \n             if (negative) {\n--- a/src/main/java/org/apache/commons/math/dfp/DfpMath.java\n+++ b/src/main/java/org/apache/commons/math/dfp/DfpMath.java\n \n             fact = fact.divide((i-1)*i);  // 1 over fact\n             y = y.add(x.multiply(fact));\n-            if (y.equals(py))\n+            if (y.equals(py)) {\n                 break;\n+            }\n             py = new Dfp(y);\n         }\n \n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n      */\n     @Override\n     public double density(double x) {\n-        if (x < 0) return 0;\n+        if (x < 0) {\n+            return 0;\n+        }\n         return FastMath.pow(x / beta, alpha - 1) / beta *\n-            FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n+               FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java\n          */\n         for (int i = 0; i < m; ++i) {\n             for (int j = 0; j < m; ++j) {\n-                if (i - j + 1 < 0)\n+                if (i - j + 1 < 0) {\n                     Hdata[i][j] = BigFraction.ZERO;\n-                else\n+                } else {\n                     Hdata[i][j] = BigFraction.ONE;\n+                }\n             }\n         }\n \n--- a/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n      * {@inheritDoc}\n      */\n     @Override\n-    protected void checkValidity(List<Integer> chromosomeRepresentation) throws InvalidRepresentationException {\n+    protected void checkValidity(List<Integer> chromosomeRepresentation)\n+        throws InvalidRepresentationException {\n         for (int i : chromosomeRepresentation) {\n-            if (i < 0 || i >1)\n-                throw new InvalidRepresentationException(\n-                        LocalizedFormats.INVALID_BINARY_DIGIT, i);\n+            if (i < 0 || i >1) {\n+                throw new InvalidRepresentationException(LocalizedFormats.INVALID_BINARY_DIGIT,\n+                                                         i);\n+            }\n         }\n     }\n \n     @Override\n     protected boolean isSame(Chromosome another) {\n         // type check\n-        if (! (another instanceof BinaryChromosome))\n+        if (! (another instanceof BinaryChromosome)) {\n             return false;\n+        }\n         BinaryChromosome anotherBc = (BinaryChromosome) another;\n         // size check\n-        if (getLength() != anotherBc.getLength())\n+        if (getLength() != anotherBc.getLength()) {\n             return false;\n+        }\n \n         for (int i=0; i< getRepresentation().size(); i++) {\n-            if (!(getRepresentation().get(i).equals(anotherBc.getRepresentation().get(i))))\n+            if (!(getRepresentation().get(i).equals(anotherBc.getRepresentation().get(i)))) {\n                 return false;\n+            }\n         }\n         // all is ok\n         return true;\n--- a/src/main/java/org/apache/commons/math/genetics/Chromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/Chromosome.java\n      */\n     protected Chromosome findSameChromosome(Population population) {\n         for (Chromosome anotherChr : population) {\n-            if (this.isSame(anotherChr))\n+            if (this.isSame(anotherChr)) {\n                 return anotherChr;\n+            }\n         }\n         return null;\n     }\n--- a/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n      *            next generation [in %]\n      */\n     public void setElitismRate(double elitismRate) {\n-        if (elitismRate < 0 || elitismRate > 1)\n+        if (elitismRate < 0 || elitismRate > 1) {\n             throw new IllegalArgumentException(\"Elitism rate has to be in [0,1]\");\n+        }\n         this.elitismRate = elitismRate;\n     }\n \n--- a/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n+++ b/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n      * @param maxGenerations number of generations to evolve\n      */\n     public FixedGenerationCount(int maxGenerations) {\n-        if (maxGenerations <= 0)\n+        if (maxGenerations <= 0) {\n             throw new IllegalArgumentException(\"The number of generations has to be >= 0\");\n+        }\n         this.maxGenerations = maxGenerations;\n     }\n \n--- a/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n+++ b/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n      */\n     private ChromosomePair crossover(AbstractListChromosome<T> first, AbstractListChromosome<T> second) {\n         int length = first.getLength();\n-        if (length != second.getLength())\n+        if (length != second.getLength()) {\n             throw new IllegalArgumentException(\"Both chromosomes must have same lengths.\");\n+        }\n \n         // array representations of the parents\n         List<T> parent1Rep = first.getRepresentation();\n--- a/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n     @Override\n     protected boolean isSame(Chromosome another) {\n         // type check\n-        if (! (another instanceof RandomKey<?>))\n+        if (! (another instanceof RandomKey<?>)) {\n             return false;\n+        }\n         RandomKey<?> anotherRk = (RandomKey<?>) another;\n         // size check\n-        if (getLength() != anotherRk.getLength())\n+        if (getLength() != anotherRk.getLength()) {\n             return false;\n+        }\n \n         // two different representations can still encode the same permutation\n         // the ordering is what counts\n         List<Integer> anotherPerm = anotherRk.baseSeqPermutation;\n \n         for (int i=0; i<getLength(); i++) {\n-            if (thisPerm.get(i) != anotherPerm.get(i))\n+            if (thisPerm.get(i) != anotherPerm.get(i)) {\n                 return false;\n+            }\n         }\n         // the permutations are the same\n         return true;\n--- a/src/main/java/org/apache/commons/math/genetics/TournamentSelection.java\n+++ b/src/main/java/org/apache/commons/math/genetics/TournamentSelection.java\n      * @return the selected chromosome.\n      */\n     private Chromosome tournament(ListPopulation population) {\n-        if (population.getPopulationSize() < this.arity)\n+        if (population.getPopulationSize() < this.arity) {\n             throw new IllegalArgumentException(\"Tournament arity cannot be bigger than population size.\");\n+        }\n         // auxiliary population\n         ListPopulation tournamentPopulation = new ListPopulation(this.arity) {\n             public Population nextGeneration() {\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n             corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n \n       // convergence test\n-      if (FastMath.abs(fn1 - fn) <= threshold)\n-        return o;\n+      if (FastMath.abs(fn1 - fn) <= threshold) {\n+          return o;\n+      }\n \n       // prepare next iteration\n       x00 = o0[0];\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n                             z[ia][i] = c * z[ia][i] - s * p;\n                         }\n                     }\n-                    if (t == 0.0 && i >= j)\n+                    if (t == 0.0 && i >= j) {\n                         continue;\n+                    }\n                     realEigenvalues[j] -= u;\n                     e[j] = q;\n                     e[m] = 0.0;\n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> outerProduct(FieldVector<T> v) {\n-        if(v instanceof SparseFieldVector<?>)\n+        if (v instanceof SparseFieldVector<?>) {\n             return outerProduct((SparseFieldVector<T>)v);\n-        else\n+        } else {\n             return outerProduct(v.toArray());\n+        }\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public FieldVector<T> subtract(FieldVector<T> v) {\n-        if(v instanceof SparseFieldVector<?>)\n+        if (v instanceof SparseFieldVector<?>) {\n             return subtract((SparseFieldVector<T>)v);\n-        else\n+        } else {\n             return subtract(v.toArray());\n+        }\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n \n             // Take the integration direction into account.\n             forward = interpolator.getCurrentTime() >= lastTime;\n-            if (!forward) h = -h;\n+            if (!forward) {\n+                h = -h;\n+            }\n         }\n \n         double nextTime = (mode == StepNormalizerMode.INCREMENT) ?\n      */\n     private boolean isNextInStep(double nextTime,\n                                  StepInterpolator interpolator) {\n-        return forward ? nextTime <= interpolator.getCurrentTime()\n-                       : nextTime >= interpolator.getCurrentTime();\n+        return forward ?\n+               nextTime <= interpolator.getCurrentTime() :\n+               nextTime >= interpolator.getCurrentTime();\n     }\n \n     /**\n      * caller if the underlying user function triggers one\n      */\n     private void doNormalizedStep(boolean isLast) throws MathUserException {\n-        if (!bounds.firstIncluded() && firstTime == lastTime) return;\n+        if (!bounds.firstIncluded() && firstTime == lastTime) {\n+            return;\n+        }\n         handler.handleStep(lastTime, lastState, lastDerivatives, isLast);\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n                 for (int k = 0; k < lambda; k++) {\n                     RealMatrix arxk = null;\n                     for (int i = 0; i < checkFeasableCount+1; i++) {\n-                        if (diagonalOnly <= 0)\n+                        if (diagonalOnly <= 0) {\n                             arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                     .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n-                        else\n+                        } else {\n                             arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                     .scalarMultiply(sigma));\n-                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0)))\n+                        }\n+                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                             break;\n+                        }\n                         // regenerate random arguments for row\n                         arz.setColumn(k, randn(dimension));\n                     }\n                 RealMatrix bestArz = selectColumns(arz, MathUtils.copyOf(arindex, mu));\n                 RealMatrix zmean = bestArz.multiply(weights);\n                 boolean hsig = updateEvolutionPaths(zmean, xold);\n-                if (diagonalOnly <= 0)\n+                if (diagonalOnly <= 0) {\n                     updateCovariance(hsig, bestArx, arz, arindex, xold);\n-                else\n+                } else {\n                     updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n+                }\n                 // Adapt step size sigma - Eq. (5)\n                 sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                 double bestFitness = fitness[arindex[0]];\n                             fitfun.decode(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n-                        if (getConvergenceChecker().converged(\n-                                iterations, optimum, lastResult))\n+                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                             break generationLoop;\n+                        }\n                     }\n                 }\n                 // handle termination criteria\n                 // Break, if fitness is good enough\n                 if (stopfitness != 0) { // only if stopfitness is defined\n-                    if (bestFitness < (isMinimize ? stopfitness : -stopfitness))\n+                    if (bestFitness < (isMinimize ? stopfitness : -stopfitness)) {\n                         break generationLoop;\n+                    }\n                 }\n                 double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                 double[] pcCol = pc.getColumn(0);\n                 for (int i = 0; i < dimension; i++) {\n-                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX)\n+                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                         break;\n-                    if (i >= dimension-1)\n+                    }\n+                    if (i >= dimension-1) {\n                         break generationLoop;\n-                }\n-                for (int i = 0; i < dimension; i++)\n-                    if (sigma*sqrtDiagC[i] > stopTolUpX)\n+                    }\n+                }\n+                for (int i = 0; i < dimension; i++) {\n+                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                         break generationLoop;\n+                    }\n+                }\n                 double historyBest = min(fitnessHistory);\n                 double historyWorst = max(fitnessHistory);\n                 if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n-                        Math.min(historyBest, bestFitness) < stopTolFun)\n+                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                     break generationLoop;\n+                }\n                 if (iterations > fitnessHistory.length &&\n-                        historyWorst-historyBest < stopTolHistFun)\n+                        historyWorst-historyBest < stopTolHistFun) {\n                     break generationLoop;\n+                }\n                 // condition number of the covariance matrix exceeds 1e14\n-                if (max(diagD)/min(diagD) > 1e7)\n+                if (max(diagD)/min(diagD) > 1e7) {\n                     break generationLoop;\n+                }\n                 // user defined termination\n                 if (getConvergenceChecker() != null) {\n                     RealPointValuePair current =\n                         new RealPointValuePair(bestArx.getColumn(0),\n                                 isMinimize ? bestFitness : -bestFitness);\n                     if (lastResult != null &&\n-                            getConvergenceChecker().converged(\n-                                    iterations, current, lastResult))\n+                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                         break generationLoop;\n+                    }\n                     lastResult = current;\n                 }\n                 // Adjust step size in case of equal function values (flat fitness)\n-                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]])\n+                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                     sigma = sigma * Math.exp(0.2+cs/damps);\n+                }\n                 if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n-                        Math.min(historyBest, bestFitness) == 0)\n+                        Math.min(historyBest, bestFitness) == 0) {\n                     sigma = sigma * Math.exp(0.2+cs/damps);\n+                }\n                 // store best in history\n                 push(fitnessHistory,bestFitness);\n                 fitfun.setValueRange(worstFitness-bestFitness);\n     private void checkParameters() {\n         double[] init = getStartPoint();\n         if (boundaries != null) {\n-            if (boundaries.length != 2)\n+            if (boundaries.length != 2) {\n                 throw new MultiDimensionMismatchException(\n                         new Integer[] { boundaries.length },\n                         new Integer[] { 2 });\n-            if (boundaries[0] == null || boundaries[1] == null)\n+            }\n+            if (boundaries[0] == null || boundaries[1] == null) {\n                 throw new NoDataException();\n-            if (boundaries[0].length != init.length)\n+            }\n+            if (boundaries[0].length != init.length) {\n                 throw new MultiDimensionMismatchException(\n                         new Integer[] { boundaries[0].length },\n                         new Integer[] { init.length });\n-            if (boundaries[1].length != init.length)\n+            }\n+            if (boundaries[1].length != init.length) {\n                 throw new MultiDimensionMismatchException(\n                         new Integer[] { boundaries[1].length },\n                         new Integer[] { init.length });\n+            }\n             for (int i = 0; i < init.length; i++) {\n-                if (boundaries[0][i] > init[i] || boundaries[1][i] < init[i])\n+                if (boundaries[0][i] > init[i] || boundaries[1][i] < init[i]) {\n                     throw new OutOfRangeException(init[i], boundaries[0][i],\n                             boundaries[1][i]);\n+                }\n             }\n         }\n         if (inputSigma != null) {\n-            if (inputSigma.length != init.length)\n+            if (inputSigma.length != init.length) {\n                 throw new MultiDimensionMismatchException(\n                         new Integer[] { inputSigma.length },\n                         new Integer[] { init.length });\n+            }\n             for (int i = 0; i < init.length; i++) {\n-                if (inputSigma[i] < 0)\n+                if (inputSigma[i] < 0) {\n                     throw new NotPositiveException(inputSigma[i]);\n+                }\n                 if (boundaries != null) {\n-                    if (inputSigma[i] > 1.0)\n+                    if (inputSigma[i] > 1.0) {\n                         throw new OutOfRangeException(inputSigma[i], 0, 1.0);\n+                    }\n                 }\n             }\n         }\n      */\n \n     private void initializeCMA(double[] guess) {\n-        if (lambda <= 0)\n+        if (lambda <= 0) {\n             lambda = 4 + (int) (3. * Math.log(dimension));\n+        }\n         // initialize sigma\n         double[][] sigmaArray = new double[guess.length][1];\n-        for (int i = 0; i < guess.length; i++)\n+        for (int i = 0; i < guess.length; i++) {\n             sigmaArray[i][0] = inputSigma != null ? inputSigma[i] : 0.3;\n+        }\n         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n         sigma = max(insigma); // overall standard deviation\n \n         C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\n         historySize = 10 + (int) (3. * 10. * dimension / lambda);\n         fitnessHistory = new double[historySize]; // history of fitness values\n-        for (int i = 0; i < historySize; i++)\n+        for (int i = 0; i < historySize; i++) {\n             fitnessHistory[i] = Double.MAX_VALUE;\n+        }\n     }\n \n     /**\n             Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /\n                 chiN < 1.4 + 2. / (dimension + 1.);\n         pc = pc.scalarMultiply(1. - cc);\n-        if (hsig)\n+        if (hsig) {\n             pc = pc.add(xmean.subtract(xold).scalarMultiply(\n                     Math.sqrt(cc * (2. - cc) * mueff) / sigma));\n+        }\n         return hsig;\n     }\n \n                 // check and set learning rate negccov\n                 double negcovMax = (1. - negminresidualvariance) /\n                         square(arnormsInv).multiply(weights).getEntry(0, 0);\n-                if (negccov > negcovMax)\n+                if (negccov > negcovMax) {\n                     negccov = negcovMax;\n+                }\n                 arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                 RealMatrix artmp = BD.multiply(arzneg);\n                 RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n             D = eig.getD();\n             diagD = diag(D);\n             if (min(diagD) <= 0) {\n-                for (int i = 0; i < dimension; i++)\n-                    if (diagD.getEntry(i, 0) < 0)\n+                for (int i = 0; i < dimension; i++) {\n+                    if (diagD.getEntry(i, 0) < 0) {\n                         diagD.setEntry(i, 0, 0.);\n+                    }\n+                }\n                 double tfac = max(diagD) / 1e14;\n                 C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                 diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n      *            current best fitness value\n      */\n     private static void push(double[] vals, double val) {\n-        for (int i = vals.length-1; i > 0; i--)\n+        for (int i = vals.length-1; i > 0; i--) {\n             vals[i] = vals[i-1];\n+        }\n         vals[0] = val;\n     }\n \n      */\n     private int[] sortedIndices(final double[] doubles) {\n         DoubleIndex[] dis = new DoubleIndex[doubles.length];\n-        for (int i = 0; i < doubles.length; i++)\n+        for (int i = 0; i < doubles.length; i++) {\n             dis[i] = new DoubleIndex(doubles[i], i);\n+        }\n         Arrays.sort(dis);\n         int[] indices = new int[doubles.length];\n-        for (int i = 0; i < doubles.length; i++)\n+        for (int i = 0; i < doubles.length; i++) {\n             indices[i] = dis[i].index;\n+        }\n         return indices;\n     }\n \n          * @return Normalized objective variables.\n          */\n         public double[] encode(final double[] x) {\n-            if (boundaries == null)\n+            if (boundaries == null) {\n                 return x;\n+            }\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n          * @return Original objective variables.\n          */\n         public double[] decode(final double[] x) {\n-            if (boundaries == null)\n+            if (boundaries == null) {\n                 return x;\n+            }\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n                 value = CMAESOptimizer.this\n                         .computeObjectiveValue(decode(repaired)) +\n                         penalty(point, repaired);\n-            } else\n+            } else {\n                 value = CMAESOptimizer.this\n                         .computeObjectiveValue(decode(point));\n+            }\n             return isMinimize ? value : -value;\n         }\n \n          * @return True if in bounds\n          */\n         public boolean isFeasible(final double[] x) {\n-            if (boundaries == null)\n+            if (boundaries == null) {\n                 return true;\n+            }\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0)\n+                if (x[i] < 0) {\n                     return false;\n-                if (x[i] > 1.0)\n+                }\n+                if (x[i] > 1.0) {\n                     return false;\n+                }\n             }\n             return true;\n         }\n         private double[] repair(final double[] x) {\n             double[] repaired = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0)\n+                if (x[i] < 0) {\n                     repaired[i] = 0;\n-                else if (x[i] > 1.0)\n+                } else if (x[i] > 1.0) {\n                     repaired[i] = 1.0;\n-                else\n+                } else {\n                     repaired[i] = x[i];\n+                }\n             }\n             return repaired;\n         }\n      */\n     private static RealMatrix log(final RealMatrix m) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n-        for (int r = 0; r < m.getRowDimension(); r++)\n-            for (int c = 0; c < m.getColumnDimension(); c++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n+            for (int c = 0; c < m.getColumnDimension(); c++) {\n                 d[r][c] = Math.log(m.getEntry(r, c));\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static RealMatrix sqrt(final RealMatrix m) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n-        for (int r = 0; r < m.getRowDimension(); r++)\n-            for (int c = 0; c < m.getColumnDimension(); c++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n+            for (int c = 0; c < m.getColumnDimension(); c++) {\n                 d[r][c] = Math.sqrt(m.getEntry(r, c));\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static RealMatrix square(final RealMatrix m) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n-        for (int r = 0; r < m.getRowDimension(); r++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n             for (int c = 0; c < m.getColumnDimension(); c++) {\n                 double e = m.getEntry(r, c);\n                 d[r][c] = e * e;\n             }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n-        for (int r = 0; r < m.getRowDimension(); r++)\n-            for (int c = 0; c < m.getColumnDimension(); c++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n+            for (int c = 0; c < m.getColumnDimension(); c++) {\n                 d[r][c] = m.getEntry(r, c)*n.getEntry(r, c);\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n-        for (int r = 0; r < m.getRowDimension(); r++)\n-            for (int c = 0; c < m.getColumnDimension(); c++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n+            for (int c = 0; c < m.getColumnDimension(); c++) {\n                 d[r][c] = m.getEntry(r, c)/n.getEntry(r, c);\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n         double[][] d = new double[m.getRowDimension()][cols.length];\n-        for (int r = 0; r < m.getRowDimension(); r++)\n-            for (int c = 0; c < cols.length; c++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n+            for (int c = 0; c < cols.length; c++) {\n                 d[r][c] = m.getEntry(r, cols[c]);\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static RealMatrix triu(final RealMatrix m, int k) {\n         double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n-        for (int r = 0; r < m.getRowDimension(); r++)\n-            for (int c = 0; c < m.getColumnDimension(); c++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n+            for (int c = 0; c < m.getColumnDimension(); c++) {\n                 d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n-                return new Array2DRowRealMatrix(d, false);\n+            }\n+        }\n+        return new Array2DRowRealMatrix(d, false);\n     }\n \n     /**\n         double[][] d = new double[1][m.getColumnDimension()];\n         for (int c = 0; c < m.getColumnDimension(); c++) {\n             double sum = 0;\n-            for (int r = 0; r < m.getRowDimension(); r++)\n+            for (int r = 0; r < m.getRowDimension(); r++) {\n                 sum += m.getEntry(r, c);\n+            }\n             d[0][c] = sum;\n         }\n         return new Array2DRowRealMatrix(d, false);\n     private static RealMatrix diag(final RealMatrix m) {\n         if (m.getColumnDimension() == 1) {\n             double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n-            for (int i = 0; i < m.getRowDimension(); i++)\n+            for (int i = 0; i < m.getRowDimension(); i++) {\n                 d[i][i] = m.getEntry(i, 0);\n+            }\n             return new Array2DRowRealMatrix(d, false);\n         } else {\n             double[][] d = new double[m.getRowDimension()][1];\n-            for (int i = 0; i < m.getColumnDimension(); i++)\n+            for (int i = 0; i < m.getColumnDimension(); i++) {\n                 d[i][0] = m.getEntry(i, i);\n+            }\n             return new Array2DRowRealMatrix(d, false);\n         }\n     }\n      *            Target column.\n      */\n     private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) {\n-        for (int i = 0; i < m1.getRowDimension(); i++)\n+        for (int i = 0; i < m1.getRowDimension(); i++) {\n             m2.setEntry(i, col2, m1.getEntry(i, col1));\n+        }\n     }\n \n     /**\n      */\n     private static RealMatrix ones(int n, int m) {\n         double[][] d = new double[n][m];\n-        for (int r = 0; r < n; r++)\n+        for (int r = 0; r < n; r++) {\n             Arrays.fill(d[r], 1.0);\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static RealMatrix eye(int n, int m) {\n         double[][] d = new double[n][m];\n-        for (int r = 0; r < n; r++)\n-            if (r < m)\n+        for (int r = 0; r < n; r++) {\n+            if (r < m) {\n                 d[r][r] = 1;\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n         int rd = mat.getRowDimension();\n         int cd = mat.getColumnDimension();\n         double[][] d = new double[n * rd][m * cd];\n-        for (int r = 0; r < n * rd; r++)\n-            for (int c = 0; c < m * cd; c++)\n+        for (int r = 0; r < n * rd; r++) {\n+            for (int c = 0; c < m * cd; c++) {\n                 d[r][c] = mat.getEntry(r % rd, c % cd);\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n \n      */\n     private static double max(final RealMatrix m) {\n         double max = -Double.MAX_VALUE;\n-        for (int r = 0; r < m.getRowDimension(); r++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n             for (int c = 0; c < m.getColumnDimension(); c++) {\n                 double e = m.getEntry(r, c);\n-                if (max < e)\n+                if (max < e) {\n                     max = e;\n-            }\n+                }\n+            }\n+        }\n         return max;\n     }\n \n      */\n     private static double min(final RealMatrix m) {\n         double min = Double.MAX_VALUE;\n-        for (int r = 0; r < m.getRowDimension(); r++)\n+        for (int r = 0; r < m.getRowDimension(); r++) {\n             for (int c = 0; c < m.getColumnDimension(); c++) {\n                 double e = m.getEntry(r, c);\n-                if (min > e)\n+                if (min > e) {\n                     min = e;\n-            }\n+                }\n+            }\n+        }\n         return min;\n     }\n \n      */\n     private static double max(final double[] m) {\n         double max = -Double.MAX_VALUE;\n-        for (int r = 0; r < m.length; r++)\n-            if (max < m[r])\n+        for (int r = 0; r < m.length; r++) {\n+            if (max < m[r]) {\n                 max = m[r];\n+            }\n+        }\n         return max;\n     }\n \n      */\n     private static double min(final double[] m) {\n         double min = Double.MAX_VALUE;\n-        for (int r = 0; r < m.length; r++)\n-            if (min > m[r])\n+        for (int r = 0; r < m.length; r++) {\n+            if (min > m[r]) {\n                 min = m[r];\n+            }\n+        }\n         return min;\n     }\n \n      */\n     private static int[] inverse(final int[] indices) {\n         int[] inverse = new int[indices.length];\n-        for (int i = 0; i < indices.length; i++)\n+        for (int i = 0; i < indices.length; i++) {\n             inverse[indices[i]] = i;\n+        }\n         return inverse;\n     }\n \n      */\n     private static int[] reverse(final int[] indices) {\n         int[] reverse = new int[indices.length];\n-        for (int i = 0; i < indices.length; i++)\n+        for (int i = 0; i < indices.length; i++) {\n             reverse[i] = indices[indices.length - i - 1];\n+        }\n         return reverse;\n     }\n \n      */\n     private double[] randn(int size) {\n         double[] randn = new double[size];\n-        for (int i = 0; i < size; i++)\n+        for (int i = 0; i < size; i++) {\n             randn[i] = random.nextGaussian();\n+        }\n         return randn;\n     }\n \n      */\n     private RealMatrix randn1(int size, int popSize) {\n         double[][] d = new double[size][popSize];\n-        for (int r = 0; r < size; r++)\n-            for (int c = 0; c < popSize; c++)\n+        for (int r = 0; r < size; r++) {\n+            for (int c = 0; c < popSize; c++) {\n                 d[r][c] = random.nextGaussian();\n+            }\n+        }\n         return new Array2DRowRealMatrix(d, false);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n     /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object obj) {\n-        if (this == obj)\n+        if (this == obj) {\n             return true;\n-        if (!(obj instanceof Frequency))\n+        }\n+        if (!(obj instanceof Frequency)) {\n             return false;\n+        }\n         Frequency other = (Frequency) obj;\n         if (freqTable == null) {\n-            if (other.freqTable != null)\n+            if (other.freqTable != null) {\n                 return false;\n-        } else if (!freqTable.equals(other.freqTable))\n+            }\n+        } else if (!freqTable.equals(other.freqTable)) {\n             return false;\n+        }\n         return true;\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n     /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object obj) {\n-        if (this == obj)\n+        if (this == obj) {\n             return true;\n-        if (!(obj instanceof VectorialCovariance))\n+        }\n+        if (!(obj instanceof VectorialCovariance)) {\n             return false;\n+        }\n         VectorialCovariance other = (VectorialCovariance) obj;\n-        if (isBiasCorrected != other.isBiasCorrected)\n+        if (isBiasCorrected != other.isBiasCorrected) {\n             return false;\n-        if (n != other.n)\n+        }\n+        if (n != other.n) {\n             return false;\n-        if (!Arrays.equals(productsSums, other.productsSums))\n+        }\n+        if (!Arrays.equals(productsSums, other.productsSums)) {\n             return false;\n-        if (!Arrays.equals(sums, other.sums))\n+        }\n+        if (!Arrays.equals(sums, other.sums)) {\n             return false;\n+        }\n         return true;\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialMean.java\n     /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object obj) {\n-        if (this == obj)\n+        if (this == obj) {\n             return true;\n-        if (!(obj instanceof VectorialMean))\n+        }\n+        if (!(obj instanceof VectorialMean)) {\n             return false;\n+        }\n         VectorialMean other = (VectorialMean) obj;\n-        if (!Arrays.equals(means, other.means))\n+        if (!Arrays.equals(means, other.means)) {\n             return false;\n+        }\n         return true;\n     }\n \n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n                 temp[i] = mdcm.get(subVector);\n             }\n \n-            if (forward)\n+            if (forward) {\n                 temp = transform2(temp);\n-            else\n+            } else {\n                 temp = inversetransform2(temp);\n+            }\n \n             for (int i = 0; i < dimensionSize[d]; i++) {\n                 subVector[d] = i;\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n         }\n \n         if (y == Double.POSITIVE_INFINITY) {\n-            if (x * x == 1.0)\n-              return Double.NaN;\n+            if (x * x == 1.0) {\n+                return Double.NaN;\n+            }\n \n             if (x * x > 1.0) {\n                 return Double.POSITIVE_INFINITY;\n                 remA = a + b;\n                 remB += -(remA - b - a);\n \n-                if (remA > 0.0)\n+                if (remA > 0.0) {\n                     break;\n+                }\n \n                 // Remainder is negative, so decrement k and try again.\n                 // This should only happen if the input is very close\n                 remA = a + b;\n                 remB += -(remA - b - a);\n \n-                if (remA > 0.0)\n+                if (remA > 0.0) {\n                     break;\n+                }\n \n                 // Remainder is negative, so decrement k and try again.\n                 // This should only happen if the input is very close\n                 remA = a + b;\n                 remB += -(remA - b - a);\n \n-                if (remA > 0.0)\n+                if (remA > 0.0) {\n                     break;\n+                }\n \n                 // Remainder is negative, so decrement k and try again.\n                 // This should only happen if the input is very close\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n             return n;\n         }\n         // Use symmetry for large k\n-        if (k > n / 2)\n+        if (k > n / 2) {\n             return binomialCoefficient(n, n - k);\n+        }\n \n         // We use the formula\n         // (n choose k) = n! / (n-k)! / k!\n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n         } else {\n             // \"Subtract\" this number of discarded from numElements\n             numElements -= i;\n-            if (front) startIndex += i;\n+            if (front) {\n+                startIndex += i;\n+            }\n         }\n         if (shouldContract()) {\n             contract();", "timestamp": 1309113752, "metainfo": ""}