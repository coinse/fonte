{"sha": "287f41b32167b6022e720c7656c5dec1ecc887f6", "log": "MATH-650 Suggesting to use \"resource\" files for storing large tables. \"FastMathResource\" is a utility for creating and loading those resources. \"FastMathLoadCheck\" modified to allow the benchmarking of the various ways to create the tables needed in \"FastMath\". \"FastMathResourcesSave\" shows how to create the resource files (not a \"user\" functionality, as this should be done only once): The resource files have been created and are located under \"src/main/resources/data\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n      * </p>\n      */\n     private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;\n+    /** Indicator for loading big tables from \"resource\" files. */\n+    private static final boolean LOAD_RESOURCES = true;\n \n     /** log(2) (high bits). */\n     private static final double LN_2_A = 0.693147063255310059;\n \n \n     /** Index of exp(0) in the array of integer exponentials. */\n-    private static final int EXP_INT_TABLE_MAX_INDEX = 750;\n+    static final int EXP_INT_TABLE_MAX_INDEX = 750;\n \n     /** Length of the array of integer exponentials. */\n-    private static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n+    static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n \n     // Enclose large data table in nested static class so it's only loaded on first access\n     private static class ExpIntTable {\n         private static final double[] EXP_INT_TABLE_B;\n \n         static {\n-            if (FastMath.RECOMPUTE_TABLES_AT_RUNTIME) {\n+            if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                 EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n                 EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n \n                         EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n                     }\n                 }\n+            } else if (LOAD_RESOURCES) {\n+                final double[][] expInt = FastMathResources.loadExpInt();\n+                EXP_INT_TABLE_A = expInt[0];\n+                EXP_INT_TABLE_B = expInt[1];\n             } else {\n                 EXP_INT_TABLE_A = new double[] {\n         +0.0d,\n         }\n     }\n \n-    private static final int EXP_FRAC_TABLE_LEN = TWO_POWER_10 + 1; // 0, 1/1024, ... 1024/1024\n+    static final int EXP_FRAC_TABLE_LEN = TWO_POWER_10 + 1; // 0, 1/1024, ... 1024/1024\n \n     // Enclose large data table in nested static class so it's only loaded on first access\n     private static class ExpFracTable {\n         private static final double[] EXP_FRAC_TABLE_B;\n \n         static {\n-            if (FastMath.RECOMPUTE_TABLES_AT_RUNTIME) {\n+            if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                 EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];\n                 EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];\n \n                     EXP_FRAC_TABLE_A[i] = tmp[0];\n                     EXP_FRAC_TABLE_B[i] = tmp[1];\n                 }\n+            } else if (LOAD_RESOURCES) {\n+                final double[][] expFrac = FastMathResources.loadExpFrac();\n+                EXP_FRAC_TABLE_A = expFrac[0];\n+                EXP_FRAC_TABLE_B = expFrac[1];\n             } else {\n                 EXP_FRAC_TABLE_A = new double[] {\n       +1.0d,\n         }\n     }\n \n-    private static final int LN_MANT_LEN = TWO_POWER_10; // (see LN_MANT comment below)\n+    static final int LN_MANT_LEN = TWO_POWER_10; // (see LN_MANT comment below)\n \n     // Enclose large data table in nested static class so it's only loaded on first access\n     private static class lnMant {\n         private static final double[][] LN_MANT;\n \n         static {\n-            if (FastMath.RECOMPUTE_TABLES_AT_RUNTIME) {\n+            if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                 LN_MANT = new double[FastMath.LN_MANT_LEN][];\n \n                 // Populate lnMant table\n                     final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n                     LN_MANT[i] = FastMathCalc.slowLog(d);\n                 }\n+            } else if (LOAD_RESOURCES) {\n+                LN_MANT = FastMathResources.loadLnMant();\n             } else {\n                 LN_MANT = new double[][] { \n       {+0.0d,                   +0.0d,                   }, // 0\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/FastMathResources.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.io.File;\n+import java.io.DataOutputStream;\n+import java.io.DataInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.BufferedInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import  org.apache.commons.math.exception.MathInternalError;\n+\n+/**\n+ * Utility class for saving and loading tabulated data used by\n+ * {@link FastMath}.\n+ *\n+ * @version $Id$\n+ */\n+public class FastMathResources {\n+    /**\n+     * Resource directory. Assuming that this class and the resource files\n+     * are located in the same package as \"FastMath\".\n+     */\n+    private static final String RES_DIR = \"data/\" +\n+        FastMath.class.getPackage().getName().replace('.', '/') + \"/\";\n+    /** File resource prefix. */\n+    private static final String RES_PREFIX = RES_DIR + \"FastMath__\";\n+    /** Resource basename for \"EXP_INT_TABLE_A\" and \"EXP_INT_TABLE_B\". */\n+    private static final String EXP_INT = \"exp_int\";\n+    /** Resource basename for \"EXP_FRAC_TABLE_A\" and \"EXP_FRAC_TABLE_B\". */\n+    private static final String EXP_FRAC = \"exp_frac\";\n+    /** Resource basename for \"LN_MANT\". */\n+    private static final String LN_MANT = \"ln_mant\";\n+\n+    /**\n+     * Class contains only static methods.\n+     */\n+    private FastMathResources() {}\n+\n+    /**\n+     * Compute and save all the resources.\n+     */\n+    static void createAll() {\n+        // Create resource directory.\n+        final File resDir = new File(RES_DIR);\n+        if (resDir.exists()) {\n+            if (!resDir.isDirectory()) {\n+                throw new MathInternalError();\n+            }\n+        } else {\n+            try {\n+                resDir.mkdirs();\n+            } catch (SecurityException e) {\n+                throw new MathInternalError(e);\n+            }\n+        }\n+\n+        // \"EXP_INT\" tables.\n+        final double[] expIntA = new double[FastMath.EXP_INT_TABLE_LEN];\n+        final double[] expIntB = new double[FastMath.EXP_INT_TABLE_LEN];\n+\n+        final double tmp[] = new double[2];\n+        final double recip[] = new double[2];\n+\n+        for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n+            FastMathCalc.expint(i, tmp);\n+            expIntA[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n+            expIntB[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n+\n+            if (i != 0) {\n+                // Negative integer powers.\n+                FastMathCalc.splitReciprocal(tmp, recip);\n+                expIntA[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n+                expIntB[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n+            }\n+        }\n+\n+        saveTable2d(EXP_INT, 2, FastMath.EXP_INT_TABLE_LEN,\n+                    new double[][] { expIntA, expIntB });\n+\n+        // \"EXP_FRAC\" tables.\n+        final double[] expFracA = new double[FastMath.EXP_FRAC_TABLE_LEN];\n+        final double[] expFracB = new double[FastMath.EXP_FRAC_TABLE_LEN];\n+\n+        for (int i = 0; i < FastMath.EXP_FRAC_TABLE_LEN; i++) {\n+            FastMathCalc.slowexp(i / 1024d, tmp); // TWO_POWER_10\n+            expFracA[i] = tmp[0];\n+            expFracB[i] = tmp[1];\n+        }\n+\n+        saveTable2d(EXP_FRAC, 2, FastMath.EXP_FRAC_TABLE_LEN,\n+                    new double[][] { expFracA, expFracB });\n+\n+        // \"LN_MANT\" table.\n+        final double[][] lnMant = new double[FastMath.LN_MANT_LEN][];\n+\n+        for (int i = 0; i < FastMath.LN_MANT_LEN; i++) {\n+            final double d = Double.longBitsToDouble((((long) i) << 42) |\n+                                                     0x3ff0000000000000L);\n+            lnMant[i] = FastMathCalc.slowLog(d);\n+        }\n+\n+        saveTable2d(LN_MANT, FastMath.LN_MANT_LEN, 2, lnMant);\n+    }\n+\n+    /**\n+     * Load \"EXP_INT\" tables.\n+     * \"EXP_INT_TABLE_A\" is at index 0.\n+     * \"EXP_INT_TABLE_B\" is at index 1.\n+     *\n+     * @return the retrieved data.\n+     */\n+    public static double[][] loadExpInt() {\n+        return loadTable2d(EXP_INT, 2, FastMath.EXP_INT_TABLE_LEN);\n+    }\n+    /**\n+     * Load \"EXP_FRAC\" tables.\n+     * \"EXP_FRAC_TABLE_A\" is at index 0.\n+     * \"EXP_FRAC_TABLE_B\" is at index 1.\n+     *\n+     * @return the retrieved data.\n+     */\n+\n+    public static double[][] loadExpFrac() {\n+        return loadTable2d(EXP_FRAC, 2, FastMath.EXP_FRAC_TABLE_LEN);\n+    }\n+    /**\n+     * Load \"LN_MANT\".\n+     *\n+     * @return the retrieved data.\n+     */\n+\n+    public static double[][] loadLnMant() {\n+        return loadTable2d(LN_MANT, FastMath.LN_MANT_LEN, 2);\n+    }\n+\n+    /**\n+     * @param name Basename of the resource.\n+     * @return an output stream.\n+     * @throws FileNotFoundException if the file cannot be opened.\n+     */\n+    private static DataOutputStream out(String name)\n+        throws FileNotFoundException {\n+        final String fullName = RES_PREFIX + name;\n+        return new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fullName)));\n+    }\n+\n+    /**\n+     * @param name Basename of the resource.\n+     * @param len Number of {@code double}s to be stored.\n+     * @param data Data to be stored.\n+     */\n+    private static void saveTable1d(String name,\n+                                    int len,\n+                                    double[] data) {\n+        try {\n+            final DataOutputStream out = out(name);\n+\n+            for (int i = 0; i < len; i++) {\n+                out.writeDouble(data[i]);\n+            }\n+\n+            out.close();\n+        } catch (IOException e) {\n+            throw new MathInternalError(e);\n+        }\n+    }\n+\n+    /**\n+     * @param name Basename of the resource.\n+     * @param len Number of table rows to be stored.\n+     * @param rowLen Number of {@code double}s per table row.\n+     * @param data Data to be stored.\n+     */\n+    private static void saveTable2d(String name,\n+                                    int len,\n+                                    int rowLen,\n+                                    double[][] data) {\n+        try {\n+            final DataOutputStream out = out(name);\n+\n+            for (int i = 0; i < len; i++) {\n+                for (int j = 0; j < rowLen; j++) {\n+                    out.writeDouble(data[i][j]);\n+                }\n+            }\n+\n+            out.close();\n+        } catch (IOException e) {\n+            throw new MathInternalError(e);\n+        }\n+    }\n+\n+    /**\n+     * @param name Basename of the resource.\n+     * @return an input stream.\n+     * @throws FileNotFoundException if the resource cannot be accessed.\n+     */\n+    private static DataInputStream in(String name)\n+        throws FileNotFoundException {\n+        final String fullName = \"/\" + RES_PREFIX + name;\n+        return new DataInputStream(new BufferedInputStream(FastMathResources.class.getResourceAsStream(fullName)));\n+    }\n+\n+\n+    /**\n+     * @param name Basename of the resource.\n+     * @param len Number of {@code double}s to be retrieved.\n+     * @return the retrieved data.\n+     */\n+    private static double[] loadTable1d(String name,\n+                                        int len) {\n+        try {\n+            final DataInputStream in = in(name);\n+\n+            final double[] data = new double[len];\n+            for (int i = 0; i < len; i++) {\n+                data[i] = in.readDouble();\n+            }\n+\n+            in.close();\n+            return data;\n+        } catch (IOException e) {\n+            throw new MathInternalError(e);\n+        }\n+    }\n+\n+    /**\n+     * @param name Basename of the resource.\n+     * @param len Number of table rows to be retrieved.\n+     * @param rowLen Number of {@code double}s per table row.\n+     * @return the retrieved data.\n+     */\n+    private static double[][] loadTable2d(String name,\n+                                          int len,\n+                                          int rowLen) {\n+        try {\n+            final DataInputStream in = in(name);\n+\n+            final double[][] data = new double[len][rowLen];\n+            for (int i = 0; i < len; i++) {\n+                for (int j = 0; j < rowLen; j++) {\n+                    data[i][j] = in.readDouble();\n+                }\n+            }\n+\n+            in.close();\n+            return data;\n+        } catch (IOException e) {\n+            throw new MathInternalError(e);\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/util/FastMathLoadCheck.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathLoadCheck.java\n import java.lang.reflect.Field;\n \n /*\n- * FastMath load test - requires that FastMath.USE_PRECOMPUTED_TABLES be set to non-final.\n+ * FastMath load performance test - requires that\n+ * <ul>\n+ *  <li>{@code FastMath.USE_PRECOMPUTED_TABLES}</li>\n+ *  <li>{@code FastMath.LOAD_RESOURCES}</li>\n+ * </ul>\n+ * be non-\"final\".\n  * \n-Sample output from:\n-java -cp target/classes;target/test-classes org.apache.commons.math.util.FastMathLoadCheck false false\n-java -cp target/classes;target/test-classes org.apache.commons.math.util.FastMathLoadCheck false true\n-java -cp target/classes;target/test-classes org.apache.commons.math.util.FastMathLoadCheck true  false\n-java -cp target/classes;target/test-classes org.apache.commons.math.util.FastMathLoadCheck true  true\n-\n-Using exp(100); compute=false\n-new   12155456       9219       5308       5029       5587       5308       5029       5029       5029       5308\n-Using exp(100); compute=true\n-new   34929579       9499       5308       5308       5029       5029       5029       5308       5028       5029\n-Using max(0,0); compute=false\n-new       5029       3632       3073       3073       3073       3073       3073       3073       3073       3073\n-Using max(0,0); compute=true\n-new       5028       3911       3073       3073       3073       3073       3073       3073       3073       3073\n-\n+ * For example, this shell command:\n+ * <pre>\n+ *  $ for max in false true ; do for how in compute resources array; do java -cp target/classes:target/test-classes org.apache.commons.math.util.FastMathLoadCheck $max $how ; done ; done\n+ * </pre>\n+ * will produce an output similar to the following:\n+ * <pre>\n+ *  Using exp(100); how=compute\n+ *  times  50955053      4062      1783      1708      1731      1728      1739      1735      1746      1735\n+ *  Using exp(100); how=resources\n+ *  times  18467554      4822      1953      1769      1851      1746      1821      1817      1813      1742\n+ *  Using exp(100); how=array\n+ *  times   5952415      2960      1839      1776      1720      1847      1839      1780      1788      1742\n+ *  Using max(0,0); how=compute\n+ *  times      1596       521       401       352       345       405       393       390       397       382\n+ *  Using max(0,0); how=resources\n+ *  times      1517       521       401       386       386       394       363       386       382       383\n+ *  Using max(0,0); how=array\n+ *  times      1569       453       398       390       389       394       333       390       334       359\n+ * </pre>\n  */\n public class FastMathLoadCheck {\n+    private final static String COMP = \"compute\";\n+    private final static String RES = \"resources\";\n+    private final static String ARR = \"array\";\n \n     private static int LOOPS = 10;\n     private static boolean MAX = false;\n-    private static boolean compute = true;\n+    private static String how = ARR;\n \n     public static void main(String[] args) throws Exception {\n-        if (args.length>0) MAX = Boolean.valueOf(args[0]);\n-        if (args.length>1) compute = Boolean.valueOf(args[1]);\n-        if (args.length>2) LOOPS = Integer.valueOf(args[2]);\n-        p(\"Using \"+ (MAX ? \"max(0,0)\" : \"exp(100)\") + \"; compute=\" + compute+\"\\n\");\n-        Field usePrecompute = FastMath.class.getDeclaredField(\"RECOMPUTE_TABLES_AT_RUNTIME\");\n-        usePrecompute.setAccessible(true);\n-        if (usePrecompute.getBoolean(null) != compute) {\n-            usePrecompute.setBoolean(null, compute);\n+        if (args.length > 0) MAX = Boolean.valueOf(args[0]);\n+        if (args.length > 1) how = args[1];\n+        if (args.length > 2) LOOPS = Integer.valueOf(args[2]);\n+        p(\"Using \"+ (MAX ? \"max(0,0)\" : \"exp(100)\") + \"; how=\" + how + \"\\n\");\n+\n+        final Field recompute = FastMath.class.getDeclaredField(\"RECOMPUTE_TABLES_AT_RUNTIME\");\n+        final Field load = FastMath.class.getDeclaredField(\"LOAD_RESOURCES\");\n+        if (how.equals(COMP)) {\n+            recompute.setAccessible(true);\n+            recompute.setBoolean(null, true);\n+            recompute.setAccessible(false);\n+            load.setAccessible(true);\n+            load.setBoolean(null, false);\n+            load.setAccessible(false);\n+        } else if (how.equals(RES)) {\n+            recompute.setAccessible(true);\n+            recompute.setBoolean(null, false);\n+            recompute.setAccessible(false);\n+            load.setAccessible(true);\n+            load.setBoolean(null, true);\n+            load.setAccessible(false);\n+        } else if (how.equals(ARR)) {\n+            recompute.setAccessible(true);\n+            recompute.setBoolean(null, false);\n+            recompute.setAccessible(false);\n+            load.setAccessible(true);\n+            load.setBoolean(null, false);\n+            load.setAccessible(false);\n+        } else {\n+            throw new IllegalArgumentException(\"'how' must be 'compute' or 'resources' or 'array'\");\n         }\n-        usePrecompute.setAccessible(false);\n+\n         test();\n     }\n     private static void test(){\n         p(\"times\");\n-        for(int i=0; i< LOOPS; i++){\n+        for(int i = 0; i < LOOPS; i++){\n             p(\" \");\n             long t1 = System.nanoTime();\n             if (MAX) {\n-                FastMath.max(0,0);\n+                FastMath.max(0, 0);\n             } else {\n                 FastMath.exp(100);\n             }\n             long t2 = System.nanoTime();\n-            p(\"%10d\",t2-t1);\n+            p(\"%9d\", t2 - t1);\n         }\n         p(\"\\n\");\n     }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/FastMathResourcesSave.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+/**\n+ * Not a test class.\n+ * It is used to generate the resource data used by the \"FastMath\" class.\n+ * You should run it from inside the \"resources\" directory, i.e. use as:\n+ * <pre>\n+ *  $ cd src/main/resources/\n+ *  $ java -cp ../../../target/classes:../../../target/test-classes org.apache.commons.math.util.FastMathResourcesSave\n+ * </pre>\n+ */\n+public class FastMathResourcesSave {\n+    public static void main(String[] args) throws Exception {\n+        FastMathResources.createAll();\n+    }\n+}", "timestamp": 1316616811, "metainfo": ""}