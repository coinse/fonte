{"sha": "92a2a61ebbe174a71ea2e6b42a0464b3a565402f", "log": "Fixed JavaDoc warnings. Fixed a few TODOs in the interpolation code. Updated project TODO list. Promoted myself to \"developer\".   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/SplineInterpolator.java\n /**\n  * Computes a natural spline interpolation for the data set.\n  *\n- * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n+ * @version $Revision: 1.5 $ $Date: 2003/09/26 19:30:32 $\n  *\n  */\n public class SplineInterpolator implements UnivariateRealInterpolator {\n      */\n     public UnivariateRealFunction interpolate(double[] xval, double[] yval) {\n         if (xval.length != yval.length) {\n-            throw new IllegalArgumentException(\n-                \"Dataset arrays must have same length.\");\n+            throw new IllegalArgumentException(\"Dataset arrays must have same length.\");\n         }\n \n         if (c == null) {\n             // Separation should be checked too (not implemented: which criteria?).\n             for (int i = 0; i < n; i++) {\n                 if (xval[i] >= xval[i + 1]) {\n-                    throw new IllegalArgumentException(\n-                        \"Dataset must specify sorted, ascending x values.\");\n+                    throw new IllegalArgumentException(\"Dataset must specify sorted, ascending x values.\");\n                 }\n             }\n             // Vectors for the equation system. There are n-1 equations for the unknowns s[i] (1<=i<=N-1),\n             //                           ...\n             //                     l[N-4]*s[N-3]+d[N-3]*s[N-2]+u[N-3]*s[N-1] = b[N-3]\n             //                                   l[N-3]*s[N-2]+d[N-2]*s[N-1] = b[N-2]\n-            // Vector b is the right hand side of the system.\n+            // Vector b is the right hand side (RHS) of the system.\n             double b[] = new double[n - 1];\n             // Vector d is diagonal of the matrix and also holds the computed solution.\n             double d[] = new double[n - 1];\n-            // u[] and l[] are not really needed, the computation can be folded into the\n-            // system solving loops.\n-            //double u[] = new double[n - 2]; // upper diagonal\n-            //double l[] = new double[n - 2]; // lower diagonal\n-            // Setup RHS and diagonal.\n+            // Setup right hand side and diagonal.\n+            double dquot = (yval[1] - yval[0]) / (xval[1] - xval[0]);\n             for (int i = 0; i < n - 1; i++) {\n                 // TODO avoid recomputing the term\n                 //    (yval[i + 2] - yval[i + 1]) / (xval[i + 2] - xval[i + 1])\n                 // take it from the previous loop pass. Note: the interesting part of performance\n                 // loss is the range check in the array access, not the computation itself.\n-                b[i] = 6.0 * ((yval[i + 2] - yval[i + 1]) / (xval[i + 2] - \n-                    xval[i + 1]) - (yval[i + 1] - yval[i]) / (xval[i + 1] -\n-                    xval[i]));\n+                double dquotNext = \n+                    (yval[i + 2] - yval[i + 1]) / (xval[i + 2] - xval[i + 1]);\n+                b[i] = 6.0 * (dquotNext - dquot);\n                 d[i] = 2.0 * (xval[i + 2] - xval[i]);\n+                dquot = dquotNext;\n             }\n+            // u[] and l[] (for the upper and lower diagonal respectively) are not\n+            // really needed, the computation is folded into the system solving loops.\n+            // Keep this for documentation purposes:\n+            //double u[] = new double[n - 2]; // upper diagonal\n+            //double l[] = new double[n - 2]; // lower diagonal\n             // Set up upper and lower diagonal. Keep the offsets in mind.\n             //for (int i = 0; i < n - 2; i++) {\n-            //u[i] = xval[i + 2] - xval[i + 1];\n-            //l[i] = xval[i + 2] - xval[i + 1];\n+            //  u[i] = xval[i + 2] - xval[i + 1];\n+            //  l[i] = xval[i + 2] - xval[i + 1];\n             //}\n             // Solve the system: forward pass.\n             for (int i = 0; i < n - 2; i++) {\n-                // TODO: This relies on compiler for CSE of delta/d[i]. Is this a reasonable assumption?\n                 double delta = xval[i + 2] - xval[i + 1];\n-                d[i + 1] -= delta * delta / d[i];\n-                b[i + 1] -= b[i] * delta / d[i];\n+                double deltaquot = delta / d[i];\n+                d[i + 1] -= delta * deltaquot;\n+                b[i + 1] -= b[i] * deltaquot;\n             }\n             // Solve the system: backward pass.\n             d[n - 2] = b[n - 2] / d[n - 2];\n             // Compute coefficients as usual polynomial coefficients.\n             // Not the best with respect to roundoff on evaluation, but simple.\n             c = new double[n][4];\n-            c[0][3] = d[0] / (xval[1] - xval[0]) / 6.0;\n+            double delta = xval[1] - xval[0];\n+            c[0][3] = d[0] / delta / 6.0;\n             c[0][2] = 0.0;\n-            c[0][1] = (yval[1] - yval[0]) / (xval[1] - xval[0]) - d[0] * \n-                (xval[1] - xval[0]) / 6.0;\n+            c[0][1] = (yval[1] - yval[0]) / delta - d[0] * delta / 6.0;\n             for (int i = 1; i < n - 2; i++) {\n-                // TODO: This relies on compiler for CSE of xval[i + 1] - xval[i]. Is this a reasonable assumption?\n-                c[i][3] = (d[i] - d[i - 1]) / (xval[i + 1] - xval[i]) / 6.0;\n+                delta = xval[i + 1] - xval[i];\n+                c[i][3] = (d[i] - d[i - 1]) / delta / 6.0;\n                 c[i][2] = d[i - 1] / 2.0;\n-                c[i][1] = (yval[i + 1] - yval[i]) / (xval[i + 1] - xval[i]) -\n-                    d[i] * (xval[i + 1] - xval[i]) / 6.0 - d[i - 1] * \n-                    (xval[i + 1] - xval[i]) / 3.0;\n+                c[i][1] =\n+                    (yval[i + 1] - yval[i]) / delta\n+                        - (d[i] / 2.0 - d[i - 1]) * delta / 3.0;\n             }\n-            // TODO: again, CSE aspects.\n-            c[n - 1][3] = -d[n - 2] / (xval[n] - xval[n - 1]) / 6.0;\n+            delta = (xval[n] - xval[n - 1]);\n+            c[n - 1][3] = -d[n - 2] / delta / 6.0;\n             c[n - 1][2] = d[n - 2] / 2.0;\n-            c[n - 1][1] = (yval[n] - yval[n - 1]) / (xval[n] - xval[n - 1]) -\n-                d[n - 2] * (xval[n] - xval[n - 1]) / 3.0;\n+            c[n - 1][1] =\n+                (yval[n] - yval[n - 1]) / delta - d[n - 2] * delta / 3.0;\n             for (int i = 0; i < n; i++) {\n                 c[i][0] = yval[i];\n             }\n--- a/src/java/org/apache/commons/math/distribution/AbstractDiscreteDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractDiscreteDistribution.java\n  * implementations for some of the methods that do not vary from distribution\n  * to distribution.\n  *  \n- * @version $Revision: 1.1 $ $Date: 2003/08/16 17:06:15 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/26 19:30:33 $\n  */\n public abstract class AbstractDiscreteDistribution\n     implements DiscreteDistribution {\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(int)} to find critical values.\n+     * {@link #inverseCummulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.  This method is used by\n-     * {@link #inverseCummulativeProbability(int)} to find critical values.\n+     * {@link #inverseCummulativeProbability(double)} to find critical values.\n      * \n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n /**\n  * The default implementation of {@link GammaDistribution}\n  * \n- * @version $Revision: 1.6 $ $Date: 2003/09/17 19:29:28 $\n+ * @version $Revision: 1.7 $ $Date: 2003/09/26 19:30:33 $\n  */\n public class GammaDistributionImpl extends AbstractContinuousDistribution\n     implements GammaDistribution {\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n-     * @todo try to improve on this estimate\n+     * TODO: try to improve on this estimate\n      */\n     protected double getDomainLowerBound(double p) {\n         return Double.MIN_VALUE;\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n      *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n-     * @todo try to improve on this estimate\n+     * TODO: try to improve on this estimate\n      */\n     protected double getDomainUpperBound(double p) {\n         // NOTE: gamma is skewed to the left\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n-     * @todo try to improve on this estimate\n+     * TODO: try to improve on this estimate\n      */\n     protected double getInitialDomain(double p) {\n-        // NOTE: gamma is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > .5\n+        // Gamma is skewed to the left, therefore, P(X < &mu;) > .5\n \n         double ret;\n \n--- a/src/java/org/apache/commons/math/stat/AbstractStoreUnivariate.java\n+++ b/src/java/org/apache/commons/math/stat/AbstractStoreUnivariate.java\n \n /**\n  * Provides univariate measures for an array of doubles. \n- * @version $Revision: 1.10 $ $Date: 2003/07/15 03:45:10 $\n+ * @version $Revision: 1.11 $ $Date: 2003/09/26 19:30:32 $\n  */\n public abstract class AbstractStoreUnivariate\n     extends AbstractUnivariate\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat2.AbstractStoreUnivariate#getSortedValues()\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getSortedValues()\n      */\n     public double[] getSortedValues() {\n         double[] sort = getValues();\n--- a/src/java/org/apache/commons/math/stat/AbstractUnivariate.java\n+++ b/src/java/org/apache/commons/math/stat/AbstractUnivariate.java\n \n /**\n  * Provides univariate measures for an array of doubles.\n- * @version $Revision: 1.2 $ $Date: 2003/07/15 03:45:10 $  \n+ * @version $Revision: 1.3 $ $Date: 2003/09/26 19:30:32 $  \n  */\n public abstract class AbstractUnivariate implements Univariate {\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#clear()\n+     * @see org.apache.commons.math.stat.Univariate#clear()\n      */\n     public void clear() {\n         this.n = 0;\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#getWindowSize()\n+     * @see org.apache.commons.math.stat.Univariate#getWindowSize()\n      */\n     public int getWindowSize() {\n         return windowSize;\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+     * @see org.apache.commons.math.stat.Univariate#setWindowSize(int)\n      */\n     public void setWindowSize(int windowSize) {\n         clear();\n--- a/src/java/org/apache/commons/math/stat/Applyable.java\n+++ b/src/java/org/apache/commons/math/stat/Applyable.java\n-/*\n- * Created on Jul 15, 2003\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n  *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n  */\n package org.apache.commons.math.stat;\n \n /**\n  * Applyable.java\n  * \n- * To change the template for this generated type comment go to\n- * Window>Preferences>Java>Code Generation>Code and Comments\n+ * TODO: add javadocs\n  * \n  */\n public interface Applyable {\n--- a/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/BeanListUnivariateImpl.java\n  * univariate statistics for a List of Java Beans by property.  This \n  * implementation uses beanutils' PropertyUtils to get a simple, nested,\n  * indexed, mapped, or combined property from an element of a List.\n- * @version $Revision: 1.5 $ $Date: 2003/09/07 03:12:56 $\n+ * @version $Revision: 1.6 $ $Date: 2003/09/26 19:30:32 $\n  */\n public class BeanListUnivariateImpl extends ListUnivariateImpl {\n \n     }\n \n     /**\n-      * @see org.apache.commons.math.Univariate#addValue(double)\n+      * @see org.apache.commons.math.stat.Univariate#addValue(double)\n       */\n     public void addValue(double v) {\n         String msg =\n--- a/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/ListUnivariateImpl.java\n import org.apache.commons.math.util.NumberTransformer;\n \n /**\n- * @version $Revision: 1.5 $ $Date: 2003/09/07 03:12:56 $\n+ * @version $Revision: 1.6 $ $Date: 2003/09/26 19:30:32 $\n  */\n public class ListUnivariateImpl\n     extends AbstractStoreUnivariate\n     }\n \n     /**\n-     * @see org.apache.commons.math.StoreUnivariate#getValues()\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getValues()\n      */\n     public double[] getValues() {\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getElement(int)\n      */\n     public double getElement(int index) {\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#getN()\n+     * @see org.apache.commons.math.stat.Univariate#getN()\n      */\n     public int getN() {\n         int n = 0;\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#addValue(double)\n+     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n      */\n     public void addValue(double v) {\n         list.add(new Double(v));\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#clear()\n+     * @see org.apache.commons.math.stat.Univariate#clear()\n      */\n     public void clear() {\n         super.clear();\n--- a/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/StoreUnivariateImpl.java\n import org.apache.commons.math.util.ContractableDoubleArray;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2003/09/07 03:12:56 $\n+ * @version $Revision: 1.7 $ $Date: 2003/09/26 19:30:32 $\n  */\n public class StoreUnivariateImpl extends AbstractStoreUnivariate {\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.StoreUnivariate#getValues()\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getValues()\n      */\n     public double[] getValues() {\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n+     * @see org.apache.commons.math.stat.StoreUnivariate#getElement(int)\n      */\n     public double getElement(int index) {\n         return eDA.getElement(index);\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#getN()\n+     * @see org.apache.commons.math.stat.Univariate#getN()\n      */\n     public int getN() {\n         return eDA.getNumElements();\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#addValue(double)\n+     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n      */\n     public synchronized void addValue(double v) {\n         if (windowSize != Univariate.INFINITE_WINDOW) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#clear()\n+     * @see org.apache.commons.math.stat.Univariate#clear()\n      */\n     public synchronized void clear() {\n         super.clear();\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+     * @see org.apache.commons.math.stat.Univariate#setWindowSize(int)\n      */\n     public synchronized void setWindowSize(int windowSize) {\n         this.windowSize = windowSize;\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n  * Integers, floats and longs can be added, but they will be converted\n  * to doubles by addValue().\n  *\n- * @version $Revision: 1.19 $ $Date: 2003/07/15 03:45:10 $\n+ * @version $Revision: 1.20 $ $Date: 2003/09/26 19:30:32 $\n */\n public class UnivariateImpl\n     extends AbstractUnivariate\n     }\n \n     /**\n-     * @see org.apache.commons.math.Univariate#clear()\n+     * @see org.apache.commons.math.stat.Univariate#clear()\n      */\n     public void clear() {\n         super.clear();\n--- a/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ContractableDoubleArray.java\n  * internal storage array is swapped.\n  * </p>\n  * \n- * @version $Revision: 1.4 $ $Date: 2003/09/07 03:12:56 $\n+ * @version $Revision: 1.5 $ $Date: 2003/09/26 19:30:33 $\n  */\n public class ContractableDoubleArray\n     extends ExpandableDoubleArray\n      * must validate the combination of expansionFactor and \n      * contractionCriteria.\n      *\n-     * @see org.apache.commons.math.ExpandableDoubleArray#setExpansionFactor(float)\n+     * @see org.apache.commons.math.util.ExpandableDoubleArray#setExpansionFactor(float)\n      */\n     public void setExpansionFactor(float expansionFactor) {\n         checkContractExpand(getContractionCriteria(), expansionFactor);\n     }\n \n     /**\n-     * @see org.apache.commons.math.ExpandableDoubleArray#discardFrontElements(int)\n+     * @see org.apache.commons.math.util.ExpandableDoubleArray#discardFrontElements(int)\n      */\n     public synchronized void discardFrontElements(int i) {\n         super.discardFrontElements(i);\n--- a/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ExpandableDoubleArray.java\n  * expand the array 10 times - first from 2 -> 4. then 4 -> 8, 8 -> 16,\n  * and so on until we reach 4096 which is sufficient to hold 3546 elements.\n  * </p>\n- * @version $Revision: 1.5 $ $Date: 2003/09/07 03:12:56 $\n+ * @version $Revision: 1.6 $ $Date: 2003/09/26 19:30:33 $\n  */\n public class ExpandableDoubleArray implements Serializable, DoubleArray {\n \n     }\n \n     /**\n-     * @see org.apache.commons.math.DoubleArray#getElements()\n+     * @see org.apache.commons.math.util.DoubleArray#getElements()\n      */\n     public double[] getElements() {\n         double[] elementArray = new double[numElements];\n--- a/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/FixedDoubleArray.java\n  * \"fixed\" in memory, this implementation will never allocate, or copy\n  * the internal storage array to a new array instance.\n  * </p>\n- * @version $Revision: 1.6 $ $Date: 2003/09/07 03:12:56 $\n+ * @version $Revision: 1.7 $ $Date: 2003/09/26 19:30:33 $\n  */\n public class FixedDoubleArray implements DoubleArray {\n \n \n     /**\n      * Retrieves the current size of the array.\n-     * @see org.apache.commons.math.DoubleArray#getNumElements()\n+     * @see org.apache.commons.math.util.DoubleArray#getNumElements()\n      */\n     public int getNumElements() {\n         return size;\n      * 2 - trying to retrieve an element outside of the current element\n      * array will throw an ArrayIndexOutOfBoundsException.\n      *\n-     * @see org.apache.commons.math.DoubleArray#getElement(int)\n+     * @see org.apache.commons.math.util.DoubleArray#getElement(int)\n      */\n     public double getElement(int index) {\n         if (index > (size - 1)) {\n      * </ul>\n      * </p>\n      *\n-     * @see org.apache.commons.math.DoubleArray#setElement(int, double)\n+     * @see org.apache.commons.math.util.DoubleArray#setElement(int, double)\n      */\n     public void setElement(int index, double value) {\n         if (index > (size - 1)) {\n      * this array has already met or exceeded the maximum number\n      * of elements\n      *\n-     * @see org.apache.commons.math.DoubleArray#addElement(double)\n+     * @see org.apache.commons.math.util.DoubleArray#addElement(double)\n      */\n     public void addElement(double value) {\n         if (size < internalArray.length) {\n      * \n      * @return The array of elements added to this DoubleArray\n      *         implementation.\n-     * @see org.apache.commons.math.DoubleArray#getElements()\n+     * @see org.apache.commons.math.util.DoubleArray#getElements()\n      */\n     public double[] getElements() {\n         double[] copy = new double[size];\n      * setting the size of the array back to zero, and reinitializing\n      * the internal storage array.\n      *\n-     * @see org.apache.commons.math.DoubleArray#clear()\n+     * @see org.apache.commons.math.util.DoubleArray#clear()\n      */\n     public void clear() {\n         size = 0;\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n  * 2. Redistributions in binary form must reproduce the above copyright\n  *    notice, this list of conditions and the following disclaimer in\n  *    the documentation and/or other materials provided with the\n- *    distribution. \n+ *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n  *    any, must include the following acknowlegement:\n /**\n  * Test cases for the RandomData class.\n  *\n- * @version $Revision: 1.2 $ $Date: 2003/07/07 23:19:21 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/26 19:30:33 $\n  */\n \n public final class RandomDataTest extends TestCase {", "timestamp": 1064604633, "metainfo": ""}