{"sha": "7486b9ea36c6112ba8a0b2c93b6da4833eb0e028", "log": "fixed varargs declaration warnings  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/function/Gaussian.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Gaussian.java\n          * not 3.\n          * @throws NotStrictlyPositiveException if {@code param[2]} is negative.\n          */\n-        public double value(double x,\n-                            double[] param) {\n+        public double value(double x, double ... param) {\n             validateParameters(param);\n \n             final double diff = x - param[1];\n          * not 3.\n          * @throws NotStrictlyPositiveException if {@code param[2]} is negative.\n          */\n-        public double[] gradient(double x, double[] param) {\n+        public double[] gradient(double x, double ... param) {\n             validateParameters(param);\n \n             final double norm = param[0];\n--- a/src/main/java/org/apache/commons/math/analysis/function/HarmonicOscillator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/HarmonicOscillator.java\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 3.\n          */\n-        public double value(double x,\n-                            double[] param) {\n+        public double value(double x, double ... param) {\n             validateParameters(param);\n             return HarmonicOscillator.value(x * param[1] + param[2], param[0]);\n         }\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 3.\n          */\n-        public double[] gradient(double x, double[] param) {\n+        public double[] gradient(double x, double ... param) {\n             validateParameters(param);\n \n             final double amplitude = param[0];\n--- a/src/main/java/org/apache/commons/math/analysis/function/Logistic.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Logistic.java\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 6.\n          */\n-        public double value(double x,\n-                            double[] param) {\n+        public double value(double x, double ... param) {\n             validateParameters(param);\n             return Logistic.value(param[1] - x, param[0],\n                                   param[2], param[3],\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 6.\n          */\n-        public double[] gradient(double x, double[] param) {\n+        public double[] gradient(double x, double ... param) {\n             validateParameters(param);\n \n             final double b = param[2];\n--- a/src/main/java/org/apache/commons/math/analysis/function/Logit.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Logit.java\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 2.\n          */\n-        public double value(double x,\n-                            double[] param) {\n+        public double value(double x, double ... param) {\n             validateParameters(param);\n             return Logit.value(x, param[0], param[1]);\n         }\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 2.\n          */\n-        public double[] gradient(double x, double[] param) {\n+        public double[] gradient(double x, double ... param) {\n             validateParameters(param);\n \n             final double lo = param[0];\n--- a/src/main/java/org/apache/commons/math/analysis/function/Sigmoid.java\n+++ b/src/main/java/org/apache/commons/math/analysis/function/Sigmoid.java\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 2.\n          */\n-        public double value(double x,\n-                            double[] param) {\n+        public double value(double x, double ... param) {\n             validateParameters(param);\n             return Sigmoid.value(x, param[0], param[1]);\n         }\n          * @throws DimensionMismatchException if the size of {@code param} is\n          * not 2.\n          */\n-        public double[] gradient(double x, double[] param) {\n+        public double[] gradient(double x, double ... param) {\n             validateParameters(param);\n \n             final double lo = param[0];\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n      */\n     public static class Parametric implements ParametricUnivariateRealFunction {\n         /** {@inheritDoc} */\n-        public double[] gradient(double x, double[] parameters) {\n+        public double[] gradient(double x, double ... parameters) {\n             final double[] gradient = new double[parameters.length];\n             double xn = 1.0;\n             for (int i = 0; i < parameters.length; ++i) {\n         }\n \n         /** {@inheritDoc} */\n-        public double value(final double x, final double[] parameters) {\n+        public double value(final double x, final double ... parameters) {\n             return PolynomialFunction.evaluate(parameters, x);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n         final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n                 private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n \n-                public double value(double x, double[] p) {\n+                public double value(double x, double ... p) {\n                     double v = Double.POSITIVE_INFINITY;\n                     try {\n                         v = g.value(x, p);\n                     return v;\n                 }\n \n-                public double[] gradient(double x, double[] p) {\n+                public double[] gradient(double x, double ... p) {\n                     double[] v = { Double.POSITIVE_INFINITY,\n                                    Double.POSITIVE_INFINITY,\n                                    Double.POSITIVE_INFINITY };\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/CurveFitterTest.java\n \n         ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n \n-            public double value(double x, double[] parameters) {\n+            public double value(double x, double ... parameters) {\n \n                 double a = parameters[0];\n                 double b = parameters[1];\n                 return d + ((a - d) / (1 + FastMath.pow(x / c, b)));\n             }\n \n-            public double[] gradient(double x, double[] parameters) {\n+            public double[] gradient(double x, double ... parameters) {\n \n                 double a = parameters[0];\n                 double b = parameters[1];\n \n     private static class SimpleInverseFunction implements ParametricUnivariateRealFunction {\n \n-        public double value(double x, double[] parameters) {\n+        public double value(double x, double ... parameters) {\n             return parameters[0] / x + (parameters.length < 2 ? 0 : parameters[1]);\n         }\n \n-        public double[] gradient(double x, double[] doubles) {\n+        public double[] gradient(double x, double ... doubles) {\n             double[] gradientVector = new double[doubles.length];\n             gradientVector[0] = 1 / x;\n             if (doubles.length >= 2) {", "timestamp": 1300889085, "metainfo": ""}