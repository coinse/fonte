{"sha": "8e43e2c78be1e28bb274d8cd4869c39b8a1d4bb1", "log": "added matrix transformer to bi-diagonal shape (for later use by singular value decomposition)  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Class transforming any matrix to bi-diagonal shape.\n+ * <p>Any m &times; n matrix A can be written as the product of three matrices:\n+ * A = U &times; B &times; V<sup>T</sup> with U an m &times; m orthogonal matrix,\n+ * B an m &times; n bi-diagonal matrix (lower diagonal if m &lt; n, upper diagonal\n+ * otherwise), and V an n &times; n orthogonal matrix.</p>\n+ * <p>Transformation to bi-diagonal shape is often not a goal by itself, but it is\n+ * an intermediate step in more general decomposition algorithms like {@link\n+ * SingularValueDecomposition Singular Value Decomposition}. This class is therefore\n+ * intended for internal use by the library and is not public. As a consequence of\n+ * this explicitly limited scope, many methods directly returns references to\n+ * internal arrays, not copies.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class BiDiagonalTransformer implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8935390784125343332L;\n+\n+    /** Householder vectors. */\n+    private final double householderVectors[][];\n+\n+    /** Main diagonal. */\n+    private final double[] main;\n+\n+    /** Secondary diagonal. */\n+    private final double[] secondary;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of B. */\n+    private RealMatrix cachedB;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /**\n+     * Build the transformation to bi-diagonal shape of a matrix. \n+     * @param matrix The matrix to transform.\n+     */\n+    public BiDiagonalTransformer(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        final int p = Math.min(m, n);\n+        householderVectors = matrix.getData();\n+        main      = new double[p];\n+        secondary = new double[p - 1];\n+        cachedU   = null;\n+        cachedB   = null;\n+        cachedV   = null;\n+\n+        // transform matrix\n+        if (m >= n) {\n+            transformToUpperBiDiagonal();\n+        } else {\n+            transformToLowerBiDiagonal();\n+        }\n+\n+    }\n+\n+    /**\n+     * Returns the matrix U of the transform. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix\n+     */\n+    public RealMatrix getU() {\n+\n+        if (cachedU == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            final int p = main.length;\n+            final int diagOffset    = (m >= n) ? 0 : 1;\n+            final double[] diagonal = (m >= n) ? main : secondary;\n+            final double[][] uData  = new double[m][m];\n+\n+            // fill up the part of the matrix not affected by Householder transforms\n+            for (int k = m - 1; k >= p; --k) {\n+                uData[k][k] = 1;\n+            }\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = p - 1; k >= diagOffset; --k) {\n+                final double[] hK = householderVectors[k];\n+                uData[k][k] = 1;\n+                if (hK[k - diagOffset] != 0.0) {\n+                    for (int j = k; j < m; ++j) {\n+                        double alpha = 0;\n+                        for (int i = k; i < m; ++i) {\n+                            alpha -= uData[i][j] * householderVectors[i][k - diagOffset];\n+                        }\n+                        alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];\n+\n+                        for (int i = k; i < m; ++i) {\n+                            uData[i][j] -= alpha * householderVectors[i][k - diagOffset];\n+                        }\n+                    }\n+                }\n+            }\n+            if (diagOffset > 0) {\n+                uData[0][0] = 1;\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedU = new RealMatrixImpl(uData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedU;\n+\n+    }\n+\n+    /**\n+     * Returns the bi-diagonal matrix B of the transform. \n+     * @return the B matrix\n+     */\n+    public RealMatrix getB() {\n+\n+        if (cachedB == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            double[][] bData = new double[m][n];\n+            for (int i = 0; i < main.length; ++i) {\n+                bData[i][i] = main[i];\n+                if (i < main.length - 1) {\n+                    if (m < n) {\n+                        bData[i + 1][i] = secondary[i];\n+                    } else {\n+                        bData[i][i + 1] = secondary[i];\n+                    }\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedB = new RealMatrixImpl(bData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedB;\n+\n+    }\n+\n+    /**\n+     * Returns the matrix V of the transform. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix\n+     */\n+    public RealMatrix getV() {\n+\n+        if (cachedV == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            final int p = main.length;\n+            final int diagOffset    = (m >= n) ? 1 : 0;\n+            final double[] diagonal = (m >= n) ? secondary : main;\n+            final double[][] vData  = new double[n][n];\n+\n+            // fill up the part of the matrix not affected by Householder transforms\n+            for (int k = n - 1; k >= p; --k) {\n+                vData[k][k] = 1;\n+            }\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = p - 1; k >= diagOffset; --k) {\n+                final double[] hK = householderVectors[k - diagOffset];\n+                vData[k][k] = 1;\n+                if (hK[k] != 0.0) {\n+                    for (int j = k; j < n; ++j) {\n+                        double beta = 0;\n+                        for (int i = k; i < n; ++i) {\n+                            beta -= vData[i][j] * hK[i];\n+                        }\n+                        beta /= diagonal[k - diagOffset] * hK[k];\n+\n+                        for (int i = k; i < n; ++i) {\n+                            vData[i][j] -= beta * hK[i];\n+                        }\n+                    }\n+                }\n+            }\n+            if (diagOffset > 0) {\n+                vData[0][0] = 1;\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedV = new RealMatrixImpl(vData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /**\n+     * Get the Householder vectors of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[][] getHouseholderVectorsRef() {\n+        return householderVectors;\n+    }\n+\n+    /**\n+     * Get the main diagonal elements of the matrix B of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[] getMainDiagonalRef() {\n+        return main;\n+    }\n+\n+    /**\n+     * Get the secondary diagonal elements of the matrix B of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the secondary diagonal elements of the B matrix\n+     */\n+    double[] getSecondaryDiagonalRef() {\n+        return secondary;\n+    }\n+\n+    /**\n+     * Check if the matrix is transformed to upper bi-diagonal.\n+     * @return true if the matrix is transformed to upper bi-diagonal\n+     */\n+    boolean isUpperBiDiagonal() {\n+        return householderVectors.length >=  householderVectors[0].length;\n+    }\n+\n+    /**\n+     * Transform original matrix to upper bi-diagonal form.\n+     * <p>Transformation is done using alternate Householder transforms\n+     * on columns and rows.</p>\n+     */\n+    private void transformToUpperBiDiagonal() {\n+\n+        final int m = householderVectors.length;\n+        final int n = householderVectors[0].length;\n+        for (int k = 0; k < n; k++) {\n+\n+            //zero-out a column\n+            double xNormSqr = 0;\n+            for (int i = k; i < m; ++i) {\n+                final double c = householderVectors[i][k];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (householderVectors[k][k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            main[k] = a;\n+            if (a != 0.0) {\n+                householderVectors[k][k] -= a;\n+                for (int j = k + 1; j < n; ++j) {\n+                    double alpha = 0;\n+                    for (int i = k; i < m; ++i) {\n+                        final double[] uvI = householderVectors[i];\n+                        alpha -= uvI[j] * uvI[k];\n+                    }\n+                    alpha /= a * householderVectors[k][k];\n+                    for (int i = k; i < m; ++i) {\n+                        final double[] uvI = householderVectors[i];\n+                        uvI[j] -= alpha * uvI[k];\n+                    }\n+                }\n+            }\n+\n+            if (k < n - 1) {\n+                //zero-out a row\n+                final double[] uvK = householderVectors[k];\n+                xNormSqr = 0;\n+                for (int j = k + 1; j < n; ++j) {\n+                    final double c = uvK[j];\n+                    xNormSqr += c * c;\n+                }\n+                final double b = (uvK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                secondary[k] = b;\n+                if (b != 0.0) {\n+                    uvK[k + 1] -= b;\n+                    for (int i = k + 1; i < m; ++i) {\n+                        final double[] uvI = householderVectors[i];\n+                        double beta = 0;\n+                        for (int j = k + 1; j < n; ++j) {\n+                            beta -= uvI[j] * uvK[j];\n+                        }\n+                        beta /= b * uvK[k + 1];\n+                        for (int j = k + 1; j < n; ++j) {\n+                            uvI[j] -= beta * uvK[j];\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Transform original matrix to lower bi-diagonal form.\n+     * <p>Transformation is done using alternate Householder transforms\n+     * on rows and columns.</p>\n+     */\n+    private void transformToLowerBiDiagonal() {\n+\n+        final int m = householderVectors.length;\n+        final int n = householderVectors[0].length;\n+        for (int k = 0; k < m; k++) {\n+\n+            //zero-out a row\n+            final double[] uvK = householderVectors[k];\n+            double xNormSqr = 0;\n+            for (int j = k; j < n; ++j) {\n+                final double c = uvK[j];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (uvK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            main[k] = a;\n+            if (a != 0.0) {\n+                uvK[k] -= a;\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] uvI = householderVectors[i];\n+                    double alpha = 0;\n+                    for (int j = k; j < n; ++j) {\n+                        alpha -= uvI[j] * uvK[j];\n+                    }\n+                    alpha /= a * householderVectors[k][k];\n+                    for (int j = k; j < n; ++j) {\n+                        uvI[j] -= alpha * uvK[j];\n+                    }\n+                }\n+            }\n+\n+            if (k < m - 1) {\n+                //zero-out a column\n+                xNormSqr = 0;\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double c = householderVectors[i][k];\n+                    xNormSqr += c * c;\n+                }\n+                final double b = (householderVectors[k + 1][k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                secondary[k] = b;\n+                if (b != 0.0) {\n+                    householderVectors[k + 1][k] -= b;\n+                    for (int j = k + 1; j < n; ++j) {\n+                        double beta = 0;\n+                        for (int i = k + 1; i < m; ++i) {\n+                            final double[] uvI = householderVectors[i];\n+                            beta -= uvI[j] * uvI[k];\n+                        }\n+                        beta /= b * householderVectors[k + 1][k];\n+                        for (int i = k + 1; i < m; ++i) {\n+                            final double[] uvI = householderVectors[i];\n+                            uvI[j] -= beta * uvI[k];\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class BiDiagonalTransformerTest extends TestCase {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private double[][] testNonSquare = {\n+        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },\n+        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },\n+        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },\n+        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },\n+    };\n+\n+    public BiDiagonalTransformerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testDimensions() {\n+        checkdimensions(new RealMatrixImpl(testSquare, false));\n+        checkdimensions(new RealMatrixImpl(testNonSquare, false));\n+        checkdimensions(new RealMatrixImpl(testNonSquare, false).transpose());\n+    }\n+\n+    private void checkdimensions(RealMatrix matrix) {\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);\n+        assertEquals(m, transformer.getU().getRowDimension());\n+        assertEquals(m, transformer.getU().getColumnDimension());\n+        assertEquals(m, transformer.getB().getRowDimension());\n+        assertEquals(n, transformer.getB().getColumnDimension());\n+        assertEquals(n, transformer.getV().getRowDimension());\n+        assertEquals(n, transformer.getV().getColumnDimension());\n+\n+    }\n+\n+    public void testAEqualUSVt() {\n+        checkAEqualUSVt(new RealMatrixImpl(testSquare, false));\n+        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false));\n+        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false).transpose());\n+    }\n+\n+    private void checkAEqualUSVt(RealMatrix matrix) {\n+        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);\n+        RealMatrix u = transformer.getU();\n+        RealMatrix b = transformer.getB();\n+        RealMatrix v = transformer.getV();\n+        double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 1.0e-14);\n+    }\n+\n+    public void testUOrthogonal() {\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getU());\n+    }\n+\n+    public void testVOrthogonal() {\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getV());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);        \n+    }\n+\n+    public void testBBiDiagonal() {\n+        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getB());\n+    }\n+\n+    private void checkBiDiagonal(RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if (rows < cols) {\n+                    if ((i < j) || (i > j + 1)) {\n+                        assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                    }                    \n+                } else {\n+                    if ((i < j - 1) || (i > j)) {\n+                        assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testMatricesValues() {\n+       BiDiagonalTransformer transformer =\n+            new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false));\n+       final double s17 = Math.sqrt(17.0);\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+                {  -8 / (5 * s17), 19 / (5 * s17) },\n+                { -19 / (5 * s17), -8 / (5 * s17) }\n+        });\n+        RealMatrix bRef = new RealMatrixImpl(new double[][] {\n+                { -3 * s17 / 5, 32 * s17 / 85 },\n+                {      0.0,     -5 * s17 / 17 }\n+        });\n+        RealMatrix vRef = new RealMatrixImpl(new double[][] {\n+                { 1.0,  0.0 },\n+                { 0.0, -1.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix u = transformer.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);\n+        RealMatrix b = transformer.getB();\n+        assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);\n+        RealMatrix v = transformer.getV();\n+        assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(u == transformer.getU());\n+        assertTrue(b == transformer.getB());\n+        assertTrue(v == transformer.getV());\n+        \n+    }\n+\n+    public void testUpperOrLower() {\n+        assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).isUpperBiDiagonal());\n+        assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).isUpperBiDiagonal());\n+        assertFalse(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).isUpperBiDiagonal());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(BiDiagonalTransformerTest.class);\n+    }\n+\n+}", "timestamp": 1220433509, "metainfo": ""}