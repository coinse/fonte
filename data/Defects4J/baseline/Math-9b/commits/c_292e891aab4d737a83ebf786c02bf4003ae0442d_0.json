{"sha": "292e891aab4d737a83ebf786c02bf4003ae0442d", "log": "use standard declaration order rules  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/DimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/DimensionMismatchException.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1316089546353786411L;\n \n+    /** First dimension. */\n+    private final int dimension1;\n+\n+    /** Second dimension. */\n+    private final int dimension2;\n+\n     /**\n      * Construct an exception from the mismatched dimensions\n      * @param dimension1 first dimension\n      * @param dimension2 second dimension\n      */\n-    public DimensionMismatchException(int dimension1, int dimension2) {\n+    public DimensionMismatchException(final int dimension1, final int dimension2) {\n         super(\"dimension mismatch {0} != {1}\", dimension1, dimension2);\n         this.dimension1 = dimension1;\n         this.dimension2 = dimension2;\n         return dimension2;\n     }\n \n-    /** First dimension. */\n-    private int dimension1;\n-\n-    /** Second dimension. */\n-    private int dimension2;\n-\n }\n--- a/src/main/java/org/apache/commons/math/MathException.java\n+++ b/src/main/java/org/apache/commons/math/MathException.java\n     private final Object[] arguments;\n \n     /**\n-     * Translate a string to a given locale.\n-     * @param s string to translate\n-     * @param locale locale into which to translate the string\n-     * @return translated string or original string\n-     * for unsupported locales or unknown strings\n-     */\n-    private static String translate(String s, Locale locale) {\n-        try {\n-            ResourceBundle bundle =\n-                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n-            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n-                // the value of the resource is the translated string\n-                return bundle.getString(s);\n-            }\n-\n-        } catch (MissingResourceException mre) {\n-            // do nothing here\n-        }\n-\n-        // the locale is not supported or the resource is unknown\n-        // don't translate and fall back to using the string as is\n-        return s;\n-\n-    }\n-\n-    /**\n-     * Builds a message string by from a pattern and its arguments.\n-     * @param locale Locale in which the message should be translated\n-     * @param pattern format specifier\n-     * @param arguments format arguments\n-     * @return a message string\n-     */\n-    private static String buildMessage(Locale locale, String pattern, Object ... arguments) {\n-        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n-    }\n-\n-    /**\n      * Constructs a new <code>MathException</code> with no\n      * detail message.\n      */\n       super(buildMessage(Locale.US, pattern, arguments), rootCause);\n       this.pattern   = pattern;\n       this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /**\n+     * Translate a string to a given locale.\n+     * @param s string to translate\n+     * @param locale locale into which to translate the string\n+     * @return translated string or original string\n+     * for unsupported locales or unknown strings\n+     */\n+    private static String translate(String s, Locale locale) {\n+        try {\n+            ResourceBundle bundle =\n+                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n+            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n+                // the value of the resource is the translated string\n+                return bundle.getString(s);\n+            }\n+\n+        } catch (MissingResourceException mre) {\n+            // do nothing here\n+        }\n+\n+        // the locale is not supported or the resource is unknown\n+        // don't translate and fall back to using the string as is\n+        return s;\n+\n+    }\n+\n+    /**\n+     * Builds a message string by from a pattern and its arguments.\n+     * @param locale Locale in which the message should be translated\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return a message string\n+     */\n+    private static String buildMessage(Locale locale, String pattern, Object ... arguments) {\n+        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n     }\n \n     /** Gets the pattern used to build the message of this throwable.\n--- a/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n     private final Object[] arguments;\n \n     /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathRuntimeException(final String pattern, final Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments));\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public MathRuntimeException(final Throwable rootCause) {\n+        super(rootCause);\n+        this.pattern   = getMessage();\n+        this.arguments = new Object[0];\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathRuntimeException(final Throwable rootCause,\n+                                final String pattern, final Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments), rootCause);\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /**\n      * Translate a string to a given locale.\n      * @param s string to translate\n      * @param locale locale into which to translate the string\n     private static String buildMessage(final Locale locale, final String pattern,\n                                        final Object ... arguments) {\n         return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n-    }\n-\n-    /**\n-     * Constructs a new <code>MathRuntimeException</code> with specified\n-     * formatted detail message.\n-     * Message formatting is delegated to {@link java.text.MessageFormat}.\n-     * @param pattern format specifier\n-     * @param arguments format arguments\n-     */\n-    public MathRuntimeException(final String pattern, final Object ... arguments) {\n-      super(buildMessage(Locale.US, pattern, arguments));\n-      this.pattern   = pattern;\n-      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n-    }\n-\n-    /**\n-     * Constructs a new <code>MathRuntimeException</code> with specified\n-     * nested <code>Throwable</code> root cause.\n-     *\n-     * @param rootCause  the exception or error that caused this exception\n-     *                   to be thrown.\n-     */\n-    public MathRuntimeException(final Throwable rootCause) {\n-        super(rootCause);\n-        this.pattern   = getMessage();\n-        this.arguments = new Object[0];\n-    }\n-\n-    /**\n-     * Constructs a new <code>MathRuntimeException</code> with specified\n-     * formatted detail message and nested <code>Throwable</code> root cause.\n-     * Message formatting is delegated to {@link java.text.MessageFormat}.\n-     * @param rootCause the exception or error that caused this exception\n-     * to be thrown.\n-     * @param pattern format specifier\n-     * @param arguments format arguments\n-     */\n-    public MathRuntimeException(final Throwable rootCause,\n-                                final String pattern, final Object ... arguments) {\n-      super(buildMessage(Locale.US, pattern, arguments), rootCause);\n-      this.pattern   = pattern;\n-      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n \n     /** Gets the pattern used to build the message of this throwable.\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n  */\n public class MessagesResources_fr\n   extends ListResourceBundle {\n-\n-  /**\n-   * Simple constructor.\n-   */\n-  public MessagesResources_fr() {\n-  }\n-\n-  /**\n-   * Get the non-translated/translated messages arrays from this resource bundle.\n-   * @return non-translated/translated messages arrays\n-   */\n-  @Override\n-  public Object[][] getContents() {\n-    return CONTENTS.clone();\n-  }\n \n   /** Non-translated/translated messages arrays. */\n   private static final Object[][] CONTENTS = {\n \n   };\n \n+  /**\n+   * Simple constructor.\n+   */\n+  public MessagesResources_fr() {\n+  }\n+\n+  /**\n+   * Get the non-translated/translated messages arrays from this resource bundle.\n+   * @return non-translated/translated messages arrays\n+   */\n+  @Override\n+  public Object[][] getContents() {\n+    return CONTENTS.clone();\n+  }\n+\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n public class LoessInterpolator\n         implements UnivariateRealInterpolator, Serializable {\n \n+    /** Default value of the bandwidth parameter. */\n+    public static final double DEFAULT_BANDWIDTH = 0.3;\n+\n+    /** Default value of the number of robustness iterations. */\n+    public static final int DEFAULT_ROBUSTNESS_ITERS = 2;\n+\n     /** serializable version identifier. */\n     private static final long serialVersionUID = 5204927143605193821L;\n-\n-    /**\n-     * Default value of the bandwidth parameter.\n-     */\n-    public static final double DEFAULT_BANDWIDTH = 0.3;\n-    /**\n-     * Default value of the number of robustness iterations.\n-     */\n-    public static final int DEFAULT_ROBUSTNESS_ITERS = 2;\n \n     /**\n      * The bandwidth parameter: when computing the loess fit at\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n         }\n     }\n \n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the factory.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n      */\n     private static class LazyHolder {\n-\n-        /** Private constructor. */\n-        private LazyHolder() {\n-        }\n-\n         /** Cached solver factory */\n-        private static final UnivariateRealSolverFactory FACTORY =\n-            UnivariateRealSolverFactory.newInstance();\n-\n-    }\n+        private static final UnivariateRealSolverFactory FACTORY = UnivariateRealSolverFactory.newInstance();\n+    }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n \n }\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n  */\n public class Complex implements FieldElement<Complex>, Serializable  {\n \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -6195664516687396620L;\n-\n     /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n     public static final Complex I = new Complex(0.0, 1.0);\n \n     /** A complex number representing \"0.0 + 0.0i\" */\n     public static final Complex ZERO = new Complex(0.0, 0.0);\n \n-    /**\n-     * The imaginary part\n-     */\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6195664516687396620L;\n+\n+    /** The imaginary part. */\n     private final double imaginary;\n \n-    /**\n-     * The real part\n-     */\n+    /** The real part. */\n     private final double real;\n \n-    /**\n-     * Record whether this complex number is equal to NaN\n-     */\n+    /** Record whether this complex number is equal to NaN. */\n     private final transient boolean isNaN;\n \n-    /**\n-     * Record whether this complex number is infinite\n-     */\n+    /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n \n     /**\n--- a/src/main/java/org/apache/commons/math/complex/ComplexField.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexField.java\n         return Complex.ZERO;\n     }\n \n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n      */\n     private static class LazyHolder {\n-\n-        /** Private constructor. */\n-        private LazyHolder() {\n-        }\n-\n         /** Cached field instance. */\n         private static final ComplexField INSTANCE = new ComplexField();\n-\n     }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n \n     /** Handle deserialization of the singleton.\n      * @return the singleton instance\n--- a/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n     /** Default maximal number of cost evaluations allowed. */\n     public static final int DEFAULT_MAX_COST_EVALUATIONS = 100;\n \n+    /** Array of measurements. */\n+    protected WeightedMeasurement[] measurements;\n+\n+    /** Array of parameters. */\n+    protected EstimatedParameter[] parameters;\n+\n+    /**\n+     * Jacobian matrix.\n+     * <p>This matrix is in canonical form just after the calls to\n+     * {@link #updateJacobian()}, but may be modified by the solver\n+     * in the derived class (the {@link LevenbergMarquardtEstimator\n+     * Levenberg-Marquardt estimator} does this).</p>\n+     */\n+    protected double[] jacobian;\n+\n+    /** Number of columns of the jacobian matrix. */\n+    protected int cols;\n+\n+    /** Number of rows of the jacobian matrix. */\n+    protected int rows;\n+\n+    /** Residuals array.\n+     * <p>This array is in canonical form just after the calls to\n+     * {@link #updateJacobian()}, but may be modified by the solver\n+     * in the derived class (the {@link LevenbergMarquardtEstimator\n+     * Levenberg-Marquardt estimator} does this).</p>\n+     */\n+    protected double[] residuals;\n+\n+    /** Cost value (square root of the sum of the residuals). */\n+    protected double cost;\n+\n+    /** Maximal allowed number of cost evaluations. */\n+    private int maxCostEval;\n+\n+    /** Number of cost evaluations. */\n+    private int costEvaluations;\n+\n+    /** Number of jacobian evaluations. */\n+    private int jacobianEvaluations;\n+\n     /**\n      * Build an abstract estimator for least squares problems.\n      * <p>The maximal number of cost evaluations allowed is set\n     public abstract void estimate(EstimationProblem problem)\n     throws EstimationException;\n \n-    /** Array of measurements. */\n-    protected WeightedMeasurement[] measurements;\n-\n-    /** Array of parameters. */\n-    protected EstimatedParameter[] parameters;\n-\n-    /**\n-     * Jacobian matrix.\n-     * <p>This matrix is in canonical form just after the calls to\n-     * {@link #updateJacobian()}, but may be modified by the solver\n-     * in the derived class (the {@link LevenbergMarquardtEstimator\n-     * Levenberg-Marquardt estimator} does this).</p>\n-     */\n-    protected double[] jacobian;\n-\n-    /** Number of columns of the jacobian matrix. */\n-    protected int cols;\n-\n-    /** Number of rows of the jacobian matrix. */\n-    protected int rows;\n-\n-    /** Residuals array.\n-     * <p>This array is in canonical form just after the calls to\n-     * {@link #updateJacobian()}, but may be modified by the solver\n-     * in the derived class (the {@link LevenbergMarquardtEstimator\n-     * Levenberg-Marquardt estimator} does this).</p>\n-     */\n-    protected double[] residuals;\n-\n-    /** Cost value (square root of the sum of the residuals). */\n-    protected double cost;\n-\n-    /** Maximal allowed number of cost evaluations. */\n-    private int maxCostEval;\n-\n-    /** Number of cost evaluations. */\n-    private int costEvaluations;\n-\n-    /** Number of jacobian evaluations. */\n-    private int jacobianEvaluations;\n-\n }\n--- a/src/main/java/org/apache/commons/math/estimation/EstimatedParameter.java\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimatedParameter.java\n public class EstimatedParameter\n   implements Serializable {\n \n-  /** Simple constructor.\n-   * Build an instance from a first estimate of the parameter,\n-   * initially considered unbound.\n-   * @param name name of the parameter\n-   * @param firstEstimate first estimate of the parameter\n-   */\n-  public EstimatedParameter(String name, double firstEstimate) {\n-    this.name = name;\n-    estimate  = firstEstimate;\n-    bound     = false;\n-  }\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -555440800213416949L;\n \n-  /** Simple constructor.\n-   * Build an instance from a first estimate of the parameter and a\n-   * bound flag\n-   * @param name name of the parameter\n-   * @param firstEstimate first estimate of the parameter\n-   * @param bound flag, should be true if the parameter is bound\n-   */\n-  public EstimatedParameter(String name,\n-                            double firstEstimate,\n-                            boolean bound) {\n-    this.name  = name;\n-    estimate   = firstEstimate;\n-    this.bound = bound;\n-  }\n+    /** Current value of the parameter */\n+    protected double  estimate;\n \n-  /** Copy constructor.\n-   * Build a copy of a parameter\n-   * @param parameter instance to copy\n-   */\n-  public EstimatedParameter(EstimatedParameter parameter) {\n-    name     = parameter.name;\n-    estimate = parameter.estimate;\n-    bound    = parameter.bound;\n-  }\n+    /** Name of the parameter */\n+    private   String  name;\n \n-  /** Set a new estimated value for the parameter.\n-   * @param estimate new estimate for the parameter\n-   */\n-  public void setEstimate(double estimate) {\n-    this.estimate = estimate;\n-  }\n+    /** Indicator for bound parameters\n+     * (ie parameters that should not be estimated)\n+     */\n+    private   boolean bound;\n \n-  /** Get the current estimate of the parameter\n-   * @return current estimate\n-   */\n-  public double getEstimate() {\n-    return estimate;\n-  }\n+    /** Simple constructor.\n+     * Build an instance from a first estimate of the parameter,\n+     * initially considered unbound.\n+     * @param name name of the parameter\n+     * @param firstEstimate first estimate of the parameter\n+     */\n+    public EstimatedParameter(String name, double firstEstimate) {\n+        this.name = name;\n+        estimate  = firstEstimate;\n+        bound     = false;\n+    }\n \n-  /** get the name of the parameter\n-   * @return parameter name\n-   */\n-  public String getName() {\n-    return name;\n-  }\n+    /** Simple constructor.\n+     * Build an instance from a first estimate of the parameter and a\n+     * bound flag\n+     * @param name name of the parameter\n+     * @param firstEstimate first estimate of the parameter\n+     * @param bound flag, should be true if the parameter is bound\n+     */\n+    public EstimatedParameter(String name,\n+                              double firstEstimate,\n+                              boolean bound) {\n+        this.name  = name;\n+        estimate   = firstEstimate;\n+        this.bound = bound;\n+    }\n \n-  /** Set the bound flag of the parameter\n-   * @param bound this flag should be set to true if the parameter is\n-   * bound (i.e. if it should not be adjusted by the solver).\n-   */\n-  public void setBound(boolean bound) {\n-    this.bound = bound;\n-  }\n+    /** Copy constructor.\n+     * Build a copy of a parameter\n+     * @param parameter instance to copy\n+     */\n+    public EstimatedParameter(EstimatedParameter parameter) {\n+        name     = parameter.name;\n+        estimate = parameter.estimate;\n+        bound    = parameter.bound;\n+    }\n \n-  /** Check if the parameter is bound\n-   * @return true if the parameter is bound */\n-  public boolean isBound() {\n-    return bound;\n-  }\n+    /** Set a new estimated value for the parameter.\n+     * @param estimate new estimate for the parameter\n+     */\n+    public void setEstimate(double estimate) {\n+        this.estimate = estimate;\n+    }\n \n-  /** Name of the parameter */\n-  private   String  name;\n+    /** Get the current estimate of the parameter\n+     * @return current estimate\n+     */\n+    public double getEstimate() {\n+        return estimate;\n+    }\n \n-  /** Current value of the parameter */\n-  protected double  estimate;\n+    /** get the name of the parameter\n+     * @return parameter name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n \n-  /** Indicator for bound parameters\n-   * (ie parameters that should not be estimated)\n-   */\n-  private   boolean bound;\n+    /** Set the bound flag of the parameter\n+     * @param bound this flag should be set to true if the parameter is\n+     * bound (i.e. if it should not be adjusted by the solver).\n+     */\n+    public void setBound(boolean bound) {\n+        this.bound = bound;\n+    }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -555440800213416949L;\n+    /** Check if the parameter is bound\n+     * @return true if the parameter is bound */\n+    public boolean isBound() {\n+        return bound;\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n @Deprecated\n public class LevenbergMarquardtEstimator extends AbstractEstimator implements Serializable {\n \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5705952631533171019L;\n+\n+    /** Number of solved variables. */\n+    private int solvedCols;\n+\n+    /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n+    private double[] diagR;\n+\n+    /** Norms of the columns of the jacobian matrix. */\n+    private double[] jacNorm;\n+\n+    /** Coefficients of the Householder transforms vectors. */\n+    private double[] beta;\n+\n+    /** Columns permutation array. */\n+    private int[] permutation;\n+\n+    /** Rank of the jacobian matrix. */\n+    private int rank;\n+\n+    /** Levenberg-Marquardt parameter. */\n+    private double lmPar;\n+\n+    /** Parameters evolution direction associated with lmPar. */\n+    private double[] lmDir;\n+\n+    /** Positive input variable used in determining the initial step bound. */\n+    private double initialStepBoundFactor;\n+\n+    /** Desired relative error in the sum of squares. */\n+    private double costRelativeTolerance;\n+\n+    /**  Desired relative error in the approximate solution parameters. */\n+    private double parRelativeTolerance;\n+\n+    /** Desired max cosine on the orthogonality between the function vector\n+     * and the columns of the jacobian. */\n+    private double orthoTolerance;\n+\n   /**\n    * Build an estimator for least squares problems.\n    * <p>The default values for the algorithm settings are:\n     }\n   }\n \n-  /** Number of solved variables. */\n-  private int solvedCols;\n-\n-  /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n-  private double[] diagR;\n-\n-  /** Norms of the columns of the jacobian matrix. */\n-  private double[] jacNorm;\n-\n-  /** Coefficients of the Householder transforms vectors. */\n-  private double[] beta;\n-\n-  /** Columns permutation array. */\n-  private int[] permutation;\n-\n-  /** Rank of the jacobian matrix. */\n-  private int rank;\n-\n-  /** Levenberg-Marquardt parameter. */\n-  private double lmPar;\n-\n-  /** Parameters evolution direction associated with lmPar. */\n-  private double[] lmDir;\n-\n-  /** Positive input variable used in determining the initial step bound. */\n-  private double initialStepBoundFactor;\n-\n-  /** Desired relative error in the sum of squares. */\n-  private double costRelativeTolerance;\n-\n-  /**  Desired relative error in the approximate solution parameters. */\n-  private double parRelativeTolerance;\n-\n-  /** Desired max cosine on the orthogonality between the function vector\n-   * and the columns of the jacobian. */\n-  private double orthoTolerance;\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -5705952631533171019L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n+++ b/src/main/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n  */\n @Deprecated\n public class SimpleEstimationProblem implements EstimationProblem {\n+\n+    /** Estimated parameters. */\n+    private final List<EstimatedParameter> parameters;\n+\n+    /** Measurements. */\n+    private final List<WeightedMeasurement> measurements;\n \n     /**\n      * Build an empty instance without parameters nor measurements.\n         measurements.add(m);\n     }\n \n-    /** Estimated parameters. */\n-    private final List<EstimatedParameter> parameters;\n-\n-    /** Measurements. */\n-    private final List<WeightedMeasurement> measurements;\n-\n }\n--- a/src/main/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n+++ b/src/main/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 4360046376796901941L;\n \n-    /**\n+    /** Measurement weight. */\n+    private final double  weight;\n+\n+    /** Value of the measurements. */\n+    private final double  measuredValue;\n+\n+    /** Ignore measurement indicator. */\n+    private boolean ignored;\n+\n+  /**\n    * Simple constructor.\n    * Build a measurement with the given parameters, and set its ignore\n    * flag to false.\n     return ignored;\n   }\n \n-  /** Measurement weight. */\n-  private final double  weight;\n-\n-  /** Value of the measurements. */\n-  private final double  measuredValue;\n-\n-  /** Ignore measurement indicator. */\n-  private       boolean ignored;\n-\n }\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n \n     /**\n      * <p>\n-     * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n-     * Y/Z.\n-     * </p>\n-     *\n-     * <p>\n-     * Any negative signs are resolved to be on the numerator.\n-     * </p>\n-     *\n-     * @param numerator\n-     *            the numerator, for example the three in 'three sevenths'.\n-     * @param denominator\n-     *            the denominator, for example the seven in 'three sevenths'.\n-     * @return a new fraction instance, with the numerator and denominator\n-     *         reduced.\n-     * @throws ArithmeticException\n-     *             if the denominator is <code>zero</code>.\n-     */\n-    public static BigFraction getReducedFraction(final int numerator,\n-                                                 final int denominator) {\n-        if (numerator == 0) {\n-            return ZERO; // normalize zero.\n-        }\n-\n-        return new BigFraction(numerator, denominator);\n-    }\n-\n-    /**\n-     * <p>\n      * Create a {@link BigFraction} equivalent to the passed <tt>BigInteger</tt>, ie\n      * \"num / 1\".\n      * </p>\n \n     /**\n      * <p>\n+     * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n+     * Y/Z.\n+     * </p>\n+     *\n+     * <p>\n+     * Any negative signs are resolved to be on the numerator.\n+     * </p>\n+     *\n+     * @param numerator\n+     *            the numerator, for example the three in 'three sevenths'.\n+     * @param denominator\n+     *            the denominator, for example the seven in 'three sevenths'.\n+     * @return a new fraction instance, with the numerator and denominator\n+     *         reduced.\n+     * @throws ArithmeticException\n+     *             if the denominator is <code>zero</code>.\n+     */\n+    public static BigFraction getReducedFraction(final int numerator,\n+                                                 final int denominator) {\n+        if (numerator == 0) {\n+            return ZERO; // normalize zero.\n+        }\n+\n+        return new BigFraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>\n      * Returns the absolute value of this {@link BigFraction}.\n      * </p>\n      *\n--- a/src/main/java/org/apache/commons/math/fraction/BigFractionField.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionField.java\n         return BigFraction.ZERO;\n     }\n \n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n      */\n     private static class LazyHolder {\n-\n-        /** Private constructor. */\n-        private LazyHolder() {\n-        }\n-\n         /** Cached field instance. */\n         private static final BigFractionField INSTANCE = new BigFractionField();\n-\n     }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n \n     /** Handle deserialization of the singleton.\n      * @return the singleton instance\n--- a/src/main/java/org/apache/commons/math/fraction/FractionField.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionField.java\n         return Fraction.ZERO;\n     }\n \n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n      */\n     private static class LazyHolder {\n-\n-        /** Private constructor. */\n-        private LazyHolder() {\n-        }\n-\n         /** Cached field instance. */\n         private static final FractionField INSTANCE = new FractionField();\n-\n     }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n \n     /** Handle deserialization of the singleton.\n      * @return the singleton instance\n--- a/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n     //@GuardedBy(\"this\")\n     private static RandomGenerator randomGenerator = new JDKRandomGenerator();\n \n-    /**\n-     * Set the (static) random generator.\n-     *\n-     * @param random random generator\n-     */\n-    public static synchronized void setRandomGenerator(RandomGenerator random) {\n-        randomGenerator = random;\n-    }\n-\n-    /**\n-     * Returns the (static) random generator.\n-     *\n-     * @return the static random generator shared by GA implementation classes\n-     */\n-    public static synchronized RandomGenerator getRandomGenerator() {\n-        return randomGenerator;\n-    }\n-\n     /** the crossover policy used by the algorithm. */\n     private final CrossoverPolicy crossoverPolicy;\n \n         this.mutationPolicy = mutationPolicy;\n         this.mutationRate = mutationRate;\n         this.selectionPolicy = selectionPolicy;\n+    }\n+\n+    /**\n+     * Set the (static) random generator.\n+     *\n+     * @param random random generator\n+     */\n+    public static synchronized void setRandomGenerator(RandomGenerator random) {\n+        randomGenerator = random;\n+    }\n+\n+    /**\n+     * Returns the (static) random generator.\n+     *\n+     * @return the static random generator shared by GA implementation classes\n+     */\n+    public static synchronized RandomGenerator getRandomGenerator() {\n+        return randomGenerator;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+++ b/src/main/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n public class CardanEulerSingularityException\n   extends MathException {\n \n-  /**\n-   * Simple constructor.\n-   * build an exception with a default message.\n-   * @param isCardan if true, the rotation is related to Cardan angles,\n-   * if false it is related to EulerAngles\n-   */\n-  public CardanEulerSingularityException(boolean isCardan) {\n-    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\");\n-  }\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1360952845582206770L;\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -1360952845582206770L;\n+    /**\n+     * Simple constructor.\n+     * build an exception with a default message.\n+     * @param isCardan if true, the rotation is related to Cardan angles,\n+     * if false it is related to EulerAngles\n+     */\n+    public CardanEulerSingularityException(boolean isCardan) {\n+        super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\");\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n public class NotARotationMatrixException\n   extends MathException {\n \n-  /**\n-   * Simple constructor.\n-   * Build an exception by translating and formating a message\n-   * @param specifier format specifier (to be translated)\n-   * @param parts to insert in the format (no translation)\n-   */\n-  public NotARotationMatrixException(String specifier, Object ... parts) {\n-    super(specifier, parts);\n-  }\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5647178478658937642L;\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = 5647178478658937642L;\n+    /**\n+     * Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public NotARotationMatrixException(String specifier, Object ... parts) {\n+        super(specifier, parts);\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/RotationOrder.java\n+++ b/src/main/java/org/apache/commons/math/geometry/RotationOrder.java\n  */\n public final class RotationOrder {\n \n-  /** Private constructor.\n-   * This is a utility class that cannot be instantiated by the user,\n-   * so its only constructor is private.\n-   * @param name name of the rotation order\n-   * @param a1 axis of the first rotation\n-   * @param a2 axis of the second rotation\n-   * @param a3 axis of the third rotation\n-   */\n-  private RotationOrder(String name,\n-                        Vector3D a1, Vector3D a2, Vector3D a3) {\n-    this.name = name;\n-    this.a1   = a1;\n-    this.a2   = a2;\n-    this.a3   = a3;\n-  }\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around X, then around Y, then\n+     * around Z\n+     */\n+    public static final RotationOrder XYZ =\n+      new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);\n \n-  /** Get a string representation of the instance.\n-   * @return a string representation of the instance (in fact, its name)\n-   */\n-  @Override\n-  public String toString() {\n-    return name;\n-  }\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around X, then around Z, then\n+     * around Y\n+     */\n+    public static final RotationOrder XZY =\n+      new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);\n \n-  /** Get the axis of the first rotation.\n-   * @return axis of the first rotation\n-   */\n-  public Vector3D getA1() {\n-    return a1;\n-  }\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Y, then around X, then\n+     * around Z\n+     */\n+    public static final RotationOrder YXZ =\n+      new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);\n \n-  /** Get the axis of the second rotation.\n-   * @return axis of the second rotation\n-   */\n-  public Vector3D getA2() {\n-    return a2;\n-  }\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Y, then around Z, then\n+     * around X\n+     */\n+    public static final RotationOrder YZX =\n+      new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);\n \n-  /** Get the axis of the second rotation.\n-   * @return axis of the second rotation\n-   */\n-  public Vector3D getA3() {\n-    return a3;\n-  }\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Z, then around X, then\n+     * around Y\n+     */\n+    public static final RotationOrder ZXY =\n+      new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);\n \n-  /** Set of Cardan angles.\n-   * this ordered set of rotations is around X, then around Y, then\n-   * around Z\n-   */\n-  public static final RotationOrder XYZ =\n-    new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Z, then around Y, then\n+     * around X\n+     */\n+    public static final RotationOrder ZYX =\n+      new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);\n \n-  /** Set of Cardan angles.\n-   * this ordered set of rotations is around X, then around Z, then\n-   * around Y\n-   */\n-  public static final RotationOrder XZY =\n-    new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around X, then around Y, then\n+     * around X\n+     */\n+    public static final RotationOrder XYX =\n+      new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);\n \n-  /** Set of Cardan angles.\n-   * this ordered set of rotations is around Y, then around X, then\n-   * around Z\n-   */\n-  public static final RotationOrder YXZ =\n-    new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around X, then around Z, then\n+     * around X\n+     */\n+    public static final RotationOrder XZX =\n+      new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);\n \n-  /** Set of Cardan angles.\n-   * this ordered set of rotations is around Y, then around Z, then\n-   * around X\n-   */\n-  public static final RotationOrder YZX =\n-    new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Y, then around X, then\n+     * around Y\n+     */\n+    public static final RotationOrder YXY =\n+      new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);\n \n-  /** Set of Cardan angles.\n-   * this ordered set of rotations is around Z, then around X, then\n-   * around Y\n-   */\n-  public static final RotationOrder ZXY =\n-    new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Y, then around Z, then\n+     * around Y\n+     */\n+    public static final RotationOrder YZY =\n+      new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);\n \n-  /** Set of Cardan angles.\n-   * this ordered set of rotations is around Z, then around Y, then\n-   * around X\n-   */\n-  public static final RotationOrder ZYX =\n-    new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Z, then around X, then\n+     * around Z\n+     */\n+    public static final RotationOrder ZXZ =\n+      new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);\n \n-  /** Set of Euler angles.\n-   * this ordered set of rotations is around X, then around Y, then\n-   * around X\n-   */\n-  public static final RotationOrder XYX =\n-    new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Z, then around Y, then\n+     * around Z\n+     */\n+    public static final RotationOrder ZYZ =\n+      new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);\n \n-  /** Set of Euler angles.\n-   * this ordered set of rotations is around X, then around Z, then\n-   * around X\n-   */\n-  public static final RotationOrder XZX =\n-    new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);\n+    /** Name of the rotations order. */\n+    private final String name;\n \n-  /** Set of Euler angles.\n-   * this ordered set of rotations is around Y, then around X, then\n-   * around Y\n-   */\n-  public static final RotationOrder YXY =\n-    new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);\n+    /** Axis of the first rotation. */\n+    private final Vector3D a1;\n \n-  /** Set of Euler angles.\n-   * this ordered set of rotations is around Y, then around Z, then\n-   * around Y\n-   */\n-  public static final RotationOrder YZY =\n-    new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);\n+    /** Axis of the second rotation. */\n+    private final Vector3D a2;\n \n-  /** Set of Euler angles.\n-   * this ordered set of rotations is around Z, then around X, then\n-   * around Z\n-   */\n-  public static final RotationOrder ZXZ =\n-    new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);\n+    /** Axis of the third rotation. */\n+    private final Vector3D a3;\n \n-  /** Set of Euler angles.\n-   * this ordered set of rotations is around Z, then around Y, then\n-   * around Z\n-   */\n-  public static final RotationOrder ZYZ =\n-    new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);\n+    /** Private constructor.\n+     * This is a utility class that cannot be instantiated by the user,\n+     * so its only constructor is private.\n+     * @param name name of the rotation order\n+     * @param a1 axis of the first rotation\n+     * @param a2 axis of the second rotation\n+     * @param a3 axis of the third rotation\n+     */\n+    private RotationOrder(final String name,\n+                          final Vector3D a1, final Vector3D a2, final Vector3D a3) {\n+        this.name = name;\n+        this.a1   = a1;\n+        this.a2   = a2;\n+        this.a3   = a3;\n+    }\n \n-  /** Name of the rotations order. */\n-  private final String name;\n+    /** Get a string representation of the instance.\n+     * @return a string representation of the instance (in fact, its name)\n+     */\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n \n-  /** Axis of the first rotation. */\n-  private final Vector3D a1;\n+    /** Get the axis of the first rotation.\n+     * @return axis of the first rotation\n+     */\n+    public Vector3D getA1() {\n+        return a1;\n+    }\n \n-  /** Axis of the second rotation. */\n-  private final Vector3D a2;\n+    /** Get the axis of the second rotation.\n+     * @return axis of the second rotation\n+     */\n+    public Vector3D getA2() {\n+        return a2;\n+    }\n \n-  /** Axis of the third rotation. */\n-  private final Vector3D a3;\n+    /** Get the axis of the second rotation.\n+     * @return axis of the second rotation\n+     */\n+    public Vector3D getA3() {\n+        return a3;\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n     private final Field<T> field;\n \n     /**\n+     * Constructor for use with Serializable\n+     */\n+    protected AbstractFieldMatrix() {\n+        field = null;\n+    }\n+\n+    /**\n+     * Creates a matrix with no data\n+     * @param field field to which the elements belong\n+     */\n+    protected AbstractFieldMatrix(final Field<T> field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     */\n+    protected AbstractFieldMatrix(final Field<T> field,\n+                                  final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        if (rowDimension <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid row dimension {0} (must be positive)\",\n+                    rowDimension);\n+        }\n+        if (columnDimension <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid column dimension {0} (must be positive)\",\n+                    columnDimension);\n+        }\n+        this.field = field;\n+    }\n+\n+    /**\n      * Get the elements type from an array.\n      * @param <T> the type of the field elements\n      * @param d data array\n         T[] array = (T[]) Array.newInstance(field.getZero().getClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n-    }\n-\n-    /**\n-     * Constructor for use with Serializable\n-     */\n-    protected AbstractFieldMatrix() {\n-        field = null;\n-    }\n-\n-    /**\n-     * Creates a matrix with no data\n-     * @param field field to which the elements belong\n-     */\n-    protected AbstractFieldMatrix(final Field<T> field) {\n-        this.field = field;\n-    }\n-\n-    /**\n-     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n-     *\n-     * @param field field to which the elements belong\n-     * @param rowDimension  the number of rows in the new matrix\n-     * @param columnDimension  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not positive\n-     */\n-    protected AbstractFieldMatrix(final Field<T> field,\n-                                  final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n-        if (rowDimension <= 0 ) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid row dimension {0} (must be positive)\",\n-                    rowDimension);\n-        }\n-        if (columnDimension <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid column dimension {0} (must be positive)\",\n-                    columnDimension);\n-        }\n-        this.field = field;\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 7648186910365927050L;\n \n+    /** Entries of the vector. */\n+    protected T[] data;\n+\n     /** Field to which the elements belong. */\n     private final Field<T> field;\n-\n-    /** Entries of the vector. */\n-    protected T[] data;\n-\n-    /** Build an array of elements.\n-     * @param length size of the array to build\n-     * @return a new array\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private T[] buildArray(final int length) {\n-        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n-    }\n \n     /**\n      * Build a 0-length vector.\n             throw MathRuntimeException.createIllegalArgumentException(\n                       \"vector must have at least one element\");\n         }\n+    }\n+\n+    /** Build an array of elements.\n+     * @param length size of the array to build\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n @Deprecated\n public class BigMatrixImpl implements BigMatrix, Serializable {\n \n+    /** BigDecimal 0 */\n+    static final BigDecimal ZERO = new BigDecimal(0);\n+\n+    /** BigDecimal 1 */\n+    static final BigDecimal ONE = new BigDecimal(1);\n+\n+    /** Bound to determine effective singularity in LU decomposition */\n+    private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);\n+\n     /** Serialization id */\n     private static final long serialVersionUID = -1011428905656140431L;\n \n \n     /*** BigDecimal scale ***/\n     private int scale = 64;\n-\n-    /** Bound to determine effective singularity in LU decomposition */\n-    private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);\n-\n-    /** BigDecimal 0 */\n-    static final BigDecimal ZERO = new BigDecimal(0);\n-    /** BigDecimal 1 */\n-    static final BigDecimal ONE = new BigDecimal(1);\n \n     /**\n      * Creates a matrix with no data\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n  */\n public class BlockFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n \n+    /** Block size. */\n+    public static final int BLOCK_SIZE = 36;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -4602336630143123183L;\n-\n-    /** Block size. */\n-    public static final int BLOCK_SIZE = 36;\n \n     /** Blocks of matrix entries. */\n     private final T blocks[][];\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n  */\n public class BlockRealMatrix extends AbstractRealMatrix implements Serializable {\n \n+    /** Block size. */\n+    public static final int BLOCK_SIZE = 52;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 4991895511313664478L;\n-\n-    /** Block size. */\n-    public static final int BLOCK_SIZE = 52;\n \n     /** Blocks of matrix entries. */\n     private final double blocks[][];\n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n  */\n public class LUDecompositionImpl implements LUDecomposition {\n \n+    /** Default bound to determine effective singularity in LU decomposition */\n+    private static final double DEFAULT_TOO_SMALL = 10E-12;\n+\n     /** Entries of LU decomposition. */\n     private double lu[][];\n \n \n     /** Cached value of P. */\n     private RealMatrix cachedP;\n-\n-    /** Default bound to determine effective singularity in LU decomposition */\n-    private static final double DEFAULT_TOO_SMALL = 10E-12;\n \n     /**\n      * Calculates the LU-decomposition of the given matrix.\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n */\n public class OpenMapRealVector implements SparseRealVector, Serializable {\n \n+    /** Default Tolerance for having a value considered zero. */\n+    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 8772222695580707260L;\n-\n-    /** Default Tolerance for having a value considered zero. */\n-    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n \n     /** Entries of the vector. */\n     private final OpenIntToDoubleHashMap entries;\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n  */\n public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n \n+    /** Step handler. */\n+    protected Collection<StepHandler> stepHandlers;\n+\n+    /** Current step start time. */\n+    protected double stepStart;\n+\n+    /** Current stepsize. */\n+    protected double stepSize;\n+\n+    /** Events handlers manager. */\n+    protected CombinedEventsManager eventsHandlersManager;\n \n     /** Name of the method. */\n     private final String name;\n \n     /** Differential equations to integrate. */\n     private transient FirstOrderDifferentialEquations equations;\n-\n-    /** Step handler. */\n-    protected Collection<StepHandler> stepHandlers;\n-\n-    /** Current step start time. */\n-    protected double stepStart;\n-\n-    /** Current stepsize. */\n-    protected double stepSize;\n-\n-    /** Events handlers manager. */\n-    protected CombinedEventsManager eventsHandlersManager;\n \n     /** Build an instance.\n      * @param name name of the method\n--- a/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n \n public class ContinuousOutputModel\n   implements StepHandler, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1417964919405031606L;\n+\n+    /** Initial integration time. */\n+    private double initialTime;\n+\n+    /** Final integration time. */\n+    private double finalTime;\n+\n+    /** Integration direction indicator. */\n+    private boolean forward;\n+\n+    /** Current interpolator index. */\n+    private int index;\n+\n+    /** Steps table. */\n+    private List<StepInterpolator> steps;\n \n   /** Simple constructor.\n    * Build an empty continuous output model.\n     }\n   }\n \n-  /** Initial integration time. */\n-  private double initialTime;\n-\n-  /** Final integration time. */\n-  private double finalTime;\n-\n-  /** Integration direction indicator. */\n-  private boolean forward;\n-\n-  /** Current interpolator index. */\n-  private int index;\n-\n-  /** Steps table. */\n-  private List<StepInterpolator> steps;\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -1417964919405031606L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderConverter.java\n \n public class FirstOrderConverter implements FirstOrderDifferentialEquations {\n \n+    /** Underlying second order equations set. */\n+    private final SecondOrderDifferentialEquations equations;\n+\n+    /** second order problem dimension. */\n+    private final int dimension;\n+\n+    /** state vector. */\n+    private final double[] z;\n+\n+    /** first time derivative of the state vector. */\n+    private final double[] zDot;\n+\n+    /** second time derivative of the state vector. */\n+    private final double[] zDDot;\n+\n   /** Simple constructor.\n    * Build a converter around a second order equations set.\n    * @param equations second order equations set to convert\n \n   }\n \n-  /** Underlying second order equations set. */\n-  private SecondOrderDifferentialEquations equations;\n-\n-  /** second order problem dimension. */\n-  private int dimension;\n-\n-  /** state vector. */\n-  private double[] z;\n-\n-  /** first time derivative of the state vector. */\n-  private double[] zDot;\n-\n-  /** second time derivative of the state vector. */\n-  private double[] zDDot;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n  */\n public abstract class MultistepIntegrator extends AdaptiveStepsizeIntegrator {\n \n+    /** First scaled derivative (h y'). */\n+    protected double[] scaled;\n+\n+    /** Nordsieck matrix of the higher scaled derivatives.\n+     * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y(k))</p>\n+     */\n+    protected Array2DRowRealMatrix nordsieck;\n+\n     /** Starter integrator. */\n     private FirstOrderIntegrator starter;\n \n     /** Number of steps of the multistep method (excluding the one being computed). */\n     private final int nSteps;\n-\n-    /** First scaled derivative (h y'). */\n-    protected double[] scaled;\n-\n-    /** Nordsieck matrix of the higher scaled derivatives.\n-     * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y(k))</p>\n-     */\n-    protected Array2DRowRealMatrix nordsieck;\n \n     /** Stepsize control exponent. */\n     private double exp;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n public abstract class AdaptiveStepsizeIntegrator\n   extends AbstractIntegrator {\n \n+    /** Allowed absolute scalar error. */\n+    protected final double scalAbsoluteTolerance;\n+\n+    /** Allowed relative scalar error. */\n+    protected final double scalRelativeTolerance;\n+\n+    /** Allowed absolute vectorial error. */\n+    protected final double[] vecAbsoluteTolerance;\n+\n+    /** Allowed relative vectorial error. */\n+    protected final double[] vecRelativeTolerance;\n+\n+    /** User supplied initial step. */\n+    private double initialStep;\n+\n+    /** Minimal step. */\n+    private final double minStep;\n+\n+    /** Maximal step. */\n+    private final double maxStep;\n \n   /** Build an integrator with the given stepsize bounds.\n    * The default step handler does nothing.\n     return maxStep;\n   }\n \n-  /** Minimal step. */\n-  private double minStep;\n-\n-  /** Maximal step. */\n-  private double maxStep;\n-\n-  /** User supplied initial step. */\n-  private double initialStep;\n-\n-  /** Allowed absolute scalar error. */\n-  protected double scalAbsoluteTolerance;\n-\n-  /** Allowed relative scalar error. */\n-  protected double scalRelativeTolerance;\n-\n-  /** Allowed absolute vectorial error. */\n-  protected double[] vecAbsoluteTolerance;\n-\n-  /** Allowed relative vectorial error. */\n-  protected double[] vecRelativeTolerance;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n \n class DormandPrince54StepInterpolator\n   extends RungeKuttaStepInterpolator {\n+\n+    /** Last row of the Butcher-array internal weights, element 0. */\n+    private static final double A70 =    35.0 /  384.0;\n+\n+    // element 1 is zero, so it is neither stored nor used\n+\n+    /** Last row of the Butcher-array internal weights, element 2. */\n+    private static final double A72 =   500.0 / 1113.0;\n+\n+    /** Last row of the Butcher-array internal weights, element 3. */\n+    private static final double A73 =   125.0 /  192.0;\n+\n+    /** Last row of the Butcher-array internal weights, element 4. */\n+    private static final double A74 = -2187.0 / 6784.0;\n+\n+    /** Last row of the Butcher-array internal weights, element 5. */\n+    private static final double A75 =    11.0 /   84.0;\n+\n+    /** Shampine (1986) Dense output, element 0. */\n+    private static final double D0 =  -12715105075.0 /  11282082432.0;\n+\n+    // element 1 is zero, so it is neither stored nor used\n+\n+    /** Shampine (1986) Dense output, element 2. */\n+    private static final double D2 =   87487479700.0 /  32700410799.0;\n+\n+    /** Shampine (1986) Dense output, element 3. */\n+    private static final double D3 =  -10690763975.0 /   1880347072.0;\n+\n+    /** Shampine (1986) Dense output, element 4. */\n+    private static final double D4 =  701980252875.0 / 199316789632.0;\n+\n+    /** Shampine (1986) Dense output, element 5. */\n+    private static final double D5 =   -1453857185.0 /    822651844.0;\n+\n+    /** Shampine (1986) Dense output, element 6. */\n+    private static final double D6 =      69997945.0 /     29380423.0;\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4104157279605906956L;\n+\n+    /** First vector for interpolation. */\n+    private double[] v1;\n+\n+    /** Second vector for interpolation. */\n+    private double[] v2;\n+\n+    /** Third vector for interpolation. */\n+    private double[] v3;\n+\n+    /** Fourth vector for interpolation. */\n+    private double[] v4;\n+\n+    /** Initialization indicator for the interpolation vectors. */\n+    private boolean vectorsInitialized;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** First vector for interpolation. */\n-  private double[] v1;\n-\n-  /** Second vector for interpolation. */\n-  private double[] v2;\n-\n-  /** Third vector for interpolation. */\n-  private double[] v3;\n-\n-  /** Fourth vector for interpolation. */\n-  private double[] v4;\n-\n-  /** Initialization indicator for the interpolation vectors. */\n-  private boolean vectorsInitialized;\n-\n-  /** Last row of the Butcher-array internal weights, element 0. */\n-  private static final double A70 =    35.0 /  384.0;\n-\n-  // element 1 is zero, so it is neither stored nor used\n-\n-  /** Last row of the Butcher-array internal weights, element 2. */\n-  private static final double A72 =   500.0 / 1113.0;\n-\n-  /** Last row of the Butcher-array internal weights, element 3. */\n-  private static final double A73 =   125.0 /  192.0;\n-\n-  /** Last row of the Butcher-array internal weights, element 4. */\n-  private static final double A74 = -2187.0 / 6784.0;\n-\n-  /** Last row of the Butcher-array internal weights, element 5. */\n-  private static final double A75 =    11.0 /   84.0;\n-\n-  /** Shampine (1986) Dense output, element 0. */\n-  private static final double D0 =  -12715105075.0 /  11282082432.0;\n-\n-  // element 1 is zero, so it is neither stored nor used\n-\n-  /** Shampine (1986) Dense output, element 2. */\n-  private static final double D2 =   87487479700.0 /  32700410799.0;\n-\n-  /** Shampine (1986) Dense output, element 3. */\n-  private static final double D3 =  -10690763975.0 /   1880347072.0;\n-\n-  /** Shampine (1986) Dense output, element 4. */\n-  private static final double D4 =  701980252875.0 / 199316789632.0;\n-\n-  /** Shampine (1986) Dense output, element 5. */\n-  private static final double D5 =   -1453857185.0 /    822651844.0;\n-\n-  /** Shampine (1986) Dense output, element 6. */\n-  private static final double D6 =      69997945.0 /     29380423.0;\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = 4104157279605906956L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n \n class DormandPrince853StepInterpolator\n   extends RungeKuttaStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7152276390558450974L;\n+\n+    /** Propagation weights, element 1. */\n+    private static final double B_01 =         104257.0 / 1920240.0;\n+\n+    // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+    /** Propagation weights, element 6. */\n+    private static final double B_06 =        3399327.0 / 763840.0;\n+\n+    /** Propagation weights, element 7. */\n+    private static final double B_07 =       66578432.0 / 35198415.0;\n+\n+    /** Propagation weights, element 8. */\n+    private static final double B_08 =    -1674902723.0 / 288716400.0;\n+\n+    /** Propagation weights, element 9. */\n+    private static final double B_09 = 54980371265625.0 / 176692375811392.0;\n+\n+    /** Propagation weights, element 10. */\n+    private static final double B_10 =        -734375.0 / 4826304.0;\n+\n+    /** Propagation weights, element 11. */\n+    private static final double B_11 =      171414593.0 / 851261400.0;\n+\n+    /** Propagation weights, element 12. */\n+    private static final double B_12 =         137909.0 / 3084480.0;\n+\n+    /** Time step for stage 14 (interpolation only). */\n+    private static final double C14    = 1.0 / 10.0;\n+\n+    /** Internal weights for stage 14, element 1. */\n+    private static final double K14_01 =       13481885573.0 / 240030000000.0      - B_01;\n+\n+    // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+    /** Internal weights for stage 14, element 6. */\n+    private static final double K14_06 =                 0.0                       - B_06;\n+\n+    /** Internal weights for stage 14, element 7. */\n+    private static final double K14_07 =      139418837528.0 / 549975234375.0      - B_07;\n+\n+    /** Internal weights for stage 14, element 8. */\n+    private static final double K14_08 =   -11108320068443.0 / 45111937500000.0    - B_08;\n+\n+    /** Internal weights for stage 14, element 9. */\n+    private static final double K14_09 = -1769651421925959.0 / 14249385146080000.0 - B_09;\n+\n+    /** Internal weights for stage 14, element 10. */\n+    private static final double K14_10 =          57799439.0 / 377055000.0         - B_10;\n+\n+    /** Internal weights for stage 14, element 11. */\n+    private static final double K14_11 =      793322643029.0 / 96734250000000.0    - B_11;\n+\n+    /** Internal weights for stage 14, element 12. */\n+    private static final double K14_12 =        1458939311.0 / 192780000000.0      - B_12;\n+\n+    /** Internal weights for stage 14, element 13. */\n+    private static final double K14_13 =             -4149.0 / 500000.0;\n+\n+    /** Time step for stage 15 (interpolation only). */\n+    private static final double C15    = 1.0 / 5.0;\n+\n+\n+    /** Internal weights for stage 15, element 1. */\n+    private static final double K15_01 =     1595561272731.0 / 50120273500000.0    - B_01;\n+\n+    // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+    /** Internal weights for stage 15, element 6. */\n+    private static final double K15_06 =      975183916491.0 / 34457688031250.0    - B_06;\n+\n+    /** Internal weights for stage 15, element 7. */\n+    private static final double K15_07 =    38492013932672.0 / 718912673015625.0   - B_07;\n+\n+    /** Internal weights for stage 15, element 8. */\n+    private static final double K15_08 = -1114881286517557.0 / 20298710767500000.0 - B_08;\n+\n+    /** Internal weights for stage 15, element 9. */\n+    private static final double K15_09 =                 0.0                       - B_09;\n+\n+    /** Internal weights for stage 15, element 10. */\n+    private static final double K15_10 =                 0.0                       - B_10;\n+\n+    /** Internal weights for stage 15, element 11. */\n+    private static final double K15_11 =    -2538710946863.0 / 23431227861250000.0 - B_11;\n+\n+    /** Internal weights for stage 15, element 12. */\n+    private static final double K15_12 =        8824659001.0 / 23066716781250.0    - B_12;\n+\n+    /** Internal weights for stage 15, element 13. */\n+    private static final double K15_13 =      -11518334563.0 / 33831184612500.0;\n+\n+    /** Internal weights for stage 15, element 14. */\n+    private static final double K15_14 =        1912306948.0 / 13532473845.0;\n+\n+    /** Time step for stage 16 (interpolation only). */\n+    private static final double C16    = 7.0 / 9.0;\n+\n+\n+    /** Internal weights for stage 16, element 1. */\n+    private static final double K16_01 =      -13613986967.0 / 31741908048.0       - B_01;\n+\n+    // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+    /** Internal weights for stage 16, element 6. */\n+    private static final double K16_06 =       -4755612631.0 / 1012344804.0        - B_06;\n+\n+    /** Internal weights for stage 16, element 7. */\n+    private static final double K16_07 =    42939257944576.0 / 5588559685701.0     - B_07;\n+\n+    /** Internal weights for stage 16, element 8. */\n+    private static final double K16_08 =    77881972900277.0 / 19140370552944.0    - B_08;\n+\n+    /** Internal weights for stage 16, element 9. */\n+    private static final double K16_09 =    22719829234375.0 / 63689648654052.0    - B_09;\n+\n+    /** Internal weights for stage 16, element 10. */\n+    private static final double K16_10 =                 0.0                       - B_10;\n+\n+    /** Internal weights for stage 16, element 11. */\n+    private static final double K16_11 =                 0.0                       - B_11;\n+\n+    /** Internal weights for stage 16, element 12. */\n+    private static final double K16_12 =                 0.0                       - B_12;\n+\n+    /** Internal weights for stage 16, element 13. */\n+    private static final double K16_13 =       -1199007803.0 / 857031517296.0;\n+\n+    /** Internal weights for stage 16, element 14. */\n+    private static final double K16_14 =      157882067000.0 / 53564469831.0;\n+\n+    /** Internal weights for stage 16, element 15. */\n+    private static final double K16_15 =     -290468882375.0 / 31741908048.0;\n+\n+    /** Interpolation weights.\n+     * (beware that only the non-null values are in the table)\n+     */\n+    private static final double[][] D = {\n+\n+      {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n+              -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n+        3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,\n+              2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,\n+                    -126493.0 / 1421424.0,                    98350000.0 / 5419179.0,\n+                  -18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},\n+\n+      {         32941697297.0 / 3159114840.0,             456696183123.0 / 1884966160.0,\n+             19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,\n+       -4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,\n+            -85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,\n+                    2479159.0 / 157936.0,                    -18750000.0 / 602131.0,\n+                  -19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},\n+\n+      {         12627015655.0 / 631822968.0,              -72955222965.0 / 188496616.0,\n+            -13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,\n+        -296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,\n+               -18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,\n+                  -11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,\n+                  519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},\n+\n+      {          -450944925.0 / 17550638.0,               -14532122925.0 / 94248308.0,\n+              -595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,\n+        2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,\n+                53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,\n+                   -1718875.0 / 39484.0,                      58000000.0 / 602131.0,\n+                   -1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}\n+\n+    };\n+\n+    /** Last evaluations. */\n+    private double[][] yDotKLast;\n+\n+    /** Vectors for interpolation. */\n+    private double[][] v;\n+\n+    /** Initialization indicator for the interpolation vectors. */\n+    private boolean vectorsInitialized;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** Last evaluations. */\n-  private double[][] yDotKLast;\n-\n-  /** Vectors for interpolation. */\n-  private double[][] v;\n-\n-  /** Initialization indicator for the interpolation vectors. */\n-  private boolean vectorsInitialized;\n-\n-  /** Propagation weights, element 1. */\n-  private static final double B_01 =         104257.0 / 1920240.0;\n-\n-  // elements 2 to 5 are zero, so they are neither stored nor used\n-\n-  /** Propagation weights, element 6. */\n-  private static final double B_06 =        3399327.0 / 763840.0;\n-\n-  /** Propagation weights, element 7. */\n-  private static final double B_07 =       66578432.0 / 35198415.0;\n-\n-  /** Propagation weights, element 8. */\n-  private static final double B_08 =    -1674902723.0 / 288716400.0;\n-\n-  /** Propagation weights, element 9. */\n-  private static final double B_09 = 54980371265625.0 / 176692375811392.0;\n-\n-  /** Propagation weights, element 10. */\n-  private static final double B_10 =        -734375.0 / 4826304.0;\n-\n-  /** Propagation weights, element 11. */\n-  private static final double B_11 =      171414593.0 / 851261400.0;\n-\n-  /** Propagation weights, element 12. */\n-  private static final double B_12 =         137909.0 / 3084480.0;\n-\n-  /** Time step for stage 14 (interpolation only). */\n-  private static final double C14    = 1.0 / 10.0;\n-\n-  /** Internal weights for stage 14, element 1. */\n-  private static final double K14_01 =       13481885573.0 / 240030000000.0      - B_01;\n-\n-  // elements 2 to 5 are zero, so they are neither stored nor used\n-\n-  /** Internal weights for stage 14, element 6. */\n-  private static final double K14_06 =                 0.0                       - B_06;\n-\n-  /** Internal weights for stage 14, element 7. */\n-  private static final double K14_07 =      139418837528.0 / 549975234375.0      - B_07;\n-\n-  /** Internal weights for stage 14, element 8. */\n-  private static final double K14_08 =   -11108320068443.0 / 45111937500000.0    - B_08;\n-\n-  /** Internal weights for stage 14, element 9. */\n-  private static final double K14_09 = -1769651421925959.0 / 14249385146080000.0 - B_09;\n-\n-  /** Internal weights for stage 14, element 10. */\n-  private static final double K14_10 =          57799439.0 / 377055000.0         - B_10;\n-\n-  /** Internal weights for stage 14, element 11. */\n-  private static final double K14_11 =      793322643029.0 / 96734250000000.0    - B_11;\n-\n-  /** Internal weights for stage 14, element 12. */\n-  private static final double K14_12 =        1458939311.0 / 192780000000.0      - B_12;\n-\n-  /** Internal weights for stage 14, element 13. */\n-  private static final double K14_13 =             -4149.0 / 500000.0;\n-\n-  /** Time step for stage 15 (interpolation only). */\n-  private static final double C15    = 1.0 / 5.0;\n-\n-\n-  /** Internal weights for stage 15, element 1. */\n-  private static final double K15_01 =     1595561272731.0 / 50120273500000.0    - B_01;\n-\n-  // elements 2 to 5 are zero, so they are neither stored nor used\n-\n-  /** Internal weights for stage 15, element 6. */\n-  private static final double K15_06 =      975183916491.0 / 34457688031250.0    - B_06;\n-\n-  /** Internal weights for stage 15, element 7. */\n-  private static final double K15_07 =    38492013932672.0 / 718912673015625.0   - B_07;\n-\n-  /** Internal weights for stage 15, element 8. */\n-  private static final double K15_08 = -1114881286517557.0 / 20298710767500000.0 - B_08;\n-\n-  /** Internal weights for stage 15, element 9. */\n-  private static final double K15_09 =                 0.0                       - B_09;\n-\n-  /** Internal weights for stage 15, element 10. */\n-  private static final double K15_10 =                 0.0                       - B_10;\n-\n-  /** Internal weights for stage 15, element 11. */\n-  private static final double K15_11 =    -2538710946863.0 / 23431227861250000.0 - B_11;\n-\n-  /** Internal weights for stage 15, element 12. */\n-  private static final double K15_12 =        8824659001.0 / 23066716781250.0    - B_12;\n-\n-  /** Internal weights for stage 15, element 13. */\n-  private static final double K15_13 =      -11518334563.0 / 33831184612500.0;\n-\n-  /** Internal weights for stage 15, element 14. */\n-  private static final double K15_14 =        1912306948.0 / 13532473845.0;\n-\n-  /** Time step for stage 16 (interpolation only). */\n-  private static final double C16    = 7.0 / 9.0;\n-\n-\n-  /** Internal weights for stage 16, element 1. */\n-  private static final double K16_01 =      -13613986967.0 / 31741908048.0       - B_01;\n-\n-  // elements 2 to 5 are zero, so they are neither stored nor used\n-\n-  /** Internal weights for stage 16, element 6. */\n-  private static final double K16_06 =       -4755612631.0 / 1012344804.0        - B_06;\n-\n-  /** Internal weights for stage 16, element 7. */\n-  private static final double K16_07 =    42939257944576.0 / 5588559685701.0     - B_07;\n-\n-  /** Internal weights for stage 16, element 8. */\n-  private static final double K16_08 =    77881972900277.0 / 19140370552944.0    - B_08;\n-\n-  /** Internal weights for stage 16, element 9. */\n-  private static final double K16_09 =    22719829234375.0 / 63689648654052.0    - B_09;\n-\n-  /** Internal weights for stage 16, element 10. */\n-  private static final double K16_10 =                 0.0                       - B_10;\n-\n-  /** Internal weights for stage 16, element 11. */\n-  private static final double K16_11 =                 0.0                       - B_11;\n-\n-  /** Internal weights for stage 16, element 12. */\n-  private static final double K16_12 =                 0.0                       - B_12;\n-\n-  /** Internal weights for stage 16, element 13. */\n-  private static final double K16_13 =       -1199007803.0 / 857031517296.0;\n-\n-  /** Internal weights for stage 16, element 14. */\n-  private static final double K16_14 =      157882067000.0 / 53564469831.0;\n-\n-  /** Internal weights for stage 16, element 15. */\n-  private static final double K16_15 =     -290468882375.0 / 31741908048.0;\n-\n-  /** Interpolation weights.\n-   * (beware that only the non-null values are in the table)\n-   */\n-  private static final double[][] D = {\n-\n-    {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n-            -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n-      3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,\n-            2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,\n-                  -126493.0 / 1421424.0,                    98350000.0 / 5419179.0,\n-                -18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},\n-\n-    {         32941697297.0 / 3159114840.0,             456696183123.0 / 1884966160.0,\n-           19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,\n-     -4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,\n-          -85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,\n-                  2479159.0 / 157936.0,                    -18750000.0 / 602131.0,\n-                -19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},\n-\n-    {         12627015655.0 / 631822968.0,              -72955222965.0 / 188496616.0,\n-          -13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,\n-      -296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,\n-             -18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,\n-                -11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,\n-                519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},\n-\n-    {          -450944925.0 / 17550638.0,               -14532122925.0 / 94248308.0,\n-            -595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,\n-      2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,\n-              53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,\n-                 -1718875.0 / 39484.0,                      58000000.0 / 602131.0,\n-                 -1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}\n-\n-  };\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = 7152276390558450974L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n public abstract class EmbeddedRungeKuttaIntegrator\n   extends AdaptiveStepsizeIntegrator {\n+\n+    /** Indicator for <i>fsal</i> methods. */\n+    private final boolean fsal;\n+\n+    /** Time steps from Butcher array (without the first zero). */\n+    private final double[] c;\n+\n+    /** Internal weights from Butcher array (without the first empty row). */\n+    private final double[][] a;\n+\n+    /** External weights for the high order method from Butcher array. */\n+    private final double[] b;\n+\n+    /** Prototype of the step interpolator. */\n+    private final RungeKuttaStepInterpolator prototype;\n+\n+    /** Stepsize control exponent. */\n+    private final double exp;\n+\n+    /** Safety factor for stepsize control. */\n+    private double safety;\n+\n+    /** Minimal reduction factor for stepsize control. */\n+    private double minReduction;\n+\n+    /** Maximal growth factor for stepsize control. */\n+    private double maxGrowth;\n \n   /** Build a Runge-Kutta integrator with the given Butcher array.\n    * @param name name of the method\n                                           double[] y0, double[] y1,\n                                           double h);\n \n-  /** Indicator for <i>fsal</i> methods. */\n-  private boolean fsal;\n-\n-  /** Time steps from Butcher array (without the first zero). */\n-  private double[] c;\n-\n-  /** Internal weights from Butcher array (without the first empty row). */\n-  private double[][] a;\n-\n-  /** External weights for the high order method from Butcher array. */\n-  private double[] b;\n-\n-  /** Prototype of the step interpolator. */\n-  private RungeKuttaStepInterpolator prototype;\n-\n-  /** Stepsize control exponent. */\n-  private double exp;\n-\n-  /** Safety factor for stepsize control. */\n-  private double safety;\n-\n-  /** Minimal reduction factor for stepsize control. */\n-  private double minReduction;\n-\n-  /** Maximal growth factor for stepsize control. */\n-  private double maxGrowth;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n \n class GillStepInterpolator\n   extends RungeKuttaStepInterpolator {\n+\n+    /** First Gill coefficient. */\n+    private static final double TWO_MINUS_SQRT_2 = 2 - Math.sqrt(2.0);\n+\n+    /** Second Gill coefficient. */\n+    private static final double TWO_PLUS_SQRT_2 = 2 + Math.sqrt(2.0);\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -107804074496313322L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** First Gill coefficient. */\n-  private static final double TWO_MINUS_SQRT_2 = 2 - Math.sqrt(2.0);\n-\n-  /** Second Gill coefficient. */\n-  private static final double TWO_PLUS_SQRT_2 = 2 + Math.sqrt(2.0);\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -107804074496313322L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n \n public class GraggBulirschStoerIntegrator extends AdaptiveStepsizeIntegrator {\n \n-  /** Integrator method name. */\n-  private static final String METHOD_NAME = \"Gragg-Bulirsch-Stoer\";\n+    /** Integrator method name. */\n+    private static final String METHOD_NAME = \"Gragg-Bulirsch-Stoer\";\n+\n+    /** maximal order. */\n+    private int maxOrder;\n+\n+    /** step size sequence. */\n+    private int[] sequence;\n+\n+    /** overall cost of applying step reduction up to iteration k+1, in number of calls. */\n+    private int[] costPerStep;\n+\n+    /** cost per unit step. */\n+    private double[] costPerTimeUnit;\n+\n+    /** optimal steps for each order. */\n+    private double[] optimalStep;\n+\n+    /** extrapolation coefficients. */\n+    private double[][] coeff;\n+\n+    /** stability check enabling parameter. */\n+    private boolean performTest;\n+\n+    /** maximal number of checks for each iteration. */\n+    private int maxChecks;\n+\n+    /** maximal number of iterations for which checks are performed. */\n+    private int maxIter;\n+\n+    /** stepsize reduction factor in case of stability check failure. */\n+    private double stabilityReduction;\n+\n+    /** first stepsize control factor. */\n+    private double stepControl1;\n+\n+    /** second stepsize control factor. */\n+    private double stepControl2;\n+\n+    /** third stepsize control factor. */\n+    private double stepControl3;\n+\n+    /** fourth stepsize control factor. */\n+    private double stepControl4;\n+\n+    /** first order control factor. */\n+    private double orderControl1;\n+\n+    /** second order control factor. */\n+    private double orderControl2;\n+\n+    /** dense outpute required. */\n+    private boolean denseOutput;\n+\n+    /** use interpolation error in stepsize control. */\n+    private boolean useInterpolationError;\n+\n+    /** interpolation order control parameter. */\n+    private int mudif;\n \n   /** Simple constructor.\n    * Build a Gragg-Bulirsch-Stoer integrator with the given step\n \n   }\n \n-  /** maximal order. */\n-  private int maxOrder;\n-\n-  /** step size sequence. */\n-  private int[] sequence;\n-\n-  /** overall cost of applying step reduction up to iteration k+1,\n-   *  in number of calls.\n-   */\n-  private int[] costPerStep;\n-\n-  /** cost per unit step. */\n-  private double[] costPerTimeUnit;\n-\n-  /** optimal steps for each order. */\n-  private double[] optimalStep;\n-\n-  /** extrapolation coefficients. */\n-  private double[][] coeff;\n-\n-  /** stability check enabling parameter. */\n-  private boolean performTest;\n-\n-  /** maximal number of checks for each iteration. */\n-  private int maxChecks;\n-\n-  /** maximal number of iterations for which checks are performed. */\n-  private int maxIter;\n-\n-  /** stepsize reduction factor in case of stability check failure. */\n-  private double stabilityReduction;\n-\n-  /** first stepsize control factor. */\n-  private double stepControl1;\n-\n-  /** second stepsize control factor. */\n-  private double stepControl2;\n-\n-  /** third stepsize control factor. */\n-  private double stepControl3;\n-\n-  /** fourth stepsize control factor. */\n-  private double stepControl4;\n-\n-  /** first order control factor. */\n-  private double orderControl1;\n-\n-  /** second order control factor. */\n-  private double orderControl2;\n-\n-  /** dense outpute required. */\n-  private boolean denseOutput;\n-\n-  /** use interpolation error in stepsize control. */\n-  private boolean useInterpolationError;\n-\n-  /** interpolation order control parameter. */\n-  private int mudif;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n class GraggBulirschStoerStepInterpolator\n   extends AbstractStepInterpolator {\n \n-  /** Slope at the beginning of the step. */\n-  private double[] y0Dot;\n-\n-  /** State at the end of the step. */\n-  private double[] y1;\n-\n-  /** Slope at the end of the step. */\n-  private double[] y1Dot;\n-\n-  /** Derivatives at the middle of the step.\n-   * element 0 is state at midpoint, element 1 is first derivative ...\n-   */\n-  private double[][] yMidDots;\n-\n-  /** Interpolation polynoms. */\n-  private double[][] polynoms;\n-\n-  /** Error coefficients for the interpolation. */\n-  private double[] errfac;\n-\n-  /** Degree of the interpolation polynoms. */\n-  private int currentDegree;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7320613236731409847L;\n+\n+    /** Slope at the beginning of the step. */\n+    private double[] y0Dot;\n+\n+    /** State at the end of the step. */\n+    private double[] y1;\n+\n+    /** Slope at the end of the step. */\n+    private double[] y1Dot;\n+\n+    /** Derivatives at the middle of the step.\n+     * element 0 is state at midpoint, element 1 is first derivative ...\n+     */\n+    private double[][] yMidDots;\n+\n+    /** Interpolation polynoms. */\n+    private double[][] polynoms;\n+\n+    /** Error coefficients for the interpolation. */\n+    private double[] errfac;\n+\n+    /** Degree of the interpolation polynoms. */\n+    private int currentDegree;\n+\n+  /** Simple constructor.\n+   * This constructor should not be used directly, it is only intended\n+   * for the serialization process.\n+   */\n+  public GraggBulirschStoerStepInterpolator() {\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+    resetTables(-1);\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the current state\n+   * @param y0Dot reference to the integrator array holding the slope\n+   * at the beginning of the step\n+   * @param y1 reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param y1Dot reference to the integrator array holding the slope\n+   * at theend of the step\n+   * @param yMidDots reference to the integrator array holding the\n+   * derivatives at the middle point of the step\n+   * @param forward integration direction indicator\n+   */\n+  public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,\n+                                            final double[] y1, final double[] y1Dot,\n+                                            final double[][] yMidDots,\n+                                            final boolean forward) {\n+\n+    super(y, forward);\n+    this.y0Dot    = y0Dot;\n+    this.y1       = y1;\n+    this.y1Dot    = y1Dot;\n+    this.yMidDots = yMidDots;\n+\n+    resetTables(yMidDots.length + 4);\n+\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GraggBulirschStoerStepInterpolator\n+    (final GraggBulirschStoerStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    final int dimension = currentState.length;\n+\n+    // the interpolator has been finalized,\n+    // the following arrays are not needed anymore\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+\n+    // copy the interpolation polynoms (up to the current degree only)\n+    if (interpolator.polynoms == null) {\n+      polynoms = null;\n+      currentDegree = -1;\n+    } else {\n+      resetTables(interpolator.currentDegree);\n+      for (int i = 0; i < polynoms.length; ++i) {\n+        polynoms[i] = new double[dimension];\n+        System.arraycopy(interpolator.polynoms[i], 0,\n+                         polynoms[i], 0, dimension);\n+      }\n+      currentDegree = interpolator.currentDegree;\n+    }\n+\n+  }\n \n   /** Reallocate the internal tables.\n    * Reallocate the internal tables in order to be able to handle\n \n   }\n \n-  /** Simple constructor.\n-   * This constructor should not be used directly, it is only intended\n-   * for the serialization process.\n-   */\n-  public GraggBulirschStoerStepInterpolator() {\n-    y0Dot    = null;\n-    y1       = null;\n-    y1Dot    = null;\n-    yMidDots = null;\n-    resetTables(-1);\n-  }\n-\n-  /** Simple constructor.\n-   * @param y reference to the integrator array holding the current state\n-   * @param y0Dot reference to the integrator array holding the slope\n-   * at the beginning of the step\n-   * @param y1 reference to the integrator array holding the state at\n-   * the end of the step\n-   * @param y1Dot reference to the integrator array holding the slope\n-   * at theend of the step\n-   * @param yMidDots reference to the integrator array holding the\n-   * derivatives at the middle point of the step\n-   * @param forward integration direction indicator\n-   */\n-  public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,\n-                                            final double[] y1, final double[] y1Dot,\n-                                            final double[][] yMidDots,\n-                                            final boolean forward) {\n-\n-    super(y, forward);\n-    this.y0Dot    = y0Dot;\n-    this.y1       = y1;\n-    this.y1Dot    = y1Dot;\n-    this.yMidDots = yMidDots;\n-\n-    resetTables(yMidDots.length + 4);\n-\n-  }\n-\n-  /** Copy constructor.\n-   * @param interpolator interpolator to copy from. The copy is a deep\n-   * copy: its arrays are separated from the original arrays of the\n-   * instance\n-   */\n-  public GraggBulirschStoerStepInterpolator\n-    (final GraggBulirschStoerStepInterpolator interpolator) {\n-\n-    super(interpolator);\n-\n-    final int dimension = currentState.length;\n-\n-    // the interpolator has been finalized,\n-    // the following arrays are not needed anymore\n-    y0Dot    = null;\n-    y1       = null;\n-    y1Dot    = null;\n-    yMidDots = null;\n-\n-    // copy the interpolation polynoms (up to the current degree only)\n-    if (interpolator.polynoms == null) {\n-      polynoms = null;\n-      currentDegree = -1;\n-    } else {\n-      resetTables(interpolator.currentDegree);\n-      for (int i = 0; i < polynoms.length; ++i) {\n-        polynoms[i] = new double[dimension];\n-        System.arraycopy(interpolator.polynoms[i], 0,\n-                         polynoms[i], 0, dimension);\n-      }\n-      currentDegree = interpolator.currentDegree;\n-    }\n-\n-  }\n-\n   /** {@inheritDoc} */\n   @Override\n   protected StepInterpolator doCopy() {\n \n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = 7320613236731409847L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n \n class HighamHall54StepInterpolator\n   extends RungeKuttaStepInterpolator {\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -3583240427587318654L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -3583240427587318654L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n \n class MidpointStepInterpolator\n   extends RungeKuttaStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -865524111506042509L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -865524111506042509L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n  */\n \n public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n+\n+    /** Time steps from Butcher array (without the first zero). */\n+    private final double[] c;\n+\n+    /** Internal weights from Butcher array (without the first empty row). */\n+    private final double[][] a;\n+\n+    /** External weights for the high order method from Butcher array. */\n+    private final double[] b;\n+\n+    /** Prototype of the step interpolator. */\n+    private final RungeKuttaStepInterpolator prototype;\n+\n+    /** Integration step. */\n+    private final double step;\n \n   /** Simple constructor.\n    * Build a Runge-Kutta integrator with the given\n \n   }\n \n-  /** Time steps from Butcher array (without the first zero). */\n-  private double[] c;\n-\n-  /** Internal weights from Butcher array (without the first empty row). */\n-  private double[][] a;\n-\n-  /** External weights for the high order method from Butcher array. */\n-  private double[] b;\n-\n-  /** Prototype of the step interpolator. */\n-  private RungeKuttaStepInterpolator prototype;\n-\n-  /** Integration step. */\n-  private double step;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n \n abstract class RungeKuttaStepInterpolator\n   extends AbstractStepInterpolator {\n+\n+    /** Slopes at the intermediate points */\n+    protected double[][] yDotK;\n+\n+    /** Reference to the integrator. */\n+    protected AbstractIntegrator integrator;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** Slopes at the intermediate points */\n-  protected double[][] yDotK;\n-\n-  /** Reference to the integrator. */\n-  protected AbstractIntegrator integrator;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n \n class ThreeEighthesStepInterpolator\n   extends RungeKuttaStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3345024435978721931L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -3345024435978721931L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/DummyStepHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/DummyStepHandler.java\n  */\n \n package org.apache.commons.math.ode.sampling;\n-\n \n /**\n  * This class is a step handler that does nothing.\n \n public class DummyStepHandler implements StepHandler {\n \n-  /** Private constructor.\n-   * The constructor is private to prevent users from creating\n-   * instances (Singleton design-pattern).\n-   */\n-  private DummyStepHandler() {\n-  }\n+    /** Private constructor.\n+     * The constructor is private to prevent users from creating\n+     * instances (Singleton design-pattern).\n+     */\n+    private DummyStepHandler() {\n+    }\n \n-  /** Get the only instance.\n-   * @return the only instance\n-   */\n-  public static DummyStepHandler getInstance() {\n-    return INSTANCE;\n-  }\n+    /** Get the only instance.\n+     * @return the only instance\n+     */\n+    public static DummyStepHandler getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n \n-  /** Determines whether this handler needs dense output.\n-   * Since this handler does nothing, it does not require dense output.\n-   * @return always false\n-   */\n-  public boolean requiresDenseOutput() {\n-    return false;\n-  }\n+    /** Determines whether this handler needs dense output.\n+     * Since this handler does nothing, it does not require dense output.\n+     * @return always false\n+     */\n+    public boolean requiresDenseOutput() {\n+        return false;\n+    }\n \n-  /** Reset the step handler.\n-   * Initialize the internal data as required before the first step is\n-   * handled.\n-   */\n-  public void reset() {\n-  }\n+    /** Reset the step handler.\n+     * Initialize the internal data as required before the first step is\n+     * handled.\n+     */\n+    public void reset() {\n+    }\n \n-  /**\n-   * Handle the last accepted step.\n-   * This method does nothing in this class.\n-   * @param interpolator interpolator for the last accepted step. For\n-   * efficiency purposes, the various integrators reuse the same\n-   * object on each call, so if the instance wants to keep it across\n-   * all calls (for example to provide at the end of the integration a\n-   * continuous model valid throughout the integration range), it\n-   * should build a local copy using the clone method and store this\n-   * copy.\n-   * @param isLast true if the step is the last one\n-   */\n-  public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n-  }\n+    /**\n+     * Handle the last accepted step.\n+     * This method does nothing in this class.\n+     * @param interpolator interpolator for the last accepted step. For\n+     * efficiency purposes, the various integrators reuse the same\n+     * object on each call, so if the instance wants to keep it across\n+     * all calls (for example to provide at the end of the integration a\n+     * continuous model valid throughout the integration range), it\n+     * should build a local copy using the clone method and store this\n+     * copy.\n+     * @param isLast true if the step is the last one\n+     */\n+    public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+    }\n \n-  /** The only instance. */\n-  private static final DummyStepHandler INSTANCE = new DummyStepHandler();\n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final DummyStepHandler INSTANCE = new DummyStepHandler();\n+    }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE;\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n \n public class DummyStepInterpolator\n   extends AbstractStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 1708010296707839488L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n \n   }\n \n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = 1708010296707839488L;\n-\n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -7179861704951334960L;\n \n+    /** State variation. */\n+    protected double[] stateVariation;\n+\n     /** Step size used in the first scaled derivative and Nordsieck vector. */\n     private double scalingH;\n \n \n     /** Nordsieck vector. */\n     private Array2DRowRealMatrix nordsieck;\n-\n-    /** State variation. */\n-    protected double[] stateVariation;\n \n     /** Simple constructor.\n      * This constructor builds an instance that is not usable yet, the\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n     /** Default maximal number of iterations allowed. */\n     public static final int DEFAULT_MAX_ITERATIONS = 100;\n \n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Number of iterations already performed. */\n-    private int iterations;\n-\n-    /** Maximal number of evaluations allowed. */\n-    private int maxEvaluations;\n-\n-    /** Number of evaluations already performed. */\n-    private int objectiveEvaluations;\n-\n-    /** Number of jacobian evaluations. */\n-    private int jacobianEvaluations;\n-\n     /** Convergence checker. */\n     protected VectorialConvergenceChecker checker;\n \n     /** Number of rows of the jacobian matrix. */\n     protected int rows;\n \n+    /** Target value for the objective functions at optimum. */\n+    protected double[] targetValues;\n+\n+    /** Weight for the least squares cost computation. */\n+    protected double[] residualsWeights;\n+\n+    /** Current point. */\n+    protected double[] point;\n+\n+    /** Current objective function value. */\n+    protected double[] objective;\n+\n+    /** Current residuals. */\n+    protected double[] residuals;\n+\n+    /** Cost value (square root of the sum of the residuals). */\n+    protected double cost;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int objectiveEvaluations;\n+\n+    /** Number of jacobian evaluations. */\n+    private int jacobianEvaluations;\n+\n     /** Objective function. */\n     private DifferentiableMultivariateVectorialFunction function;\n \n     /** Objective function derivatives. */\n     private MultivariateMatrixFunction jF;\n-\n-    /** Target value for the objective functions at optimum. */\n-    protected double[] targetValues;\n-\n-    /** Weight for the least squares cost computation. */\n-    protected double[] residualsWeights;\n-\n-    /** Current point. */\n-    protected double[] point;\n-\n-    /** Current objective function value. */\n-    protected double[] objective;\n-\n-    /** Current residuals. */\n-    protected double[] residuals;\n-\n-    /** Cost value (square root of the sum of the residuals). */\n-    protected double cost;\n \n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n     /** Default maximal number of iterations allowed. */\n     public static final int DEFAULT_MAX_ITERATIONS = 100;\n \n+    /** Convergence checker. */\n+    protected RealConvergenceChecker checker;\n+\n+    /** Type of optimization. */\n+    protected GoalType goal;\n+\n+    /** Current point set. */\n+    protected double[] point;\n+\n     /** Maximal number of iterations allowed. */\n     private int maxIterations;\n \n     /** Number of gradient evaluations. */\n     private int gradientEvaluations;\n \n-    /** Convergence checker. */\n-    protected RealConvergenceChecker checker;\n-\n     /** Objective function. */\n     private DifferentiableMultivariateRealFunction function;\n \n     /** Objective function gradient. */\n     private MultivariateVectorialFunction gradient;\n-\n-    /** Type of optimization. */\n-    protected GoalType goal;\n-\n-    /** Current point set. */\n-    protected double[] point;\n \n     /** Simple constructor with default settings.\n      * <p>The convergence check is set to a {@link SimpleScalarValueChecker}\n--- a/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n     /** Default maximal number of iterations allowed. */\n     public static final int DEFAULT_MAX_ITERATIONS = 100;\n \n-    /** Maximal number of iterations allowed. */\n-    private int maxIterations;\n-\n-    /** Number of iterations already performed. */\n-    private int iterations;\n-\n     /** Linear objective function. */\n     protected LinearObjectiveFunction function;\n \n \n     /** Whether to restrict the variables to non-negative values. */\n     protected boolean nonNegative;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n \n     /** Simple constructor with default settings.\n      * <p>The maximal number of evaluation is set to its default value.</p>\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n     private final boolean restrictToNonNegative;\n \n     /** Simple tableau. */\n-    protected transient RealMatrix tableau;\n+    private transient RealMatrix tableau;\n \n     /** Number of decision variables. */\n-    protected final int numDecisionVariables;\n+    private final int numDecisionVariables;\n \n     /** Number of slack variables. */\n-    protected final int numSlackVariables;\n+    private final int numSlackVariables;\n \n     /** Number of artificial variables. */\n-    protected int numArtificialVariables;\n+    private int numArtificialVariables;\n \n     /** Amount of error to accept in floating point comparisons. */\n-    protected final double epsilon;\n+    private final double epsilon;\n \n     /**\n      * Build a tableau for a linear problem.\n--- a/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n public class CorrelatedRandomVectorGenerator\n     implements RandomVectorGenerator {\n \n+    /** Mean vector. */\n+    private final double[] mean;\n+\n+    /** Underlying generator. */\n+    private final NormalizedRandomGenerator generator;\n+\n+    /** Storage for the normalized vector. */\n+    private final double[] normalized;\n+\n+    /** Permutated Cholesky root of the covariance matrix. */\n+    private RealMatrix root;\n+\n+    /** Rank of the covariance matrix. */\n+    private int rank;\n+\n     /** Simple constructor.\n      * <p>Build a correlated random vector generator from its mean\n      * vector and covariance matrix.</p>\n \n     }\n \n-    /** Mean vector. */\n-    private double[] mean;\n-\n-    /** Permutated Cholesky root of the covariance matrix. */\n-    private RealMatrix root;\n-\n-    /** Rank of the covariance matrix. */\n-    private int rank;\n-\n-    /** Underlying generator. */\n-    private NormalizedRandomGenerator generator;\n-\n-    /** Storage for the normalized vector. */\n-    private double[] normalized;\n-\n }\n--- a/src/main/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n \n public class GaussianRandomGenerator implements NormalizedRandomGenerator {\n \n+    /** Underlying generator. */\n+    private final RandomGenerator generator;\n+\n     /** Create a new generator.\n      * @param generator underlying random generator to use\n      */\n-    public GaussianRandomGenerator(RandomGenerator generator) {\n+    public GaussianRandomGenerator(final RandomGenerator generator) {\n         this.generator = generator;\n     }\n \n         return generator.nextGaussian();\n     }\n \n-    /** Underlying generator. */\n-    private RandomGenerator generator;\n-\n }\n--- a/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n \n public class UncorrelatedRandomVectorGenerator\n   implements RandomVectorGenerator {\n+\n+    /** Underlying scalar generator. */\n+    private final NormalizedRandomGenerator generator;\n+\n+    /** Mean vector. */\n+    private final double[] mean;\n+\n+    /** Standard deviation vector. */\n+    private final double[] standardDeviation;\n \n   /** Simple constructor.\n    * <p>Build an uncorrelated random vector generator from\n \n   }\n \n-  /** Mean vector. */\n-  private double[] mean;\n-\n-  /** Standard deviation vector. */\n-  private double[] standardDeviation;\n-\n-  /** Underlying scalar generator. */\n-  private NormalizedRandomGenerator generator;\n-\n }\n--- a/src/main/java/org/apache/commons/math/random/UniformRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UniformRandomGenerator.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 1569292426375546027L;\n \n+    /** Square root of three. */\n+    private static final double SQRT3 = Math.sqrt(3.0);\n+\n+    /** Underlying generator. */\n+    private final RandomGenerator generator;\n+\n     /** Create a new generator.\n      * @param generator underlying random generator to use\n      */\n         return SQRT3 * (2 * generator.nextDouble() - 1.0);\n     }\n \n-    /** Underlying generator. */\n-    private RandomGenerator generator;\n-\n-    /** Square root of three. */\n-    private static final double SQRT3 = Math.sqrt(3.0);\n-\n }\n--- a/src/main/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/main/java/org/apache/commons/math/random/ValueServer.java\n  *\n  */\n public class ValueServer {\n-    /** mode determines how values are generated */\n-    private int mode = 5;\n-\n-    /** URI to raw data values  */\n-    private URL valuesFileURL = null;\n-\n-    /** Mean for use with non-data-driven modes */\n-    private double mu = 0.0;\n-\n-    /** Standard deviation for use with GAUSSIAN_MODE */\n-    private double sigma = 0.0;\n-\n-    /** Empirical probability distribution for use with DIGEST_MODE */\n-    private EmpiricalDistribution empiricalDistribution = null;\n-\n-    /** file pointer for REPLAY_MODE */\n-    private BufferedReader filePointer = null;\n-\n-    /** RandomDataImpl to use for random data generation */\n-    private RandomData randomData = new RandomDataImpl();\n-\n-    // Data generation modes ======================================\n-\n-    /** Use empirical distribution  */\n+\n+    /** Use empirical distribution.  */\n     public static final int DIGEST_MODE = 0;\n \n-    /** Replay data from valuesFilePath */\n+    /** Replay data from valuesFilePath. */\n     public static final int REPLAY_MODE = 1;\n \n-    /** Uniform random deviates with mean = mu */\n+    /** Uniform random deviates with mean = &mu;. */\n     public static final int UNIFORM_MODE = 2;\n \n-    /** Exponential random deviates with mean = mu */\n+    /** Exponential random deviates with mean = &mu;. */\n     public static final int EXPONENTIAL_MODE = 3;\n \n-    /** Gaussian random deviates with mean = mu, std dev = sigma */\n+    /** Gaussian random deviates with mean = &mu;, std dev = &sigma;. */\n     public static final int GAUSSIAN_MODE = 4;\n \n     /** Always return mu */\n     public static final int CONSTANT_MODE = 5;\n \n+    /** mode determines how values are generated. */\n+    private int mode = 5;\n+\n+    /** URI to raw data values. */\n+    private URL valuesFileURL = null;\n+\n+    /** Mean for use with non-data-driven modes. */\n+    private double mu = 0.0;\n+\n+    /** Standard deviation for use with GAUSSIAN_MODE. */\n+    private double sigma = 0.0;\n+\n+    /** Empirical probability distribution for use with DIGEST_MODE. */\n+    private EmpiricalDistribution empiricalDistribution = null;\n+\n+    /** File pointer for REPLAY_MODE. */\n+    private BufferedReader filePointer = null;\n+\n+    /** RandomDataImpl to use for random data generation. */\n+    private RandomData randomData = new RandomDataImpl();\n+\n+    // Data generation modes ======================================\n+\n     /** Creates new ValueServer */\n     public ValueServer() {\n+    }\n+\n+    /**\n+     * Construct a ValueServer instance using a RandomData as its source\n+     * of random data.\n+     *\n+     * @param randomData the RandomData instance used to source random data\n+     * @since 1.1\n+     */\n+    public ValueServer(RandomData randomData) {\n+        this.randomData = randomData;\n     }\n \n     /**\n         return randomData.nextGaussian(mu, sigma);\n     }\n \n-    /**\n-     * Construct a ValueServer instance using a RandomData as its source\n-     * of random data.\n-     *\n-     * @param randomData the RandomData instance used to source random data\n-     * @since 1.1\n-     */\n-    public ValueServer(RandomData randomData) {\n-        super();\n-        this.randomData = randomData;\n-    }\n }\n--- a/src/main/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n     /** Avoid repeated computation of log of 2 PI in logGamma */\n     private static final double HALF_LOG_2_PI = 0.5 * Math.log(2.0 * Math.PI);\n \n+    // limits for switching algorithm in digamma\n+    /** C limit. */\n+    private static final double C_LIMIT = 49;\n+\n+    /** S limit. */\n+    private static final double S_LIMIT = 1e-5;\n \n     /**\n      * Default constructor.  Prohibit instantiation.\n     }\n \n \n-    // limits for switching algorithm in digamma\n-    /** C limit */\n-     private static final double C_LIMIT = 49;\n-     /** S limit */\n-     private static final double S_LIMIT = 1e-5;\n-\n     /**\n      * <p>Computes the digamma function of x.</p>\n      *\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n  */\n public class DescriptiveStatistics implements StatisticalSummary, Serializable {\n \n-    /** Serialization UID */\n-    private static final long serialVersionUID = 4133067267405273064L;\n-\n-    /** hold the window size **/\n-    protected int windowSize = INFINITE_WINDOW;\n-\n-    /**\n-     *  Stored data values\n-     */\n-    protected ResizableDoubleArray eDA = new ResizableDoubleArray();\n-\n-    /** Mean statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic meanImpl = new Mean();\n-\n-    /** Geometric mean statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic geometricMeanImpl = new GeometricMean();\n-\n-    /** Kurtosis statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic kurtosisImpl = new Kurtosis();\n-\n-    /** Maximum statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic maxImpl = new Max();\n-\n-    /** Minimum statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic minImpl = new Min();\n-\n-    /** Percentile statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic percentileImpl = new Percentile();\n-\n-    /** Skewness statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic skewnessImpl = new Skewness();\n-\n-    /** Variance statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic varianceImpl = new Variance();\n-\n-    /** Sum of squares statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic sumsqImpl = new SumOfSquares();\n-\n-    /** Sum statistic implementation - can be reset by setter. */\n-    private UnivariateStatistic sumImpl = new Sum();\n-\n-    /**\n-     * Construct a DescriptiveStatistics instance with an infinite window\n-     */\n-    public DescriptiveStatistics() {\n-    }\n-\n-    /**\n-     * Construct a DescriptiveStatistics instance with the specified window\n-     *\n-     * @param window the window size.\n-     */\n-    public DescriptiveStatistics(int window) {\n-        setWindowSize(window);\n-    }\n-\n-    /**\n-     * Copy constructor.  Construct a new DescriptiveStatistics instance that\n-     * is a copy of original.\n-     *\n-     * @param original DescriptiveStatistics instance to copy\n-     */\n-    public DescriptiveStatistics(DescriptiveStatistics original) {\n-        copy(original, this);\n-    }\n-\n     /**\n      * Represents an infinite window size.  When the {@link #getWindowSize()}\n      * returns this value, there is no limit to the number of data values\n      * that can be stored in the dataset.\n      */\n     public static final int INFINITE_WINDOW = -1;\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = 4133067267405273064L;\n+\n+    /** hold the window size **/\n+    protected int windowSize = INFINITE_WINDOW;\n+\n+    /**\n+     *  Stored data values\n+     */\n+    protected ResizableDoubleArray eDA = new ResizableDoubleArray();\n+\n+    /** Mean statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic meanImpl = new Mean();\n+\n+    /** Geometric mean statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic geometricMeanImpl = new GeometricMean();\n+\n+    /** Kurtosis statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic kurtosisImpl = new Kurtosis();\n+\n+    /** Maximum statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic maxImpl = new Max();\n+\n+    /** Minimum statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic minImpl = new Min();\n+\n+    /** Percentile statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic percentileImpl = new Percentile();\n+\n+    /** Skewness statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic skewnessImpl = new Skewness();\n+\n+    /** Variance statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic varianceImpl = new Variance();\n+\n+    /** Sum of squares statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic sumsqImpl = new SumOfSquares();\n+\n+    /** Sum statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic sumImpl = new Sum();\n+\n+    /**\n+     * Construct a DescriptiveStatistics instance with an infinite window\n+     */\n+    public DescriptiveStatistics() {\n+    }\n+\n+    /**\n+     * Construct a DescriptiveStatistics instance with the specified window\n+     *\n+     * @param window the window size.\n+     */\n+    public DescriptiveStatistics(int window) {\n+        setWindowSize(window);\n+    }\n+\n+    /**\n+     * Copy constructor.  Construct a new DescriptiveStatistics instance that\n+     * is a copy of original.\n+     *\n+     * @param original DescriptiveStatistics instance to copy\n+     */\n+    public DescriptiveStatistics(DescriptiveStatistics original) {\n+        copy(original, this);\n+    }\n \n     /**\n      * Adds the value to the dataset. If the dataset is at the maximum size\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n     /** Serialization UID */\n     private static final long serialVersionUID = 2271900808994826718L;\n \n+    /** Dimension of the data. */\n+    private int k;\n+\n+    /** Count of values that have been added */\n+    private long n = 0;\n+\n+    /** Sum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumImpl;\n+\n+    /** Sum of squares statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumSqImpl;\n+\n+    /** Minimum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] minImpl;\n+\n+    /** Maximum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] maxImpl;\n+\n+    /** Sum of log statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumLogImpl;\n+\n+    /** Geometric mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] geoMeanImpl;\n+\n+    /** Mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] meanImpl;\n+\n+    /** Covariance statistic implementation - cannot be reset. */\n+    private VectorialCovariance covarianceImpl;\n+\n     /**\n      * Construct a MultivariateSummaryStatistics instance\n      * @param k dimension of the data\n             new VectorialCovariance(k, isCovarianceBiasCorrected);\n \n     }\n-\n-    /** Dimension of the data. */\n-    private int k;\n-\n-    /** Count of values that have been added */\n-    private long n = 0;\n-\n-    /** Sum statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic[] sumImpl;\n-\n-    /** Sum of squares statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic[] sumSqImpl;\n-\n-    /** Minimum statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic[] minImpl;\n-\n-    /** Maximum statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic[] maxImpl;\n-\n-    /** Sum of log statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic[] sumLogImpl;\n-\n-    /** Geometric mean statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic[] geoMeanImpl;\n-\n-    /** Mean statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic[] meanImpl;\n-\n-    /** Covariance statistic implementation - cannot be reset. */\n-    private VectorialCovariance covarianceImpl;\n \n     /**\n      * Add an n-tuple to the data\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n     /** Serialization UID */\n     private static final long serialVersionUID = -2021321786743555871L;\n \n+    /** count of values that have been added */\n+    protected long n = 0;\n+\n+    /** SecondMoment is used to compute the mean and variance */\n+    protected SecondMoment secondMoment = new SecondMoment();\n+\n+    /** sum of values that have been added */\n+    protected Sum sum = new Sum();\n+\n+    /** sum of the square of each value that has been added */\n+    protected SumOfSquares sumsq = new SumOfSquares();\n+\n+    /** min of values that have been added */\n+    protected Min min = new Min();\n+\n+    /** max of values that have been added */\n+    protected Max max = new Max();\n+\n+    /** sumLog of values that have been added */\n+    protected SumOfLogs sumLog = new SumOfLogs();\n+\n+    /** geoMean of values that have been added */\n+    protected GeometricMean geoMean = new GeometricMean(sumLog);\n+\n+    /** mean of values that have been added */\n+    protected Mean mean = new Mean();\n+\n+    /** variance of values that have been added */\n+    protected Variance variance = new Variance();\n+\n+    /** Sum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic sumImpl = sum;\n+\n+    /** Sum of squares statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic sumsqImpl = sumsq;\n+\n+    /** Minimum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic minImpl = min;\n+\n+    /** Maximum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic maxImpl = max;\n+\n+    /** Sum of log statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic sumLogImpl = sumLog;\n+\n+    /** Geometric mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic geoMeanImpl = geoMean;\n+\n+    /** Mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic meanImpl = mean;\n+\n+    /** Variance statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic varianceImpl = variance;\n+\n     /**\n      * Construct a SummaryStatistics instance\n      */\n     public SummaryStatistics(SummaryStatistics original) {\n         copy(original, this);\n     }\n-\n-    /** count of values that have been added */\n-    protected long n = 0;\n-\n-    /** SecondMoment is used to compute the mean and variance */\n-    protected SecondMoment secondMoment = new SecondMoment();\n-\n-    /** sum of values that have been added */\n-    protected Sum sum = new Sum();\n-\n-    /** sum of the square of each value that has been added */\n-    protected SumOfSquares sumsq = new SumOfSquares();\n-\n-    /** min of values that have been added */\n-    protected Min min = new Min();\n-\n-    /** max of values that have been added */\n-    protected Max max = new Max();\n-\n-    /** sumLog of values that have been added */\n-    protected SumOfLogs sumLog = new SumOfLogs();\n-\n-    /** geoMean of values that have been added */\n-    protected GeometricMean geoMean = new GeometricMean(sumLog);\n-\n-    /** mean of values that have been added */\n-    protected Mean mean = new Mean();\n-\n-    /** variance of values that have been added */\n-    protected Variance variance = new Variance();\n-\n-    /** Sum statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic sumImpl = sum;\n-\n-    /** Sum of squares statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic sumsqImpl = sumsq;\n-\n-    /** Minimum statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic minImpl = min;\n-\n-    /** Maximum statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic maxImpl = max;\n-\n-    /** Sum of log statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic sumLogImpl = sumLog;\n-\n-    /** Geometric mean statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic geoMeanImpl = geoMean;\n-\n-    /** Mean statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic meanImpl = mean;\n-\n-    /** Variance statistic implementation - can be reset by setter. */\n-    private StorelessUnivariateStatistic varianceImpl = variance;\n \n     /**\n      * Return a {@link StatisticalSummaryValues} instance reporting current\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n     }\n \n     /**\n+     * Create a GeometricMean instance using the given SumOfLogs instance\n+     * @param sumOfLogs sum of logs instance to use for computation\n+     */\n+    public GeometricMean(SumOfLogs sumOfLogs) {\n+        this.sumOfLogs = sumOfLogs;\n+    }\n+\n+    /**\n      * {@inheritDoc}\n      */\n     @Override\n         GeometricMean result = new GeometricMean();\n         copy(this, result);\n         return result;\n-    }\n-\n-    /**\n-     * Create a GeometricMean instance using the given SumOfLogs instance\n-     * @param sumOfLogs sum of logs instance to use for computation\n-     */\n-    public GeometricMean(SumOfLogs sumOfLogs) {\n-        this.sumOfLogs = sumOfLogs;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/inference/TestUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TestUtils.java\n  * @version $Revision$ $Date$\n  */\n public class TestUtils  {\n-    /**\n-     * Prevent instantiation.\n-     */\n-    protected TestUtils() {\n-        super();\n-    }\n \n     /** Singleton TTest instance using default implementation. */\n     private static TTest tTest = new TTestImpl();\n         new OneWayAnovaImpl();\n \n     /**\n+     * Prevent instantiation.\n+     */\n+    protected TestUtils() {\n+        super();\n+    }\n+\n+    /**\n      * Set the (singleton) TTest instance.\n      *\n      * @param chiSquareTest the new instance to use\n--- a/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n  */\n public class NaturalRanking implements RankingAlgorithm {\n \n+    /** default NaN strategy */\n+    public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.MAXIMAL;\n+\n+    /** default ties strategy */\n+    public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;\n+\n     /** NaN strategy - defaults to NaNs maximal */\n     private final NaNStrategy nanStrategy;\n \n \n     /** Source of random data - used only when ties strategy is RANDOM */\n     private final RandomData randomData;\n-\n-    /** default NaN strategy */\n-    public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.MAXIMAL;\n-\n-    /** default ties strategy */\n-    public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;\n \n     /**\n      * Create a NaturalRanking with default strategies for handling ties and NaNs.\n--- a/src/main/java/org/apache/commons/math/util/BigReal.java\n+++ b/src/main/java/org/apache/commons/math/util/BigReal.java\n  */\n public class BigReal implements FieldElement<BigReal>, Comparable<BigReal>, Serializable {\n \n+    /** A big real representing 0. */\n+    public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);\n+\n+    /** A big real representing 1. */\n+    public static final BigReal ONE = new BigReal(BigDecimal.ONE);\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 7887631840434052850L;\n-\n-    /** A big real representing 0. */\n-    public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);\n-\n-    /** A big real representing 1. */\n-    public static final BigReal ONE = new BigReal(BigDecimal.ONE);\n \n     /** Underlying BigDecimal. */\n     private final BigDecimal d;\n--- a/src/main/java/org/apache/commons/math/util/BigRealField.java\n+++ b/src/main/java/org/apache/commons/math/util/BigRealField.java\n         return BigReal.ZERO;\n     }\n \n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n     /** Holder for the instance.\n      * <p>We use here the Initialization On Demand Holder Idiom.</p>\n      */\n     private static class LazyHolder {\n-\n-        /** Private constructor. */\n-        private LazyHolder() {\n-        }\n-\n         /** Cached field instance. */\n         private static final BigRealField INSTANCE = new BigRealField();\n-\n     }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n \n     /** Handle deserialization of the singleton.\n      * @return the singleton instance\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     /** Offset to order signed double numbers lexicographically. */\n     private static final long SGN_MASK = 0x8000000000000000L;\n \n+    /** All long-representable factorials */\n+    private static final long[] FACTORIALS = new long[] {\n+                       1l,                  1l,                   2l,\n+                       6l,                 24l,                 120l,\n+                     720l,               5040l,               40320l,\n+                  362880l,            3628800l,            39916800l,\n+               479001600l,         6227020800l,         87178291200l,\n+           1307674368000l,     20922789888000l,     355687428096000l,\n+        6402373705728000l, 121645100408832000l, 2432902008176640000l };\n+\n     /**\n      * Private Constructor\n      */\n         }\n         return true;\n     }\n-\n-    /** All long-representable factorials */\n-    private static final long[] FACTORIALS = new long[]\n-       {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,\n-        479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,\n-        355687428096000l, 6402373705728000l, 121645100408832000l,\n-        2432902008176640000l};\n \n     /**\n      * Returns n!. Shorthand for <code>n</code> <a\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n  */\n public class OpenIntToDoubleHashMap implements Serializable {\n \n+    /** Status indicator for free table entries. */\n+    protected static final byte FREE    = 0;\n+\n+    /** Status indicator for full table entries. */\n+    protected static final byte FULL    = 1;\n+\n+    /** Status indicator for removed table entries. */\n+    protected static final byte REMOVED = 2;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3646337053166149105L;\n \n \n     /** Number of bits to perturb the index when probing for collision resolution. */\n     private static final int PERTURB_SHIFT = 5;\n-\n-    /** Status indicator for free table entries. */\n-    protected static final byte FREE    = 0;\n-\n-    /** Status indicator for full table entries. */\n-    protected static final byte FULL    = 1;\n-\n-    /** Status indicator for removed table entries. */\n-    protected static final byte REMOVED = 2;\n \n     /** Keys table. */\n     private int[] keys;\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n  */\n public class OpenIntToFieldHashMap<T extends FieldElement<T>> implements Serializable {\n \n+    /** Status indicator for free table entries. */\n+    protected static final byte FREE    = 0;\n+\n+    /** Status indicator for full table entries. */\n+    protected static final byte FULL    = 1;\n+\n+    /** Status indicator for removed table entries. */\n+    protected static final byte REMOVED = 2;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -9179080286849120720L;\n \n \n     /** Number of bits to perturb the index when probing for collision resolution. */\n     private static final int PERTURB_SHIFT = 5;\n-\n-    /** Status indicator for free table entries. */\n-    protected static final byte FREE    = 0;\n-\n-    /** Status indicator for full table entries. */\n-    protected static final byte FULL    = 1;\n-\n-    /** Status indicator for removed table entries. */\n-    protected static final byte REMOVED = 2;\n \n     /** Field to which the elements belong. */\n     private final Field<T> field;\n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n  */\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n \n+    /** additive expansion mode */\n+    public static final int ADDITIVE_MODE = 1;\n+\n+    /** multiplicative expansion mode */\n+    public static final int MULTIPLICATIVE_MODE = 0;\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3485529955529426875L;\n-\n-    /** additive expansion mode */\n-    public static final int ADDITIVE_MODE = 1;\n-\n-    /** multiplicative expansion mode */\n-    public static final int MULTIPLICATIVE_MODE = 0;\n \n     /**\n      * The contraction criteria determines when the internal array will be", "timestamp": 1252251170, "metainfo": ""}