{"sha": "60f99131f87d7250527bec11c5d84e104a78c6cf", "log": "added a way to build dense matrices from data already in block layout  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n         blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n         blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n-        // number of lines in smaller blocks at the bottom side of the matrix\n-        final int lastLines = rows - (blockRows - 1) * BLOCK_SIZE;\n-\n-        // number of columns in smaller blocks at the right side of the matrix\n-        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n-\n         // allocate storage blocks, taking care of smaller ones at right and bottom\n-        blocks       = new double[blockRows * blockColumns][];\n+        blocks = new double[blockRows * blockColumns][];\n         int blockIndex = 0;\n-        for (int iBlock = 0; iBlock < (blockRows - 1); ++iBlock) {\n-            for (int jBlock = 0; jBlock < (blockColumns - 1); ++jBlock) {\n-                blocks[blockIndex++] = new double[BLOCK_SIZE * BLOCK_SIZE];\n-            }\n-            blocks[blockIndex++] = new double[BLOCK_SIZE * lastColumns];\n-        }\n-        for (int jBlock = 0; jBlock < (blockColumns - 1); ++jBlock) {\n-            blocks[blockIndex++] = new double[lastLines * BLOCK_SIZE];\n-        }\n-        blocks[blockIndex++] = new double[lastLines * lastColumns];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                blocks[blockIndex++] = new double[iHeight * blockWidth(jBlock)];\n+            }\n+        }\n \n     }\n \n     /**\n-     * Create a new RealMatrix using the input array as the underlying\n-     * data array.\n-     * <p>The input array is copied (and data rearranged), it is not referenced.</p>\n+     * Create a new dense matrix copying entries from raw layout data.\n+     * <p>The input array <em>must</em> already be in raw layout.</p>\n+     * <p>Calling this constructor is equivalent to call:\n+     * <pre>matrix = new DenseRealMatrix(rawData.length, rawData[0].length,\n+     *                                   toBlocksLayout(rawData), false);</pre>\n+     * </p>\n+     * @param rawData data for new matrix, in raw layout\n      *\n-     * @param d data for new matrix\n-     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #DenseRealMatrix(int, int, double[][], boolean)\n+     */\n+    public DenseRealMatrix(final double[][] rawData)\n+        throws IllegalArgumentException {\n+        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from block layout data.\n+     * <p>The input array <em>must</em> already be in blocks layout.</p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @param blockData data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #toBlocksLayout(double[][])\n+     * @see #DenseRealMatrix(double[][])\n+     */\n+    public DenseRealMatrix(final int rows, final int columns,\n+                           final double[][] blockData, final boolean copyArray)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        if (copyArray) {\n+            // allocate storage blocks, taking care of smaller ones at right and bottom\n+            blocks = new double[blockRows * blockColumns][];\n+        } else {\n+            // reference existing array\n+            blocks = blockData;\n+        }\n+\n+        int index = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n+                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\"wrong array shape (block length = {0}, expected {1})\",\n+                                                                              new Object[] {\n+                                                                                  blockData[index].length,\n+                                                                                  iHeight * blockWidth(jBlock)\n+                                                                              });\n+                }\n+                if (copyArray) {\n+                    blocks[index] = blockData[index].clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a data array from raw layout to blocks layout.\n+     * <p>\n+     * Raw layout is the straightforward layout where element at row i and\n+     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n+     * is the layout used in {@link DenseRealMatrix} instances, where the matrix\n+     * is split in square blocks (except at right and bottom side where blocks may\n+     * be rectangular to fit matrix size) and each block is stored in a flattened\n+     * one-dimensional array.\n+     * </p>\n+     * <p>\n+     * This method creates an array in blocks layout from an input array in raw layout.\n+     * It can be used to provide the array argument of the {@link\n+     * DenseRealMatrix#DenseRealMatrix(int, int, double[][], boolean)} constructor.\n+     * </p>\n+     * @param rawData data array in raw layout\n+     * @return a new data array containing the same entries but in blocks layout\n+     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n      *  (not all rows have the same length)\n+     * @see #DenseRealMatrix(int, int, double[][], boolean)\n      */\n-    public DenseRealMatrix(final double[][] d)\n+    public static double[][] toBlocksLayout(final double[][] rawData)\n         throws IllegalArgumentException {\n \n-        // build empty instance\n-        this(d.length, d[0].length);\n-\n-        // fill in instance\n-        for (int i = 0; i < d.length; ++i) {\n-            final double[] rowI = d[i];\n-            if (rowI.length != columns) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"some rows have length {0} while others have length {1}\",\n-                                                                          new Object[] {\n-                                                                              columns, rowI.length\n-                                                                          }); \n-            }\n-            for (int j = 0; j < rowI.length; ++j) {\n-                setEntry(i, j, rowI[j]);\n-            }\n-        }\n+        final int rows         = rawData.length;\n+        final int columns      = rawData[0].length;\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // safety checks\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int length = rawData[i].length;\n+            if (length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        new Object[] { columns, length }); \n+            }\n+        }\n+\n+        // convert array\n+        final double[][] blocks = new double[blockRows * blockColumns][];\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+\n+                // allocate new block\n+                final double[] block = new double[iHeight * jWidth];\n+                blocks[blockIndex] = block;\n+\n+                // copy data\n+                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n+                }\n+\n+            }\n+        }\n+\n+        return blocks;\n \n     }\n ", "timestamp": 1230927190, "metainfo": ""}