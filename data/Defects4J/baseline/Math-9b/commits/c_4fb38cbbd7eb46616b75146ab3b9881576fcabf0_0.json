{"sha": "4fb38cbbd7eb46616b75146ab3b9881576fcabf0", "log": "Issues 356 and 357.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n \n     // org.apache.commons.math.analysis.interpolation.SplineInterpolator\n     { \"points {0} and {1} are not strictly increasing ({2} >= {3})\",\n-      \"les points {0} et {1} ne sont pas strictements croissants ({2} >= {3})\" },\n+      \"les points {0} et {1} ne sont pas strictement croissants ({2} >= {3})\" },\n+    { \"points {0} and {1} are not strictly decreasing ({2} <= {3})\",\n+      \"les points {0} et {1} ne sont pas strictement d\\u00e9croissants ({2} <= {3})\" },\n+    { \"points {0} and {1} are not increasing ({2} > {3})\",\n+      \"les points {0} et {1} ne sont pas croissants ({2} > {3})\" },\n+    { \"points {0} and {1} are not decreasing ({2} < {3})\",\n+      \"les points {0} et {1} ne sont pas d\\u00e9croissants ({2} < {3})\" },\n \n     // org.apache.commons.math.analysis.interpolation.LoessInterpolator\n     { \"bandwidth must be in the interval [0,1], but got {0}\",\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+\n+/**\n+ * Function that implements the\n+ * <a href=\"http://en.wikipedia.org/wiki/Bicubic_interpolation\">\n+ * bicubic spline interpolation</a>.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class BicubicSplineInterpolatingFunction\n+    implements BivariateRealFunction {\n+    /**\n+     * Matrix to compute the spline coefficients from the function values\n+     * and function derivatives values\n+     */\n+    private final static double[][] aInv = {\n+        { 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0 },\n+        { -3,3,0,0,-2,-1,0,0,0,0,0,0,0,0,0,0 },\n+        { 2,-2,0,0,1,1,0,0,0,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0 },\n+        { 0,0,0,0,0,0,0,0,-3,3,0,0,-2,-1,0,0 },\n+        { 0,0,0,0,0,0,0,0,2,-2,0,0,1,1,0,0 },\n+        { -3,0,3,0,0,0,0,0,-2,0,-1,0,0,0,0,0 },\n+        { 0,0,0,0,-3,0,3,0,0,0,0,0,-2,0,-1,0 },\n+        { 9,-9,-9,9,6,3,-6,-3,6,-6,3,-3,4,2,2,1 },\n+        { -6,6,6,-6,-3,-3,3,3,-4,4,-2,2,-2,-2,-1,-1 },\n+        { 2,0,-2,0,0,0,0,0,1,0,1,0,0,0,0,0 },\n+        { 0,0,0,0,2,0,-2,0,0,0,0,0,1,0,1,0 },\n+        { -6,6,6,-6,-4,-2,4,2,-3,3,-3,3,-2,-1,-2,-1 },\n+        { 4,-4,-4,4,2,2,-2,-2,2,-2,2,-2,1,1,1,1 }\n+    };\n+\n+    /** Samples x-coordinates */\n+    private final double[] xval;\n+    /** Samples y-coordinates */\n+    private final double[] yval;\n+    /** Set of cubic splines pacthing the whole data grid */\n+    private final BicubicSplineFunction[][] splines;\n+\n+    /**\n+     * @param x Sample values of the x-coordinate, in increasing order\n+     * @param y Sample values of the y-coordinate, in increasing order\n+     * @param z Values of the function on every grid point\n+     * @param dZdX Values of the partial derivative of function with respect\n+     * to x on every grid point\n+     * @param dZdY Values of the partial derivative of function with respect\n+     * to y on every grid point\n+     * @param dZdXdY Values of the cross partial derivative of function on\n+     * every grid point\n+     * @throws DimensionMismatchException if the various arrays do not contain\n+     * the expected number of elements.\n+     * @throws IllegalArgumentException if {@code x} or {@code y} are not strictly\n+     * increasing.\n+     */\n+    public BicubicSplineInterpolatingFunction(double[] x,\n+                                              double[] y,\n+                                              double[][] z,\n+                                              double[][] dZdX,\n+                                              double[][] dZdY,\n+                                              double[][] dZdXdY)\n+        throws MathException {\n+        final int xLen = x.length;\n+        final int yLen = y.length;\n+\n+        if (xLen == 0 || yLen == 0 || z.length == 0 || z[0].length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+        }\n+        if (xLen != z.length) {\n+            throw new DimensionMismatchException(xLen, z.length);\n+        }\n+        if (xLen != dZdX.length) {\n+            throw new DimensionMismatchException(xLen, dZdX.length);\n+        }\n+        if (xLen != dZdY.length) {\n+            throw new DimensionMismatchException(xLen, dZdY.length);\n+        }\n+        if (xLen != dZdXdY.length) {\n+            throw new DimensionMismatchException(xLen, dZdXdY.length);\n+        }\n+\n+        MathUtils.checkOrder(x, 1, true);\n+        MathUtils.checkOrder(y, 1, true);\n+        \n+        xval = x.clone();\n+        yval = y.clone();\n+\n+        final int lastI = xLen - 1;\n+        final int lastJ = yLen - 1;\n+        splines = new BicubicSplineFunction[lastI][lastJ];\n+\n+        for (int i = 0; i < lastI; i++) {\n+            if (z[i].length != yLen) {\n+                throw new DimensionMismatchException(z[i].length, yLen);\n+            }\n+            if (dZdX[i].length != yLen) {\n+                throw new DimensionMismatchException(dZdX[i].length, yLen);\n+            }\n+            if (dZdY[i].length != yLen) {\n+                throw new DimensionMismatchException(dZdY[i].length, yLen);\n+            }\n+            if (dZdXdY[i].length != yLen) {\n+                throw new DimensionMismatchException(dZdXdY[i].length, yLen);\n+            }\n+            final int ip1 = i + 1;\n+            for (int j = 0; j < lastJ; j++) {\n+                final int jp1 = j + 1;\n+                final double[] beta = new double[] {\n+                    z[i][j],      z[ip1][j],      z[i][jp1],      z[ip1][jp1],\n+                    dZdX[i][j],   dZdX[ip1][j],   dZdX[i][jp1],   dZdX[ip1][jp1],\n+                    dZdY[i][j],   dZdY[ip1][j],   dZdY[i][jp1],   dZdY[ip1][jp1],\n+                    dZdXdY[i][j], dZdXdY[ip1][j], dZdXdY[i][jp1], dZdXdY[ip1][jp1]\n+                };\n+\n+                splines[i][j] = new BicubicSplineFunction(computeSplineCoefficients(beta));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double value(double x, double y) {\n+        final int i = searchIndex(x, xval);\n+        if (i == -1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      x, xval[0], xval[xval.length - 1]);\n+        }\n+        final int j = searchIndex(y, yval);\n+        if (j == -1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      y, yval[0], yval[yval.length - 1]);\n+        }\n+\n+        final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n+        final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]);\n+\n+        return splines[i][j].value(xN, yN);\n+    }\n+\n+    /**\n+     * @param c coordinate\n+     * @param val coordinate samples\n+     * @return the index in {@code val} corresponding to the interval\n+     * containing {@code c}, or {@code -1} if {@code c} is out of the\n+     * range defined by the end values of {@code val}\n+     */\n+    private int searchIndex(double c, double[] val) {\n+        if (c < val[0]) {\n+            return -1;\n+        }\n+\n+        for (int i = 1, max = val.length; i < max; i++) {\n+            if (c <= val[i]) {\n+                return i - 1;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    /**\n+     * Compute the spline coefficients from the list of function values and\n+     * function partial derivatives values at the four corners of a grid\n+     * element. They must be specified in the following order:\n+     * <ul>\n+     *  <li>f(0,0)</li>\n+     *  <li>f(1,0)</li>\n+     *  <li>f(0,1)</li>\n+     *  <li>f(1,1)</li>\n+     *  <li>fx(0,0)</li>\n+     *  <li>fx(1,0)</li>\n+     *  <li>fx(0,1)</li>\n+     *  <li>fx(1,1)</li>\n+     *  <li>fy(0,0)</li>\n+     *  <li>fy(1,0)</li>\n+     *  <li>fy(0,1)</li>\n+     *  <li>fy(1,1)</li>\n+     *  <li>fxy(0,0)</li>\n+     *  <li>fxy(1,0)</li>\n+     *  <li>fxy(0,1)</li>\n+     *  <li>fxy(1,1)</li>\n+     * </ul>\n+     * @param beta List of function values and function partial derivatives\n+     * values\n+     * @return the spline coefficients\n+     */\n+    private double[] computeSplineCoefficients(double[] beta) {\n+        final double[] a = new double[16];\n+        \n+        for (int i = 0; i < 16; i++) {\n+            double result = 0;\n+            final double[] row = aInv[i];\n+            for (int j = 0; j < 16; j++) {\n+                result += row[j] * beta[j];\n+            }\n+            a[i] = result;\n+        }\n+\n+        return a;\n+    }\n+}\n+\n+/**\n+ * 2D-spline function.\n+ */\n+class BicubicSplineFunction\n+    implements BivariateRealFunction {\n+    /** Coefficients */\n+    private final double\n+        a00, a01, a02, a03,\n+        a10, a11, a12, a13,\n+        a20, a21, a22, a23,\n+        a30, a31, a32, a33;\n+\n+    /**\n+     * @param a Spline coefficients\n+     */\n+    public BicubicSplineFunction(double[] a) {\n+        this.a00 = a[0];\n+        this.a10 = a[1];\n+        this.a20 = a[2];\n+        this.a30 = a[3];\n+        this.a01 = a[4];\n+        this.a11 = a[5];\n+        this.a21 = a[6];\n+        this.a31 = a[7];\n+        this.a02 = a[8];\n+        this.a12 = a[9];\n+        this.a22 = a[10];\n+        this.a32 = a[11];\n+        this.a03 = a[12];\n+        this.a13 = a[13];\n+        this.a23 = a[14];\n+        this.a33 = a[15];\n+    }\n+\n+    /**\n+     * @param x x-coordinate of the interpolation point\n+     * @param y y-coordinate of the interpolation point\n+     * @return the interpolated value.\n+     */\n+    public double value(double x, double y) {\n+        if (x < 0 || x > 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      x, 0, 1);\n+        }\n+        if (y < 0 || y > 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"{0} out of [{1}, {2}] range\",\n+                                                                      y, 0, 1);\n+        }\n+        \n+        final double x2 = x * x;\n+        final double x3 = x2 * x;\n+        final double y2 = y * y;\n+        final double y3 = y2 * y;\n+        \n+        return a00 + a01 * y + a02 * y2 + a03 * y3\n+            + a10 * x + a11 * x * y + a12 * x * y2 + a13 * x * y3\n+            + a20 * x2 + a21 * x2 * y + a22 * x2 * y2 + a23 * x2 * y3\n+            + a30 * x3 + a31 * x3 * y + a32 * x3 * y2 + a33 * x3 * y3;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateRealGridInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+\n+/**\n+ * Interface representing a bivariate real interpolating function where the\n+ * sample points must be specified on a regular grid.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface BivariateRealGridInterpolator {\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param xval all the x-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param yval all the y-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param zval the values of the interpolation points on all the grid knots:\n+     * {@code zval[i][j] = f(xval[i], yval[j])}\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments violate assumptions made by the\n+     *         interpolation algorithm\n+     */\n+    BivariateRealFunction interpolate(double[] xval, double[] yval, double[][] zval)\n+        throws MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+/**\n+ * Generates a bicubic interpolation function.\n+ * Before interpolating, smoothing of the input data is performed using\n+ * splines.\n+ * See <b>Handbook on splines for the user</b>, ISBN 084939404X,\n+ * chapter 2.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class SmoothingBicubicSplineInterpolator\n+    implements BivariateRealGridInterpolator {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public BivariateRealFunction interpolate(final double[] xval,\n+                                             final double[] yval,\n+                                             final double[][] zval)\n+        throws MathException, IllegalArgumentException {\n+        if (xval.length == 0 || yval.length == 0 || zval.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"no data\");\n+        }\n+        if (xval.length != zval.length) {\n+            throw new DimensionMismatchException(xval.length, zval.length);\n+        }\n+\n+        MathUtils.checkOrder(xval, 1, true);\n+        MathUtils.checkOrder(yval, 1, true);\n+        \n+        final int xLen = xval.length;\n+        final int yLen = yval.length;\n+\n+        // Samples (first index is y-coordinate, i.e. subarray variable is x)\n+        // 0 <= i < xval.length\n+        // 0 <= j < yval.length\n+        // zX[j][i] = f(xval[i], yval[j])\n+        final double[][] zX = new double[yLen][xLen];\n+        for (int i = 0; i < xLen; i++) {\n+            if (zval[i].length != yLen) {\n+                throw new DimensionMismatchException(zval[i].length, yLen);\n+            }\n+\n+            for (int j = 0; j < yLen; j++) {\n+                zX[j][i] = zval[i][j];\n+            }\n+        }\n+\n+        final SplineInterpolator spInterpolator = new SplineInterpolator();\n+\n+        // For each line y[j] (0 <= j < yLen), construct a 1D spline with\n+        // respect to variable x\n+        final PolynomialSplineFunction[] ySplineX = new PolynomialSplineFunction[yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            ySplineX[j] = spInterpolator.interpolate(xval, zX[j]);\n+        }\n+\n+        // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n+        // values zY_1\n+        final double[][] zY_1 = new double[xLen][yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            final PolynomialSplineFunction f = ySplineX[j];\n+            for (int i = 0; i < xLen; i++) {\n+                zY_1[i][j] = f.value(xval[i]);\n+            }\n+        }\n+\n+        // For each line x[i] (0 <= i < xLen), construct a 1D spline with\n+        // respect to variable y generated by array zY_1[i]\n+        final PolynomialSplineFunction[] xSplineY = new PolynomialSplineFunction[xLen];\n+        for (int i = 0; i < xLen; i++) {\n+            xSplineY[i] = spInterpolator.interpolate(yval, zY_1[i]);\n+        }\n+\n+        // For every knot (xval[i], yval[j]) of the grid, calculate corrected\n+        // values zY_2\n+        final double[][] zY_2 = new double[xLen][yLen];\n+        for (int i = 0; i < xLen; i++) {\n+            final PolynomialSplineFunction f = xSplineY[i];\n+            for (int j = 0; j < yLen; j++) {\n+                zY_2[i][j] = f.value(yval[j]);\n+            }\n+        }\n+\n+        // Partial derivatives with respect to x at the grid knots\n+        final double[][] dZdX = new double[xLen][yLen];\n+        for (int j = 0; j < yLen; j++) {\n+            final UnivariateRealFunction f = ySplineX[j].derivative();\n+            for (int i = 0; i < xLen; i++) {\n+                dZdX[i][j] = f.value(xval[i]);\n+            }\n+        }\n+\n+        // Partial derivatives with respect to y at the grid knots\n+        final double[][] dZdY = new double[xLen][yLen];\n+        for (int i = 0; i < xLen; i++) {\n+            final UnivariateRealFunction f = xSplineY[i].derivative();\n+            for (int j = 0; j < yLen; j++) {\n+                dZdY[i][j] = f.value(yval[j]);\n+            }\n+        }\n+\n+        // Cross partial derivatives\n+        final double[][] dZdXdY = new double[xLen][yLen];\n+        for (int i = 0; i < xLen ; i++) {\n+            final int nI = nextIndex(i, xLen);\n+            final int pI = previousIndex(i);\n+            for (int j = 0; j < yLen; j++) {\n+                final int nJ = nextIndex(j, yLen);\n+                final int pJ = previousIndex(j);\n+                dZdXdY[i][j] =  (zY_2[nI][nJ] - zY_2[nI][pJ]\n+                                 - zY_2[pI][nJ] + zY_2[pI][pJ])\n+                    / ((xval[nI] - xval[pI]) * (yval[nJ] - yval[pJ])) ;\n+            }\n+        }\n+\n+        // Create the interpolating splines\n+        return new BicubicSplineInterpolatingFunction(xval, yval, zY_2,\n+                                                      dZdX, dZdY, dZdXdY);\n+    }\n+\n+    /**\n+     * Compute the next index of an array, clipping if necessary.\n+     * It is assumed (but not checked) that {@code i} is larger than or equal to 0}.\n+     *\n+     * @param i Index\n+     * @param max Upper limit of the array\n+     * @return the next index\n+     */\n+    private int nextIndex(int i, int max) {\n+        final int index = i + 1;\n+        return index < max ? index : index - 1;\n+    }\n+    /**\n+     * Compute the previous index of an array, clipping if necessary.\n+     * It is assumed (but not checked) that {@code i} is smaller than the size of the array.\n+     *\n+     * @param i Index\n+     * @param max Upper limit of the array\n+     * @return the previous index\n+     */\n+    private int previousIndex(int i) {\n+        final int index = i - 1;\n+        return index >= 0 ? index : 0;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n         return observations.toArray(new WeightedObservedPoint[observations.size()]);\n     }\n \n+    /**\n+     * Remove all observations.\n+     */\n+    public void clearObservations() {\n+        observations.clear();\n+    }\n+\n     /** Fit a curve.\n      * <p>This method compute the coefficients of the curve that best\n      * fit the sample of observed points previously given through calls\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n         return max;\n     }\n \n-\n+    /**\n+     * Checks that the given array is sorted.\n+     *\n+     * @param val Values\n+     * @param dir Order direction (-1 for decreasing, 1 for increasing)\n+     * @param strict Whether the order should be strict\n+     * @throws IllegalArgumentException if the array is not sorted.\n+     */\n+    public static void checkOrder(double[] val, int dir, boolean strict) {\n+        double previous = val[0];\n+\n+        for (int i = 1, max = val.length; i < max; i++) {\n+            if (dir > 0) {\n+                if (strict) {\n+                    if (val[i] <= previous) {\n+                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not strictly increasing ({2} >= {3})\",\n+                                                                                  i - 1, i, previous, val[i]);\n+                    }\n+                } else {\n+                    if (val[i] < previous) {\n+                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not increasing ({2} > {3})\",\n+                                                                                  i - 1, i, previous, val[i]);\n+                    }\n+                }\n+            } else {\n+                if (strict) {\n+                    if (val[i] >= previous) {\n+                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not strictly decreasing ({2} <= {3})\",\n+                                                                                  i - 1, i, previous, val[i]);\n+                    }\n+                } else {\n+                    if (val[i] > previous) {\n+                        throw MathRuntimeException.createIllegalArgumentException(\"points {0} and {1} are not decreasing ({2} < {3})\",\n+                                                                                  i - 1, i, previous, val[i]);\n+                    }\n+                }\n+            }\n+\n+            previous = val[i];\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for the bicubic function.\n+ * \n+ * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n+ */\n+public final class BicubicSplineInterpolatingFunctionTest {\n+    /**\n+     * Test preconditions.\n+     */\n+    @Test\n+    public void testPreconditions() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+\n+        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                                           zval, zval, zval);\n+        \n+        double[] wxval = new double[] {3, 2, 5, 6.5};\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(wxval, yval, zval, zval, zval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        double[] wyval = new double[] {-4, -1, -1, 2.5};\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, wyval, zval, zval, zval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        double[][] wzval = new double[xval.length][yval.length - 1];\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+\n+        wzval = new double[xval.length - 1][yval.length];\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        try {\n+            bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Test for a plane.\n+     * <p>\n+     * z = 2 x - 3 y + 5\n+     */\n+    @Test\n+    public void testPlane() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        // Function values\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x - 3 * y + 5;\n+                }\n+            };\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+        // Partial derivatives with respect to x\n+        double[][] dZdX = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                dZdX[i][j] = 2;\n+            }\n+        }\n+        // Partial derivatives with respect to y\n+        double[][] dZdY = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                dZdY[i][j] = -3;\n+            }\n+        }\n+        // Partial cross-derivatives\n+        double[][] dZdXdY = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                dZdXdY[i][j] = 0;\n+            }\n+        }\n+\n+        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                                           dZdX, dZdY, dZdXdY);\n+        double x, y;\n+        double expected, result;\n+\n+        x = 4;\n+        y = -3;\n+        expected = f.value(x, y);\n+        result = bcf.value(x, y);\n+        Assert.assertEquals(\"On sample point\",\n+                            expected, result, 1e-15);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = bcf.value(x, y);\n+        Assert.assertEquals(\"Half-way between sample points (middle of the patch)\",\n+                            expected, result, 0.3);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = bcf.value(x, y);\n+        Assert.assertEquals(\"Half-way between sample points (border of the patch)\",\n+                            expected, result, 0.3);\n+    }\n+\n+    /**\n+     * Test for a paraboloid.\n+     * <p>\n+     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5\n+     */\n+    @Test\n+    public void testParaboloid() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        // Function values\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;\n+                }\n+            };\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+        // Partial derivatives with respect to x\n+        double[][] dZdX = new double[xval.length][yval.length];\n+        BivariateRealFunction dfdX = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 4 * (x + y);\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                dZdX[i][j] = dfdX.value(xval[i], yval[j]);\n+            }\n+        }\n+        // Partial derivatives with respect to y\n+        double[][] dZdY = new double[xval.length][yval.length];\n+        BivariateRealFunction dfdY = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 4 * x - 6 * y;\n+                }\n+            };\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                dZdY[i][j] = dfdY.value(xval[i], yval[j]);\n+            }\n+        }\n+        // Partial cross-derivatives\n+        double[][] dZdXdY = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                dZdXdY[i][j] = 4;\n+            }\n+        }\n+\n+        BivariateRealFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval,\n+                                                                           dZdX, dZdY, dZdXdY);\n+        double x, y;\n+        double expected, result;\n+        \n+        x = 4;\n+        y = -3;\n+        expected = f.value(x, y);\n+        result = bcf.value(x, y);\n+        Assert.assertEquals(\"On sample point\",\n+                            expected, result, 1e-15);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = bcf.value(x, y);\n+        Assert.assertEquals(\"Half-way between sample points (middle of the patch)\",\n+                            expected, result, 2);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = bcf.value(x, y);\n+        Assert.assertEquals(\"Half-way between sample points (border of the patch)\",\n+                            expected, result, 2);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingBicubicSplineInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.analysis.BivariateRealFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for the bicubic interpolator.\n+ * \n+ * @version $Revision: 821626 $ $Date: 2009-10-04 23:57:30 +0200 (Sun, 04 Oct 2009) $ \n+ */\n+public final class SmoothingBicubicSplineInterpolatorTest {\n+    /**\n+     * Test preconditions.\n+     */\n+    @Test\n+    public void testPreconditions() throws MathException {\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+\n+        BivariateRealGridInterpolator interpolator = new SmoothingBicubicSplineInterpolator();\n+        \n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        \n+        double[] wxval = new double[] {3, 2, 5, 6.5};\n+        try {\n+            p = interpolator.interpolate(wxval, yval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[] wyval = new double[] {-4, -3, -1, -1};\n+        try {\n+            p = interpolator.interpolate(xval, wyval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+\n+        double[][] wzval = new double[xval.length][yval.length + 1];\n+        try {\n+            p = interpolator.interpolate(xval, wyval, zval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        wzval = new double[xval.length - 1][yval.length];\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+        wzval = new double[xval.length][yval.length - 1];\n+        try {\n+            p = interpolator.interpolate(xval, yval, wzval);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (DimensionMismatchException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Test of interpolator for a plane.\n+     * <p>\n+     * z = 2 x - 3 y + 5\n+     */\n+    @Test\n+    public void testPlane() throws MathException {\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x - 3 * y + 5;\n+                }\n+            };\n+\n+        BivariateRealGridInterpolator interpolator = new SmoothingBicubicSplineInterpolator();\n+\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        double x, y;\n+        double expected, result;\n+        \n+        x = 4;\n+        y = -3;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"On sample point\", expected, result, 1e-15);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (middle of the patch)\", expected, result, 0.3);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (border of the patch)\", expected, result, 0.3);\n+    }\n+\n+    /**\n+     * Test of interpolator for a paraboloid.\n+     * <p>\n+     * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5\n+     */\n+    @Test\n+    public void testParaboloid() throws MathException {\n+        BivariateRealFunction f = new BivariateRealFunction() {\n+                public double value(double x, double y) {\n+                    return 2 * x * x - 3 * y * y + 4 * x * y - 5;\n+                }\n+            };\n+\n+        BivariateRealGridInterpolator interpolator = new SmoothingBicubicSplineInterpolator();\n+\n+        double[] xval = new double[] {3, 4, 5, 6.5};\n+        double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};\n+        double[][] zval = new double[xval.length][yval.length];\n+        for (int i = 0; i < xval.length; i++) {\n+            for (int j = 0; j < yval.length; j++) {\n+                zval[i][j] = f.value(xval[i], yval[j]);\n+            }\n+        }\n+\n+        BivariateRealFunction p = interpolator.interpolate(xval, yval, zval);\n+        double x, y;\n+        double expected, result;\n+        \n+        x = 5;\n+        y = 0.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"On sample point\", expected, result, 1e-13);\n+\n+        x = 4.5;\n+        y = -1.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (middle of the patch)\", expected, result, 0.2);\n+\n+        x = 3.5;\n+        y = -3.5;\n+        expected = f.value(x, y);\n+        result = p.value(x, y);\n+        Assert.assertEquals(\"half-way between sample points (border of the patch)\", expected, result, 0.2);\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         assertEquals(4, MathUtils.distanceInf(p1, p2));\n     }\n \n+    public void testCheckOrder() {\n+        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 15}, 1, true);\n+        MathUtils.checkOrder(new double[] {-15, -5.5, -1, 2, 2}, 1, false);\n+        MathUtils.checkOrder(new double[] {3, -5.5, -11, -27.5}, -1, true);\n+        MathUtils.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5}, -1, false);\n+\n+        try {\n+            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15}, 1, true);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        try {\n+            MathUtils.checkOrder(new double[] {-15, -5.5, -1, -2, 2}, 1, false);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        try {\n+            MathUtils.checkOrder(new double[] {3, 3, -5.5, -11, -27.5}, -1, true);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+        try {\n+            MathUtils.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5}, -1, false);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException e) {\n+            // Expected\n+        }\n+    }\n }", "timestamp": 1269429247, "metainfo": ""}