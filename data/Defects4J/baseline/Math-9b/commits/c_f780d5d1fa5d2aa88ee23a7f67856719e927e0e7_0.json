{"sha": "f780d5d1fa5d2aa88ee23a7f67856719e927e0e7", "log": "added a getQT() method to QRDecomposition interface compute Q by transposing QT rather than the other way round for efficiency JIRA: MATH-223  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n     RealMatrix getQ() throws IllegalStateException;\n \n     /**\n+     * Returns the transpose of the matrix Q of the decomposition.\n+     * <p>Q is an orthogonal matrix</p>\n+     * @return the Q matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getQT() throws IllegalStateException;\n+\n+    /**\n      * Returns the Householder reflector vectors.\n      * <p>H is a lower trapezoidal matrix whose columns represent\n      * each successive Householder reflector vector. This matrix is used\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n     /** Cached value of Q. */\n     private RealMatrix cachedQ;\n \n+    /** Cached value of QT. */\n+    private RealMatrix cachedQT;\n+\n     /** Cached value of R. */\n     private RealMatrix cachedR;\n \n         final int n = matrix.getColumnDimension();\n         qrt = matrix.transpose().getData();\n         rDiag = new double[n];\n-        cachedQ = null;\n-        cachedR = null;\n-        cachedH = null;\n+        cachedQ  = null;\n+        cachedQT = null;\n+        cachedR  = null;\n+        cachedH  = null;\n \n         /*\n          * The QR decomposition of a matrix A is calculated using Householder\n     /** {@inheritDoc} */\n     public RealMatrix getQ()\n         throws IllegalStateException {\n-\n         if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getQT()\n+        throws IllegalStateException {\n+\n+            if (cachedQ == null) {\n \n             checkDecomposed();\n \n-            // Q is supposed to be m x m\n+            // QT is supposed to be m x m\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            double[][] q = new double[m][m];\n+            double[][] qT = new double[m][m];\n \n             /* \n              * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n              * succession to the result \n              */ \n             for (int minor = m - 1; minor >= Math.min(m, n); minor--) {\n-                q[minor][minor]=1;\n+                qT[minor][minor]=1;\n             }\n \n             for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n                 final double[] qrtMinor = qrt[minor];\n-                q[minor][minor] = 1;\n+                qT[minor][minor] = 1;\n                 if (qrtMinor[minor] != 0.0) {\n                     for (int col = minor; col < m; col++) {\n+                        final double[] qTCol = qT[col];\n                         double alpha = 0;\n                         for (int row = minor; row < m; row++) {\n-                            alpha -= q[row][col] * qrtMinor[row];\n+                            alpha -= qTCol[row] * qrtMinor[row];\n                         }\n                         alpha /= rDiag[minor] * qrtMinor[minor];\n \n                         for (int row = minor; row < m; row++) {\n-                            q[row][col] -= alpha * qrtMinor[row];\n+                            qTCol[row] -= alpha * qrtMinor[row];\n                         }\n                     }\n                 }\n             }\n \n             // cache the matrix for subsequent calls\n-            cachedQ = new RealMatrixImpl(q, false);\n+            cachedQT = new RealMatrixImpl(qT, false);\n \n         }\n \n         // return the cached matrix\n-        return cachedQ;\n+        return cachedQT;\n \n     }\n \n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n     /** test the orthogonality of Q */\n     public void testQOrthogonal() {\n         RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        RealMatrix q  = new QRDecompositionImpl(matrix).getQ();\n+        RealMatrix qT = new QRDecompositionImpl(matrix).getQT();\n         RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);\n-        double norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        double norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x3 nonsingular Q'Q = I\", 0, norm, normTolerance);\n \n         matrix = new RealMatrixImpl(testData3x3Singular, false);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        q  = new QRDecompositionImpl(matrix).getQ();\n+        qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n-        norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x3 singular Q'Q = I\", 0, norm, normTolerance);\n \n         matrix = new RealMatrixImpl(testData3x4, false);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        q  = new QRDecompositionImpl(matrix).getQ();\n+        qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n-        norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x4 Q'Q = I\", 0, norm, normTolerance);\n \n         matrix = new RealMatrixImpl(testData4x3, false);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        q  = new QRDecompositionImpl(matrix).getQ();\n+        qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(4);\n-        norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"4x3 Q'Q = I\", 0, norm, normTolerance);\n     }\n \n         // check values against known references\n         RealMatrix q = qr.getQ();\n         assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n+        RealMatrix qT = qr.getQT();\n+        assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);\n         RealMatrix r = qr.getR();\n         assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n         RealMatrix h = qr.getH();", "timestamp": 1222618661, "metainfo": ""}