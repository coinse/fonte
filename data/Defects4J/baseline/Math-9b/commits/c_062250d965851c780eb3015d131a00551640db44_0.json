{"sha": "062250d965851c780eb3015d131a00551640db44", "log": "Added a wrapper class to compute Jacobian from differentiable function.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/JacobianFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n+\n+/** Class representing the Jacobian of a multivariate vector function.\n+ * <p>\n+ * The rows iterate on the model functions while the columns iterate on the parameters; thus,\n+ * the numbers of rows is equal to the dimension of the underlying function vector\n+ * value and the number of columns is equal to the number of free parameters of\n+ * the underlying function.\n+ * </p>\n+ * @version $Id$\n+ * @since 3.1\n+ */\n+public class JacobianFunction implements MultivariateMatrixFunction {\n+\n+    /** Underlying vector-valued function. */\n+    private final MultivariateDifferentiableVectorFunction f;\n+\n+    /** Simple constructor.\n+     * @param f underlying vector-valued function\n+     */\n+    public JacobianFunction(final MultivariateDifferentiableVectorFunction f) {\n+        this.f = f;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[][] value(double[] point)\n+        throws IllegalArgumentException {\n+\n+        // set up parameters\n+        final DerivativeStructure[] dsX = new DerivativeStructure[point.length];\n+        for (int i = 0; i < point.length; ++i) {\n+            dsX[i] = new DerivativeStructure(point.length, 1, i, point[i]);\n+        }\n+\n+        // compute the derivatives\n+        final DerivativeStructure[] dsY = f.value(dsX);\n+\n+        // extract the Jacobian\n+        final double[][] y = new double[dsY.length][point.length];\n+        final int[] orders = new int[point.length];\n+        for (int i = 0; i < dsY.length; ++i) {\n+            for (int j = 0; j < point.length; ++j) {\n+                orders[j] = 1;\n+                y[i][j] = dsY[i].getPartialDerivative(orders);\n+                orders[j] = 0;\n+            }\n+        }\n+\n+        return y;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/JacobianFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.analysis.differentiation;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Test;\n+\n+\n+/**\n+ * Test for class {@link JacobianFunction}.\n+ */\n+public class JacobianFunctionTest {\n+\n+    @Test\n+    public void testSphere() {\n+        SphereMapping    f = new SphereMapping(10.0);\n+        JacobianFunction j = new JacobianFunction(f);\n+        for (double latitude = -1.5; latitude < 1.5; latitude += 0.1) {\n+            for (double longitude = -3.1; longitude < 3.1; longitude += 0.1) {\n+                double[] point = new double[] { latitude, longitude };\n+                double[][] referenceJacobian  = f.jacobian(point);\n+                double[][] testJacobian       = j.value(point);\n+                Assert.assertEquals(referenceJacobian.length, testJacobian.length);\n+                for (int i = 0; i < 3; ++i) {\n+                    TestUtils.assertEquals(referenceJacobian[i], testJacobian[i], 2.0e-15);\n+                }\n+            }\n+        }\n+    }\n+\n+    /* Maps (latitude, longitude) to (x, y, z) */\n+    private static class SphereMapping implements MultivariateDifferentiableVectorFunction {\n+\n+        private final double radius;\n+\n+        public SphereMapping(final double radius) {\n+            this.radius = radius;\n+        }\n+        \n+        public double[] value(double[] point) {\n+            final double cLat = FastMath.cos(point[0]);\n+            final double sLat = FastMath.sin(point[0]);\n+            final double cLon = FastMath.cos(point[1]);\n+            final double sLon = FastMath.sin(point[1]);\n+            return new double[] {\n+                radius * cLon * cLat,\n+                radius * sLon * cLat,\n+                radius * sLat\n+            };\n+        }\n+        \n+        public DerivativeStructure[] value(DerivativeStructure[] point) {\n+            final DerivativeStructure cLat = point[0].cos();\n+            final DerivativeStructure sLat = point[0].sin();\n+            final DerivativeStructure cLon = point[1].cos();\n+            final DerivativeStructure sLon = point[1].sin();\n+            return new DerivativeStructure[] {\n+                cLon.multiply(cLat).multiply(radius),\n+                sLon.multiply(cLat).multiply(radius),\n+                sLat.multiply(radius)\n+            };\n+        }\n+\n+        public double[][] jacobian(double[] point) {\n+            final double cLat = FastMath.cos(point[0]);\n+            final double sLat = FastMath.sin(point[0]);\n+            final double cLon = FastMath.cos(point[1]);\n+            final double sLon = FastMath.sin(point[1]);\n+            return new double[][] {\n+                { -radius * cLon * sLat, -radius * sLon * cLat },\n+                { -radius * sLon * sLat,  radius * cLon * cLat },\n+                {  radius * cLat,         0  }\n+            };\n+        }\n+\n+    }\n+\n+}", "timestamp": 1347449003, "metainfo": ""}