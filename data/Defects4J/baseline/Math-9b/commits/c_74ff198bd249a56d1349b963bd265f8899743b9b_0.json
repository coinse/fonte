{"sha": "74ff198bd249a56d1349b963bd265f8899743b9b", "log": "MATH-439 Refactored the \"solvers\" package. Implementations refer to number of evaluation of the objective function (instead of the number of iterations). New interfaces and base classes. \"NewtonSolver\" fits in the design without resorting to a cast. Created class \"MullerSolver2\" to contain the code of the method named \"solve2\" in class \"MullerSolver\". Removed \"UnivariateRealSolverFactory\" and \"UnivariateRealSolverFactoryImpl\". Default solver in \"UnivariateRealSolverUtils\" is explicitely instantiated. \"AbstractContinuousDistribution\": Type of exception thrown changed in \"UnivariateRealSolverUtils\". Factored out duplicate code (in \"GaussNewtonOptimizerTest\" and \"LevenbergMarquardtOptimizerTest\"): class \"Circle\" is now called \"CircleVectorial\". Also factored out the \"Circle\" class from \"NonLinearConjugateGradientOptimizerTest\": class is named \"CircleScalar\". Created \"SecantSolverTest\", moving there all the tests for the class \"SecantSolver\" that were located in class \"BrentSolverTest\". Created new interface and base class for polynomial functions solvers (\"LaguerreSolver\") so that the function type is now checked at compile time. Removed deprecated exceptions (MATH-441). Javadoc clean-up. Lowered tolerance values in some unit tests. Tests upgraded to Junit 4 (MATH-423).    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n  * @since 3.0\n  */\n public class FunctionUtils {\n+    /**\n+     * Class only contains static methods.\n+     */\n+    private FunctionUtils() {}\n+\n     /**\n      * Compose functions.\n      *\n      *\n      * @param f Binary function.\n      * @param fixed Value to which the first argument of {@code f} is set.\n+     * @return a unary function.\n      */\n     public static UnivariateRealFunction fix1stArgument(final BivariateRealFunction f,\n                                                         final double fixed) {\n      *\n      * @param f Binary function.\n      * @param fixed Value to which the second argument of {@code f} is set.\n+     * @return a unary function.\n      */\n     public static UnivariateRealFunction fix2ndArgument(final BivariateRealFunction f,\n                                                         final double fixed) {\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n  */\n package org.apache.commons.math.analysis.polynomials;\n \n-import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n      *\n      * @param a Coefficients in Newton form formula.\n      * @param c Centers.\n-     * @throws NullArgumentException if any argument is {@code null}.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * any argument is {@code null}.\n      * @throws NoDataException if any array has zero length.\n      * @throws DimensionMismatchException if the size difference between\n      * {@code a} and {@code c} is not equal to 1.\n      * @param c Centers.\n      * @param z Point at which the function value is to be computed.\n      * @return the function value.\n-     * @throws NullArgumentException if any argument is {@code null}.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * any argument is {@code null}.\n      * @throws NoDataException if any array has zero length.\n      * @throws DimensionMismatchException if the size difference between\n      * {@code a} and {@code c} is not equal to 1.\n      *\n      * @param a the coefficients in Newton form formula\n      * @param c the centers\n-     * @throws NullArgumentException if any argument is {@code null}.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * any argument is {@code null}.\n      * @throws NoDataException if any array has zero length.\n      * @throws DimensionMismatchException if the size difference between\n      * {@code a} and {@code c} is not equal to 1.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractDifferentiableUnivariateRealSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * solvers.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public abstract class AbstractDifferentiableUnivariateRealSolver\n+    extends BaseAbstractUnivariateRealSolver<DifferentiableUnivariateRealFunction>\n+    implements DifferentiableUnivariateRealSolver {\n+    /** Derivative of the function to solve. */\n+    private UnivariateRealFunction functionDerivative;\n+\n+    /**\n+     * Construct a solver with given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractDifferentiableUnivariateRealSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     * @param functionValueAccuracy Maximum function value error.\n+     */\n+    protected AbstractDifferentiableUnivariateRealSolver(final double relativeAccuracy,\n+                                                         final double absoluteAccuracy,\n+                                                         final double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     */\n+    protected double computeDerivativeObjectiveValue(double point) {\n+        incrementEvaluationCount();\n+        return functionDerivative.value(point);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void setup(DifferentiableUnivariateRealFunction f,\n+                         double min, double max,\n+                         double startValue) {\n+        super.setup(f, min, max, startValue);\n+        functionDerivative = f.derivative();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractPolynomialSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+\n+/**\n+ * Base class for solvers.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public abstract class AbstractPolynomialSolver\n+    extends BaseAbstractUnivariateRealSolver<PolynomialFunction>\n+    implements PolynomialSolver {\n+    /** Function. */\n+    private PolynomialFunction polynomialFunction;\n+\n+    /**\n+     * Construct a solver with given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractPolynomialSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractPolynomialSolver(final double relativeAccuracy,\n+                                       final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     * @param functionValueAccuracy Maximum function value error.\n+     */\n+    protected AbstractPolynomialSolver(final double relativeAccuracy,\n+                                       final double absoluteAccuracy,\n+                                       final double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void setup(PolynomialFunction f,\n+                         double min, double max,\n+                         double startValue) {\n+        super.setup(f, min, max, startValue);\n+        polynomialFunction = f;\n+    }\n+\n+    /**\n+     * @return the coefficients of the polynomial function.\n+     */\n+    protected double[] getCoefficients() {\n+        return polynomialFunction.getCoefficients();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AbstractUnivariateRealSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Base class for solvers.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public abstract class AbstractUnivariateRealSolver\n+    extends BaseAbstractUnivariateRealSolver<UnivariateRealFunction>\n+    implements UnivariateRealSolver {\n+    /**\n+     * Construct a solver with given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractUnivariateRealSolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected AbstractUnivariateRealSolver(final double relativeAccuracy,\n+                                           final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     * @param functionValueAccuracy Maximum function value error.\n+     */\n+    protected AbstractUnivariateRealSolver(final double relativeAccuracy,\n+                                           final double absoluteAccuracy,\n+                                           final double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.util.Incrementor;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * solvers.\n+ *\n+ * @param <FUNC> Type of function to solve.\n+ *\n+ * @version $Revision: 1030464 $ $Date: 2010-11-03 14:46:04 +0100 (Wed, 03 Nov 2010) $\n+ * @since 2.0\n+ */\n+public abstract class BaseAbstractUnivariateRealSolver<FUNC extends UnivariateRealFunction>\n+    implements BaseUnivariateRealSolver<FUNC> {\n+    /** Default absolute accuracy */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+    /** Default relative accuracy. */\n+    public static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n+    /** Default function value accuracy. */\n+    public static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n+    /** Function value accuracy. */\n+    private final double functionValueAccuracy;\n+    /** Absolute accuracy. */\n+    private final double absoluteAccuracy;\n+    /** Relative accuracy. */\n+    private final double relativeAccuracy;\n+    /** Evaluations counter. */\n+    private final Incrementor evaluations = new Incrementor();\n+    /** Lower end of search interval. */\n+    private double searchMin;\n+    /** Higher end of search interval. */\n+    private double searchMax;\n+    /** Initial guess. */\n+    private double searchStart;\n+    /** Function to solve. */\n+    private FUNC function;\n+\n+    /**\n+     * Construct a solver with given absolute accuracy.\n+     *\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected BaseAbstractUnivariateRealSolver(final double absoluteAccuracy) {\n+        this(DEFAULT_RELATIVE_ACCURACY,\n+             absoluteAccuracy,\n+             DEFAULT_FUNCTION_VALUE_ACCURACY);\n+    }\n+\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    protected BaseAbstractUnivariateRealSolver(final double relativeAccuracy,\n+                                               final double absoluteAccuracy) {\n+        this(relativeAccuracy,\n+             absoluteAccuracy,\n+             DEFAULT_FUNCTION_VALUE_ACCURACY);\n+    }\n+\n+    /**\n+     * Construct a solver with given accuracies.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     * @param functionValueAccuracy Maximum function value error.\n+     */\n+    protected BaseAbstractUnivariateRealSolver(final double relativeAccuracy,\n+                                               final double absoluteAccuracy,\n+                                               final double functionValueAccuracy) {\n+        this.absoluteAccuracy = absoluteAccuracy;\n+        this.relativeAccuracy = relativeAccuracy;\n+        this.functionValueAccuracy = functionValueAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        evaluations.setMaximalCount(maxEvaluations);\n+    }\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+    /**\n+     * @return the lower end of the search interval.\n+     */\n+    public double getMin() {\n+        return searchMin;\n+    }\n+    /**\n+     * @return the higher end of the search interval.\n+     */\n+    public double getMax() {\n+        return searchMax;\n+    }\n+    /**\n+     * @return the initial guess.\n+     */\n+    public double getStartValue() {\n+        return searchStart;\n+    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double getFunctionValueAccuracy() {\n+        return functionValueAccuracy;\n+    }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the objective function value at specified point.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    protected double computeObjectiveValue(double point) {\n+        incrementEvaluationCount();\n+        return function.value(point);\n+    }\n+\n+    /**\n+     * Prepare for computation.\n+     * Subclasses must call this method if they override any of the\n+     * {@code solve} methods.\n+     *\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     */\n+    protected void setup(FUNC f,\n+                         double min, double max,\n+                         double startValue) {\n+        // Checks.\n+        if (f == null) {\n+            throw new NullArgumentException();\n+        }\n+\n+        // Reset.\n+        searchMin = min;\n+        searchMax = max;\n+        searchStart = startValue;\n+        function = f;\n+        evaluations.resetCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(FUNC f, double min, double max, double startValue) {\n+        // Initialization.\n+        setup(f, min, max, startValue);\n+\n+        // Perform computation.\n+        return doSolve();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(FUNC f, double min, double max) {\n+        return solve(f, min, max, min + 0.5 * (max - min));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(FUNC f, double startValue) {\n+        return solve(f, Double.NaN, Double.NaN, startValue);\n+    }\n+\n+    /**\n+     * Method for implementing actual optimization algorithms in derived\n+     * classes.\n+     *\n+     * @return the root.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    protected abstract double doSolve();\n+\n+    /**\n+     * Check whether the function takes opposite signs at the endpoints.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @return {@code true} if the function values have opposite signs at the\n+     * given points.\n+     */\n+    protected boolean isBracketing(final double lower,\n+                                   final double upper) {\n+        return UnivariateRealSolverUtils.isBracketing(function, lower, upper);\n+    }\n+\n+    /**\n+     * Check whether the arguments form a (strictly) increasing sequence.\n+     *\n+     * @param start First number.\n+     * @param mid Second number.\n+     * @param end Third number.\n+     * @return {@code true} if the arguments form an increasing sequence.\n+     */\n+    protected boolean isSequence(final double start,\n+                                 final double mid,\n+                                 final double end) {\n+        return UnivariateRealSolverUtils.isSequence(start, mid, end);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n+     * if {@code lower >= upper}.\n+     */\n+    protected void verifyInterval(final double lower,\n+                                  final double upper) {\n+        UnivariateRealSolverUtils.verifyInterval(lower, upper);\n+    }\n+\n+    /**\n+     * Check that {@code lower < initial < upper}.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param initial Initial value.\n+     * @param upper Upper endpoint.\n+     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n+     * if {@code lower >= initial} or {@code initial >= upper}.\n+     */\n+    protected void verifySequence(final double lower,\n+                                  final double initial,\n+                                  final double upper) {\n+        UnivariateRealSolverUtils.verifySequence(lower, initial, upper);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval and the function takes\n+     * opposite signs at the endpoints.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws org.apache.commons.math.exception.NoBracketingException if\n+     * the function has the same sign at the endpoints.\n+     */\n+    protected void verifyBracketing(final double lower,\n+                                    final double upper) {\n+        UnivariateRealSolverUtils.verifyBracketing(function, lower, upper);\n+    }\n+\n+    /**\n+     * Increment the evaluation count by one.\n+     * Method {@link #computeObjectiveValue(double)} calls this method internally.\n+     * It is provided for subclasses that do not exclusively use\n+     * {@code computeObjectiveValue} to solve the function.\n+     * See e.g. {@link AbstractDifferentiableUnivariateRealSolver}.\n+     */\n+    protected void incrementEvaluationCount() {\n+        try {\n+            evaluations.incrementCount();\n+        } catch (MaxCountExceededException e) {\n+            throw new TooManyEvaluationsException(e.getMax());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseUnivariateRealSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) rootfinding algorithms.\n+ * Implementations will search for only one zero in the given interval.\n+ *\n+ * @param <FUNC> Type of function to solve.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface BaseUnivariateRealSolver<FUNC extends UnivariateRealFunction> {\n+    /**\n+     * Set the maximal number of function evaluations.\n+     *\n+     * @param maxEvaluations Maximal number of function evaluations.\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /**\n+     * Get the maximal number of function evaluations.\n+     *\n+     * @return the maximal number of function evaluations.\n+     */\n+    int getMaxEvaluations();\n+\n+    /**\n+     * Get the number of evaluations of the objective function.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@code optimize} method. It is 0 if the method has not been\n+     * called yet.\n+     *\n+     * @return the number of evaluations of the objective function.\n+     */\n+    int getEvaluations();\n+\n+    /**\n+     * @return the absolute accuracy.\n+     */\n+    double getAbsoluteAccuracy();\n+    /**\n+     * @return the relative accuracy.\n+     */\n+    double getRelativeAccuracy();\n+    /**\n+     * @return the function value accuracy.\n+     */\n+    double getFunctionValueAccuracy();\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @return a value where the function is zero.\n+     * @throws IllegalArgumentException if {@code min > max} or the endpoints\n+     * do not satisfy the requirements specified by the solver.\n+     * @since 2.0\n+     */\n+    double solve(FUNC f, double min, double max);\n+\n+    /**\n+     * Solve for a zero in the given interval, start at {@code startValue}.\n+     * A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.\n+     *\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param startValue Start value to use.\n+     * @return a value where the function is zero.\n+     * @throws IllegalArgumentException if {@code min > max} or the arguments\n+     * do not satisfy the requirements specified by the solver.\n+     * @since 2.0\n+     */\n+    double solve(FUNC f, double min, double max, double startValue);\n+\n+    /**\n+     * Solve for a zero in the vicinity of {@code startValue}.\n+     * A solver may require that the interval brackets a single zero root.\n+     *\n+     * @param f Function to solve.\n+     * @param startValue Start value to use.\n+     * @return a value where the function is zero.\n+     * @throws IllegalArgumentException if {@code min > max} or the arguments\n+     * do not satisfy the requirements specified by the solver.\n+     * @since 2.0\n+     */\n+    double solve(FUNC f, double startValue);\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  *\n  * @version $Revision$ $Date$\n  */\n-public class BisectionSolver extends UnivariateRealSolverImpl {\n+public class BisectionSolver extends AbstractUnivariateRealSolver {\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n+    /**\n+     * Construct a solver with default accuracy.\n+     */\n+    public BisectionSolver() {\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n     /**\n      * Construct a solver.\n      *\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n-    public BisectionSolver() {\n-        super(100, 1E-6);\n+    public BisectionSolver(double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public BisectionSolver(double relativeAccuracy,\n+                           double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n     }\n \n-    /** {@inheritDoc} */\n-    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n-        throws MaxIterationsExceededException, MathUserException {\n-        return solve(f, min, max);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double solve(final UnivariateRealFunction f, double min, double max)\n-        throws MaxIterationsExceededException, MathUserException {\n-\n-        clearResult();\n-        verifyInterval(min,max);\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected double doSolve() {\n+        double min = getMin();\n+        double max = getMax();\n+        verifyInterval(min, max);\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n         double m;\n         double fm;\n         double fmin;\n \n-        int i = 0;\n-        while (i < maximalIterationCount) {\n+        while (true) {\n             m = UnivariateRealSolverUtils.midpoint(min, max);\n-           fmin = f.value(min);\n-           fm = f.value(m);\n+            fmin = computeObjectiveValue(min);\n+            fm = computeObjectiveValue(m);\n \n-            if (fm * fmin > 0.0) {\n+            if (fm * fmin > 0) {\n                 // max and m bracket the root.\n                 min = m;\n             } else {\n \n             if (FastMath.abs(max - min) <= absoluteAccuracy) {\n                 m = UnivariateRealSolverUtils.midpoint(min, max);\n-                setResult(m, i);\n                 return m;\n             }\n-            ++i;\n         }\n-\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n- * Brent algorithm</a> for  finding zeros of real univariate functions.\n- * <p>\n- * The function should be continuous but not necessarily smooth.</p>\n+ * This class implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n+ * Brent algorithm</a> for finding zeros of real univariate functions.\n+ * The function should be continuous but not necessarily smooth.\n+ * The {@code solve} method returns a zero {@code x} of the function {@code f}\n+ * in the given interval {@code [a, b]} to within a tolerance\n+ * {@code 6 eps abs(x) + t} where {@code eps} is the relative accuracy and\n+ * {@code t} is the absolute accuracy.\n+ * The given interval must bracket the root.\n  *\n  * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  */\n-public class BrentSolver extends UnivariateRealSolverImpl {\n-\n-    /**\n-     * Default absolute accuracy\n-     * @since 2.1\n-     */\n-    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1E-6;\n-\n-    /** Default maximum number of iterations\n-     * @since 2.1\n-     */\n-    public static final int DEFAULT_MAXIMUM_ITERATIONS = 100;\n-\n+public class BrentSolver extends AbstractUnivariateRealSolver {\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7694577816772532779L;\n-\n-    /**\n-     * Construct a solver with default properties.\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n+    /**\n+     * Construct a solver with default accuracies.\n      */\n     public BrentSolver() {\n-        super(DEFAULT_MAXIMUM_ITERATIONS, DEFAULT_ABSOLUTE_ACCURACY);\n-    }\n-\n-    /**\n-     * Construct a solver with the given absolute accuracy.\n-     *\n-     * @param absoluteAccuracy lower bound for absolute accuracy of solutions returned by the solver\n-     * @since 2.1\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public BrentSolver(double absoluteAccuracy) {\n-        super(DEFAULT_MAXIMUM_ITERATIONS, absoluteAccuracy);\n-    }\n-\n-    /**\n-     * Contstruct a solver with the given maximum iterations and absolute accuracy.\n-     *\n-     * @param maximumIterations maximum number of iterations\n-     * @param absoluteAccuracy lower bound for absolute accuracy of solutions returned by the solver\n-     * @since 2.1\n-     */\n-    public BrentSolver(int maximumIterations, double absoluteAccuracy) {\n-        super(maximumIterations, absoluteAccuracy);\n-    }\n-\n-    /**\n-     * Find a zero in the given interval with an initial guess.\n-     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n-     * function at the three points have the same sign (note that it is\n-     * allowed to have endpoints with the same sign if the initial point has\n-     * opposite sign function-wise).</p>\n-     *\n-     * @param f function to solve.\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @param initial the start value to use (must be set to min if no\n-     * initial point is known).\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating  the function\n-     * @throws IllegalArgumentException if initial is not between min and max\n-     * (even if it <em>is</em> a root)\n-     */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, MathUserException {\n-\n-        clearResult();\n-        if ((initial < min) || (initial > max)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS,\n-                  min, initial, max);\n-        }\n-\n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public BrentSolver(double relativeAccuracy,\n+                       double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param functionValueAccuracy Function value accuracy.\n+     */\n+    public BrentSolver(double relativeAccuracy,\n+                       double absoluteAccuracy,\n+                       double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected double doSolve() {\n+        double min = getMin();\n+        double max = getMax();\n+        final double initial = getStartValue();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        verifySequence(min, initial, max);\n+\n+        // Return the initial guess if it is good enough.\n+        double yInitial = computeObjectiveValue(initial);\n         if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n-        }\n-\n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n+            return initial;\n+        }\n+\n+        // Return the first endpoint if it is good enough.\n+        double yMin = computeObjectiveValue(min);\n         if (FastMath.abs(yMin) <= functionValueAccuracy) {\n-            setResult(min, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n+            return min;\n+        }\n+\n+        // Reduce interval if min and initial bracket the root.\n         if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n+            return brent(min, initial, yMin, yInitial);\n+        }\n+\n+        // Return the second endpoint if it is good enough.\n+        double yMax = computeObjectiveValue(max);\n         if (FastMath.abs(yMax) <= functionValueAccuracy) {\n-            setResult(max, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if initial and max bracket the root\n+            return max;\n+        }\n+\n+        // Reduce interval if initial and max bracket the root.\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n-\n-        throw MathRuntimeException.createIllegalArgumentException(\n-              LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, yMin, yMax);\n-\n-    }\n-\n-    /**\n-     * Find a zero in the given interval.\n-     * <p>\n-     * Requires that the values of the function at the endpoints have opposite\n-     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n-     * the case.</p>\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if min is not less than max or the\n-     * signs of the values of the function at the endpoints are not opposites\n-     */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max)\n-        throws MaxIterationsExceededException, MathUserException {\n-\n-        clearResult();\n-        verifyInterval(min, max);\n-\n-        double ret = Double.NaN;\n-\n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n-\n-        // Verify bracketing\n-        double sign = yMin * yMax;\n-        if (sign > 0) {\n-            // check if either value is close to a zero\n-            if (FastMath.abs(yMin) <= functionValueAccuracy) {\n-                setResult(min, 0);\n-                ret = min;\n-            } else if (FastMath.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n+            return brent(initial, max, yInitial, yMax);\n+        }\n+\n+        throw new NoBracketingException(min, max, yMin, yMax);\n+    }\n+\n+    /**\n+     * Search for a zero inside the provided interval.\n+     * This implemenation is based on the algorithm described at page 58 of\n+     * the book\n+     * <quote>\n+     *  <b>Algorithms for Minimization Without Derivatives</b>\n+     *  <it>Richard P. Brent</it>\n+     *  Dover 0-486-41998-3\n+     * </quote>\n+     *\n+     * @param lo Lower bound of the search interval.\n+     * @param hi Higher bound of the search interval.\n+     * @param fLo Function value at the lower bound of the search interval.\n+     * @param fHi Function value at the higher bound of the search interval.\n+     * @return the value where the function is zero.\n+     */\n+    private double brent(double lo, double hi,\n+                         double fLo, double fHi) {\n+        double a = lo;\n+        double fa = fLo;\n+        double b = hi;\n+        double fb = fHi;\n+        double c = a;\n+        double fc = fa;\n+        double d = b - a;\n+        double e = d;\n+\n+        final double t = getAbsoluteAccuracy();\n+        final double eps = getRelativeAccuracy();\n+\n+        while (true) {\n+            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n+                a = b;\n+                b = c;\n+                c = a;\n+                fa = fb;\n+                fb = fc;\n+                fc = fa;\n+            }\n+\n+            final double tol = 2 * eps * FastMath.abs(b) + t;\n+            final double m = 0.5 * (c - b);\n+\n+            if (FastMath.abs(m) <= tol ||\n+                MathUtils.equals(fb, 0))  {\n+                return b;\n+            }\n+            if (FastMath.abs(e) < tol ||\n+                FastMath.abs(fa) <= FastMath.abs(fb)) {\n+                // Force bisection.\n+                d = m;\n+                e = d;\n             } else {\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, yMin, yMax);\n-            }\n-        } else if (sign < 0){\n-            // solve using only the first endpoint as initial guess\n-            ret = solve(f, min, yMin, max, yMax, min, yMin);\n-        } else {\n-            // either min or max is a root\n-            if (yMin == 0.0) {\n-                ret = min;\n-            } else {\n-                ret = max;\n-            }\n-        }\n-\n-        return ret;\n-    }\n-\n-    /**\n-     * Find a zero starting search according to the three provided points.\n-     * @param f the function to solve\n-     * @param x0 old approximation for the root\n-     * @param y0 function value at the approximation for the root\n-     * @param x1 last calculated approximation for the root\n-     * @param y1 function value at the last calculated approximation\n-     * for the root\n-     * @param x2 bracket point (must be set to x0 if no bracket point is\n-     * known, this will force starting with linear interpolation)\n-     * @param y2 function value at the bracket point.\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n-     */\n-    private double solve(final UnivariateRealFunction f,\n-                         double x0, double y0,\n-                         double x1, double y1,\n-                         double x2, double y2)\n-    throws MaxIterationsExceededException, MathUserException {\n-\n-        double delta = x1 - x0;\n-        double oldDelta = delta;\n-\n-        int i = 0;\n-        while (i < maximalIterationCount) {\n-            if (FastMath.abs(y2) < FastMath.abs(y1)) {\n-                // use the bracket point if is better than last approximation\n-                x0 = x1;\n-                x1 = x2;\n-                x2 = x0;\n-                y0 = y1;\n-                y1 = y2;\n-                y2 = y0;\n-            }\n-            if (FastMath.abs(y1) <= functionValueAccuracy) {\n-                // Avoid division by very small values. Assume\n-                // the iteration has converged (the problem may\n-                // still be ill conditioned)\n-                setResult(x1, i);\n-                return result;\n-            }\n-            double dx = x2 - x1;\n-            double tolerance =\n-                FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy);\n-            if (FastMath.abs(dx) <= tolerance) {\n-                setResult(x1, i);\n-                return result;\n-            }\n-            if ((FastMath.abs(oldDelta) < tolerance) ||\n-                    (FastMath.abs(y0) <= FastMath.abs(y1))) {\n-                // Force bisection.\n-                delta = 0.5 * dx;\n-                oldDelta = delta;\n-            } else {\n-                double r3 = y1 / y0;\n+                double s = fb / fa;\n                 double p;\n-                double p1;\n-                // the equality test (x0 == x2) is intentional,\n-                // it is part of the original Brent's method,\n-                // it should NOT be replaced by proximity test\n-                if (x0 == x2) {\n+                double q;\n+                // The equality test (a == c) is intentional,\n+                // it is part of the original Brent's method and\n+                // it should NOT be replaced by proximity test.\n+                if (a == c) {\n                     // Linear interpolation.\n-                    p = dx * r3;\n-                    p1 = 1.0 - r3;\n+                    p = 2 * m * s;\n+                    q = 1 - s;\n                 } else {\n                     // Inverse quadratic interpolation.\n-                    double r1 = y0 / y2;\n-                    double r2 = y1 / y2;\n-                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n-                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+                    q = fa / fc;\n+                    final double r = fb / fc;\n+                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n+                    q = (q - 1) * (r - 1) * (s - 1);\n                 }\n-                if (p > 0.0) {\n-                    p1 = -p1;\n+                if (p > 0) {\n+                    q = -q;\n                 } else {\n                     p = -p;\n                 }\n-                if (2.0 * p >= 1.5 * dx * p1 - FastMath.abs(tolerance * p1) ||\n-                        p >= FastMath.abs(0.5 * oldDelta * p1)) {\n+                s = e;\n+                e = d;\n+                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n+                    p >= FastMath.abs(0.5 * s * q)) {\n                     // Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n-                    delta = 0.5 * dx;\n-                    oldDelta = delta;\n+                    d = m;\n+                    e = d;\n                 } else {\n-                    oldDelta = delta;\n-                    delta = p / p1;\n+                    d = p / q;\n                 }\n             }\n-            // Save old X1, Y1\n-            x0 = x1;\n-            y0 = y1;\n-            // Compute new X1, Y1\n-            if (FastMath.abs(delta) > tolerance) {\n-                x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n-                x1 = x1 + 0.5 * tolerance;\n-            } else if (dx <= 0.0) {\n-                x1 = x1 - 0.5 * tolerance;\n-            }\n-            y1 = f.value(x1);\n-            if ((y1 > 0) == (y2 > 0)) {\n-                x2 = x0;\n-                y2 = y0;\n-                delta = x1 - x0;\n-                oldDelta = delta;\n-            }\n-            i++;\n-        }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n+            a = b;\n+            fa = fb;\n+\n+            if (FastMath.abs(d) > tol) {\n+                b += d;\n+            } else if (m > 0) {\n+                b += tol;\n+            } else {\n+                b -= tol;\n+            }\n+            fb = computeObjectiveValue(b);\n+            if ((fb > 0 && fc > 0) ||\n+                (fb <= 0 && fc <= 0)) {\n+                c = a;\n+                fc = fa;\n+                d = b - a;\n+                e = d;\n+            }\n+        }\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/DifferentiableUnivariateRealSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) rootfinding algorithms.\n+ * Implementations will search for only one zero in the given interval.\n+ *\n+ * @version $Revision: 1034896 $ $Date: 2010-11-13 23:27:34 +0100 (Sat, 13 Nov 2010) $\n+ */\n+public interface DifferentiableUnivariateRealSolver\n+    extends BaseUnivariateRealSolver<DifferentiableUnivariateRealFunction> {}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.complex.Complex;\n-import org.apache.commons.math.exception.MathUserException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n  * Laguerre's Method</a> for root finding of real coefficient polynomials.\n- * For reference, see <b>A First Course in Numerical Analysis</b>,\n- * ISBN 048641454X, chapter 8.\n- * <p>\n+ * For reference, see\n+ * <quote>\n+ *  <b>A First Course in Numerical Analysis</b>\n+ *  ISBN 048641454X, chapter 8.\n+ * </quote>\n  * Laguerre's method is global in the sense that it can start with any initial\n- * approximation and be able to solve all roots from that point.</p>\n+ * approximation and be able to solve all roots from that point.\n+ * The algorithm requires a bracketing condition.\n  *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public class LaguerreSolver extends UnivariateRealSolverImpl {\n-\n+public class LaguerreSolver extends AbstractPolynomialSolver {\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+    /** Complex solver. */\n+    protected ComplexSolver complexSolver = new ComplexSolver();\n+\n+    /**\n+     * Construct a solver with default accuracies.\n+     */\n+    public LaguerreSolver() {\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n     /**\n      * Construct a solver.\n-     */\n-    public LaguerreSolver() {\n-        super(100, 1E-6);\n-    }\n-\n-    /**\n-     * Find a real root in the given interval with initial value.\n-     * <p>\n-     * Requires bracketing condition.</p>\n-     *\n-     * @param f function to solve (must be polynomial)\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws ConvergenceException, MathUserException {\n-\n-        // check for zeros before verifying bracketing\n-        if (f.value(min) == 0.0) {\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public LaguerreSolver(double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public LaguerreSolver(double relativeAccuracy,\n+                          double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param functionValueAccuracy Function value accuracy.\n+     */\n+    public LaguerreSolver(double relativeAccuracy,\n+                          double absoluteAccuracy,\n+                          double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double doSolve() {\n+        double min = getMin();\n+        double max = getMax();\n+        double initial = getStartValue();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        verifySequence(min, initial, max);\n+\n+        // Return the initial guess if it is good enough.\n+        double yInitial = computeObjectiveValue(initial);\n+        if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n+            return initial;\n+        }\n+\n+        // Return the first endpoint if it is good enough.\n+        double yMin = computeObjectiveValue(min);\n+        if (FastMath.abs(yMin) <= functionValueAccuracy) {\n             return min;\n         }\n-        if (f.value(max) == 0.0) {\n+\n+        // Reduce interval if min and initial bracket the root.\n+        if (yInitial * yMin < 0) {\n+            return laguerre(min, initial, yMin, yInitial);\n+        }\n+\n+        // Return the second endpoint if it is good enough.\n+        double yMax = computeObjectiveValue(max);\n+        if (FastMath.abs(yMax) <= functionValueAccuracy) {\n             return max;\n         }\n-        if (f.value(initial) == 0.0) {\n-            return initial;\n-        }\n-\n-        verifyBracketing(min, max, f);\n-        verifySequence(min, initial, max);\n-        if (isBracketing(min, initial, f)) {\n-            return solve(f, min, initial);\n-        } else {\n-            return solve(f, initial, max);\n-        }\n-\n+\n+        // Reduce interval if initial and max bracket the root.\n+        if (yInitial * yMax < 0) {\n+            return laguerre(initial, max, yInitial, yMax);\n+        }\n+\n+        throw new NoBracketingException(min, max, yMin, yMax);\n     }\n \n     /**\n      * Find a real root in the given interval.\n-     * <p>\n-     * Despite the bracketing condition, the root returned by solve(Complex[],\n-     * Complex) may not be a real zero inside [min, max]. For example,\n-     * p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try\n-     * another initial value, or, as we did here, call solveAll() to obtain\n-     * all roots and pick up the one that we're looking for.</p>\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max)\n-        throws ConvergenceException, MathUserException {\n-\n-        // check function type\n-        if (!(f instanceof PolynomialFunction)) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FUNCTION_NOT_POLYNOMIAL);\n-        }\n-\n-        // check for zeros before verifying bracketing\n-        if (f.value(min) == 0.0) { return min; }\n-        if (f.value(max) == 0.0) { return max; }\n-        verifyBracketing(min, max, f);\n-\n-        double coefficients[] = ((PolynomialFunction) f).getCoefficients();\n+     *\n+     * Despite the bracketing condition, the root returned by\n+     * {@link LaguerreSolver.ComplexSolver#solve(Complex[],Complex)} may\n+     * not be a real zero inside {@code [min, max]}.\n+     * For example, <code>p(x) = x<sup>3</sup> + 1,</code>\n+     * with {@code min = -2}, {@code max = 2}, {@code initial = 0}.\n+     * When it occurs, this code calls\n+     * {@link LaguerreSolver.ComplexSolver#solveAll(Complex[],Complex)}\n+     * in order to obtain all roots and picks up one real root.\n+     *\n+     * @param lo Lower bound of the search interval.\n+     * @param hi Higher bound of the search interval.\n+     * @param fLo Function value at the lower bound of the search interval.\n+     * @param fHi Function value at the higher bound of the search interval.\n+     * @return the point at which the function value is zero.\n+     */\n+    public double laguerre(double lo, double hi,\n+                           double fLo, double fHi) {\n+        double result = Double.NaN;\n+        double coefficients[] = getCoefficients();\n         Complex c[] = new Complex[coefficients.length];\n         for (int i = 0; i < coefficients.length; i++) {\n-            c[i] = new Complex(coefficients[i], 0.0);\n-        }\n-        Complex initial = new Complex(0.5 * (min + max), 0.0);\n-        Complex z = solve(c, initial);\n-        if (isRootOK(min, max, z)) {\n-            setResult(z.getReal(), iterationCount);\n-            return result;\n-        }\n-\n-        // solve all roots and select the one we're seeking\n-        Complex[] root = solveAll(c, initial);\n-        for (int i = 0; i < root.length; i++) {\n-            if (isRootOK(min, max, root[i])) {\n-                setResult(root[i].getReal(), iterationCount);\n-                return result;\n-            }\n-        }\n-\n-        // should never happen\n-        throw new ConvergenceException();\n-    }\n-\n-    /**\n-     * Returns true iff the given complex root is actually a real zero\n-     * in the given interval, within the solver tolerance level.\n-     *\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param z the complex root\n-     * @return true iff z is the sought-after real zero\n-     */\n-    protected boolean isRootOK(double min, double max, Complex z) {\n-        double tolerance = FastMath.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n-        return (isSequence(min, z.getReal(), max)) &&\n-               (FastMath.abs(z.getImaginary()) <= tolerance ||\n-                z.abs() <= functionValueAccuracy);\n-    }\n-\n-    /**\n-     * Find all complex roots for the polynomial with the given coefficients,\n-     * starting from the given initial value.\n-     *\n-     * @param coefficients the polynomial coefficients array\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] solveAll(double coefficients[], double initial) throws\n-        ConvergenceException, MathUserException {\n-\n-        Complex c[] = new Complex[coefficients.length];\n-        Complex z = new Complex(initial, 0.0);\n-        for (int i = 0; i < c.length; i++) {\n-            c[i] = new Complex(coefficients[i], 0.0);\n-        }\n-        return solveAll(c, z);\n-    }\n-\n-    /**\n-     * Find all complex roots for the polynomial with the given coefficients,\n-     * starting from the given initial value.\n-     *\n-     * @param coefficients the polynomial coefficients array\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n-        MaxIterationsExceededException, MathUserException {\n-\n-        int n = coefficients.length - 1;\n-        int iterationCount = 0;\n-        if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE, n);\n-        }\n-        Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n-        for (int i = 0; i <= n; i++) {\n-            c[i] = coefficients[i];\n-        }\n-\n-        // solve individual root successively\n-        Complex root[] = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            Complex subarray[] = new Complex[n-i+1];\n-            System.arraycopy(c, 0, subarray, 0, subarray.length);\n-            root[i] = solve(subarray, initial);\n-            // polynomial deflation using synthetic division\n-            Complex newc = c[n-i];\n-            Complex oldc = null;\n-            for (int j = n-i-1; j >= 0; j--) {\n-                oldc = c[j];\n-                c[j] = newc;\n-                newc = oldc.add(newc.multiply(root[i]));\n-            }\n-            iterationCount += this.iterationCount;\n-        }\n-\n-        resultComputed = true;\n-        this.iterationCount = iterationCount;\n-        return root;\n-    }\n-\n-    /**\n-     * Find a complex root for the polynomial with the given coefficients,\n-     * starting from the given initial value.\n-     *\n-     * @param coefficients the polynomial coefficients array\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex solve(Complex coefficients[], Complex initial) throws\n-        MaxIterationsExceededException, MathUserException {\n-\n-        int n = coefficients.length - 1;\n-        if (n < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE, n);\n-        }\n-        Complex N  = new Complex(n,     0.0);\n-        Complex N1 = new Complex(n - 1, 0.0);\n-\n-        int i = 1;\n-        Complex pv = null;\n-        Complex dv = null;\n-        Complex d2v = null;\n-        Complex G = null;\n-        Complex G2 = null;\n-        Complex H = null;\n-        Complex delta = null;\n-        Complex denominator = null;\n-        Complex z = initial;\n-        Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n-        while (i <= maximalIterationCount) {\n-            // Compute pv (polynomial value), dv (derivative value), and\n-            // d2v (second derivative value) simultaneously.\n-            pv = coefficients[n];\n-            dv = Complex.ZERO;\n-            d2v = Complex.ZERO;\n-            for (int j = n-1; j >= 0; j--) {\n-                d2v = dv.add(z.multiply(d2v));\n-                dv = pv.add(z.multiply(dv));\n-                pv = coefficients[j].add(z.multiply(pv));\n-            }\n-            d2v = d2v.multiply(new Complex(2.0, 0.0));\n-\n-            // check for convergence\n-            double tolerance = FastMath.max(relativeAccuracy * z.abs(),\n-                                        absoluteAccuracy);\n-            if ((z.subtract(oldz)).abs() <= tolerance) {\n-                resultComputed = true;\n-                iterationCount = i;\n-                return z;\n-            }\n-            if (pv.abs() <= functionValueAccuracy) {\n-                resultComputed = true;\n-                iterationCount = i;\n-                return z;\n-            }\n-\n-            // now pv != 0, calculate the new approximation\n-            G = dv.divide(pv);\n-            G2 = G.multiply(G);\n-            H = G2.subtract(d2v.divide(pv));\n-            delta = N1.multiply((N.multiply(H)).subtract(G2));\n-            // choose a denominator larger in magnitude\n-            Complex deltaSqrt = delta.sqrt();\n-            Complex dplus = G.add(deltaSqrt);\n-            Complex dminus = G.subtract(deltaSqrt);\n-            denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n-            // Perturb z if denominator is zero, for instance,\n-            // p(x) = x^3 + 1, z = 0.\n-            if (denominator.equals(new Complex(0.0, 0.0))) {\n-                z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));\n-                oldz = new Complex(Double.POSITIVE_INFINITY,\n-                                   Double.POSITIVE_INFINITY);\n-            } else {\n-                oldz = z;\n-                z = z.subtract(N.divide(denominator));\n-            }\n-            i++;\n-        }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n+            c[i] = new Complex(coefficients[i], 0);\n+        }\n+        Complex initial = new Complex(0.5 * (lo + hi), 0);\n+        Complex z = complexSolver.solve(c, initial);\n+        if (complexSolver.isRoot(lo, hi, z)) {\n+            return z.getReal();\n+        } else {\n+            double r = Double.NaN;\n+            // Solve all roots and select the one we are seeking.\n+            Complex[] root = complexSolver.solveAll(c, initial);\n+            for (int i = 0; i < root.length; i++) {\n+                if (complexSolver.isRoot(lo, hi, root[i])) {\n+                    r = root[i].getReal();\n+                    break;\n+                }\n+            }\n+            return r;\n+        }\n+    }\n+\n+    /**\n+     * Class for searching all (complex) roots.\n+     */\n+    private class ComplexSolver {\n+        /**\n+         * Check whether the given complex root is actually a real zero\n+         * in the given interval, within the solver tolerance level.\n+         *\n+         * @param min Lower bound for the interval.\n+         * @param max Upper bound for the interval.\n+         * @param z Complex root.\n+         * @return {@code true} if z is a real zero.\n+         */\n+        public boolean isRoot(double min, double max, Complex z) {\n+            double tolerance = FastMath.max(getRelativeAccuracy() * z.abs(), getAbsoluteAccuracy());\n+            return (isSequence(min, z.getReal(), max)) &&\n+                (FastMath.abs(z.getImaginary()) <= tolerance ||\n+                 z.abs() <= getFunctionValueAccuracy());\n+        }\n+\n+        /**\n+         * Find all complex roots for the polynomial with the given\n+         * coefficients, starting from the given initial value.\n+         *\n+         * @param coefficients Polynomial coefficients.\n+         * @param initial Start value.\n+         * @return the point at which the function value is zero.\n+         * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+         * if the maximum number of evaluations is exceeded.\n+         * @throws NullArgumentException if the {@code coefficients} is\n+         * {@code null}.\n+         * @throws NoDataException if the {@code coefficients} array is empty.\n+         */\n+        public Complex[] solveAll(double coefficients[], double initial) {\n+            if (coefficients == null) {\n+                throw new NullArgumentException();\n+            }\n+            Complex c[] = new Complex[coefficients.length];\n+            Complex z = new Complex(initial, 0);\n+            for (int i = 0; i < c.length; i++) {\n+                c[i] = new Complex(coefficients[i], 0);\n+            }\n+            return solveAll(c, z);\n+        }\n+\n+        /**\n+         * Find all complex roots for the polynomial with the given\n+         * coefficients, starting from the given initial value.\n+         *\n+         * @param coefficients Polynomial coefficients.\n+         * @param initial Start value.\n+         * @return the point at which the function value is zero.\n+         * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+         * if the maximum number of evaluations is exceeded.\n+         * @throws NullArgumentException if the {@code coefficients} is\n+         * {@code null}.\n+         * @throws NoDataException if the {@code coefficients} array is empty.\n+         */\n+        public Complex[] solveAll(Complex coefficients[], Complex initial) {\n+            if (coefficients == null) {\n+                throw new NullArgumentException();\n+            }\n+            int n = coefficients.length - 1;\n+            if (n == 0) {\n+                throw new NoDataException(LocalizedFormats.POLYNOMIAL);\n+            }\n+            // Coefficients for deflated polynomial.\n+            Complex c[] = new Complex[n + 1];\n+            for (int i = 0; i <= n; i++) {\n+                c[i] = coefficients[i];\n+            }\n+\n+            // Solve individual roots successively.\n+            Complex root[] = new Complex[n];\n+            for (int i = 0; i < n; i++) {\n+                Complex subarray[] = new Complex[n - i + 1];\n+                System.arraycopy(c, 0, subarray, 0, subarray.length);\n+                root[i] = solve(subarray, initial);\n+                // Polynomial deflation using synthetic division.\n+                Complex newc = c[n - i];\n+                Complex oldc = null;\n+                for (int j = n - i - 1; j >= 0; j--) {\n+                    oldc = c[j];\n+                    c[j] = newc;\n+                    newc = oldc.add(newc.multiply(root[i]));\n+                }\n+            }\n+\n+            return root;\n+        }\n+\n+        /**\n+         * Find a complex root for the polynomial with the given coefficients,\n+         * starting from the given initial value.\n+         *\n+         * @param coefficients Polynomial coefficients.\n+         * @param initial Start value.\n+         * @return the point at which the function value is zero.\n+         * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+         * if the maximum number of evaluations is exceeded.\n+         * @throws NullArgumentException if the {@code coefficients} is\n+         * {@code null}.\n+         * @throws NoDataException if the {@code coefficients} array is empty.\n+         */\n+        public Complex solve(Complex coefficients[], Complex initial) {\n+            if (coefficients == null) {\n+                throw new NullArgumentException();\n+            }\n+\n+            int n = coefficients.length - 1;\n+            if (n == 0) {\n+                throw new NoDataException(LocalizedFormats.POLYNOMIAL);\n+            }\n+\n+            final double absoluteAccuracy = getAbsoluteAccuracy();\n+            final double relativeAccuracy = getRelativeAccuracy();\n+            final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+            Complex N  = new Complex(n,     0.0);\n+            Complex N1 = new Complex(n - 1, 0.0);\n+\n+            Complex pv = null;\n+            Complex dv = null;\n+            Complex d2v = null;\n+            Complex G = null;\n+            Complex G2 = null;\n+            Complex H = null;\n+            Complex delta = null;\n+            Complex denominator = null;\n+            Complex z = initial;\n+            Complex oldz = new Complex(Double.POSITIVE_INFINITY,\n+                                       Double.POSITIVE_INFINITY);\n+            while (true) {\n+                // Compute pv (polynomial value), dv (derivative value), and\n+                // d2v (second derivative value) simultaneously.\n+                pv = coefficients[n];\n+                dv = Complex.ZERO;\n+                d2v = Complex.ZERO;\n+                for (int j = n-1; j >= 0; j--) {\n+                    d2v = dv.add(z.multiply(d2v));\n+                    dv = pv.add(z.multiply(dv));\n+                    pv = coefficients[j].add(z.multiply(pv));\n+                }\n+                d2v = d2v.multiply(new Complex(2.0, 0.0));\n+\n+                // check for convergence\n+                double tolerance = FastMath.max(relativeAccuracy * z.abs(),\n+                                                absoluteAccuracy);\n+                if ((z.subtract(oldz)).abs() <= tolerance) {\n+                    return z;\n+                }\n+                if (pv.abs() <= functionValueAccuracy) {\n+                    return z;\n+                }\n+\n+                // now pv != 0, calculate the new approximation\n+                G = dv.divide(pv);\n+                G2 = G.multiply(G);\n+                H = G2.subtract(d2v.divide(pv));\n+                delta = N1.multiply((N.multiply(H)).subtract(G2));\n+                // choose a denominator larger in magnitude\n+                Complex deltaSqrt = delta.sqrt();\n+                Complex dplus = G.add(deltaSqrt);\n+                Complex dminus = G.subtract(deltaSqrt);\n+                denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n+                // Perturb z if denominator is zero, for instance,\n+                // p(x) = x^3 + 1, z = 0.\n+                if (denominator.equals(new Complex(0.0, 0.0))) {\n+                    z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));\n+                    oldz = new Complex(Double.POSITIVE_INFINITY,\n+                                       Double.POSITIVE_INFINITY);\n+                } else {\n+                    oldz = z;\n+                    z = z.subtract(N.divide(denominator));\n+                }\n+                incrementEvaluationCount();\n+            }\n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n+ * This class implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n  * Muller's Method</a> for root finding of real univariate functions. For\n  * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,\n  * chapter 3.\n  * <p>\n  * Muller's method applies to both real and complex functions, but here we\n- * restrict ourselves to real functions. Methods solve() and solve2() find\n- * real zeros, using different ways to bypass complex arithmetics.</p>\n+ * restrict ourselves to real functions.\n+ * This class differs from {@link MullerSolver} in the way it avoids complex\n+ * operations.</p>\n+ * Muller's original method would have function evaluation at complex point.\n+ * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n+ * condition is one way to go: by requiring bracketing in every iteration,\n+ * the newly computed approximation is guaranteed to be real.</p>\n+ * <p>\n+ * Normally Muller's method converges quadratically in the vicinity of a\n+ * zero, however it may be very slow in regions far away from zeros. For\n+ * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n+ * bisection as a safety backup if it performs very poorly.</p>\n+ * <p>\n+ * The formulas here use divided differences directly.</p>\n  *\n  * @version $Revision$ $Date$\n  * @since 1.2\n+ * @see MullerSolver2\n  */\n-public class MullerSolver extends UnivariateRealSolverImpl {\n+public class MullerSolver extends AbstractUnivariateRealSolver {\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7694577816772532779L;\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n     /**\n-     * Construct a solver.\n+     * Construct a solver with default accuracies.\n      */\n     public MullerSolver() {\n-        super(100, 1E-6);\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public MullerSolver(double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public MullerSolver(double relativeAccuracy,\n+                        double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n     }\n \n     /**\n-     * Find a real root in the given interval with initial value.\n-     * <p>\n-     * Requires bracketing condition.</p>\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * {@inheritDoc}\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, MathUserException {\n+    @Override\n+    protected double doSolve() {\n+        final double min = getMin();\n+        final double max = getMax();\n+        final double initial = getStartValue();\n+\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        verifySequence(min, initial, max);\n \n         // check for zeros before verifying bracketing\n-        if (f.value(min) == 0.0) { return min; }\n-        if (f.value(max) == 0.0) { return max; }\n-        if (f.value(initial) == 0.0) { return initial; }\n+        final double fMin = computeObjectiveValue(min);\n+        if (FastMath.abs(fMin) < functionValueAccuracy) {\n+            return min;\n+        }\n+        final double fMax = computeObjectiveValue(max);\n+        if (FastMath.abs(fMax) < functionValueAccuracy) {\n+            return max;\n+        }\n+        final double fInitial = computeObjectiveValue(initial);\n+        if (FastMath.abs(fInitial) <  functionValueAccuracy) {\n+            return initial;\n+        }\n \n-        verifyBracketing(min, max, f);\n-        verifySequence(min, initial, max);\n-        if (isBracketing(min, initial, f)) {\n-            return solve(f, min, initial);\n+        verifyBracketing(min, max);\n+\n+        if (isBracketing(min, initial)) {\n+            return solve(min, initial, fMin, fInitial);\n         } else {\n-            return solve(f, initial, max);\n+            return solve(initial, max, fInitial, fMax);\n         }\n     }\n \n     /**\n      * Find a real root in the given interval.\n-     * <p>\n-     * Original Muller's method would have function evaluation at complex point.\n-     * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n-     * condition is one way to go: by requiring bracketing in every iteration,\n-     * the newly computed approximation is guaranteed to be real.</p>\n-     * <p>\n-     * Normally Muller's method converges quadratically in the vicinity of a\n-     * zero, however it may be very slow in regions far away from zeros. For\n-     * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n-     * bisection as a safety backup if it performs very poorly.</p>\n-     * <p>\n-     * The formulas here use divided differences directly.</p>\n      *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * @param min Lower bound for the interval.\n+     * @param max Upper bound for the interval.\n+     * @param fMin function value at the lower bound.\n+     * @param fMax function value at the upper bound.\n+     * @return the point at which the function value is zero.\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max)\n-        throws MaxIterationsExceededException, MathUserException {\n+    private double solve(double min, double max,\n+                         double fMin, double fMax) {\n+        final double relativeAccuracy = getRelativeAccuracy();\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n \n         // [x0, x2] is the bracketing interval in each iteration\n         // x1 is the last approximation and an interpolation point in (x0, x2)\n         // d01, d12, d012 are divided differences\n \n         double x0 = min;\n-        double y0 = f.value(x0);\n+        double y0 = fMin;\n         double x2 = max;\n-        double y2 = f.value(x2);\n+        double y2 = fMax;\n         double x1 = 0.5 * (x0 + x2);\n-        double y1 = f.value(x1);\n-\n-        // check for zeros before verifying bracketing\n-        if (y0 == 0.0) {\n-            return min;\n-        }\n-        if (y2 == 0.0) {\n-            return max;\n-        }\n-        verifyBracketing(min, max, f);\n+        double y1 = computeObjectiveValue(x1);\n \n         double oldx = Double.POSITIVE_INFINITY;\n-        for (int i = 1; i <= maximalIterationCount; ++i) {\n+        while (true) {\n             // Muller's method employs quadratic interpolation through\n             // x0, x1, x2 and x is the zero of the interpolating parabola.\n             // Due to bracketing condition, this parabola must have two\n             // xplus and xminus are two roots of parabola and at least\n             // one of them should lie in (x0, x2)\n             final double x = isSequence(x0, xplus, x2) ? xplus : xminus;\n-            final double y = f.value(x);\n+            final double y = computeObjectiveValue(x);\n \n             // check for convergence\n             final double tolerance = FastMath.max(relativeAccuracy * FastMath.abs(x), absoluteAccuracy);\n-            if (FastMath.abs(x - oldx) <= tolerance) {\n-                setResult(x, i);\n-                return result;\n-            }\n-            if (FastMath.abs(y) <= functionValueAccuracy) {\n-                setResult(x, i);\n-                return result;\n+            if (FastMath.abs(x - oldx) <= tolerance ||\n+                FastMath.abs(y) <= functionValueAccuracy) {\n+                return x;\n             }\n \n             // Bisect if convergence is too slow. Bisection would waste\n                 oldx = x;\n             } else {\n                 double xm = 0.5 * (x0 + x2);\n-                double ym = f.value(xm);\n+                double ym = computeObjectiveValue(xm);\n                 if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {\n                     x2 = xm; y2 = ym;\n                 } else {\n                     x0 = xm; y0 = ym;\n                 }\n                 x1 = 0.5 * (x0 + x2);\n-                y1 = f.value(x1);\n+                y1 = computeObjectiveValue(x1);\n                 oldx = Double.POSITIVE_INFINITY;\n             }\n         }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n-    }\n-\n-    /**\n-     * Find a real root in the given interval.\n-     * <p>\n-     * solve2() differs from solve() in the way it avoids complex operations.\n-     * Except for the initial [min, max], solve2() does not require bracketing\n-     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n-     * number arises in the computation, we simply use its modulus as real\n-     * approximation.</p>\n-     * <p>\n-     * Because the interval may not be bracketing, bisection alternative is\n-     * not applicable here. However in practice our treatment usually works\n-     * well, especially near real zeros where the imaginary part of complex\n-     * approximation is often negligible.</p>\n-     * <p>\n-     * The formulas here do not use divided differences directly.</p>\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve2(final UnivariateRealFunction f,\n-                         final double min, final double max)\n-        throws MaxIterationsExceededException, MathUserException {\n-\n-        // x2 is the last root approximation\n-        // x is the new approximation and new x2 for next round\n-        // x0 < x1 < x2 does not hold here\n-\n-        double x0 = min;\n-        double y0 = f.value(x0);\n-        double x1 = max;\n-        double y1 = f.value(x1);\n-        double x2 = 0.5 * (x0 + x1);\n-        double y2 = f.value(x2);\n-\n-        // check for zeros before verifying bracketing\n-        if (y0 == 0.0) { return min; }\n-        if (y1 == 0.0) { return max; }\n-        verifyBracketing(min, max, f);\n-\n-        double oldx = Double.POSITIVE_INFINITY;\n-        for (int i = 1; i <= maximalIterationCount; ++i) {\n-            // quadratic interpolation through x0, x1, x2\n-            final double q = (x2 - x1) / (x1 - x0);\n-            final double a = q * (y2 - (1 + q) * y1 + q * y0);\n-            final double b = (2 * q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n-            final double c = (1 + q) * y2;\n-            final double delta = b * b - 4 * a * c;\n-            double x;\n-            final double denominator;\n-            if (delta >= 0.0) {\n-                // choose a denominator larger in magnitude\n-                double dplus = b + FastMath.sqrt(delta);\n-                double dminus = b - FastMath.sqrt(delta);\n-                denominator = FastMath.abs(dplus) > FastMath.abs(dminus) ? dplus : dminus;\n-            } else {\n-                // take the modulus of (B +/- FastMath.sqrt(delta))\n-                denominator = FastMath.sqrt(b * b - delta);\n-            }\n-            if (denominator != 0) {\n-                x = x2 - 2.0 * c * (x2 - x1) / denominator;\n-                // perturb x if it exactly coincides with x1 or x2\n-                // the equality tests here are intentional\n-                while (x == x1 || x == x2) {\n-                    x += absoluteAccuracy;\n-                }\n-            } else {\n-                // extremely rare case, get a random number to skip it\n-                x = min + FastMath.random() * (max - min);\n-                oldx = Double.POSITIVE_INFINITY;\n-            }\n-            final double y = f.value(x);\n-\n-            // check for convergence\n-            final double tolerance = FastMath.max(relativeAccuracy * FastMath.abs(x), absoluteAccuracy);\n-            if (FastMath.abs(x - oldx) <= tolerance) {\n-                setResult(x, i);\n-                return result;\n-            }\n-            if (FastMath.abs(y) <= functionValueAccuracy) {\n-                setResult(x, i);\n-                return result;\n-            }\n-\n-            // prepare the next iteration\n-            x0 = x1;\n-            y0 = y1;\n-            x1 = x2;\n-            y1 = y2;\n-            x2 = x;\n-            y2 = y;\n-            oldx = x;\n-        }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * This class implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n+ * Muller's Method</a> for root finding of real univariate functions. For\n+ * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,\n+ * chapter 3.\n+ * <p>\n+ * Muller's method applies to both real and complex functions, but here we\n+ * restrict ourselves to real functions.<\n+ * This class differs from {@link MullerSolver} in the way it avoids complex\n+ * operations.</p>\n+ * Except for the initial [min, max], it does not require bracketing\n+ * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+ * number arises in the computation, we simply use its modulus as real\n+ * approximation.</p>\n+ * <p>\n+ * Because the interval may not be bracketing, bisection alternative is\n+ * not applicable here. However in practice our treatment usually works\n+ * well, especially near real zeroes where the imaginary part of complex\n+ * approximation is often negligible.</p>\n+ * <p>\n+ * The formulas here do not use divided differences directly.</p>\n+ *\n+ * @version $Revision: 1034896 $ $Date: 2010-11-13 23:27:34 +0100 (Sat, 13 Nov 2010) $\n+ * @since 1.2\n+ * @see MullerSolver\n+ */\n+public class MullerSolver2 extends AbstractUnivariateRealSolver {\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7694577816772532779L;\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n+    /**\n+     * Construct a solver with default accuracies.\n+     */\n+    public MullerSolver2() {\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public MullerSolver2(double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public MullerSolver2(double relativeAccuracy,\n+                        double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected double doSolve() {\n+        final double min = getMin();\n+        final double max = getMax();\n+\n+        verifyInterval(min, max);\n+\n+        final double relativeAccuracy = getRelativeAccuracy();\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        // x2 is the last root approximation\n+        // x is the new approximation and new x2 for next round\n+        // x0 < x1 < x2 does not hold here\n+\n+        double x0 = min;\n+        double y0 = computeObjectiveValue(x0);\n+        if (FastMath.abs(y0) < functionValueAccuracy) {\n+            return x0;\n+        }\n+        double x1 = max;\n+        double y1 = computeObjectiveValue(x1);\n+        if (FastMath.abs(y1) < functionValueAccuracy) {\n+            return x1;\n+        }\n+\n+        if(y0 * y1 > 0) {\n+            throw new NoBracketingException(x0, x1, y0, y1);\n+        }\n+\n+        double x2 = 0.5 * (x0 + x1);\n+        double y2 = computeObjectiveValue(x2);\n+\n+        double oldx = Double.POSITIVE_INFINITY;\n+        while (true) {\n+            // quadratic interpolation through x0, x1, x2\n+            final double q = (x2 - x1) / (x1 - x0);\n+            final double a = q * (y2 - (1 + q) * y1 + q * y0);\n+            final double b = (2 * q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n+            final double c = (1 + q) * y2;\n+            final double delta = b * b - 4 * a * c;\n+            double x;\n+            final double denominator;\n+            if (delta >= 0.0) {\n+                // choose a denominator larger in magnitude\n+                double dplus = b + FastMath.sqrt(delta);\n+                double dminus = b - FastMath.sqrt(delta);\n+                denominator = FastMath.abs(dplus) > FastMath.abs(dminus) ? dplus : dminus;\n+            } else {\n+                // take the modulus of (B +/- FastMath.sqrt(delta))\n+                denominator = FastMath.sqrt(b * b - delta);\n+            }\n+            if (denominator != 0) {\n+                x = x2 - 2.0 * c * (x2 - x1) / denominator;\n+                // perturb x if it exactly coincides with x1 or x2\n+                // the equality tests here are intentional\n+                while (x == x1 || x == x2) {\n+                    x += absoluteAccuracy;\n+                }\n+            } else {\n+                // extremely rare case, get a random number to skip it\n+                x = min + FastMath.random() * (max - min);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            final double y = computeObjectiveValue(x);\n+\n+            // check for convergence\n+            final double tolerance = FastMath.max(relativeAccuracy * FastMath.abs(x), absoluteAccuracy);\n+            if (FastMath.abs(x - oldx) <= tolerance ||\n+                FastMath.abs(y) <= functionValueAccuracy) {\n+                return x;\n+            }\n+\n+            // prepare the next iteration\n+            x0 = x1;\n+            y0 = y1;\n+            x1 = x2;\n+            y1 = y2;\n+            x2 = x;\n+            y2 = y;\n+            oldx = x;\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  *\n  * @version $Revision$ $Date$\n  */\n-public class NewtonSolver extends UnivariateRealSolverImpl {\n+public class NewtonSolver extends AbstractDifferentiableUnivariateRealSolver {\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n     /**\n      * Construct a solver.\n      */\n     public NewtonSolver() {\n-        super(100, 1E-6);\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public NewtonSolver(double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n     }\n \n     /**\n-     * Find a zero near the midpoint of <code>min</code> and <code>max</code>.\n+     * Find a zero near the midpoint of {@code min} and {@code max}.\n      *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function or derivative\n-     * @throws IllegalArgumentException if min is not less than max\n+     * @param f Function to solve.\n+     * @param min Lower bound for the interval?\n+     * @param max Upper bound for the interval.\n+     * @return the value where the function is zero.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximum evaluation count is exceeded.\n+     * @throws IllegalArgumentException if {@code min >= max}.\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max)\n-        throws MaxIterationsExceededException, MathUserException  {\n-        return solve(f, min, max, UnivariateRealSolverUtils.midpoint(min, max));\n+    public double solve(final DifferentiableUnivariateRealFunction f,\n+                        final double min, final double max) {\n+        return super.solve(f, UnivariateRealSolverUtils.midpoint(min, max));\n     }\n \n     /**\n-     * Find a zero near the value <code>startValue</code>.\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval (ignored).\n-     * @param max the upper bound for the interval (ignored).\n-     * @param startValue the start value to use.\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function or derivative\n-     * @throws IllegalArgumentException if startValue is not between min and max or\n-     * if function is not a {@link DifferentiableUnivariateRealFunction} instance\n+     * {@inheritDoc}\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double startValue)\n-        throws MaxIterationsExceededException, MathUserException {\n+    @Override\n+    protected double doSolve() {\n+        final double startValue = getStartValue();\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n \n-        try {\n-\n-            final UnivariateRealFunction derivative =\n-                ((DifferentiableUnivariateRealFunction) f).derivative();\n-            clearResult();\n-            verifySequence(min, startValue, max);\n-\n-            double x0 = startValue;\n-            double x1;\n-\n-            int i = 0;\n-            while (i < maximalIterationCount) {\n-\n-                x1 = x0 - (f.value(x0) / derivative.value(x0));\n-                if (FastMath.abs(x1 - x0) <= absoluteAccuracy) {\n-                    setResult(x1, i);\n-                    return x1;\n-                }\n-\n-                x0 = x1;\n-                ++i;\n+        double x0 = startValue;\n+        double x1;\n+        while (true) {\n+            x1 = x0 - (computeObjectiveValue(x0) / computeDerivativeObjectiveValue(x0));\n+            if (FastMath.abs(x1 - x0) <= absoluteAccuracy) {\n+                return x1;\n             }\n \n-            throw new MaxIterationsExceededException(maximalIterationCount);\n-        } catch (ClassCastException cce) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FUNCTION_NOT_DIFFERENTIABLE);\n+            x0 = x1;\n         }\n     }\n-\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/PolynomialSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+\n+/**\n+ * Interface for (polynomial) root-finding algorithms.\n+ * Implementations will search for only one zero in the given interval.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public interface PolynomialSolver\n+    extends BaseUnivariateRealSolver<PolynomialFunction> {}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public class RiddersSolver extends UnivariateRealSolverImpl {\n+public class RiddersSolver extends AbstractUnivariateRealSolver {\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n     /**\n-     * Construct a solver.\n+     * Construct a solver with default accuracy.\n      */\n     public RiddersSolver() {\n-        super(100, 1E-6);\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public RiddersSolver(double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public RiddersSolver(double relativeAccuracy,\n+                         double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n     }\n \n     /**\n-     * Find a root in the given interval with initial value.\n-     * <p>\n-     * Requires bracketing condition.</p>\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * {@inheritDoc}\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, MathUserException {\n-\n-        // check for zeros before verifying bracketing\n-        if (f.value(min) == 0.0) { return min; }\n-        if (f.value(max) == 0.0) { return max; }\n-        if (f.value(initial) == 0.0) { return initial; }\n-\n-        verifyBracketing(min, max, f);\n-        verifySequence(min, initial, max);\n-        if (isBracketing(min, initial, f)) {\n-            return solve(f, min, initial);\n-        } else {\n-            return solve(f, initial, max);\n-        }\n-    }\n-\n-    /**\n-     * Find a root in the given interval.\n-     * <p>\n-     * Requires bracketing condition.</p>\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max)\n-        throws MaxIterationsExceededException, MathUserException {\n-\n+    @Override\n+    protected double doSolve() {\n+        double min = getMin();\n+        double max = getMax();\n         // [x1, x2] is the bracketing interval in each iteration\n         // x3 is the midpoint of [x1, x2]\n         // x is the new root approximation and an endpoint of the new interval\n         double x1 = min;\n-        double y1 = f.value(x1);\n+        double y1 = computeObjectiveValue(x1);\n         double x2 = max;\n-        double y2 = f.value(x2);\n+        double y2 = computeObjectiveValue(x2);\n \n         // check for zeros before verifying bracketing\n-        if (y1 == 0.0) {\n+        if (y1 == 0) {\n             return min;\n         }\n-        if (y2 == 0.0) {\n+        if (y2 == 0) {\n             return max;\n         }\n-        verifyBracketing(min, max, f);\n+        verifyBracketing(min, max);\n \n-        int i = 1;\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+        final double relativeAccuracy = getRelativeAccuracy();\n+\n         double oldx = Double.POSITIVE_INFINITY;\n-        while (i <= maximalIterationCount) {\n+        while (true) {\n             // calculate the new root approximation\n             final double x3 = 0.5 * (x1 + x2);\n-            final double y3 = f.value(x3);\n+            final double y3 = computeObjectiveValue(x3);\n             if (FastMath.abs(y3) <= functionValueAccuracy) {\n-                setResult(x3, i);\n-                return result;\n+                return x3;\n             }\n             final double delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n             final double correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n                                       (x3 - x1) / FastMath.sqrt(delta);\n             final double x = x3 - correction;                // correction != 0\n-            final double y = f.value(x);\n+            final double y = computeObjectiveValue(x);\n \n             // check for convergence\n             final double tolerance = FastMath.max(relativeAccuracy * FastMath.abs(x), absoluteAccuracy);\n             if (FastMath.abs(x - oldx) <= tolerance) {\n-                setResult(x, i);\n-                return result;\n+                return x;\n             }\n             if (FastMath.abs(y) <= functionValueAccuracy) {\n-                setResult(x, i);\n-                return result;\n+                return x;\n             }\n \n             // prepare the new interval for next iteration\n                 }\n             }\n             oldx = x;\n-            i++;\n         }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n-import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n \n \n  *\n  * @version $Revision$ $Date$\n  */\n-public class SecantSolver extends UnivariateRealSolverImpl {\n+public class SecantSolver extends AbstractUnivariateRealSolver {\n+    /** Default absolute accuracy. */\n+    public static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n     /**\n-     * Construct a solver.\n+     * Construct a solver with default accuracy.\n      */\n     public SecantSolver() {\n-        super(100, 1E-6);\n+        this(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public SecantSolver(double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     */\n+    public SecantSolver(double relativeAccuracy,\n+                        double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n     }\n \n     /**\n-     * Find a zero in the given interval.\n-     *\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param initial the start value to use (ignored)\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if min is not less than max or the\n-     * signs of the values of the function at the endpoints are not opposites\n+     * {@inheritDoc}\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, MathUserException {\n-        return solve(f, min, max);\n-    }\n+    @Override\n+    protected double doSolve() {\n+        double min = getMin();\n+        double max = getMax();\n+        verifyInterval(min, max);\n \n-    /**\n-     * Find a zero in the given interval.\n-     * @param f the function to solve\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if min is not less than max or the\n-     * signs of the values of the function at the endpoints are not opposites\n-     */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max)\n-        throws MaxIterationsExceededException, MathUserException {\n-\n-        clearResult();\n-        verifyInterval(min, max);\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n \n         // Index 0 is the old approximation for the root.\n         // Index 1 is the last calculated approximation  for the root.\n         // iteration.\n         double x0 = min;\n         double x1 = max;\n-        double y0 = f.value(x0);\n-        double y1 = f.value(x1);\n+\n+        double y0 = computeObjectiveValue(x0);\n+        // return the first endpoint if it is good enough\n+        if (FastMath.abs(y0) <= functionValueAccuracy) {\n+            return x0;\n+        }\n+\n+        // return the second endpoint if it is good enough\n+        double y1 = computeObjectiveValue(x1);\n+        if (FastMath.abs(y1) <= functionValueAccuracy) {\n+            return x1;\n+        }\n \n         // Verify bracketing\n         if (y0 * y1 >= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, min, max, y0, y1);\n+            throw new NoBracketingException(min, max, y0, y1);\n         }\n+\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double relativeAccuracy = getRelativeAccuracy();\n \n         double x2 = x0;\n         double y2 = y0;\n         double oldDelta = x2 - x1;\n-        int i = 0;\n-        while (i < maximalIterationCount) {\n+        while (true) {\n             if (FastMath.abs(y2) < FastMath.abs(y1)) {\n                 x0 = x1;\n                 x1 = x2;\n                 y2 = y0;\n             }\n             if (FastMath.abs(y1) <= functionValueAccuracy) {\n-                setResult(x1, i);\n-                return result;\n+                return x1;\n             }\n-            if (FastMath.abs(oldDelta) <\n-                FastMath.max(relativeAccuracy * FastMath.abs(x1), absoluteAccuracy)) {\n-                setResult(x1, i);\n-                return result;\n+            if (FastMath.abs(oldDelta) < FastMath.max(relativeAccuracy * FastMath.abs(x1),\n+                                                      absoluteAccuracy)) {\n+                return x1;\n             }\n             double delta;\n             if (FastMath.abs(y1) > FastMath.abs(y0)) {\n             x0 = x1;\n             y0 = y1;\n             x1 = x1 + delta;\n-            y1 = f.value(x1);\n+            y1 = computeObjectiveValue(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n                 // New bracket is (x0,x1).\n                 x2 = x0;\n                 y2 = y0;\n             }\n             oldDelta = x2 - x1;\n-            i++;\n         }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.ConvergingAlgorithm;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n \n /**\n- * Interface for (univariate real) rootfinding algorithms.\n- * <p>\n- * Implementations will search for only one zero in the given interval.</p>\n+ * Interface for (univariate real) root-finding algorithms.\n+ * Implementations will search for only one zero in the given interval.\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface UnivariateRealSolver extends ConvergingAlgorithm {\n-\n-    /**\n-     * Set the function value accuracy.\n-     * <p>\n-     * This is used to determine when an evaluated function value or some other\n-     * value which is used as divisor is zero.</p>\n-     * <p>\n-     * This is a safety guard and it shouldn't be necessary to change this in\n-     * general.</p>\n-     *\n-     * @param accuracy the accuracy.\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the solver or is otherwise deemed unreasonable.\n-     */\n-    void setFunctionValueAccuracy(double accuracy);\n-\n-    /**\n-     * Get the actual function value accuracy.\n-     * @return the accuracy\n-     */\n-    double getFunctionValueAccuracy();\n-\n-    /**\n-     * Reset the actual function accuracy to the default.\n-     * The default value is provided by the solver implementation.\n-     */\n-    void resetFunctionValueAccuracy();\n-\n-    /**\n-     * Solve for a zero root in the given interval.\n-     * <p>A solver may require that the interval brackets a single zero root.\n-     * Solvers that do require bracketing should be able to handle the case\n-     * where one of the endpoints is itself a root.</p>\n-     *\n-     * @param f the function to solve.\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @return a value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise.\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if min > max or the endpoints do not\n-     * satisfy the requirements specified by the solver\n-     * @since 2.0\n-     */\n-    double solve(UnivariateRealFunction f, double min, double max)\n-        throws ConvergenceException, MathUserException;\n-\n-    /**\n-     * Solve for a zero in the given interval, start at startValue.\n-     * <p>A solver may require that the interval brackets a single zero root.\n-     * Solvers that do require bracketing should be able to handle the case\n-     * where one of the endpoints is itself a root.</p>\n-     *\n-     * @param f the function to solve.\n-     * @param min the lower bound for the interval.\n-     * @param max the upper bound for the interval.\n-     * @param startValue the start value to use\n-     * @return a value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise.\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if min > max or the arguments do not\n-     * satisfy the requirements specified by the solver\n-     * @since 2.0\n-     */\n-    double solve(UnivariateRealFunction f, double min, double max, double startValue)\n-        throws ConvergenceException, MathUserException, IllegalArgumentException;\n-\n-    /**\n-     * Get the result of the last run of the solver.\n-     *\n-     * @return the last result.\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed.\n-     */\n-    double getResult();\n-\n-    /**\n-     * Get the result of the last run of the solver.\n-     *\n-     * @return the value of the function at the last result.\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed.\n-     */\n-    double getFunctionValue();\n-}\n+public interface UnivariateRealSolver\n+    extends BaseUnivariateRealSolver<UnivariateRealFunction> {}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.exception.NullArgumentException;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n  * solvers.\n  *\n  * @version $Revision$ $Date$\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link AbstractUnivariateRealSolver} instead.\n  */\n-public abstract class UnivariateRealSolverImpl\n-    extends ConvergingAlgorithmImpl implements UnivariateRealSolver {\n+@Deprecated\n+public abstract class UnivariateRealSolverImpl extends ConvergingAlgorithmImpl {\n \n     /** Maximum error of function. */\n     protected double functionValueAccuracy;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @version $Revision$ $Date$\n  */\n public class UnivariateRealSolverUtils {\n-\n-    /**\n-     * Default constructor.\n-     */\n-    private UnivariateRealSolverUtils() {\n-        super();\n-    }\n+    /**\n+     * Class contains only static methods.\n+     */\n+    private UnivariateRealSolverUtils() {}\n \n     /**\n      * Convenience method to find a zero of a univariate real function.  A default\n      * solver is used.\n      *\n-     * @param f the function.\n-     * @param x0 the lower bound for the interval.\n-     * @param x1 the upper bound for the interval.\n+     * @param function Function.\n+     * @param x0 Lower bound for the interval.\n+     * @param x1 Upper bound for the interval.\n      * @return a value where the function is zero.\n-     * @throws ConvergenceException if the iteration count was exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n      * @throws IllegalArgumentException if f is null or the endpoints do not\n-     * specify a valid interval\n-     */\n-    public static double solve(UnivariateRealFunction f, double x0, double x1)\n-    throws ConvergenceException, MathUserException {\n-        setup(f);\n-        return LazyHolder.FACTORY.newDefaultSolver().solve(f, x0, x1);\n+     * specify a valid interval.\n+     */\n+    public static double solve(UnivariateRealFunction function, double x0, double x1) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        final UnivariateRealSolver solver = new BrentSolver();\n+        solver.setMaxEvaluations(Integer.MAX_VALUE);\n+        return solver.solve(function, x0, x1);\n     }\n \n     /**\n      * Convenience method to find a zero of a univariate real function.  A default\n      * solver is used.\n      *\n-     * @param f the function\n-     * @param x0 the lower bound for the interval\n-     * @param x1 the upper bound for the interval\n-     * @param absoluteAccuracy the accuracy to be used by the solver\n-     * @return a value where the function is zero\n-     * @throws ConvergenceException if the iteration count is exceeded\n-     * @throws MathUserException if an error occurs evaluating the function\n-     * @throws IllegalArgumentException if f is null, the endpoints do not\n-     * specify a valid interval, or the absoluteAccuracy is not valid for the\n-     * default solver\n-     */\n-    public static double solve(UnivariateRealFunction f, double x0, double x1,\n-            double absoluteAccuracy) throws ConvergenceException,\n-            MathUserException {\n-\n-        setup(f);\n-        UnivariateRealSolver solver = LazyHolder.FACTORY.newDefaultSolver();\n-        solver.setAbsoluteAccuracy(absoluteAccuracy);\n-        return solver.solve(f, x0, x1);\n+     * @param function Function.\n+     * @param x0 Lower bound for the interval.\n+     * @param x1 Upper bound for the interval.\n+     * @param absoluteAccuracy Accuracy to be used by the solver.\n+     * @return a value where the function is zero.\n+     * @throws IllegalArgumentException if {@code function} is {@code null},\n+     * the endpoints do not specify a valid interval, or the absolute accuracy\n+     * is not valid for the default solver.\n+     */\n+    public static double solve(UnivariateRealFunction function,\n+                               double x0, double x1,\n+                               double absoluteAccuracy) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        final UnivariateRealSolver solver = new BrentSolver(absoluteAccuracy);\n+        solver.setMaxEvaluations(Integer.MAX_VALUE);\n+        return solver.solve(function, x0, x1);\n     }\n \n     /**\n      * {@link #bracket(UnivariateRealFunction, double, double, double, int)},\n      * explicitly specifying the maximum number of iterations.</p>\n      *\n-     * @param function the function\n-     * @param initial initial midpoint of interval being expanded to\n-     * bracket a root\n-     * @param lowerBound lower bound (a is never lower than this value)\n-     * @param upperBound upper bound (b never is greater than this\n-     * value)\n-     * @return a two element array holding {a, b}\n-     * @throws ConvergenceException if a root can not be bracketted\n-     * @throws MathUserException if an error occurs evaluating the function\n+     * @param function Function.\n+     * @param initial Initial midpoint of interval being expanded to\n+     * bracket a root.\n+     * @param lowerBound Lower bound (a is never lower than this value)\n+     * @param upperBound Upper bound (b never is greater than this\n+     * value).\n+     * @return a two-element array holding a and b.\n+     * @throws NoBracketingException if a root cannot be bracketted.\n      * @throws IllegalArgumentException if function is null, maximumIterations\n-     * is not positive, or initial is not between lowerBound and upperBound\n+     * is not positive, or initial is not between lowerBound and upperBound.\n      */\n     public static double[] bracket(UnivariateRealFunction function,\n-            double initial, double lowerBound, double upperBound)\n-    throws ConvergenceException, MathUserException {\n-        return bracket( function, initial, lowerBound, upperBound,\n-            Integer.MAX_VALUE ) ;\n+                                   double initial,\n+                                   double lowerBound, double upperBound) {\n+        return bracket(function, initial, lowerBound, upperBound, Integer.MAX_VALUE);\n     }\n \n      /**\n      * <li> <code> maximumIterations</code> iterations elapse\n      * -- ConvergenceException </li></ul></p>\n      *\n-     * @param function the function\n-     * @param initial initial midpoint of interval being expanded to\n-     * bracket a root\n-     * @param lowerBound lower bound (a is never lower than this value)\n-     * @param upperBound upper bound (b never is greater than this\n-     * value)\n-     * @param maximumIterations maximum number of iterations to perform\n-     * @return a two element array holding {a, b}.\n-     * @throws ConvergenceException if the algorithm fails to find a and b\n-     * satisfying the desired conditions\n-     * @throws MathUserException if an error occurs evaluating the function\n+     * @param function Function.\n+     * @param initial Initial midpoint of interval being expanded to\n+     * bracket a root.\n+     * @param lowerBound Lower bound (a is never lower than this value).\n+     * @param upperBound Upper bound (b never is greater than this\n+     * value).\n+     * @param maximumIterations Maximum number of iterations to perform\n+     * @return a two element array holding a and b.\n+     * @throws NoBracketingException if the algorithm fails to find a and b\n+     * satisfying the desired conditions.\n      * @throws IllegalArgumentException if function is null, maximumIterations\n-     * is not positive, or initial is not between lowerBound and upperBound\n+     * is not positive, or initial is not between lowerBound and upperBound.\n      */\n     public static double[] bracket(UnivariateRealFunction function,\n-            double initial, double lowerBound, double upperBound,\n-            int maximumIterations) throws ConvergenceException,\n-            MathUserException {\n-\n+                                   double initial,\n+                                   double lowerBound, double upperBound,\n+                                   int maximumIterations)  {\n         if (function == null) {\n             throw new NullArgumentException(LocalizedFormats.FUNCTION);\n         }\n         if (maximumIterations <= 0)  {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n-        }\n-        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INVALID_BRACKETING_PARAMETERS,\n-                  lowerBound, initial, upperBound);\n-        }\n+            throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n+        }\n+        verifySequence(lowerBound, initial, upperBound);\n+\n         double a = initial;\n         double b = initial;\n         double fa;\n         double fb;\n-        int numIterations = 0 ;\n+        int numIterations = 0;\n \n         do {\n             a = FastMath.max(a - 1.0, lowerBound);\n             fa = function.value(a);\n \n             fb = function.value(b);\n-            numIterations++ ;\n+            ++numIterations;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&\n                 ((a > lowerBound) || (b < upperBound)));\n \n-        if (fa * fb > 0.0 ) {\n-            throw new ConvergenceException(\n-                      LocalizedFormats.FAILED_BRACKETING,\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n-        }\n-\n-        return new double[]{a, b};\n+        if (fa * fb > 0.0) {\n+            throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING,\n+                                            a, b, fa, fb,\n+                                            numIterations, maximumIterations, initial,\n+                                            lowerBound, upperBound);\n+        }\n+\n+        return new double[] {a, b};\n     }\n \n     /**\n      * @return the midpoint.\n      */\n     public static double midpoint(double a, double b) {\n-        return (a + b) * .5;\n-    }\n-\n-    /**\n-     * Checks to see if f is null, throwing IllegalArgumentException if so.\n-     * @param f  input function\n-     * @throws IllegalArgumentException if f is null\n-     */\n-    private static void setup(UnivariateRealFunction f) {\n-        if (f == null) {\n-            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n-        }\n-    }\n-\n-    // CHECKSTYLE: stop HideUtilityClassConstructor\n-    /** Holder for the factory.\n-     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n-     */\n-    private static class LazyHolder {\n-        /** Cached solver factory */\n-        private static final UnivariateRealSolverFactory FACTORY = UnivariateRealSolverFactory.newInstance();\n-    }\n-    // CHECKSTYLE: resume HideUtilityClassConstructor\n-\n+        return (a + b) * 0.5;\n+    }\n+\n+    /**\n+     * Check whether the function takes opposite signs at the endpoints.\n+     *\n+     * @param function Function.\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @return {@code true} if the function values have opposite signs at the\n+     * given points.\n+     */\n+    public static boolean isBracketing(UnivariateRealFunction function,\n+                                       final double lower,\n+                                       final double upper) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        final double fLo = function.value(lower);\n+        final double fHi = function.value(upper);\n+        return (fLo > 0 && fHi < 0) || (fLo < 0 && fHi > 0);\n+    }\n+\n+    /**\n+     * Check whether the arguments form a (strictly) increasing sequence.\n+     *\n+     * @param start First number.\n+     * @param mid Second number.\n+     * @param end Third number.\n+     * @return {@code true} if the arguments form an increasing sequence.\n+     */\n+    public static boolean isSequence(final double start,\n+                                     final double mid,\n+                                     final double end) {\n+        return (start < mid) && (mid < end);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     */\n+    public static void verifyInterval(final double lower,\n+                                      final double upper) {\n+        if (lower >= upper) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n+                                                lower, upper, false);\n+        }\n+    }\n+\n+    /**\n+     * Check that {@code lower < initial < upper}.\n+     *\n+     * @param lower Lower endpoint.\n+     * @param initial Initial value.\n+     * @param upper Upper endpoint.\n+     * @throws NumberIsTooLargeException if {@code lower >= initial} or\n+     * {@code initial >= upper}.\n+     */\n+    public static void verifySequence(final double lower,\n+                                      final double initial,\n+                                      final double upper) {\n+        verifyInterval(lower, initial);\n+        verifyInterval(initial, upper);\n+    }\n+\n+    /**\n+     * Check that the endpoints specify an interval and the function takes\n+     * opposite signs at the endpoints.\n+     *\n+     * @param function Function.\n+     * @param lower Lower endpoint.\n+     * @param upper Upper endpoint.\n+     * @throws NoBracketingException if function has the same sign at the\n+     * endpoints.\n+     */\n+    public static void verifyBracketing(UnivariateRealFunction function,\n+                                        final double lower,\n+                                        final double upper) {\n+        if (function == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        verifyInterval(lower, upper);\n+        if (!isBracketing(function, lower, upper)) {\n+            throw new NoBracketingException(lower, upper,\n+                                            function.value(lower),\n+                                            function.value(upper));\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.random.RandomDataImpl;\n import org.apache.commons.math.util.FastMath;\n \n             bracket = UnivariateRealSolverUtils.bracket(\n                     rootFindingFunction, getInitialDomain(p),\n                     lowerBound, upperBound);\n-        } catch (ConvergenceException ex) {\n+        } catch (NumberIsTooLargeException ex) {\n             /*\n              * Check domain endpoints to see if one gives value that is within\n              * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NoBracketingException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when function values have the same sign at both\n+ * ends of an interval.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NoBracketingException extends MathIllegalArgumentException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -3629324471511904459L;\n+    /** Lower end of the interval. */\n+    private final double lo;\n+    /** Higher end of the interval. */\n+    private final double hi;\n+    /** Value at lower end of the interval. */\n+    private final double fLo;\n+    /** Value at higher end of the interval. */\n+    private final double fHi;\n+\n+    /**\n+     * Construct the exception.\n+     *\n+     * @param lo Lower end of the interval.\n+     * @param hi Higher end of the interval.\n+     * @param fLo Value at lower end of the interval.\n+     * @param fHi Value at higher end of the interval.\n+     */\n+    public NoBracketingException(double lo, double hi,\n+                                 double fLo, double fHi) {\n+        this(null, lo, hi, fLo, fHi);\n+    }\n+    /**\n+     * Construct the exception with a specific context.\n+     *\n+     * @param specific Contextual information on what caused the exception.\n+     * @param lo Lower end of the interval.\n+     * @param hi Higher end of the interval.\n+     * @param fLo Value at lower end of the interval.\n+     * @param fHi Value at higher end of the interval.\n+     */\n+    public NoBracketingException(Localizable specific,\n+                                 double lo, double hi,\n+                                 double fLo, double fHi) {\n+        super(specific, LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, lo, hi, fLo, fHi);\n+        this.lo = lo;\n+        this.hi = hi;\n+        this.fLo = fLo;\n+        this.fHi = fHi;\n+    }\n+    /**\n+     * Construct the exception with a specific context.\n+     *\n+     * @param specific Contextual information on what caused the exception.\n+     * @param lo Lower end of the interval.\n+     * @param hi Higher end of the interval.\n+     * @param fLo Value at lower end of the interval.\n+     * @param fHi Value at higher end of the interval.\n+     * @param args Additional arguments.\n+     */\n+    public NoBracketingException(Localizable specific,\n+                                 double lo, double hi,\n+                                 double fLo, double fHi,\n+                                 Object ... args) {\n+        super(specific, LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, lo, hi, fLo, fHi, args);\n+        this.lo = lo;\n+        this.hi = hi;\n+        this.fLo = fLo;\n+        this.fHi = fHi;\n+    }\n+\n+    /**\n+     * Get the lower end of the interval.\n+     *\n+     * @return the lower end.\n+     */\n+    public double getLo() {\n+        return lo;\n+    }\n+    /**\n+     * Get the higher end of the interval.\n+     *\n+     * @return the higher end.\n+     */\n+    public double getHi() {\n+        return hi;\n+    }\n+    /**\n+     * Get the value at the lower end of the interval.\n+     *\n+     * @return the value at the lower end.\n+     */\n+    public double getFLo() {\n+        return fLo;\n+    }\n+    /**\n+     * Get the value at the higher end of the interval.\n+     *\n+     * @return the value at the higher end.\n+     */\n+    public double getFHi() {\n+        return fHi;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     EVALUATION(\"evaluation\"), /* keep */\n     EXPANSION_FACTOR_SMALLER_THAN_ONE(\"expansion factor smaller than one ({0})\"),\n     FACTORIAL_NEGATIVE_PARAMETER(\"must have n >= 0 for n!, got n = {0}\"),\n-    FAILED_BRACKETING(\"number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\"),\n+    FAILED_BRACKETING(\"number of iterations={4}, maximum iterations={5}, initial={6}, lower bound={7}, upper bound={8}, final a value={0}, final b value={1}, f(a)={2}, f(b)={3}\"),\n     FAILED_FRACTION_CONVERSION(\"Unable to convert {0} to fraction after {1} iterations\"),\n     FIRST_COLUMNS_NOT_INITIALIZED_YET(\"first {0} columns are not initialized yet\"),\n     FIRST_ELEMENT_NOT_ZERO(\"first element is not 0: {0}\"),\n     PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD(\"cannot access {0} method in percentile implementation {1}\"),\n     PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD(\"percentile implementation {0} does not support {1}\"),\n     PERMUTATION_EXCEEDS_N(\"permutation size ({0}) exceeds permuation domain ({1})\"), /* keep */\n+    POLYNOMIAL(\"polynomial\"), /* keep */\n     POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS(\"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\"),\n     POPULATION_LIMIT_NOT_POSITIVE(\"population limit has to be positive\"),\n     POSITION_SIZE_MISMATCH_INPUT_ARRAY(\"position {0} and size {1} don't fit to the size of the input array {2}\"),\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n                             }\n                         }\n                     };\n-                    final BrentSolver solver = new BrentSolver(maxIterationCount, convergence);\n+                    final BrentSolver solver = new BrentSolver(convergence);\n+                    solver.setMaxEvaluations(maxIterationCount);\n                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                     if ((FastMath.abs(root - ta) <= convergence) &&\n                          (FastMath.abs(root - previousEventTime) <= convergence)) {\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n      * the {@link #value(double[])} method is called)\n      */\n     public LeastSquaresConverter(final MultivariateVectorialFunction function,\n-                                 final double[] observations, final double[] weights)\n-        throws IllegalArgumentException {\n+                                 final double[] observations, final double[] weights) {\n         if (observations.length != weights.length) {\n             throw new DimensionMismatchException(observations.length, weights.length);\n         }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n package org.apache.commons.math.optimization.fitting;\n \n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n-import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n import org.apache.commons.math.optimization.fitting.WeightedObservedPoint;\n \n \n     /**\n      * Fits Gaussian function to the observed points.\n-     * It will call {@link CurveFitter#fit()}.\n+     * It will call the base class\n+     * {@link CurveFitter#fit(ParametricRealFunction,double[]) fit} method.\n      *\n      * @return the Gaussian function that best fits the observed points.\n      * @see CurveFitter\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n      * @return harmonic Function that best fits the observed points.\n      * @throws NumberIsTooSmallException if the sample is too short or if\n      * the first guess cannot be computed.\n+     * @throws OptimizationException\n      */\n     public HarmonicFunction fit() throws OptimizationException {\n         // shall we compute the first guess of the parameters ourselves ?\n                 guesser.getGuessedAmplitude(),\n                 guesser.getGuessedPulsation(),\n                 guesser.getGuessedPhase()\n-            };    \n+            };\n         }\n \n         double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunction.java\n      * respect to {@code c}, and the partial derivative of {@code f(a, b, c,\n      * d)} with respect to {@code d}.\n      *\n-     * @param x {@code x} value to be used as constant in {@code f(a, b, c, d)}.\n-     * @param parameters values of {@code a}, {@code b}, {@code c}, and\n-     * {@code d} for computation of gradient vector of {@code f(a, b, c, d)}.\n+     * @param x Value to be used as constant in {@code f(x, a, b, c, d)}.\n+     * @param parameters Values of {@code a}, {@code b}, {@code c}, and {@code d}.\n      * @return the gradient vector of {@code f(a, b, c, d)}.\n-     * @param parameters Values of {@code a}, {@code b}, {@code c}, and {@code d}.\n      * @throws NullArgumentException if {@code parameters} is {@code null}.\n      * @throws DimensionMismatchException if the size of {@code parameters} is\n      * not 4.\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n      *\n      * @throws DimensionMismatchException if the Jacobian dimension does not\n      * match problem dimension.\n-     * @throws MathUserException if users jacobian function throws one\n-     */\n-    protected void updateJacobian() throws MathUserException {\n+     * @throws org.apache.commons.math.exception.MathUserException if the jacobian\n+     * function throws one.\n+     */\n+    protected void updateJacobian() {\n         ++jacobianEvaluations;\n         weightedResidualJacobian = jF.value(point);\n         if (weightedResidualJacobian.length != rows) {\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n-    protected void updateResidualsAndCost() throws MathUserException {\n+    protected void updateResidualsAndCost() {\n         objective = computeObjectiveValue(point);\n         if (objective.length != rows) {\n             throw new DimensionMismatchException(objective.length, rows);\n      * @return the covariance matrix.\n      * @throws org.apache.commons.math.exception.SingularMatrixException\n      * if the covariance matrix cannot be computed (singular problem).\n-     * @throws MathUserException if jacobian function throws one\n-     */\n-    public double[][] getCovariances() throws MathUserException {\n+     * @throws org.apache.commons.math.exception.MathUserException if the jacobian\n+     * function throws one.\n+     */\n+    public double[][] getCovariances() {\n         // set up the jacobian\n         updateJacobian();\n \n      * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n      * positive, i.e. the number of measurements is less or equal to the number of\n      * parameters.\n-     * @throws MathUserException if jacobian function throws one\n-     */\n-    public double[] guessParametersErrors() throws MathUserException {\n+     * @throws org.apache.commons.math.exception.MathUserException if the jacobian\n+     * function throws one.\n+     */\n+    public double[] guessParametersErrors() {\n         if (rows <= cols) {\n             throw new NumberIsTooSmallException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                                                 rows, cols, false);\n     @Override\n     public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n                                             final double[] target, final double[] weights,\n-                                            final double[] startPoint) throws MathUserException {\n+                                            final double[] startPoint) {\n         // Reset counter.\n         jacobianEvaluations = 0;\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.exception.MathIllegalStateException;\n-import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n  * @since 2.0\n  *\n  */\n-\n public class NonLinearConjugateGradientOptimizer\n     extends AbstractScalarDifferentiableOptimizer {\n     /** Update formula for the beta parameter. */\n      * default {@link BrentSolver Brent solver}.\n      */\n     public void setLineSearchSolver(final UnivariateRealSolver lineSearchSolver) {\n-        this.solver = lineSearchSolver;\n+        solver = lineSearchSolver;\n+        solver.setMaxEvaluations(getMaxEvaluations());\n     }\n \n     /**\n         }\n         if (solver == null) {\n             solver = new BrentSolver();\n+            solver.setMaxEvaluations(getMaxEvaluations());\n         }\n         point = getStartPoint();\n         final GoalType goal = getGoalType();\n \n             // Find the optimal step in the search direction.\n             final UnivariateRealFunction lsf = new LineSearchFunction(searchDirection);\n-            try {\n-                final double step = solver.solve(lsf, 0, findUpperBound(lsf, 0, initialStep));\n-\n-                // Validate new point.\n-                for (int i = 0; i < point.length; ++i) {\n-                    point[i] += step * searchDirection[i];\n-                }\n-            } catch (org.apache.commons.math.ConvergenceException e) {\n-                throw new ConvergenceException(); // XXX ugly workaround.\n+            final double uB = findUpperBound(lsf, 0, initialStep);\n+            // XXX Last parameters is set to a value clode to zero in order to\n+            // work around the divergence problem in the \"testCircleFitting\"\n+            // unit test (see MATH-439).\n+            final double step = solver.solve(lsf, 0, uB, 1e-15);\n+\n+            // Validate new point.\n+            for (int i = 0; i < point.length; ++i) {\n+                point[i] += step * searchDirection[i];\n             }\n \n             r = computeObjectiveGradient(point);\n         public double[] precondition(double[] variables, double[] r) {\n             return r.clone();\n         }\n-\n     }\n \n     /** Internal class for line search.\n \n         /** {@inheritDoc} */\n         public double value(double x) throws MathUserException {\n-\n             // current point in the search direction\n             final double[] shiftedPoint = point.clone();\n             for (int i = 0; i < shiftedPoint.length; ++i) {\n             }\n \n             return dotProduct;\n-\n-        }\n-\n-    }\n-\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public final class BisectionSolverTest extends TestCase {\n-\n-    public void testSinZero() throws MathException {\n+public final class BisectionSolverTest {\n+    @Test\n+    public void testSinZero() {\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n \n-        UnivariateRealSolver solver = new BisectionSolver();\n+        BisectionSolver solver = new BisectionSolver();\n+        solver.setMaxEvaluations(50);\n         result = solver.solve(f, 3, 4);\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 1, 4);\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n     }\n \n-   public void testQuinticZero() throws MathException {\n+    @Test\n+    public void testQuinticZero() {\n         UnivariateRealFunction f = new QuinticFunction();\n         double result;\n \n-        UnivariateRealSolver solver = new BisectionSolver();\n+        BisectionSolver solver = new BisectionSolver();\n+        solver.setMaxEvaluations(50);\n         result = solver.solve(f, -0.2, 0.2);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, -0.1, 0.3);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, -0.3, 0.45);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.3, 0.7);\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.2, 0.6);\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.05, 0.95);\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.85, 1.25);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.8, 1.2);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.85, 1.75);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.55, 1.45);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.85, 5);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n-        assertEquals(result, solver.getResult(), 0);\n-        assertTrue(solver.getIterationCount() > 0);\n+        Assert.assertTrue(solver.getEvaluations() > 0);\n     }\n \n+    @Test\n     public void testMath369() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        assertEquals(FastMath.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n+        BisectionSolver solver = new BisectionSolver();\n+        solver.setMaxEvaluations(40);\n+        Assert.assertEquals(FastMath.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy());\n     }\n \n     /**\n      *\n      */\n-    public void testSetFunctionValueAccuracy(){\n-        double expected = 1.0e-2;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        solver.setFunctionValueAccuracy(expected);\n-        assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);\n+    @Test\n+    public void testSetMaximalEvaluationCount(){\n+        int expected = 100;\n+        BisectionSolver solver = new BisectionSolver();\n+        solver.setMaxEvaluations(expected);\n+        Assert.assertEquals(expected, solver.getMaxEvaluations());\n     }\n-\n-    /**\n-     *\n-     */\n-    public void testResetFunctionValueAccuracy(){\n-        double newValue = 1.0e-2;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        double oldValue = solver.getFunctionValueAccuracy();\n-        solver.setFunctionValueAccuracy(newValue);\n-        solver.resetFunctionValueAccuracy();\n-        assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);\n-    }\n-\n-    /**\n-     *\n-     */\n-    public void testSetAbsoluteAccuracy(){\n-        double expected = 1.0e-2;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        solver.setAbsoluteAccuracy(expected);\n-        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2);\n-    }\n-\n-    /**\n-     *\n-     */\n-    public void testResetAbsoluteAccuracy(){\n-        double newValue = 1.0e-2;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        double oldValue = solver.getAbsoluteAccuracy();\n-        solver.setAbsoluteAccuracy(newValue);\n-        solver.resetAbsoluteAccuracy();\n-        assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);\n-    }\n-\n-    /**\n-     *\n-     */\n-    public void testSetMaximalIterationCount(){\n-        int expected = 100;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        solver.setMaximalIterationCount(expected);\n-        assertEquals(expected, solver.getMaximalIterationCount());\n-    }\n-\n-    /**\n-     *\n-     */\n-    public void testResetMaximalIterationCount(){\n-        int newValue = 10000;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        int oldValue = solver.getMaximalIterationCount();\n-        solver.setMaximalIterationCount(newValue);\n-        solver.resetMaximalIterationCount();\n-        assertEquals(oldValue, solver.getMaximalIterationCount());\n-    }\n-\n-    /**\n-     *\n-     */\n-    public void testSetRelativeAccuracy(){\n-        double expected = 1.0e-2;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        solver.setRelativeAccuracy(expected);\n-        assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);\n-    }\n-\n-    /**\n-     *\n-     */\n-    public void testResetRelativeAccuracy(){\n-        double newValue = 1.0e-2;\n-        UnivariateRealSolver solver = new BisectionSolver();\n-        double oldValue = solver.getRelativeAccuracy();\n-        solver.setRelativeAccuracy(newValue);\n-        solver.resetRelativeAccuracy();\n-        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n-    }\n-\n-\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import junit.framework.TestCase;\n-\n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.MonitoredFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n- * Testcase for UnivariateRealSolver.\n+ * Testcase for {@link BrentSolver Brent} solver.\n  * Because Brent-Dekker is guaranteed to converge in less than the default\n  * maximum iteration count due to bisection fallback, it is quite hard to\n  * debug. I include measured iteration counts plus one in order to detect\n  *\n  * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  */\n-public final class BrentSolverTest extends TestCase {\n-\n-    public BrentSolverTest(String name) {\n-        super(name);\n-    }\n-\n-    public void testSinZero() throws MathException {\n-        // The sinus function is behaved well around the root at #pi. The second\n+public final class BrentSolverTest {\n+    @Test\n+    public void testSinZero() {\n+        // The sinus function is behaved well around the root at pi. The second\n         // order derivative is zero, which means linar approximating methods will\n         // still converge quadratically.\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n         UnivariateRealSolver solver = new BrentSolver();\n+        solver.setMaxEvaluations(10);\n         // Somewhat benign interval. The function is monotone.\n         result = solver.solve(f, 3, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 4 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 5);\n+        // System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 7);\n         // Larger and somewhat less benign interval. The function is grows first.\n         result = solver.solve(f, 1, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 5 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 6);\n-        solver = new SecantSolver();\n-        result = solver.solve(f, 3, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 4 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 5);\n-        result = solver.solve(f, 1, 4);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n-        // 5 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 6);\n-        assertEquals(result, solver.getResult(), 0);\n-    }\n-\n-   public void testQuinticZero() throws MathException {\n+        // System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 8);\n+    }\n+\n+    @Test\n+    public void testQuinticZero() {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // Around the root of 0 the function is well behaved, with a second derivative\n         // of zero a 0.\n         double result;\n         // Brent-Dekker solver.\n         UnivariateRealSolver solver = new BrentSolver();\n+        solver.setMaxEvaluations(20);\n         // Symmetric bracket around 0. Test whether solvers can handle hitting\n         // the root in the first iteration.\n         result = solver.solve(f, -0.2, 0.2);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        assertTrue(solver.getIterationCount() <= 2);\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 3);\n         // 1 iterations on i586 JDK 1.4.1.\n         // Asymmetric bracket around 0, just for fun. Contains extremum.\n         result = solver.solve(f, -0.1, 0.3);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         // 5 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 6);\n+        Assert.assertTrue(solver.getEvaluations() <= 7);\n         // Large bracket around 0. Contains two extrema.\n         result = solver.solve(f, -0.3, 0.45);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n         // 6 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 7);\n+        Assert.assertTrue(solver.getEvaluations() <= 8);\n         // Benign bracket around 0.5, function is monotonous.\n         result = solver.solve(f, 0.3, 0.7);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n         // 6 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 7);\n+        Assert.assertTrue(solver.getEvaluations() <= 9);\n         // Less benign bracket around 0.5, contains one extremum.\n         result = solver.solve(f, 0.2, 0.6);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        // 6 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 7);\n+        // System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 10);\n         // Large, less benign bracket around 0.5, contains both extrema.\n         result = solver.solve(f, 0.05, 0.95);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        // 8 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 9);\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 11);\n         // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1\n         // is still a problem.\n         result = solver.solve(f, 0.85, 1.25);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 8 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 9);\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 11);\n         // Less benign bracket around 1 with extremum.\n         result = solver.solve(f, 0.8, 1.2);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 8 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 9);\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 11);\n         // Large bracket around 1. Monotonous.\n         result = solver.solve(f, 0.85, 1.75);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 10 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 11);\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 13);\n         // Large bracket around 1. Interval contains extremum.\n         result = solver.solve(f, 0.55, 1.45);\n         //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 7 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 8);\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 10);\n         // Very large bracket around 1 for testing fast growth behaviour.\n         result = solver.solve(f, 0.85, 5);\n         //System.out.println(\n-       //     \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 12 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 13);\n-        // Secant solver.\n-        solver = new SecantSolver();\n-        result = solver.solve(f, -0.2, 0.2);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        // 1 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 2);\n-        result = solver.solve(f, -0.1, 0.3);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        // 5 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 6);\n-        result = solver.solve(f, -0.3, 0.45);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        // 6 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 7);\n-        result = solver.solve(f, 0.3, 0.7);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        // 7 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 8);\n-        result = solver.solve(f, 0.2, 0.6);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        // 6 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 7);\n-        result = solver.solve(f, 0.05, 0.95);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n-        // 8 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 9);\n-        result = solver.solve(f, 0.85, 1.25);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 10 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 11);\n-        result = solver.solve(f, 0.8, 1.2);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 8 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 9);\n-        result = solver.solve(f, 0.85, 1.75);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 14 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 15);\n-        // The followig is especially slow because the solver first has to reduce\n-        // the bracket to exclude the extremum. After that, convergence is rapide.\n-        result = solver.solve(f, 0.55, 1.45);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 7 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 8);\n-        result = solver.solve(f, 0.85, 5);\n-        //System.out.println(\n-        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        // 14 iterations on i586 JDK 1.4.1.\n-        assertTrue(solver.getIterationCount() <= 15);\n-        // Static solve method\n-        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n-        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);\n-        assertEquals(result, 0, 1E-8);\n-        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);\n-        assertEquals(result, 0, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);\n-        assertEquals(result, 0.5, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);\n-        assertEquals(result, 0.5, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);\n-        assertEquals(result, 0.5, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);\n-        assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);\n-        assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);\n-        assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);\n-        assertEquals(result, 1.0, 1E-6);\n-        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);\n-        assertEquals(result, 1.0, 1E-6);\n-    }\n-\n-    public void testRootEndpoints() throws Exception {\n+       //     \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 15);\n+    }\n+\n+    @Test\n+    public void testRootEndpoints() {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new BrentSolver();\n+        BrentSolver solver = new BrentSolver();\n+        solver.setMaxEvaluations(10);\n \n         // endpoint is root\n         double result = solver.solve(f, FastMath.PI, 4);\n-        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 3, FastMath.PI);\n-        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, FastMath.PI, 4, 3.5);\n-        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 3, FastMath.PI, 3.07);\n-        assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n-\n-    }\n-\n-    public void testBadEndpoints() throws Exception {\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+    }\n+\n+    @Test\n+    public void testBadEndpoints() {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new BrentSolver();\n+        BrentSolver solver = new BrentSolver();\n+        solver.setMaxEvaluations(10);\n         try {  // bad interval\n             solver.solve(f, 1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {  // no bracket\n             solver.solve(f, 1, 1.5);\n-            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n+            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {  // no bracket\n             solver.solve(f, 1, 1.5, 1.2);\n-            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n+            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n-    public void testInitialGuess() throws MathException {\n-\n+    @Test\n+    public void testInitialGuess() {\n         MonitoredFunction f = new MonitoredFunction(new QuinticFunction());\n-        UnivariateRealSolver solver = new BrentSolver();\n+        BrentSolver solver = new BrentSolver();\n+        solver.setMaxEvaluations(20);\n         double result;\n \n         // no guess\n         result = solver.solve(f, 0.6, 7.0);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         int referenceCallsCount = f.getCallsCount();\n-        assertTrue(referenceCallsCount >= 13);\n+        Assert.assertTrue(referenceCallsCount >= 13);\n \n         // invalid guess (it *is* a root, but outside of the range)\n         try {\n           result = solver.solve(f, 0.6, 7.0, 0.0);\n-          fail(\"an IllegalArgumentException was expected\");\n+          Assert.fail(\"an IllegalArgumentException was expected\");\n         } catch (IllegalArgumentException iae) {\n             // expected behaviour\n         }\n         // bad guess\n         f.setCallsCount(0);\n         result = solver.solve(f, 0.6, 7.0, 0.61);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertTrue(f.getCallsCount() > referenceCallsCount);\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(f.getCallsCount() > referenceCallsCount);\n \n         // good guess\n         f.setCallsCount(0);\n         result = solver.solve(f, 0.6, 7.0, 0.999999);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertTrue(f.getCallsCount() < referenceCallsCount);\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(f.getCallsCount() < referenceCallsCount);\n \n         // perfect guess\n         f.setCallsCount(0);\n         result = solver.solve(f, 0.6, 7.0, 1.0);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        assertEquals(0, solver.getIterationCount());\n-        assertEquals(1, f.getCallsCount());\n-\n-    }\n-\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(1, solver.getEvaluations());\n+        Assert.assertEquals(1, f.getCallsCount());\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.Ignore;\n \n /**\n  * Testcase for Laguerre solver.\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class LaguerreSolverTest extends TestCase {\n-\n+public final class LaguerreSolverTest {\n     /**\n      * Test of solver for the linear function.\n      */\n-    public void testLinearFunction() throws MathException {\n+    @Test\n+    public void testLinearFunction() {\n         double min, max, expected, result, tolerance;\n \n         // p(x) = 4x - 1\n         double coefficients[] = { -1.0, 4.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver();\n+        LaguerreSolver solver = new LaguerreSolver();\n+        solver.setMaxEvaluations(10);\n \n         min = 0.0; max = 1.0; expected = 0.25;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of solver for the quadratic function.\n      */\n-    public void testQuadraticFunction() throws MathException {\n+    @Test\n+    public void testQuadraticFunction() {\n         double min, max, expected, result, tolerance;\n \n         // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)\n         double coefficients[] = { -3.0, 5.0, 2.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver();\n+        LaguerreSolver solver = new LaguerreSolver();\n+        solver.setMaxEvaluations(10);\n \n         min = 0.0; max = 2.0; expected = 0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -4.0; max = -1.0; expected = -3.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of solver for the quintic function.\n      */\n-    public void testQuinticFunction() throws MathException {\n+    @Test\n+    public void testQuinticFunction() {\n         double min, max, expected, result, tolerance;\n \n         // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)\n         double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver();\n+        LaguerreSolver solver = new LaguerreSolver();\n+        solver.setMaxEvaluations(10);\n \n         min = -2.0; max = 2.0; expected = -1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -5.0; max = -2.5; expected = -3.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = 3.0; max = 6.0; expected = 4.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of solver for the quintic function using solveAll().\n+     * XXX commented out because \"solveAll\" is not part of the API.\n      */\n-    public void testQuinticFunction2() throws MathException {\n-        double initial = 0.0, tolerance;\n-        Complex expected, result[];\n+    // public void testQuinticFunction2() {\n+    //     double initial = 0.0, tolerance;\n+    //     Complex expected, result[];\n \n-        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n-        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n-        LaguerreSolver solver = new LaguerreSolver();\n-        result = solver.solveAll(coefficients, initial);\n+    //     // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n+    //     double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n+    //     LaguerreSolver solver = new LaguerreSolver();\n+    //     result = solver.solveAll(coefficients, initial);\n \n-        expected = new Complex(0.0, -2.0);\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n+    //     expected = new Complex(0.0, -2.0);\n+    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n+    //     TestUtils.assertContains(result, expected, tolerance);\n \n-        expected = new Complex(0.0, 2.0);\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n+    //     expected = new Complex(0.0, 2.0);\n+    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n+    //     TestUtils.assertContains(result, expected, tolerance);\n \n-        expected = new Complex(0.5, 0.5 * FastMath.sqrt(3.0));\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n+    //     expected = new Complex(0.5, 0.5 * FastMath.sqrt(3.0));\n+    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n+    //     TestUtils.assertContains(result, expected, tolerance);\n \n-        expected = new Complex(-1.0, 0.0);\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n+    //     expected = new Complex(-1.0, 0.0);\n+    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n+    //     TestUtils.assertContains(result, expected, tolerance);\n \n-        expected = new Complex(0.5, -0.5 * FastMath.sqrt(3.0));\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n-    }\n+    //     expected = new Complex(0.5, -0.5 * FastMath.sqrt(3.0));\n+    //     tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+    //                 FastMath.abs(expected.abs() * solver.getRelativeAccuracy()));\n+    //     TestUtils.assertContains(result, expected, tolerance);\n+    // }\n \n     /**\n      * Test of parameters for the solver.\n      */\n-    public void testParameters() throws Exception {\n+    @Test\n+    public void testParameters() {\n         double coefficients[] = { -3.0, 5.0, 2.0 };\n         PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver();\n+        LaguerreSolver solver = new LaguerreSolver();\n+        solver.setMaxEvaluations(10);\n \n         try {\n             // bad interval\n             solver.solve(f, 1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n             solver.solve(f, 2, 3);\n-            fail(\"Expecting IllegalArgumentException - no bracketing\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad function\n-            solver.solve(new SinFunction(), -1, 1);\n-            fail(\"Expecting IllegalArgumentException - bad function\");\n+            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolver2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for {@link MullerSolver2 Muller} solver.\n+ * <p>\n+ * Muller's method converges almost quadratically near roots, but it can\n+ * be very slow in regions far away from zeros. Test runs show that for\n+ * reasonably good initial values, for a default absolute accuracy of 1E-6,\n+ * it generally takes 5 to 10 iterations for the solver to converge.\n+ * <p>\n+ * Tests for the exponential function illustrate the situations where\n+ * Muller solver performs poorly.\n+ *\n+ * @version $Revision: 1034896 $ $Date: 2010-11-13 23:27:34 +0100 (Sat, 13 Nov 2010) $\n+ */\n+public final class MullerSolver2Test {\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    @Test\n+    public void testSinFunction() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver2();\n+        solver.setMaxEvaluations(10);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = FastMath.PI;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    @Test\n+    public void testQuinticFunction() {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new MullerSolver2();\n+        solver.setMaxEvaluations(10);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     * <p>\n+     * It takes 25 to 50 iterations for the last two tests to converge.\n+     */\n+    @Test\n+    public void testExpm1Function() {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new MullerSolver2();\n+        solver.setMaxEvaluations(55);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n+                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        Assert.assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    @Test\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver2();\n+        solver.setMaxEvaluations(10);\n+\n+        try {\n+            // bad interval\n+            solver.solve(f, 1, -1);\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(f, 2, 3);\n+            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (NoBracketingException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n- * Testcase for Muller solver.\n+ * Testcase for {@link MullerSolver Muller} solver.\n  * <p>\n  * Muller's method converges almost quadratically near roots, but it can\n  * be very slow in regions far away from zeros. Test runs show that for\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class MullerSolverTest extends TestCase {\n-\n+public final class MullerSolverTest {\n     /**\n      * Test of solver for the sine function.\n      */\n-    public void testSinFunction() throws MathException {\n+    @Test\n+    public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n+        solver.setMaxEvaluations(10);\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the sine function using solve2().\n-     */\n-    public void testSinFunction2() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        MullerSolver solver = new MullerSolver();\n-        double min, max, expected, result, tolerance;\n-\n-        min = 3.0; max = 4.0; expected = FastMath.PI;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of solver for the quintic function.\n      */\n-    public void testQuinticFunction() throws MathException {\n+    @Test\n+    public void testQuinticFunction() {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n+        solver.setMaxEvaluations(15);\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the quintic function using solve2().\n-     */\n-    public void testQuinticFunction2() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        MullerSolver solver = new MullerSolver();\n-        double min, max, expected, result, tolerance;\n-\n-        min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * In fact, if not for the bisection alternative, the solver would\n      * exceed the default maximal iteration of 100.\n      */\n-    public void testExpm1Function() throws MathException {\n+    @Test\n+    public void testExpm1Function() {\n         UnivariateRealFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new MullerSolver();\n+        solver.setMaxEvaluations(25);\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the exponential function using solve2().\n-     * <p>\n-     * It takes 25 to 50 iterations for the last two tests to converge.\n-     */\n-    public void testExpm1Function2() throws MathException {\n-        UnivariateRealFunction f = new Expm1Function();\n-        MullerSolver solver = new MullerSolver();\n-        double min, max, expected, result, tolerance;\n-\n-        min = -1.0; max = 2.0; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -20.0; max = 10.0; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -50.0; max = 100.0; expected = 0.0;\n-        tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n-                    FastMath.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of parameters for the solver.\n      */\n+    @Test\n     public void testParameters() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new MullerSolver();\n+        solver.setMaxEvaluations(10);\n \n         try {\n             // bad interval\n-            solver.solve(f, 1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            double root = solver.solve(f, 1, -1);\n+            System.out.println(\"root=\" + root);\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n             solver.solve(f, 2, 3);\n-            fail(\"Expecting IllegalArgumentException - no bracketing\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (NoBracketingException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n-\n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public final class NewtonSolverTest extends TestCase {\n-\n+public final class NewtonSolverTest {\n     /**\n      *\n      */\n-    public void testSinZero() throws MathException {\n+    @Test\n+    public void testSinZero() {\n         DifferentiableUnivariateRealFunction f = new SinFunction();\n         double result;\n \n-        UnivariateRealSolver solver = new NewtonSolver();\n+        NewtonSolver solver = new NewtonSolver();\n+        solver.setMaxEvaluations(10);\n         result = solver.solve(f, 3, 4);\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 1, 4);\n-        assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n \n-        assertEquals(result, solver.getResult(), 0);\n-        assertTrue(solver.getIterationCount() > 0);\n+        Assert.assertTrue(solver.getEvaluations() > 0);\n     }\n \n     /**\n      *\n      */\n-    public void testQuinticZero() throws MathException {\n+    @Test\n+    public void testQuinticZero() {\n         DifferentiableUnivariateRealFunction f = new QuinticFunction();\n         double result;\n \n-        UnivariateRealSolver solver = new NewtonSolver();\n+        NewtonSolver solver = new NewtonSolver();\n+        solver.setMaxEvaluations(30);\n         result = solver.solve(f, -0.2, 0.2);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, -0.1, 0.3);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, -0.3, 0.45);\n-        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.3, 0.7);\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.2, 0.6);\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.05, 0.95);\n-        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.85, 1.25);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.8, 1.2);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.85, 1.75);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.55, 1.45);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.85, 5);\n-        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n     }\n-\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n  */\n package org.apache.commons.math.analysis.solvers;\n \n-import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.Expm1Function;\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n-\n-import junit.framework.TestCase;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n- * Testcase for Ridders solver.\n+ * Testcase for {@link RiddersSolver Ridders} solver.\n  * <p>\n  * Ridders' method converges superlinearly, more specific, its rate of\n  * convergence is sqrt(2). Test runs show that for a default absolute\n  *\n  * @version $Revision$ $Date$\n  */\n-public final class RiddersSolverTest extends TestCase {\n-\n+public final class RiddersSolverTest {\n     /**\n      * Test of solver for the sine function.\n      */\n-    public void testSinFunction() throws MathException {\n+    @Test\n+    public void testSinFunction() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n+        solver.setMaxEvaluations(10);\n         double min, max, expected, result, tolerance;\n \n         min = 3.0; max = 4.0; expected = FastMath.PI;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -1.0; max = 1.5; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of solver for the quintic function.\n      */\n-    public void testQuinticFunction() throws MathException {\n+    @Test\n+    public void testQuinticFunction() {\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n+        solver.setMaxEvaluations(15);\n         double min, max, expected, result, tolerance;\n \n         min = -0.4; max = 0.2; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = 0.75; max = 1.5; expected = 1.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -0.9; max = -0.2; expected = -0.5;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of solver for the exponential function.\n      */\n-    public void testExpm1Function() throws MathException {\n+    @Test\n+    public void testExpm1Function() {\n         UnivariateRealFunction f = new Expm1Function();\n         UnivariateRealSolver solver = new RiddersSolver();\n+        solver.setMaxEvaluations(20);\n         double min, max, expected, result, tolerance;\n \n         min = -1.0; max = 2.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -20.0; max = 10.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n \n         min = -50.0; max = 100.0; expected = 0.0;\n         tolerance = FastMath.max(solver.getAbsoluteAccuracy(),\n                     FastMath.abs(expected * solver.getRelativeAccuracy()));\n         result = solver.solve(f, min, max);\n-        assertEquals(expected, result, tolerance);\n+        Assert.assertEquals(expected, result, tolerance);\n     }\n \n     /**\n      * Test of parameters for the solver.\n      */\n-    public void testParameters() throws Exception {\n+    @Test\n+    public void testParameters() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new RiddersSolver();\n+        solver.setMaxEvaluations(10);\n \n         try {\n             // bad interval\n             solver.solve(f, 1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n             // expected\n         }\n         try {\n             // no bracketing\n             solver.solve(f, 2, 3);\n-            fail(\"Expecting IllegalArgumentException - no bracketing\");\n-        } catch (IllegalArgumentException ex) {\n+            Assert.fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (NoBracketingException ex) {\n             // expected\n         }\n     }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.MonitoredFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Testcase for {@link SecantSolver}.\n+ *\n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n+ */\n+public final class SecantSolverTest {\n+    @Test\n+    public void testSinZero() {\n+        // The sinus function is behaved well around the root at pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically.\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new SecantSolver();\n+        solver.setMaxEvaluations(10);\n+\n+        result = solver.solve(f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 6);\n+        result = solver.solve(f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 7);\n+    }\n+\n+    @Test\n+    public void testQuinticZero() {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second derivative\n+        // of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1, because\n+        // the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        // intervals containing these values are harder for the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        // Brent-Dekker solver.\n+        UnivariateRealSolver solver = new SecantSolver();\n+        solver.setMaxEvaluations(20);\n+        result = solver.solve(f, -0.2, 0.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 3);\n+        result = solver.solve(f, -0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 7);\n+        result = solver.solve(f, -0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 8);\n+        result = solver.solve(f, 0.3, 0.7);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 9);\n+        result = solver.solve(f, 0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 8);\n+        result = solver.solve(f, 0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 10);\n+        result = solver.solve(f, 0.85, 1.25);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 12);\n+        result = solver.solve(f, 0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 10);\n+        result = solver.solve(f, 0.85, 1.75);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 16);\n+        // The followig is especially slow because the solver first has to reduce\n+        // the bracket to exclude the extremum. After that, convergence is rapide.\n+        result = solver.solve(f, 0.55, 1.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 9);\n+        result = solver.solve(f, 0.85, 5);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 16);\n+    }\n+\n+    @Test\n+    public void testRootEndpoints() {\n+        UnivariateRealFunction f = new SinFunction();\n+        SecantSolver solver = new SecantSolver();\n+        solver.setMaxEvaluations(10);\n+\n+        // endpoint is root\n+        double result = solver.solve(f, FastMath.PI, 4);\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 3, FastMath.PI);\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, FastMath.PI, 4, 3.5);\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 3, FastMath.PI, 3.07);\n+        Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy());\n+\n+    }\n+\n+    @Test\n+    public void testBadEndpoints() {\n+        UnivariateRealFunction f = new SinFunction();\n+        SecantSolver solver = new SecantSolver();\n+        solver.setMaxEvaluations(10);\n+        try {  // bad interval\n+            solver.solve(f, 1, -1);\n+            Assert.fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(f, 1, 1.5);\n+            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(f, 1, 1.5, 1.2);\n+            Assert.fail(\"Expecting IllegalArgumentException - non-bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import junit.framework.TestCase;\n-\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * @version $Revision$ $Date$\n  */\n-public class UnivariateRealSolverUtilsTest extends TestCase {\n+public class UnivariateRealSolverUtilsTest {\n \n     protected UnivariateRealFunction sin = new SinFunction();\n \n-    public void testSolveNull() throws MathException {\n+    @Test\n+    public void testSolveNull() {\n         try {\n             UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n-            fail();\n+            Assert.fail();\n         } catch(IllegalArgumentException ex){\n             // success\n         }\n     }\n \n-    public void testSolveBadEndpoints() throws MathException {\n+    @Test\n+    public void testSolveBadEndpoints() {\n         try { // bad endpoints\n-            UnivariateRealSolverUtils.solve(sin, -0.1, 4.0, 4.0);\n-            fail(\"Expecting IllegalArgumentException\");\n+            double root = UnivariateRealSolverUtils.solve(sin, 4.0, -0.1, 1e-6);\n+            System.out.println(\"root=\" + root);\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n-    public void testSolveBadAccuracy() throws MathException {\n+    @Test\n+    public void testSolveBadAccuracy() {\n         try { // bad accuracy\n             UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0);\n-//             fail(\"Expecting IllegalArgumentException\"); // TODO needs rework since convergence behaviour was changed\n+//             Assert.fail(\"Expecting IllegalArgumentException\"); // TODO needs rework since convergence behaviour was changed\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n-    public void testSolveSin() throws MathException {\n+    @Test\n+    public void testSolveSin() {\n         double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);\n-        assertEquals(FastMath.PI, x, 1.0e-4);\n+        Assert.assertEquals(FastMath.PI, x, 1.0e-4);\n     }\n \n-    public void testSolveAccuracyNull()  throws MathException {\n+    @Test\n+    public void testSolveAccuracyNull()  {\n         try {\n             double accuracy = 1.0e-6;\n             UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);\n-            fail();\n+            Assert.fail();\n         } catch(IllegalArgumentException ex){\n             // success\n         }\n     }\n \n-    public void testSolveAccuracySin() throws MathException {\n+    @Test\n+    public void testSolveAccuracySin() {\n         double accuracy = 1.0e-6;\n         double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n                 4.0, accuracy);\n-        assertEquals(FastMath.PI, x, accuracy);\n+        Assert.assertEquals(FastMath.PI, x, accuracy);\n     }\n \n-    public void testSolveNoRoot() throws MathException {\n+    @Test\n+    public void testSolveNoRoot() {\n         try {\n             UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);\n-            fail(\"Expecting IllegalArgumentException \");\n+            Assert.fail(\"Expecting IllegalArgumentException \");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n-    public void testBracketSin() throws MathException {\n+    @Test\n+    public void testBracketSin() {\n         double[] result = UnivariateRealSolverUtils.bracket(sin,\n                 0.0, -2.0, 2.0);\n-        assertTrue(sin.value(result[0]) < 0);\n-        assertTrue(sin.value(result[1]) > 0);\n+        Assert.assertTrue(sin.value(result[0]) < 0);\n+        Assert.assertTrue(sin.value(result[1]) > 0);\n     }\n \n-    public void testBracketEndpointRoot() throws MathException {\n+    @Test\n+    public void testBracketEndpointRoot() {\n         double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0);\n-        assertEquals(0.0, sin.value(result[0]), 1.0e-15);\n-        assertTrue(sin.value(result[1]) > 0);\n+        Assert.assertEquals(0.0, sin.value(result[0]), 1.0e-15);\n+        Assert.assertTrue(sin.value(result[1]) > 0);\n     }\n \n-    public void testNullFunction() throws MathException {\n+    @Test\n+    public void testNullFunction() {\n         try { // null function\n             UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n     \n-    public void testBadInitial() throws MathException {\n+    @Test\n+    public void testBadInitial() {\n         try { // initial not between endpoints\n             UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n     \n-    public void testBadEndpoints() throws MathException {\n+    @Test\n+    public void testBadEndpoints() {\n         try { // endpoints not valid\n             UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n     \n-    public void testBadMaximumIterations() throws MathException {\n+    @Test\n+    public void testBadMaximumIterations() {\n         try { // bad maximum iterations\n             UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n-            fail(\"Expecting IllegalArgumentException\");\n+            Assert.fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n+    @Test\n+    public void testMisc() {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        // Static solve method\n+        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);\n+        Assert.assertEquals(result, 0, 1E-8);\n+        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);\n+        Assert.assertEquals(result, 0, 1E-8);\n+        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);\n+        Assert.assertEquals(result, 0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);\n+        Assert.assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);\n+        Assert.assertEquals(result, 1.0, 1E-6);\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n \n-    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalValueError(), 1.1e-7);\n     assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n     assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n     integ.clearEventHandlers();\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n import junit.framework.TestCase;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n                       pb.getInitialTime(), pb.getInitialState(),\n                       pb.getFinalTime(), new double[pb.getDimension()]);\n       fail(\"an exception should have been thrown\");\n-    } catch (IntegratorException ie) {\n-       assertTrue(ie.getCause() != null);\n-       assertTrue(ie.getCause() instanceof ConvergenceException);\n+    } catch (TooManyEvaluationsException tmee) {\n+        // Expected.\n     }\n \n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/general/CircleScalar.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import java.util.ArrayList;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+\n+/**\n+ * Class used in the tests.\n+ */\n+class CircleScalar implements DifferentiableMultivariateRealFunction {\n+    private ArrayList<Point2D.Double> points;\n+\n+    public CircleScalar() {\n+        points  = new ArrayList<Point2D.Double>();\n+    }\n+\n+    public void addPoint(double px, double py) {\n+        points.add(new Point2D.Double(px, py));\n+    }\n+\n+    public double getRadius(Point2D.Double center) {\n+        double r = 0;\n+        for (Point2D.Double point : points) {\n+            r += point.distance(center);\n+        }\n+        return r / points.size();\n+    }\n+\n+    private double[] gradient(double[] point) {\n+        // optimal radius\n+        Point2D.Double center = new Point2D.Double(point[0], point[1]);\n+        double radius = getRadius(center);\n+\n+        // gradient of the sum of squared residuals\n+        double dJdX = 0;\n+        double dJdY = 0;\n+        for (Point2D.Double pk : points) {\n+            double dk = pk.distance(center);\n+            dJdX += (center.x - pk.x) * (dk - radius) / dk;\n+            dJdY += (center.y - pk.y) * (dk - radius) / dk;\n+        }\n+        dJdX *= 2;\n+        dJdY *= 2;\n+\n+        return new double[] { dJdX, dJdY };\n+    }\n+\n+    public double value(double[] variables)  {\n+        Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+        double radius = getRadius(center);\n+\n+        double sum = 0;\n+        for (Point2D.Double point : points) {\n+            double di = point.distance(center) - radius;\n+            sum += di * di;\n+        }\n+\n+        return sum;\n+    }\n+\n+    public MultivariateVectorialFunction gradient() {\n+        return new MultivariateVectorialFunction() {\n+            private static final long serialVersionUID = 3174909643301201710L;\n+            public double[] value(double[] point) {\n+                return gradient(point);\n+            }\n+        };\n+    }\n+\n+    public MultivariateRealFunction partialDerivative(final int k) {\n+        return new MultivariateRealFunction() {\n+            private static final long serialVersionUID = 3073956364104833888L;\n+            public double value(double[] point) {\n+                return gradient(point)[k];\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/general/CircleVectorial.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import java.awt.geom.Point2D;\n+import java.util.ArrayList;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+\n+/**\n+ * Class used in the tests.\n+ */\n+class CircleVectorial implements DifferentiableMultivariateVectorialFunction {\n+    private ArrayList<Point2D.Double> points;\n+\n+    public CircleVectorial() {\n+        points  = new ArrayList<Point2D.Double>();\n+    }\n+\n+    public void addPoint(double px, double py) {\n+        points.add(new Point2D.Double(px, py));\n+    }\n+\n+    public int getN() {\n+        return points.size();\n+    }\n+\n+    public double getRadius(Point2D.Double center) {\n+        double r = 0;\n+        for (Point2D.Double point : points) {\n+            r += point.distance(center);\n+        }\n+        return r / points.size();\n+    }\n+\n+    private double[][] jacobian(double[] point) {\n+        int n = points.size();\n+        Point2D.Double center = new Point2D.Double(point[0], point[1]);\n+\n+        // gradient of the optimal radius\n+        double dRdX = 0;\n+        double dRdY = 0;\n+        for (Point2D.Double pk : points) {\n+            double dk = pk.distance(center);\n+            dRdX += (center.x - pk.x) / dk;\n+            dRdY += (center.y - pk.y) / dk;\n+        }\n+        dRdX /= n;\n+        dRdY /= n;\n+\n+        // jacobian of the radius residuals\n+        double[][] jacobian = new double[n][2];\n+        for (int i = 0; i < n; ++i) {\n+            Point2D.Double pi = points.get(i);\n+            double di   = pi.distance(center);\n+            jacobian[i][0] = (center.x - pi.x) / di - dRdX;\n+            jacobian[i][1] = (center.y - pi.y) / di - dRdY;\n+        }\n+\n+        return jacobian;\n+    }\n+\n+    public double[] value(double[] variables) {\n+        Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+        double radius = getRadius(center);\n+\n+        double[] residuals = new double[points.size()];\n+        for (int i = 0; i < residuals.length; ++i) {\n+            residuals[i] = points.get(i).distance(center) - radius;\n+        }\n+\n+        return residuals;\n+    }\n+\n+    public MultivariateMatrixFunction jacobian() {\n+        return new MultivariateMatrixFunction() {\n+            private static final long serialVersionUID = -4340046230875165095L;\n+            public double[][] value(double[] point) {\n+                return jacobian(point);\n+            }\n+        };\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n     }\n \n     public void testMaxEvaluations() throws Exception {\n-        Circle circle = new Circle();\n+        CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         circle.addPoint(110.0, -20.0);\n     }\n \n     public void testCircleFitting() throws MathUserException {\n-        Circle circle = new Circle();\n+        CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         circle.addPoint(110.0, -20.0);\n     }\n \n     public void testCircleFittingBadInit() throws MathUserException {\n-        Circle circle = new Circle();\n+        CircleVectorial circle = new CircleVectorial();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n                 {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n                 }\n             };\n         }\n-\n-    }\n-\n-    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {\n-\n-        private static final long serialVersionUID = -7165774454925027042L;\n-        private ArrayList<Point2D.Double> points;\n-\n-        public Circle() {\n-            points  = new ArrayList<Point2D.Double>();\n-        }\n-\n-        public void addPoint(double px, double py) {\n-            points.add(new Point2D.Double(px, py));\n-        }\n-\n-        public int getN() {\n-            return points.size();\n-        }\n-\n-        public double getRadius(Point2D.Double center) {\n-            double r = 0;\n-            for (Point2D.Double point : points) {\n-                r += point.distance(center);\n-            }\n-            return r / points.size();\n-        }\n-\n-        private double[][] jacobian(double[] variables) {\n-\n-            int n = points.size();\n-            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n-\n-            // gradient of the optimal radius\n-            double dRdX = 0;\n-            double dRdY = 0;\n-            for (Point2D.Double pk : points) {\n-                double dk = pk.distance(center);\n-                dRdX += (center.x - pk.x) / dk;\n-                dRdY += (center.y - pk.y) / dk;\n-            }\n-            dRdX /= n;\n-            dRdY /= n;\n-\n-            // jacobian of the radius residuals\n-            double[][] jacobian = new double[n][2];\n-            for (int i = 0; i < n; ++i) {\n-                Point2D.Double pi = points.get(i);\n-                double di   = pi.distance(center);\n-                jacobian[i][0] = (center.x - pi.x) / di - dRdX;\n-                jacobian[i][1] = (center.y - pi.y) / di - dRdY;\n-           }\n-\n-            return jacobian;\n-\n-        }\n-\n-        public double[] value(double[] variables) {\n-\n-            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n-            double radius = getRadius(center);\n-\n-            double[] residuals = new double[points.size()];\n-            for (int i = 0; i < residuals.length; ++i) {\n-                residuals[i] = points.get(i).distance(center) - radius;\n-            }\n-\n-            return residuals;\n-\n-        }\n-\n-        public MultivariateMatrixFunction jacobian() {\n-            return new MultivariateMatrixFunction() {\n-                private static final long serialVersionUID = -4340046230875165095L;\n-                public double[][] value(double[] point) {\n-                    return jacobian(point);\n-                }\n-            };\n-        }\n-\n-    }\n-\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.exception.SingularMatrixException;\n+import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math.exception.ConvergenceException;\n-import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.exception.MathUserException;\n-import org.apache.commons.math.exception.NumberIsTooSmallException;\n-import org.apache.commons.math.exception.SingularMatrixException;\n-import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n+import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n         super(name);\n     }\n \n-    public void testTrivial() throws MathUserException {\n+    public void testTrivial() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testQRColumnsPermutation() throws MathUserException {\n+    public void testQRColumnsPermutation() {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n         assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n     }\n \n-    public void testNoDependency() throws MathUserException {\n+    public void testNoDependency() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws MathUserException {\n+    public void testOneSet() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n         assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n     }\n \n-    public void testTwoSets() throws MathUserException {\n+    public void testTwoSets() {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n         assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n     }\n \n-    public void testNonInvertible() throws MathUserException {\n+    public void testNonInvertible() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n         }\n     }\n \n-    public void testIllConditioned() throws MathUserException {\n+    public void testIllConditioned() {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n         assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n     }\n \n-    public void testMoreEstimatedParametersSimple() throws MathUserException {\n+    public void testMoreEstimatedParametersSimple() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n     }\n \n-    public void testMoreEstimatedParametersUnsorted() throws MathUserException {\n+    public void testMoreEstimatedParametersUnsorted() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n         assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n     }\n \n-    public void testRedundantEquations() throws MathUserException {\n+    public void testRedundantEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n     }\n \n-    public void testInconsistentEquations() throws MathUserException {\n+    public void testInconsistentEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         assertTrue(optimizer.getRMS() > 0.1);\n     }\n \n-    public void testInconsistentSizes() throws MathUserException {\n+    public void testInconsistentSizes() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         }\n     }\n \n-    public void testControlParameters() throws MathUserException {\n-        Circle circle = new Circle();\n+    public void testControlParameters() {\n+        CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         circle.addPoint(110.0, -20.0);\n     private void checkEstimate(DifferentiableMultivariateVectorialFunction problem,\n                                double initialStepBoundFactor, int maxCostEval,\n                                double costRelativeTolerance, double parRelativeTolerance,\n-                               double orthoTolerance, boolean shouldFail) throws MathUserException {\n+                               double orthoTolerance, boolean shouldFail) {\n         try {\n             LevenbergMarquardtOptimizer optimizer\n                 = new LevenbergMarquardtOptimizer(initialStepBoundFactor,\n         }\n     }\n \n-    public void testCircleFitting() throws MathUserException {\n-        Circle circle = new Circle();\n+    public void testCircleFitting() {\n+        CircleVectorial circle = new CircleVectorial();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         circle.addPoint(110.0, -20.0);\n         assertEquals(0.004, errors[1], 0.001);\n     }\n \n-    public void testCircleFittingBadInit() throws MathUserException {\n-        Circle circle = new Circle();\n+    public void testCircleFittingBadInit() {\n+        CircleVectorial circle = new CircleVectorial();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n                 {-0.390426,  0.260487}, {-0.361212,  0.328325}, {-0.346039,  0.392619},\n         assertEquals( 0.2075001, center.y,      1.0e-6);\n     }\n \n-    public void testMath199() throws MathUserException {\n+    public void testMath199() {\n         try {\n             QuadraticProblem problem = new QuadraticProblem();\n             problem.addPoint (0, -3.182591015485607);\n         }\n     }\n \n-    private static class Circle implements DifferentiableMultivariateVectorialFunction, Serializable {\n-\n-        private static final long serialVersionUID = -4711170319243817874L;\n-\n-        private ArrayList<Point2D.Double> points;\n-\n-        public Circle() {\n-            points  = new ArrayList<Point2D.Double>();\n-        }\n-\n-        public void addPoint(double px, double py) {\n-            points.add(new Point2D.Double(px, py));\n-        }\n-\n-        public int getN() {\n-            return points.size();\n-        }\n-\n-        public double getRadius(Point2D.Double center) {\n-            double r = 0;\n-            for (Point2D.Double point : points) {\n-                r += point.distance(center);\n-            }\n-            return r / points.size();\n-        }\n-\n-        private double[][] jacobian(double[] point) {\n-\n-            int n = points.size();\n-            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n-\n-            // gradient of the optimal radius\n-            double dRdX = 0;\n-            double dRdY = 0;\n-            for (Point2D.Double pk : points) {\n-                double dk = pk.distance(center);\n-                dRdX += (center.x - pk.x) / dk;\n-                dRdY += (center.y - pk.y) / dk;\n-            }\n-            dRdX /= n;\n-            dRdY /= n;\n-\n-            // jacobian of the radius residuals\n-            double[][] jacobian = new double[n][2];\n-            for (int i = 0; i < n; ++i) {\n-                Point2D.Double pi = points.get(i);\n-                double di   = pi.distance(center);\n-                jacobian[i][0] = (center.x - pi.x) / di - dRdX;\n-                jacobian[i][1] = (center.y - pi.y) / di - dRdY;\n-            }\n-\n-            return jacobian;\n-        }\n-\n-        public double[] value(double[] variables) {\n-\n-            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n-            double radius = getRadius(center);\n-\n-            double[] residuals = new double[points.size()];\n-            for (int i = 0; i < residuals.length; ++i) {\n-                residuals[i] = points.get(i).distance(center) - radius;\n-            }\n-\n-            return residuals;\n-        }\n-\n-        public MultivariateMatrixFunction jacobian() {\n-            return new MultivariateMatrixFunction() {\n-                private static final long serialVersionUID = -4340046230875165095L;\n-                public double[][] value(double[] point) {\n-                    return jacobian(point);\n-                }\n-            };\n-        }\n-    }\n-\n     private static class QuadraticProblem implements DifferentiableMultivariateVectorialFunction, Serializable {\n \n         private static final long serialVersionUID = 7072187082052755854L;\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n import java.io.Serializable;\n import java.util.ArrayList;\n \n-import junit.framework.TestCase;\n-\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * @author Jorge J. More (original fortran minpack tests)\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n-public class NonLinearConjugateGradientOptimizerTest\n-extends TestCase {\n-\n-    public NonLinearConjugateGradientOptimizerTest(String name) {\n-        super(name);\n-    }\n-\n-    public void testTrivial() throws MathUserException {\n+public class NonLinearConjugateGradientOptimizerTest {\n+    @Test\n+    public void testTrivial() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         NonLinearConjugateGradientOptimizer optimizer =\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0 });\n-        assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(0.0, optimum.getValue(), 1.0e-10);\n-    }\n-\n-    public void testColumnsPermutation() throws MathUserException {\n-\n+        Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testColumnsPermutation() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n                               new double[] { 4.0, 6.0, 1.0 });\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n-        assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(0.0, optimum.getValue(), 1.0e-10);\n-\n-    }\n-\n-    public void testNoDependency() throws MathUserException {\n+        Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testNoDependency() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         for (int i = 0; i < problem.target.length; ++i) {\n-            assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n-        }\n-    }\n-\n-    public void testOneSet() throws MathUserException {\n-\n+            Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n+        }\n+    }\n+\n+    @Test\n+    public void testOneSet() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n                 { -1,  1, 0 },\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n-        assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n-\n-    }\n-\n-    public void testTwoSets() throws MathUserException {\n+        Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testTwoSets() {\n         final double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n \n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n-        assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n-        assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n-        assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n-        assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n-        assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n-        assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n-\n-    }\n-\n-    public void testNonInversible() throws MathUserException {\n-\n+        Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n+        Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n+        Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n+        Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10);\n+        Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10);\n+        Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testNonInversible() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n                 {  2, 1,  3 },\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n                 optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n-        assertTrue(optimum.getValue() > 0.5);\n-    }\n-\n-    public void testIllConditioned() throws MathUserException {\n+        Assert.assertTrue(optimum.getValue() > 0.5);\n+    }\n+\n+    @Test\n+    public void testIllConditioned() {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n         optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n-        BrentSolver solver = new BrentSolver();\n-        solver.setAbsoluteAccuracy(1.0e-15);\n-        solver.setRelativeAccuracy(1.0e-15);\n+        BrentSolver solver = new BrentSolver(1e-15, 1e-15);\n         optimizer.setLineSearchSolver(solver);\n         RealPointValuePair optimum1 =\n             optimizer.optimize(problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n-        assertEquals(1.0, optimum1.getPoint()[0], 1.0e-5);\n-        assertEquals(1.0, optimum1.getPoint()[1], 1.0e-5);\n-        assertEquals(1.0, optimum1.getPoint()[2], 1.0e-5);\n-        assertEquals(1.0, optimum1.getPoint()[3], 1.0e-5);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4);\n+        Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-4);\n \n         LinearProblem problem2 = new LinearProblem(new double[][] {\n                 { 10.00, 7.00, 8.10, 7.20 },\n         }, new double[] { 32, 23, 33, 31 });\n         RealPointValuePair optimum2 =\n             optimizer.optimize(problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n-        assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);\n-        assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);\n-        assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1);\n-        assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1);\n-\n-    }\n-\n-    public void testMoreEstimatedParametersSimple()\n-        throws MathUserException {\n-\n+        Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);\n+        Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);\n+        Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1);\n+        Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1);\n+\n+    }\n+\n+    @Test\n+    public void testMoreEstimatedParametersSimple() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n                 { 0.0, 1.0, -1.0, 1.0 },\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n-        assertEquals(0, optimum.getValue(), 1.0e-10);\n-\n-    }\n-\n-    public void testMoreEstimatedParametersUnsorted()\n-        throws MathUserException {\n+        Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testMoreEstimatedParametersUnsorted() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                  { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                  { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n-        assertEquals(0, optimum.getValue(), 1.0e-10);\n-    }\n-\n-    public void testRedundantEquations() throws MathUserException {\n+        Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testRedundantEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n-        assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n-        assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n-\n-    }\n-\n-    public void testInconsistentEquations() throws MathUserException {\n+        Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n+        Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n+\n+    }\n+\n+    @Test\n+    public void testInconsistentEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n         RealPointValuePair optimum =\n             optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n-        assertTrue(optimum.getValue() > 0.1);\n-\n-    }\n-\n-    public void testCircleFitting() throws MathUserException {\n-        Circle circle = new Circle();\n+        Assert.assertTrue(optimum.getValue() > 0.1);\n+\n+    }\n+\n+    @Test\n+    public void testCircleFitting() {\n+        CircleScalar circle = new CircleScalar();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         circle.addPoint(110.0, -20.0);\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n         optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));\n-        BrentSolver solver = new BrentSolver();\n-        solver.setAbsoluteAccuracy(1.0e-13);\n-        solver.setRelativeAccuracy(1.0e-15);\n+        UnivariateRealSolver solver = new BrentSolver(1e-15, 1e-13);\n         optimizer.setLineSearchSolver(solver);\n         RealPointValuePair optimum =\n             optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n-        assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n-        assertEquals(96.075902096, center.x, 1.0e-8);\n-        assertEquals(48.135167894, center.y, 1.0e-8);\n+        Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n+        Assert.assertEquals(96.075902096, center.x, 1.0e-8);\n+        Assert.assertEquals(48.135167894, center.y, 1.0e-8);\n     }\n \n     private static class LinearProblem implements DifferentiableMultivariateRealFunction, Serializable {\n             return p;\n         }\n \n-        public double value(double[] variables) throws MathUserException {\n+        public double value(double[] variables) {\n             double[] y = factors.operate(variables);\n             double sum = 0;\n             for (int i = 0; i < y.length; ++i) {\n                 }\n             };\n         }\n-\n-    }\n-\n-    private static class Circle implements DifferentiableMultivariateRealFunction, Serializable {\n-\n-        private static final long serialVersionUID = -4711170319243817874L;\n-\n-        private ArrayList<Point2D.Double> points;\n-\n-        public Circle() {\n-            points  = new ArrayList<Point2D.Double>();\n-        }\n-\n-        public void addPoint(double px, double py) {\n-            points.add(new Point2D.Double(px, py));\n-        }\n-\n-        public double getRadius(Point2D.Double center) {\n-            double r = 0;\n-            for (Point2D.Double point : points) {\n-                r += point.distance(center);\n-            }\n-            return r / points.size();\n-        }\n-\n-        private double[] gradient(double[] point) {\n-\n-            // optimal radius\n-            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n-            double radius = getRadius(center);\n-\n-            // gradient of the sum of squared residuals\n-            double dJdX = 0;\n-            double dJdY = 0;\n-            for (Point2D.Double pk : points) {\n-                double dk = pk.distance(center);\n-                dJdX += (center.x - pk.x) * (dk - radius) / dk;\n-                dJdY += (center.y - pk.y) * (dk - radius) / dk;\n-            }\n-            dJdX *= 2;\n-            dJdY *= 2;\n-\n-            return new double[] { dJdX, dJdY };\n-\n-        }\n-\n-        public double value(double[] variables)\n-                throws IllegalArgumentException, MathUserException {\n-\n-            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n-            double radius = getRadius(center);\n-\n-            double sum = 0;\n-            for (Point2D.Double point : points) {\n-                double di = point.distance(center) - radius;\n-                sum += di * di;\n-            }\n-\n-            return sum;\n-\n-        }\n-\n-        public MultivariateVectorialFunction gradient() {\n-            return new MultivariateVectorialFunction() {\n-                private static final long serialVersionUID = 3174909643301201710L;\n-                public double[] value(double[] point) {\n-                    return gradient(point);\n-                }\n-            };\n-        }\n-\n-        public MultivariateRealFunction partialDerivative(final int k) {\n-            return new MultivariateRealFunction() {\n-                private static final long serialVersionUID = 3073956364104833888L;\n-                public double value(double[] point) {\n-                    return gradient(point)[k];\n-                }\n-            };\n-        }\n-\n-    }\n-\n+    }\n }", "timestamp": 1290702120, "metainfo": ""}