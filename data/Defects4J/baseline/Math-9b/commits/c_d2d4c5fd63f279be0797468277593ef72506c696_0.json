{"sha": "d2d4c5fd63f279be0797468277593ef72506c696", "log": "Added and used a specialized convergence exception for exceeded iteration counts  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n+package org.apache.commons.math;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+public class MaxIterationsExceededException extends ConvergenceException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -2154780004193976271L;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxIterations maximal number of iterations allowed\n+     */\n+    public MaxIterationsExceededException(int maxIterations) {\n+        super(\"Maximal number of iterations ({0}) exceeded\",\n+              new Object[] { new Integer(maxIterations) });\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument \n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MaxIterationsExceededException(int maxIterations,\n+                                          String pattern, Object[] arguments) {\n+        super(pattern, arguments);\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** Get the maximal number of iterations allowed.\n+     * @return maximal number of iterations allowed\n+     */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BisectionSolver.java\n package org.apache.commons.math.analysis;\n \n import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">\n public class BisectionSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 7137520585963699578L;\n-    \n+    private static final long serialVersionUID = 4963578633786538912L;\n+\n     /**\n      * Construct a solver for the given function.\n      * \n      * @param max the upper bound for the interval.\n      * @param initial the start value to use (ignored).\n      * @return the value where the function is zero\n-     * @throws ConvergenceException the maximum iteration count is exceeded \n+     * @throws MaxIterationsExceededException the maximum iteration count is exceeded \n      * @throws FunctionEvaluationException if an error occurs evaluating\n      *  the function\n      * @throws IllegalArgumentException if min is not less than max\n      */\n     public double solve(double min, double max, double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n           \n         return solve(min, max);\n     }\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded.\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function\n      * @throws IllegalArgumentException if min is not less than max\n      */\n-    public double solve(double min, double max) throws ConvergenceException,\n+    public double solve(double min, double max) throws MaxIterationsExceededException,\n         FunctionEvaluationException {\n         \n         clearResult();\n             ++i;\n         }\n         \n-        throw new ConvergenceException\n-            (\"Maximum number of iterations exceeded: \"  + maximalIterationCount);\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n package org.apache.commons.math.analysis;\n \n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n public class BrentSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 3350616277306882875L;\n+    private static final long serialVersionUID = -2136672307739067002L;\n \n     /**\n      * Construct a solver for the given function.\n      * @param max the upper bound for the interval.\n      * @param initial the start value to use (ignored).\n      * @return the value where the function is zero\n-     * @throws ConvergenceException the maximum iteration count is exceeded \n+     * @throws MaxIterationsExceededException the maximum iteration count is exceeded \n      * @throws FunctionEvaluationException if an error occurs evaluating\n      *  the function\n      * @throws IllegalArgumentException if initial is not between min and max\n      */\n     public double solve(double min, double max, double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n             \n         return solve(min, max);\n     }\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function \n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws ConvergenceException, \n+    public double solve(double min, double max) throws MaxIterationsExceededException, \n         FunctionEvaluationException {\n         \n         clearResult();\n             }\n             i++;\n         }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n--- a/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.complex.Complex;\n-import org.apache.commons.math.complex.ComplexUtils;\n-\n-/**\n- * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n- * Laguerre's Method</a> for root finding of real coefficient polynomials.\n- * For reference, see <b>A First Course in Numerical Analysis</b>,\n- * ISBN 048641454X, chapter 8.\n- * <p>\n- * Laguerre's method is global in the sense that it can start with any initial\n- * approximation and be able to solve all roots from that point.\n- *\n- * @version $Revision$ $Date$\n- */\n-public class LaguerreSolver extends UnivariateRealSolverImpl {\n-\n-    /** serializable version identifier */\n-    private static final long serialVersionUID = 5287689975005870178L;\n-\n-    /** polynomial function to solve */\n-    private PolynomialFunction p;\n-\n-    /**\n-     * Construct a solver for the given function.\n-     *\n-     * @param f function to solve\n-     * @throws IllegalArgumentException if function is not polynomial\n-     */\n-    public LaguerreSolver(UnivariateRealFunction f) throws\n-        IllegalArgumentException {\n-\n-        super(f, 100, 1E-6);\n-        if (f instanceof PolynomialFunction) {\n-            p = (PolynomialFunction)f;\n-        } else {\n-            throw new IllegalArgumentException(\"Function is not polynomial.\");\n-        }\n-    }\n-\n-    /**\n-     * Returns a copy of the polynomial function.\n-     * \n-     * @return a fresh copy of the polynomial function\n-     */\n-    public PolynomialFunction getPolynomialFunction() {\n-        return new PolynomialFunction(p.getCoefficients());\n-    }\n-\n-    /**\n-     * Find a real root in the given interval with initial value.\n-     * <p>\n-     * Requires bracketing condition.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(double min, double max, double initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n-\n-        // check for zeros before verifying bracketing\n-        if (p.value(min) == 0.0) { return min; }\n-        if (p.value(max) == 0.0) { return max; }\n-        if (p.value(initial) == 0.0) { return initial; }\n-\n-        verifyBracketing(min, max, p);\n-        verifySequence(min, initial, max);\n-        if (isBracketing(min, initial, p)) {\n-            return solve(min, initial);\n-        } else {\n-            return solve(initial, max);\n-        }\n-    }\n-\n-    /**\n-     * Find a real root in the given interval.\n-     * <p>\n-     * Despite the bracketing condition, the root returned by solve(Complex[],\n-     * Complex) may not be a real zero inside [min, max]. For example,\n-     * p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try\n-     * another initial value, or, as we did here, call solveAll() to obtain\n-     * all roots and pick up the one that we're looking for.\n-     *\n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(double min, double max) throws ConvergenceException, \n-        FunctionEvaluationException {\n-\n-        // check for zeros before verifying bracketing\n-        if (p.value(min) == 0.0) { return min; }\n-        if (p.value(max) == 0.0) { return max; }\n-        verifyBracketing(min, max, p);\n-\n-        double coefficients[] = p.getCoefficients();\n-        Complex c[] = new Complex[coefficients.length];\n-        for (int i = 0; i < coefficients.length; i++) {\n-            c[i] = new Complex(coefficients[i], 0.0);\n-        }\n-        Complex initial = new Complex(0.5 * (min + max), 0.0);\n-        Complex z = solve(c, initial);\n-        if (isRootOK(min, max, z)) {\n-            setResult(z.getReal(), iterationCount);\n-            return result;\n-        }\n-\n-        // solve all roots and select the one we're seeking\n-        Complex[] root = solveAll(c, initial);\n-        for (int i = 0; i < root.length; i++) {\n-            if (isRootOK(min, max, root[i])) {\n-                setResult(root[i].getReal(), iterationCount);\n-                return result;\n-            }\n-        }\n-\n-        // should never happen\n-        throw new ConvergenceException(\"Convergence failed.\");\n-    }\n-\n-    /**\n-     * Returns true iff the given complex root is actually a real zero\n-     * in the given interval, within the solver tolerance level.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param z the complex root\n-     * @return true iff z is the sought-after real zero\n-     */\n-    protected boolean isRootOK(double min, double max, Complex z) {\n-        double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n-        return (isSequence(min, z.getReal(), max)) &&\n-               (Math.abs(z.getImaginary()) <= tolerance ||\n-                z.abs() <= functionValueAccuracy);\n-    }\n-\n-    /**\n-     * Find all complex roots for the polynomial with the given coefficients,\n-     * starting from the given initial value.\n-     * \n-     * @param coefficients the polynomial coefficients array\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] solveAll(double coefficients[], double initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n-\n-        Complex c[] = new Complex[coefficients.length];\n-        Complex z = new Complex(initial, 0.0);\n-        for (int i = 0; i < c.length; i++) {\n-            c[i] = new Complex(coefficients[i], 0.0);\n-        }\n-        return solveAll(c, z);\n-    }\n-\n-    /**\n-     * Find all complex roots for the polynomial with the given coefficients,\n-     * starting from the given initial value.\n-     * \n-     * @param coefficients the polynomial coefficients array\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n-\n-        int n = coefficients.length - 1;\n-        int iterationCount = 0;\n-        if (n < 1) {\n-            throw new IllegalArgumentException\n-                (\"Polynomial degree must be positive: degree=\" + n);\n-        }\n-        Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n-        for (int i = 0; i <= n; i++) {\n-            c[i] = coefficients[i];\n-        }\n-\n-        // solve individual root successively\n-        Complex root[] = new Complex[n];\n-        for (int i = 0; i < n; i++) {\n-            Complex subarray[] = new Complex[n-i+1];\n-            System.arraycopy(c, 0, subarray, 0, subarray.length);\n-            root[i] = solve(subarray, initial);\n-            // polynomial deflation using synthetic division\n-            Complex newc = c[n-i];\n-            Complex oldc = null;\n-            for (int j = n-i-1; j >= 0; j--) {\n-                oldc = c[j];\n-                c[j] = newc;\n-                newc = oldc.add(newc.multiply(root[i]));\n-            }\n-            iterationCount += this.iterationCount;\n-        }\n-\n-        resultComputed = true;\n-        this.iterationCount = iterationCount;\n-        return root;\n-    }\n-\n-    /**\n-     * Find a complex root for the polynomial with the given coefficients,\n-     * starting from the given initial value.\n-     * \n-     * @param coefficients the polynomial coefficients array\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public Complex solve(Complex coefficients[], Complex initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n-\n-        int n = coefficients.length - 1;\n-        if (n < 1) {\n-            throw new IllegalArgumentException\n-                (\"Polynomial degree must be positive: degree=\" + n);\n-        }\n-        Complex N = new Complex((double)n, 0.0);\n-        Complex N1 = new Complex((double)(n-1), 0.0);\n-\n-        int i = 1;\n-        Complex pv = null;\n-        Complex dv = null;\n-        Complex d2v = null;\n-        Complex G = null;\n-        Complex G2 = null;\n-        Complex H = null;\n-        Complex delta = null;\n-        Complex denominator = null;\n-        Complex z = initial;\n-        Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n-        while (i <= maximalIterationCount) {\n-            // Compute pv (polynomial value), dv (derivative value), and\n-            // d2v (second derivative value) simultaneously.\n-            pv = coefficients[n];\n-            dv = Complex.ZERO;\n-            d2v = Complex.ZERO;\n-            for (int j = n-1; j >= 0; j--) {\n-                d2v = dv.add(z.multiply(d2v));\n-                dv = pv.add(z.multiply(dv));\n-                pv = coefficients[j].add(z.multiply(pv));\n-            }\n-            d2v = d2v.multiply(new Complex(2.0, 0.0));\n-\n-            // check for convergence\n-            double tolerance = Math.max(relativeAccuracy * z.abs(),\n-                                        absoluteAccuracy);\n-            if ((z.subtract(oldz)).abs() <= tolerance) {\n-                resultComputed = true;\n-                iterationCount = i;\n-                return z;\n-            }\n-            if (pv.abs() <= functionValueAccuracy) {\n-                resultComputed = true;\n-                iterationCount = i;\n-                return z;\n-            }\n-\n-            // now pv != 0, calculate the new approximation\n-            G = dv.divide(pv);\n-            G2 = G.multiply(G);\n-            H = G2.subtract(d2v.divide(pv));\n-            delta = N1.multiply((N.multiply(H)).subtract(G2));\n-            // choose a denominator larger in magnitude\n-            Complex dplus = G.add(ComplexUtils.sqrt(delta));\n-            Complex dminus = G.subtract(ComplexUtils.sqrt(delta));\n-            denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n-            // Perturb z if denominator is zero, for instance,\n-            // p(x) = x^3 + 1, z = 0.\n-            if (denominator.equals(new Complex(0.0, 0.0))) {\n-                z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));\n-                oldz = new Complex(Double.POSITIVE_INFINITY,\n-                                   Double.POSITIVE_INFINITY);\n-            } else {\n-                oldz = z;\n-                z = z.subtract(N.divide(denominator));\n-            }\n-            i++;\n-        }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.complex.ComplexUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n+ * Laguerre's Method</a> for root finding of real coefficient polynomials.\n+ * For reference, see <b>A First Course in Numerical Analysis</b>,\n+ * ISBN 048641454X, chapter 8.\n+ * <p>\n+ * Laguerre's method is global in the sense that it can start with any initial\n+ * approximation and be able to solve all roots from that point.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class LaguerreSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = -3775334783473775723L;\n+\n+    /** polynomial function to solve */\n+    private PolynomialFunction p;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     *\n+     * @param f function to solve\n+     * @throws IllegalArgumentException if function is not polynomial\n+     */\n+    public LaguerreSolver(UnivariateRealFunction f) throws\n+        IllegalArgumentException {\n+\n+        super(f, 100, 1E-6);\n+        if (f instanceof PolynomialFunction) {\n+            p = (PolynomialFunction)f;\n+        } else {\n+            throw new IllegalArgumentException(\"Function is not polynomial.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns a copy of the polynomial function.\n+     * \n+     * @return a fresh copy of the polynomial function\n+     */\n+    public PolynomialFunction getPolynomialFunction() {\n+        return new PolynomialFunction(p.getCoefficients());\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max, double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (p.value(min) == 0.0) { return min; }\n+        if (p.value(max) == 0.0) { return max; }\n+        if (p.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, p);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, p)) {\n+            return solve(min, initial);\n+        } else {\n+            return solve(initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Despite the bracketing condition, the root returned by solve(Complex[],\n+     * Complex) may not be a real zero inside [min, max]. For example,\n+     * p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try\n+     * another initial value, or, as we did here, call solveAll() to obtain\n+     * all roots and pick up the one that we're looking for.\n+     *\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (p.value(min) == 0.0) { return min; }\n+        if (p.value(max) == 0.0) { return max; }\n+        verifyBracketing(min, max, p);\n+\n+        double coefficients[] = p.getCoefficients();\n+        Complex c[] = new Complex[coefficients.length];\n+        for (int i = 0; i < coefficients.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        Complex initial = new Complex(0.5 * (min + max), 0.0);\n+        Complex z = solve(c, initial);\n+        if (isRootOK(min, max, z)) {\n+            setResult(z.getReal(), iterationCount);\n+            return result;\n+        }\n+\n+        // solve all roots and select the one we're seeking\n+        Complex[] root = solveAll(c, initial);\n+        for (int i = 0; i < root.length; i++) {\n+            if (isRootOK(min, max, root[i])) {\n+                setResult(root[i].getReal(), iterationCount);\n+                return result;\n+            }\n+        }\n+\n+        // should never happen\n+        throw new ConvergenceException();\n+    }\n+\n+    /**\n+     * Returns true iff the given complex root is actually a real zero\n+     * in the given interval, within the solver tolerance level.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param z the complex root\n+     * @return true iff z is the sought-after real zero\n+     */\n+    protected boolean isRootOK(double min, double max, Complex z) {\n+        double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n+        return (isSequence(min, z.getReal(), max)) &&\n+               (Math.abs(z.getImaginary()) <= tolerance ||\n+                z.abs() <= functionValueAccuracy);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(double coefficients[], double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        Complex c[] = new Complex[coefficients.length];\n+        Complex z = new Complex(initial, 0.0);\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        return solveAll(c, z);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        int n = coefficients.length - 1;\n+        int iterationCount = 0;\n+        if (n < 1) {\n+            throw new IllegalArgumentException\n+                (\"Polynomial degree must be positive: degree=\" + n);\n+        }\n+        Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n+        for (int i = 0; i <= n; i++) {\n+            c[i] = coefficients[i];\n+        }\n+\n+        // solve individual root successively\n+        Complex root[] = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            Complex subarray[] = new Complex[n-i+1];\n+            System.arraycopy(c, 0, subarray, 0, subarray.length);\n+            root[i] = solve(subarray, initial);\n+            // polynomial deflation using synthetic division\n+            Complex newc = c[n-i];\n+            Complex oldc = null;\n+            for (int j = n-i-1; j >= 0; j--) {\n+                oldc = c[j];\n+                c[j] = newc;\n+                newc = oldc.add(newc.multiply(root[i]));\n+            }\n+            iterationCount += this.iterationCount;\n+        }\n+\n+        resultComputed = true;\n+        this.iterationCount = iterationCount;\n+        return root;\n+    }\n+\n+    /**\n+     * Find a complex root for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex solve(Complex coefficients[], Complex initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        int n = coefficients.length - 1;\n+        if (n < 1) {\n+            throw new IllegalArgumentException\n+                (\"Polynomial degree must be positive: degree=\" + n);\n+        }\n+        Complex N = new Complex((double)n, 0.0);\n+        Complex N1 = new Complex((double)(n-1), 0.0);\n+\n+        int i = 1;\n+        Complex pv = null;\n+        Complex dv = null;\n+        Complex d2v = null;\n+        Complex G = null;\n+        Complex G2 = null;\n+        Complex H = null;\n+        Complex delta = null;\n+        Complex denominator = null;\n+        Complex z = initial;\n+        Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        while (i <= maximalIterationCount) {\n+            // Compute pv (polynomial value), dv (derivative value), and\n+            // d2v (second derivative value) simultaneously.\n+            pv = coefficients[n];\n+            dv = Complex.ZERO;\n+            d2v = Complex.ZERO;\n+            for (int j = n-1; j >= 0; j--) {\n+                d2v = dv.add(z.multiply(d2v));\n+                dv = pv.add(z.multiply(dv));\n+                pv = coefficients[j].add(z.multiply(pv));\n+            }\n+            d2v = d2v.multiply(new Complex(2.0, 0.0));\n+\n+            // check for convergence\n+            double tolerance = Math.max(relativeAccuracy * z.abs(),\n+                                        absoluteAccuracy);\n+            if ((z.subtract(oldz)).abs() <= tolerance) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+            if (pv.abs() <= functionValueAccuracy) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+\n+            // now pv != 0, calculate the new approximation\n+            G = dv.divide(pv);\n+            G2 = G.multiply(G);\n+            H = G2.subtract(d2v.divide(pv));\n+            delta = N1.multiply((N.multiply(H)).subtract(G2));\n+            // choose a denominator larger in magnitude\n+            Complex dplus = G.add(ComplexUtils.sqrt(delta));\n+            Complex dminus = G.subtract(ComplexUtils.sqrt(delta));\n+            denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n+            // Perturb z if denominator is zero, for instance,\n+            // p(x) = x^3 + 1, z = 0.\n+            if (denominator.equals(new Complex(0.0, 0.0))) {\n+                z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));\n+                oldz = new Complex(Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY);\n+            } else {\n+                oldz = z;\n+                z = z.subtract(N.divide(denominator));\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/MullerSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/MullerSolver.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.util.MathUtils;\n-\n-/**\n- * Implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n- * Muller's Method</a> for root finding of real univariate functions. For\n- * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,\n- * chapter 3.\n- * <p>\n- * Muller's method applies to both real and complex functions, but here we\n- * restrict ourselves to real functions. Methods solve() and solve2() find\n- * real zeros, using different ways to bypass complex arithmetics.\n- *\n- * @version $Revision$ $Date$\n- */\n-public class MullerSolver extends UnivariateRealSolverImpl {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = 2619993603551148137L;\n-\n-    /**\n-     * Construct a solver for the given function.\n-     * \n-     * @param f function to solve\n-     */\n-    public MullerSolver(UnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n-     * Find a real root in the given interval with initial value.\n-     * <p>\n-     * Requires bracketing condition.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(double min, double max, double initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n-\n-        // check for zeros before verifying bracketing\n-        if (f.value(min) == 0.0) { return min; }\n-        if (f.value(max) == 0.0) { return max; }\n-        if (f.value(initial) == 0.0) { return initial; }\n-\n-        verifyBracketing(min, max, f);\n-        verifySequence(min, initial, max);\n-        if (isBracketing(min, initial, f)) {\n-            return solve(min, initial);\n-        } else {\n-            return solve(initial, max);\n-        }\n-    }\n-\n-    /**\n-     * Find a real root in the given interval.\n-     * <p>\n-     * Original Muller's method would have function evaluation at complex point.\n-     * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n-     * condition is one way to go: by requiring bracketing in every iteration,\n-     * the newly computed approximation is guaranteed to be real.\n-     * <p>\n-     * Normally Muller's method converges quadratically in the vicinity of a\n-     * zero, however it may be very slow in regions far away from zeros. For\n-     * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n-     * bisection as a safety backup if it performs very poorly.\n-     * <p>\n-     * The formulas here use divided differences directly.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(double min, double max) throws ConvergenceException, \n-        FunctionEvaluationException {\n-\n-        // [x0, x2] is the bracketing interval in each iteration\n-        // x1 is the last approximation and an interpolation point in (x0, x2)\n-        // x is the new root approximation and new x1 for next round\n-        // d01, d12, d012 are divided differences\n-        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n-        double d01, d12, d012, c1, delta, xplus, xminus, tolerance;\n-\n-        x0 = min; y0 = f.value(x0);\n-        x2 = max; y2 = f.value(x2);\n-        x1 = 0.5 * (x0 + x2); y1 = f.value(x1);\n-\n-        // check for zeros before verifying bracketing\n-        if (y0 == 0.0) { return min; }\n-        if (y2 == 0.0) { return max; }\n-        verifyBracketing(min, max, f);\n-\n-        int i = 1;\n-        oldx = Double.POSITIVE_INFINITY;\n-        while (i <= maximalIterationCount) {\n-            // Muller's method employs quadratic interpolation through\n-            // x0, x1, x2 and x is the zero of the interpolating parabola.\n-            // Due to bracketing condition, this parabola must have two\n-            // real roots and we choose one in [x0, x2] to be x.\n-            d01 = (y1 - y0) / (x1 - x0);\n-            d12 = (y2 - y1) / (x2 - x1);\n-            d012 = (d12 - d01) / (x2 - x0);\n-            c1 = d01 + (x1 - x0) * d012;\n-            delta = c1 * c1 - 4 * y1 * d012;\n-            xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n-            xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n-            // xplus and xminus are two roots of parabola and at least\n-            // one of them should lie in (x0, x2)\n-            x = isSequence(x0, xplus, x2) ? xplus : xminus;\n-            y = f.value(x);\n-\n-            // check for convergence\n-            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n-            if (Math.abs(x - oldx) <= tolerance) {\n-                setResult(x, i);\n-                return result;\n-            }\n-            if (Math.abs(y) <= functionValueAccuracy) {\n-                setResult(x, i);\n-                return result;\n-            }\n-\n-            // Bisect if convergence is too slow. Bisection would waste\n-            // our calculation of x, hopefully it won't happen often.\n-            boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||\n-                             (x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||\n-                             (x == x1);\n-            // prepare the new bracketing interval for next iteration\n-            if (!bisect) {\n-                x0 = x < x1 ? x0 : x1;\n-                y0 = x < x1 ? y0 : y1;\n-                x2 = x > x1 ? x2 : x1;\n-                y2 = x > x1 ? y2 : y1;\n-                x1 = x; y1 = y;\n-                oldx = x;\n-            } else {\n-                double xm = 0.5 * (x0 + x2);\n-                double ym = f.value(xm);\n-                if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {\n-                    x2 = xm; y2 = ym;\n-                } else {\n-                    x0 = xm; y0 = ym;\n-                }\n-                x1 = 0.5 * (x0 + x2);\n-                y1 = f.value(x1);\n-                oldx = Double.POSITIVE_INFINITY;\n-            }\n-            i++;\n-        }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n-    }\n-\n-    /**\n-     * Find a real root in the given interval.\n-     * <p>\n-     * solve2() differs from solve() in the way it avoids complex operations.\n-     * Except for the initial [min, max], solve2() does not require bracketing\n-     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n-     * number arises in the computation, we simply use its modulus as real\n-     * approximation.\n-     * <p>\n-     * Because the interval may not be bracketing, bisection alternative is\n-     * not applicable here. However in practice our treatment usually works\n-     * well, especially near real zeros where the imaginary part of complex\n-     * approximation is often negligible.\n-     * <p>\n-     * The formulas here do not use divided differences directly.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve2(double min, double max) throws ConvergenceException, \n-        FunctionEvaluationException {\n-\n-        // x2 is the last root approximation\n-        // x is the new approximation and new x2 for next round\n-        // x0 < x1 < x2 does not hold here\n-        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n-        double q, A, B, C, delta, denominator, tolerance;\n-\n-        x0 = min; y0 = f.value(x0);\n-        x1 = max; y1 = f.value(x1);\n-        x2 = 0.5 * (x0 + x1); y2 = f.value(x2);\n-\n-        // check for zeros before verifying bracketing\n-        if (y0 == 0.0) { return min; }\n-        if (y1 == 0.0) { return max; }\n-        verifyBracketing(min, max, f);\n-\n-        int i = 1;\n-        oldx = Double.POSITIVE_INFINITY;\n-        while (i <= maximalIterationCount) {\n-            // quadratic interpolation through x0, x1, x2\n-            q = (x2 - x1) / (x1 - x0);\n-            A = q * (y2 - (1 + q) * y1 + q * y0);\n-            B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n-            C = (1 + q) * y2;\n-            delta = B * B - 4 * A * C;\n-            if (delta >= 0.0) {\n-                // choose a denominator larger in magnitude\n-                double dplus = B + Math.sqrt(delta);\n-                double dminus = B - Math.sqrt(delta);\n-                denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;\n-            } else {\n-                // take the modulus of (B +/- Math.sqrt(delta))\n-                denominator = Math.sqrt(B * B - delta);\n-            }\n-            if (denominator != 0) {\n-                x = x2 - 2.0 * C * (x2 - x1) / denominator;\n-                // perturb x if it coincides with x1 or x2\n-                while (x == x1 || x == x2) {\n-                    x += absoluteAccuracy;\n-                }\n-            } else {\n-                // extremely rare case, get a random number to skip it\n-                x = min + Math.random() * (max - min);\n-                oldx = Double.POSITIVE_INFINITY;\n-            }\n-            y = f.value(x);\n-\n-            // check for convergence\n-            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n-            if (Math.abs(x - oldx) <= tolerance) {\n-                setResult(x, i);\n-                return result;\n-            }\n-            if (Math.abs(y) <= functionValueAccuracy) {\n-                setResult(x, i);\n-                return result;\n-            }\n-\n-            // prepare the next iteration\n-            x0 = x1; y0 = y1;\n-            x1 = x2; y1 = y2;\n-            x2 = x; y2 = y;\n-            oldx = x;\n-            i++;\n-        }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n+ * Muller's Method</a> for root finding of real univariate functions. For\n+ * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,\n+ * chapter 3.\n+ * <p>\n+ * Muller's method applies to both real and complex functions, but here we\n+ * restrict ourselves to real functions. Methods solve() and solve2() find\n+ * real zeros, using different ways to bypass complex arithmetics.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class MullerSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = 6552227503458976920L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     */\n+    public MullerSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max, double initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(min, initial);\n+        } else {\n+            return solve(initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Original Muller's method would have function evaluation at complex point.\n+     * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n+     * condition is one way to go: by requiring bracketing in every iteration,\n+     * the newly computed approximation is guaranteed to be real.\n+     * <p>\n+     * Normally Muller's method converges quadratically in the vicinity of a\n+     * zero, however it may be very slow in regions far away from zeros. For\n+     * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n+     * bisection as a safety backup if it performs very poorly.\n+     * <p>\n+     * The formulas here use divided differences directly.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max) throws MaxIterationsExceededException, \n+        FunctionEvaluationException {\n+\n+        // [x0, x2] is the bracketing interval in each iteration\n+        // x1 is the last approximation and an interpolation point in (x0, x2)\n+        // x is the new root approximation and new x1 for next round\n+        // d01, d12, d012 are divided differences\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double d01, d12, d012, c1, delta, xplus, xminus, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x2 = max; y2 = f.value(x2);\n+        x1 = 0.5 * (x0 + x2); y1 = f.value(x1);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // Muller's method employs quadratic interpolation through\n+            // x0, x1, x2 and x is the zero of the interpolating parabola.\n+            // Due to bracketing condition, this parabola must have two\n+            // real roots and we choose one in [x0, x2] to be x.\n+            d01 = (y1 - y0) / (x1 - x0);\n+            d12 = (y2 - y1) / (x2 - x1);\n+            d012 = (d12 - d01) / (x2 - x0);\n+            c1 = d01 + (x1 - x0) * d012;\n+            delta = c1 * c1 - 4 * y1 * d012;\n+            xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n+            xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n+            // xplus and xminus are two roots of parabola and at least\n+            // one of them should lie in (x0, x2)\n+            x = isSequence(x0, xplus, x2) ? xplus : xminus;\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // Bisect if convergence is too slow. Bisection would waste\n+            // our calculation of x, hopefully it won't happen often.\n+            boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||\n+                             (x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||\n+                             (x == x1);\n+            // prepare the new bracketing interval for next iteration\n+            if (!bisect) {\n+                x0 = x < x1 ? x0 : x1;\n+                y0 = x < x1 ? y0 : y1;\n+                x2 = x > x1 ? x2 : x1;\n+                y2 = x > x1 ? y2 : y1;\n+                x1 = x; y1 = y;\n+                oldx = x;\n+            } else {\n+                double xm = 0.5 * (x0 + x2);\n+                double ym = f.value(xm);\n+                if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {\n+                    x2 = xm; y2 = ym;\n+                } else {\n+                    x0 = xm; y0 = ym;\n+                }\n+                x1 = 0.5 * (x0 + x2);\n+                y1 = f.value(x1);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * solve2() differs from solve() in the way it avoids complex operations.\n+     * Except for the initial [min, max], solve2() does not require bracketing\n+     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+     * number arises in the computation, we simply use its modulus as real\n+     * approximation.\n+     * <p>\n+     * Because the interval may not be bracketing, bisection alternative is\n+     * not applicable here. However in practice our treatment usually works\n+     * well, especially near real zeros where the imaginary part of complex\n+     * approximation is often negligible.\n+     * <p>\n+     * The formulas here do not use divided differences directly.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve2(double min, double max) throws MaxIterationsExceededException, \n+        FunctionEvaluationException {\n+\n+        // x2 is the last root approximation\n+        // x is the new approximation and new x2 for next round\n+        // x0 < x1 < x2 does not hold here\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double q, A, B, C, delta, denominator, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x1 = max; y1 = f.value(x1);\n+        x2 = 0.5 * (x0 + x1); y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y1 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // quadratic interpolation through x0, x1, x2\n+            q = (x2 - x1) / (x1 - x0);\n+            A = q * (y2 - (1 + q) * y1 + q * y0);\n+            B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n+            C = (1 + q) * y2;\n+            delta = B * B - 4 * A * C;\n+            if (delta >= 0.0) {\n+                // choose a denominator larger in magnitude\n+                double dplus = B + Math.sqrt(delta);\n+                double dminus = B - Math.sqrt(delta);\n+                denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;\n+            } else {\n+                // take the modulus of (B +/- Math.sqrt(delta))\n+                denominator = Math.sqrt(B * B - delta);\n+            }\n+            if (denominator != 0) {\n+                x = x2 - 2.0 * C * (x2 - x1) / denominator;\n+                // perturb x if it coincides with x1 or x2\n+                while (x == x1 || x == x2) {\n+                    x += absoluteAccuracy;\n+                }\n+            } else {\n+                // extremely rare case, get a random number to skip it\n+                x = min + Math.random() * (max - min);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the next iteration\n+            x0 = x1; y0 = y1;\n+            x1 = x2; y1 = y2;\n+            x2 = x; y2 = y;\n+            oldx = x;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/NewtonSolver.java\n package org.apache.commons.math.analysis;\n \n import java.io.IOException;\n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException; \n+import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n  * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n public class NewtonSolver extends UnivariateRealSolverImpl {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 2606474895443431607L;\n-    \n+    private static final long serialVersionUID = 2067325783137941016L;\n+\n     /** The first derivative of the target function. */\n     private transient UnivariateRealFunction derivative;\n     \n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded \n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function or derivative\n      * @throws IllegalArgumentException if min is not less than max\n      */\n-    public double solve(double min, double max) throws ConvergenceException, \n+    public double solve(double min, double max) throws MaxIterationsExceededException, \n         FunctionEvaluationException  {\n         return solve(min, max, UnivariateRealSolverUtils.midpoint(min, max));\n     }\n      * @param max the upper bound for the interval (ignored).\n      * @param startValue the start value to use.\n      * @return the value where the function is zero\n-    * @throws ConvergenceException if the maximum iteration count is exceeded \n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function or derivative\n      * @throws IllegalArgumentException if startValue is not between min and max\n      */\n     public double solve(double min, double max, double startValue)\n-        throws ConvergenceException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n         \n         clearResult();\n         verifySequence(min, startValue, max);\n             ++i;\n         }\n         \n-        throw new ConvergenceException\n-            (\"Maximum number of iterations exceeded \" + i);\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.FunctionEvaluationException;\n-import org.apache.commons.math.util.MathUtils;\n-\n-/**\n- * Implements the <a href=\"http://mathworld.wolfram.com/RiddersMethod.html\">\n- * Ridders' Method</a> for root finding of real univariate functions. For\n- * reference, see C. Ridders, <i>A new algorithm for computing a single root\n- * of a real continuous function </i>, IEEE Transactions on Circuits and\n- * Systems, 26 (1979), 979 - 980.\n- * <p>\n- * The function should be continuous but not necessarily smooth.\n- *  \n- * @version $Revision$ $Date$\n- */\n-public class RiddersSolver extends UnivariateRealSolverImpl {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = -4703139035737911735L;\n-\n-    /**\n-     * Construct a solver for the given function.\n-     * \n-     * @param f function to solve\n-     */\n-    public RiddersSolver(UnivariateRealFunction f) {\n-        super(f, 100, 1E-6);\n-    }\n-\n-    /**\n-     * Find a root in the given interval with initial value.\n-     * <p>\n-     * Requires bracketing condition.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @param initial the start value to use\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(double min, double max, double initial) throws\n-        ConvergenceException, FunctionEvaluationException {\n-\n-        // check for zeros before verifying bracketing\n-        if (f.value(min) == 0.0) { return min; }\n-        if (f.value(max) == 0.0) { return max; }\n-        if (f.value(initial) == 0.0) { return initial; }\n-\n-        verifyBracketing(min, max, f);\n-        verifySequence(min, initial, max);\n-        if (isBracketing(min, initial, f)) {\n-            return solve(min, initial);\n-        } else {\n-            return solve(initial, max);\n-        }\n-    }\n-\n-    /**\n-     * Find a root in the given interval.\n-     * <p>\n-     * Requires bracketing condition.\n-     * \n-     * @param min the lower bound for the interval\n-     * @param max the upper bound for the interval\n-     * @return the point at which the function value is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n-     * or the solver detects convergence problems otherwise\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public double solve(double min, double max) throws ConvergenceException, \n-        FunctionEvaluationException {\n-\n-        // [x1, x2] is the bracketing interval in each iteration\n-        // x3 is the midpoint of [x1, x2]\n-        // x is the new root approximation and an endpoint of the new interval\n-        double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;\n-\n-        x1 = min; y1 = f.value(x1);\n-        x2 = max; y2 = f.value(x2);\n-\n-        // check for zeros before verifying bracketing\n-        if (y1 == 0.0) { return min; }\n-        if (y2 == 0.0) { return max; }\n-        verifyBracketing(min, max, f);\n-\n-        int i = 1;\n-        oldx = Double.POSITIVE_INFINITY;\n-        while (i <= maximalIterationCount) {\n-            // calculate the new root approximation\n-            x3 = 0.5 * (x1 + x2);\n-            y3 = f.value(x3);\n-            if (Math.abs(y3) <= functionValueAccuracy) {\n-                setResult(x3, i);\n-                return result;\n-            }\n-            delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n-            correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n-                         (x3 - x1) / Math.sqrt(delta);\n-            x = x3 - correction;                // correction != 0\n-            y = f.value(x);\n-\n-            // check for convergence\n-            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n-            if (Math.abs(x - oldx) <= tolerance) {\n-                setResult(x, i);\n-                return result;\n-            }\n-            if (Math.abs(y) <= functionValueAccuracy) {\n-                setResult(x, i);\n-                return result;\n-            }\n-\n-            // prepare the new interval for next iteration\n-            // Ridders' method guarantees x1 < x < x2\n-            if (correction > 0.0) {             // x1 < x < x3\n-                if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {\n-                    x2 = x; y2 = y;\n-                } else {\n-                    x1 = x; x2 = x3;\n-                    y1 = y; y2 = y3;\n-                }\n-            } else {                            // x3 < x < x2\n-                if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {\n-                    x1 = x; y1 = y;\n-                } else {\n-                    x1 = x3; x2 = x;\n-                    y1 = y3; y2 = y;\n-                }\n-            }\n-            oldx = x;\n-            i++;\n-        }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/RiddersMethod.html\">\n+ * Ridders' Method</a> for root finding of real univariate functions. For\n+ * reference, see C. Ridders, <i>A new algorithm for computing a single root\n+ * of a real continuous function </i>, IEEE Transactions on Circuits and\n+ * Systems, 26 (1979), 979 - 980.\n+ * <p>\n+ * The function should be continuous but not necessarily smooth.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public class RiddersSolver extends UnivariateRealSolverImpl {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = -4703139035737911735L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     */\n+    public RiddersSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Find a root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max, double initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(min, initial);\n+        } else {\n+            return solve(initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a root in the given interval.\n+     * <p>\n+     * Requires bracketing condition.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(double min, double max) throws MaxIterationsExceededException, \n+        FunctionEvaluationException {\n+\n+        // [x1, x2] is the bracketing interval in each iteration\n+        // x3 is the midpoint of [x1, x2]\n+        // x is the new root approximation and an endpoint of the new interval\n+        double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;\n+\n+        x1 = min; y1 = f.value(x1);\n+        x2 = max; y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y1 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // calculate the new root approximation\n+            x3 = 0.5 * (x1 + x2);\n+            y3 = f.value(x3);\n+            if (Math.abs(y3) <= functionValueAccuracy) {\n+                setResult(x3, i);\n+                return result;\n+            }\n+            delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n+            correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n+                         (x3 - x1) / Math.sqrt(delta);\n+            x = x3 - correction;                // correction != 0\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the new interval for next iteration\n+            // Ridders' method guarantees x1 < x < x2\n+            if (correction > 0.0) {             // x1 < x < x3\n+                if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {\n+                    x2 = x; y2 = y;\n+                } else {\n+                    x1 = x; x2 = x3;\n+                    y1 = y; y2 = y3;\n+                }\n+            } else {                            // x3 < x < x2\n+                if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {\n+                    x1 = x; y1 = y;\n+                } else {\n+                    x1 = x3; x2 = x;\n+                    y1 = y3; y2 = y;\n+                }\n+            }\n+            oldx = x;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/RombergIntegration.html\">\n public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n \n     /** serializable version identifier */\n-    static final long serialVersionUID = -1058849527738180243L;\n+    private static final long serialVersionUID = -1058849527738180243L;\n \n     /**\n      * Construct an integrator for the given function.\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value of integral\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the integrator detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double integrate(double min, double max) throws ConvergenceException,\n+    public double integrate(double min, double max) throws MaxIterationsExceededException,\n         FunctionEvaluationException, IllegalArgumentException {\n         \n         int i = 1, j, m = maximalIterationCount + 1;\n             olds = s;\n             i++;\n         }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n \n \n /**\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 1984971194738974867L;\n-    \n+\n     /**\n      * Construct a solver for the given function.\n      * @param f function to solve.\n      * @param max the upper bound for the interval\n      * @param initial the start value to use (ignored)\n      * @return the value where the function is zero\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function \n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n     public double solve(double min, double max, double initial)\n-        throws ConvergenceException, FunctionEvaluationException {\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n             \n         return solve(min, max);\n     }\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n-     * @throws ConvergenceException  if the maximum iteration count is exceeded\n+     * @throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function \n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws ConvergenceException, \n+    public double solve(double min, double max) throws MaxIterationsExceededException, \n         FunctionEvaluationException {\n         \n         clearResult();\n             oldDelta = x2 - x1;\n             i++;\n         }\n-        throw new ConvergenceException(\"Maximal iteration number exceeded\" + i);\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/SimpsonsRule.html\">\n public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n \n     /** serializable version identifier */\n-    static final long serialVersionUID = 3405465123320678216L;\n+    private static final long serialVersionUID = 3405465123320678216L;\n \n     /**\n      * Construct an integrator for the given function.\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value of integral\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the integrator detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double integrate(double min, double max) throws ConvergenceException,\n+    public double integrate(double min, double max) throws MaxIterationsExceededException,\n         FunctionEvaluationException, IllegalArgumentException {\n         \n         int i = 1;\n             oldt = t;\n             i++;\n         }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n  */\n package org.apache.commons.math.analysis;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/TrapezoidalRule.html\">\n public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n \n     /** serializable version identifier */\n-    static final long serialVersionUID = 4978222553983172543L;\n+    private static final long serialVersionUID = 4978222553983172543L;\n \n     /** intermediate result */\n     private double s;\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value of integral\n-     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the integrator detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n-    public double integrate(double min, double max) throws ConvergenceException,\n+    public double integrate(double min, double max) throws MaxIterationsExceededException,\n         FunctionEvaluationException, IllegalArgumentException {\n         \n         int i = 1;\n             oldt = t;\n             i++;\n         }\n-        throw new ConvergenceException(\"Maximum number of iterations exceeded.\");\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.util.ContinuedFraction;\n \n /**\n  */\n public class Gamma implements Serializable {\n     \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6587513359895466954L;\n+\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 10e-9;\n \n                 sum = sum + an;\n             }\n             if (n >= maxIterations) {\n-                throw new ConvergenceException(\n-                    \"maximum number of iterations reached\");\n+                throw new MaxIterationsExceededException(maxIterations);\n             } else {\n                 ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n             }\n         } else {\n             // create continued fraction\n             ContinuedFraction cf = new ContinuedFraction() {\n+\n+                private static final long serialVersionUID = 5378525034886164398L;\n+\n                 protected double getA(int n, double x) {\n                     return ((2.0 * n) + 1.0) - a + x;\n                 }\n--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n \n /**\n  * Provides a generic means to evaluate continued fractions.  Subclasses simply\n                 } else {\n                     // can not scale an convergent is unbounded.\n                     throw new ConvergenceException(\n-                        \"Continued fraction convergents diverged to +/- \" +\n-                        \"infinity.\");\n+                        \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+                        new Object[] { new Double(x) });\n                 }\n             }\n             double r = p2 / q2;\n         }\n \n         if (n >= maxIterations) {\n-            throw new ConvergenceException(\n-                \"Continued fraction convergents failed to converge.\");\n+            throw new MaxIterationsExceededException(maxIterations,\n+                \"Continued fraction convergents failed to converge for value {0}\",\n+                new Object[] { new Double(x) });\n         }\n \n         return c;\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision:$\n+ */\n+public class MaxIterationsExceededExceptionTest extends TestCase {\n+    \n+    public void testConstructor(){\n+        MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);\n+        assertNull(ex.getCause());\n+        assertNotNull(ex.getMessage());\n+        assertTrue(ex.getMessage().indexOf(\"1,000,000\") > 0);\n+        assertEquals(1000000, ex.getMaxIterations());\n+        assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n+    }\n+    \n+}", "timestamp": 1171307861, "metainfo": ""}