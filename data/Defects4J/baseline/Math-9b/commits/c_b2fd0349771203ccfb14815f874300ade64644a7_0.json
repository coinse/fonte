{"sha": "b2fd0349771203ccfb14815f874300ade64644a7", "log": "* DoubleArray is now an interface which is implemented by ExpandableDoubleArray.  The interface provides a public interface which does not hint at any of the storage parameters of Expandable or Contractable.  * DoubleArrayTest now operates on the DoubleArray interface, casting to Expandable when we need to call the package scopes getInternalLength method.  * While we should not provide access to the internal storage array, it should be possible to obtain a double[] of elements stored in this DoubleArray - double[] getElements() was added to the DoubleArray interface, it will return the element array.   ", "commit": "\n--- a/src/java/org/apache/commons/math/ContractableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ContractableDoubleArray.java\n \t * \n \t * @return value to be added to end of array\n \t */\n-\tpublic synchronized void addElementRolling(double value) {\n-\t\tsuper.addElementRolling(value);\n+\tpublic synchronized double addElementRolling(double value) {\n+\t\tdouble discarded = super.addElementRolling(value);\n \t\t// Check the contraction criteria\n \t\tif( shouldContract() ) {\n \t\t\tcontract();\n \t\t}\n+\t\treturn discarded;\n \t}\n \t\n \t/**\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/DoubleArray.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Provides an interface to implemntations which function as an array\n+ * of double primitives.\n+ * \n+ * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n+ */\n+public interface DoubleArray {\n+\n+\t/**\n+\t * Returns the number of elements currently in the array.  Please note\n+\t * that this is different from the length of the internal storage array.  \n+\t * @return number of elements\n+\t */\n+\tpublic abstract int getNumElements();\n+\n+\t/**\n+\t * Returns the element at the specified index\n+\t * \n+\t * @param index index to fetch a value from\n+\t * @return value stored at the specified index\n+\t */\n+\tpublic abstract double getElement(int index) throws NoSuchElementException;\n+\n+\t/**\n+\t * Sets the element at the specified index.  This method will expand the internal storage array to\n+\t * accomodate the insertion of a value at an index beyond the current capacity.\n+\t * @param index index to store a value in\n+\t * @param value value to store at the specified index\n+\t */\n+\tpublic abstract void setElement(int index, double value);\n+\n+\t/**\n+\t * Adds an element to the end of this expandable array\n+\t * \n+\t * @return value to be added to end of array\n+\t */\n+\tpublic abstract void addElement(double value);\n+\n+\t/**\n+\t * Adds an element and moves the window of elements up one.  This\n+\t * has the effect of a FIFO.  when you \"roll\" the array an element is removed \n+\t * from the array.  The return value of this function is the discarded double.\n+\t * \n+\t * @return the value which has been discarded or \"pushed\" out of the array\n+\t * \t  by this rolling insert.\n+\t */\n+\tpublic abstract double addElementRolling(double value);\n+\t\n+\t/**\n+\t * Returns a double[] of elements\n+\t */\n+\tpublic abstract double[] getElements();\n+\t\n+\t/**\n+\t * Clear the double array\n+\t */\n+\tpublic abstract void clear();\n+\n+\t/**\n+\t * Discards values from the front of the list.  This function removes n elements from\n+\t * the front of the array.\n+\t * \n+\t * @param i number of elements to discard from the front of the array.\n+\t */\n+\tpublic abstract void discardFrontElements(int i);\n+}\n--- a/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n-public class ExpandableDoubleArray implements Serializable {\n+public class ExpandableDoubleArray implements Serializable, DoubleArray {\n \n \t// This is the internal storage array.\n \tprotected double[] internalArray;\n \t\n \t/**\n \t * Adds an element and moves the window of elements up one.  This\n-\t * has the effect of a FIFO\n-\t */\n-\tpublic synchronized void addElementRolling(double value) {\n+\t * has the effect of a FIFO.  when you \"roll\" the array an element is removed \n+\t * from the array.  The return value of this function is the discarded double.\n+\t * \n+\t * @return the value which has been discarded or \"pushed\" out of the array\n+\t * \t  by this rolling insert.\n+\t */\n+\tpublic synchronized double addElementRolling(double value) {\n+\t\tdouble discarded = internalArray[startIndex];\n+\t\t\n \t\tif ( (startIndex + (numElements+1) ) > internalArray.length) {\n \t\t\texpand();\n \t\t}\n \t\t\n \t\t// Add the new value\n \t\tinternalArray[startIndex + (numElements -1)] = value;\n+\t\t\n+\t\treturn discarded;\n \t}\n \n \n \t\t}\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getElements()\n+\t */\n+\tpublic double[] getElements() {\n+\t\tdouble[] elementArray = new double[numElements];\n+\t\tSystem.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\n+\t\treturn elementArray;\n+\t}\n+\n }\n--- a/src/test/org/apache/commons/math/ContractableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/ContractableDoubleArrayTest.java\n \t * @see junit.framework.TestCase#setUp()\n \t */\n \tprotected void setUp() throws Exception {\n-\t\teDA = new ContractableDoubleArray();\n+\t\tda = new ContractableDoubleArray();\n \t}\n \n \t/** Test normal operations and then test internal storage */\n \t\tsuper.testAdd1000();\n \t\tassertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n \t\t\t\"16 and an expansion factor of 2.0\",\n-\t\t\t\t\t\t\t1024, eDA.getInternalLength());\n+\t\t\t\t\t\t\t1024, ((ExpandableDoubleArray) da).getInternalLength());\n \t}\n \t\n \tpublic void testSetElementArbitraryExpansion() {\n \t\tsuper.testSetElementArbitraryExpansion();\n-\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", eDA.getInternalLength(), 1001);\n+\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", ((ExpandableDoubleArray) da).getInternalLength(), 1001);\n \t}\n \n \tpublic void testAddElementRolling() {\n \t\tsuper.testAddElementRolling();\n \t\tassertTrue( \"Even though there are only 6 element, internal storage should be less than 2.5 times the number of elements\", \n-\t\t\teDA.getInternalLength() < ((int) 6 * 2.5) );\n+\t\t\t((ExpandableDoubleArray) da).getInternalLength() < ((int) 6 * 2.5) );\n \t}\n \n \n--- a/src/test/org/apache/commons/math/DoubleArrayAbstractTest.java\n+++ b/src/test/org/apache/commons/math/DoubleArrayAbstractTest.java\n  */\n public abstract class DoubleArrayAbstractTest extends TestCase {\n \n-\tprotected ExpandableDoubleArray eDA = null;\n+\tprotected DoubleArray da = null;\n \n \tpublic DoubleArrayAbstractTest(String name) {\n \t\tsuper( name );\n \tpublic void testAdd1000() {\n \n \t\tfor( int i = 0; i < 1000; i++) {\n-\t\t\teDA.addElement( i );\n+\t\t\tda.addElement( i );\n \t\t}\n \t\t\n \t\tassertEquals(\"Number of elements should be equal to 1000 after adding 1000 values\",\n-\t\t\t\t\t\t\t1000, eDA.getNumElements() );\n+\t\t\t\t\t\t\t1000, da.getNumElements() );\n \t\t\t\t\t\t\t\n \t\t\t\t\t\t    \n \t\tassertEquals(\"The element at the 56th index should be 56\", \n-\t\t\t\t\t\t\t56.0, eDA.getElement(56), Double.MIN_VALUE );\n+\t\t\t\t\t\t\t56.0, da.getElement(56), Double.MIN_VALUE );\n \t\t\t\t\t\t    \n \t}\n \t\n \tpublic void testGetValues() {\n \t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n \t\t\n-\t\teDA.addElement(2.0);\n-\t\teDA.addElement(4.0);\n-\t\teDA.addElement(6.0);\n-\t\tdouble[] testArray = eDA.getValues();\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(4.0);\n+\t\tda.addElement(6.0);\n+\t\tdouble[] testArray = da.getElements();\n \t\t\n-\t\tfor( int i = 0; i < eDA.getNumElements(); i++) {\n+\t\tfor( int i = 0; i < da.getNumElements(); i++) {\n \t\t\tassertEquals( \"The testArray values should equal the controlArray values, index i: \" + i +\n \t\t\t\t\" does not match\", testArray[i], controlArray[i], Double.MIN_VALUE);\n \t\t}\n \tpublic void testSetElementArbitraryExpansion() {\n \t\tdouble[] controlArray = {2.0, 4.0, 6.0};\n \t\t\n-\t\teDA.addElement(2.0);\n-\t\teDA.addElement(4.0);\n-\t\teDA.addElement(6.0);\n-\t\teDA.setElement(1, 3.0);\n+\t\tda.addElement(2.0);\n+\t\tda.addElement(4.0);\n+\t\tda.addElement(6.0);\n+\t\tda.setElement(1, 3.0);\n \t\t\n \t\t// Expand the array arbitrarily to 1000 items\n-\t\teDA.setElement(1000, 3.4);\n+\t\tda.setElement(1000, 3.4);\n \n-\t\tassertEquals( \"The number of elements should now be 1001, it isn't\", eDA.getNumElements(), 1001);\n+\t\tassertEquals( \"The number of elements should now be 1001, it isn't\", da.getNumElements(), 1001);\n \t\t\n \t\tassertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n-\t\t\t\t\t\t\teDA.getElement( 760 ), Double.MIN_VALUE );\n+\t\t\t\t\t\t\tda.getElement( 760 ), Double.MIN_VALUE );\n \t\t\n-\t\tassertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, eDA.getElement(1000), Double.MIN_VALUE );\n-\t\tassertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, eDA.getElement(0), Double.MIN_VALUE);\t\t\n+\t\tassertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000), Double.MIN_VALUE );\n+\t\tassertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0), Double.MIN_VALUE);\t\t\n \t\t\n \t}\n \t\n \tpublic void testSetNumberOfElements() {\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\tassertEquals( \"Number of elements should equal 6\", eDA.getNumElements(), 6);\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tassertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n \t\t\n-\t\teDA.setNumElements( 3 );\n-\t\tassertEquals( \"Number of elements should equal 3\", eDA.getNumElements(), 3);\n+\t\t((ExpandableDoubleArray) da).setNumElements( 3 );\n+\t\tassertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n \t\t\n \t\ttry {\n-\t\t\teDA.setNumElements( -3 );\n+\t\t\t((ExpandableDoubleArray) da).setNumElements( -3 );\n \t\t\tfail( \"Setting number of elements to negative should've thrown an exception\");\n \t\t} catch( IllegalArgumentException iae ) {\n \t\t}\n \n-\t\teDA.setNumElements(1024);\n-\t\tassertEquals( \"Number of elements should now be 1024\", eDA.getNumElements(), 1024);\n-\t\tassertEquals( \"Element 453 should be a default double\", eDA.getElement( 453 ), 0.0, Double.MIN_VALUE);\n+\t\t((ExpandableDoubleArray) da).setNumElements(1024);\n+\t\tassertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n+\t\tassertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n \t\t\t\t\n \t}\n \t\n \tpublic void testAddElementRolling() {\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElement( 1.0 );\n-\t\teDA.addElementRolling( 2.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElement( 1.0 );\n+\t\tda.addElementRolling( 2.0 );\n \t\t\n-\t\tassertEquals( \"There should be 6 elements in the eda\", eDA.getNumElements(), 6);\n-\t\tassertEquals( \"The last element should be 2.0\", eDA.getElement( eDA.getNumElements() -1 ), 2.0, Double.MIN_VALUE);\n+\t\tassertEquals( \"There should be 6 elements in the eda\", da.getNumElements(), 6);\n+\t\tassertEquals( \"The last element should be 2.0\", da.getElement( da.getNumElements() -1 ), 2.0, Double.MIN_VALUE);\n \t\t\n \t\tfor( int i = 0; i  < 1024; i++ ) {\n-\t\t\teDA.addElementRolling( i );\n+\t\t\tda.addElementRolling( i );\n \t\t}\n \t\t\n-\t\tassertEquals( \"We just inserted 1024 rolling elements, num elements should still be 6\", eDA.getNumElements(), 6);\n+\t\tassertEquals( \"We just inserted 1024 rolling elements, num elements should still be 6\", da.getNumElements(), 6);\n \t\t\t\t\n \t}\n \n--- a/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/ExpandableDoubleArrayTest.java\n \t * @see junit.framework.TestCase#setUp()\n \t */\n \tprotected void setUp() throws Exception {\n-\t\teDA = new ExpandableDoubleArray();\n+\t\tda = new ExpandableDoubleArray();\n \t}\n \n \t/* (non-Javadoc)\n \t * @see junit.framework.TestCase#tearDown()\n \t */\n \tprotected void tearDown() throws Exception {\n-\t\teDA = null;\n+\t\tda = null;\n \t}\n \t\n \t\n \t\tsuper.testAdd1000();\n \t\tassertEquals(\"Internal Storage length should be 1024 if we started out with initial capacity of \" +\n \t\t\t\"16 and an expansion factor of 2.0\",\n-\t\t\t\t\t\t\t1024, eDA.getInternalLength());\n+\t\t\t\t\t\t\t1024, ((ExpandableDoubleArray) da).getInternalLength());\n \t}\n \t\n \tpublic void testSetElementArbitraryExpansion() {\n \t\tsuper.testSetElementArbitraryExpansion();\n-\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", eDA.getInternalLength(), 1001);\n+\t\tassertEquals( \"The length of the internal array should now be 1001, it isn't\", ((ExpandableDoubleArray) da).getInternalLength(), 1001);\n \t}\n \n \tpublic void testAddElementRolling() {\n \t\tsuper.testAddElementRolling();\n-\t\tassertEquals( \"Even though there are only 6 element, internal storage should be 2048\", eDA.getInternalLength(), 2048);\n+\t\tassertEquals( \"Even though there are only 6 element, internal storage should be 2048\", ((ExpandableDoubleArray) da).getInternalLength(), 2048);\n \t}\n \n \t/** TESTS WHICH FOCUS ON ExpandableSpecific internal storage */", "timestamp": 1053058986, "metainfo": ""}