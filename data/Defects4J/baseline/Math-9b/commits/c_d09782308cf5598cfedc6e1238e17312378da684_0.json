{"sha": "d09782308cf5598cfedc6e1238e17312378da684", "log": "moved multistep integrator and step interpolator base classes to their corresponding generic package  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.events.EventException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.events.EventState;\n+import org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator;\n+import org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.FixedStepHandler;\n+import org.apache.commons.math.ode.sampling.MultistepStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepNormalizer;\n+\n+/**\n+ * This class is the base class for multistep integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * @see AdamsBashforthIntegrator\n+ * @see AdamsMoultonIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class MultistepIntegrator extends AbstractIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1705864253238417163L;\n+\n+    /** Starter integrator. */\n+    private FirstOrderIntegrator starter;\n+\n+    /** Previous steps times. */\n+    protected double[] previousT;\n+\n+    /** Previous steps derivatives. */\n+    protected double[][] previousF;\n+\n+    /** Time of last detected reset. */\n+    private double resetTime;\n+\n+    /** Prototype of the step interpolator. */\n+    protected MultistepStepInterpolator prototype;\n+                                           \n+    /**\n+     * Build a multistep integrator with the given number of steps.\n+     * <p>The default starter integrator is set to the {@link\n+     * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n+     * some defaults settings.</p>\n+     * @param name name of the method\n+     * @param k number of steps of the multistep method\n+     * (including the one being computed)\n+     * @param prototype prototype of the step interpolator to use\n+     */\n+    protected MultistepIntegrator(final String name, final int k,\n+                                  final MultistepStepInterpolator prototype) {\n+        super(name);\n+        starter = new DormandPrince853Integrator(1.0e-6, 1.0e6, 1.0e-5, 1.0e-6);\n+        previousT = new double[k];\n+        previousF = new double[k][];\n+        this.prototype = prototype;\n+    }\n+\n+    /**\n+     * Get the starter integrator.\n+     * @return starter integrator\n+     */\n+    public ODEIntegrator getStarterIntegrator() {\n+        return starter;\n+    }\n+\n+    /**\n+     * Set the starter integrator.\n+     * <p>The various step and event handlers for this starter integrator\n+     * will be managed automatically by the multi-step integrator. Any\n+     * user configuration for these elements will be cleared before use.</p>\n+     * @param starter starter integrator\n+     */\n+    public void setStarterIntegrator(FirstOrderIntegrator starter) {\n+        this.starter = starter;\n+    }\n+\n+    /** Start the integration.\n+     * <p>This method computes the first few steps of the multistep method,\n+     * using the underlying starter integrator, ensuring the returned steps\n+     * all belong to the same smooth range.</p>\n+     * <p>In order to ensure smoothness, the start phase is automatically\n+     * restarted when a state or derivative reset is triggered by the\n+     * registered events handlers before this start phase is completed. As\n+     * an example, consider integrating a differential equation from t=0\n+     * to t=100 with a 4 steps method and step size equal to 0.2. If an event\n+     * resets the state at t=0.5, the start phase will not end at t=0.6 with\n+     * steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps\n+     * at [0.5, 0.7, 0.9, 1.1].</p>\n+     * <p>A side effect of the need for smoothness is that an ODE triggering\n+     * short period regular resets will remain in the start phase throughout\n+     * the integration range if the step size or the number of steps to store\n+     * are too large.</p>\n+     * <p>If the start phase ends prematurely (because of some triggered event\n+     * for example), then the time of latest previous steps will be set to\n+     * <code>Double.NaN</code>.</p>\n+     * @param n number of steps to store\n+     * @param h signed step size to use for the first steps\n+     * @param manager discrete events manager to use\n+     * @param equations differential equations to integrate\n+     * @param t0 initial time\n+     * @param y state vector: contains the initial value of the state vector at t0,\n+     * will be used to put the state vector at each successful step and hence\n+     * contains the final value at the end of the start phase\n+     * @return time of the end of the start phase\n+     * @throws IntegratorException if the integrator cannot perform integration\n+     * @throws DerivativeException this exception is propagated to the caller if\n+     * the underlying user function triggers one\n+     */\n+    protected double start(final int n, final double h,\n+                           final CombinedEventsManager manager,\n+                           final FirstOrderDifferentialEquations equations,\n+                           final double t0, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        // clear the first steps\n+        Arrays.fill(previousT, Double.NaN);\n+        Arrays.fill(previousF, null);\n+\n+        // configure the event handlers\n+        starter.clearEventHandlers();\n+        for (EventState state : manager.getEventsStates()) {\n+            starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),\n+                                    state.getMaxCheckInterval(),\n+                                    state.getConvergence(), state.getMaxIterationCount());\n+        }\n+\n+        // configure the step handlers\n+        starter.clearStepHandlers();\n+        for (final StepHandler handler : stepHandlers) {\n+            // add the user defined step handlers, filtering out the isLast indicator\n+            starter.addStepHandler(new FilteringWrapper(handler));\n+        }\n+\n+        // add one specific step handler to store the first steps\n+        final StoringStepHandler store = new StoringStepHandler(n);\n+        starter.addStepHandler(new StepNormalizer(h, store));\n+\n+        // integrate over the first few steps, ensuring no intermediate reset occurs\n+        double t = t0;\n+        double stopTime = Double.NaN;\n+        do {\n+            resetTime = Double.NaN;\n+            store.restart();\n+            // we overshoot by 1/10000 step the end to make sure we don't miss the last point\n+            stopTime = starter.integrate(equations, t, y, t + (n - 0.9999) * h, y);\n+            if (!Double.isNaN(resetTime)) {\n+                // there was an intermediate reset, we restart\n+                t = resetTime;\n+            }\n+        } while (!Double.isNaN(resetTime));\n+\n+        // clear configuration\n+        starter.clearEventHandlers();\n+        starter.clearStepHandlers();\n+\n+        if (store.getFinalState() != null) {\n+            System.arraycopy(store.getFinalState(), 0, y, 0, y.length);\n+        }\n+        return stopTime;\n+\n+    }\n+\n+    /** Rotate the previous steps arrays.\n+     */\n+    protected void rotatePreviousSteps() {\n+        final double[] rolled = previousF[previousT.length - 1];\n+        for (int k = previousF.length - 1; k > 0; --k) {\n+            previousT[k] = previousT[k - 1];\n+            previousF[k] = previousF[k - 1];\n+        }\n+        previousF[0] = rolled;\n+    }\n+\n+    /** Event handler wrapper to check if state or derivatives have been reset. */\n+    private class ResetCheckingWrapper implements EventHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4922660285376467937L;\n+\n+        /** Wrapped event handler. */\n+        private final EventHandler handler;\n+\n+        /** Build a new instance.\n+         * @param handler event handler to wrap\n+         */\n+        public ResetCheckingWrapper(final EventHandler handler) {\n+            this.handler = handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int eventOccurred(double t, double[] y) throws EventException {\n+            final int action = handler.eventOccurred(t, y);\n+            if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {\n+                // a singularity has been encountered\n+                // we need to restart the start phase\n+                resetTime = t;\n+                return STOP;\n+            }\n+            return action;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double g(double t, double[] y) throws EventException {\n+            return handler.g(t, y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void resetState(double t, double[] y) throws EventException {\n+            handler.resetState(t, y);\n+        }\n+        \n+    }\n+\n+    /** Step handler wrapper filtering out the isLast indicator. */\n+    private class FilteringWrapper implements StepHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4607975253344802232L;\n+\n+        /** Wrapped step handler. */\n+        private final StepHandler handler;\n+\n+        /** Build a new instance.\n+         * @param handler step handler to wrap\n+         */\n+        public FilteringWrapper(final StepHandler handler) {\n+            this.handler = handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+                throws DerivativeException {\n+            // we force the isLast indicator to false EXCEPT if some event handler triggered a stop\n+            handler.handleStep(interpolator, eventsHandlersManager.stop());\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean requiresDenseOutput() {\n+            return handler.requiresDenseOutput();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void reset() {\n+            handler.reset();\n+        }\n+        \n+    }\n+\n+    /** Specialized step handler storing the first few steps. */\n+    private class StoringStepHandler implements FixedStepHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4592974435520688797L;\n+\n+        /** Number of steps to store. */\n+        private final int n;\n+\n+        /** Counter for already stored steps. */\n+        private int count;\n+\n+        /** Final state. */\n+        private double[] finalState;\n+\n+        /** Build a new instance.\n+         * @param n number of steps to store\n+         */\n+        public StoringStepHandler(final int n) {\n+            this.n = n;\n+            restart();\n+        }\n+\n+        /** Restart storage.\n+         */\n+        public void restart() {\n+            count = 0;\n+            finalState = null;\n+        }\n+\n+        /** Get the final state.\n+         * @return final state\n+         */\n+        public double[] getFinalState() {\n+            return finalState;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(final double t, final double[] y, final double[] yDot,\n+                               final boolean isLast) {\n+            if (count++ < n) {\n+                previousT[n - count] = t;\n+                previousF[n - count] = yDot.clone();\n+                if (count == n) {\n+                    finalState = y.clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n \n     /** Compute the backward differences coefficients array.\n      * <p>This is quite similar to the Pascal triangle containing the\n-     * binomial coefficiens, except for an additional (-1)<sup>i</sup> sign.\n+     * binomial coefficients, except for an additional (-1)<sup>i</sup> sign.\n      * We use a straightforward approach here, since we don't expect this to\n      * be run too many times with too high k. It is based on the recurrence\n      * relations:</p>\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthStepInterpolator.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.MultistepStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.StepHandler;\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonStepInterpolator.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.MultistepStepInterpolator;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/MultistepStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for multistep integrators.\n+ *\n+ * @see MultistepIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public abstract class MultistepStepInterpolator\n+    extends AbstractStepInterpolator {\n+\n+    /** Previous steps times. */\n+    protected double[] previousT;\n+\n+    /** Previous steps derivatives. */\n+    protected double[][] previousF;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link #reinitialize} method should be called before using the\n+     * instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases. The {@link MultistepIntegrator} classe uses the\n+     * prototyping design pattern to create the step interpolators by\n+     * cloning an uninitialized model and latter initializing the copy.\n+     */\n+    protected MultistepStepInterpolator() {\n+        previousT = null;\n+        previousF = null;\n+    }\n+\n+    /** Copy constructor.\n+\n+     * <p>The copied interpolator should have been finalized before the\n+     * copy, otherwise the copy will not be able to perform correctly any\n+     * interpolation and will throw a {@link NullPointerException}\n+     * later. Since we don't want this constructor to throw the\n+     * exceptions finalization may involve and since we don't want this\n+     * method to modify the state of the copied interpolator,\n+     * finalization is <strong>not</strong> done automatically, it\n+     * remains under user control.</p>\n+\n+     * <p>The copy is a deep copy: its arrays are separated from the\n+     * original arrays of the instance.</p>\n+\n+     * @param interpolator interpolator to copy from.\n+\n+     */\n+    public MultistepStepInterpolator(final MultistepStepInterpolator interpolator) {\n+\n+        super(interpolator);\n+\n+        if (interpolator.currentState != null) {\n+            previousT = interpolator.previousT.clone();\n+            previousF = new double[interpolator.previousF.length][];\n+            for (int k = 0; k < interpolator.previousF.length; ++k) {\n+                previousF[k] = interpolator.previousF[k].clone();\n+            }\n+            initializeCoefficients();\n+        } else {\n+            previousT = null;\n+            previousF = null;\n+        }\n+\n+    }\n+\n+    /** Reinitialize the instance\n+     * @param y reference to the integrator array holding the state at\n+     * the end of the step\n+     * @param previousT reference to the integrator array holding the times\n+     * of the previous steps\n+     * @param previousF reference to the integrator array holding the\n+     * previous slopes\n+     * @param forward integration direction indicator\n+     */\n+    public void reinitialize(final double[] y,\n+                             final double[] previousT, final double[][] previousF,\n+                             final boolean forward) {\n+        reinitialize(y, forward);\n+        this.previousT = previousT;\n+        this.previousF = previousF;\n+        initializeCoefficients();\n+    }\n+\n+    /** Initialize the coefficients arrays.\n+     */\n+    protected abstract void initializeCoefficients();\n+\n+    /** {@inheritDoc} */\n+    public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+        // save the state of the base class\n+        writeBaseExternal(out);\n+\n+        // save the local attributes\n+        out.writeInt(previousT.length);\n+        for (int k = 0; k < previousF.length; ++k) {\n+            out.writeDouble(previousT[k]);\n+            for (int i = 0; i < currentState.length; ++i) {\n+                out.writeDouble(previousF[k][i]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+        // read the base class \n+        final double t = readBaseExternal(in);\n+\n+        // read the local attributes\n+        final int kMax = in.readInt();\n+        previousT = new double[kMax];\n+        previousF = new double[kMax][];\n+        for (int k = 0; k < kMax; ++k) {\n+            previousT[k] = in.readDouble();\n+            previousF[k] = new double[currentState.length];\n+            for (int i = 0; i < currentState.length; ++i) {\n+                previousF[k][i] = in.readDouble();\n+            }\n+        }\n+\n+        // initialize the coefficients\n+        initializeCoefficients();\n+\n+        try {\n+            // we can now set the interpolated time and state\n+            setInterpolatedTime(t);\n+        } catch (DerivativeException e) {\n+            throw MathRuntimeException.createIOException(e);\n+        }\n+\n+    }\n+\n+}", "timestamp": 1238686185, "metainfo": ""}