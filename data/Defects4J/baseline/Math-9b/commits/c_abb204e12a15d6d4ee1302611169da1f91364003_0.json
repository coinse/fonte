{"sha": "abb204e12a15d6d4ee1302611169da1f91364003", "log": "MATH-860 Matrix \"block inversion\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math3/linear/MatrixUtils.java\n             }\n         }\n     }\n+\n+    /**\n+     * Computes the inverse of the given matrix by splitting it into\n+     * 4 sub-matrices.\n+     *\n+     * @param m Matrix whose inverse must be computed.\n+     * @param splitIndex Index that determines the \"split\" line and\n+     * column.\n+     * The element corresponding to this index will part of the\n+     * upper-left sub-matrix.\n+     * @return the inverse of {@code m}.\n+     * @throws NonSquareMatrixException if {@code m} is not square.\n+     */\n+    public static RealMatrix blockInverse(RealMatrix m,\n+                                          int splitIndex) {\n+        final int n = m.getRowDimension();\n+        if (m.getColumnDimension() != n) {\n+            throw new NonSquareMatrixException(m.getRowDimension(),\n+                                               m.getColumnDimension());\n+        }\n+\n+        final int splitIndex1 = splitIndex + 1;\n+\n+        final RealMatrix a = m.getSubMatrix(0, splitIndex, 0, splitIndex);\n+        final RealMatrix b = m.getSubMatrix(0, splitIndex, splitIndex1, n - 1);\n+        final RealMatrix c = m.getSubMatrix(splitIndex1, n - 1, 0, splitIndex);\n+        final RealMatrix d = m.getSubMatrix(splitIndex1, n - 1, splitIndex1, n - 1);\n+\n+        final SingularValueDecomposition aDec = new SingularValueDecomposition(a);\n+        final RealMatrix aInv = aDec.getSolver().getInverse();\n+\n+        final SingularValueDecomposition dDec = new SingularValueDecomposition(d);\n+        final RealMatrix dInv = dDec.getSolver().getInverse();\n+\n+        final RealMatrix tmp1 = a.subtract(b.multiply(dInv).multiply(c));\n+        final SingularValueDecomposition tmp1Dec = new SingularValueDecomposition(tmp1);\n+        final RealMatrix result00 = tmp1Dec.getSolver().getInverse();\n+\n+        final RealMatrix tmp2 = d.subtract(c.multiply(aInv).multiply(b));\n+        final SingularValueDecomposition tmp2Dec = new SingularValueDecomposition(tmp2);\n+        final RealMatrix result11 = tmp2Dec.getSolver().getInverse();\n+\n+        final RealMatrix result01 = aInv.multiply(b).multiply(result11).scalarMultiply(-1);\n+        final RealMatrix result10 = dInv.multiply(c).multiply(result00).scalarMultiply(-1);\n+\n+        final RealMatrix result = new Array2DRowRealMatrix(n, n);\n+        result.setSubMatrix(result00.getData(), 0, 0);\n+        result.setSubMatrix(result01.getData(), 0, splitIndex1);\n+        result.setSubMatrix(result10.getData(), splitIndex1, 0);\n+        result.setSubMatrix(result11.getData(), splitIndex1, splitIndex1);\n+\n+        return result;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/linear/MatrixUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/MatrixUtilsTest.java\n         MatrixUtils.solveUpperTriangularSystem(rm, b);\n         TestUtils.assertEquals( new double[]{-1,3,1}  , b.toArray() , 1.0e-12);\n     }\n+\n+    /**\n+     * This test should probably be replaced by one that could show\n+     * whether this algorithm can sometimes perform better (precision- or\n+     * performance-wise) than the direct inversion of the whole matrix.\n+     */\n+    @Test\n+    public void testBlockInverse() {\n+        final double[][] data = {\n+            { -1, 0, 123, 4 },\n+            { -56, 78.9, -0.1, -23.4 },\n+            { 5.67, 8, -9, 1011 },\n+            { 12, 345, -67.8, 9 },\n+        };\n+\n+        final RealMatrix m = new Array2DRowRealMatrix(data);\n+        final int len = data.length;\n+        final double tol = 1e-14;\n+\n+        for (int splitIndex = 0; splitIndex < 3; splitIndex++) {\n+            final RealMatrix mInv = MatrixUtils.blockInverse(m, splitIndex);\n+            final RealMatrix id = m.multiply(mInv);\n+\n+            // Check that we recovered the identity matrix.\n+            for (int i = 0; i < len; i++) {\n+                for (int j = 0; j < len; j++) {\n+                    final double entry = id.getEntry(i, j);\n+                    if (i == j) {\n+                        Assert.assertEquals(\"[\" + i + \"][\" + j + \"]\",\n+                                            1, entry, tol);\n+                    } else {\n+                        Assert.assertEquals(\"[\" + i + \"][\" + j + \"]\",\n+                                            0, entry, tol);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n-", "timestamp": 1348242066, "metainfo": ""}