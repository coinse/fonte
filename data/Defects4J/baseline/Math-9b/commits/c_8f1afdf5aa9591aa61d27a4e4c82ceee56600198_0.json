{"sha": "8f1afdf5aa9591aa61d27a4e4c82ceee56600198", "log": "New implementation of the pdf of Gamma distributions. Solves MATH-753. Additional unit tests to come.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n      * @since 2.1\n      */\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -3239549463135430361L;\n+\n     /** The shape parameter. */\n     private final double alpha;\n+\n     /** The scale parameter. */\n     private final double beta;\n+\n+    /**\n+     * The constant value of {@code alpha + g + 0.5}, where {@code alpha} is\n+     * the shape parameter, and {@code g} is the Lanczos constant\n+     * {@link Gamma#LANCZOS_G}.\n+     */\n+    private final double shiftedShape;\n+\n+    /**\n+     * The constant value of\n+     * {@code alpha / beta * sqrt(e / (2 * pi * (alpha + g + 0.5))) / L(alpha)},\n+     * where {@code alpha} is the shape parameter, {@code beta} is the scale\n+     * parameter, and {@code L(alpha)} is the Lanczos approximation returned by\n+     * {@link Gamma#lanczos(double)}. This prefactor is used in\n+     * {@link #density(double)}, when no overflow occurs with the natural\n+     * calculation.\n+     */\n+    private final double densityPrefactor1;\n+\n+    /**\n+     * The constant value of\n+     * {@code alpha * sqrt(e / (2 * pi * (alpha + g + 0.5))) / L(alpha)},\n+     * where {@code alpha} is the shape parameter, and {@code L(alpha)} is the\n+     * Lanczos approximation returned by {@link Gamma#lanczos(double)}. This\n+     * prefactor is used in {@link #density(double)}, when overflow occurs with\n+     * the natural calculation.\n+     */\n+    private final double densityPrefactor2;\n+\n+    /**\n+     * Lower bound on {@code y = x / beta} for the selection of the computation\n+     * method in {@link #density(double)}. For {@code y <= minY}, the natural\n+     * calculation overflows. {@code beta} is the shape parameter.\n+     */\n+    private final double minY;\n+\n+    /**\n+     * Upper bound on {@code log(y)} ({@code y = x / beta}) for the selection of\n+     * the computation method in {@link #density(double)}. For\n+     * {@code log(y) >= maxLogY}, the natural calculation overflows.\n+     * {@code beta} is the shape parameter.\n+     */\n+    private final double maxLogY;\n+\n     /** Inverse cumulative probability accuracy. */\n     private final double solverAbsoluteAccuracy;\n \n \n         this.alpha = alpha;\n         this.beta = beta;\n-        solverAbsoluteAccuracy = inverseCumAccuracy;\n+        this.solverAbsoluteAccuracy = inverseCumAccuracy;\n+        this.shiftedShape = alpha + Gamma.LANCZOS_G + 0.5;\n+        final double aux = FastMath.E / (2.0 * FastMath.PI * shiftedShape);\n+        this.densityPrefactor2 = alpha * FastMath.sqrt(aux) / Gamma.lanczos(alpha);\n+        this.densityPrefactor1 = this.densityPrefactor2 / beta *\n+                FastMath.pow(shiftedShape, -alpha) *\n+                FastMath.exp(alpha + Gamma.LANCZOS_G);\n+        this.minY = alpha + Gamma.LANCZOS_G - FastMath.log(Double.MAX_VALUE);\n+        this.maxLogY = FastMath.log(Double.MAX_VALUE) / (alpha - 1.0);\n     }\n \n     /**\n \n     /** {@inheritDoc} */\n     public double density(double x) {\n+       /* The present method must return the value of\n+        *\n+        *     1       x a     - x\n+        * ---------- (-)  exp(---)\n+        * x Gamma(a)  b        b\n+        *\n+        * where a is the shape parameter, and b the scale parameter.\n+        * Substituting the Lanczos approximation of Gamma(a) leads to the\n+        * following expression of the density\n+        *\n+        * a              e            1         y      a\n+        * - sqrt(------------------) ---- (-----------)  exp(a - y + g),\n+        * x      2 pi (a + g + 0.5)  L(a)  a + g + 0.5\n+        *\n+        * where y = x / b. The above formula is the \"natural\" computation, which\n+        * is implemented when no overflow is likely to occur. If overflow occurs\n+        * with the natural computation, the following identity is used. It is\n+        * based on the BOOST library\n+        * http://www.boost.org/doc/libs/1_35_0/libs/math/doc/sf_and_dist/html/math_toolkit/special/sf_gamma/igamma.html\n+        * Formula (15) needs adaptations, which are detailed below.\n+        *\n+        *       y      a\n+        * (-----------)  exp(a - y + g)\n+        *  a + g + 0.5\n+        *                              y - a - g - 0.5    y (g + 0.5)\n+        *               = exp(a log1pm(---------------) - ----------- + g),\n+        *                                a + g + 0.5      a + g + 0.5\n+        *\n+        *  where log1pm(z) = log(1 + z) - z. Therefore, the value to be\n+        *  returned is\n+        *\n+        * a              e            1\n+        * - sqrt(------------------) ----\n+        * x      2 pi (a + g + 0.5)  L(a)\n+        *                              y - a - g - 0.5    y (g + 0.5)\n+        *               * exp(a log1pm(---------------) - ----------- + g).\n+        *                                a + g + 0.5      a + g + 0.5\n+        */\n         if (x < 0) {\n             return 0;\n         }\n-        return FastMath.pow(x / beta, alpha - 1) / beta *\n-               FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n+        final double y = x / beta;\n+        if ((y <= minY) || (FastMath.log(y) >= maxLogY)) {\n+            /*\n+             * Overflow.\n+             */\n+            final double aux1 = (y - shiftedShape) / shiftedShape;\n+            final double aux2 = alpha * (FastMath.log1p(aux1) - aux1);\n+            final double aux3 = -y * (Gamma.LANCZOS_G + 0.5) / shiftedShape +\n+                    Gamma.LANCZOS_G + aux2;\n+            return densityPrefactor2 / x * FastMath.exp(aux3);\n+        }\n+        /*\n+         * Natural calculation.\n+         */\n+        return densityPrefactor1  * FastMath.exp(-y) *\n+                FastMath.pow(y, alpha - 1);\n     }\n \n     /**", "timestamp": 1337062913, "metainfo": ""}