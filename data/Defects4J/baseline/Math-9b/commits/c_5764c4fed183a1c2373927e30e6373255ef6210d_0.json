{"sha": "5764c4fed183a1c2373927e30e6373255ef6210d", "log": "fixed a dimension error with under-determined problems removed IllegalStateException create a DenseRealMatrix when solving A.X = B  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n \n /**\n         final int m = matrix.getRowDimension();\n         final int n = matrix.getColumnDimension();\n         qrt = matrix.transpose().getData();\n-        rDiag = new double[n];\n+        rDiag = new double[Math.min(m, n)];\n         cachedQ  = null;\n         cachedQT = null;\n         cachedR  = null;\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getQ()\n-        throws IllegalStateException {\n+    public RealMatrix getQ() {\n         if (cachedQ == null) {\n             cachedQ = getQT().transpose();\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getQT()\n-        throws IllegalStateException {\n+    public RealMatrix getQT() {\n \n         if (cachedQT == null) {\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getH()\n-        throws IllegalStateException {\n+    public RealMatrix getH() {\n \n         if (cachedH == null) {\n \n         }\n \n         /** {@inheritDoc} */\n-        public boolean isNonSingular()\n-        throws IllegalStateException {\n+        public boolean isNonSingular() {\n \n             for (double diag : rDiag) {\n                 if (diag == 0) {\n \n         /** {@inheritDoc} */\n         public double[] solve(double[] b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalArgumentException, InvalidMatrixException {\n \n             final int n = qrt.length;\n             final int m = qrt[0].length;\n             if (b.length != m) {\n-                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        new Object[] { b.length, m });\n             }\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n             }\n \n             // solve triangular system R.x = y\n-            for (int row = n - 1; row >= 0; --row) {\n+            for (int row = rDiag.length - 1; row >= 0; --row) {\n                 y[row] /= rDiag[row];\n                 final double yRow   = y[row];\n                 final double[] qrtRow = qrt[row];\n \n         /** {@inheritDoc} */\n         public RealVector solve(RealVector b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalArgumentException, InvalidMatrixException {\n             try {\n                 return solve((RealVectorImpl) b);\n             } catch (ClassCastException cce) {\n          * <p>The A matrix is implicit here. It is </p>\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n-         * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-         * has not been called\n          * @throws IllegalArgumentException if matrices dimensions don't match\n          * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealVectorImpl solve(RealVectorImpl b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalArgumentException, InvalidMatrixException {\n             return new RealVectorImpl(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n         public RealMatrix solve(RealMatrix b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        throws IllegalArgumentException, InvalidMatrixException {\n \n             final int n = qrt.length;\n             final int m = qrt[0].length;\n             if (b.getRowDimension() != m) {\n-                throw new IllegalArgumentException(\"Incorrect row dimension\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        new Object[] { b.getRowDimension(), b.getColumnDimension(), m, \"n\"});\n             }\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n             }\n \n-            final int cols = b.getColumnDimension();\n-            final double[][] xData = new double[n][cols];\n-            final double[] y = new double[b.getRowDimension()];\n-\n-            for (int k = 0; k < cols; ++k) {\n+            final int columns        = b.getColumnDimension();\n+            final int blockSize      = DenseRealMatrix.BLOCK_SIZE;\n+            final int cBlocks        = (columns + blockSize - 1) / blockSize;\n+            final double[][] xBlocks = DenseRealMatrix.createBlocksLayout(n, columns);\n+            final double[][] y       = new double[b.getRowDimension()][blockSize];\n+            final double[]   alpha   = new double[blockSize];\n+\n+            for (int kBlock = 0; kBlock < cBlocks; ++kBlock) {\n+                final int kStart = kBlock * blockSize;\n+                final int kEnd   = Math.min(kStart + blockSize, columns);\n+                final int kWidth = kEnd - kStart;\n \n                 // get the right hand side vector\n-                for (int j = 0; j < y.length; ++j) {\n-                    y[j] = b.getEntry(j, k);\n-                }\n+                b.copySubMatrix(0, m - 1, kStart, kEnd - 1, y);\n \n                 // apply Householder transforms to solve Q.y = b\n                 for (int minor = 0; minor < Math.min(m, n); minor++) {\n-\n                     final double[] qrtMinor = qrt[minor];\n-                    double dotProduct = 0;\n-                    for (int row = minor; row < m; row++) {\n-                        dotProduct += y[row] * qrtMinor[row];\n-                    }\n-                    dotProduct /= rDiag[minor] * qrtMinor[minor];\n-\n-                    for (int row = minor; row < m; row++) {\n-                        y[row] += dotProduct * qrtMinor[row];\n+                    final double factor     = 1.0 / (rDiag[minor] * qrtMinor[minor]); \n+\n+                    Arrays.fill(alpha, 0, kWidth, 0.0);\n+                    for (int row = minor; row < m; ++row) {\n+                        final double   d    = qrtMinor[row];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            alpha[k] += d * yRow[k];\n+                        }\n+                    }\n+                    for (int k = 0; k < kWidth; ++k) {\n+                        alpha[k] *= factor;\n+                    }\n+\n+                    for (int row = minor; row < m; ++row) {\n+                        final double   d    = qrtMinor[row];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yRow[k] += alpha[k] * d;\n+                        }\n                     }\n \n                 }\n \n                 // solve triangular system R.x = y\n-                for (int row = n - 1; row >= 0; --row) {\n-                    y[row] /= rDiag[row];\n-                    final double yRow = y[row];\n-                    final double[] qrtRow = qrt[row];\n-                    xData[row][k] = yRow;\n-                    for (int i = 0; i < row; i++) {\n-                        y[i] -= yRow * qrtRow[i];\n-                    }\n-                }\n-\n-            }\n-\n-            return new RealMatrixImpl(xData, false);\n+                for (int j = rDiag.length - 1; j >= 0; --j) {\n+                    final int      jBlock = j / blockSize;\n+                    final int      jStart = jBlock * blockSize;\n+                    final double   factor = 1.0 / rDiag[j];\n+                    final double[] yJ     = y[j];\n+                    final double[] xBlock = xBlocks[jBlock * cBlocks + kBlock];\n+                    for (int k = 0, index = (j - jStart) * kWidth; k < kWidth; ++k, ++index) {\n+                        yJ[k]        *= factor;\n+                        xBlock[index] = yJ[k];\n+                    }\n+\n+                    final double[] qrtJ = qrt[j];\n+                    for (int i = 0; i < j; ++i) {\n+                        final double rIJ  = qrtJ[i];\n+                        final double[] yI = y[i];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yI[k] -= yJ[k] * rIJ;\n+                        }\n+                    }\n+\n+                }\n+\n+            }\n+\n+            return new DenseRealMatrix(n, columns, xBlocks, false);\n \n         }\n \n         /** {@inheritDoc} */\n         public RealMatrix getInverse()\n-        throws IllegalStateException, InvalidMatrixException {\n+        throws InvalidMatrixException {\n             return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n         }\n ", "timestamp": 1231092498, "metainfo": ""}