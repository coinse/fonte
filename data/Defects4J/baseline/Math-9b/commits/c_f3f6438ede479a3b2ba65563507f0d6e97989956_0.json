{"sha": "f3f6438ede479a3b2ba65563507f0d6e97989956", "log": "MATH-707 Changed \"...MultivariateRealFunction\" to \"...MultivariateFunction\".   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableMultivariateFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Extension of {@link MultivariateFunction} representing a differentiable\n+ * multivariate real function.\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public interface DifferentiableMultivariateFunction extends MultivariateFunction {\n+\n+    /**\n+     * Returns the partial derivative of the function with respect to a point coordinate.\n+     * <p>\n+     * The partial derivative is defined with respect to point coordinate\n+     * x<sub>k</sub>. If the partial derivatives with respect to all coordinates are\n+     * needed, it may be more efficient to use the {@link #gradient()} method which will\n+     * compute them all at once.\n+     * </p>\n+     * @param k index of the coordinate with respect to which the partial\n+     * derivative is computed\n+     * @return the partial derivative function with respect to k<sup>th</sup> point coordinate\n+     */\n+    MultivariateFunction partialDerivative(int k);\n+\n+    /**\n+     * Returns the gradient function.\n+     * <p>If only one partial derivative with respect to a specific coordinate is\n+     * needed, it may be more efficient to use the {@link #partialDerivative(int)} method\n+     * which will compute only the specified component.</p>\n+     * @return the gradient function\n+     */\n+    MultivariateVectorialFunction gradient();\n+\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/FunctionUtils.java\n     }\n \n     /**\n-     * Returns a MultivariateRealFunction h(x[]) defined by <pre> <code>\n+     * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n      * h(x[]) = combiner(...combiner(combiner(initialValue,f(x[0])),f(x[1]))...),f(x[x.length-1]))\n      * </code></pre>\n      *\n      * @param initialValue Initial value.\n      * @return a collector function.\n      */\n-    public static MultivariateRealFunction collector(final BivariateRealFunction combiner,\n+    public static MultivariateFunction collector(final BivariateRealFunction combiner,\n                                                      final UnivariateFunction f,\n                                                      final double initialValue) {\n-        return new MultivariateRealFunction() {\n+        return new MultivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double[] point) {\n                 double result = combiner.value(initialValue, f.value(point[0]));\n     }\n \n     /**\n-     * Returns a MultivariateRealFunction h(x[]) defined by <pre> <code>\n+     * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n      * h(x[]) = combiner(...combiner(combiner(initialValue,x[0]),x[1])...),x[x.length-1])\n      * </code></pre>\n      *\n      * @param initialValue Initial value.\n      * @return a collector function.\n      */\n-    public static MultivariateRealFunction collector(final BivariateRealFunction combiner,\n+    public static MultivariateFunction collector(final BivariateRealFunction combiner,\n                                                      final double initialValue) {\n         return collector(combiner, new Identity(), initialValue);\n     }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * An interface representing a multivariate real function.\n+ *\n+ * @version $Id$\n+ * @since 2.0\n+ */\n+public interface MultivariateFunction {\n+\n+    /**\n+     * Compute the value for the function at the given point.\n+     *\n+     * @param point Point at which the function must be evaluated.\n+     * @return the function value for the given point.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the parameter's dimension is wrong for the function being evaluated.\n+     * @throws  org.apache.commons.math.exception.MathIllegalArgumentException\n+     * when the activated method itself can ascertain that preconditions,\n+     * specified in the API expressed at the level of the activated method,\n+     * have been violated.  In the vast majority of cases where Commons Math\n+     * throws this exception, it is the result of argument checking of actual\n+     * parameters immediately passed to a method.\n+     */\n+    double value(double[] point);\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n import java.util.List;\n import java.util.Map;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NullArgumentException;\n  * @version $Id$\n  */\n public class MicrosphereInterpolatingFunction\n-    implements MultivariateRealFunction {\n+    implements MultivariateFunction {\n     /**\n      * Space dimension.\n      */\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n     /**\n      * {@inheritDoc}\n      */\n-    public MultivariateRealFunction interpolate(final double[][] xval,\n+    public MultivariateFunction interpolate(final double[][] xval,\n                                                 final double[] yval) {\n         final UnitSphereRandomVectorGenerator rand\n             = new UnitSphereRandomVectorGenerator(xval[0].length);\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MultivariateRealInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MultivariateRealInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n \n /**\n  * Interface representing a univariate real interpolating function.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * the arguments are {@code null}.\n      */\n-    MultivariateRealFunction interpolate(double[][] xval, double[] yval);\n+    MultivariateFunction interpolate(double[][] xval, double[] yval);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n  * @version $Id$\n  * @since 3.0\n  */\n-public class BaseMultiStartMultivariateRealOptimizer<FUNC extends MultivariateRealFunction>\n+public class BaseMultiStartMultivariateRealOptimizer<FUNC extends MultivariateFunction>\n     implements BaseMultivariateRealOptimizer<FUNC> {\n     /** Underlying classical optimizer. */\n     private final BaseMultivariateRealOptimizer<FUNC> optimizer;\n      *\n      * @param optimizer Single-start optimizer to wrap.\n      * @param starts Number of starts to perform. If {@code starts == 1},\n-     * the {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n+     * the {@link #optimize(int,MultivariateFunction,GoalType,double[])\n      * optimize} will return the same solution as {@code optimizer} would.\n      * @param generator Random vector generator to use for restarts.\n      * @throws NullArgumentException if {@code optimizer} or {@code generator}\n \n     /**\n      * Get all the optima found during the last call to {@link\n-     * #optimize(int,MultivariateRealFunction,GoalType,double[]) optimize}.\n+     * #optimize(int,MultivariateFunction,GoalType,double[]) optimize}.\n      * The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n+     * restarts. The {@link #optimize(int,MultivariateFunction,GoalType,double[])\n      * optimize} method returns the best point only. This method\n      * returns all the points found at the end of each starts,\n      * including the best one already returned by the {@link\n-     * #optimize(int,MultivariateRealFunction,GoalType,double[]) optimize} method.\n+     * #optimize(int,MultivariateFunction,GoalType,double[]) optimize} method.\n      * <br/>\n      * The returned array as one element for each start as specified\n      * in the constructor. It is ordered with the results from the\n      * objective value (i.e in ascending order if minimizing and in\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n+     * elements will be null if the {@link #optimize(int,MultivariateFunction,GoalType,double[])\n      * optimize} method did throw an exception.\n      * This also means that if the first element is not {@code null}, it\n      * is the best point found across all starts.\n      *\n      * @return an array containing the optima.\n      * @throws MathIllegalStateException if {@link\n-     * #optimize(int,MultivariateRealFunction,GoalType,double[]) optimize}\n+     * #optimize(int,MultivariateFunction,GoalType,double[]) optimize}\n      * has not been called.\n      */\n     public RealPointValuePair[] getOptima() {\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n \n /**\n  * This interface is mainly intended to enforce the internal coherence of\n  * @version $Id$\n  * @since 3.0\n  */\n-public interface BaseMultivariateRealOptimizer<FUNC extends MultivariateRealFunction>\n+public interface BaseMultivariateRealOptimizer<FUNC extends MultivariateFunction>\n     extends BaseOptimizer<RealPointValuePair> {\n     /**\n      * Optimize an objective function.\n--- a/src/main/java/org/apache/commons/math/optimization/BaseSimpleBoundsMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseSimpleBoundsMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n \n /**\n  * This interface is mainly intended to enforce the internal coherence of\n  * @version $Id$\n  * @since 3.0\n  */\n-public interface BaseSimpleBoundsMultivariateRealOptimizer<FUNC extends MultivariateRealFunction>\n+public interface BaseSimpleBoundsMultivariateRealOptimizer<FUNC extends MultivariateFunction>\n     extends BaseMultivariateRealOptimizer<FUNC> {\n     /**\n      * Optimize an objective function.\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n \n /**\n  * This interface represents an optimization algorithm for\n- * {@link DifferentiableMultivariateRealFunction scalar differentiable objective\n+ * {@link DifferentiableMultivariateFunction scalar differentiable objective\n  * functions}.\n  * Optimization algorithms find the input point set that either {@link GoalType\n  * maximize or minimize} an objective function.\n  * @since 2.0\n  */\n public interface DifferentiableMultivariateRealOptimizer\n-    extends BaseMultivariateRealOptimizer<DifferentiableMultivariateRealFunction> {}\n+    extends BaseMultivariateRealOptimizer<DifferentiableMultivariateFunction> {}\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.linear.RealMatrix;\n \n /** This class converts {@link MultivariateVectorialFunction vectorial\n- * objective functions} to {@link MultivariateRealFunction scalar objective functions}\n+ * objective functions} to {@link MultivariateFunction scalar objective functions}\n  * when the goal is to minimize them.\n  * <p>\n  * This class is mostly used when the vectorial objective function represents\n  * This class computes a possibly weighted squared sum of the residuals, which is\n  * a scalar value. The residuals are the difference between the theoretical model\n  * (i.e. the output of the vectorial objective function) and the observations. The\n- * class implements the {@link MultivariateRealFunction} interface and can therefore be\n+ * class implements the {@link MultivariateFunction} interface and can therefore be\n  * minimized by any optimizer supporting scalar objectives functions.This is one way\n  * to perform a least square estimation. There are other ways to do this without using\n  * this converter, as some optimization algorithms directly support vectorial objective\n  * This class support combination of residuals with or without weights and correlations.\n  * </p>\n   *\n- * @see MultivariateRealFunction\n+ * @see MultivariateFunction\n  * @see MultivariateVectorialFunction\n  * @version $Id$\n  * @since 2.0\n  */\n \n-public class LeastSquaresConverter implements MultivariateRealFunction {\n+public class LeastSquaresConverter implements MultivariateFunction {\n \n     /** Underlying vectorial function. */\n     private final MultivariateVectorialFunction function;\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /**\n  * @since 2.0\n  */\n public class MultiStartDifferentiableMultivariateRealOptimizer\n-    extends BaseMultiStartMultivariateRealOptimizer<DifferentiableMultivariateRealFunction>\n+    extends BaseMultiStartMultivariateRealOptimizer<DifferentiableMultivariateFunction>\n     implements DifferentiableMultivariateRealOptimizer {\n     /**\n      * Create a multi-start optimizer from a single-start optimizer.\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n /**\n  * @since 2.0\n  */\n public class MultiStartMultivariateRealOptimizer\n-    extends BaseMultiStartMultivariateRealOptimizer<MultivariateRealFunction>\n+    extends BaseMultiStartMultivariateRealOptimizer<MultivariateFunction>\n     implements MultivariateRealOptimizer {\n     /**\n      * Create a multi-start optimizer from a single-start optimizer.\n--- a/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n \n /**\n- * This interface represents an optimization algorithm for {@link MultivariateRealFunction\n+ * This interface represents an optimization algorithm for {@link MultivariateFunction\n  * scalar objective functions}.\n  * <p>Optimization algorithms find the input point set that either {@link GoalType\n  * maximize or minimize} an objective function.</p>\n  * @since 2.0\n  */\n public interface MultivariateRealOptimizer\n-    extends BaseMultivariateRealOptimizer<MultivariateRealFunction> {}\n+    extends BaseMultivariateRealOptimizer<MultivariateFunction> {}\n--- a/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n  * This class holds a point and the value of an objective function at this point.\n  * <p>This is a simple immutable container.</p>\n  * @see VectorialPointValuePair\n- * @see org.apache.commons.math.analysis.MultivariateRealFunction\n+ * @see org.apache.commons.math.analysis.MultivariateFunction\n  * @version $Id$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.ZeroException;\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the algorithm fails to converge.\n      */\n-    public abstract void iterate(final MultivariateRealFunction evaluationFunction,\n+    public abstract void iterate(final MultivariateFunction evaluationFunction,\n                                  final Comparator<RealPointValuePair> comparator);\n \n     /**\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n-    public void evaluate(final MultivariateRealFunction evaluationFunction,\n+    public void evaluate(final MultivariateFunction evaluationFunction,\n                          final Comparator<RealPointValuePair> comparator) {\n         // Evaluate the objective function at all non-evaluated simplex points.\n         for (int i = 0; i < simplex.length; i++) {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.OutOfRangeException;\n  * @since 3.0\n  */\n public class BOBYQAOptimizer\n-    extends BaseAbstractSimpleBoundsScalarOptimizer<MultivariateRealFunction>\n+    extends BaseAbstractSimpleBoundsScalarOptimizer<MultivariateFunction>\n     implements MultivariateRealOptimizer {\n     /** Minimum dimension of the problem: {@value} */\n     public static final int MINIMUM_PROBLEM_DIMENSION = 2;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n  * @version $Id$\n  * @since 2.2\n  */\n-public abstract class BaseAbstractScalarOptimizer<FUNC extends MultivariateRealFunction>\n+public abstract class BaseAbstractScalarOptimizer<FUNC extends MultivariateFunction>\n     implements BaseMultivariateRealOptimizer<FUNC> {\n     /** Evaluations counter. */\n     protected final Incrementor evaluations = new Incrementor();\n     /** Initial guess. */\n     private double[] start;\n     /** Objective function. */\n-    private MultivariateRealFunction function;\n+    private MultivariateFunction function;\n \n     /**\n      * Simple constructor with default settings.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractSimpleBoundsScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractSimpleBoundsScalarOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.BaseMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.BaseSimpleBoundsMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n  * @version $Id$\n  * @since 3.0\n  */\n-public abstract class BaseAbstractSimpleBoundsScalarOptimizer<FUNC extends MultivariateRealFunction>\n+public abstract class BaseAbstractSimpleBoundsScalarOptimizer<FUNC extends MultivariateFunction>\n     extends BaseAbstractScalarOptimizer<FUNC>\n     implements BaseMultivariateRealOptimizer<FUNC>,\n                BaseSimpleBoundsMultivariateRealOptimizer<FUNC> {\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n import java.util.Arrays;\n import java.util.List;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.MultiDimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NotPositiveException;\n  */\n \n public class CMAESOptimizer\n-    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    extends BaseAbstractScalarOptimizer<MultivariateFunction>\n     implements MultivariateRealOptimizer {\n     /** Default value for {@link #checkFeasableCount}: {@value}. */\n     public static final int DEFAULT_CHECKFEASABLECOUNT = 0;\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n /**\n \n     /** {@inheritDoc} */\n     @Override\n-    public void iterate(final MultivariateRealFunction evaluationFunction,\n+    public void iterate(final MultivariateFunction evaluationFunction,\n                         final Comparator<RealPointValuePair> comparator) {\n         // Save the original simplex.\n         final RealPointValuePair[] original = getPoints();\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n-    private RealPointValuePair evaluateNewSimplex(final MultivariateRealFunction evaluationFunction,\n+    private RealPointValuePair evaluateNewSimplex(final MultivariateFunction evaluationFunction,\n                                                   final RealPointValuePair[] original,\n                                                   final double coeff,\n                                                   final Comparator<RealPointValuePair> comparator) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionMappingAdapter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.function.Logit;\n+import org.apache.commons.math.analysis.function.Sigmoid;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>Adapter for mapping bounded {@link MultivariateFunction} to unbounded ones.</p>\n+ *\n+ * <p>\n+ * This adapter can be used to wrap functions subject to simple bounds on\n+ * parameters so they can be used by optimizers that do <em>not</em> directly\n+ * support simple bounds.\n+ * </p>\n+ * <p>\n+ * The principle is that the user function that will be wrapped will see its\n+ * parameters bounded as required, i.e when its {@code value} method is called\n+ * with argument array {@code point}, the elements array will fulfill requirement\n+ * {@code lower[i] <= point[i] <= upper[i]} for all i. Some of the components\n+ * may be unbounded or bounded only on one side if the corresponding bound is\n+ * set to an infinite value. The optimizer will not manage the user function by\n+ * itself, but it will handle this adapter and it is this adapter that will take\n+ * care the bounds are fulfilled. The adapter {@link #value(double[])} method will\n+ * be called by the optimizer with unbound parameters, and the adapter will map\n+ * the unbounded value to the bounded range using appropriate functions like\n+ * {@link Sigmoid} for double bounded elements for example.\n+ * </p>\n+ * <p>\n+ * As the optimizer sees only unbounded parameters, it should be noted that the\n+ * start point or simplex expected by the optimizer should be unbounded, so the\n+ * user is responsible for converting his bounded point to unbounded by calling\n+ * {@link #boundedToUnbounded(double[])} before providing them to the optimizer.\n+ * For the same reason, the point returned by the {@link\n+ * org.apache.commons.math.optimization.BaseMultivariateRealOptimizer#optimize(int,\n+ * MultivariateFunction, org.apache.commons.math.optimization.GoalType, double[])}\n+ * method is unbounded. So to convert this point to bounded, users must call\n+ * {@link #unboundedToBounded(double[])} by themselves!</p>\n+ * <p>\n+ * This adapter is only a poor man solution to simple bounds optimization constraints\n+ * that can be used with simple optimizers like {@link SimplexOptimizer} with {@link\n+ * NelderMeadSimplex} or {@link MultiDirectionalSimplex}. A better solution is to use\n+ * an optimizer that directly supports simple bounds like {@link CMAESOptimizer} or\n+ * {@link BOBYQAOptimizer}. One caveat of this poor man solution is that behavior near\n+ * the bounds may be numerically unstable as bounds are mapped from infinite values.\n+ * Another caveat is that convergence values are evaluated by the optimizer with respect\n+ * to unbounded variables, so there will be scales differences when converted to bounded\n+ * variables.\n+ * </p>\n+ *\n+ * @see MultivariateFunctionPenaltyAdapter\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public class MultivariateFunctionMappingAdapter implements MultivariateFunction {\n+\n+    /** Underlying bounded function. */\n+    private final MultivariateFunction bounded;\n+\n+    /** Mapping functions. */\n+    private final Mapper[] mappers;\n+\n+    /** Simple constructor.\n+     * @param bounded bounded function\n+     * @param lower lower bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for\n+     * unbounded values)\n+     * @param upper upper bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.POSITIVE_INFINITY} for\n+     * unbounded values)\n+     * @exception MathIllegalArgumentException if lower and upper bounds are not\n+     * consistent, either according to dimension or to values\n+     */\n+    public MultivariateFunctionMappingAdapter(final MultivariateFunction bounded,\n+                                                  final double[] lower, final double[] upper) {\n+\n+        // safety checks\n+        MathUtils.checkNotNull(lower);\n+        MathUtils.checkNotNull(upper);\n+        if (lower.length != upper.length) {\n+            throw new DimensionMismatchException(lower.length, upper.length);\n+        }\n+        for (int i = 0; i < lower.length; ++i) {\n+            // note the following test is written in such a way it also fails for NaN\n+            if (!(upper[i] >= lower[i])) {\n+                throw new NumberIsTooSmallException(upper[i], lower[i], true);\n+            }\n+        }\n+\n+        this.bounded = bounded;\n+        this.mappers = new Mapper[lower.length];\n+        for (int i = 0; i < mappers.length; ++i) {\n+            if (Double.isInfinite(lower[i])) {\n+                if (Double.isInfinite(upper[i])) {\n+                    // element is unbounded, no transformation is needed\n+                    mappers[i] = new NoBoundsMapper();\n+                } else {\n+                    // element is simple-bounded on the upper side\n+                    mappers[i] = new UpperBoundMapper(upper[i]);\n+                }\n+            } else {\n+                if (Double.isInfinite(upper[i])) {\n+                    // element is simple-bounded on the lower side\n+                    mappers[i] = new LowerBoundMapper(lower[i]);\n+                } else {\n+                    // element is double-bounded\n+                    mappers[i] = new LowerUpperBoundMapper(lower[i], upper[i]);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /** Map an array from unbounded to bounded.\n+     * @param point unbounded value\n+     * @return bounded value\n+     */\n+    public double[] unboundedToBounded(double[] point) {\n+\n+        // map unbounded input point to bounded point\n+        final double[] mapped = new double[mappers.length];\n+        for (int i = 0; i < mappers.length; ++i) {\n+            mapped[i] = mappers[i].unboundedToBounded(point[i]);\n+        }\n+\n+        return mapped;\n+\n+    }\n+\n+    /** \n+     * Map an array from bounded to unbounded.\n+     * @param point bounded value\n+     * @return unbounded value\n+     */\n+    public double[] boundedToUnbounded(double[] point) {\n+\n+        // map bounded input point to unbounded point\n+        final double[] mapped = new double[mappers.length];\n+        for (int i = 0; i < mappers.length; ++i) {\n+            mapped[i] = mappers[i].boundedToUnbounded(point[i]);\n+        }\n+\n+        return mapped;\n+\n+    }\n+\n+    /** Compute the underlying function value from an unbounded point.\n+     * <p>\n+     * This method simply bounds the unbounded point using the mappings\n+     * set up at construction and calls the underlying function using\n+     * the bounded point.\n+     * </p>\n+     * @see #unboundedToBounded(double[])\n+     */\n+    public double value(double[] point) {\n+        return bounded.value(unboundedToBounded(point));\n+    }\n+\n+    /** Mapping interface. */\n+    private static interface Mapper {\n+\n+        /** Map a value from unbounded to bounded.\n+         * @param y unbounded value\n+         * @return bounded value\n+         */\n+        public double unboundedToBounded(double y);\n+\n+        /** Map a value from bounded to unbounded.\n+         * @param x bounded value\n+         * @return unbounded value\n+         */\n+        public double boundedToUnbounded(double x);\n+\n+    }\n+\n+    /** Local class for no bounds mapping. */\n+    private static class NoBoundsMapper implements Mapper {\n+\n+        /** Simple constructor.\n+         */\n+        public NoBoundsMapper() {\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return y;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return x;\n+        }\n+\n+    }\n+\n+    /** Local class for lower bounds mapping. */\n+    private static class LowerBoundMapper implements Mapper {\n+\n+        /** Low bound. */\n+        private final double lower;\n+\n+        /** Simple constructor.\n+         * @param lower lower bound\n+         */\n+        public LowerBoundMapper(final double lower) {\n+            this.lower = lower;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return lower + FastMath.exp(y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return FastMath.log(x - lower);\n+        }\n+\n+    }\n+\n+    /** Local class for upper bounds mapping. */\n+    private static class UpperBoundMapper implements Mapper {\n+\n+        /** Upper bound. */\n+        private final double upper;\n+\n+        /** Simple constructor.\n+         * @param upper upper bound\n+         */\n+        public UpperBoundMapper(final double upper) {\n+            this.upper = upper;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return upper - FastMath.exp(-y);\n+        }\n+        \n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return -FastMath.log(upper - x);\n+        }\n+        \n+    }\n+\n+    /** Local class for lower and bounds mapping. */\n+    private static class LowerUpperBoundMapper implements Mapper {\n+\n+        /** Function from unbounded to bounded. */\n+        private final UnivariateFunction boundingFunction;\n+\n+        /** Function from bounded to unbounded. */\n+        private final UnivariateFunction unboundingFunction;\n+\n+        /** Simple constructor.\n+         * @param lower lower bound\n+         * @param upper upper bound\n+         */\n+        public LowerUpperBoundMapper(final double lower, final double upper) {\n+            boundingFunction   = new Sigmoid(lower, upper);\n+            unboundingFunction = new Logit(lower, upper);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return boundingFunction.value(y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return unboundingFunction.value(x);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>Adapter extending bounded {@link MultivariateFunction} to an unbouded\n+ * domain using a penalty function.</p>\n+ *\n+ * <p>\n+ * This adapter can be used to wrap functions subject to simple bounds on\n+ * parameters so they can be used by optimizers that do <em>not</em> directly\n+ * support simple bounds.\n+ * </p>\n+ * <p>\n+ * The principle is that the user function that will be wrapped will see its\n+ * parameters bounded as required, i.e when its {@code value} method is called\n+ * with argument array {@code point}, the elements array will fulfill requirement\n+ * {@code lower[i] <= point[i] <= upper[i]} for all i. Some of the components\n+ * may be unbounded or bounded only on one side if the corresponding bound is\n+ * set to an infinite value. The optimizer will not manage the user function by\n+ * itself, but it will handle this adapter and it is this adapter that will take\n+ * care the bounds are fulfilled. The adapter {@link #value(double[])} method will\n+ * be called by the optimizer with unbound parameters, and the adapter will check\n+ * if the parameters is within range or not. If it is in range, then the underlying\n+ * user function will be called, and if it is not the value of a penalty function\n+ * will be returned instead.\n+ * </p>\n+ * <p>\n+ * This adapter is only a poor man solution to simple bounds optimization constraints\n+ * that can be used with simple optimizers like {@link SimplexOptimizer} with {@link\n+ * NelderMeadSimplex} or {@link MultiDirectionalSimplex}. A better solution is to use\n+ * an optimizer that directly supports simple bounds like {@link CMAESOptimizer} or\n+ * {@link BOBYQAOptimizer}. One caveat of this poor man solution is that if start point\n+ * or start simplex is completely outside of the allowed range, only the penalty function\n+ * is used, and the optimizer may converge without ever entering the range.\n+ * </p>\n+ *\n+ * @see MultivariateFunctionMappingAdapter\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public class MultivariateFunctionPenaltyAdapter implements MultivariateFunction {\n+\n+    /** Underlying bounded function. */\n+    private final MultivariateFunction bounded;\n+\n+    /** Lower bounds. */\n+    private final double[] lower;\n+\n+    /** Upper bounds. */\n+    private final double[] upper;\n+\n+    /** Penalty offset. */\n+    private final double offset;\n+\n+    /** Penalty scales. */\n+    private final double[] scale;\n+\n+    /** Simple constructor.\n+     * <p>\n+     * When the optimizer provided points are out of range, the value of the\n+     * penalty function will be used instead of the value of the underlying\n+     * function. In order for this penalty to be effective in rejecting this\n+     * point during the optimization process, the penalty function value should\n+     * be defined with care. This value is computed as:\n+     * <pre>\n+     *   penalty(point) = offset + &sum;<sub>i</sub>[scale[i] * &radic;|point[i]-boundary[i]|]\n+     * </pre>\n+     * where indices i correspond to all the components that violates their boundaries.\n+     * </p>\n+     * <p>\n+     * So when attempting a function minimization, offset should be larger than\n+     * the maximum expected value of the underlying function and scale components\n+     * should all be positive. When attempting a function maximization, offset\n+     * should be lesser than the minimum expected value of the underlying function\n+     * and scale components should all be negative.\n+     * minimization, and lesser than the minimum expected value of the underlying\n+     * function when attempting maximization.\n+     * </p>\n+     * <p>\n+     * These choices for the penalty function have two properties. First, all out\n+     * of range points will return a function value that is worse than the value\n+     * returned by any in range point. Second, the penalty is worse for large\n+     * boundaries violation than for small violations, so the optimizer has an hint\n+     * about the direction in which it should search for acceptable points.\n+     * </p>\n+     * @param bounded bounded function\n+     * @param lower lower bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for\n+     * unbounded values)\n+     * @param upper upper bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.POSITIVE_INFINITY} for\n+     * unbounded values)\n+     * @param offset base offset of the penalty function\n+     * @param scale scale of the penalty function\n+     * @exception MathIllegalArgumentException if lower bounds, upper bounds and\n+     * scales are not consistent, either according to dimension or to bounadary\n+     * values\n+     */\n+    public MultivariateFunctionPenaltyAdapter(final MultivariateFunction bounded,\n+                                                  final double[] lower, final double[] upper,\n+                                                  final double offset, final double[] scale) {\n+\n+        // safety checks\n+        MathUtils.checkNotNull(lower);\n+        MathUtils.checkNotNull(upper);\n+        MathUtils.checkNotNull(scale);\n+        if (lower.length != upper.length) {\n+            throw new DimensionMismatchException(lower.length, upper.length);\n+        }\n+        if (lower.length != scale.length) {\n+            throw new DimensionMismatchException(lower.length, scale.length);\n+        }\n+        for (int i = 0; i < lower.length; ++i) {\n+            // note the following test is written in such a way it also fails for NaN\n+            if (!(upper[i] >= lower[i])) {\n+                throw new NumberIsTooSmallException(upper[i], lower[i], true);\n+            }\n+        }\n+\n+        this.bounded = bounded;\n+        this.lower   = lower.clone();\n+        this.upper   = upper.clone();\n+        this.offset  = offset;\n+        this.scale   = scale.clone();\n+\n+    }\n+\n+    /** Compute the underlying function value from an unbounded point.\n+     * <p>\n+     * This method simply bounds the unbounded point using the mappings\n+     * set up at construction and calls the underlying function using\n+     * the bounded point.\n+     * </p>\n+     * @see #unboundedToBounded(double[])\n+     */\n+    public double value(double[] point) {\n+\n+        for (int i = 0; i < scale.length; ++i) {\n+            if ((point[i] < lower[i]) || (point[i] > upper[i])) {\n+                // bound violation starting at this component\n+                double sum = 0;\n+                for (int j = i; j < scale.length; ++j) {\n+                    final double overshoot;\n+                    if (point[j] < lower[j]) {\n+                        overshoot = lower[j] - point[j];\n+                    } else if (point[j] > upper[j]) {\n+                        overshoot = point[j] - upper[j];\n+                    } else {\n+                        overshoot = 0;\n+                    }\n+                    sum += FastMath.sqrt(overshoot);\n+                }\n+                return offset + sum;\n+            }\n+        }\n+\n+        // all boundaries are fulfilled, we are in the expected\n+        // domain of the underlying function\n+        return bounded.value(point);\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n import java.util.Comparator;\n \n import org.apache.commons.math.optimization.RealPointValuePair;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n \n /**\n  * This class implements the Nelder-Mead simplex algorithm.\n \n     /** {@inheritDoc} */\n     @Override\n-    public void iterate(final MultivariateRealFunction evaluationFunction,\n+    public void iterate(final MultivariateFunction evaluationFunction,\n                         final Comparator<RealPointValuePair> comparator) {\n         // The simplex has n + 1 points if dimension is n.\n         final int n = getDimension();\n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathArrays;\n import org.apache.commons.math.analysis.UnivariateFunction;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.GoalType;\n  * @since 2.2\n  */\n public class PowellOptimizer\n-    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    extends BaseAbstractScalarOptimizer<MultivariateFunction>\n     implements MultivariateRealOptimizer {\n     /**\n      * Minimum relative tolerance.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n  *  be called prior to calling the {@code optimize} method.\n  * </p>\n  * <p>\n- *  Each call to {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n+ *  Each call to {@link #optimize(int,MultivariateFunction,GoalType,double[])\n  *  optimize} will re-use the start configuration of the current simplex and\n  *  move it such that its first vertex is at the provided start point of the\n  *  optimization. If the {@code optimize} method is called to solve a different\n  * optimization with simple bounds, so for such optimizations, either a more\n  * dedicated method must be used like {@link CMAESOptimizer} or {@link\n  * BOBYQAOptimizer}, or the optimized method must be wrapped in an adapter like\n- * {@link MultivariateRealFunctionMappingAdapter} or {@link\n- * MultivariateRealFunctionPenaltyAdapter}.\n+ * {@link MultivariateFunctionMappingAdapter} or {@link\n+ * MultivariateFunctionPenaltyAdapter}.\n  * </p>\n  *\n  * @see AbstractSimplex\n- * @see MultivariateRealFunctionMappingAdapter\n- * @see MultivariateRealFunctionPenaltyAdapter\n+ * @see MultivariateFunctionMappingAdapter\n+ * @see MultivariateFunctionPenaltyAdapter\n  * @see CMAESOptimizer\n  * @see BOBYQAOptimizer\n  * @version $Id$\n  * @since 3.0\n  */\n public class SimplexOptimizer\n-    extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n+    extends BaseAbstractScalarOptimizer<MultivariateFunction>\n     implements MultivariateRealOptimizer {\n     /** Simplex. */\n     private AbstractSimplex simplex;\n \n         // Indirect call to \"computeObjectiveValue\" in order to update the\n         // evaluations counter.\n-        final MultivariateRealFunction evalFunc\n-            = new MultivariateRealFunction() {\n+        final MultivariateFunction evalFunc\n+            = new MultivariateFunction() {\n                 public double value(double[] point) {\n                     return computeObjectiveValue(point);\n                 }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n  * @since 2.0\n  */\n public abstract class AbstractScalarDifferentiableOptimizer\n-    extends BaseAbstractScalarOptimizer<DifferentiableMultivariateRealFunction>\n+    extends BaseAbstractScalarOptimizer<DifferentiableMultivariateFunction>\n     implements DifferentiableMultivariateRealOptimizer {\n     /**\n      * Objective function gradient.\n     /** {@inheritDoc} */\n     @Override\n     public RealPointValuePair optimize(int maxEval,\n-                                       final DifferentiableMultivariateRealFunction f,\n+                                       final DifferentiableMultivariateFunction f,\n                                        final GoalType goalType,\n                                        final double[] startPoint) {\n         // Store optimization problem characteristics.\n--- a/src/main/java/org/apache/commons/math/optimization/package-info.java\n+++ b/src/main/java/org/apache/commons/math/optimization/package-info.java\n  *      UnivariateRealOptimizer} for {@link org.apache.commons.math.analysis.UnivariateFunction\n  *      univariate real functions}</li>\n  *  <li>{@link org.apache.commons.math.optimization.MultivariateRealOptimizer\n- *      MultivariateRealOptimizer} for {@link org.apache.commons.math.analysis.MultivariateRealFunction\n+ *      MultivariateRealOptimizer} for {@link org.apache.commons.math.analysis.MultivariateFunction\n  *      multivariate real functions}</li>\n  *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer\n  *      DifferentiableMultivariateRealOptimizer} for {@link\n- *      org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction\n+ *      org.apache.commons.math.analysis.DifferentiableMultivariateFunction\n  *      differentiable multivariate real functions}</li>\n  *  <li>{@link org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer\n  *      DifferentiableMultivariateVectorialOptimizer} for {@link\n  * Despite there are only four types of supported optimizers, it is possible to optimize a\n  * transform a {@link org.apache.commons.math.analysis.MultivariateVectorialFunction\n  * non-differentiable multivariate vectorial function} by converting it to a {@link\n- * org.apache.commons.math.analysis.MultivariateRealFunction non-differentiable multivariate\n+ * org.apache.commons.math.analysis.MultivariateFunction non-differentiable multivariate\n  * real function} thanks to the {@link\n  * org.apache.commons.math.optimization.LeastSquaresConverter LeastSquaresConverter} helper class.\n  * The transformed function can be optimized using any implementation of the {@link\n--- a/src/test/java/org/apache/commons/math/analysis/FunctionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/FunctionUtilsTest.java\n import org.apache.commons.math.analysis.function.Max;\n import org.apache.commons.math.analysis.function.Pow;\n import org.apache.commons.math.analysis.function.Log;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n \n import org.junit.Assert;\n import org.junit.Test;\n     @Test\n     public void testCollector() {\n         BivariateRealFunction bi = new Add();\n-        MultivariateRealFunction coll = FunctionUtils.collector(bi, 0);\n+        MultivariateFunction coll = FunctionUtils.collector(bi, 0);\n         Assert.assertEquals(10, coll.value(new double[] {1, 2, 3, 4}), EPS);\n \n         bi = new Multiply();\n--- a/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SumSincFunction.java\n  *\n  * @version $Id$\n  */\n-public class SumSincFunction implements DifferentiableMultivariateRealFunction {\n+public class SumSincFunction implements DifferentiableMultivariateFunction {\n     private static final DifferentiableUnivariateFunction sinc = new SincFunction();\n     private static final UnivariateFunction sincDeriv = sinc.derivative();\n \n     /**\n      * {@inheritDoc}\n      */\n-    public MultivariateRealFunction partialDerivative(final int k) {\n-        return new MultivariateRealFunction() {\n+    public MultivariateFunction partialDerivative(final int k) {\n+        return new MultivariateFunction() {\n             public double value(double[] point) {\n                 return sincDeriv.value(point[k]);\n             }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n      */\n     @Test\n     public void testLinearFunction2D() {\n-        MultivariateRealFunction f = new MultivariateRealFunction() {\n+        MultivariateFunction f = new MultivariateFunction() {\n                 public double value(double[] x) {\n                     if (x.length != 2) {\n                         throw new IllegalArgumentException();\n             }\n         }\n \n-        MultivariateRealFunction p = interpolator.interpolate(x, y);\n+        MultivariateFunction p = interpolator.interpolate(x, y);\n \n         double[] c = new double[dim];\n         double expected, result;\n      */\n     @Test\n     public void testParaboloid2D() {\n-        MultivariateRealFunction f = new MultivariateRealFunction() {\n+        MultivariateFunction f = new MultivariateFunction() {\n                 public double value(double[] x) {\n                     if (x.length != 2) {\n                         throw new IllegalArgumentException();\n             }\n         }\n \n-        MultivariateRealFunction p = interpolator.interpolate(x, y);\n+        MultivariateFunction p = interpolator.interpolate(x, y);\n \n         double[] c = new double[dim];\n         double expected, result;\n--- a/src/test/java/org/apache/commons/math/optimization/BatteryNISTTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/BatteryNISTTest.java\n import junit.framework.Assert;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.direct.BOBYQAOptimizer;\n     }\n     \n     /* generic test runner */\n-    private double[] run(MultivariateRealOptimizer optim, DifferentiableMultivariateRealFunction func, double[] start) {\n+    private double[] run(MultivariateRealOptimizer optim, DifferentiableMultivariateFunction func, double[] start) {\n         return (optim.optimize(1000000, func, GoalType.MINIMIZE, start).getPointRef());\n     }\n     /* generic test runner for AbstractScalarDifferentiableOptimizer */\n-    private double[] run(AbstractScalarDifferentiableOptimizer optim, DifferentiableMultivariateRealFunction func, double[] start) {\n+    private double[] run(AbstractScalarDifferentiableOptimizer optim, DifferentiableMultivariateFunction func, double[] start) {\n         return (optim.optimize(1000000, func, GoalType.MINIMIZE, start).getPointRef());\n     }\n \n     /* base objective function class for these tests */\n-    private abstract static class nistMVRF implements DifferentiableMultivariateRealFunction {\n-        protected final MultivariateRealFunction[] mrf;\n+    private abstract static class nistMVRF implements DifferentiableMultivariateFunction {\n+        protected final MultivariateFunction[] mrf;\n         protected final MultivariateVectorialFunction mvf = new MultivariateVectorialFunction() {\n \n             public double[] value(double[] point) throws IllegalArgumentException {\n             this.gradient = new double[nparams];\n             this.nparams = nparams;\n             this.data = data;\n-            mrf = new MultivariateRealFunction[nvars];\n+            mrf = new MultivariateFunction[nvars];\n             for (int i = 0; i < nvars; i++) {\n                 final int idx = i;\n-                mrf[i] = new MultivariateRealFunction() {\n+                mrf[i] = new MultivariateFunction() {\n \n                     private int myIdx = idx;\n \n             return mvf;\n         }\n \n-        public MultivariateRealFunction partialDerivative(int k) {\n+        public MultivariateFunction partialDerivative(int k) {\n             return mrf[k];\n         }\n \n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n import java.awt.geom.Point2D;\n import java.util.ArrayList;\n \n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.optimization.general.ConjugateGradientFormula;\n import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;\n         Assert.assertEquals(3.1267527, optimum.getValue(), 1.0e-8);\n     }\n \n-    private static class Circle implements DifferentiableMultivariateRealFunction {\n+    private static class Circle implements DifferentiableMultivariateFunction {\n \n         private ArrayList<Point2D.Double> points;\n \n             };\n         }\n \n-        public MultivariateRealFunction partialDerivative(final int k) {\n-            return new MultivariateRealFunction() {\n+        public MultivariateFunction partialDerivative(final int k) {\n+            return new MultivariateFunction() {\n                 public double value(double[] point) {\n                     return gradient(point)[k];\n                 }\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n package org.apache.commons.math.optimization;\n \n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.direct.NelderMeadSimplex;\n import org.apache.commons.math.optimization.direct.SimplexOptimizer;\n import org.apache.commons.math.random.GaussianRandomGenerator;\n         Assert.assertTrue(optimum.getValue() < 8.0e-4);\n     }\n \n-    private static class Rosenbrock implements MultivariateRealFunction {\n+    private static class Rosenbrock implements MultivariateFunction {\n         private int count;\n \n         public Rosenbrock() {\n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n import java.util.Arrays;\n import java.util.Random;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n      * @param maxEvaluations Maximum number of evaluations.\n      * @param expected Expected point / value.\n      */\n-    private void doTest(MultivariateRealFunction func,\n+    private void doTest(MultivariateFunction func,\n             double[] startPoint,\n             double[][] boundaries,\n             GoalType goal,\n         return boundaries;\n     }\n \n-    private static class Sphere implements MultivariateRealFunction {\n+    private static class Sphere implements MultivariateFunction {\n \n         public double value(double[] x) {\n             double f = 0;\n         }\n     }\n \n-    private static class Cigar implements MultivariateRealFunction {\n+    private static class Cigar implements MultivariateFunction {\n         private double factor;\n \n         Cigar() {\n         }\n     }\n \n-    private static class Tablet implements MultivariateRealFunction {\n+    private static class Tablet implements MultivariateFunction {\n         private double factor;\n \n         Tablet() {\n         }\n     }\n \n-    private static class CigTab implements MultivariateRealFunction {\n+    private static class CigTab implements MultivariateFunction {\n         private double factor;\n \n         CigTab() {\n         }\n     }\n \n-    private static class TwoAxes implements MultivariateRealFunction {\n+    private static class TwoAxes implements MultivariateFunction {\n \n         private double factor;\n \n         }\n     }\n \n-    private static class ElliRotated implements MultivariateRealFunction {\n+    private static class ElliRotated implements MultivariateFunction {\n         private Basis B = new Basis();\n         private double factor;\n \n         }\n     }\n \n-    private static class Elli implements MultivariateRealFunction {\n+    private static class Elli implements MultivariateFunction {\n \n         private double factor;\n \n         }\n     }\n \n-    private static class MinusElli implements MultivariateRealFunction {\n+    private static class MinusElli implements MultivariateFunction {\n         private final Elli elli = new Elli();\n         public double value(double[] x) {\n             return 1.0 - elli.value(x);\n         }\n     }\n \n-    private static class DiffPow implements MultivariateRealFunction {\n+    private static class DiffPow implements MultivariateFunction {\n //        private int fcount = 0;\n         public double value(double[] x) {\n             double f = 0;\n         }\n     }\n \n-    private static class SsDiffPow implements MultivariateRealFunction {\n+    private static class SsDiffPow implements MultivariateFunction {\n \n         public double value(double[] x) {\n             double f = Math.pow(new DiffPow().value(x), 0.25);\n         }\n     }\n \n-    private static class Rosen implements MultivariateRealFunction {\n+    private static class Rosen implements MultivariateFunction {\n \n         public double value(double[] x) {\n             double f = 0;\n         }\n     }\n \n-    private static class Ackley implements MultivariateRealFunction {\n+    private static class Ackley implements MultivariateFunction {\n         private double axisratio;\n \n         Ackley(double axra) {\n         }\n     }\n \n-    private static class Rastrigin implements MultivariateRealFunction {\n+    private static class Rastrigin implements MultivariateFunction {\n \n         private double axisratio;\n         private double amplitude;\n--- a/src/test/java/org/apache/commons/math/optimization/direct/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/CMAESOptimizerTest.java\n \n import org.apache.commons.math.Retry;\n import org.apache.commons.math.RetryRunner;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.exception.MultiDimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NotPositiveException;\n      * @param maxEvaluations Maximum number of evaluations.\n      * @param expected Expected point / value.\n      */\n-    private void doTest(MultivariateRealFunction func,\n+    private void doTest(MultivariateFunction func,\n             double[] startPoint,\n             double[] inSigma,\n             double[][] boundaries,\n         return boundaries;\n     }\n \n-    private static class Sphere implements MultivariateRealFunction {\n+    private static class Sphere implements MultivariateFunction {\n \n         public double value(double[] x) {\n             double f = 0;\n         }\n     }\n \n-    private static class Cigar implements MultivariateRealFunction {\n+    private static class Cigar implements MultivariateFunction {\n         private double factor;\n \n         Cigar() {\n         }\n     }\n \n-    private static class Tablet implements MultivariateRealFunction {\n+    private static class Tablet implements MultivariateFunction {\n         private double factor;\n \n         Tablet() {\n         }\n     }\n \n-    private static class CigTab implements MultivariateRealFunction {\n+    private static class CigTab implements MultivariateFunction {\n         private double factor;\n \n         CigTab() {\n         }\n     }\n \n-    private static class TwoAxes implements MultivariateRealFunction {\n+    private static class TwoAxes implements MultivariateFunction {\n \n         private double factor;\n \n         }\n     }\n \n-    private static class ElliRotated implements MultivariateRealFunction {\n+    private static class ElliRotated implements MultivariateFunction {\n         private Basis B = new Basis();\n         private double factor;\n \n         }\n     }\n \n-    private static class Elli implements MultivariateRealFunction {\n+    private static class Elli implements MultivariateFunction {\n \n         private double factor;\n \n         }\n     }\n \n-    private static class MinusElli implements MultivariateRealFunction {\n+    private static class MinusElli implements MultivariateFunction {\n \n         public double value(double[] x) {\n             return 1.0-(new Elli().value(x));\n         }\n     }\n \n-    private static class DiffPow implements MultivariateRealFunction {\n+    private static class DiffPow implements MultivariateFunction {\n \n         public double value(double[] x) {\n             double f = 0;\n         }\n     }\n \n-    private static class SsDiffPow implements MultivariateRealFunction {\n+    private static class SsDiffPow implements MultivariateFunction {\n \n         public double value(double[] x) {\n             double f = Math.pow(new DiffPow().value(x), 0.25);\n         }\n     }\n \n-    private static class Rosen implements MultivariateRealFunction {\n+    private static class Rosen implements MultivariateFunction {\n \n         public double value(double[] x) {\n             double f = 0;\n         }\n     }\n \n-    private static class Ackley implements MultivariateRealFunction {\n+    private static class Ackley implements MultivariateFunction {\n         private double axisratio;\n \n         Ackley(double axra) {\n         }\n     }\n \n-    private static class Rastrigin implements MultivariateRealFunction {\n+    private static class Rastrigin implements MultivariateFunction {\n \n         private double axisratio;\n         private double amplitude;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionMappingAdapterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MultivariateFunctionMappingAdapterTest {\n+\n+    @Test\n+    public void testStartSimplexInsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateFunctionMappingAdapter wrapped =\n+                new MultivariateFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testOptimumOutsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateFunctionMappingAdapter wrapped =\n+                new MultivariateFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(100, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testUnbounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        final MultivariateFunctionMappingAdapter wrapped =\n+                new MultivariateFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testHalfBounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0,\n+                                                        1.0, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, 3.0);\n+        final MultivariateFunctionMappingAdapter wrapped =\n+                new MultivariateFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-13, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(200, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 1e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 1e-7);\n+\n+    }\n+\n+    private static class BiQuadratic implements MultivariateFunction {\n+\n+        private final double xOptimum;\n+        private final double yOptimum;\n+\n+        private final double xMin;\n+        private final double xMax;\n+        private final double yMin;\n+        private final double yMax;\n+\n+        public BiQuadratic(final double xOptimum, final double yOptimum,\n+                           final double xMin, final double xMax,\n+                           final double yMin, final double yMax) {\n+            this.xOptimum = xOptimum;\n+            this.yOptimum = yOptimum;\n+            this.xMin     = xMin;\n+            this.xMax     = xMax;\n+            this.yMin     = yMin;\n+            this.yMax     = yMax;\n+        }\n+\n+        public double value(double[] point) {\n+\n+            // the function should never be called with out of range points\n+            Assert.assertTrue(point[0] >= xMin);\n+            Assert.assertTrue(point[0] <= xMax);\n+            Assert.assertTrue(point[1] >= yMin);\n+            Assert.assertTrue(point[1] <= yMax);\n+\n+            final double dx = point[0] - xOptimum;\n+            final double dy = point[1] - yOptimum;\n+            return dx * dx + dy * dy;\n+\n+        }\n+\n+        public double[] getLower() {\n+            return new double[] { xMin, yMin };\n+        }\n+\n+        public double[] getUpper() {\n+            return new double[] { xMax, yMax };\n+        }\n+\n+        public double getBoundedXOptimum() {\n+            return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum);\n+        }\n+\n+        public double getBoundedYOptimum() {\n+            return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleRealPointChecker;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MultivariateFunctionPenaltyAdapterTest {\n+\n+    @Test\n+    public void testStartSimplexInsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateFunctionPenaltyAdapter wrapped =\n+                new MultivariateFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { 1.5, 2.25 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testStartSimplexOutsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateFunctionPenaltyAdapter wrapped =\n+                new MultivariateFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testOptimumOutsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateFunctionPenaltyAdapter wrapped =\n+                new MultivariateFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-11, 1.0e-20));\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(600, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testUnbounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        final MultivariateFunctionPenaltyAdapter wrapped =\n+                new MultivariateFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testHalfBounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0,\n+                                                        1.0, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, 3.0);\n+        final MultivariateFunctionPenaltyAdapter wrapped =\n+                new MultivariateFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-10, 1.0e-20));\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(400, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    private static class BiQuadratic implements MultivariateFunction {\n+\n+        private final double xOptimum;\n+        private final double yOptimum;\n+\n+        private final double xMin;\n+        private final double xMax;\n+        private final double yMin;\n+        private final double yMax;\n+\n+        public BiQuadratic(final double xOptimum, final double yOptimum,\n+                           final double xMin, final double xMax,\n+                           final double yMin, final double yMax) {\n+            this.xOptimum = xOptimum;\n+            this.yOptimum = yOptimum;\n+            this.xMin     = xMin;\n+            this.xMax     = xMax;\n+            this.yMin     = yMin;\n+            this.yMax     = yMax;\n+        }\n+\n+        public double value(double[] point) {\n+\n+            // the function should never be called with out of range points\n+            Assert.assertTrue(point[0] >= xMin);\n+            Assert.assertTrue(point[0] <= xMax);\n+            Assert.assertTrue(point[1] >= yMin);\n+            Assert.assertTrue(point[1] <= yMax);\n+\n+            final double dx = point[0] - xOptimum;\n+            final double dy = point[1] - yOptimum;\n+            return dx * dx + dy * dy;\n+\n+        }\n+\n+        public double[] getLower() {\n+            return new double[] { xMin, yMin };\n+        }\n+\n+        public double[] getUpper() {\n+            return new double[] { xMax, yMax };\n+        }\n+\n+        public double getBoundedXOptimum() {\n+            return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum);\n+        }\n+\n+        public double getBoundedYOptimum() {\n+            return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum);\n+        }\n+\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n  */\n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.analysis.SumSincFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n \n     @Test\n     public void testSumSinc() {\n-        final MultivariateRealFunction func = new SumSincFunction(-1);\n+        final MultivariateFunction func = new SumSincFunction(-1);\n \n         int dim = 2;\n         final double[] minPoint = new double[dim];\n \n     @Test\n     public void testQuadratic() {\n-        final MultivariateRealFunction func = new MultivariateRealFunction() {\n+        final MultivariateFunction func = new MultivariateFunction() {\n                 public double value(double[] x) {\n                     final double a = x[0] - 1;\n                     final double b = x[1] - 1;\n \n     @Test\n     public void testMaximizeQuadratic() {\n-        final MultivariateRealFunction func = new MultivariateRealFunction() {\n+        final MultivariateFunction func = new MultivariateFunction() {\n                 public double value(double[] x) {\n                     final double a = x[0] - 1;\n                     final double b = x[1] - 1;\n      * \"Powell\" algorithm.\n      * @param pointTol Tolerance for checking that the optimum is correct.\n      */\n-    private void doTest(MultivariateRealFunction func,\n+    private void doTest(MultivariateFunction func,\n                         double[] optimum,\n                         double[] init,\n                         GoalType goal,\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n     @Test\n     public void testRosenbrock() {\n-        MultivariateRealFunction rosenbrock =\n-            new MultivariateRealFunction() {\n+        MultivariateFunction rosenbrock =\n+            new MultivariateFunction() {\n                 public double value(double[] x) {\n                     ++count;\n                     double a = x[1] - x[0] * x[0];\n \n     @Test\n     public void testPowell() {\n-        MultivariateRealFunction powell =\n-            new MultivariateRealFunction() {\n+        MultivariateFunction powell =\n+            new MultivariateFunction() {\n                 public double value(double[] x) {\n                     ++count;\n                     double a = x[0] + 10 * x[1];\n         Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n     }\n \n-    private static class FourExtrema implements MultivariateRealFunction {\n+    private static class FourExtrema implements MultivariateFunction {\n         // The following function has 4 local extrema.\n         final double xM = -3.841947088256863675365;\n         final double yM = -1.391745200270734924416;\n         }\n     }\n \n-    private static class Gaussian2D implements MultivariateRealFunction {\n+    private static class Gaussian2D implements MultivariateFunction {\n         private final double[] maximumPosition;\n         private final double std;\n \n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n \n \n import org.apache.commons.math.exception.TooManyEvaluationsException;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n         optimizer.optimize(20, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n     }\n \n-    private static class FourExtrema implements MultivariateRealFunction {\n+    private static class FourExtrema implements MultivariateFunction {\n         // The following function has 4 local extrema.\n         final double xM = -3.841947088256863675365;\n         final double yM = -1.391745200270734924416;\n         }\n     }\n \n-    private static class Rosenbrock implements MultivariateRealFunction {\n+    private static class Rosenbrock implements MultivariateFunction {\n         private int count;\n \n         public Rosenbrock() {\n         }\n     }\n \n-    private static class Powell implements MultivariateRealFunction {\n+    private static class Powell implements MultivariateFunction {\n         private int count;\n \n         public Powell() {\n--- a/src/test/java/org/apache/commons/math/optimization/general/CircleScalar.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/CircleScalar.java\n \n import java.awt.geom.Point2D;\n import java.util.ArrayList;\n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n \n /**\n  * Class used in the tests.\n  */\n-class CircleScalar implements DifferentiableMultivariateRealFunction {\n+class CircleScalar implements DifferentiableMultivariateFunction {\n     private ArrayList<Point2D.Double> points;\n \n     public CircleScalar() {\n         };\n     }\n \n-    public MultivariateRealFunction partialDerivative(final int k) {\n-        return new MultivariateRealFunction() {\n+    public MultivariateFunction partialDerivative(final int k) {\n+        return new MultivariateFunction() {\n             public double value(double[] point) {\n                 return gradient(point)[k];\n             }\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n \n import java.awt.geom.Point2D;\n import java.io.Serializable;\n-import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateFunction;\n+import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.linear.BlockRealMatrix;\n         Assert.assertEquals(48.135167894, center.y, 1.0e-8);\n     }\n \n-    private static class LinearProblem implements DifferentiableMultivariateRealFunction, Serializable {\n+    private static class LinearProblem implements DifferentiableMultivariateFunction, Serializable {\n \n         private static final long serialVersionUID = 703247177355019415L;\n         final RealMatrix factors;\n             };\n         }\n \n-        public MultivariateRealFunction partialDerivative(final int k) {\n-            return new MultivariateRealFunction() {\n+        public MultivariateFunction partialDerivative(final int k) {\n+            return new MultivariateFunction() {\n                 public double value(double[] point) {\n                     return gradient(point)[k];\n                 }", "timestamp": 1322433594, "metainfo": ""}