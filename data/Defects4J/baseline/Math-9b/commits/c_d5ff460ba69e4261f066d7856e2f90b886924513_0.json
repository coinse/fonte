{"sha": "d5ff460ba69e4261f066d7856e2f90b886924513", "log": "MATH-855 The best point is sometimes not the last one evaluated.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n         if (abs <= 0) {\n             throw new NotStrictlyPositiveException(abs);\n         }\n+\n         relativeThreshold = rel;\n         absoluteThreshold = abs;\n     }\n \n     /**\n-     * The arguments are used implement the original stopping criterion\n+     * The arguments are used for implementing the original stopping criterion\n      * of Brent's algorithm.\n      * {@code abs} and {@code rel} define a tolerance\n      * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return current;\n+                        return best(current, previous, isMinim);\n                     }\n                 }\n \n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return current;\n+                return best(current, previous, isMinim);\n             }\n             ++iter;\n         }\n     }\n+\n+    /**\n+     * Selects the best of two points.\n+     *\n+     * @param a Point and value.\n+     * @param b Point and value.\n+     * @param isMinim {@code true} if the selected point must be the one with\n+     * the lowest value.\n+     * @return the best point, or {@code null} if {@code a} and {@code b} are\n+     * both {@code null}.\n+     */\n+    private UnivariatePointValuePair best(UnivariatePointValuePair a,\n+                                          UnivariatePointValuePair b,\n+                                          boolean isMinim) {\n+        if (a == null) {\n+            return b;\n+        }\n+        if (b == null) {\n+            return a;\n+        }\n+\n+        if (isMinim) {\n+            return a.getValue() < b.getValue() ? a : b;\n+        } else {\n+            return a.getValue() > b.getValue() ? a : b;\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java\n import org.apache.commons.math3.analysis.QuinticFunction;\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.analysis.function.Sin;\n+import org.apache.commons.math3.analysis.function.StepFunction;\n+import org.apache.commons.math3.analysis.FunctionUtils;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n     public void testSinMin() {\n         UnivariateFunction f = new Sin();\n         UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n-        Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);\n+        Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(), 1e-8);\n         Assert.assertTrue(optimizer.getEvaluations() <= 50);\n         Assert.assertEquals(200, optimizer.getMaxEvaluations());\n         Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);\n \n         Assert.assertEquals(804.9355825, result, 1e-6);\n     }\n+\n+    /**\n+     * Contrived example showing that prior to the resolution of MATH-855,\n+     * the algorithm, by always returning the last evaluated point, would\n+     * sometimes not report the best point it had found.\n+     */\n+    @Test\n+    public void testMath855() {\n+        final double minSin = 3 * Math.PI / 2;\n+        final double offset = 1e-8;\n+        final double delta = 1e-7;\n+        final UnivariateFunction f1 = new Sin();\n+        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset },\n+                                                       new double[] { 0, -1, 0 });\n+        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n+        final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100);\n+        final UnivariatePointValuePair result\n+            = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta);\n+        final int numEval = optimizer.getEvaluations();\n+\n+        final double sol = result.getPoint();\n+        final double expected = 4.712389027602411;\n+\n+        // System.out.println(\"min=\" + (minSin + offset) + \" f=\" + f.value(minSin + offset));\n+        // System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n+        // System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n+\n+        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n+    }\n }", "timestamp": 1346854964, "metainfo": ""}