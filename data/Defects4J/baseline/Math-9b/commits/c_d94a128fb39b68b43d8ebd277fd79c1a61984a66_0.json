{"sha": "d94a128fb39b68b43d8ebd277fd79c1a61984a66", "log": "Moved \"SAFE_MIN\" and \"EPSILON\" from \"MathUtils\" to \"Precision.\"  JIRA: MATH-689 (Committing on behalf of erans)   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n      *       achieved due to large values or short mantissa length. If this\n      *       should be the primary criterion for convergence rather then a\n      *       safety measure, set the absolute accuracy to a ridiculously small value,\n-     *       like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</li>\n+     *       like {@link org.apache.commons.math.util.Precision#SAFE_MIN Precision.SAFE_MIN}.</li>\n      *   <li>absolute accuracy:\n      *       The default is usually chosen so that results in the interval\n      *       -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.partitioning.Embedding;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /** The class represent lines in a three dimensional space.\n \n \n         final Vector3D normal = Vector3D.crossProduct(direction, line.direction);\n         final double n = normal.getNorm();\n-        if (n < MathUtils.SAFE_MIN) {\n+        if (n < Precision.SAFE_MIN) {\n             // lines are parallel\n             return distance(line.zero);\n         }\n \n         final double cos = direction.dotProduct(line.direction);\n         final double n = 1 - cos * cos;\n-        if (n < MathUtils.EPSILON) {\n+        if (n < Precision.EPSILON) {\n             // the lines are parallel\n             return zero;\n         }\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecomposition.java\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * </ul>\n  * <p>\n  * As of 2.0, this class supports only <strong>symmetric</strong> matrices, and\n- * hence computes only real real Eigenvalues. This implies the D matrix returned\n+ * hence computes only real realEigenvalues. This implies the D matrix returned\n  * by {@link #getD()} is always diagonal and the imaginary values returned\n  * {@link #getImagEigenvalue(int)} and {@link #getImagEigenvalues()} are always\n  * null.\n                                 boolean raiseException) {\n         final int rows = matrix.getRowDimension();\n         final int columns = matrix.getColumnDimension();\n-        final double eps = 10 * rows * columns * MathUtils.EPSILON;\n+        final double eps = 10 * rows * columns * Precision.EPSILON;\n         for (int i = 0; i < rows; ++i) {\n             for (int j = i + 1; j < columns; ++j) {\n                 final double mij = matrix.getEntry(i, j);\n         // Make null any main and secondary value too small to be significant\n         if (maxAbsoluteValue!=0.0) {\n             for (int i=0; i < n; i++) {\n-                if (FastMath.abs(realEigenvalues[i])<=MathUtils.EPSILON*maxAbsoluteValue) {\n+                if (FastMath.abs(realEigenvalues[i])<=Precision.EPSILON*maxAbsoluteValue) {\n                     realEigenvalues[i]=0.0;\n                 }\n-                if (FastMath.abs(e[i])<=MathUtils.EPSILON*maxAbsoluteValue) {\n+                if (FastMath.abs(e[i])<=Precision.EPSILON*maxAbsoluteValue) {\n                     e[i]=0.0;\n                 }\n             }\n         // Make null any eigen value too small to be significant\n         if (maxAbsoluteValue!=0.0) {\n             for (int i=0; i < n; i++) {\n-                if (FastMath.abs(realEigenvalues[i])<MathUtils.EPSILON*maxAbsoluteValue) {\n+                if (FastMath.abs(realEigenvalues[i])<Precision.EPSILON*maxAbsoluteValue) {\n                     realEigenvalues[i]=0.0;\n                 }\n             }\n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * A collection of static methods that operate on or return matrices.\n         int rows = rm.getRowDimension();\n         for( int i = 0 ; i < rows ; i++ ){\n             double diag = rm.getEntry(i, i);\n-            if( FastMath.abs(diag) < MathUtils.SAFE_MIN ){\n+            if( FastMath.abs(diag) < Precision.SAFE_MIN ){\n                 throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n             }\n             double bi = b.getEntry(i)/diag;\n         int rows = rm.getRowDimension();\n         for( int i = rows-1 ; i >-1 ; i-- ){\n             double diag = rm.getEntry(i, i);\n-            if( FastMath.abs(diag) < MathUtils.SAFE_MIN ){\n+            if( FastMath.abs(diag) < Precision.SAFE_MIN ){\n                 throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n             }\n             double bi = b.getEntry(i)/diag;\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * Calculates the compact Singular Value Decomposition of a matrix.\n \n         // Set the small value tolerance used to calculate rank and pseudo-inverse\n         tol = FastMath.max(m * singularValues[0] * EPS,\n-                           FastMath.sqrt(MathUtils.SAFE_MIN));\n+                           FastMath.sqrt(Precision.SAFE_MIN));\n \n         if (!transposed) {\n             cachedU = MatrixUtils.createRealMatrix(U);\n     /**\n      * Returns the diagonal matrix &Sigma; of the decomposition.\n      * <p>&Sigma; is a diagonal matrix. The singular values are provided in\n-     * non-increasing order, for compatibility with JAMA.</p>\n+     * non-increasing order, for compatibility with Jama.</p>\n      * @return the &Sigma; matrix\n      */\n     public RealMatrix getS() {\n--- a/src/main/java/org/apache/commons/math/ode/JacobianMatrices.java\n+++ b/src/main/java/org/apache/commons/math/ode/JacobianMatrices.java\n      * </p>\n      * <p>\n      * Given a non zero parameter value pval for the parameter, a reasonable value\n-     * for such a step is {@code pval * FastMath.sqrt(MathUtils.EPSILON)}.\n+     * for such a step is {@code pval * FastMath.sqrt(Precision.EPSILON)}.\n      * </p>\n      * <p>\n      * A zero value for such a step doesn't enable to compute the parameter Jacobian matrix.\n--- a/src/main/java/org/apache/commons/math/optimization/AbstractConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/AbstractConvergenceChecker.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * Base class for all convergence checker implementations.\n     /**\n      * Default relative threshold.\n      */\n-    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * Precision.EPSILON;\n     /**\n      * Default absolute threshold.\n      */\n-    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * Precision.SAFE_MIN;\n     /**\n      * Relative tolerance threshold.\n      */\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n \n \n      *  <li>Cost relative tolerance: 1e-10</li>\n      *  <li>Parameters relative tolerance: 1e-10</li>\n      *  <li>Orthogonality tolerance: 1e-10</li>\n-     *  <li>QR ranking threshold: {@link MathUtils#SAFE_MIN}</li>\n+     *  <li>QR ranking threshold: {@link Precision#SAFE_MIN}</li>\n      * </ul>\n      */\n     public LevenbergMarquardtOptimizer() {\n-        this(100, 1e-10, 1e-10, 1e-10, MathUtils.SAFE_MIN);\n+        this(100, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n     }\n \n     /**\n      *  <li>Cost relative tolerance: 1e-10</li>\n      *  <li>Parameters relative tolerance: 1e-10</li>\n      *  <li>Orthogonality tolerance: 1e-10</li>\n-     *  <li>QR ranking threshold: {@link MathUtils#SAFE_MIN}</li>\n+     *  <li>QR ranking threshold: {@link Precision#SAFE_MIN}</li>\n      * </ul>\n      *\n      * @param checker Convergence checker.\n      */\n     public LevenbergMarquardtOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n-        this(100, checker, 1e-10, 1e-10, 1e-10, MathUtils.SAFE_MIN);\n+        this(100, checker, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n     }\n \n     /**\n      * The default values for the algorithm settings are:\n      * <ul>\n      *  <li>Initial step bound factor}: 100</li>\n-     *  <li>QR ranking threshold}: {@link MathUtils#SAFE_MIN}</li>\n+     *  <li>QR ranking threshold}: {@link Precision#SAFE_MIN}</li>\n      * </ul>\n      *\n      * @param costRelativeTolerance Desired relative error in the sum of\n                                        double orthoTolerance) {\n         this(100,\n              costRelativeTolerance, parRelativeTolerance, orthoTolerance,\n-             MathUtils.SAFE_MIN);\n+             Precision.SAFE_MIN);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n \n         /**\n          * MathUtils provides factorials up to 20, so let's use that limit together\n-         * with MathUtils.EPSILON to generate the following code (a priori, we know that\n+         * with Precision.EPSILON to generate the following code (a priori, we know that\n          * there will be 16 elements, but instead of hardcoding that, this is\n          * prettier):\n          */\n--- a/src/main/java/org/apache/commons/math/stat/regression/MillerUpdatingRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/MillerUpdatingRegression.java\n import java.util.Arrays;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.MathArrays;\n \n /**\n      * @param includeConstant include a constant automatically\n      */\n     public MillerUpdatingRegression(int numberOfVariables, boolean includeConstant) {\n-        this(numberOfVariables, includeConstant, MathUtils.EPSILON);\n+        this(numberOfVariables, includeConstant, Precision.EPSILON);\n     }\n \n     /**\n             if (di != 0.0) {\n                 dpi = smartAdd(di, wxi * xi);\n                 double tmp = wxi * xi / di;\n-                if (FastMath.abs(tmp) > MathUtils.EPSILON) {\n+                if (FastMath.abs(tmp) > Precision.EPSILON) {\n                     w = (di * w) / dpi;\n                 }\n             } else {\n         double _a = FastMath.abs(a);\n         double _b = FastMath.abs(b);\n         if (_a > _b) {\n-            double eps = _a * MathUtils.EPSILON;\n+            double eps = _a * Precision.EPSILON;\n             if (_b > eps) {\n                 return a + b;\n             }\n             return a;\n         } else {\n-            double eps = _b * MathUtils.EPSILON;\n+            double eps = _b * Precision.EPSILON;\n             if (_a > eps) {\n                 return a + b;\n             }\n--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * Estimates an ordinary least squares regression model\n           if( n < 3 ){\n               throw new NoDataException( LocalizedFormats.NOT_ENOUGH_DATA_REGRESSION );\n           }\n-          if( FastMath.abs( sumXX ) > MathUtils.SAFE_MIN ){\n+          if( FastMath.abs( sumXX ) > Precision.SAFE_MIN ){\n               final double[] params = new double[]{ getIntercept(), getSlope() };\n               final double mse = getMeanSquareError();\n               final double _syy = sumYY + sumY * sumY / ((double) n);\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n      * already computed ones provided as literal arrays below.\n      * </p>\n      */\n-    private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;\n+    private static /* final */ boolean RECOMPUTE_TABLES_AT_RUNTIME = false;\n     /** Indicator for loading big tables from \"resource\" files. */\n-    private static final boolean LOAD_RESOURCES = false;\n+    private static /* final */ boolean LOAD_RESOURCES = false;\n \n     /** log(2) (high bits). */\n     private static final double LN_2_A = 0.693147063255310059;\n      * @return the high order part of the mantissa\n      */\n     private static double doubleHighPart(double d) {\n-        if (d > -MathUtils.SAFE_MIN && d < MathUtils.SAFE_MIN){\n+        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n             return d; // These are un-normalised - don't try to convert\n         }\n         long xl = Double.doubleToLongBits(d);\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n  * @version $Id$\n  */\n public final class MathUtils {\n-\n-    /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n-    public static final double EPSILON = 0x1.0p-53;\n-\n-    /** Safe minimum, such that 1 / SAFE_MIN does not overflow.\n-     * <p>In IEEE 754 arithmetic, this is also the smallest normalized\n-     * number 2<sup>-1022</sup>.</p>\n-     */\n-    public static final double SAFE_MIN = 0x1.0p-1022;\n-\n     /**\n      * 2 &pi;.\n      * @since 2.1\n--- a/src/main/java/org/apache/commons/math/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math/util/Precision.java\n  * @version $Id$\n  */\n public class Precision {\n+    /**\n+     * Smallest positive number such that {@code 1 - EPSILON} is not\n+     * numerically equal to 1: {@value}.\n+     */\n+    public static final double EPSILON = 0x1.0p-53;\n+    /**\n+     * Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.\n+     * In IEEE 754 arithmetic, this is also the smallest normalized\n+     * number 2<sup>-1022</sup>: {@value}.\n+     */\n+    public static final double SAFE_MIN = 0x1.0p-1022;\n     /** Offset to order signed double numbers lexicographically. */\n     private static final long SGN_MASK = 0x8000000000000000L;\n-\n     /** Offset to order signed double numbers lexicographically. */\n     private static final int SGN_MASK_FLOAT = 0x80000000;\n \n--- a/src/test/java/org/apache/commons/math/dfp/DfpTest.java\n+++ b/src/test/java/org/apache/commons/math/dfp/DfpTest.java\n package org.apache.commons.math.dfp;\n \n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n     @Test\n     public void testIssue567() {\n         DfpField field = new DfpField(100);\n-        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);\n-        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), MathUtils.SAFE_MIN);\n-        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), MathUtils.EPSILON);\n-        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), MathUtils.EPSILON);\n+        Assert.assertEquals(0.0, field.getZero().toDouble(), Precision.SAFE_MIN);\n+        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), Precision.SAFE_MIN);\n+        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), Precision.EPSILON);\n+        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), Precision.EPSILON);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/linear/EigenDecompositionTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionTest.java\n \n \n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n         RealMatrix matrix =\n             MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);\n     }\n \n                     { 12.0, 66.0 }\n             });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);\n         Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);\n     }\n                                    { -16560.0,  7920.0,  17300.0 }\n                                });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);\n         Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);\n         Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);\n                     { 15,   30,   45 }\n             });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);\n         Assert.assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);\n         Assert.assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);\n                                    {  0.000,  0.000, -0.048,  0.136 }\n                                });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n         Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n         Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n                                    { -0.2976,  0.1152, -0.1344,  0.3872 }\n                                });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n         Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n         Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n         EigenDecomposition decomposition;\n         decomposition = new EigenDecomposition(mainTridiagonal,\n                                                    secondaryTridiagonal,\n-                                                   MathUtils.SAFE_MIN);\n+                                                   Precision.SAFE_MIN);\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n         EigenDecomposition decomposition;\n         decomposition = new EigenDecomposition(mainTridiagonal,\n                                                    secondaryTridiagonal,\n-                                                   MathUtils.SAFE_MIN);\n+                                                   Precision.SAFE_MIN);\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n         EigenDecomposition decomposition;\n         decomposition = new EigenDecomposition(mainTridiagonal,\n                                                    secondaryTridiagonal,\n-                                                   MathUtils.SAFE_MIN);\n+                                                   Precision.SAFE_MIN);\n \n         double[] eigenValues = decomposition.getRealEigenvalues();\n         for (int i = 0; i < refEigenValues.length; ++i) {\n         EigenDecomposition ed;\n         ed = new EigenDecomposition(t.getMainDiagonalRef(),\n                                         t.getSecondaryDiagonalRef(),\n-                                        MathUtils.SAFE_MIN);\n+                                        Precision.SAFE_MIN);\n         double[] eigenValues = ed.getRealEigenvalues();\n         Assert.assertEquals(ref.length, eigenValues.length);\n         for (int i = 0; i < ref.length; ++i) {\n     public void testDimensions() {\n         final int m = matrix.getRowDimension();\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         Assert.assertEquals(m, ed.getV().getRowDimension());\n         Assert.assertEquals(m, ed.getV().getColumnDimension());\n         Assert.assertEquals(m, ed.getD().getColumnDimension());\n     @Test\n     public void testEigenvalues() {\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         double[] eigenValues = ed.getRealEigenvalues();\n         Assert.assertEquals(refValues.length, eigenValues.length);\n         for (int i = 0; i < refValues.length; ++i) {\n         Arrays.sort(bigValues);\n         EigenDecomposition ed;\n         ed = new EigenDecomposition(createTestMatrix(r, bigValues),\n-                                        MathUtils.SAFE_MIN);\n+                                        Precision.SAFE_MIN);\n         double[] eigenValues = ed.getRealEigenvalues();\n         Assert.assertEquals(bigValues.length, eigenValues.length);\n         for (int i = 0; i < bigValues.length; ++i) {\n     @Test\n     public void testEigenvectors() {\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         for (int i = 0; i < matrix.getRowDimension(); ++i) {\n             double lambda = ed.getRealEigenvalue(i);\n             RealVector v  = ed.getEigenvector(i);\n     @Test\n     public void testAEqualVDVt() {\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(matrix, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(matrix, Precision.SAFE_MIN);\n         RealMatrix v  = ed.getV();\n         RealMatrix d  = ed.getD();\n         RealMatrix vT = ed.getVT();\n     /** test that V is orthogonal */\n     @Test\n     public void testVOrthogonal() {\n-        RealMatrix v = new EigenDecomposition(matrix, MathUtils.SAFE_MIN).getV();\n+        RealMatrix v = new EigenDecomposition(matrix, Precision.SAFE_MIN).getV();\n         RealMatrix vTv = v.transpose().multiply(v);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n         Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n         double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n         RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(m, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(m, Precision.SAFE_MIN);\n         Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);\n         Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);\n         Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);\n                 {4,  2,  3}\n         });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(repeated, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(repeated, Precision.SAFE_MIN);\n         checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n         checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n     }\n                 {-4, -4, 8}\n         });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(distinct, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(distinct, Precision.SAFE_MIN);\n         checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n         checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n         checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n                 { -1.0,0.0, 1.0 }\n         });\n         EigenDecomposition ed;\n-        ed = new EigenDecomposition(indefinite, MathUtils.SAFE_MIN);\n+        ed = new EigenDecomposition(indefinite, Precision.SAFE_MIN);\n         checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);\n         double isqrt3 = 1/FastMath.sqrt(3.0);\n         checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);\n--- a/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n \n import java.util.Random;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n \n import org.junit.Test;\n         Random r = new Random(9994100315209l);\n         RealMatrix m =\n             EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });\n-        DecompositionSolver es = new EigenDecomposition(m, MathUtils.SAFE_MIN).getSolver();\n+        DecompositionSolver es = new EigenDecomposition(m, Precision.SAFE_MIN).getSolver();\n         Assert.assertFalse(es.isNonSingular());\n         try {\n             es.getInverse();\n         Random r = new Random(9994100315209l);\n         RealMatrix m =\n             EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n-        DecompositionSolver es = new EigenDecomposition(m, MathUtils.SAFE_MIN).getSolver();\n+        DecompositionSolver es = new EigenDecomposition(m, Precision.SAFE_MIN).getSolver();\n         Assert.assertTrue(es.isNonSingular());\n         RealMatrix inverse = es.getInverse();\n         RealMatrix error =\n         };\n         final RealMatrix matrix = EigenDecompositionTest.createTestMatrix(new Random(35992629946426l), refValues);\n \n-        DecompositionSolver es = new EigenDecomposition(matrix, MathUtils.SAFE_MIN).getSolver();\n+        DecompositionSolver es = new EigenDecomposition(matrix, Precision.SAFE_MIN).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n         try {\n             es.solve(b);\n                 { 40,  2, 21,  9, 51, 19 },\n                 { 14, -1,  8,  0, 19, 14 }\n         });\n-        DecompositionSolver es = new EigenDecomposition(m, MathUtils.SAFE_MIN).getSolver();\n+        DecompositionSolver es = new EigenDecomposition(m, Precision.SAFE_MIN).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1561, 269, 188 },\n                 {   69, -21,  70 },\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import org.apache.commons.math.linear.SingularMatrixException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n                                                   costRelativeTolerance,\n                                                   parRelativeTolerance,\n                                                   orthoTolerance,\n-                                                  MathUtils.SAFE_MIN);\n+                                                  Precision.SAFE_MIN);\n             optimizer.optimize(maxCostEval, problem, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n--- a/src/test/java/org/apache/commons/math/util/FastMathStrictComparisonTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathStrictComparisonTest.java\n         Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, // 4,5\n         -Double.MAX_VALUE, Double.MAX_VALUE,                // 6,7\n         // decreasing order of absolute value to help catch first failure\n-        -MathUtils.EPSILON, MathUtils.EPSILON,              // 8,9\n-        -MathUtils.SAFE_MIN, MathUtils.SAFE_MIN,            // 10,11\n+        -Precision.EPSILON, Precision.EPSILON,              // 8,9\n+        -Precision.SAFE_MIN, Precision.SAFE_MIN,            // 10,11\n         -Double.MIN_VALUE, Double.MIN_VALUE,                // 12,13\n     };\n \n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n             {  Double.NaN, 0.0 },\n             {  Double.NaN, Double.NEGATIVE_INFINITY },\n             {  Double.NaN, Double.POSITIVE_INFINITY },\n-            { MathUtils.SAFE_MIN, MathUtils.EPSILON }\n+            { Precision.SAFE_MIN, Precision.EPSILON }\n         };\n         for (double[] pair : pairs) {\n             Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n                                 Math.min(pair[0], pair[1]),\n                                 FastMath.min(pair[0], pair[1]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n             Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n                                 Math.min(pair[1], pair[0]),\n                                 FastMath.min(pair[1], pair[0]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n             Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n                                 Math.max(pair[0], pair[1]),\n                                 FastMath.max(pair[0], pair[1]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n             Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n                                 Math.max(pair[1], pair[0]),\n                                 FastMath.max(pair[1], pair[0]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n         }\n     }\n \n             Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n                                 Math.min(pair[0], pair[1]),\n                                 FastMath.min(pair[0], pair[1]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n             Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n                                 Math.min(pair[1], pair[0]),\n                                 FastMath.min(pair[1], pair[0]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n             Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n                                 Math.max(pair[0], pair[1]),\n                                 FastMath.max(pair[0], pair[1]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n             Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n                                 Math.max(pair[1], pair[0]),\n                                 FastMath.max(pair[1], pair[0]),\n-                                MathUtils.EPSILON);\n+                                Precision.EPSILON);\n         }\n     }\n \n     public void testAtan2() {\n         double y1 = 1.2713504628280707e10;\n         double x1 = -5.674940885228782e-10;\n-        Assert.assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * MathUtils.EPSILON);\n+        Assert.assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * Precision.EPSILON);\n         double y2 = 0.0;\n         double x2 = Double.POSITIVE_INFINITY;\n-        Assert.assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), MathUtils.SAFE_MIN);\n+        Assert.assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), Precision.SAFE_MIN);\n     }\n \n     @Test\n         Assert.assertEquals(0, maxErr, 2);\n \n         maxErr = 0;\n-        for (double x = -1 + MathUtils.EPSILON; x < 1 - MathUtils.EPSILON; x += 0.0001) {\n+        for (double x = -1 + Precision.EPSILON; x < 1 - Precision.EPSILON; x += 0.0001) {\n             maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.tanh(FastMath.atanh(x))) / (2 * FastMath.ulp(x)));\n         }\n         Assert.assertEquals(0, maxErr, 2);\n \n         Assert.assertTrue(\"Log of negative number should be NaN\", Double.isNaN(FastMath.log(-1.0)));\n \n-        Assert.assertEquals(\"Log of Double.MIN_VALUE should be -744.4400719213812\", -744.4400719213812, FastMath.log(Double.MIN_VALUE), MathUtils.EPSILON);\n+        Assert.assertEquals(\"Log of Double.MIN_VALUE should be -744.4400719213812\", -744.4400719213812, FastMath.log(Double.MIN_VALUE), Precision.EPSILON);\n \n         Assert.assertTrue(\"Log of infinity should be infinity\", Double.isInfinite(FastMath.log(Double.POSITIVE_INFINITY)));\n     }\n     public void testExpSpecialCases() {\n \n         // Smallest value that will round up to Double.MIN_VALUE\n-        Assert.assertEquals(Double.MIN_VALUE, FastMath.exp(-745.1332191019411), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"exp(-745.1332191019412) should be 0.0\", 0.0, FastMath.exp(-745.1332191019412), MathUtils.EPSILON);\n+        Assert.assertEquals(Double.MIN_VALUE, FastMath.exp(-745.1332191019411), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"exp(-745.1332191019412) should be 0.0\", 0.0, FastMath.exp(-745.1332191019412), Precision.EPSILON);\n \n         Assert.assertTrue(\"exp of NaN should be NaN\", Double.isNaN(FastMath.exp(Double.NaN)));\n \n         Assert.assertTrue(\"exp of infinity should be infinity\", Double.isInfinite(FastMath.exp(Double.POSITIVE_INFINITY)));\n \n-        Assert.assertEquals(\"exp of -infinity should be 0.0\", 0.0, FastMath.exp(Double.NEGATIVE_INFINITY), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"exp(1) should be Math.E\", Math.E, FastMath.exp(1.0), MathUtils.EPSILON);\n+        Assert.assertEquals(\"exp of -infinity should be 0.0\", 0.0, FastMath.exp(Double.NEGATIVE_INFINITY), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"exp(1) should be Math.E\", Math.E, FastMath.exp(1.0), Precision.EPSILON);\n     }\n \n     @Test\n     public void testPowSpecialCases() {\n \n-        Assert.assertEquals(\"pow(-1, 0) should be 1.0\", 1.0, FastMath.pow(-1.0, 0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"pow(-1, -0) should be 1.0\", 1.0, FastMath.pow(-1.0, -0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"pow(PI, 1.0) should be PI\", FastMath.PI, FastMath.pow(FastMath.PI, 1.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"pow(-PI, 1.0) should be -PI\", -FastMath.PI, FastMath.pow(-FastMath.PI, 1.0), MathUtils.EPSILON);\n+        Assert.assertEquals(\"pow(-1, 0) should be 1.0\", 1.0, FastMath.pow(-1.0, 0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"pow(-1, -0) should be 1.0\", 1.0, FastMath.pow(-1.0, -0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"pow(PI, 1.0) should be PI\", FastMath.PI, FastMath.pow(FastMath.PI, 1.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"pow(-PI, 1.0) should be -PI\", -FastMath.PI, FastMath.pow(-FastMath.PI, 1.0), Precision.EPSILON);\n \n         Assert.assertTrue(\"pow(PI, NaN) should be NaN\", Double.isNaN(FastMath.pow(Math.PI, Double.NaN)));\n \n \n         Assert.assertTrue(\"pow(0.5, -Infinity) should be Infinity\", Double.isInfinite(FastMath.pow(0.5, Double.NEGATIVE_INFINITY)));\n \n-        Assert.assertEquals(\"pow(0.5, Infinity) should be 0.0\", 0.0, FastMath.pow(0.5, Double.POSITIVE_INFINITY), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"pow(2.0, -Infinity) should be 0.0\", 0.0, FastMath.pow(2.0, Double.NEGATIVE_INFINITY), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"pow(0.0, 0.5) should be 0.0\", 0.0, FastMath.pow(0.0, 0.5), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"pow(Infinity, -0.5) should be 0.0\", 0.0, FastMath.pow(Double.POSITIVE_INFINITY, -0.5), MathUtils.EPSILON);\n+        Assert.assertEquals(\"pow(0.5, Infinity) should be 0.0\", 0.0, FastMath.pow(0.5, Double.POSITIVE_INFINITY), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"pow(2.0, -Infinity) should be 0.0\", 0.0, FastMath.pow(2.0, Double.NEGATIVE_INFINITY), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"pow(0.0, 0.5) should be 0.0\", 0.0, FastMath.pow(0.0, 0.5), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"pow(Infinity, -0.5) should be 0.0\", 0.0, FastMath.pow(Double.POSITIVE_INFINITY, -0.5), Precision.EPSILON);\n \n         Assert.assertTrue(\"pow(0.0, -0.5) should be Inf\", Double.isInfinite(FastMath.pow(0.0, -0.5)));\n \n \n         Assert.assertTrue(\"pow(Inf, 3.5) should be Inf\", Double.isInfinite(FastMath.pow(Double.POSITIVE_INFINITY, 3.5)));\n \n-        Assert.assertEquals(\"pow(-2.0, 3.0) should be -8.0\", -8.0, FastMath.pow(-2.0, 3.0), MathUtils.EPSILON);\n+        Assert.assertEquals(\"pow(-2.0, 3.0) should be -8.0\", -8.0, FastMath.pow(-2.0, 3.0), Precision.EPSILON);\n \n         Assert.assertTrue(\"pow(-2.0, 3.5) should be NaN\", Double.isNaN(FastMath.pow(-2.0, 3.5)));\n \n \n         Assert.assertTrue(\"pow(-Inf, NaN) should be NaN\", Double.isNaN(FastMath.pow(Double.NEGATIVE_INFINITY, Double.NaN)));\n \n-        Assert.assertEquals(\"pow(-Inf, -1.0) should be 0.0\", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -1.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"pow(-Inf, -2.0) should be 0.0\", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -2.0), MathUtils.EPSILON);\n+        Assert.assertEquals(\"pow(-Inf, -1.0) should be 0.0\", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -1.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"pow(-Inf, -2.0) should be 0.0\", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -2.0), Precision.EPSILON);\n \n         Assert.assertTrue(\"pow(-Inf, 1.0) should be -Inf\", Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY, 1.0)));\n \n \n         Assert.assertTrue(\"atan2(0.0, NaN) should be NaN\", Double.isNaN(FastMath.atan2(0.0, Double.NaN)));\n \n-        Assert.assertEquals(\"atan2(0.0, 0.0) should be 0.0\", 0.0, FastMath.atan2(0.0, 0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(0.0, 0.001) should be 0.0\", 0.0, FastMath.atan2(0.0, 0.001), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(0.1, +Inf) should be 0.0\", 0.0, FastMath.atan2(0.1, Double.POSITIVE_INFINITY), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-0.0, 0.0) should be -0.0\", -0.0, FastMath.atan2(-0.0, 0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-0.0, 0.001) should be -0.0\", -0.0, FastMath.atan2(-0.0, 0.001), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-0.0, +Inf) should be -0.0\", -0.0, FastMath.atan2(-0.1, Double.POSITIVE_INFINITY), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(0.0, -0.0) should be PI\", FastMath.PI, FastMath.atan2(0.0, -0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(0.1, -Inf) should be PI\", FastMath.PI, FastMath.atan2(0.1, Double.NEGATIVE_INFINITY), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-0.0, -0.0) should be -PI\", -FastMath.PI, FastMath.atan2(-0.0, -0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(0.1, -Inf) should be -PI\", -FastMath.PI, FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(0.1, 0.0) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(0.1, 0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(0.1, -0.0) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(0.1, -0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(Inf, 0.1) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, 0.1), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(Inf, -0.1) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, -0.1), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-0.1, 0.0) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(-0.1, 0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-0.1, -0.0) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(-0.1, -0.0), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-Inf, 0.1) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1), MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"atan2(-Inf, -0.1) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1), MathUtils.EPSILON);\n+        Assert.assertEquals(\"atan2(0.0, 0.0) should be 0.0\", 0.0, FastMath.atan2(0.0, 0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(0.0, 0.001) should be 0.0\", 0.0, FastMath.atan2(0.0, 0.001), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(0.1, +Inf) should be 0.0\", 0.0, FastMath.atan2(0.1, Double.POSITIVE_INFINITY), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-0.0, 0.0) should be -0.0\", -0.0, FastMath.atan2(-0.0, 0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-0.0, 0.001) should be -0.0\", -0.0, FastMath.atan2(-0.0, 0.001), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-0.0, +Inf) should be -0.0\", -0.0, FastMath.atan2(-0.1, Double.POSITIVE_INFINITY), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(0.0, -0.0) should be PI\", FastMath.PI, FastMath.atan2(0.0, -0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(0.1, -Inf) should be PI\", FastMath.PI, FastMath.atan2(0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-0.0, -0.0) should be -PI\", -FastMath.PI, FastMath.atan2(-0.0, -0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(0.1, -Inf) should be -PI\", -FastMath.PI, FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(0.1, 0.0) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(0.1, 0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(0.1, -0.0) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(0.1, -0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(Inf, 0.1) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, 0.1), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(Inf, -0.1) should be PI/2\", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, -0.1), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-0.1, 0.0) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(-0.1, 0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-0.1, -0.0) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(-0.1, -0.0), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-Inf, 0.1) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1), Precision.EPSILON);\n+\n+        Assert.assertEquals(\"atan2(-Inf, -0.1) should be -PI/2\", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1), Precision.EPSILON);\n \n         Assert.assertEquals(\"atan2(Inf, Inf) should be PI/4\", FastMath.PI / 4.0, FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY),\n-                MathUtils.EPSILON);\n+                Precision.EPSILON);\n \n         Assert.assertEquals(\"atan2(Inf, -Inf) should be PI * 3/4\", FastMath.PI * 3.0 / 4.0,\n-                FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY), MathUtils.EPSILON);\n+                FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON);\n \n         Assert.assertEquals(\"atan2(-Inf, Inf) should be -PI/4\", -FastMath.PI / 4.0, FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY),\n-                MathUtils.EPSILON);\n+                Precision.EPSILON);\n \n         Assert.assertEquals(\"atan2(-Inf, -Inf) should be -PI * 3/4\", - FastMath.PI * 3.0 / 4.0,\n-                FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), MathUtils.EPSILON);\n+                FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON);\n     }\n \n     @Test\n \n         Assert.assertTrue(\"acos(-1.1) should be NaN\", Double.isNaN(FastMath.acos(1.1)));\n         \n-        Assert.assertEquals(\"acos(-1.0) should be PI\", FastMath.acos(-1.0), FastMath.PI, MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"acos(1.0) should be 0.0\", FastMath.acos(1.0), 0.0, MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"acos(0.0) should be PI/2\", FastMath.acos(0.0), FastMath.PI / 2.0, MathUtils.EPSILON);\n+        Assert.assertEquals(\"acos(-1.0) should be PI\", FastMath.acos(-1.0), FastMath.PI, Precision.EPSILON);\n+\n+        Assert.assertEquals(\"acos(1.0) should be 0.0\", FastMath.acos(1.0), 0.0, Precision.EPSILON);\n+\n+        Assert.assertEquals(\"acos(0.0) should be PI/2\", FastMath.acos(0.0), FastMath.PI / 2.0, Precision.EPSILON);\n     }\n \n     /**\n         \n         Assert.assertTrue(\"asin(-1.1) should be NaN\", Double.isNaN(FastMath.asin(-1.1)));\n         \n-        Assert.assertEquals(\"asin(1.0) should be PI/2\", FastMath.asin(1.0), FastMath.PI / 2.0, MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"asin(-1.0) should be -PI/2\", FastMath.asin(-1.0), -FastMath.PI / 2.0, MathUtils.EPSILON);\n-\n-        Assert.assertEquals(\"asin(0.0) should be 0.0\", FastMath.asin(0.0), 0.0, MathUtils.EPSILON);\n+        Assert.assertEquals(\"asin(1.0) should be PI/2\", FastMath.asin(1.0), FastMath.PI / 2.0, Precision.EPSILON);\n+\n+        Assert.assertEquals(\"asin(-1.0) should be -PI/2\", FastMath.asin(-1.0), -FastMath.PI / 2.0, Precision.EPSILON);\n+\n+        Assert.assertEquals(\"asin(0.0) should be 0.0\", FastMath.asin(0.0), 0.0, Precision.EPSILON);\n     }\n \n     private Dfp cosh(Dfp x) {", "timestamp": 1319685114, "metainfo": ""}