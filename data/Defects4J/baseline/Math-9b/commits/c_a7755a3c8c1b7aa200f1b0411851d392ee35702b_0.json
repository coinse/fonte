{"sha": "a7755a3c8c1b7aa200f1b0411851d392ee35702b", "log": "Javadoc only. Added @since tags.  ", "commit": "\n--- a/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n+++ b/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n /**\n  * Error thrown when a method is called with an out of bounds argument.\n  *\n+ * @since 1.2\n  * @version $Revision$ $Date$\n  */\n public class ArgumentOutsideDomainException extends FunctionEvaluationException {\n--- a/src/java/org/apache/commons/math/ConvergenceException.java\n+++ b/src/java/org/apache/commons/math/ConvergenceException.java\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @since 1.2\n      */\n     public ConvergenceException(String pattern, Object[] arguments) {\n         super(pattern, arguments);\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @param cause  the exception or error that caused this exception to be thrown\n+     * @since 1.2\n      */\n     public ConvergenceException(String pattern, Object[] arguments, Throwable cause) {\n         super(pattern, arguments, cause);\n--- a/src/java/org/apache/commons/math/DimensionMismatchException.java\n+++ b/src/java/org/apache/commons/math/DimensionMismatchException.java\n \n /**\n  * Error thrown when two dimensions differ.\n+ * \n+ * @since 1.2\n  * @version $Revision$ $Date$\n  */\n public class DimensionMismatchException extends MathException {\n--- a/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+++ b/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n \n /**\n  * Exeption thrown when a sample contains several entries at the same abscissa.\n+ * \n+ * @since 1.2\n  * @version $Revision$ $Date$\n  */\n public class DuplicateSampleAbscissaException extends MathException  {\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n      * @param argument  the failing function argument \n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @since 1.2\n      */\n     public FunctionEvaluationException(double argument,\n                                        String pattern, Object[] arguments) {\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param argument  the failing function argument \n      * @param cause  the exception or error that caused this exception to be thrown\n+     * @since 1.2\n      */\n     public FunctionEvaluationException(double argument, Throwable cause) {\n         super(cause);\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @param cause  the exception or error that caused this exception to be thrown\n+     * @since 1.2\n      */\n     public FunctionEvaluationException(double argument,\n                                        String pattern, Object[] arguments,\n--- a/src/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/java/org/apache/commons/math/MathConfigurationException.java\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n+     * @since 1.2\n      */\n     public MathConfigurationException(String pattern, Object[] arguments) {\n         super(pattern, arguments);\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @param cause  the exception or error that caused this exception to be thrown\n+     * @since 1.2\n      */\n     public MathConfigurationException(String pattern, Object[] arguments, Throwable cause) {\n         super(pattern, arguments, cause);\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n      * @param arguments format arguments\n-     * @param rootCause  the exception or error that caused this exception\n-     *                   to be thrown.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @since 1.2\n      */\n     public MathException(String pattern, Object[] arguments, Throwable rootCause) {\n       super(buildMessage(pattern, arguments, Locale.US));\n     /** Gets the pattern used to build the message of this throwable.\n      *\n      * @return the pattern used to build the message of this throwable\n+     * @since 1.2\n      */\n     public String getPattern() {\n         return pattern;\n     /** Gets the arguments used to build the message of this throwable.\n      *\n      * @return the arguments used to build the message of this throwable\n+     * @since 1.2\n      */\n     public Object[] getArguments() {\n         return (Object[]) arguments.clone();\n      * @param locale Locale in which the message should be translated\n      * \n      * @return localized message\n+     * @since 1.2\n      */\n     public String getMessage(Locale locale) {\n         return (pattern == null) ? null : buildMessage(pattern, arguments, locale);\n--- a/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n+++ b/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n  * number of iterations.\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class MaxIterationsExceededException extends ConvergenceException {\n \n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n \n import java.util.ListResourceBundle;\n \n-/** French localization message resources for the commons-math library.\n+/** \n+ * French localization message resources for the commons-math library.\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class MessagesResources_fr\n   extends ListResourceBundle {\n \n-  /** Simple constructor.\n+  /** \n+   * Simple constructor.\n    */\n   public MessagesResources_fr() {\n   }\n \n-  /** Get the non-translated/translated messages arrays from this resource bundle.\n+  /** \n+   * Get the non-translated/translated messages arrays from this resource bundle.\n    * @return non-translated/translated messages arrays\n    */\n   public Object[][] getContents() {\n--- a/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n  * this class provides an easy-to-use interface to it.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,\n     Serializable {\n--- a/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/LaguerreSolver.java\n  * approximation and be able to solve all roots from that point.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class LaguerreSolver extends UnivariateRealSolverImpl {\n \n--- a/src/java/org/apache/commons/math/analysis/MullerSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/MullerSolver.java\n  * real zeros, using different ways to bypass complex arithmetics.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class MullerSolver extends UnivariateRealSolverImpl {\n \n--- a/src/java/org/apache/commons/math/analysis/NevilleInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/NevilleInterpolator.java\n  * this class provides an easy-to-use interface to it.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class NevilleInterpolator implements UnivariateRealInterpolator,\n     Serializable {\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n  * to work well. Otherwise, consider using splines instead.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction,\n     Serializable {\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java\n  * Note that the length of a[] is one more than the length of c[]</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,\n     Serializable {\n--- a/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/RiddersSolver.java\n  * The function should be continuous but not necessarily smooth.</p>\n  *  \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class RiddersSolver extends UnivariateRealSolverImpl {\n \n--- a/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/RombergIntegrator.java\n  * is a special case of k = 2.</p>\n  *  \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n \n--- a/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/SimpsonIntegrator.java\n  * calculate the Simpson's rule of alternating 2/3 and 4/3.</p>\n  *  \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n \n--- a/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/TrapezoidIntegrator.java\n  * The function should be integrable.</p>\n  *  \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n \n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealIntegrator.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealIntegrator.java\n  * Interface for univariate real integration algorithms.\n  *  \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public interface UnivariateRealIntegrator {\n \n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealIntegratorImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealIntegratorImpl.java\n  * Provide a default implementation for several generic functions.\n  *  \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public abstract class UnivariateRealIntegratorImpl implements\n     UnivariateRealIntegrator, Serializable {\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n  * or imaginary part - e.g., <pre>\n  * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre></p>\n  *\n- * @author Apache Software Foundation\n  * @version $Revision$ $Date$\n  */\n public class Complex implements Serializable  {\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n  * <p>This base class handles the boilerplates methods associated to thresholds\n  * settings, jacobian and error estimation.</p>\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n public abstract class AbstractEstimator implements Estimator {\n--- a/src/java/org/apache/commons/math/estimation/EstimatedParameter.java\n+++ b/src/java/org/apache/commons/math/estimation/EstimatedParameter.java\n  * satisfy convergence criterions specific to each solver.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n \n--- a/src/java/org/apache/commons/math/estimation/EstimationException.java\n+++ b/src/java/org/apache/commons/math/estimation/EstimationException.java\n  * This class represents exceptions thrown by the estimation solvers.\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n \n--- a/src/java/org/apache/commons/math/estimation/EstimationProblem.java\n+++ b/src/java/org/apache/commons/math/estimation/EstimationProblem.java\n  * @see WeightedMeasurement\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n \n--- a/src/java/org/apache/commons/math/estimation/Estimator.java\n+++ b/src/java/org/apache/commons/math/estimation/Estimator.java\n  * @see EstimationProblem\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n \n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n  * Gauss-Newton algorithm.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n \n--- a/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n  * @author Jorge J. More (original fortran)\n \n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n+ *\n  */\n public class LevenbergMarquardtEstimator extends AbstractEstimator implements Serializable {\n \n--- a/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n+++ b/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n  * various parameters and their current estimate.</p>\n \n  * @version $Revision$ $Date$\n+ * @since 1.2\n \n  */\n public class SimpleEstimationProblem implements EstimationProblem {\n--- a/src/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n+++ b/src/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n  * @see EstimationProblem\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n \n--- a/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n  * in the allowed number of iterations.\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class FractionConversionException extends ConvergenceException {\n \n--- a/src/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+++ b/src/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n  * or Euler angles from a rotation.\n \n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n public class CardanEulerSingularityException\n   extends MathException {\n \n-  /** Simple constructor.\n+  /** \n+   * Simple constructor.\n    * build an exception with a default message.\n    * @param isCardan if true, the rotation is related to Cardan angles,\n    * if false it is related to EulerAngles\n--- a/src/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n+++ b/src/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n \n import org.apache.commons.math.MathException;\n \n-/** This class represents exceptions thrown while building rotations\n+/** \n+ * This class represents exceptions thrown while building rotations\n  * from matrices.\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class NotARotationMatrixException\n   extends MathException {\n \n-  /** Simple constructor.\n+  /** \n+   * Simple constructor.\n    * Build an exception by translating and formating a message\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n \n /**\n  * This class implements rotations in a three-dimensional space.\n-\n+ *\n  * <p>Rotations can be represented by several different mathematical\n  * entities (matrices, axe and angle, Cardan or Euler angles,\n  * quaternions). This class presents an higher level abstraction, more\n  * need to transform the observing direction in the topocentric frame into the\n  * observing direction in inertial frame taking into account the observatory\n  * location and the Earth rotation.</p>\n-\n+ *\n  * <p>These examples show that a rotation is what the user wants it to be, so this\n  * class does not push the user towards one specific definition and hence does not\n  * provide methods like <code>projectVectorIntoDestinationFrame</code> or\n  * <code>computeTransformedDirection</code>. It provides simpler and more generic\n  * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link\n  * #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n-\n+ *\n  * <p>Since a rotation is basically a vectorial operator, several rotations can be\n  * composed together and the composite operation <code>r = r<sub>1</sub> o\n  * r<sub>2</sub></code> (which means that for each vector <code>u</code>,\n  * we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the\n  * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and\n  * {@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n-\n+ *\n  * <p>Rotations are guaranteed to be immutable objects.</p>\n-\n+ *\n  * @version $Revision$ $Date$\n  * @see Vector3D\n  * @see RotationOrder\n-\n+ * @since 1.2\n  */\n \n public class Rotation implements Serializable {\n--- a/src/java/org/apache/commons/math/geometry/RotationOrder.java\n+++ b/src/java/org/apache/commons/math/geometry/RotationOrder.java\n /**\n  * This class is a utility representing a rotation order specification\n  * for Cardan or Euler angles specification.\n-\n+ *\n  * This class cannot be instanciated by the user. He can only use one\n  * of the twelve predefined supported orders as an argument to either\n  * the {@link Rotation#Rotation(RotationOrder,double,double,double)}\n  * constructor or the {@link Rotation#getAngles} method.\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n public final class RotationOrder {\n \n--- a/src/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n \n import java.io.Serializable;\n \n-/** This class implements vectors in a three-dimensional space.\n+/** \n+ * This class implements vectors in a three-dimensional space.\n  * <p>Instance of this class are guaranteed to be immutable.</p>\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n \n public class Vector3D\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n  *   \n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n- * \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public interface QRDecomposition {\n \n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n  * orthogonal (Q<sup>T</sup>Q = I), and R is upper triangular. If A is\n  * m&times;n, Q is m&times;m and R m&times;n. \n  * <p>\n- * Implemented using Householder reflectors.\n- *\n+ * Implemented using Householder reflectors.</p>\n  *\n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n  * \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class QRDecompositionImpl implements QRDecomposition {\n \n--- a/src/java/org/apache/commons/math/ode/AbstractStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/AbstractStepInterpolator.java\n  * @see StepHandler\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  *\n  */\n \n--- a/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/AdaptiveStepsizeIntegrator.java\n /**\n  * This abstract class holds the common part of all adaptive\n  * stepsize integrators for Ordinary Differential Equations.\n-\n+ *\n  * <p>These algorithms perform integration with stepsize control, which\n  * means the user does not specify the integration step but rather a\n  * tolerance on error. The error threshold is computed as\n  * state vector and relTol_i is the relative tolerance for the same\n  * component. The user can also use only two scalar values absTol and\n  * relTol which will be used for all components.</p>\n-\n+ *\n  * <p>If the estimated error for ym+1 is such that\n  * <pre>\n  * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1\n  * </pre>\n-\n+ *\n  * (where n is the state vector dimension) then the step is accepted,\n  * otherwise the step is rejected and a new attempt is made with a new\n  * stepsize.</p>\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n+ *\n  */\n \n public abstract class AdaptiveStepsizeIntegrator\n--- a/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaIntegrator.java\n  * This class implements the classical fourth order Runge-Kutta\n  * integrator for Ordinary Differential Equations (it is the most\n  * often used Runge-Kutta method).\n-\n+ *\n  * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n  * is the following one :\n  * <pre>\n  *       | 1/6  1/3  1/3  1/6\n  * </pre>\n  * </p>\n-\n+ *\n  * @see EulerIntegrator\n  * @see GillIntegrator\n  * @see MidpointIntegrator\n  * @see ThreeEighthesIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class ClassicalRungeKuttaIntegrator\n--- a/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolator.java\n /**\n  * This class implements a step interpolator for the classical fourth\n  * order Runge-Kutta integrator.\n-\n+ *\n  * <p>This interpolator allows to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n  *                                          -(4 theta^2 +   theta + 1) y'_4\n  *                                        ]\n  * </pre>\n-\n+ *\n  * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n  * evaluations of the derivatives already computed during the\n  * step.</p>\n-\n+ *\n  * @see ClassicalRungeKuttaIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n class ClassicalRungeKuttaStepInterpolator\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n  * This class stores all information provided by an ODE integrator\n  * during the integration process and build a continuous model of the\n  * solution from this.\n-\n+ *\n  * <p>This class act as a step handler from the integrator point of\n  * view. It is called iteratively during the integration process and\n  * stores a copy of all steps information in a sorted collection for\n  * integration to be over before attempting to call {@link\n  * #setInterpolatedTime setInterpolatedTime} because some internal\n  * variables are set only once the last step has been handled.</p>\n-\n+ *\n  * <p>This is useful for example if the main loop of the user\n  * application should remain independent from the integration process\n  * or if one needs to mimic the behaviour of an analytical model\n  * despite a numerical model is used (i.e. one needs the ability to\n  * get the model value at any time or to navigate through the\n  * data).</p>\n-\n+ *\n  * <p>If problem modelization is done with several separate\n  * integration phases for contiguous intervals, the same\n  * ContinuousOutputModel can be used as step handler for all\n  * output model handles the steps of all integration phases, the user\n  * do not need to bother when the maneuver begins or ends, he has all\n  * the data available in a transparent manner.</p>\n-\n+ *\n  * <p>An important feature of this class is that it implements the\n  * <code>Serializable</code> interface. This means that the result of\n  * an integration can be serialized and reused later (if stored into a\n  * sent to another application). Only the result of the integration is\n  * stored, there is no reference to the integrated problem by\n  * itself.</p>\n-\n+ *\n  * <p>One should be aware that the amount of data stored in a\n  * ContinuousOutputModel instance can be important if the state vector\n  * is large, if the integration interval is long or if the steps are\n  * small (which can result from small tolerance settings in {@link\n  * AdaptiveStepsizeIntegrator adaptive step size integrators}).</p>\n-\n+ *\n  * @see StepHandler\n  * @see StepInterpolator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class ContinuousOutputModel\n--- a/src/java/org/apache/commons/math/ode/DerivativeException.java\n+++ b/src/java/org/apache/commons/math/ode/DerivativeException.java\n  * the error conditions that are trigegred while computing\n  * the differential equations.\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class DerivativeException\n   extends MathException {\n--- a/src/java/org/apache/commons/math/ode/DormandPrince54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54Integrator.java\n  * is an <i>fsal</i>, the last evaluation of one step is the same as\n  * the first evaluation of the next step and hence can be avoided. So\n  * the cost is really 6 functions evaluations per step.</p>\n-\n+ *\n  * <p>This method has been published (whithout the continuous output\n  * that was added by Shampine in 1986) in the following article :\n  * <pre>\n  *  Journal of Computational and Applied Mathematics\n  *  volume 6, no 1, 1980, pp. 19-26\n  * </pre></p>\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class DormandPrince54Integrator\n--- a/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n  * @see DormandPrince54Integrator\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n class DormandPrince54StepInterpolator\n--- a/src/java/org/apache/commons/math/ode/DormandPrince853Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853Integrator.java\n /**\n  * This class implements the 8(5,3) Dormand-Prince integrator for Ordinary\n  * Differential Equations.\n-\n+ *\n  * <p>This integrator is an embedded Runge-Kutta integrator\n  * of order 8(5,3) used in local extrapolation mode (i.e. the solution\n  * is computed using the high order formula) with stepsize control\n  * <i>fsal</i>. Hence, despite we have 13 stages here, the cost is\n  * really 12 evaluations per step even if no interpolation is done,\n  * and the overcost of interpolation is only 3 evaluations.</p>\n-\n+ *\n  * <p>This method is based on an 8(6) method by Dormand and Prince\n  * (i.e. order 8 for the integration and order 6 for error estimation)\n  * modified by Hairer and Wanner to use a 5th order error estimator\n  * Problems) of the reference book by Hairer, Norsett and Wanner:\n  * <i>Solving Ordinary Differential Equations</i> (Springer-Verlag,\n  * ISBN 3-540-56670-8).</p>\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class DormandPrince853Integrator\n--- a/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n  * @see DormandPrince853Integrator\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n class DormandPrince853StepInterpolator\n--- a/src/java/org/apache/commons/math/ode/DummyStepHandler.java\n+++ b/src/java/org/apache/commons/math/ode/DummyStepHandler.java\n  * <p>This class is provided as a convenience for users who are only\n  * interested in the final state of an integration and not in the\n  * intermediate steps. Its handleStep method does nothing.</p>\n-\n+ *\n  * <p>Since this class has no internal state, it is implemented using\n  * the Singleton design pattern. This means that only one instance is\n  * ever created, which can be retrieved using the getInstance\n  * method. This explains why there is no public constructor.</p>\n-\n+ *\n  * @see StepHandler\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class DummyStepHandler\n--- a/src/java/org/apache/commons/math/ode/DummyStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DummyStepInterpolator.java\n  * @see StepHandler\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n public class DummyStepInterpolator\n--- a/src/java/org/apache/commons/math/ode/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/EmbeddedRungeKuttaIntegrator.java\n /**\n  * This class implements the common part of all embedded Runge-Kutta\n  * integrators for Ordinary Differential Equations.\n-\n+ *\n  * <p>These methods are embedded explicit Runge-Kutta methods with two\n  * sets of coefficients allowing to estimate the error, their Butcher\n  * arrays are as follows :\n  *       |  b'1  b'2 ...   b's-1 b's\n  * </pre>\n  * </p>\n-\n+ *\n  * <p>In fact, we rather use the array defined by ej = bj - b'j to\n  * compute directly the error rather than computing two estimates and\n  * then comparing them.</p>\n-\n+ *\n  * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n  * methods. This means the last evaluation of the derivatives in one\n  * step is the same as the first in the next step. Then, this\n  * the step is rejected after the error estimation phase, no\n  * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n  * asi = bi for all i.</p>\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public abstract class EmbeddedRungeKuttaIntegrator\n--- a/src/java/org/apache/commons/math/ode/EulerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/EulerIntegrator.java\n /**\n  * This class implements a simple Euler integrator for Ordinary\n  * Differential Equations.\n-\n+ *\n  * <p>The Euler algorithm is the simplest one that can be used to\n  * integrate ordinary differential equations. It is a simple inversion\n  * of the forward difference expression :\n  * <code>f'=(f(t+h)-f(t))/h</code> which leads to\n  * <code>f(t+h)=f(t)+hf'</code>. The interpolation scheme used for\n  * dense output is the linear scheme already used for integration.</p>\n-\n+ *\n  * <p>This algorithm looks cheap because it needs only one function\n  * evaluation per step. However, as it uses linear estimates, it needs\n  * very small steps to achieve high accuracy, and small steps lead to\n  * numerical errors and instabilities.</p>\n-\n+ *\n  * <p>This algorithm is almost never used and has been included in\n  * this package only as a comparison reference for more useful\n  * integrators.</p>\n-\n+ *\n  * @see MidpointIntegrator\n  * @see ClassicalRungeKuttaIntegrator\n  * @see GillIntegrator\n  * @see ThreeEighthesIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class EulerIntegrator\n--- a/src/java/org/apache/commons/math/ode/EulerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/EulerStepInterpolator.java\n \n /**\n  * This class implements a linear interpolator for step.\n-\n+ *\n  * <p>This interpolator allow to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n-\n+ *\n  * <pre>\n  *   y(t_n + theta h) = y (t_n + h) - (1-theta) h y'\n  * </pre>\n-\n+ *\n  * where theta belongs to [0 ; 1] and where y' is the evaluation of\n  * the derivatives already computed during the step.</p>\n-\n+ *\n  * @see EulerIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n class EulerStepInterpolator\n--- a/src/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderConverter.java\n \n /** This class converts second order differential equations to first\n  * order ones.\n-\n+ *\n  * <p>This class is a wrapper around a {@link\n  * SecondOrderDifferentialEquations} which allow to use a {@link\n  * FirstOrderIntegrator} to integrate it.</p>\n-\n+ *\n  * <p>The transformation is done by changing the n dimension state\n  * vector to a 2n dimension vector, where the first n components are\n  * the initial state variables and the n last components are their\n  * vector then really contains both the first and second time\n  * derivative of the initial state vector, which can be handled by the\n  * underlying second order equations set.</p>\n-\n+ *\n  * <p>One should be aware that the data is duplicated during the\n  * transformation process and that for each call to {@link\n  * #computeDerivatives computeDerivatives}, this wrapper does copy 4n\n  * avoid this duplication is to perform the transformation at the\n  * problem level, i.e. to implement the problem as a first order one\n  * and then avoid using this class.</p>\n-\n+ *\n  * @see FirstOrderIntegrator\n  * @see FirstOrderDifferentialEquations\n  * @see SecondOrderDifferentialEquations\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class FirstOrderConverter\n--- a/src/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n  * @see SecondOrderDifferentialEquations\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n public interface FirstOrderDifferentialEquations {\n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n  * equations should implement this interface. The problems which can\n  * be handled should implement the {@link\n  * FirstOrderDifferentialEquations} interface.</p>\n-\n+ *\n  * @see FirstOrderDifferentialEquations\n  * @see StepHandler\n  * @see SwitchingFunction\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public interface FirstOrderIntegrator {\n--- a/src/java/org/apache/commons/math/ode/FixedStepHandler.java\n+++ b/src/java/org/apache/commons/math/ode/FixedStepHandler.java\n  * {@link StepNormalizer} object is called according to the integrator\n  * internal algorithms and it calls objects implementing this\n  * interface as necessary at fixed time steps.</p>\n-\n+ *\n  * @see StepHandler\n  * @see StepNormalizer\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public interface FixedStepHandler {\n--- a/src/java/org/apache/commons/math/ode/GillIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GillIntegrator.java\n  *       |   1/6    (2-q)/6 (2+q)/6  1/6\n  * </pre>\n  * where q = sqrt(2)</p>\n-\n+ *\n  * @see EulerIntegrator\n  * @see ClassicalRungeKuttaIntegrator\n  * @see MidpointIntegrator\n  * @see ThreeEighthesIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class GillIntegrator\n--- a/src/java/org/apache/commons/math/ode/GillStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/GillStepInterpolator.java\n /**\n  * This class implements a step interpolator for the Gill fourth\n  * order Runge-Kutta integrator.\n-\n+ *\n  * <p>This interpolator allows to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n-\n+ *\n  * <pre>\n  *   y(t_n + theta h) = y (t_n + h)\n  *                    - (1 - theta) (h/6) [ (1 - theta) (1 - 4 theta) y'_1\n  * where theta belongs to [0 ; 1], q = sqrt(2) and where y'_1 to y'_4\n  * are the four evaluations of the derivatives already computed during\n  * the step.</p>\n-\n+ *\n  * @see GillIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n class GillStepInterpolator\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerIntegrator.java\n /**\n  * This class implements a Gragg-Bulirsch-Stoer integrator for\n  * Ordinary Differential Equations.\n-\n+ *\n  * <p>The Gragg-Bulirsch-Stoer algorithm is one of the most efficient\n  * ones currently available for smooth problems. It uses Richardson\n  * extrapolation to estimate what would be the solution if the step\n  * size could be decreased down to zero.</p>\n-\n+ *\n  * <p>\n  * This method changes both the step size and the order during\n  * integration, in order to minimize computation cost. It is\n  * bodies (pleiades problem, involving quasi-collisions for which\n  * <i>automatic step size control is essential</i>).\n  * </p>\n-\n+ *\n  * <p>\n  * This implementation is basically a reimplementation in Java of the\n  * <a\n  * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n  * convenience, it is reproduced below.</p>\n  * </p>\n-\n+ *\n  * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n  * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n-\n+ *\n  * <tr><td>Redistribution and use in source and binary forms, with or\n  * without modification, are permitted provided that the following\n  * conditions are met:\n  *      notice, this list of conditions and the following disclaimer in the\n  *      documentation and/or other materials provided with the distribution.</li>\n  * </ul></td></tr>\n-\n+ *\n  * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n  * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n  * </table>\n-\n+ *\n  * @author E. Hairer and G. Wanner (fortran version)\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class GraggBulirschStoerIntegrator\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolator.java\n /**\n  * This class implements an interpolator for the Gragg-Bulirsch-Stoer\n  * integrator.\n-\n+ *\n  * <p>This interpolator compute dense output inside the last step\n  * produced by a Gragg-Bulirsch-Stoer integrator.</p>\n-\n+ *\n  * <p>\n  * This implementation is basically a reimplementation in Java of the\n  * <a\n  * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n  * convenience, it is reproduced below.</p>\n  * </p>\n-\n+ *\n  * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n  * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n-\n+ *\n  * <tr><td>Redistribution and use in source and binary forms, with or\n  * without modification, are permitted provided that the following\n  * conditions are met:\n  *      notice, this list of conditions and the following disclaimer in the\n  *      documentation and/or other materials provided with the distribution.</li>\n  * </ul></td></tr>\n-\n+ *\n  * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n  * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n  * </table>\n-\n+ *\n  * @see GraggBulirschStoerIntegrator\n-\n  * @version $Revision$ $Date$\n  * @author E. Hairer and G. Wanner (fortran version)\n-\n+ * @since 1.2\n  */\n \n class GraggBulirschStoerStepInterpolator\n--- a/src/java/org/apache/commons/math/ode/HighamHall54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54Integrator.java\n /**\n  * This class implements the 5(4) Higham and Hall integrator for\n  * Ordinary Differential Equations.\n-\n+ *\n  * <p>This integrator is an embedded Runge-Kutta integrator\n  * of order 5(4) used in local extrapolation mode (i.e. the solution\n  * is computed using the high order formula) with stepsize control\n  * (and automatic step initialization) and continuous output. This\n  * method uses 7 functions evaluations per step.</p>\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class HighamHall54Integrator\n--- a/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n  * @see HighamHall54Integrator\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n class HighamHall54StepInterpolator\n--- a/src/java/org/apache/commons/math/ode/IntegratorException.java\n+++ b/src/java/org/apache/commons/math/ode/IntegratorException.java\n  * This exception is made available to users to report\n  * the error conditions that are triggered during integration\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class IntegratorException\n   extends MathException {\n--- a/src/java/org/apache/commons/math/ode/MidpointIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/MidpointIntegrator.java\n /**\n  * This class implements a second order Runge-Kutta integrator for\n  * Ordinary Differential Equations.\n-\n+ *\n  * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n  * is the following one :\n  * <pre>\n  *       |  0    1\n  * </pre>\n  * </p>\n-\n+ *\n  * @see EulerIntegrator\n  * @see ClassicalRungeKuttaIntegrator\n  * @see GillIntegrator\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class MidpointIntegrator\n--- a/src/java/org/apache/commons/math/ode/MidpointStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/MidpointStepInterpolator.java\n /**\n  * This class implements a step interpolator for second order\n  * Runge-Kutta integrator.\n-\n+ *\n  * <p>This interpolator allow to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n-\n+ *\n  * <pre>\n  *   y(t_n + theta h) = y (t_n + h) + (1-theta) h [theta y'_1 - (1+theta) y'_2]\n  * </pre>\n-\n+ *\n  * where theta belongs to [0 ; 1] and where y'_1 and y'_2 are the two\n  * evaluations of the derivatives already computed during the\n  * step.</p>\n-\n+ *\n  * @see MidpointIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n class MidpointStepInterpolator\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n /**\n  * This class implements the common part of all fixed step Runge-Kutta\n  * integrators for Ordinary Differential Equations.\n-\n+ *\n  * <p>These methods are explicit Runge-Kutta methods, their Butcher\n  * arrays are as follows :\n  * <pre>\n  *       |  b1   b2  ...   bs-1  bs\n  * </pre>\n  * </p>\n-\n+ *\n  * @see EulerIntegrator\n  * @see ClassicalRungeKuttaIntegrator\n  * @see GillIntegrator\n  * @see MidpointIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public abstract class RungeKuttaIntegrator\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaStepInterpolator.java\n  * @see EmbeddedRungeKuttaIntegrator\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n abstract class RungeKuttaStepInterpolator\n--- a/src/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n+++ b/src/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n  * <p>This interface should be implemented by all real second order\n  * differential equation problems before they can be handled by the\n  * integrators {@link SecondOrderIntegrator#integrate} method.</p>\n-\n+ *\n  * <p>A second order differential equations problem, as seen by an\n  * integrator is the second time derivative <code>d2Y/dt^2</code> of a\n  * state vector <code>Y</code>, both being one dimensional\n  * only on the current time <code>t</code>, on the state vector\n  * <code>Y</code> and on the first time derivative of the state\n  * vector.</p>\n-\n+ *\n  * <p>For real problems, the derivative depends also on parameters\n  * that do not belong to the state vector (dynamical model constants\n  * for example). These constants are completely outside of the scope\n  * of this interface, the classes that implement it are allowed to\n  * handle them as they want.</p>\n-\n+ *\n  * @see SecondOrderIntegrator\n  * @see FirstOrderConverter\n  * @see FirstOrderDifferentialEquations\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public interface SecondOrderDifferentialEquations {\n--- a/src/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n \n /** This interface represents a second order integrator for\n  * differential equations.\n-\n+ *\n  * <p>The classes which are devoted to solve second order differential\n  * equations should implement this interface. The problems which can\n  * be handled should implement the {@link\n  * SecondOrderDifferentialEquations} interface.</p>\n-\n+ *\n  * @see SecondOrderDifferentialEquations\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public interface SecondOrderIntegrator {\n--- a/src/java/org/apache/commons/math/ode/StepHandler.java\n+++ b/src/java/org/apache/commons/math/ode/StepHandler.java\n /**\n  * This interface represents a handler that should be called after\n  * each successful step.\n-\n+ *\n  * <p>The ODE integrators compute the evolution of the state vector at\n  * some grid points that depend on their own internal algorithm. Once\n  * they have found a new grid point (possibly after having computed\n  * typically either ignore the intermediate steps and wait for the\n  * last one, store the points in an ephemeris, or forward them to\n  * specialized processing or output methods.</p>\n-\n+ *\n  * @see FirstOrderIntegrator\n  * @see SecondOrderIntegrator\n  * @see StepInterpolator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public interface StepHandler {\n--- a/src/java/org/apache/commons/math/ode/StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/StepInterpolator.java\n  * @see FirstOrderIntegrator\n  * @see SecondOrderIntegrator\n  * @see StepHandler\n- *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n public interface StepInterpolator\n--- a/src/java/org/apache/commons/math/ode/StepNormalizer.java\n+++ b/src/java/org/apache/commons/math/ode/StepNormalizer.java\n  * integrators which cannot guaranty their integration steps will\n  * remain constant and therefore only accept general step\n  * handlers.</p>\n-\n+ *\n  * <p>The stepsize used is selected at construction time. The {@link\n  * FixedStepHandler#handleStep handleStep} method of the underlying\n  * {@link FixedStepHandler} object is called at the beginning time of\n  * last point handled will be the endpoint of the integration tend, if\n  * not, the last point will belong to the interval [tend - h ;\n  * tend].</p>\n-\n+ *\n  * <p>There is no constraint on the integrator, it can use any\n  * timestep it needs (time steps longer or shorter than the fixed time\n  * step and non-integer ratios are all allowed).</p>\n-\n+ *\n  * @see StepHandler\n  * @see FixedStepHandler\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class StepNormalizer\n--- a/src/java/org/apache/commons/math/ode/SwitchState.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchState.java\n  * occurs at a bound rather than inside the step).</p>\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n class SwitchState implements Serializable {\n \n--- a/src/java/org/apache/commons/math/ode/SwitchingFunction.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunction.java\n  * fixed step ones).</p>\n  *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n public interface SwitchingFunction extends Serializable {\n--- a/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n+++ b/src/java/org/apache/commons/math/ode/SwitchingFunctionsHandler.java\n  * functions} during integration.\n  *\n  * @see SwitchingFunction\n- *\n  * @version $Revision$ $Date$\n- *\n+ * @since 1.2\n  */\n \n public class SwitchingFunctionsHandler {\n--- a/src/java/org/apache/commons/math/ode/ThreeEighthesIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/ThreeEighthesIntegrator.java\n /**\n  * This class implements the 3/8 fourth order Runge-Kutta\n  * integrator for Ordinary Differential Equations.\n-\n+ *\n  * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n  * is the following one :\n  * <pre>\n  *       | 1/8  3/8  3/8  1/8\n  * </pre>\n  * </p>\n-\n+ *\n  * @see EulerIntegrator\n  * @see ClassicalRungeKuttaIntegrator\n  * @see GillIntegrator\n  * @see MidpointIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class ThreeEighthesIntegrator\n--- a/src/java/org/apache/commons/math/ode/ThreeEighthesStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/ThreeEighthesStepInterpolator.java\n /**\n  * This class implements a step interpolator for the 3/8 fourth\n  * order Runge-Kutta integrator.\n-\n+ *\n  * <p>This interpolator allows to compute dense output inside the last\n  * step computed. The interpolation equation is consistent with the\n  * integration scheme :\n-\n+ *\n  * <pre>\n  *   y(t_n + theta h) = y (t_n + h)\n  *                    - (1 - theta) (h/8) [ (1 - 7 theta + 8 theta^2) y'_1\n  *                                      +   (1 +   theta + 4 theta^2) y'_4\n  *                                        ]\n  * </pre>\n-\n+ *\n  * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n  * evaluations of the derivatives already computed during the\n  * step.</p>\n-\n+ *\n  * @see ThreeEighthesIntegrator\n-\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n class ThreeEighthesStepInterpolator\n--- a/src/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n+++ b/src/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n \n /** This interface specifies how to check if a {@link\n  * DirectSearchOptimizer direct search method} has converged.\n-\n+ *\n  * <p>Deciding if convergence has been reached is a problem-dependent\n  * issue. The user should provide a class implementing this interface\n  * to allow the optimization algorithm to stop its search according to\n  * the problem at hand.</p>\n-\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public interface ConvergenceChecker {\n--- a/src/java/org/apache/commons/math/optimization/CostException.java\n+++ b/src/java/org/apache/commons/math/optimization/CostException.java\n \n import org.apache.commons.math.MathException;\n \n-/** This class represents exceptions thrown by cost functions.\n-\n+/** \n+ * This class represents exceptions thrown by cost functions.\n+ *\n  * @version $Revision$ $Date$\n-\n+ * @since 1.2\n  */\n \n public class CostException\n--- a/src/java/org/apache/commons/math/optimization/CostFunction.java\n+++ b/src/java/org/apache/commons/math/optimization/CostFunction.java\n \n package org.apache.commons.math.optimization;\n \n-/** This interface represents a cost function to be minimized.\n+/** \n+ * This interface represents a cost function to be minimized.\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public interface CostFunction {\n \n \n-  /** Compute the cost associated to the given parameters array.\n+  /** \n+   * Compute the cost associated to the given parameters array.\n    * @param x parameters array\n    * @return cost associated to the parameters array\n    * @exception CostException if no cost can be computed for the parameters\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n import org.apache.commons.math.stat.descriptive.moment.VectorialMean;\n \n-/** This class implements simplex-based direct search optimization\n+/** \n+ * This class implements simplex-based direct search optimization\n  * algorithms.\n-\n+ *\n  * <p>Direct search methods only use cost function values, they don't\n  * need derivatives and don't either try to compute approximation of\n  * the derivatives. According to a 1996 paper by Margaret H. Wright\n  * <em>not too bad</em> point is desired. In the latter cases, an\n  * optimum is desired but cannot be reasonably found. In all cases\n  * direct search methods can be useful.</p>\n-\n+ *\n  * <p>Simplex-based direct search methods are based on comparison of\n  * the cost function values at the vertices of a simplex (which is a\n  * set of n+1 points in dimension n) that is updated by the algorithms\n  * steps.</p>\n-\n+ *\n  * <p>Minimization can be attempted either in single-start or in\n  * multi-start mode. Multi-start is a traditional way to try to avoid\n  * being trapped in a local minimum and miss the global minimum of a\n  * minima from all starts (including the one already provided by the\n  * {@link #minimizes(CostFunction, int, ConvergenceChecker, double[],\n  * double[]) minimizes} method).</p>\n-\n+ *\n  * <p>This class is the base class performing the boilerplate simplex\n  * initialization and handling. The simplex update by itself is\n  * performed by the derived classes according to the implemented\n  * algorithms.</p>\n-\n- * @version $Revision$ $Date$\n+ *\n  * @see CostFunction\n  * @see NelderMead\n  * @see MultiDirectional\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public abstract class DirectSearchOptimizer {\n \n--- a/src/java/org/apache/commons/math/optimization/MultiDirectional.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiDirectional.java\n \n package org.apache.commons.math.optimization;\n \n-/** This class implements the multi-directional direct search method.\n-\n+/** \n+ * This class implements the multi-directional direct search method.\n+ *\n  * @version $Revision$ $Date$\n  * @see NelderMead\n+ * @since 1.2\n  */\n public class MultiDirectional\n   extends DirectSearchOptimizer {\n--- a/src/java/org/apache/commons/math/optimization/NelderMead.java\n+++ b/src/java/org/apache/commons/math/optimization/NelderMead.java\n \n package org.apache.commons.math.optimization;\n \n-/** This class implements the Nelder-Mead direct search method.\n-\n+/** \n+ * This class implements the Nelder-Mead direct search method.\n+ *\n  * @version $Revision$ $Date$\n  * @see MultiDirectional\n+ * @since 1.2\n  */\n public class NelderMead\n   extends DirectSearchOptimizer {\n--- a/src/java/org/apache/commons/math/optimization/PointCostPair.java\n+++ b/src/java/org/apache/commons/math/optimization/PointCostPair.java\n \n package org.apache.commons.math.optimization;\n \n-/** This class holds a point and its associated cost.\n+/** \n+ * This class holds a point and its associated cost.\n  * <p>This is a simple immutable container.</p>\n  * @version $Revision$ $Date$\n  * @see CostFunction\n+ * @since 1.2\n  */\n public class PointCostPair {\n \n--- a/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n  * uncorrelated random vector that is needed to compute the component\n  * of the correlated vector. This class handles this situation\n  * automatically.</p>\n-\n- * @version $Revision:$ $Date$\n-\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n \n public class CorrelatedRandomVectorGenerator\n--- a/src/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n \n package org.apache.commons.math.random;\n \n-/** This class is a gaussian normalized random generator for scalars.\n+/** \n+ * This class is a gaussian normalized random generator for scalars.\n  * <p>This class is a simple wrapper around the {@link\n  * RandomGenerator#nextGaussian} method.</p>\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n \n public class GaussianRandomGenerator implements NormalizedRandomGenerator {\n--- a/src/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n \n package org.apache.commons.math.random;\n \n-/** This interface represent a normalized random generator for\n+/** \n+ * This interface represent a normalized random generator for\n  * scalars.\n  * Normalized generator provide null mean and unit standard deviation scalars.\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public interface NormalizedRandomGenerator {\n \n--- a/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n  * distributions, with parameters supplied in the constructor.\n  * \n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n \n public class UncorrelatedRandomVectorGenerator\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n \n     /**\n      * @param meanImpl the meanImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setMeanImpl(UnivariateStatistic meanImpl) {\n         this.meanImpl = meanImpl;\n \n     /**\n      * @return the geometricMeanImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getGeometricMeanImpl() {\n         return geometricMeanImpl;\n \n     /**\n      * @param geometricMeanImpl the geometricMeanImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setGeometricMeanImpl(\n             UnivariateStatistic geometricMeanImpl) {\n \n     /**\n      * @return the kurtosisImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getKurtosisImpl() {\n         return kurtosisImpl;\n \n     /**\n      * @param kurtosisImpl the kurtosisImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setKurtosisImpl(UnivariateStatistic kurtosisImpl) {\n         this.kurtosisImpl = kurtosisImpl;\n \n     /**\n      * @return the maxImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getMaxImpl() {\n         return maxImpl;\n \n     /**\n      * @param maxImpl the maxImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setMaxImpl(UnivariateStatistic maxImpl) {\n         this.maxImpl = maxImpl;\n \n     /**\n      * @return the minImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getMinImpl() {\n         return minImpl;\n \n     /**\n      * @param minImpl the minImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setMinImpl(UnivariateStatistic minImpl) {\n         this.minImpl = minImpl;\n \n     /**\n      * @return the percentileImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getPercentileImpl() {\n         return percentileImpl;\n      * @param percentileImpl the percentileImpl to set\n      * @throws IllegalArgumentException if the supplied implementation does not\n      *  provide a <code>setQuantile</code> method\n+     * @since 1.2\n      */\n     public synchronized void setPercentileImpl(\n             UnivariateStatistic percentileImpl) {\n \n     /**\n      * @return the skewnessImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getSkewnessImpl() {\n         return skewnessImpl;\n \n     /**\n      * @param skewnessImpl the skewnessImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setSkewnessImpl(\n             UnivariateStatistic skewnessImpl) {\n \n     /**\n      * @return the varianceImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getVarianceImpl() {\n         return varianceImpl;\n \n     /**\n      * @param varianceImpl the varianceImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setVarianceImpl(\n             UnivariateStatistic varianceImpl) {\n \n     /**\n      * @return the sumsqImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getSumsqImpl() {\n         return sumsqImpl;\n \n     /**\n      * @param sumsqImpl the sumsqImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setSumsqImpl(UnivariateStatistic sumsqImpl) {\n         this.sumsqImpl = sumsqImpl;\n \n     /**\n      * @return the sumImpl\n+     * @since 1.2\n      */\n     public synchronized UnivariateStatistic getSumImpl() {\n         return sumImpl;\n \n     /**\n      * @param sumImpl the sumImpl to set\n+     * @since 1.2\n      */\n     public synchronized void setSumImpl(UnivariateStatistic sumImpl) {\n         this.sumImpl = sumImpl;\n--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n      * <p>\n      *  Double.NaN is returned if no values have been added.</p>\n      *\n-     * @return the sum of logs  \n+     * @return the sum of logs\n+     * @since 1.2\n      */\n     public double getSumOfLogs() {\n         return sumLogImpl.getResult();\n      * summary statistics from values that\n      * have been added.\n      * @return String with line feeds displaying statistics\n+     * @since 1.2\n      */\n     public String toString() {\n         StringBuffer outBuffer = new StringBuffer();\n      * Returns the currently configured Sum implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the sum\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getSumImpl() {\n         return sumImpl;\n      * for computing the Sum\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n         checkEmpty();\n      * Returns the currently configured sum of squares implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the sum of squares\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getSumsqImpl() {\n         return sumsqImpl;\n      * for computing the sum of squares\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setSumsqImpl(\n             StorelessUnivariateStatistic sumsqImpl) {\n      * Returns the currently configured minimum implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the minimum\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getMinImpl() {\n         return minImpl;\n      * for computing the minimum\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setMinImpl(StorelessUnivariateStatistic minImpl) {\n         checkEmpty();\n      * Returns the currently configured maximum implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the maximum\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getMaxImpl() {\n         return maxImpl;\n      * for computing the maximum\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n         checkEmpty();\n      * Returns the currently configured sum of logs implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the log sum\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getSumLogImpl() {\n         return sumLogImpl;\n      * for computing the log sum\n      * @throws IllegalStateException if data has already been added \n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setSumLogImpl(\n             StorelessUnivariateStatistic sumLogImpl) {\n      * Returns the currently configured geometric mean implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the geometric mean\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getGeoMeanImpl() {\n         return geoMeanImpl;\n      * for computing the geometric mean\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setGeoMeanImpl(\n             StorelessUnivariateStatistic geoMeanImpl) {\n      * Returns the currently configured mean implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the mean\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getMeanImpl() {\n         return meanImpl;\n      * for computing the mean\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setMeanImpl(\n             StorelessUnivariateStatistic meanImpl) {\n      * Returns the currently configured variance implementation\n      * \n      * @return the StorelessUnivariateStatistic implementing the variance\n+     * @since 1.2\n      */\n     public StorelessUnivariateStatistic getVarianceImpl() {\n         return varianceImpl;\n      * for computing the variance\n      * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n+     * @since 1.2\n      */\n     public void setVarianceImpl(\n             StorelessUnivariateStatistic varianceImpl) {\n--- a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n      * @param observed2 array of observed frequency counts of the second data set\n      * @return chi-square test statistic\n      * @throws IllegalArgumentException if preconditions are not met\n+     * @since 1.2\n      */\n     public double chiSquareDataSetsComparison(long[] observed1, long[] observed2)\n         throws IllegalArgumentException {\n      * @return p-value\n      * @throws IllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs computing the p-value\n+     * @since 1.2\n      */\n     public double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)\n         throws IllegalArgumentException, MathException {\n      * 1 - alpha\n      * @throws IllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs performing the test\n+     * @since 1.2\n      */\n     public boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,\n             double alpha) throws IllegalArgumentException, MathException {\n--- a/src/java/org/apache/commons/math/stat/inference/UnknownDistributionChiSquareTest.java\n+++ b/src/java/org/apache/commons/math/stat/inference/UnknownDistributionChiSquareTest.java\n  * <p>Two samples tests are used when the distribution is unknown <i>a priori</i>\n  * but provided by one sample. We compare the second sample against the first.</p>\n  *\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n+ * @since 1.2 \n  */\n public interface UnknownDistributionChiSquareTest extends ChiSquareTest {\n      \n--- a/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  * function transformation on how this affects the sampling.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class FastCosineTransformer implements Serializable {\n \n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n  * 32 (1978), 175 - 199.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class FastFourierTransformer implements Serializable {\n \n--- a/src/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastSineTransformer.java\n  * transformation after sampling.</p>\n  *\n  * @version $Revision$ $Date$\n+ * @since 1.2\n  */\n public class FastSineTransformer implements Serializable {\n \n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n      * and equal elements\n+     * @since 1.2\n      */\n     public static boolean equals(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n      * \n      * @param value the value to be hashed (may be null)\n      * @return the hash code\n+     * @since 1.2\n      */\n     public static int hash(double[] value) {\n         if (value == null) {\n      * @param base the base of the logarithm, must be greater than 0\n      * @param x argument, must be greater than 0\n      * @return the value of the logarithm - the number y such that base^y = x.\n+     * @since 1.2\n      */ \n     public static double log(double base, double x) {\n         return Math.log(x)/Math.log(base);\n      * @param direction (the only important thing is whether\n      * direction is greater or smaller than d)\n      * @return the next machine representable number in the specified direction\n+     * @since 1.2\n      */\n     public static double nextAfter(double d, double direction) {\n \n      * @param a angle to normalize\n      * @param center center of the desired 2&pi; interval for the result\n      * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n+     * @since 1.2\n      */\n      public static double normalizeAngle(double a, double center) {\n          return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);", "timestamp": 1202671739, "metainfo": ""}